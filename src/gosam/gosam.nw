% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: GoSam interface

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{GoSam Interface}

The code in this chapter makes amplitudes accessible to \whizard\ that
are generated and computed by the GoSam package.

These are the modules:
\begin{description}
\item[loop\_archive]
  Provide some useful extra functionality.
\item[prc\_gosam]
  The actual interface, following the \whizard\ conventions for
  matrix-element generator methods.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Save previously generated loop libraries}
<<[[loop_archive.f90]]>>=
<<File header>>

module loop_archive

  use io_units
<<Use strings>>
  use diagnostics
  use os_interface

<<Loop archive: public>>

<<Loop archive: types>>

contains

<<Loop archive: procedures>>

end module loop_archive
@ %def loop_archive
@ 
<<Loop archive: public>>=
  public :: loop_archive_t
<<Loop archive: types>>=
  type :: loop_archive_t
    logical :: active = .false.
    type(string_t) :: name
    type(string_t) :: current_prefix
    type(os_data_t) :: os_data
  contains
  <<Loop archive: loop archive: TBP>>
  end type loop_archive_t

@ %def loop_archive_t
@
<<Loop archive: loop archive: TBP>>=
  procedure :: activate => loop_archive_activate
<<Loop archive: procedures>>=
  subroutine loop_archive_activate (archive, name, os_data)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: name
    type(os_data_t), intent(in) :: os_data
    integer :: status, success
    type(string_t) :: prefix
    archive%name = name
    archive%os_data = os_data
    call os_system_call ('test -d "' // name // &
                         '"', status = status, verbose = .true.)
    if (status /= 0) then
      call os_system_call ('mkdir ' // name, &
                            status = success, verbose = .true.)
      if (success /= 0) call msg_fatal ("Creation of loop archive failed!")
    end if
    archive%active = .true.
  end subroutine loop_archive_activate

@ %def loop_archive_activate
@
<<Loop archive: loop archive: TBP>>=
  procedure :: record => loop_archive_record
<<Loop archive: procedures>>=
  subroutine loop_archive_record (archive, olp_file, olc_file, config_file, lib)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_file, olc_file, config_file, lib
    type(string_t) :: current_prefix
    type(string_t) :: filename
    
    ! Copy, rename and move olp-file and olc-file
    filename = archive%current_prefix // '.olp'
    call os_system_call ('cp ' // olp_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
    filename = archive%current_prefix // '.olc'
    call os_system_call ('cp ' // olc_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // & 
       archive%name)
    ! Do the same with the loop-library and the config file
    filename = archive%current_prefix // '_libgolem_olp.' // &
       archive%os_data%shrlib_ext
    call os_system_call ('cp ' // lib // ' ' // filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
    filename = archive%current_prefix // '_golem.in'
    call os_system_call ('cp ' // config_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
  end subroutine loop_archive_record

@ %def loop_archive_record
@
<<Loop archive: loop archive: TBP>>=
  procedure :: search => loop_archive_search
<<Loop archive: procedures>>=
  subroutine loop_archive_search (archive, files, found)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), dimension(3), intent(in) :: files
    logical, intent(out) :: found
    type(string_t) :: current_olp, current_config, current_lib
    character(len=3) :: prefix
    integer :: counter
    logical, dimension(2) :: exist
    integer, dimension(2) :: identical
    integer :: i

    counter = 1
    do
       write(prefix,"(A,I2.2)") 'V', counter
       current_olp = archive%name // '/' // var_str (prefix) // '.olp'
       current_config = archive%name // '/' // var_str (prefix) // '_golem.in'
       current_lib = archive%name // '/' // var_str (prefix) // &
            '_libgolem_olp.' // archive%os_data%shrlib_ext
       inquire (file = char (current_olp), exist = exist(1))
       inquire (file = char (current_config), exist = exist(2))
       if (all (exist)) then
          call os_system_call ('diff ' // current_olp // ' ' // files(1) // &
                               ' > /dev/null', status=identical(1))
          call os_system_call ('diff ' // current_config // ' ' // files(2) // &
                               ' > /dev/null', status=identical(2))
            if (all (identical == 0)) then
               found = .true.
               exit
            else
               counter = counter+1
            end if
       else
          found = .false.
          exit
       end if
       if (counter >= 100) call msg_fatal ("Maximum number of loop-libraries exceeded!")
    end do
    write(prefix,"(A,I2.2)") 'V', counter
    archive%current_prefix = var_str (prefix)    
  end subroutine loop_archive_search

@ %def loop_archive_searc
@
<<Loop archive: loop archive: TBP>>=
  procedure :: restore => loop_archive_restore
<<Loop archive: procedures>>=
  subroutine loop_archive_restore (archive, olp_orig, olc_orig, path)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_orig, olc_orig, path
    type(string_t) :: olp_file, olc_file, config_file, lib
    
    olp_file = archive%current_prefix // '.olp'
    olc_file = archive%current_prefix // '.olc'
    config_file = archive%current_prefix // '_golem.in'
    lib = archive%current_prefix // '_libgolem_olp.' // &
         archive%os_data%shrlib_ext

    call os_system_call ('cp ' // archive%name // '/' // olp_file // ' .')
    call os_system_call ('mv ' // olp_file // ' ' // olp_orig)

    call os_system_call ('cp ' // archive%name // '/' // olc_file // ' .')
    call os_system_call ('mv ' // olc_file // ' ' // olc_orig)
   
    call os_system_call ('cp ' // archive%name // '/' // config_file // ' .')
    call os_system_call ('mv ' // config_file // ' golem.in')

    call os_system_call ('cp ' // archive%name // '/' // lib // ' .')
    call os_system_call ('mv ' // lib // ' libgolem_olp.' // &
         archive%os_data%shrlib_ext)
    call os_system_call ('mv libgolem_olp.' // archive%os_data%shrlib_ext &
         // ' ' // path // '/.libs')
    
  end subroutine loop_archive_restore

@ %def loop_archive_restore
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gosam Interface}
<<[[prc_gosam.f90]]>>=
<<File header>>

module prc_gosam
  
  use, intrinsic :: iso_c_binding !NODEP!
  use, intrinsic :: iso_fortran_env

  use kinds
<<Use strings>>  
  use io_units
  use constants
  use system_defs, only: TAB
  use system_dependencies
  use file_utils
  use string_utils
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use interactions
  use pdg_arrays
  use sm_qcd
  use flavors
  use model_data
  
  use process_constants
  use prclib_interfaces
  use process_libraries
  use prc_core_def
  use prc_core

  use blha_config
  use loop_archive

<<Standard module head>>

<<prc gosam: constants>>

<<prc gosam: public>>

<<prc gosam: types>>

<<prc gosam: interfaces>>

contains

<<prc gosam: procedures>>

end module prc_gosam

@ 
@ %def module prc_gosam

<<prc gosam: constants>>=
  character(10), dimension(5), parameter ::  &
             lib_suffix = [character(10) :: &
             '.a', '.la', '.so', '.so.0', '.so.0.0.0']

@ The GoSam interface requires the momentum and result array to be of a fixed length.
<<prc gosam: constants>>=
  integer, parameter :: GOSAM_PARAMETER_LIMIT = 10
  integer, parameter :: GOSAM_MOMENTUM_LIMIT = 50
  integer, parameter :: GOSAM_RESULTS_LIMIT = 60

@ 
<<prc gosam: constants>>=
  integer, parameter :: Q_TO_QG = 1
  integer, parameter :: G_TO_GG = 2
  integer, parameter :: G_TO_QQ = 3

@
<<prc gosam: public>>=
  public :: gosam_writer_t
<<prc gosam: types>>=
  type, extends (prc_writer_f_module_t) :: gosam_writer_t
    type(string_t) :: gosam_dir
    type(string_t) :: golem_dir
    type(string_t) :: samurai_dir
    type(string_t) :: ninja_dir
    type(string_t) :: form_dir
    type(string_t) :: qgraf_dir
    type(blha_configuration_t) :: blha_cfg
    type(string_t) :: model_name
    type(string_t) :: process_mode
    type(string_t) :: process_string
  contains
  <<prc gosam: gosam writer: TBP>>
  end type gosam_writer_t

@ 
@ %def gosam_writer_t

<<prc gosam: public>>=
  public :: gosam_def_t
<<prc gosam: types>>=
  type, extends (prc_core_def_t) :: gosam_def_t
    type(string_t) :: basename
    type(string_t) :: suffix
    logical :: execute_olp = .true.
  contains
  <<prc gosam: gosam def: TBP>>
  end type gosam_def_t

@ 
@ %def gosam_def_t
<<prc gosam: types>>=
  type, extends (prc_core_driver_t) :: gosam_driver_t 
    type(string_t) :: gosam_dir
    type(string_t) :: olp_file
    type(string_t) :: olc_file
    type(string_t) :: olp_dir
    type(string_t) :: olp_lib
    type(loop_archive_t) :: loop_archive
    procedure(olp_start),nopass,  pointer :: &
              gosam_olp_start => null ()
    procedure(olp_eval), nopass, pointer :: &
              gosam_olp_eval => null()
    procedure(olp_info), nopass, pointer :: &
              gosam_olp_info => null ()
    procedure(olp_set_parameter), nopass, pointer :: &
              gosam_olp_set_parameter => null ()
    procedure(olp_eval2), nopass, pointer :: &
              gosam_olp_eval2 => null ()
    procedure(olp_option), nopass, pointer :: &
              gosam_olp_option => null ()
    procedure(olp_polvec), nopass, pointer :: &
              gosam_olp_polvec => null ()
    procedure(olp_finalize), nopass, pointer :: &
              gosam_olp_finalize => null ()
    procedure(olp_print_parameter), nopass, pointer :: &
              gosam_olp_print_parameter => null ()
@ We have to add two O'Mega-routines to the GoSam driver to ensure
  proper process setup.
<<prc gosam: types>>=
    procedure(omega_update_alpha_s), nopass, pointer :: &
              update_alpha_s => null ()
    procedure(omega_is_allowed), nopass, pointer :: &
              is_allowed => null ()

  contains
  <<prc gosam: gosam driver: TBP>>
  end type gosam_driver_t

@ 
@ %def gosam_driver_t
<<prc gosam: public>>=
  public :: prc_gosam_t
<<prc gosam: types>>=
  type, extends (prc_core_t) :: prc_gosam_t
    type(qcd_t) :: qcd
    integer :: n_flv
    real(default) :: maximum_accuracy = 10000.0
    logical :: initialized = .false.
    integer, dimension(:), allocatable :: i_born, i_sc, i_cc
    integer, dimension(:), allocatable :: i_real
    integer, dimension(:), allocatable :: i_virt
  contains
  <<prc gosam: prc gosam: TBP>>
  end type prc_gosam_t

@ 
@ %def prc_gosam_t
<<prc gosam: types>>=
  type, extends (prc_core_state_t) :: gosam_state_t
    logical :: new_kinematics = .true.
    real(default) :: alpha_qcd = -1
  contains
  <<prc gosam: gosam state: TBP>>
  end type gosam_state_t

@ %def gosam_state_t
@
<<prc gosam: interfaces>>=
  interface 
    subroutine olp_start (contract_file_name, ierr) bind (C,name="OLP_Start")
      import
      character(kind=c_char, len=1), intent(in) :: contract_file_name
      integer(kind=c_int), intent(out) :: ierr
    end subroutine olp_start
  end interface

@ %def olp_start_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_eval (label, momenta, mu, parameters, res) &
         bind (C,name="OLP_EvalSubProcess")
      import
      integer(kind=c_int), value, intent(in) :: label
      real(kind=c_double), value, intent(in) :: mu
      real(kind=c_double), dimension(GOSAM_MOMENTUM_LIMIT), intent(in) :: &
           momenta
      real(kind=c_double), dimension(GOSAM_PARAMETER_LIMIT), intent(in) :: &
           parameters
      real(kind=c_double), dimension(GOSAM_RESULTS_LIMIT), intent(out) :: res
    end subroutine olp_eval
  end interface

@ %def olp_eval interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_info (olp_file, olp_version, message) bind(C)
      import
      character(kind=c_char), intent(inout), dimension(15) :: olp_file
      character(kind=c_char), intent(inout), dimension(15) :: olp_version
      character(kind=c_char), intent(inout), dimension(255) :: message
    end subroutine olp_info
  end interface

@ %def olp_info interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_set_parameter &
         (variable_name, real_part, complex_part, success) bind(C)
      import
      character(kind=c_char,len=1), intent(in) :: variable_name
      real(kind=c_double), intent(in) :: real_part, complex_part
      integer(kind=c_int), intent(out) :: success
    end subroutine olp_set_parameter
  end interface

@ %def olp_set_parameter_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_eval2 (label, momenta, mu, res, acc) bind(C)
      import
      integer(kind=c_int), intent(in) :: label
      real(kind=c_double), intent(in) :: mu
      real(kind=c_double), dimension(GOSAM_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(GOSAM_RESULTS_LIMIT), intent(out) :: res
      real(kind=c_double), intent(out) :: acc
    end subroutine olp_eval2
  end interface

@ %def olp_eval2_interface
@
<<prc gosam: interfaces>>=
  abstract interface
     subroutine omega_update_alpha_s (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine omega_update_alpha_s
  end interface
  
  abstract interface
     subroutine omega_is_allowed (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine omega_is_allowed
  end interface

@ %def omega-interfaces
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_option (line, stat) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: line
      integer(kind=c_int), intent(out) :: stat
    end subroutine
  end interface

@ %def olp_option_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_polvec (p, q, eps) bind(C)
      import
      real(kind=c_double), dimension(0:3), intent(in) :: p, q
      real(kind=c_double), dimension(0:7), intent(out) :: eps
    end subroutine
  end interface

@ %def olp_polvec_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_finalize () bind(C)
      import
    end subroutine olp_finalize
  end interface

@ %def olp_finalize_interface
@
<<prc gosam: interfaces>>=
  interface
    subroutine olp_print_parameter (filename) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: filename
    end subroutine olp_print_parameter
  end interface

@ %def olp_print_parameter_interface
@
<<prc gosam: gosam def: TBP>>=
  procedure :: init => gosam_def_init
<<prc gosam: procedures>>=
  subroutine gosam_def_init (object, basename, model_name, &
                             prt_in, prt_out, nlo_type)
    class(gosam_def_t), intent(inout) :: object
    type(string_t), intent(in) :: model_name
    type(string_t), intent(in) :: basename
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer, intent(in) :: nlo_type
    object%basename = basename
    allocate (gosam_writer_t :: object%writer)
    select case (nlo_type)
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    end select
    select type (writer => object%writer)
    type is (gosam_writer_t)
      call writer%init (model_name, prt_in, prt_out)
    end select
  end subroutine gosam_def_init

@ %def gosam_def_init
@
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: needs_code => gosam_def_needs_code
<<prc gosam: procedures>>=
  function gosam_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function gosam_def_needs_code

@  %def gosam_def_needs_code
@
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: type_string => gosam_def_type_string
<<prc gosam: procedures>>=
  function gosam_def_type_string () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_def_type_string

@ 
@ %def gosam_def_type_string
<<prc gosam: gosam def: TBP>>=
  procedure :: write => gosam_def_write
<<prc gosam: procedures>>=
  subroutine gosam_def_write (object, unit)
    class(gosam_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (gosam_writer_t)
      call writer%write (unit)
    end select
  end subroutine gosam_def_write

@ 
@ %def gosam_def_write
<<prc gosam: gosam def: TBP>>=
  procedure :: read => gosam_def_read
<<prc gosam: procedures>>=
  subroutine gosam_def_read (object, unit)
    class(gosam_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug ("GoSam process definition: input not supported yet")
  end subroutine gosam_def_read


@ %def gosam_def_read
@
<<prc gosam: gosam def: TBP>>=
  procedure :: allocate_driver => gosam_def_allocate_driver
<<prc gosam: procedures>>=
  subroutine gosam_def_allocate_driver (object, driver, basename)
    class(gosam_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (gosam_driver_t :: driver)
  end subroutine gosam_def_allocate_driver

@
@ %def gosam_def_allocate_driver
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: get_features => gosam_def_get_features
<<prc gosam: procedures>>=
  subroutine gosam_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine gosam_def_get_features 

@
@ %def gosam_def_get_features
<<prc gosam: gosam def: TBP>>=
  procedure :: connect => gosam_def_connect
<<prc gosam: procedures>>=
  subroutine gosam_def_connect (def, lib_driver, i, proc_driver)   
    class(gosam_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    integer :: pid, fid
    class(prc_core_driver_t), intent(inout) :: proc_driver
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is (gosam_driver_t)       
       pid = i
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
    end select
  end subroutine gosam_def_connect

@ 
@ %def gosam_def_connect
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_wrapper => gosam_write_wrapper
<<prc gosam: procedures>>=
  subroutine gosam_write_wrapper (writer, unit, id, feature)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature    
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select

  end subroutine gosam_write_wrapper

@
@ %def gosam_write_wrapper
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_interface => gosam_write_interface
<<prc gosam: procedures>>= 
  subroutine gosam_write_interface (writer, unit, id, feature)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine gosam_write_interface

@
@ %def gosam_write_interface
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_source_code => gosam_write_source_code
<<prc gosam: procedures>>=
  subroutine gosam_write_source_code (writer, id)
    class(gosam_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine gosam_write_source_code

@ 
@ %def gosam_write_source_code
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_makefile_code => gosam_write_makefile_code
<<prc gosam: procedures>>=
  subroutine gosam_write_makefile_code (writer, unit, id, os_data, testflag)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    omega_binary = "omega_" // writer%model_name // ".opt"
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".f90:"
    write (unit, "(99A)")  TAB, char (omega_path), &
         " -o ", char (id), ".f90", &
         " -target:whizard", &
         " -target:parameter_module parameters_", char (writer%model_name), &
         " -target:module opr_", char (id), &
         " -target:md5sum '", writer%md5sum, "'", &
         char (writer%process_mode), char (writer%process_string)
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"    
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"       
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"

  end subroutine gosam_write_makefile_code

@
@ %def gosam_write_makefile_code
<<prc gosam: gosam writer: TBP>>=
  procedure, nopass:: get_procname => gosam_writer_get_procname
<<prc gosam: procedures>>=
  function gosam_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function gosam_writer_get_procname

@ %def gosam_writer_get_procname
@ 
<<prc gosam: gosam writer: TBP>>=
  procedure, nopass :: get_module_name => gosam_writer_get_module_name
<<prc gosam: procedures>>=
  function gosam_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function gosam_writer_get_module_name

@ %def gosam_writer_get_module_name
@
<<prc gosam: gosam writer: TBP>>=
  procedure, nopass :: type_name => gosam_writer_type_name
<<prc gosam: procedures>>=
  function gosam_writer_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_writer_type_name

@
@ %def gosam_writer_type_name
<<prc gosam: gosam writer: TBP>>=
  procedure :: write => gosam_writer_write
<<prc gosam: procedures>>=
  subroutine gosam_writer_write (writer, unit)
    class(gosam_writer_t), intent(in) :: writer
    integer, intent(in) :: unit    
    write (unit, "(1x,A)")  char (writer%get_process_string ())
  end subroutine gosam_writer_write

@
@ %def gosam_writer_write
<<prc gosam: gosam writer: TBP>>=
  procedure :: init => gosam_writer_init
<<prc gosam: procedures>>=
  subroutine gosam_writer_init (writer,model_name, prt_in, prt_out) 
    class(gosam_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer :: i, unit

    writer%gosam_dir = GOSAM_DIR
    writer%golem_dir = GOLEM_DIR 
    writer%samurai_dir = SAMURAI_DIR
    writer%ninja_dir = NINJA_DIR
    writer%form_dir = FORM_DIR
    writer%qgraf_dir = QGRAF_DIR

    writer%model_name = model_name

    select case (size (prt_in))
      case (1); writer%process_mode = " -decay"
      case (2); writer%process_mode = " -scatter"
    end select
    associate (s => writer%process_string)
      s = " '" 
      do i = 1, size (prt_in)
         if (i > 1) s = s // " "
         s = s // prt_in(i)
      end do
      s = s // " ->"
      do i = 1, size (prt_out)
         s = s // " " // prt_out(i)
      end do
      s = s // "'"
    end associate

    unit = free_unit ()
    open (unit, file = "golem.in", status = "replace", action = "write")
    call writer%generate_configuration_file (unit)
    close(unit)
  end subroutine gosam_writer_init  

@ %def gosam_writer_init
@
<<prc gosam: gosam driver: TBP>>=
  procedure, nopass :: type_name => gosam_driver_type_name
<<prc gosam: procedures>>=
  function gosam_driver_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_driver_type_name

@ 
@ %def gosam_driver_type_name
<<prc gosam: gosam driver: TBP>>=
  procedure :: init_gosam => gosam_driver_init_gosam
<<prc gosam: procedures>>=
  subroutine gosam_driver_init_gosam (object, os_data, olp_file, &
                                olc_file, olp_dir, olp_lib)
    class(gosam_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: olp_file, olc_file, olp_dir, olp_lib
    object%gosam_dir = GOSAM_DIR
    object%olp_file = olp_file
    object%olc_file = olc_file
    object%olp_dir = olp_dir
    object%olp_lib = olp_lib
    call object%loop_archive%activate (var_str ('Generated_Loops'), os_data)
  end subroutine gosam_driver_init_gosam

@ %def gosam_driver_init
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: generate_configuration_file => &
            gosam_writer_generate_configuration_file
<<prc gosam: procedures>>=
  subroutine gosam_writer_generate_configuration_file &
          (object, unit)
      class(gosam_writer_t), intent(in) :: object
      integer, intent(in) :: unit
      type(string_t) :: fc_bin
      type(string_t) :: form_bin, qgraf_bin, haggies_bin
      type(string_t) :: fcflags_golem, ldflags_golem
      type(string_t) :: fcflags_samurai, ldflags_samurai
      type(string_t) :: fcflags_ninja, ldflags_ninja
      type(string_t) :: ldflags_avh_olo, ldflags_qcdloop
      fc_bin = DEFAULT_FC
      form_bin = object%form_dir // '/bin/tform'
      qgraf_bin = object%qgraf_dir // '/bin/qgraf'
      if (object%gosam_dir /= "") then
        haggies_bin = '/usr/bin/java -jar ' // object%gosam_dir // &
                       '/share/golem/haggies/haggies.jar'
      else
        call msg_fatal ("generate_configuration_file: At least " // &
             "the GoSam Directory has to be specified!")
      end if
      if (object%golem_dir /= "") then
        fcflags_golem = "-I" // object%golem_dir // "/include/golem95"
        ldflags_golem = "-L" // object%golem_dir // "/lib -lgolem"
      end if
      if (object%samurai_dir /= "") then
        fcflags_samurai = "-I" // object%samurai_dir // "/include/samurai"
        ldflags_samurai = "-L" // object%samurai_dir // "/lib -lsamurai"
        ldflags_avh_olo = "-L" // object%samurai_dir // "/lib -lavh_olo"
        ldflags_qcdloop = "-L" // object%samurai_dir // "/lib -lqcdloop"
      end if
      if (object%ninja_dir /= "") then
        fcflags_ninja = "-I" // object%ninja_dir // "/include/ninja " &
                        // "-I" // object%ninja_dir // "/include"
        ldflags_ninja = "-L" // object%ninja_dir // "/lib -lninja"
      end if
      write (unit, "(A)") "+avh_olo.ldflags=" &
            // char (ldflags_avh_olo) 
      write (unit, "(A)") "reduction_programs=golem95, samurai, ninja"
      write (unit, "(A)") "extensions=autotools"
      write (unit, "(A)") "+qcdloop.ldflags=" &
            // char (ldflags_qcdloop)
      write (unit, "(A)") "+zzz.extensions=qcdloop, avh_olo"
      write (unit, "(A)") "fc.bin=" // char (fc_bin)
      write (unit, "(A)") "form.bin=" // char (form_bin)
      write (unit, "(A)") "qgraf.bin=" // char (qgraf_bin)
      write (unit, "(A)") "golem95.fcflags=" // char (fcflags_golem)
      write (unit, "(A)") "golem95.ldflags=" // char (ldflags_golem)
      write (unit, "(A)") "haggies.bin=" // char (haggies_bin)
      write (unit, "(A)") "samurai.fcflags=" // char (fcflags_samurai)
      write (unit, "(A)") "samurai.ldflags=" // char (ldflags_samurai)
      write (unit, "(A)") "ninja.fcflags=" // char (fcflags_ninja)
      write (unit, "(A)") "ninja.ldflags=" // char (ldflags_ninja)
      !!! This might collide with the mass-setup in the order-file
      !!! write (unit, "(A)") "zero=mU,mD,mC,mS,mB"
      write (unit, "(A)") "PSP_check=False"
      write (unit, "(A)") "filter.lo=lambda d: d.iprop(H) == 0 and d.iprop(chi) == 0"
      write (unit, "(A)") "filter.nlo=lambda d: d.iprop(H) == 0 and d.iprop(chi) == 0"
  end subroutine gosam_writer_generate_configuration_file

@ %def gosam_writer_generate_configuration_file
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: get_process_string => gosam_writer_get_process_string
<<prc gosam: procedures>>=
  function gosam_writer_get_process_string (writer) result (s_proc)
    class(gosam_writer_t), intent(in) :: writer
    type(string_t) :: s_proc
  end function gosam_writer_get_process_string

@ %def gosam_writer_get_process_string
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: get_n_proc => gosam_writer_get_n_proc
<<prc gosam: procedures>>=
  function gosam_writer_get_n_proc (writer) result (n_proc)
    class(gosam_writer_t), intent(in) :: writer
    integer :: n_proc
    n_proc = blha_configuration_get_n_proc (writer%blha_cfg)
  end function gosam_writer_get_n_proc

@ %def gosam_writer_get_n_proc
@ We have to assure that all files necessary for the configure process
in the GoSam code are ready. This is done with a stamp mechanism.
<<prc gosam: gosam driver: TBP>>=
  procedure :: write_makefile => gosam_driver_write_makefile
<<prc gosam: procedures>>=
  subroutine gosam_driver_write_makefile (object, unit, libname)
    class(gosam_driver_t), intent(in) :: object
    integer, intent(in) :: unit
    type(string_t), intent(in) :: libname
    write (unit, "(2A)")  "OLP_FILE = ", char (object%olp_file)
    write (unit, "(2A)")  "OLP_DIR = ", char (object%olp_dir)
    write (unit, "(A)")
    write (unit, "(A)")   "all: autogen"
    write (unit, "(4A)")   TAB, "make ", &
         char (object%loop_archive%os_data%makeflags), &
         " -C $(OLP_DIR) install"
    write (unit, "(A)")
    write (unit, "(3A)")   "autogen: ", char (libname)
    write (unit, "(3A)")  TAB, "cd $(OLP_DIR); ./autogen.sh --prefix=", &
         "$(dir $(abspath $(lastword $(MAKEFILE_LIST))))"
    write (unit, "(A)")
    write (unit, "(2A)")  char (libname), ":"
    write (unit, "(4A)")  TAB, char (object%gosam_dir // "/bin/gosam.py "), &
                             "--olp $(OLP_FILE) --destination=$(OLP_DIR)", &
                             " -f -z"
  end subroutine gosam_driver_write_makefile
@ %def gosam_driver_write_makefile
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_alpha_s => gosam_driver_set_alpha_s
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_alpha_s (driver, alpha_s)
     class(gosam_driver_t), intent(inout) :: driver
     real(default), intent(in) :: alpha_s
     integer :: ierr
     call driver%gosam_olp_set_parameter &
              (c_char_'alphaS'//c_null_char, &
               dble (alpha_s), 0._double, ierr)
  end subroutine gosam_driver_set_alpha_s

@ %def gosam_driver_set_alpha_s
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_mass_and_width => gosam_driver_set_mass_and_width
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_mass_and_width (driver, &
                                       i_pdg, mass, width)
    class(gosam_driver_t), intent(inout) :: driver
    integer, intent(in) :: i_pdg
    real(default), intent(in), optional :: mass
    real(default), intent(in), optional :: width
    type(string_t) :: buf
    character(kind=c_char,len=20) :: c_string
    integer :: ierr
    if (present (mass)) then
       buf = 'mass(' // integer_to_string (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%gosam_olp_set_parameter &
                (c_string, dble(mass), 0._double, ierr)
       if (ierr == 0) then
          buf = "GoSam: Attempt to set mass of particle " // &
                integer_to_string (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
    if (present (width)) then
       buf = 'width(' // integer_to_string (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%gosam_olp_set_parameter &
                (c_string, dble(width), 0._double, ierr)
       if (ierr == 0) then
          buf = "GoSam: Attempt to set width of particle " // &
                integer_to_string (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
  end subroutine gosam_driver_set_mass_and_width

@ %def gosam_driver_set_mass_and_width
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: load => gosam_driver_load
<<prc gosam: procedures>>=
  subroutine gosam_driver_load (object, os_data, store, success)
    class(gosam_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: store
    logical, intent(out) :: success
    type(dlaccess_t) :: dlaccess
    type(string_t) ::  path
    type(c_funptr) :: c_fptr

    path = object%olp_dir // '/.libs' 
    call dlaccess_init &
          (dlaccess, var_str ("."), path // '/libgolem_olp.' // &
          os_data%shrlib_ext, os_data)
    if (os_file_exist (path // '/libgolem_olp.' // &
         os_data%shrlib_ext)) then
       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Start"))
       call c_f_procpointer (c_fptr, object%gosam_olp_start)
       
       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess"))
       call c_f_procpointer (c_fptr, object%gosam_olp_eval)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Info"))
       call c_f_procpointer (c_fptr, object%gosam_olp_info)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_SetParameter"))
       call c_f_procpointer (c_fptr, object%gosam_olp_set_parameter)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess2"))
       call c_f_procpointer (c_fptr, object%gosam_olp_eval2)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Option"))
       call c_f_procpointer (c_fptr, object%gosam_olp_option)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Polvec"))
       call c_f_procpointer (c_fptr, object%gosam_olp_polvec)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Finalize"))
       call c_f_procpointer (c_fptr, object%gosam_olp_finalize)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_PrintParameter"))
       call c_f_procpointer (c_fptr, object%gosam_olp_print_parameter)

       success = .not. dlaccess_has_error (dlaccess)
       if (store .and. success) &
          call object%loop_archive%record (object%olp_file, object%olc_file, &
               var_str ('golem.in'), path // '/libgolem_olp.' // &
               os_data%shrlib_ext)
    else
       success = .false.
    end if
  end subroutine gosam_driver_load

@ %def gosam_driver_load
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: read_olc_file => gosam_driver_read_olc_file
<<prc gosam: procedures>>=
  subroutine gosam_driver_read_olc_file (driver, flavors, amp_type, flv_index, label)
    class(gosam_driver_t), intent(inout) :: driver
    integer, intent(in), dimension(:,:) :: flavors
    integer, intent(out), dimension(20) :: amp_type, flv_index, label
    integer :: unit, filestat
    character(len=100):: rd_line 
    logical :: read_flavor, born_found
    integer, dimension(:,:,:), allocatable :: flv_position
    integer, dimension(:,:), allocatable :: flv_read
    integer :: k, i_flv, i_part
    integer :: pos_label

    flv_position = compute_flavor_positions (flavors)
    amp_type = -1; flv_index = -1; label = -1
    allocate (flv_read (size (flavors, 1), &
                        size (flavors, 2)))
    unit = free_unit ()
    open (unit, file=char(driver%olc_file), status="old") 
    read_flavor=.false.
    k = 1
    do
      read (unit, '(A)', iostat = filestat) rd_line
      if (filestat == iostat_end) then
         exit
      else
         if (rd_line(1:13) == 'AmplitudeType') then
            if (rd_line(15:19) == 'Loop') then
               amp_type(k) = BLHA_AMP_LOOP
            else if (rd_line(15:19) == 'Tree') then
               amp_type(k) = BLHA_AMP_TREE
            else if (rd_line(15:21) == 'ccTree') then
               amp_type(k) = BLHA_AMP_CC
            else if (rd_line(15:21) == 'scTree') then
               amp_type(k) = BLHA_AMP_SC
            else
               call msg_fatal ("AmplitudeType present but &
                               &AmpType not known!")
            end if
            read_flavor = .true.
         else if (read_flavor) then
            do i_flv = 1, size (flavors, 2)
               do i_part = 1, size (flavors, 1)
                  read (rd_line (flv_position (i_part, i_flv, 1): &
                                 flv_position (i_part, i_flv, 2)), '(I3)') &
                                 flv_read (i_part, i_flv)
               end do
            end do
            born_found = .false.
            do i_flv = 1, size (flavors, 2)
               if (all (flv_read (:,i_flv) == flavors (:,i_flv))) then
                  flv_index (k) = i_flv
                  pos_label = maxval (flv_position (:,i_flv,:)) + 6
                  read (rd_line (pos_label:pos_label), '(I2)') label(k)
                  born_found = .true.
                  k = k+1
                  exit
               end if
            end do
            if (.not. born_found) call msg_fatal & 
                     ("No underlying Born found")
         end if   
      end if
    end do
    close(unit)
  contains
    function compute_flavor_positions (flavors) result (pos)
      integer, intent(in), dimension(:,:) :: flavors
      integer, dimension(:,:,:), allocatable :: pos
      integer :: i_flv, i_part
      integer :: i_first, i_last
      allocate (pos (size (flavors, 1), &
                     size (flavors, 2), 2))
      do i_flv = 1, size (flavors, 2)
         i_first = 1; i_last = 0
         do i_part = 1, size (flavors, 1)
            if (i_last > 0 .and. i_part /= 3) then
               i_first = i_last+2
            else if (i_last > 0 .and. i_part == 3) then
               i_first = i_first + 6
            end if
            i_last = i_first + flavor_digits (flavors (i_part, i_flv)) - 1
            pos (i_part, i_flv, 1) = i_first
            pos (i_part, i_flv, 2) = i_last
         end do
      end do
    end function compute_flavor_positions             
            
    function flavor_digits (flavor) result (ndigits)
      integer, intent(in) :: flavor
      integer :: ndigits
      if (abs(flavor) >= 10) then
         ndigits = 2
      else
         ndigits = 1
      end if
      if (flavor < 0) ndigits = ndigits+1
    end function flavor_digits
  end subroutine gosam_driver_read_olc_file

@ %def gosam_driver_read_olc_file
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: search_for_existing_library => &
                      prc_gosam_search_for_existing_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_search_for_existing_library (object, os_data, found)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: found
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%loop_archive%search ([driver%olp_file, &
            var_str ('golem.in'), driver%olp_dir // &
            '/.libs/libgolem_olp.' // os_data%shrlib_ext], found)
    end select
  end subroutine prc_gosam_search_for_existing_library

@ %def prc_gosam_search_for_exsting_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: write_makefile => prc_gosam_write_makefile
<<prc gosam: procedures>>=
  subroutine prc_gosam_write_makefile (object, unit, libname)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: unit
    type(string_t), intent(in) :: libname
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%write_makefile (unit, libname)
    end select
  end subroutine prc_gosam_write_makefile

@ %def prc_gosam_write_makefile
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: execute_makefile => prc_gosam_execute_makefile
<<prc gosam: procedures>>=
  subroutine prc_gosam_execute_makefile (object, libname)
    class(prc_gosam_t), intent(in) :: object
    type(string_t), intent(in) :: libname
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call os_system_call ("make " // &
            driver%loop_archive%os_data%makeflags // " -f " // &
            char (libname // "_gosam.makefile"))
    end select
  end subroutine prc_gosam_execute_makefile

@ %def prc_gosam_execute_makefile
@ 
<<prc gosam: prc gosam: TBP>>=
  procedure :: create_olp_library => prc_gosam_create_olp_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_create_olp_library (object, libname, lib_exists)
    class(prc_gosam_t), intent(inout) :: object
    type(string_t), intent(in) :: libname
    logical, intent(in) :: lib_exists
    integer :: unit
    select type (driver => object%driver)
    type is (gosam_driver_t)
       if (lib_exists) then
          call driver%loop_archive%restore (driver%olp_file, driver%olc_file, &
                                            driver%olp_dir)
       else
          unit = free_unit ()
          open (unit, file = char (libname // "_gosam.makefile"), &
               status = "replace", action= "write")
          call object%write_makefile (unit, libname)
          close (unit)
          call object%execute_makefile (libname)
       end if
    end select
  end subroutine prc_gosam_create_olp_library

@ %def prc_gosam_create_olp_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: load_olp_library => prc_gosam_load_olp_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_load_olp_library (object, os_data, store)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: store
    logical :: dl_success
    integer :: ierr
    
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%load (os_data, store, dl_success)
       if (.not. dl_success) &
          call msg_fatal ("Error while loading GoSam libraries: ")
       call driver%gosam_olp_start (char (driver%olc_file), ierr)
    end select
  end subroutine prc_gosam_load_olp_library

@ %def prc_gosam_load_olp_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: write => prc_gosam_write
<<prc gosam: procedures>>=
  subroutine prc_gosam_write (object, unit)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message ("GOSAM")
  end subroutine prc_gosam_write

@
@ %def prc_gosam_write
<<prc gosam: prc gosam: TBP>>=
  procedure :: needs_mcset => prc_gosam_needs_mcset
<<prc gosam: procedures>>=
  function prc_gosam_needs_mcset (object) result (flag)
    class(prc_gosam_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function prc_gosam_needs_mcset

@
@ %def prc_gosam_write
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_n_terms => prc_gosam_get_n_terms
<<prc gosam: procedures>>=
  function prc_gosam_get_n_terms (object) result (n)
    class(prc_gosam_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_gosam_get_n_terms

@  
@ %def prc_gosam_get_n_terms
<<prc gosam: prc gosam: TBP>>=
  procedure :: is_allowed => prc_gosam_is_allowed
<<prc gosam: procedures>>=
  function prc_gosam_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%is_allowed (f, h, c, cflag)
       flag = cflag
    class default
       call msg_fatal &
            ("Gosam instance created, but driver is not a GoSam driver!")
    end select
  end function prc_gosam_is_allowed

@
@ %def prc_gosam_is_allowed
<<prc gosam: prc gosam: TBP>>=
  procedure :: update_alpha_s => prc_gosam_update_alpha_s
<<prc gosam: procedures>>=
  subroutine prc_gosam_update_alpha_s (object, core_state, fac_scale) 
    class(prc_gosam_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    real(default), intent(in) :: fac_scale
    real(default) :: alpha_qcd
    if (allocated (object%qcd%alpha)) then
       alpha_qcd = object%qcd%alpha%get (fac_scale)
       select type (driver => object%driver)
       type is (gosam_driver_t)
          call driver%update_alpha_s (alpha_qcd)
       end select 
       if (allocated (core_state)) then
          select type (core_state)
          type is (gosam_state_t)
             core_state%alpha_qcd = alpha_qcd
          end select
       end if
    end if
  end subroutine prc_gosam_update_alpha_s

@ %def prc_gosam_update_alpha_s
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_hard_kinematics => prc_gosam_compute_hard_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state 
    call int_hard%set_momenta (p_seed)
    if (allocated (core_state)) then
      select type (core_state)
      type is (gosam_state_t); core_state%new_kinematics = .true.
      end select
    end if
  end subroutine prc_gosam_compute_hard_kinematics

@ 
@ %def prc_gosam_compute_hard_kinematics
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_eff_kinematics => prc_gosam_compute_eff_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_gosam_compute_eff_kinematics

@
@ %def prc_gosam_compute_eff_kinematics
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_amplitude => prc_gosam_compute_amplitude
<<prc gosam: procedures>>=
  function prc_gosam_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    type is (gosam_state_t)
      core_state%alpha_qcd = object%qcd%alpha%get (fac_scale)
    end select
    amp = 0.0
  end function prc_gosam_compute_amplitude

@
@ %def prc_gosam_compute_amplitude
<<prc gosam: prc gosam: TBP>>=
  procedure :: recover_kinematics => prc_gosam_recover_kinematics
<<prc gosam: procedures>>=
  subroutine prc_gosam_recover_kinematics &
       (object, p_seed, int_hard, int_eff, core_state)
    class(prc_gosam_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard, int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_in
    n_in = int_eff%get_n_in ()
    call int_eff%set_momenta (p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = int_eff%get_momenta (outgoing = .true.)
  end subroutine prc_gosam_recover_kinematics

@ 
@ %def prc_gosam_recover_kinematics
<<prc gosam: prc gosam: TBP>>=
   procedure :: init_gosam => prc_gosam_init_gosam
<<prc gosam: procedures>>=
  subroutine prc_gosam_init_gosam (object, gosam_template)
    !!! Not prc_gosam_init to avoid name-clash
    class(prc_gosam_t), intent(inout) :: object
    type(gosam_template_t), intent(inout) :: gosam_template
    integer :: i_flv

    object%n_flv = size (object%data%flv_state, 2)
   
    if (gosam_template%compute_loop ()) then
       allocate (object%i_virt (object%n_flv), &
                 object%i_cc (object%n_flv))
    else if (gosam_template%compute_subtraction ()) then
       allocate (object%i_born (object%n_flv), &
                 object%i_cc (object%n_flv) , &
                 object%i_sc (object%n_flv))
    else if (gosam_template%compute_real_trees ()) then
       allocate (object%i_real (object%n_flv))
    end if
  end subroutine prc_gosam_init_gosam

@ %def prc_gosam_init_gosam
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_nflv => prc_gosam_get_nflv
<<prc gosam: procedures>>=
  function prc_gosam_get_nflv (object) result (n_flv)
    class(prc_gosam_t), intent(in) :: object
    integer :: n_flv
    n_flv = object%n_flv
  end function prc_gosam_get_nflv

@ %def prc_gosam_get_nflv
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: init_driver => prc_gosam_init_driver
<<prc gosam: procedures>>=
  subroutine prc_gosam_init_driver (object, os_data)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical :: dl_success
    type(string_t) :: olp_file, olc_file, olp_dir
    integer(c_int) :: success
    logical :: found = .false.

    select type (def => object%def)
    type is (gosam_def_t)
      olp_file = def%basename // def%suffix // '.olp'
      olc_file = def%basename // def%suffix // '.olc'
      olp_dir = def%basename // def%suffix // '_olp_modules'
    class default
      call msg_bug ("prc_gosam_init_driver: core_def should be of gosam-type")
    end select

    select type(driver => object%driver)
    type is (gosam_driver_t)
      call driver%init_gosam (os_data, olp_file, olc_file, olp_dir, &
           var_str ("libgolem_olp"))
    end select
  end subroutine prc_gosam_init_driver

@ %def prc_gosam_init_driver
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_initialized => prc_gosam_set_initialized
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_initialized (prc_gosam)
    class(prc_gosam_t), intent(inout) :: prc_gosam
    prc_gosam%initialized = .true.
  end subroutine prc_gosam_set_initialized 

@ %def prc_gosam_set_initialized
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_parameters => prc_gosam_set_parameters
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_parameters (object, qcd, use_color_factors)
    class(prc_gosam_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    logical, intent(in) :: use_color_factors
    object%qcd = qcd
    object%use_color_factors = use_color_factors

  end subroutine prc_gosam_set_parameters

@ %def prc_gosam_set_parameters
@
<<prc gosam: procedures>>=
  function create_blha_momentum_array (p) result (mom)
    type(vector4_t), intent(in), dimension(:) :: p
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    integer :: n, i, k

    n = size (p)
    if (n > 10) call msg_fatal ("Number of external particles exceeeds" &
                                 // "size of GoSam-internal momentum array")
    k = 1
    do i = 1, n
       mom(k:k+3) = vector4_get_components (p(i))
       mom(k+4) = invariant_mass (p(i))
       k = k+5
    end do
    mom (k:50) = 0.0
  end function create_blha_momentum_array

@ %def create_blha_momentum_array
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_virt => prc_gosam_compute_sqme_virt
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_virt (object, &
                i_flv, p, ren_scale, alpha_s, sqme, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(in) :: alpha_s
    logical, intent(out) :: bad_point
    real(default), dimension(4), intent(out) :: sqme
    real(double) :: mu
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: acc_dble
    real(default) :: acc

    mom = create_blha_momentum_array (p)
    if (ren_scale == 0.0) then
      mu = sqrt (2* (p(1)*p(2)))
    else
      mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
      call driver%set_alpha_s (alpha_s)
      call driver%gosam_olp_eval2 (object%i_virt(i_flv), &
                                   mom, mu, r, acc_dble) 
    end select
    acc = acc_dble
    sqme = r(1:4)
    if (acc > object%maximum_accuracy) then
       bad_point = .true.
    else
       bad_point = .false.
    end if
  end subroutine prc_gosam_compute_sqme_virt

@ %def prc_gosam_compute_sqme_virt
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_real => prc_gosam_compute_sqme_real
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_real &
         (object, i_flv, p, ren_scale, alpha_s, sqme, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(in) :: alpha_s
    real(default), intent(out) :: sqme
    logical, intent(out) :: bad_point
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: mu
    real(double) :: acc_dble
    real(default) :: acc
 
    mom = create_blha_momentum_array (p)
    if (ren_scale == 0.0) then
       mu = sqrt (2*p(1)*p(2))
    else
      mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       call driver%gosam_olp_eval2 (object%i_real(i_flv), mom, &
                                    mu, r, acc_dble)
       sqme = r(4)
    end select
    acc = acc_dble
    if (acc > object%maximum_accuracy) bad_point = .true.
  end subroutine prc_gosam_compute_sqme_real

@ %def prc_gosam_compute_sqme_real
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_cc => prc_gosam_compute_sqme_cc
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_cc &
         (object, i_flv, p, ren_scale, alpha_s, &
          born_out, born_cc, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(in) :: alpha_s
    real(default), intent(out), optional :: born_out
    real(default), intent(inout), dimension(:,:) :: born_cc
    logical, intent(out) :: bad_point
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: mu
    integer :: i, j, pos
    integer :: im1, jm1
    real(double) :: acc_dble1, acc_dble2
    real(default) :: acc1, acc2
    real(default) :: born

    mom = create_blha_momentum_array (p)
    if (ren_scale == 0.0) then
       mu = sqrt (2*p(1)*p(2))
    else
       mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       if (allocated (object%i_born)) then
          call driver%gosam_olp_eval2 (object%i_born(i_flv), &
                                       mom, mu, r, acc_dble1)
          born = r(4)
       end if
       if (present (born_out)) born_out = born
       call driver%gosam_olp_eval2 (object%i_cc(i_flv), &
                                    mom, mu, r, acc_dble2)
    end select
    do j = 1, size (p)
      do i = 1, j
        if (i <= 2 .or. j <= 2) then
          born_cc (i,j) = 0._default
        else if (i == j) then
          born_cc (i,j) = -cf*born
        else
          im1 = i-1; jm1 = j-1
          pos = im1 + jm1*(jm1-1)/2 + 1
          born_cc (i,j) = -r(pos)
        end if
        born_cc (j,i) = born_cc (i,j)
      end do
    end do
    acc1 = acc_dble1; acc2 = acc_dble2
    if (acc1 > object%maximum_accuracy .or. &
        acc2 > object%maximum_accuracy) then
      bad_point = .true.
    end if
  end subroutine prc_gosam_compute_sqme_cc

@ %def prc_gosam_compute_sqme_cc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_sc => prc_gosam_compute_sqme_sc
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_sc (object, &
                i_flv, em, p, ren_scale_in, alpha_s, &
            me_sc, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    integer, intent(in) :: em
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale_in
    real(default), intent(in) :: alpha_s
    complex(default), intent(out) :: me_sc
    logical, intent(out) :: bad_point
    real(double), dimension(GOSAM_MOMENTUM_LIMIT) :: mom
    real(double), dimension(GOSAM_RESULTS_LIMIT) :: r
    real(double) :: ren_scale
    integer :: i, igm1, n
    integer :: pos_real, pos_imag
    real(double) :: acc_dble
    real(default) :: acc

    me_sc = cmplx(0,0,default)
    mom = create_blha_momentum_array (p)
    if (ren_scale_in == 0.0) then
      ren_scale = sqrt (2*p(1)*p(2))
    else
      ren_scale = ren_scale_in
    end if
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       call driver%gosam_olp_eval2 (object%i_sc(i_flv), &
                                    mom, ren_scale, r, acc_dble)
    end select

@ The BLHA-interface conventions require the quantity $S_{ij} = \langle M_{i,+}|T_iT_j|M_{i,-}\rangle$ to be
  produced, where $i$ is the position of the splitting gluon. However, $\tilde{M} = \langle M_{i,-}|M_{i,+}\rangle$ 
  is needed. This can be obtained using color conservation, $\sum_{j} T_j|M\rangle = 0$, so that
  \begin{equation*}
    \sum_{j \neq i} S_{ij} = -\langle M_{i,+}|T_i^2|M_{i,-}\rangle = -C_A \langle M_{i,+}|M_{i,-}\rangle = -C_A \tilde{M}^*
  \end{equation*}
  According to BLHA conventions, the real part of $S_{ij}$ is located at positions $2i + 2nj$ in the output array, where 
  $n$ denotes the number of external particles and the enumeration of particles starts at zero.
  The subsequent position, i.e. $2i + 2nj + 1$ is designated to the imaginary part of $S_{ij}$. Note that, since the first 
  array position is 1, the implemented position association deviates from the above one in the addition of 1.
<<prc gosam: procedures>>=
    igm1 = em-1
    n = size(p)
    do i = 0, n-1
      pos_real = 2*igm1 + 2*n*i + 1
      pos_imag = pos_real + 1
      me_sc = me_sc + cmplx (r(pos_real), r(pos_imag), default)
    end do

    me_sc = -conjg(me_sc)/CA
  
    acc = acc_dble
    if (acc > object%maximum_accuracy) bad_point = .true.
  end subroutine prc_gosam_compute_sqme_sc

@ %def prc_gosam_compute_sqme_sc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: allocate_workspace => prc_gosam_allocate_workspace
<<prc gosam: procedures>>=
  subroutine prc_gosam_allocate_workspace (object, core_state)
    class(prc_gosam_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (gosam_state_t :: core_state)
  end subroutine prc_gosam_allocate_workspace

@ %def prc_gosam_allocate_workspace
@ 
<<prc gosam: prc gosam: TBP>>=
  procedure :: get_alpha_s => prc_gosam_get_alpha_s
<<prc gosam: procedures>>=
  function prc_gosam_get_alpha_s (object, core_state) result (alpha)
    class(prc_gosam_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha
    if (allocated (core_state)) then
      select type (core_state)
      type is (gosam_state_t)
        alpha = core_state%alpha_qcd
      end select
    else
      alpha = 0._default 
    end if
  end function prc_gosam_get_alpha_s

@ %def prc_gosam_get_alpha_s
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: read_olc_file => prc_gosam_read_olc_file
<<prc gosam: procedures>>=
  subroutine prc_gosam_read_olc_file (object, flavors)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in), dimension(:,:) :: flavors
    integer, dimension(20) :: amp_type, flv_index, label
    integer :: i_proc
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%read_olc_file (flavors, amp_type, flv_index, label)
    end select
    do i_proc = 1, size (amp_type)
       if (amp_type (i_proc) < 0) exit
       select case (amp_type (i_proc))
       case (BLHA_AMP_TREE)
          if (allocated (object%i_born)) then
             object%i_born(flv_index(i_proc)) = label(i_proc)
          
          else if (allocated (object%i_real)) then
             object%i_real(flv_index(i_proc)) = label(i_proc)
          else 
             call msg_fatal ("Tree matrix element present, &
                             &but neither Born nor real indices are allocated!")
          end if
       case (BLHA_AMP_CC)
          if (allocated (object%i_cc)) then
             object%i_cc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Color-correlated matrix element present, &
                              &but cc-indices are not allocated!")
          end if
       case (BLHA_AMP_SC)
          if (allocated (object%i_sc)) then
             object%i_sc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Spin-correlated matrix element present, &
                             &but sc-indices are not allocated!")
          end if
       case (BLHA_AMP_LOOP)
          if (allocated (object%i_virt)) then
             object%i_virt(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Loop matrix element present, &
                             &but virt-indices are not allocated!")
          end if
       case default
          call msg_fatal ("Undefined amplitude type")
       end select
    end do
  end subroutine prc_gosam_read_olc_file

@ %def prc_gosam_read_olc_file
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_particle_properties => prc_gosam_set_particle_properties
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_particle_properties (object, model) 
    class(prc_gosam_t), intent(inout) :: object
    class(model_data_t), intent(in), target :: model
    type(flavor_t), dimension(:), allocatable :: flv
    real(default), dimension(:), allocatable :: masses
    real(default), dimension(:), allocatable :: widths
    integer :: i_part, i_flv
    integer :: n_part, n_flv
    n_part = size (object%data%flv_state,1)
    n_flv = size (object%data%flv_state,2)
    allocate (flv (n_part), masses (n_part), widths (n_part))
    do i_flv = 1, n_flv
       associate (i_pdg => object%data%flv_state (:,i_flv))
          call flv%init (i_pdg, model)
          masses = flv%get_mass ()
          widths = flv%get_width ()
          select type (driver => object%driver)
          type is (gosam_driver_t)
             do i_part = 1, n_part
                if (masses(i_part) /= 0._default) &
                   call driver%set_mass_and_width (abs(i_pdg(i_part)), &
                                                   mass=masses(i_part))
                if (abs(i_pdg(i_part)) == 6) &
                   call driver%set_mass_and_width (abs(i_pdg(i_part)), &
                                                   width=widths(i_part))
             end do
          end select
       end associate
    end do
  end subroutine prc_gosam_set_particle_properties

@ %def prc_gosam_set_particle_properties
@           
<<prc gosam: gosam state: TBP>>=
  procedure :: write => gosam_state_write
<<prc gosam: procedures>>=
  subroutine gosam_state_write (object, unit)
    class(gosam_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_warning ("gosam_state_write: What to write?")
  end subroutine gosam_state_write

@ %def prc_gosam_state_write
@
<<prc gosam: gosam state: TBP>>=
  procedure :: reset_new_kinematics => gosam_state_reset_new_kinematics
<<prc gosam: procedures>>=
  subroutine gosam_state_reset_new_kinematics (object)
    class(gosam_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine gosam_state_reset_new_kinematics

@ 
@ %def gosam_state_reset_new_kinematics
<<prc gosam: procedures>>=
  function check_golem_installation (os_data) result (res)
     type(os_data_t), intent(in) :: os_data
     logical :: res
     type(string_t) :: libavh_olo, libgolem
     integer :: i
     res = .true.
     do i = 1, size (lib_suffix)
       libavh_olo = os_data%prefix // '/lib/libavh_olo' // &
            trim (lib_suffix (i))
       libgolem = os_data%prefix // '/lib/libgolem' // trim (lib_suffix (i))
       res = res .and. (os_file_exist (libavh_olo) .and. &
            os_file_exist (libgolem))
       if (.not. res) exit
     end do
   end function check_golem_installation

@ %def check_golem_installation
@
<<prc gosam: procedures>>=
  function check_samurai_installation (os_data) result (res)
    type(os_data_t), intent(in) :: os_data
    logical :: res
    type(string_t) :: libsamurai
    integer :: i
    res = .true.
    do i = 1, size (lib_suffix)
      libsamurai = os_data%prefix // '/lib/libsamurai' // trim (lib_suffix(i))
      res = os_file_exist (libsamurai)
      if (.not. res) exit
    end do
  end function check_samurai_installation 

@ %def check_samurai_installation
@
<<prc gosam: procedures>>=
  function check_ninja_installation (os_data) result (res)
    type(os_data_t), intent(in) :: os_data
    logical :: res
    type(string_t) :: libninja
    integer :: i
    res = .true.
    do i = 1, size (lib_suffix)
      libninja = os_data%prefix // '/lib/libninja' // trim (lib_suffix(i))
      res = os_file_exist (libninja)
      if (.not. res) exit
    end do
  end function check_ninja_installation

@ %def check_ninja_installation
@
<<prc gosam: public>>=
  public :: gosam_template_t
<<prc gosam: types>>=
  type :: gosam_template_t
    integer :: I_REAL = 1
    integer :: I_LOOP = 2
    integer :: I_SUB = 3
    logical, dimension(3) :: compute_component
  contains
  <<prc gosam: gosam template: TBP>>
  end type gosam_template_t

@ %def gosam_template_t
@
<<prc gosam: gosam template: TBP>>=
  procedure :: init => gosam_template_init
<<prc gosam: procedures>>=
  subroutine gosam_template_init (template)
    class(gosam_template_t), intent(inout) :: template
    template%compute_component = .false.
  end subroutine gosam_template_init

@ %def gosam_template_init
@
<<prc gosam: gosam template: TBP>>=
  procedure :: set_loop => gosam_template_set_loop
  procedure :: set_subtraction => gosam_template_set_subtraction
  procedure :: set_real_trees => gosam_template_set_real_trees
<<prc gosam: procedures>>=
  subroutine gosam_template_set_loop (template, val)
    class(gosam_template_t), intent(inout) :: template
    logical, intent(in) :: val
    template%compute_component(template%I_LOOP) = val
  end subroutine gosam_template_set_loop

  subroutine gosam_template_set_subtraction (template, val)
    class(gosam_template_t), intent(inout) :: template
    logical, intent(in) :: val
    template%compute_component (template%I_SUB) = val
  end subroutine gosam_template_set_subtraction

  subroutine gosam_template_set_real_trees (template, val)
    class(gosam_template_t), intent(inout) :: template
    logical, intent(in) :: val
    template%compute_component (template%I_REAL) = val
  end subroutine gosam_template_set_real_trees

@ %def gosam_template_set_components
@
<<prc gosam: gosam template: TBP>>=
  procedure :: compute_loop => gosam_template_compute_loop
  procedure :: compute_subtraction => gosam_template_compute_subtraction
  procedure :: compute_real_trees => gosam_template_compute_real_trees
<<prc gosam: procedures>>=
  function gosam_template_compute_loop (template) result (val)
    class(gosam_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_LOOP)
  end function gosam_template_compute_loop  

  function gosam_template_compute_subtraction (template) result (val)
    class(gosam_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_SUB)
  end function gosam_template_compute_subtraction

  function gosam_template_compute_real_trees (template) result (val)
    class(gosam_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_REAL)
  end function gosam_template_compute_real_trees

@ %def gosam_template_compute
<<prc gosam: gosam template: TBP>>=
  procedure :: check => gosam_template_check
<<prc gosam: procedures>>=
  function gosam_template_check (template) result (val)
    class(gosam_template_t), intent(in) :: template
    logical :: val
    val = count (template%compute_component) == 1
  end function gosam_template_check

@ %def gosam_template_check
@
<<prc gosam: gosam template: TBP>>=
  procedure :: reset => gosam_template_reset
<<prc gosam: procedures>>=
  subroutine gosam_template_reset (template)
    class(gosam_template_t), intent(inout) :: template
    template%compute_component = .false.
  end subroutine gosam_template_reset

@ %def gosam_template_reset

