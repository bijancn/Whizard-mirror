% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: GoSam interface

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{GoSam Interface}

The code in this chapter makes amplitudes accessible to \whizard\ that
are generated and computed by the GoSam package.

These are the modules:
\begin{description}
\item[loop\_archive]
  Provide some useful extra functionality.
\item[prc\_gosam]
  The actual interface, following the \whizard\ conventions for
  matrix-element generator methods.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Save previously generated loop libraries}
<<[[loop_archive.f90]]>>=
<<File header>>

module loop_archive

  use io_units
<<Use strings>>
  use diagnostics
  use os_interface

<<Standard module head>>

<<Loop archive: public>>

<<Loop archive: types>>

contains

<<Loop archive: procedures>>

end module loop_archive
@ %def loop_archive
@
<<Loop archive: public>>=
  public :: loop_archive_t
<<Loop archive: types>>=
  type :: loop_archive_t
    logical :: active = .false.
    type(string_t) :: name
    type(string_t) :: current_prefix
    type(os_data_t) :: os_data
  contains
  <<Loop archive: loop archive: TBP>>
  end type loop_archive_t

@ %def loop_archive_t
@
<<Loop archive: loop archive: TBP>>=
  procedure :: activate => loop_archive_activate
<<Loop archive: procedures>>=
  subroutine loop_archive_activate (archive, name, os_data)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: name
    type(os_data_t), intent(in) :: os_data
    integer :: status, success
    type(string_t) :: prefix
    archive%name = name
    archive%os_data = os_data
    call os_system_call ('test -d "' // name // &
                         '"', status = status, verbose = .true.)
    if (status /= 0) then
      call os_system_call ('mkdir ' // name, &
                            status = success, verbose = .true.)
      if (success /= 0) call msg_fatal ("Creation of loop archive failed!")
    end if
    archive%active = .true.
  end subroutine loop_archive_activate

@ %def loop_archive_activate
@
<<Loop archive: loop archive: TBP>>=
  procedure :: record => loop_archive_record
<<Loop archive: procedures>>=
  subroutine loop_archive_record (archive, olp_file, olc_file, config_file, lib)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_file, olc_file, config_file, lib
    type(string_t) :: current_prefix
    type(string_t) :: filename

    ! Copy, rename and move olp-file and olc-file
    filename = archive%current_prefix // '.olp'
    call os_system_call ('cp ' // olp_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
    filename = archive%current_prefix // '.olc'
    call os_system_call ('cp ' // olc_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
    ! Do the same with the loop-library and the config file
    filename = archive%current_prefix // '_libgolem_olp.' // &
       archive%os_data%shrlib_ext
    call os_system_call ('cp ' // lib // ' ' // filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
    filename = archive%current_prefix // '_golem.in'
    call os_system_call ('cp ' // config_file // ' ' // &
       filename)
    call os_system_call ('mv ' // filename // ' ' // &
       archive%name)
  end subroutine loop_archive_record

@ %def loop_archive_record
@
<<Loop archive: loop archive: TBP>>=
  procedure :: search => loop_archive_search
<<Loop archive: procedures>>=
  subroutine loop_archive_search (archive, files, found)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), dimension(3), intent(in) :: files
    logical, intent(out) :: found
    type(string_t) :: current_olp, current_config, current_lib
    character(len=3) :: prefix
    integer :: counter
    logical, dimension(2) :: exist
    integer, dimension(2) :: identical
    integer :: i

    counter = 1
    do
       write(prefix,"(A,I2.2)") 'V', counter
       current_olp = archive%name // '/' // var_str (prefix) // '.olp'
       current_config = archive%name // '/' // var_str (prefix) // '_golem.in'
       current_lib = archive%name // '/' // var_str (prefix) // &
            '_libgolem_olp.' // archive%os_data%shrlib_ext
       inquire (file = char (current_olp), exist = exist(1))
       inquire (file = char (current_config), exist = exist(2))
       if (all (exist)) then
          call os_system_call ('diff ' // current_olp // ' ' // files(1) // &
                               ' > /dev/null', status=identical(1))
          call os_system_call ('diff ' // current_config // ' ' // files(2) // &
                               ' > /dev/null', status=identical(2))
            if (all (identical == 0)) then
               found = .true.
               exit
            else
               counter = counter+1
            end if
       else
          found = .false.
          exit
       end if
       if (counter >= 100) call msg_fatal ("Maximum number of loop-libraries exceeded!")
    end do
    write(prefix,"(A,I2.2)") 'V', counter
    archive%current_prefix = var_str (prefix)
  end subroutine loop_archive_search

@ %def loop_archive_searc
@
<<Loop archive: loop archive: TBP>>=
  procedure :: restore => loop_archive_restore
<<Loop archive: procedures>>=
  subroutine loop_archive_restore (archive, olp_orig, olc_orig, path)
    class(loop_archive_t), intent(inout) :: archive
    type(string_t), intent(in) :: olp_orig, olc_orig, path
    type(string_t) :: olp_file, olc_file, config_file, lib

    olp_file = archive%current_prefix // '.olp'
    olc_file = archive%current_prefix // '.olc'
    config_file = archive%current_prefix // '_golem.in'
    lib = archive%current_prefix // '_libgolem_olp.' // &
         archive%os_data%shrlib_ext

    call os_system_call ('cp ' // archive%name // '/' // olp_file // ' .')
    call os_system_call ('mv ' // olp_file // ' ' // olp_orig)

    call os_system_call ('cp ' // archive%name // '/' // olc_file // ' .')
    call os_system_call ('mv ' // olc_file // ' ' // olc_orig)

    call os_system_call ('cp ' // archive%name // '/' // config_file // ' .')
    call os_system_call ('mv ' // config_file // ' golem.in')

    call os_system_call ('cp ' // archive%name // '/' // lib // ' .')
    call os_system_call ('mv ' // lib // ' libgolem_olp.' // &
         archive%os_data%shrlib_ext)
    call os_system_call ('mv libgolem_olp.' // archive%os_data%shrlib_ext &
         // ' ' // path // '/.libs')

  end subroutine loop_archive_restore

@ %def loop_archive_restore
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Gosam Interface}
<<[[prc_gosam.f90]]>>=
<<File header>>

module prc_gosam

  use, intrinsic :: iso_c_binding !NODEP!
  use, intrinsic :: iso_fortran_env

  use kinds
<<Use strings>>
  use io_units
  use constants
  use unit_tests, only: vanishes
  use system_defs, only: TAB
  use system_dependencies
  use file_utils
  use string_utils
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use interactions
  use pdg_arrays
  use sm_qcd
  use flavors
  use model_data
  use variables

  use process_constants
  use prclib_interfaces
  use process_libraries
  use prc_core_def
  use prc_core

  use blha_config
  use blha_olp_interfaces
  use loop_archive

<<Standard module head>>

<<prc gosam: constants>>

<<prc gosam: public>>

<<prc gosam: types>>

<<prc gosam: interfaces>>

contains

<<prc gosam: procedures>>

end module prc_gosam

@
@ %def module prc_gosam

<<prc gosam: constants>>=
  character(10), dimension(5), parameter ::  &
             lib_suffix = [character(10) :: &
             '.a', '.la', '.so', '.so.0', '.so.0.0.0']

@ Different types of QCD splittings: 1 - $q \rightarrow qg$, 2 - $g \rightarrow gg$,
3 - $g \rightarrow qq$.
<<prc gosam: constants>>=
  integer, parameter :: Q_TO_QG = 1
  integer, parameter :: G_TO_GG = 2
  integer, parameter :: G_TO_QQ = 3

@
<<prc gosam: types>>=
  type, extends (prc_blha_writer_t) :: gosam_writer_t
    type(string_t) :: gosam_dir
    type(string_t) :: golem_dir
    type(string_t) :: samurai_dir
    type(string_t) :: ninja_dir
    type(string_t) :: form_dir
    type(string_t) :: qgraf_dir
    type(string_t) :: filter_lo, filter_nlo
    type(string_t) :: symmetries
    integer :: form_threads
    integer :: form_workspace
    type(string_t) :: fc
  contains
  <<prc gosam: gosam writer: TBP>>
  end type gosam_writer_t

@
@ %def gosam_writer_t

<<prc gosam: public>>=
  public :: gosam_def_t
<<prc gosam: types>>=
  type, extends (blha_def_t) :: gosam_def_t
    logical :: execute_olp = .true.
  contains
  <<prc gosam: gosam def: TBP>>
  end type gosam_def_t

@
@ %def gosam_def_t
<<prc gosam: types>>=
  type, extends (blha_driver_t) :: gosam_driver_t
    type(string_t) :: gosam_dir
    type(string_t) :: olp_file
    type(string_t) :: olc_file
    type(string_t) :: olp_dir
    type(string_t) :: olp_lib
    type(loop_archive_t) :: loop_archive
  contains
  <<prc gosam: gosam driver: TBP>>
  end type gosam_driver_t

@
@ %def gosam_driver_t
<<prc gosam: public>>=
  public :: prc_gosam_t
<<prc gosam: types>>=
  type, extends (prc_blha_t) :: prc_gosam_t
    logical :: initialized = .false.
  contains
  <<prc gosam: prc gosam: TBP>>
  end type prc_gosam_t

@
@ %def prc_gosam_t
<<prc gosam: types>>=
  type, extends (blha_state_t) :: gosam_state_t
  contains
  <<prc gosam: gosam state: TBP>>
  end type gosam_state_t

@ %def gosam_state_t
@
<<prc gosam: gosam def: TBP>>=
  procedure :: init => gosam_def_init
<<prc gosam: procedures>>=
  subroutine gosam_def_init (object, basename, model_name, &
     prt_in, prt_out, nlo_type, var_list)
    class(gosam_def_t), intent(inout) :: object
    type(string_t), intent(in) :: model_name
    type(string_t), intent(in) :: basename
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer, intent(in) :: nlo_type
    type(var_list_t), intent(in) :: var_list
    object%basename = basename
    allocate (gosam_writer_t :: object%writer)
    select case (nlo_type)
    case (BORN)
       object%suffix = '_BORN'
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    end select
    select type (writer => object%writer)
    type is (gosam_writer_t)
      call writer%init (model_name, prt_in, prt_out)
      writer%filter_lo = var_list%get_sval (var_str ("$gosam_filter_lo"))
      writer%filter_nlo = var_list%get_sval (var_str ("$gosam_filter_nlo"))
      writer%symmetries = &
           var_list%get_sval (var_str ("$gosam_symmetries"))
      writer%form_threads = &
           var_list%get_ival (var_str ("form_threads"))
      writer%form_workspace = &
           var_list%get_ival (var_str ("form_workspace"))
      writer%fc = &
           var_list%get_sval (var_str ("$gosam_fc"))
    end select
  end subroutine gosam_def_init

@ %def gosam_def_init
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: write_config => gosam_writer_write_config
<<prc gosam: procedures>>=
  subroutine gosam_writer_write_config (gosam_writer)
    class(gosam_writer_t), intent(in) :: gosam_writer
    integer :: unit
    unit = free_unit ()
    open (unit, file = "golem.in", status = "replace", action = "write")
    call gosam_writer%generate_configuration_file (unit)
    close(unit)
  end subroutine gosam_writer_write_config

@ %def gosam_writer_write_config
@
<<prc gosam: gosam def: TBP>>=
  procedure, nopass :: type_string => gosam_def_type_string
<<prc gosam: procedures>>=
  function gosam_def_type_string () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_def_type_string

@
@ %def gosam_def_type_string
<<prc gosam: gosam def: TBP>>=
  procedure :: write => gosam_def_write
<<prc gosam: procedures>>=
  subroutine gosam_def_write (object, unit)
    class(gosam_def_t), intent(in) :: object
    integer, intent(in) :: unit
    select type (writer => object%writer)
    type is (gosam_writer_t)
      call writer%write (unit)
    end select
  end subroutine gosam_def_write

@
@ %def gosam_def_write
<<prc gosam: gosam def: TBP>>=
  procedure :: read => gosam_def_read
<<prc gosam: procedures>>=
  subroutine gosam_def_read (object, unit)
    class(gosam_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine gosam_def_read

@ %def gosam_def_read
@
<<prc gosam: gosam def: TBP>>=
  procedure :: allocate_driver => gosam_def_allocate_driver
<<prc gosam: procedures>>=
  subroutine gosam_def_allocate_driver (object, driver, basename)
    class(gosam_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (gosam_driver_t :: driver)
  end subroutine gosam_def_allocate_driver

@
@ %def gosam_def_allocate_driver
<<prc gosam: gosam writer: TBP>>=
  procedure, nopass :: type_name => gosam_writer_type_name
<<prc gosam: procedures>>=
  function gosam_writer_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_writer_type_name

@
@ %def gosam_writer_type_name
<<prc gosam: gosam writer: TBP>>=
  procedure :: init => gosam_writer_init
<<prc gosam: procedures>>=
  pure subroutine gosam_writer_init (writer, model_name, prt_in, prt_out, restrictions)
    class(gosam_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    type(string_t), intent(in), optional :: restrictions
    writer%gosam_dir = GOSAM_DIR
    writer%golem_dir = GOLEM_DIR
    writer%samurai_dir = SAMURAI_DIR
    writer%ninja_dir = NINJA_DIR
    writer%form_dir = FORM_DIR
    writer%qgraf_dir = QGRAF_DIR
    call writer%base_init (model_name, prt_in, prt_out)
  end subroutine gosam_writer_init

@ %def gosam_writer_init
@
<<prc gosam: gosam driver: TBP>>=
  procedure, nopass :: type_name => gosam_driver_type_name
<<prc gosam: procedures>>=
  function gosam_driver_type_name () result (string)
    type(string_t) :: string
    string = "gosam"
  end function gosam_driver_type_name

@
@ %def gosam_driver_type_name
<<prc gosam: gosam driver: TBP>>=
  procedure :: init_gosam => gosam_driver_init_gosam
<<prc gosam: procedures>>=
  subroutine gosam_driver_init_gosam (object, os_data, olp_file, &
                                olc_file, olp_dir, olp_lib)
    class(gosam_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: olp_file, olc_file, olp_dir, olp_lib
    object%gosam_dir = GOSAM_DIR
    object%olp_file = olp_file
    object%contract_file = olc_file
    object%olp_dir = olp_dir
    object%olp_lib = olp_lib
    call object%loop_archive%activate (var_str ('Generated_Loops'), os_data)
  end subroutine gosam_driver_init_gosam

@ %def gosam_driver_init
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: init_dlaccess_to_library => gosam_driver_init_dlaccess_to_library
<<prc gosam: procedures>>=
  subroutine gosam_driver_init_dlaccess_to_library &
     (object, os_data, dlaccess, success)
    class(gosam_driver_t), intent(in) :: object
    type(os_data_t), intent(in) :: os_data
    type(dlaccess_t), intent(out) :: dlaccess
    logical, intent(out) :: success
    type(string_t) :: libname, msg_buffer
    libname = object%olp_dir // '/.libs/libgolem_olp.' // &
      os_data%shrlib_ext
    msg_buffer = "One-Loop-Provider: Using Gosam"
    call msg_message (char(msg_buffer))
    msg_buffer = "Loading library: " // libname
    call msg_message (char(msg_buffer))
    call dlaccess_init (dlaccess, var_str ("."), libname, os_data)
    success = .not. dlaccess_has_error (dlaccess)
  end subroutine gosam_driver_init_dlaccess_to_library

@ %def gosam_driver_init_dlaccess_to_library
@
<<prc gosam: gosam writer: TBP>>=
  procedure :: generate_configuration_file => &
            gosam_writer_generate_configuration_file
<<prc gosam: procedures>>=
  subroutine gosam_writer_generate_configuration_file &
          (object, unit)
      class(gosam_writer_t), intent(in) :: object
      integer, intent(in) :: unit
      type(string_t) :: fc_bin
      type(string_t) :: form_bin, qgraf_bin, haggies_bin
      type(string_t) :: fcflags_golem, ldflags_golem
      type(string_t) :: fcflags_samurai, ldflags_samurai
      type(string_t) :: fcflags_ninja, ldflags_ninja
      type(string_t) :: ldflags_avh_olo, ldflags_qcdloop
      fc_bin = DEFAULT_FC
      form_bin = object%form_dir // '/bin/tform'
      qgraf_bin = object%qgraf_dir // '/bin/qgraf'
      if (object%gosam_dir /= "") then
        haggies_bin = '/usr/bin/java -jar ' // object%gosam_dir // &
                       '/share/golem/haggies/haggies.jar'
      else
        call msg_fatal ("generate_configuration_file: At least " // &
             "the GoSam Directory has to be specified!")
      end if
      if (object%golem_dir /= "") then
        fcflags_golem = "-I" // object%golem_dir // "/include/golem95"
        ldflags_golem = "-L" // object%golem_dir // "/lib -lgolem"
      end if
      if (object%samurai_dir /= "") then
        fcflags_samurai = "-I" // object%samurai_dir // "/include/samurai"
        ldflags_samurai = "-L" // object%samurai_dir // "/lib -lsamurai"
        ldflags_avh_olo = "-L" // object%samurai_dir // "/lib -lavh_olo"
        ldflags_qcdloop = "-L" // object%samurai_dir // "/lib -lqcdloop"
      end if
      if (object%ninja_dir /= "") then
        fcflags_ninja = "-I" // object%ninja_dir // "/include/ninja " &
                        // "-I" // object%ninja_dir // "/include"
        ldflags_ninja = "-L" // object%ninja_dir // "/lib -lninja"
      end if
      write (unit, "(A)") "#+avh_olo.ldflags=" &
            // char (ldflags_avh_olo)
      write (unit, "(A)") "reduction_programs=golem95, samurai, ninja"
      write (unit, "(A)") "extensions=autotools"
      write (unit, "(A)") "#+qcdloop.ldflags=" &
            // char (ldflags_qcdloop)
      write (unit, "(A)") "#+zzz.extensions=qcdloop, avh_olo"
      write (unit, "(A)") "#fc.bin=" // char (fc_bin)
      write (unit, "(A)") "form.bin=" // char (form_bin)
      write (unit, "(A)") "qgraf.bin=" // char (qgraf_bin)
      write (unit, "(A)") "#golem95.fcflags=" // char (fcflags_golem)
      write (unit, "(A)") "#golem95.ldflags=" // char (ldflags_golem)
      write (unit, "(A)") "haggies.bin=" // char (haggies_bin)
      write (unit, "(A)") "#samurai.fcflags=" // char (fcflags_samurai)
      write (unit, "(A)") "#samurai.ldflags=" // char (ldflags_samurai)
      write (unit, "(A)") "#ninja.fcflags=" // char (fcflags_ninja)
      write (unit, "(A)") "#ninja.ldflags=" // char (ldflags_ninja)
      !!! This might collide with the mass-setup in the order-file
      !!! write (unit, "(A)") "zero=mU,mD,mC,mS,mB"
      !!! This is covered by the BLHA2 interface
      write (unit, "(A)") "PSP_check=False"
      if (char (object%filter_lo) /= "") &
         write (unit, "(A)") "filter.lo=" // char (object%filter_lo)
      if (char (object%filter_nlo) /= "") &
         write (unit, "(A)") "filter.nlo=" // char (object%filter_nlo)
      if (char (object%symmetries) /= "") &
         write (unit, "(A)") "symmetries=" // char(object%symmetries)
      write (unit, "(A,I0)") "form.threads=", object%form_threads
      write (unit, "(A,I0)") "form.workspace=", object%form_workspace
      if (char (object%fc) /= "") &
         write (unit, "(A)") "fc.bin=" // char(object%fc)
  end subroutine gosam_writer_generate_configuration_file

@ %def gosam_writer_generate_configuration_file
@ We have to assure that all files necessary for the configure process
in the GoSam code are ready. This is done with a stamp mechanism.
<<prc gosam: gosam driver: TBP>>=
  procedure :: write_makefile => gosam_driver_write_makefile
<<prc gosam: procedures>>=
  subroutine gosam_driver_write_makefile (object, unit, libname)
    class(gosam_driver_t), intent(in) :: object
    integer, intent(in) :: unit
    type(string_t), intent(in) :: libname
    write (unit, "(2A)")  "OLP_FILE = ", char (object%olp_file)
    write (unit, "(2A)")  "OLP_DIR = ", char (object%olp_dir)
    write (unit, "(A)")
    write (unit, "(A)")   "all: $(OLP_DIR)/config.log"
    write (unit, "(4A)")   TAB, "make ", &
         char (object%loop_archive%os_data%makeflags), &
         " -C $(OLP_DIR) install"
    write (unit, "(A)")
    write (unit, "(3A)")   "$(OLP_DIR)/config.log: "
    write (unit, "(4A)")  TAB, char (object%gosam_dir // "/bin/gosam.py "), &
                             "--olp $(OLP_FILE) --destination=$(OLP_DIR)", &
                             " -f -z"
    write (unit, "(3A)")  TAB, "cd $(OLP_DIR); ./autogen.sh --prefix=", &
         "$(dir $(abspath $(lastword $(MAKEFILE_LIST))))"
  end subroutine gosam_driver_write_makefile
@ %def gosam_driver_write_makefile
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_alpha_s => gosam_driver_set_alpha_s
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_alpha_s (driver, alpha_s)
     class(gosam_driver_t), intent(inout) :: driver
     real(default), intent(in) :: alpha_s
     integer :: ierr
     call driver%blha_olp_set_parameter &
              (c_char_'alphaS'//c_null_char, &
               dble (alpha_s), 0._double, ierr)
  end subroutine gosam_driver_set_alpha_s

@ %def gosam_driver_set_alpha_s
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_alpha_qed => gosam_driver_set_alpha_qed
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_alpha_qed (driver, alpha)
    class(gosam_driver_t), intent(inout) :: driver
    real(default), intent(in) :: alpha
    integer :: ierr
    call driver%blha_olp_set_parameter &
       (c_char_'alpha'//c_null_char, &
        dble (alpha), 0._double, ierr)
    if (ierr == 0) call parameter_error_message (var_str ('alpha'))
  end subroutine gosam_driver_set_alpha_qed

@ %def gosam_driver_set_alpha_qed
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_GF => gosam_driver_set_GF
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_GF (driver, GF)
    class(gosam_driver_t), intent(inout) :: driver
    real(default), intent(in) :: GF
    integer :: ierr 
    call driver%blha_olp_set_parameter &
       (c_char_'GF'//c_null_char, &
        dble(GF), 0._double, ierr)
    if (ierr == 0) call parameter_error_message (var_str ('GF'))
  end subroutine gosam_driver_set_GF

@ %def gosam_driver_set_GF
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: set_weinberg_angle => gosam_driver_set_weinberg_angle
<<prc gosam: procedures>>=
  subroutine gosam_driver_set_weinberg_angle (driver, sw2)
    class(gosam_driver_t), intent(inout) :: driver
    real(default), intent(in) :: sw2
    integer :: ierr 
    call driver%blha_olp_set_parameter &
       (c_char_'sw2'//c_null_char, &
        dble(sw2), 0._double, ierr)
    if (ierr == 0) call parameter_error_message (var_str ('sw2'))
  end subroutine gosam_driver_set_weinberg_angle

@ %def gosam_driver_set_weinberg_angle
@
<<prc gosam: gosam driver: TBP>>=
  procedure :: print_alpha_s => gosam_driver_print_alpha_s
<<prc gosam: procedures>>=
  subroutine gosam_driver_print_alpha_s (object)
    class(gosam_driver_t), intent(in) :: object
    call object%blha_olp_print_parameter (c_char_'alphaS'//c_null_char)
  end subroutine gosam_driver_print_alpha_s

@ %def gosam_driver_print_alpha_s
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: prepare_library => prc_gosam_prepare_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_prepare_library (object, os_data, libname)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in) :: libname
    logical :: lib_found
    select type (writer => object%def%writer)
    type is (gosam_writer_t)
       call writer%write_config ()
    end select
    call object%search_for_existing_library (os_data, lib_found)
    call object%create_olp_library (libname, lib_found)
    call object%load_driver (os_data, .not. lib_found)
  end subroutine prc_gosam_prepare_library

@ %def prc_gosam_prepare_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: search_for_existing_library => &
                      prc_gosam_search_for_existing_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_search_for_existing_library (object, os_data, found)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: found
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%loop_archive%search ([driver%olp_file, &
            var_str ('golem.in'), driver%olp_dir // &
            '/.libs/libgolem_olp.' // os_data%shrlib_ext], found)
    end select
  end subroutine prc_gosam_search_for_existing_library

@ %def prc_gosam_search_for_exsting_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: write_makefile => prc_gosam_write_makefile
<<prc gosam: procedures>>=
  subroutine prc_gosam_write_makefile (object, unit, libname)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in) :: unit
    type(string_t), intent(in) :: libname
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%write_makefile (unit, libname)
    end select
  end subroutine prc_gosam_write_makefile

@ %def prc_gosam_write_makefile
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: execute_makefile => prc_gosam_execute_makefile
<<prc gosam: procedures>>=
  subroutine prc_gosam_execute_makefile (object, libname)
    class(prc_gosam_t), intent(in) :: object
    type(string_t), intent(in) :: libname
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call os_system_call ("make " // &
            driver%loop_archive%os_data%makeflags // " -f " // &
            char (libname // "_gosam.makefile"))
    end select
  end subroutine prc_gosam_execute_makefile

@ %def prc_gosam_execute_makefile
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: create_olp_library => prc_gosam_create_olp_library
<<prc gosam: procedures>>=
  subroutine prc_gosam_create_olp_library (object, libname, lib_exists)
    class(prc_gosam_t), intent(inout) :: object
    type(string_t), intent(in) :: libname
    logical, intent(in) :: lib_exists
    integer :: unit
    select type (driver => object%driver)
    type is (gosam_driver_t)
       if (lib_exists) then
          call driver%loop_archive%restore (driver%olp_file, driver%contract_file, &
                                            driver%olp_dir)
       else
          unit = free_unit ()
          open (unit, file = char (libname // "_gosam.makefile"), &
               status = "replace", action= "write")
          call object%write_makefile (unit, libname)
          close (unit)
          call object%execute_makefile (libname)
       end if
    end select
  end subroutine prc_gosam_create_olp_library

@ %def prc_gosam_create_olp_library
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: load_driver => prc_gosam_load_driver
<<prc gosam: procedures>>=
  subroutine prc_gosam_load_driver (object, os_data, store)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: store
    logical :: dl_success
    type(string_t) :: libname

    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%load (os_data, dl_success)
       if (.not. dl_success) &
          call msg_fatal ("Error: GoSam Libraries could not be loaded")
       if (store .and. dl_success) then
          libname = driver%olp_dir // '/.libs/libgolem_olp.' // &
             os_data%shrlib_ext
          call driver%loop_archive%record (driver%olp_file, driver%contract_file, &
               var_str ('golem.in'), libname)
       end if
    end select
  end subroutine prc_gosam_load_driver

@ %def prc_gosam_load_driver
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: start => prc_gosam_start
<<prc gosam: procedures>>=
  subroutine prc_gosam_start (object)
    class(prc_gosam_t), intent(inout) :: object
    integer :: ierr
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%blha_olp_start (char (driver%contract_file), ierr)
    end select
  end subroutine prc_gosam_start

@ %def prc_gosam_start
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: write => prc_gosam_write
<<prc gosam: procedures>>=
  subroutine prc_gosam_write (object, unit)
    class(prc_gosam_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message (unit = unit, string = "GOSAM")
  end subroutine prc_gosam_write

@
@ %def prc_gosam_write
<<prc gosam: prc gosam: TBP>>=
  procedure :: init_driver => prc_gosam_init_driver
<<prc gosam: procedures>>=
  subroutine prc_gosam_init_driver (object, os_data)
    class(prc_gosam_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: olp_file, olc_file, olp_dir

    select type (def => object%def)
    type is (gosam_def_t)
      olp_file = def%basename // def%suffix // '.olp'
      olc_file = def%basename // def%suffix // '.olc'
      olp_dir = def%basename // def%suffix // '_olp_modules'
    class default
      call msg_bug ("prc_gosam_init_driver: core_def should be of gosam-type")
    end select

    select type(driver => object%driver)
    type is (gosam_driver_t)
      call driver%init_gosam (os_data, olp_file, olc_file, olp_dir, &
           var_str ("libgolem_olp"))
    end select
  end subroutine prc_gosam_init_driver

@ %def prc_gosam_init_driver
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: set_initialized => prc_gosam_set_initialized
<<prc gosam: procedures>>=
  subroutine prc_gosam_set_initialized (prc_gosam)
    class(prc_gosam_t), intent(inout) :: prc_gosam
    prc_gosam%initialized = .true.
  end subroutine prc_gosam_set_initialized

@ %def prc_gosam_set_initialized
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_born => prc_gosam_compute_sqme_born
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_born &
         (object, i_born, p, mu, sqme, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_born
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: mu
    real(default), intent(out) :: sqme
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(default) :: acc_born
    real(double), dimension(OLP_RESULTS_LIMIT) :: r

    real(double) :: mu_dble
    real(double) :: acc_dble
    real(default) :: alpha_s

    mom = object%create_momentum_array (p)
    mu_dble = dble(mu)
    alpha_s = object%qcd%alpha%get (mu)

    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       if (allocated (object%i_born)) then
          call driver%blha_olp_eval2 (object%i_born(i_born), mom, mu_dble, r, acc_dble)
          sqme = r(4)
       else
          sqme = 0._default
          acc_dble = 0._default
       end if
    end select
    acc_born = acc_dble
    bad_point = acc_born > object%maximum_accuracy
  end subroutine prc_gosam_compute_sqme_born

@ %def prc_gosam_compute_sqme_born
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_real => prc_gosam_compute_sqme_real
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_real &
         (object, i_flv, p, ren_scale, sqme, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(out) :: sqme
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(OLP_RESULTS_LIMIT) :: r
    real(double) :: mu_dble, acc_dble
    real(default) :: acc, alpha_s
    mom = object%create_momentum_array (p)
    if (vanishes (ren_scale)) &
       call msg_fatal ("prc_gosam_compute_sqme_real: ren_scale vanishes")
    mu_dble = dble(ren_scale)
    alpha_s = object%qcd%alpha%get (ren_scale)
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       call driver%blha_olp_eval2 (object%i_real(i_flv), mom, &
                                    mu_dble, r, acc_dble)
       sqme = r(4)
    end select
    acc = acc_dble
    if (acc > object%maximum_accuracy) bad_point = .true.
  end subroutine prc_gosam_compute_sqme_real

@ %def prc_gosam_compute_sqme_real
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: compute_sqme_sc => prc_gosam_compute_sqme_sc
<<prc gosam: procedures>>=
  subroutine prc_gosam_compute_sqme_sc (object, &
                i_flv, em, p, ren_scale, &
            me_sc, bad_point)
    class(prc_gosam_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    integer, intent(in) :: em
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    complex(default), intent(out) :: me_sc
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(OLP_RESULTS_LIMIT) :: r
    real(double) :: ren_scale_dble
    integer :: i, igm1, n
    integer :: pos_real, pos_imag
    real(double) :: acc_dble
    real(default) :: acc, alpha_s

    me_sc = cmplx (zero ,zero, kind=default)
    mom = object%create_momentum_array (p)
    if (vanishes (ren_scale)) &
       call msg_fatal ("prc_gosam_compute_sqme_sc: ren_scale vanishes")
    alpha_s = object%qcd%alpha%get (ren_scale)
    ren_scale_dble = dble (ren_scale)
    select type (driver => object%driver)
    type is (gosam_driver_t)
       call driver%set_alpha_s (alpha_s)
       call driver%blha_olp_eval2 (object%i_sc(i_flv), &
            mom, ren_scale_dble, r, acc_dble)
    end select

@ The BLHA-interface conventions require the quantity $S_{ij} = \langle M_{i,+}|T_iT_j|M_{i,-}\rangle$ to be
  produced, where $i$ is the position of the splitting gluon. However, $\tilde{M} = \langle M_{i,-}|M_{i,+}\rangle$
  is needed. This can be obtained using color conservation, $\sum_{j} T_j|M\rangle = 0$, so that
  \begin{equation*}
    \sum_{j \neq i} S_{ij} = -\langle M_{i,+}|T_i^2|M_{i,-}\rangle = -C_A \langle M_{i,+}|M_{i,-}\rangle = -C_A \tilde{M}^*
  \end{equation*}
  According to BLHA conventions, the real part of $S_{ij}$ is located at positions $2i + 2nj$ in the output array, where
  $n$ denotes the number of external particles and the enumeration of particles starts at zero.
  The subsequent position, i.e. $2i + 2nj + 1$ is designated to the imaginary part of $S_{ij}$. Note that, since the first
  array position is 1, the implemented position association deviates from the above one in the addition of 1.
<<prc gosam: procedures>>=
    igm1 = em - 1
    n = size(p)
    do i = 0, n - 1
      pos_real = 2 * igm1 + 2 * n*i + 1
      pos_imag = pos_real + 1
      me_sc = me_sc + cmplx (r(pos_real), r(pos_imag), default)
    end do

    me_sc = - conjg(me_sc) / CA

    acc = acc_dble
    if (acc > object%maximum_accuracy) bad_point = .true.
  end subroutine prc_gosam_compute_sqme_sc

@ %def prc_gosam_compute_sqme_sc
@
<<prc gosam: prc gosam: TBP>>=
  procedure :: allocate_workspace => prc_gosam_allocate_workspace
<<prc gosam: procedures>>=
  subroutine prc_gosam_allocate_workspace (object, core_state)
    class(prc_gosam_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (gosam_state_t :: core_state)
  end subroutine prc_gosam_allocate_workspace

@ %def prc_gosam_allocate_workspace
@
<<prc gosam: gosam state: TBP>>=
  procedure :: write => gosam_state_write
<<prc gosam: procedures>>=
  subroutine gosam_state_write (object, unit)
    class(gosam_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_warning (unit = unit, string = "gosam_state_write: What to write?")
  end subroutine gosam_state_write

@ %def prc_gosam_state_write
@

