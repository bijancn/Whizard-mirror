% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{BLHA Interface}

The code in this chapter implements support for the BLHA record that
communicates data for NLO processes.

These are the modules:
\begin{description}
\item[blha\_config]
\item[blha\_interface]
\item[blha\_driver]
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module definition}

These modules implement the communication with one loop matrix element providers
according to the Binoth LesHouches Accord Interface. The actual matrix
element(s) are loaded as a dynamic library.

This module defines the common OLP-interfaces defined through the Binoth Les-Houches 
accord.

<<[[blha_olp_interfaces.f90]]>>=
<<File header>>

module blha_olp_interfaces

  use, intrinsic :: iso_c_binding !NODEP!
  use, intrinsic :: iso_fortran_env

  use kinds
<<Use strings>>
  use constants
  use unit_tests, only: vanishes
  use io_units
  use string_utils
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use sm_qcd
  use interactions
  use flavors
  use model_data
  use pdg_arrays, only: is_gluon, is_quark

  use prclib_interfaces
  use process_libraries
  use prc_core_def
  use prc_core

  use prc_user_defined

  use blha_config

<<Standard module head>>

<<BLHA OLP interfaces: public>>

<<BLHA OLP interfaces: public parameters>>

<<BLHA OLP interfaces: parameters>>

<<BLHA OLP interfaces: types>>

<<BLHA OLP interfaces: interfaces>>

contains

<<BLHA OLP interfaces: procedures>>

end module blha_olp_interfaces

@ %def module blha_olp_interfaces
@
<<BLHA OLP interfaces: public>>=
  public :: blha_template_t
<<BLHA OLP interfaces: types>>=
  type :: blha_template_t
    integer :: I_BORN = 0
    integer :: I_REAL = 1
    integer :: I_LOOP = 2
    integer :: I_SUB = 3
    logical, dimension(0:3) :: compute_component
    logical :: include_polarizations = .false.
    logical :: switch_off_muon_yukawas = .false.
  contains
  <<BLHA OLP interfaces: blha template: TBP>>
  end type blha_template_t

@ %def blha_template_t
@
<<BLHA OLP interfaces: parameters>>=
  integer, parameter :: I_ALPHA = 1
  integer, parameter :: I_GF = 2
  integer, parameter :: I_SW2 = 3

<<BLHA OLP interfaces: public>>=
  public :: prc_blha_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_user_defined_base_t) :: prc_blha_t
    integer :: n_particles
    integer, dimension(:), allocatable :: i_born, i_sc, i_cc
    integer, dimension(:), allocatable :: i_real
    integer, dimension(:), allocatable :: i_virt
    integer, dimension(:,:), allocatable :: i_hel
    logical, dimension(3) :: ew_parameter_mask
  contains
  <<BLHA OLP interfaces: prc blha: TBP>>
  end type prc_blha_t

@ 
@ %def prc_blha_t
<<BLHA OLP interfaces: public>>=
  public :: blha_driver_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (user_defined_driver_t) :: blha_driver_t 
    type(string_t) :: contract_file
    logical :: include_polarizations = .false.
    logical :: switch_off_muon_yukawas = .false.
    procedure(olp_start),nopass,  pointer :: &
              blha_olp_start => null ()
    procedure(olp_eval), nopass, pointer :: &
              blha_olp_eval => null()
    procedure(olp_info), nopass, pointer :: &
              blha_olp_info => null ()
    procedure(olp_set_parameter), nopass, pointer :: &
              blha_olp_set_parameter => null ()
    procedure(olp_eval2), nopass, pointer :: &
              blha_olp_eval2 => null ()
    procedure(olp_option), nopass, pointer :: &
              blha_olp_option => null ()
    procedure(olp_polvec), nopass, pointer :: &
              blha_olp_polvec => null ()
    procedure(olp_finalize), nopass, pointer :: &
              blha_olp_finalize => null ()
    procedure(olp_print_parameter), nopass, pointer :: &
              blha_olp_print_parameter => null ()
  contains
  <<BLHA OLP interfaces: blha driver: TBP>>
  end type blha_driver_t

@ 
@ %def blha_driver_t
<<BLHA OLP interfaces: public>>=
  public :: prc_blha_writer_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_user_defined_writer_t) :: prc_blha_writer_t
    type(blha_configuration_t) :: blha_cfg
  contains
  <<BLHA OLP interfaces: blha writer: TBP>>
  end type prc_blha_writer_t

@ 
@ %def prc_blha_writer_t
<<BLHA OLP interfaces: public>>=
  public :: blha_def_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (user_defined_def_t) :: blha_def_t
    type(string_t) :: suffix
  contains
  <<BLHA OLP interfaces: blha def: TBP>>
  end type blha_def_t

@ %def blha_def_t
@ 
<<BLHA OLP interfaces: public>>=
  public :: blha_state_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (user_defined_state_t) :: blha_state_t
  contains
  <<BLHA OLP interfaces: blha state: TBP>>
  end type blha_state_t

@ %def blha_state_t
@
<<BLHA OLP interfaces: blha state: TBP>>=
  procedure :: reset_new_kinematics => blha_state_reset_new_kinematics
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_state_reset_new_kinematics (object)
    class(blha_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine blha_state_reset_new_kinematics

@ %def blha_state_reset_new_kinematics
@
<<BLHA OLP interfaces: public parameters>>=
  integer, parameter, public :: OLP_PARAMETER_LIMIT = 10
  integer, parameter, public :: OLP_MOMENTUM_LIMIT = 50
  integer, parameter, public :: OLP_RESULTS_LIMIT = 60

<<BLHA OLP interfaces: public>>=
  public :: olp_start
<<BLHA OLP interfaces: interfaces>>=
  interface 
    subroutine olp_start (contract_file_name, ierr) bind (C,name="OLP_Start")
      import
      character(kind=c_char, len=1), intent(in) :: contract_file_name
      integer(kind=c_int), intent(out) :: ierr
    end subroutine olp_start
  end interface

@ %def olp_start_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval (label, momenta, mu, parameters, res) &
         bind (C,name="OLP_EvalSubProcess")
      import
      integer(kind=c_int), value, intent(in) :: label
      real(kind=c_double), value, intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: &
           momenta
      real(kind=c_double), dimension(OLP_PARAMETER_LIMIT), intent(in) :: &
           parameters
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
    end subroutine olp_eval
  end interface

@ %def olp_eval interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_info
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_info (olp_file, olp_version, message) bind(C)
      import
      character(kind=c_char), intent(inout), dimension(15) :: olp_file
      character(kind=c_char), intent(inout), dimension(15) :: olp_version
      character(kind=c_char), intent(inout), dimension(255) :: message
    end subroutine olp_info
  end interface

@ %def olp_info interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_set_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_set_parameter &
         (variable_name, real_part, complex_part, success) bind(C)
      import
      character(kind=c_char,len=1), intent(in) :: variable_name
      real(kind=c_double), intent(in) :: real_part, complex_part
      integer(kind=c_int), intent(out) :: success
    end subroutine olp_set_parameter
  end interface

@ %def olp_set_parameter_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval2
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval2 (label, momenta, mu, res, acc) bind(C)
      import
      integer(kind=c_int), intent(in) :: label
      real(kind=c_double), intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
      real(kind=c_double), intent(out) :: acc
    end subroutine olp_eval2
  end interface

@ %def olp_eval2 interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_option
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_option (line, stat) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: line
      integer(kind=c_int), intent(out) :: stat
    end subroutine
  end interface

@ %def olp_option_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_polvec
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_polvec (p, q, eps) bind(C)
      import
      real(kind=c_double), dimension(0:3), intent(in) :: p, q
      real(kind=c_double), dimension(0:7), intent(out) :: eps
    end subroutine
  end interface

@ %def olp_polvec_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_finalize
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_finalize () bind(C)
      import
    end subroutine olp_finalize
  end interface

@ %def olp_finalize_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_print_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_print_parameter (filename) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: filename
    end subroutine olp_print_parameter
  end interface

@ %def olp_print_parameter_interface
@
<<BLHA OLP interfaces: public>>=
  public :: blha_result_array_size
<<BLHA OLP interfaces: procedures>>=
  pure function blha_result_array_size (n_part, amp_type) result (rsize)
    integer, intent(in) :: n_part, amp_type
    integer :: rsize
    select case (amp_type)
       case (BLHA_AMP_TREE)
          rsize = 1
       case (BLHA_AMP_LOOP)
          rsize = 4
       case (BLHA_AMP_CC)
          rsize = n_part*(n_part-1)/2
       case (BLHA_AMP_SC)
          rsize = 2*n_part**2
       case default
          rsize = 0
     end select
  end function blha_result_array_size

@ %def blha_result_array_size
@     
<<BLHA OLP interfaces: public>>=
!  public :: create_blha_momentum_array
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: create_momentum_array => prc_blha_create_momentum_array
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_create_momentum_array (object, p) result (mom)
    class(prc_blha_t), intent(in) :: object
    type(vector4_t), intent(in), dimension(:) :: p
    real(double), dimension(5*object%n_particles) :: mom
    integer :: n, i, k

    n = size (p)
    if (n > 10) call msg_fatal ("Number of external particles exceeds" &
                                 // "size of BLHA-internal momentum array")
    mom = 0._default
    k = 1
    do i = 1, n
       mom(k:k+3) = vector4_get_components (p(i))
       mom(k+4) = invariant_mass (p(i))
       k = k+5
    end do
!    mom (k:50) = 0.0
  end function prc_blha_create_momentum_array

@ %def prc_blha_create_momentum_array
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: init => blha_template_init
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_init (template, requires_polarizations, &
       switch_off_muon_yukawas)
    class(blha_template_t), intent(inout) :: template
    logical, intent(in) :: requires_polarizations, switch_off_muon_yukawas
    template%compute_component = .false.
    template%include_polarizations = requires_polarizations
    template%switch_off_muon_yukawas = switch_off_muon_yukawas
  end subroutine blha_template_init

@ %def blha_template_init
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: set_born => blha_template_set_born
  procedure :: set_real_trees => blha_template_set_real_trees
  procedure :: set_loop => blha_template_set_loop
  procedure :: set_subtraction => blha_template_set_subtraction
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_set_born (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component (template%I_BORN) = .true.
  end subroutine blha_template_set_born

  subroutine blha_template_set_real_trees (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component (template%I_REAL) = .true.
  end subroutine blha_template_set_real_trees

  subroutine blha_template_set_loop (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component(template%I_LOOP) = .true.
  end subroutine blha_template_set_loop

  subroutine blha_template_set_subtraction (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component (template%I_SUB) = .true.
  end subroutine blha_template_set_subtraction

@ %def blha_template_set_components
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: compute_born => blha_template_compute_born
  procedure :: compute_real_trees => blha_template_compute_real_trees
  procedure :: compute_loop => blha_template_compute_loop
  procedure :: compute_subtraction => blha_template_compute_subtraction
<<BLHA OLP interfaces: procedures>>=
  function blha_template_compute_born (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_BORN)
  end function blha_template_compute_born

  function blha_template_compute_real_trees (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_REAL)
  end function blha_template_compute_real_trees

  function blha_template_compute_loop (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_LOOP)
  end function blha_template_compute_loop  

  function blha_template_compute_subtraction (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_SUB)
  end function blha_template_compute_subtraction

@ %def blha_template_compute
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: check => blha_template_check
<<BLHA OLP interfaces: procedures>>=
  function blha_template_check (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = count (template%compute_component) == 1
  end function blha_template_check

@ %def blha_template_check
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: reset => blha_template_reset
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_reset (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component = .false.
  end subroutine blha_template_reset

@ %def blha_template_reset
@
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write => prc_blha_writer_write
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_writer_write (writer, unit)
    class(prc_blha_writer_t), intent(in) :: writer
    integer, intent(in) :: unit    
    write (unit, "(1x,A)")  char (writer%get_process_string ())
  end subroutine prc_blha_writer_write

@
@ %def prc_blha_writer_write
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: get_process_string => prc_blha_writer_get_process_string
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_get_process_string (writer) result (s_proc)
    class(prc_blha_writer_t), intent(in) :: writer
    type(string_t) :: s_proc
    s_proc = var_str ("") 
  end function prc_blha_writer_get_process_string

@ %def gosam_writer_get_process_string
@
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: get_n_proc => prc_blha_writer_get_n_proc
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_get_n_proc (writer) result (n_proc)
    class(prc_blha_writer_t), intent(in) :: writer
    integer :: n_proc
    n_proc = blha_configuration_get_n_proc (writer%blha_cfg)
  end function prc_blha_writer_get_n_proc

@ %def prc_blha_writer_get_n_proc
@     
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_set_GF), deferred :: &
     set_GF
<<BLHA OLP interfaces: interfaces>>=
  abstract interface 
    subroutine blha_driver_set_GF (driver, GF)
      import
      class(blha_driver_t), intent(inout) :: driver
      real(default), intent(in) :: GF
    end subroutine blha_driver_set_GF
  end interface

@ %def blha_driver_set_GF
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_set_alpha_s), deferred :: &
     set_alpha_s
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_set_alpha_s (driver, alpha_s)
       import
       class(blha_driver_t), intent(inout) :: driver
       real(default), intent(in) :: alpha_s
    end subroutine blha_driver_set_alpha_s
  end interface

@ %def set_alpha_s interface
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_set_weinberg_angle), deferred :: &
     set_weinberg_angle
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_set_weinberg_angle (driver, sw2)
      import
      class(blha_driver_t), intent(inout) :: driver
      real(default), intent(in) :: sw2
    end subroutine blha_driver_set_weinberg_angle
  end interface

@ %def blha_driver_set_weinberg_angle
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_set_alpha_qed), deferred :: set_alpha_qed
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_set_alpha_qed (driver, alpha)
      import
      class(blha_driver_t), intent(inout) :: driver
      real(default), intent(in) :: alpha
    end subroutine blha_driver_set_alpha_qed
  end interface

@ %def blha_driver_set_alpha_qed
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_print_alpha_s), deferred :: &
     print_alpha_s
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_print_alpha_s (object)
      import
      class(blha_driver_t), intent(in) :: object
    end subroutine blha_driver_print_alpha_s
  end interface

@ %def print_alpha_s interface
@
<<BLHA OLP interfaces: public>>=
  public :: parameter_error_message
<<BLHA OLP interfaces: procedures>>=
  subroutine parameter_error_message (par)
     type(string_t), intent(in) :: par
     type(string_t) :: message
     message = "Setting of parameter " // par &
        // "failed. This happens because the chosen " &
        // "EWScheme in the BLHA file does not fit " &
        // "your parameter choice"
     call msg_fatal (char (message))
  end subroutine parameter_error_message

@ %def parameter_error_message
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: set_mass_and_width => blha_driver_set_mass_and_width
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_set_mass_and_width (driver, &
                                       i_pdg, mass, width)
    class(blha_driver_t), intent(inout) :: driver
    integer, intent(in) :: i_pdg
    real(default), intent(in), optional :: mass
    real(default), intent(in), optional :: width
    type(string_t) :: buf
    character(kind=c_char,len=20) :: c_string
    integer :: ierr
    if (present (mass)) then
       buf = 'mass(' // str (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%blha_olp_set_parameter &
                (c_string, dble(mass), 0._double, ierr)
       if (ierr == 0) then
          buf = "BLHA driver: Attempt to set mass of particle " // &
                str (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
    if (present (width)) then
       buf = 'width(' // str (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%blha_olp_set_parameter &
                (c_string, dble(width), 0._double, ierr)
       if (ierr == 0) then
          buf = "BLHA driver: Attempt to set width of particle " // &
                str (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
  end subroutine blha_driver_set_mass_and_width

@ %def blha_driver_set_mass_and_width
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_init_dlaccess_to_library), deferred :: &
    init_dlaccess_to_library
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_init_dlaccess_to_library &
       (object, os_data, dlaccess, success)
      import
      class(blha_driver_t), intent(in) :: object
      type(os_data_t), intent(in) :: os_data
      type(dlaccess_t), intent(out) :: dlaccess
      logical, intent(out) :: success
    end subroutine blha_driver_init_dlaccess_to_library
  end interface
      
@ %def interface blha_driver_init_dlaccess_to_library
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: load => blha_driver_load
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_load (object, os_data, success)
    class(blha_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: success
    type(dlaccess_t) :: dlaccess
    type(c_funptr) :: c_fptr
    logical :: init_success

    call object%init_dlaccess_to_library (os_data, dlaccess, init_success)

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Start"))
    call c_f_procpointer (c_fptr, object%blha_olp_start)
    call check_for_error (var_str ("OLP_Start"))
    
    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess"))
    call c_f_procpointer (c_fptr, object%blha_olp_eval)
    call check_for_error (var_str ("OLP_EvalSubProcess"))

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Info"))
    call c_f_procpointer (c_fptr, object%blha_olp_info)
    call check_for_error (var_str ("OLP_Info"))

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_SetParameter"))
    call c_f_procpointer (c_fptr, object%blha_olp_set_parameter)
    call check_for_error (var_str ("OLP_SetParameter"))

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess2"))
    call c_f_procpointer (c_fptr, object%blha_olp_eval2)
    call check_for_error (var_str ("OLP_EvalSubProcess2"))

    !!! Is OLP_Option really not implemented in OpenLoops?
    !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Option"))
    !!! call c_f_procpointer (c_fptr, object%blha_olp_option)
    !!! call check_for_error (var_str ("OLP_Option"))

    !!! Is OLP_Polvec really not implemented in OpenLoops?
    !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Polvec"))
    !!! call c_f_procpointer (c_fptr, object%blha_olp_polvec)
    !!! call check_for_error (var_str ("OLP_Polvec"))

    !!! Is OLP_Finalize really not implemented in OpenLoops?
    !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Finalize"))
    !!! call c_f_procpointer (c_fptr, object%blha_olp_finalize)
    !!! call check_for_error (var_str ("OLP_Finalize"))

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_PrintParameter"))
    call c_f_procpointer (c_fptr, object%blha_olp_print_parameter)
    call check_for_error (var_str ("OLP_PrintParameter"))

    success = .true.
    contains
      subroutine check_for_error (function_name)
        type(string_t), intent(in) :: function_name
        if (dlaccess_has_error (dlaccess)) &
           call msg_fatal (char ("Loading of " // function_name // " failed!"))
     end subroutine check_for_error
  end subroutine blha_driver_load

@ %def blha_driver_load
@
<<BLHA OLP interfaces: parameters>>=
  integer, parameter :: LEN_MAX_FLAVOR_STRING = 100
  integer, parameter :: N_MAX_FLAVORS = 20
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: read_contract_file => blha_driver_read_contract_file
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_read_contract_file (driver, flavors, amp_type, flv_index, label, helicities)
    class(blha_driver_t), intent(inout) :: driver
    integer, intent(in), dimension(:,:) :: flavors
    integer, intent(out), dimension(N_MAX_FLAVORS) :: amp_type, flv_index, label
    integer, intent(out), dimension(N_MAX_FLAVORS,2) :: helicities
    integer :: unit, filestat
    character(len=LEN_MAX_FLAVOR_STRING) :: rd_line 
    logical :: read_flavor, born_found
    integer :: k, i_flv
    integer :: i_hel
    integer :: i_next, n_entries
    integer, dimension(size(flavors, 1) + 2) :: i_array
    integer, dimension(size(flavors, 1) + 2) :: hel_array
    integer, parameter :: NO_NUMBER = -1000
    integer, parameter :: PROC_NOT_FOUND = -1001

    amp_type = -1; flv_index = -1; label = -1
    helicities = 0
    n_entries = size(flavors, 1) + 2
    unit = free_unit ()
    open (unit, file=char(driver%contract_file), status="old") 
    read_flavor=.false.
    k = 1
    i_hel = 0
    do
      read (unit, "(A)", iostat = filestat) rd_line
      if (filestat == iostat_end) then
         exit
      else
         if (rd_line(1:13) == 'AmplitudeType') then
            if (i_hel > 3) i_hel = 0
            i_next = find_next_word_index (rd_line, 13) 
            if (rd_line(i_next : i_next + 4) == 'Loop') then
               amp_type(k) = BLHA_AMP_LOOP
            else if (rd_line(i_next : i_next + 4) == 'Tree') then
               amp_type(k) = BLHA_AMP_TREE
            else if (rd_line(i_next : i_next + 6) == 'ccTree') then
               amp_type(k) = BLHA_AMP_CC
            else if (rd_line(i_next : i_next + 6) == 'scTree') then
               amp_type(k) = BLHA_AMP_SC
            else
               call msg_fatal ("AmplitudeType present but &
                               &AmpType not known!")
            end if
            read_flavor = .true.
         else if (read_flavor) then
            born_found = .false.
            i_array = create_flavor_string (rd_line, n_entries)           
            if (driver%include_polarizations) then
               hel_array = create_helicity_string (rd_line, n_entries)
               call check_helicity_array (hel_array, n_entries)
            else
               hel_array = 0
            end if
            if (all (i_array == PROC_NOT_FOUND)) &
               call msg_fatal ("The desired process has not been found ",  &
                    [var_str ("by the OLP-Provider. Maybe the value of alpha_power "), &
                     var_str ("or alphas_power does not correspond to the process. "), &
                     var_str ("If you are using OpenLoops, you can set the option "), &
                     var_str ("openloops_verbosity to a value larger than 1 to obtain "),  &
                     var_str ("more information")])
               do i_flv = 1, size (flavors, 2)
                   if (all (i_array (1 : n_entries - 2) == flavors (:,i_flv))) then
                      label(k) = i_array (n_entries)
                      flv_index (k) = i_flv + i_hel
                      if (driver%include_polarizations) then
                         helicities (label(k), 1) = hel_array (1)
                         helicities (label(k), 2) = hel_array (2)
                         i_hel = i_hel + 1
                      end if
                      born_found = .true.
                      k = k + 1
                      read_flavor = .false.
                      exit
                   end if
               end do
            if (.not. born_found) call msg_fatal & 
                     ("No underlying Born found")
         end if   
      end if
    end do
    close(unit)
  contains

    function create_flavor_string (s, n_entries) result (i_array)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(in) :: n_entries
      integer, dimension(n_entries) :: i_array
      integer :: k, current_position
      integer :: i_entry
      k = 1; current_position = 1
      do
         if (current_position > LEN_MAX_FLAVOR_STRING) &
            call msg_fatal ("Read OLC File: Current position exceeds maximum value")
         if (s(current_position:current_position) /= " ") then
            call create_flavor (s, i_entry, current_position)
            if (i_entry /= NO_NUMBER .and. i_entry /= PROC_NOT_FOUND) then
               i_array(k) = i_entry
               k = k + 1
               if (k > n_entries) then
                  return
               else
                  call increment_current_position (s, current_position)
               end if
            else if (i_entry == PROC_NOT_FOUND) then
               i_array = PROC_NOT_FOUND
               return 
            else
               call increment_current_position (s, current_position)
            end if
         else
            call increment_current_position (s, current_position)
         end if
      end do
    end function create_flavor_string

    function create_helicity_string (s, n_entries) result (hel_array)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(in) :: n_entries
      integer, dimension(n_entries) :: hel_array
      integer :: k, current_position
      integer :: hel
      k = 1; current_position = 1
      do 
         if (current_position > LEN_MAX_FLAVOR_STRING) &
            call msg_fatal ("Read OLC File: Current position exceeds maximum value")
         if (s(current_position:current_position) /= " ") then
            call create_helicity (s, hel, current_position)
            if (hel >= -1 .and. hel <= 1) then
               hel_array(k) = hel
               k = k + 1
               if (k > n_entries) then
                  return
               else
                  call increment_current_position (s, current_position)
               end if
            else
               call increment_current_position (s, current_position)
            end if
         else
            call increment_current_position (s, current_position)
         end if
      end do 
    end function create_helicity_string

    subroutine increment_current_position (s, current_position)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(inout) :: current_position
      current_position = find_next_word_index (s, current_position)
    end subroutine increment_current_position

    subroutine get_next_buffer (s, current_position, buf, last_buffer_index)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(inout) :: current_position
      character(len=10), intent(out) :: buf
      integer, intent(out) :: last_buffer_index
      integer :: i
      i = 1; buf = ""
      do
         if (s(current_position:current_position) /= " ") then
            buf(i:i) = s(current_position:current_position)
            i = i + 1; current_position = current_position + 1
         else
            exit
         end if
      end do
      last_buffer_index = i
    end subroutine get_next_buffer

    function is_particle_buffer (buf, i) result (valid)
      logical :: valid
      character(len=10), intent(in) :: buf
      integer, intent(in) :: i
      valid = (buf(1:i-1) /= "->" .and. buf(1:i-1) /= "|" &
         .and. buf(1:i-1) /= "Process")
    end function is_particle_buffer
 
    subroutine create_flavor (s, i_particle, current_position)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(out) :: i_particle
      integer, intent(inout) :: current_position
      character(len=10) :: buf
      integer :: i, last_buffer_index
      call get_next_buffer (s, current_position, buf, last_buffer_index)
      i = last_buffer_index
      if (is_particle_buffer (buf, i)) then
         call strip_helicity (buf, i)
         i_particle = read_ival (var_str (buf(1:i-1)))
      else if (buf(1:i-1) == "Process") then
         i_particle = PROC_NOT_FOUND
      else
         i_particle = NO_NUMBER
      end if
    end subroutine create_flavor

    subroutine create_helicity (s, helicity, current_position)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: s
      integer, intent(out) :: helicity
      integer, intent(inout) :: current_position
      character(len=10) :: buf
      integer :: i, last_buffer_index
      logical :: success
      call get_next_buffer (s, current_position, buf, last_buffer_index)
      i = last_buffer_index
      if (is_particle_buffer (buf, i)) then
         call strip_flavor (buf, i, helicity, success)
      else
         helicity = 0
      end if
    end subroutine create_helicity

    subroutine strip_helicity (buf, i)
      character(len=10), intent(in) :: buf
      integer, intent(inout) :: i
      integer :: i_last
      i_last = i - 1
      if (i_last < 4) return
      if (buf(i_last-2:i_last) == "(1)") then
         i = i - 3
      else if (buf(i_last-3:i_last) == "(-1)") then
         i = i - 4
      end if
    end subroutine strip_helicity  

    subroutine strip_flavor (buf, i, helicity, success)
      character(len=10), intent(in) :: buf
      integer, intent(in) :: i
      integer, intent(out) :: helicity
      logical, intent(out) :: success
      integer :: i_last
      i_last = i - 1
      helicity = 0
      if (i_last < 4) return
      if (buf(i_last-2:i_last) == "(1)") then
         helicity = 1
         success = .true.
      else if (buf(i_last-3:i_last) == "(-1)") then
         helicity = -1
         success = .true.
      else
         success = .false.
      end if
    end subroutine strip_flavor
         
    function find_next_word_index (word, i_start) result (i_next)
      character(len=LEN_MAX_FLAVOR_STRING), intent(in) :: word
      integer, intent(in) :: i_start
      integer :: i_next
      i_next = i_start + 1
      do
         if (word(i_next:i_next) /= " ") then
            exit
         else
            i_next = i_next + 1
         end if
         if (i_next > LEN_MAX_FLAVOR_STRING) &
              call msg_fatal ("Find next word: line limit exceeded")
      end do
    end function find_next_word_index

    subroutine check_helicity_array (hel_array, n_entries)
      integer, intent(in), dimension(:) :: hel_array
      integer, intent(in) :: n_entries
      integer :: n_particles
      logical :: valid
      n_particles = n_entries - 2
      valid = all (hel_array (3:n_particles) == 0)
      valid = valid .and. &
         (hel_array(1) == 1 .or. hel_array(1) == -1) .and. &
         (hel_array(2) == 1 .or. hel_array(2) == -1)
      if (.not. valid) &
         call msg_fatal ("Invalid helicities encountered!")
    end subroutine check_helicity_array

  end subroutine blha_driver_read_contract_file

@ %def blha_driver_read_contract_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_alpha_qed => prc_blha_set_alpha_qed
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_alpha_qed (object, model)
    class(prc_blha_t), intent(inout) :: object
    type(model_data_t), intent(in), target :: model
    real(default) :: alpha
   
    alpha = one / model%get_real (var_str ('alpha_em_i'))

    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%set_alpha_qed (alpha)
    end select
  end subroutine prc_blha_set_alpha_qed

@ %def prc_blha_set_alpha_qed
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_GF => prc_blha_set_GF
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_GF (object, model)
    class(prc_blha_t), intent(inout) :: object
    type(model_data_t), intent(in), target :: model
    real(default) :: GF
    
    GF = model%get_real (var_str ('GF'))
    select type (driver => object%driver)
    class is (blha_driver_t)
      call driver%set_GF (GF)
    end select
  end subroutine prc_blha_set_GF

@ %def prc_blha_set_GF
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_weinberg_angle => prc_blha_set_weinberg_angle
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_weinberg_angle (object, model)
    class(prc_blha_t), intent(inout) :: object
    type(model_data_t), intent(in), target :: model
    real(default) :: sw2
    
    sw2 = model%get_real (var_str ('sw2'))
    select type (driver => object%driver)
    class is (blha_driver_t)
      call driver%set_weinberg_angle (sw2)
    end select
  end subroutine prc_blha_set_weinberg_angle

@ %def prc_blha_set_weinberg_angle
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_electroweak_parameters => &
     prc_blha_set_electroweak_parameters
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_electroweak_parameters (object, model)
     class(prc_blha_t), intent(inout) :: object
     type(model_data_t), intent(in), target :: model
     if (object%ew_parameter_mask (I_ALPHA)) call object%set_alpha_qed (model)
     if (object%ew_parameter_mask (I_GF)) call object%set_GF (model)
     if (object%ew_parameter_mask (I_SW2)) call object%set_weinberg_angle (model)
  end subroutine prc_blha_set_electroweak_parameters

@ %def prc_blha_set_electrweak_parameters
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: read_contract_file => prc_blha_read_contract_file
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_read_contract_file (object, flavors)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in), dimension(:,:) :: flavors
    integer, dimension(N_MAX_FLAVORS) :: amp_type, flv_index, label
    integer, dimension(N_MAX_FLAVORS,2) :: helicities
    integer :: i_proc
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%read_contract_file (flavors, amp_type, flv_index, label, helicities)
    end select
    do i_proc = 1, size (amp_type)
       if (amp_type (i_proc) < 0) exit
       select case (amp_type (i_proc))
       case (BLHA_AMP_TREE)
          if (allocated (object%i_born)) then
             object%i_born(flv_index(i_proc)) = label(i_proc)
          else if (allocated (object%i_real)) then
             object%i_real(flv_index(i_proc)) = label(i_proc)
          else 
             call msg_fatal ("Tree matrix element present, &
                  &but neither Born nor real indices are allocated!")
          end if
       case (BLHA_AMP_CC)
          if (allocated (object%i_cc)) then
             object%i_cc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Color-correlated matrix element present, &
                  &but cc-indices are not allocated!")
          end if
          if (allocated (object%i_hel)) &
             object%i_hel (flv_index(i_proc), :) = helicities (label(i_proc), :)
       case (BLHA_AMP_SC)
          if (allocated (object%i_sc)) then
             object%i_sc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Spin-correlated matrix element present, &
                  &but sc-indices are not allocated!")
          end if
       case (BLHA_AMP_LOOP)
          if (allocated (object%i_virt)) then
             object%i_virt(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Loop matrix element present, &
                  &but virt-indices are not allocated!")
          end if
          if (allocated (object%i_hel)) &
             object%i_hel (flv_index(i_proc), :) = helicities (label(i_proc), :)
       case default
          call msg_fatal ("Undefined amplitude type")
       end select
    end do
  end subroutine prc_blha_read_contract_file

@ %def prc_blha_read_contract_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: print_parameter_file => prc_blha_print_parameter_file
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_print_parameter_file (object)
    class(prc_blha_t), intent(in) :: object
    type(string_t) :: filename
    
    select type (def => object%def)
    class is (blha_def_t)
       filename = def%basename // '.olp_parameters'
    end select
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%blha_olp_print_parameter (char(filename)//c_null_char)
    end select
  end subroutine prc_blha_print_parameter_file

@ %def prc_blha_print_parameter_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_amplitude => prc_blha_compute_amplitude
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_blha_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    class is (blha_state_t)
      core_state%alpha_qcd = object%qcd%alpha%get (fac_scale)
    end select
    amp = 0.0
  end function prc_blha_compute_amplitude

@
@ %def prc_blha_compute_amplitude
<<BLHA OLP interfaces: prc blha: TBP>>=
   procedure :: init_blha => prc_blha_init_blha
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_init_blha (object, blha_template)
    class(prc_blha_t), intent(inout) :: object
    type(blha_template_t), intent(inout) :: blha_template
    logical :: include_polarizations 
    object%n_particles = size (object%data%flv_state, 1)
    object%n_flv = size (object%data%flv_state, 2)
    include_polarizations = blha_template%include_polarizations
    if (blha_template%compute_loop ()) then
       if (include_polarizations) then
          allocate (object%i_virt (object%n_flv * 4), &
                    object%i_cc (object%n_flv * 4))
          allocate (object%i_hel (object%n_flv * 4, 2))
       else
          allocate (object%i_virt (object%n_flv), &
                    object%i_cc (object%n_flv))
       end if
    else if (blha_template%compute_subtraction ()) then
       allocate (object%i_born (object%n_flv), &
                 object%i_cc (object%n_flv) , &
                 object%i_sc (object%n_flv))
    else if (blha_template%compute_real_trees ()) then
       allocate (object%i_real (object%n_flv))
    else if (blha_template%compute_born ()) then
       allocate (object%i_born (object%n_flv))
    end if

    call object%init_ew_parameters ()

    select type (driver => object%driver)
    class is (blha_driver_t)
       driver%include_polarizations = include_polarizations
       driver%switch_off_muon_yukawas = blha_template%switch_off_muon_yukawas
    end select
  end subroutine prc_blha_init_blha

@ %def prc_blha_init_blha
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_particle_properties => prc_blha_set_particle_properties
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_particle_properties (object, model) 
    class(prc_blha_t), intent(inout) :: object
    class(model_data_t), intent(in), target :: model
    integer :: i, i_pdg
    type(flavor_t) :: flv
    real(default) :: mass, width
    integer :: ierr
    do i = 1, OLP_N_MASSIVE_PARTICLES
       i_pdg = OLP_MASSIVE_PARTICLES(i)
       if (i_pdg < 0) cycle
       call flv%init (i_pdg, model)
       mass = flv%get_mass (); width = flv%get_width ()
       select type (driver => object%driver)
       class is (blha_driver_t)
          call driver%set_mass_and_width (i_pdg, mass = mass, width = width)
          if (i_pdg == 5) call driver%blha_olp_set_parameter &
             ('yuk(5)'//c_null_char, dble(mass), 0._double, ierr)
          if (i_pdg == 6) call driver%blha_olp_set_parameter &
             ('yuk(6)'//c_null_char, dble(mass), 0._double, ierr)
          if (driver%switch_off_muon_yukawas) then
             if (i_pdg == 13) call driver%blha_olp_set_parameter &
                ('yuk(13)' //c_null_char, 0._double, 0._double, ierr)
          end if
       end select
    end do
  end subroutine prc_blha_set_particle_properties

@ %def prc_blha_set_particle_properties
@ This mask adapts which electroweak parameters are supposed to set according to
the chosen BLHA EWScheme. This is only implemented for the default OLP method so far. 
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: init_ew_parameters => prc_blha_init_ew_parameters
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_init_ew_parameters (object)
    class(prc_blha_t), intent(inout) :: object
    object%ew_parameter_mask (I_ALPHA) = .true.
    object%ew_parameter_mask (I_GF) = .true.
    object%ew_parameter_mask (I_SW2) = .false.
  end subroutine prc_blha_init_ew_parameters

@ %def prc_blha_init_ew_parameters
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  !!!procedure :: set_bquark_mass => prc_blha_set_bquark_mass
<<BLHA OLP interfaces: procedures>>=
  !!!subroutine prc_blha_set_bquark_mass (object, model)
  !!!  class(prc_blha_t), intent(inout) :: object
  !!!  class(model_data_t), intent(in), target :: model
  !!!  type(flavor_t) :: flv
  !!!  real(default) :: mass, width
  !!!  integer :: ierr
  !!!  call flv%init (5, model)
  !!!  mass = flv%get_mass (); width = flv%get_width ()
  !!!  select type (driver => object%driver)
  !!!  class is (blha_driver_t)
  !!!     call driver%set_mass_and_width (5, mass=mass, width=width)
  !!!     call driver%blha_olp_set_parameter ('yuk(5)'//c_null_char, &
  !!!        dble(mass), 0._double, ierr)
  !!!  end select
  !!!end subroutine prc_blha_set_bquark_mass

@ %def prc_blha_set_bquark_mass
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_sqme_virt => prc_blha_compute_sqme_virt
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_sqme_virt (object, &
                i_flv, p, ren_scale, sqme, bad_point)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), dimension(4), intent(out) :: sqme
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(blha_result_array_size (object%n_particles, &
                                                    BLHA_AMP_LOOP)) :: r
    real(double) :: mu_dble
    real(default) :: mu
    real(double) :: acc_dble
    real(default) :: acc
    real(default) :: alpha_s

    mom = object%create_momentum_array (p)
    if (vanishes (ren_scale)) then
      mu = sqrt (2* (p(1)*p(2)))
    else
      mu = ren_scale
    end if
    mu_dble = dble(mu)
    alpha_s = object%qcd%alpha%get (mu)
    select type (driver => object%driver)
    class is (blha_driver_t)
      call driver%set_alpha_s (alpha_s)
      call driver%blha_olp_eval2 (object%i_virt(i_flv), &
                                   mom, mu_dble, r, acc_dble) 
    end select
    acc = acc_dble
    sqme = r(1:4)
    bad_point = acc > object%maximum_accuracy
  end subroutine prc_blha_compute_sqme_virt

@ %def prc_blha_compute_sqme_virt
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_compute_sqme_real), deferred :: &
      compute_sqme_real
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_compute_sqme_real (object, i_flv, &
          p, ren_scale, sqme, bad_point)
      import
      class(prc_blha_t), intent(inout) :: object
      integer, intent(in) :: i_flv
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: ren_scale
      real(default), intent(out) :: sqme
      logical, intent(out) :: bad_point
    end subroutine prc_blha_compute_sqme_real
  end interface 

@ %def prc_blha_compute_sqme_real interface
@ Compute the Born matrix element. This will always occur in connection to a subtraction
term, so scales and couplings have already been set, and the momenta are in the BLHA format
Hence, the interface is simpler than in the other routines.
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_compute_sqme_born), deferred :: &
      compute_sqme_born
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_compute_sqme_born (object, i_born, &
          p, mu, sqme, bad_point)
      import
      class(prc_blha_t), intent(inout) :: object
      integer, intent(in) :: i_born
      type(vector4_t), dimension(:), intent(in) :: p
      real(default), intent(in) :: mu
      real(default), intent(out) :: sqme
      logical, intent(out) :: bad_point
    end subroutine prc_blha_compute_sqme_born
  end interface 

@ %def prc_blha_compute_sqme_born interface
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_sqme_cc => prc_blha_compute_sqme_cc
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_sqme_cc &
         (object, i_flv, p, ren_scale, &
          born_out, born_cc, bad_point)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(out), optional :: born_out
    real(default), intent(inout), dimension(:,:) :: born_cc
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(blha_result_array_size (object%n_particles, &
                                              BLHA_AMP_CC)) :: r
    real(default) :: mu
    real(double) :: mu_dble
    real(default) :: alpha_s
    integer :: i, j, pos
    integer :: im1, jm1
    logical :: bad_point2 = .false.
    real(double) :: acc_dble
    real(default) :: acc
    real(default) :: born
    integer, dimension(:), allocatable :: flavors

    mom = object%create_momentum_array (p)
    if (vanishes (ren_scale)) then
       mu = sqrt (2*p(1)*p(2))
    else
       mu = ren_scale
    end if
    mu_dble = dble(mu)
    alpha_s = object%qcd%alpha%get (mu)
    flavors = object%get_flv_state (i_flv)

    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%set_alpha_s (alpha_s)
       if (allocated (object%i_born)) then
          call object%compute_sqme_born (i_flv, p, mu, born, bad_point2)
       else
          born = 0._default
          acc = 0._default
       end if
       if (present (born_out)) born_out = born
       call driver%blha_olp_eval2 (object%i_cc(i_flv), &
                                    mom, mu_dble, r, acc_dble)
    end select

    do j = 1, size (p)
      do i = 1, j
        if (i <= 2 .or. j <= 2) then
          born_cc (i,j) = 0._default
        else if (i == j) then
          if (is_quark (abs(flavors (i)))) then
             born_cc (i,j) = -cf*born 
          else if (is_gluon (flavors (i))) then
             born_cc (i,j) = -ca*born
          else 
             born_cc (i,j) = zero
          end if
        else
          im1 = i-1; jm1 = j-1
          pos = im1 + jm1*(jm1-1)/2 + 1
          born_cc (i,j) = - r(pos)
        end if
        born_cc (j,i) = born_cc (i,j)
      end do
    end do

    acc = acc_dble
    bad_point = bad_point2 .or. acc > object%maximum_accuracy
  end subroutine prc_blha_compute_sqme_cc

@ %def prc_blha_compute_sqme_cc
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  generic :: get_beam_helicities => get_beam_helicities_single
  generic :: get_beam_helicities => get_beam_helicities_array
  procedure :: get_beam_helicities_single => prc_blha_get_beam_helicities_single
  procedure :: get_beam_helicities_array => prc_blha_get_beam_helicities_array
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_get_beam_helicities_single (object, i) result (hel)
    integer, dimension(2) :: hel
    class(prc_blha_t), intent(in) :: object
    integer, intent(in) :: i
    hel = object%i_hel (i, :)
  end function prc_blha_get_beam_helicities_single

@ %def prc_blha_get_beam_helicities_single
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: includes_polarization => prc_blha_includes_polarization
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_includes_polarization (object) result (polarized)
    logical :: polarized
    class(prc_blha_t), intent(in) :: object
    select type (driver => object%driver)
    class is (blha_driver_t) 
       polarized = driver%include_polarizations
    end select
  end function prc_blha_includes_polarization

@ %def prc_blha_includes_polarization
@
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_get_beam_helicities_array (object) result (hel)
    integer, dimension(:,:), allocatable :: hel
    class(prc_blha_t), intent(in) :: object
    integer :: i, n_hel
    n_hel = object%n_flv * 4
    allocate (hel (n_hel, 2))
    do i = 1, n_hel 
       hel(i,:) = object%get_beam_helicities (i)
    end do
  end function prc_blha_get_beam_helicities_array

@ %def prc_blha_get_beam_helicities_array
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_init_driver), deferred :: &
      init_driver
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_init_driver (object, os_data)
      import
      class(prc_blha_t), intent(inout) :: object
      type(os_data_t), intent(in) :: os_data
    end subroutine prc_blha_init_driver
  end interface

@ %def prc_blha_init_driver interface
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The module is split into a configuration interface which manages configuration
and handles the request and contract files, a module which interfaces the OLP
matrix elements and a driver.

<<[[blha_config.f90]]>>=
<<File header>>

module blha_config

  use kinds
<<Use strings>>
  use io_units
  use constants
  use string_utils
  use system_defs, only: EOF
  use diagnostics
  use md5
  use model_data
  use flavors
  use quantum_numbers
  use pdg_arrays
  use sorting
  use lexers
  use parser
  use syntax_rules
  use ifiles

  use beam_structures, only: beam_structure_t

<<Standard module head>>

<<BLHA config: public>>

<<BLHA config: parameters>>

<<BLHA config: types>>

<<BLHA config: variables>>

<<BLHA config: interfaces>>

contains

<<BLHA config: procedures>>

end module blha_config

@ %def blha_config
@
\section{Configuration}

Parameters to enumerate the different options in the order.
<<BLHA config: parameters>>=
  integer, public, parameter :: &
       BLHA_CT_QCD=1, BLHA_CT_EW=2, BLHA_CT_QED=3, BLHA_CT_OTHER=4
  integer, public, parameter :: &
       BLHA_IRREG_CDR=1, BLHA_IRREG_DRED=2, BLHA_IRREG_THV=3, &
       BLHA_IRREG_MREG=4, BLHA_IRREG_OTHER=5
  integer, public, parameter :: &
       BLHA_MPS_ONSHELL=1, BLHA_MPS_OTHER=2
  integer, public, parameter :: &
       BLHA_MODE_GOSAM=1, BLHA_MODE_FEYNARTS = 2, BLHA_MODE_GENERIC=3, &
       BLHA_MODE_OPENLOOPS=4
  integer, public, parameter :: &
       BLHA_VERSION_1 = 1, BLHA_VERSION_2 = 2
  integer, public, parameter :: &
       BLHA_AMP_LOOP = 1, BLHA_AMP_CC = 2, BLHA_AMP_SC = 3, &
       BLHA_AMP_TREE = 4, BLHA_AMP_LOOPINDUCED = 5
  integer, public, parameter :: &
       BLHA_EW_GF = 1, BLHA_EW_MZ = 2, BLHA_EW_MSBAR = 3, &
       BLHA_EW_0 = 4, BLHA_EW_RUN = 5, BLHA_EW_DEFAULT = 6
  integer, public, parameter :: &
       BLHA_WIDTH_COMPLEX = 1, BLHA_WIDTH_FIXED = 2, &
       BLHA_WIDTH_RUNNING = 3, BLHA_WIDTH_POLE = 4, &
       BLHA_WIDTH_DEFAULT = 5 

@ %def blha_ct_qcd blha_ct_ew blha_ct_qed blha_ct_other
@ %def blha_irreg_cdr blha_irreg_dred blha_irreg_thv blha_irreg_mreg blha_irreg_other
@ %def blha_mps_onshell blha_mps_other
@ %def blha_mode_gosam blha_mode_feynarts blha_mode_generic
@ %def blha version blha_amp blha_ew blha_width
@ 
Those are the default pdg codes for massive particles in BLHA programs
<<BLHA config: parameters>>=
  integer, parameter, public :: OLP_N_MASSIVE_PARTICLES = 12
  integer, dimension(OLP_N_MASSIVE_PARTICLES), public :: &
    OLP_MASSIVE_PARTICLES = [5,-5,6,-6,13,-13,15,-15,23,24,-24,25]
  integer, parameter :: OLP_HEL_UNPOLARIZED = 0
  integer, parameter :: OLP_HEL_LEFT = -1
  integer, parameter :: OLP_HEL_RIGHT = 1
  integer, parameter :: OLP_HEL_LONG = 2

@ %def OLP_MASSIVE_PARTICLES
@ This type contains the pdg code of the particle to be written in the process
specification string and an optional additional information about the polarization 
of the particles. Note that the output can only be processed by OpenLoops.
<<BLHA config: types>>=
  type :: blha_particle_string_element_t
     integer :: pdg = 0
     integer :: hel = OLP_HEL_UNPOLARIZED
     logical :: polarized = .false. 
  contains
  <<BLHA config: blha particle string element: TBP>>
  end type blha_particle_string_element_t

@ %def blha_particle_string_element_t
@
<<BLHA config: blha particle string element: TBP>>=
  generic :: init => init_default
  generic :: init => init_polarized
  procedure :: init_default => blha_particle_string_element_init_default
  procedure :: init_polarized => blha_particle_string_element_init_polarized
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_init_default (blha_p, id)
    class(blha_particle_string_element_t), intent(out) :: blha_p
    integer, intent(in) :: id
    blha_p%pdg = id
  end subroutine blha_particle_string_element_init_default

@ %def blha_particle_string_element_init_default
@
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_init_polarized (blha_p, id, hel)
    class(blha_particle_string_element_t), intent(out) :: blha_p
    integer, intent(in) :: id, hel
    blha_p%polarized = .true.
    blha_p%pdg = id
    blha_p%hel = hel
  end subroutine blha_particle_string_element_init_polarized

@ %def blha_particle_string_element_init_polarized
@
<<BLHA config: blha particle string element: TBP>>=
  generic :: write_pdg => write_pdg_unit
  generic :: write_pdg => write_pdg_character
  procedure :: write_pdg_unit => blha_particle_string_element_write_pdg_unit
  procedure :: write_pdg_character &
     => blha_particle_string_element_write_pdg_character
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_write_pdg_unit (blha_p, unit)
    class(blha_particle_string_element_t), intent(in) :: blha_p
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, '(I3)') blha_p%pdg
  end subroutine blha_particle_string_element_write_pdg_unit

@ %def blha_particle_string_element_write_pdg_unit
@
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_write_pdg_character (blha_p, c)
    class(blha_particle_string_element_t), intent(in) :: blha_p
    character(3), intent(inout) :: c
    write (c, '(I3)') blha_p%pdg
  end subroutine blha_particle_string_element_write_pdg_character

@ %def blha_particle_string_element_write_pdg_character 
@
<<BLHA config: blha particle string element: TBP>>=
  generic :: write_helicity => write_helicity_unit
  generic :: write_helicity => write_helicity_character
  procedure :: write_helicity_unit &
     => blha_particle_string_element_write_helicity_unit
  procedure :: write_helicity_character &
     => blha_particle_string_element_write_helicity_character
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_write_helicity_unit (blha_p, unit)
    class(blha_particle_string_element_t), intent(in) :: blha_p
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, '(A1,I0,A1)') '(', blha_p%hel, ')'
  end subroutine blha_particle_string_element_write_helicity_unit

@ %def blha_particle_string_element_write_helicity_unit
@ 
<<BLHA config: procedures>>=
  subroutine blha_particle_string_element_write_helicity_character (blha_p, c)
    class(blha_particle_string_element_t), intent(in) :: blha_p
    character(4), intent(inout) :: c
    write (c, '(A1,I0,A1)') '(', blha_p%hel, ')'
  end subroutine blha_particle_string_element_write_helicity_character

@ %def blha_particle_string_element_write_helicity_character
@ This type encapsulates a BLHA request.
<<BLHA config: public>>=
  public :: blha_configuration_t
  public :: blha_cfg_process_node_t
<<BLHA config: types>>=
  type :: blha_cfg_process_node_t
     type(blha_particle_string_element_t), dimension(:), allocatable :: pdg_in, pdg_out
     integer, dimension(:), allocatable :: fingerprint
     integer :: nsub
     integer, dimension(:), allocatable :: ids
     integer :: amplitude_type
     type(blha_cfg_process_node_t), pointer :: next => null ()
  end type blha_cfg_process_node_t

  type :: blha_configuration_t
     type(string_t) :: name
     class(model_data_t), pointer :: model => null ()
     type(string_t) :: md5
     integer :: version = 2
     logical :: dirty = .false.
     integer :: n_proc = 0
     real(default) :: accuracy_target
     logical :: debug_unstable = .false.
     integer :: mode = BLHA_MODE_GENERIC
     logical :: polarized = .false.
     type(blha_cfg_process_node_t), pointer :: processes => null ()
     !integer, dimension(2) :: matrix_element_square_type = BLHA_MEST_SUM
     integer :: correction_type = BLHA_CT_QCD
     type(string_t) :: correction_type_other
     integer :: irreg = BLHA_IRREG_THV
     type(string_t) :: irreg_other
     integer :: massive_particle_scheme = BLHA_MPS_ONSHELL
     type(string_t) :: massive_particle_scheme_other
     type(string_t) :: model_file
     logical :: subdivide_subprocesses = .false.
     integer :: alphas_power = -1, alpha_power = -1
     integer :: ew_scheme = BLHA_EW_DEFAULT
     integer :: width_scheme = BLHA_WIDTH_DEFAULT
     integer :: openloops_phs_tolerance = 0
     logical :: openloops_top_signal = .false.
  end type blha_configuration_t

@ %def blha_cffg_process_node_t blha_configuration_t
@
This types control the creation of BLHA-interface files
<<BLHA config: public>>=
  public :: blha_flv_state_t
  public :: blha_master_t
<<BLHA config: types>>=
  type:: blha_flv_state_t
    integer, dimension(:), allocatable :: flavors
    integer :: flv_mult
    logical :: flv_real = .false.
  end type blha_flv_state_t

  type :: blha_master_t
    integer, dimension(4) :: blha_mode
    integer :: n_in, n_out
    logical :: compute_borns = .false.
    logical :: compute_real_trees = .false.
    logical :: compute_loops = .true.
    logical :: compute_correlations = .false.
    integer :: alpha_power, alphas_power
    type(string_t) :: basename
    type(string_t), dimension(:), allocatable :: suffix
    type(blha_configuration_t), dimension(:), allocatable :: blha_cfg
    integer :: n_files = 0
  contains
  <<BLHA config: blha master: TBP>>
  end type blha_master_t

@ %def blha_flv_state_t, blha_master_t
@ Master-Routines
<<BLHA config: blha master: TBP>>=
  procedure :: set_methods => blha_master_set_methods
<<BLHA config: procedures>>=
  subroutine blha_master_set_methods (master, cmp_born, &
     cmp_real, cmp_loop, cmp_corr)
    class(blha_master_t), intent(inout) :: master
    logical, intent(in) :: cmp_born, cmp_loop, cmp_corr, cmp_real
    master%n_files = count ([cmp_born, cmp_real, cmp_loop, cmp_corr])
    master%compute_borns = cmp_born
    master%compute_real_trees = cmp_real
    master%compute_loops = cmp_loop
    master%compute_correlations = cmp_corr
  end subroutine blha_master_set_methods

@ %def blha_master_set_methods
@
<<BLHA config: blha master: TBP>>=
  procedure :: allocate_config_files => blha_master_allocate_config_files
<<BLHA config: procedures>>=
  subroutine blha_master_allocate_config_files (master)
    class(blha_master_t), intent(inout) :: master
    allocate (master%blha_cfg (master%n_files))
    allocate (master%suffix (master%n_files))
  end subroutine blha_master_allocate_config_files

@ %def blha_master_allocate_config_files
@
<<BLHA config: blha master: TBP>>=
  procedure :: init => blha_master_init 
<<BLHA config: procedures>>=
  subroutine blha_master_init (master, basename, model, &
       n_in, alpha_power, alphas_power, flv_born, flv_real)
    class(blha_master_t), intent(inout) :: master
    type(string_t), intent(in) :: basename
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in
    integer, intent(in) :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable, intent(in) :: &
         flv_born, flv_real
    integer :: n_proc_real, n_flv
    type(blha_flv_state_t), dimension(:), allocatable :: blha_flavor
    integer :: i_flv, i_file
    integer :: n_flv_born 

    if (master%n_files < 1) &
       call msg_fatal ("Attempting to generate OLP-files, but none are specified!")
    n_flv = 1; n_proc_real = 0
    n_flv_born = size (flv_born, 2)
    if (master%compute_real_trees) then
       if (allocated (flv_real)) then
         n_proc_real = size (flv_real, 2)
         n_flv = n_flv + n_proc_real
       end if
    end if
    i_file = 1          
    if (master%compute_loops) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             allocate (blha_flavor(i_flv)%flavors (size (flv_born(:,i_flv))))
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 2
          end do
          master%suffix(i_file) = "_LOOP"
          call blha_init_virtual (master%blha_cfg(i_file), blha_flavor, &
               n_in, alpha_power, alphas_power, &
               basename, model, master%blha_mode(1))
          i_file = i_file + 1
        else
          call msg_fatal ("BLHA Loops requested but " &
                           // "Born flavor not existing")
        end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (master%compute_correlations) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             allocate (blha_flavor(i_flv)%flavors (size (flv_born(:,i_flv))))
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 3
          end do
          master%suffix(i_file) = "_SUB"
          call blha_init_subtraction (master%blha_cfg(i_file), blha_flavor, &
               n_in, alpha_power, alphas_power, &
               basename, model, master%blha_mode(2))
          i_file = i_file + 1
       else
          call msg_fatal ("BLHA Correlations requested but "&
                           // "Born flavor not existing")
       end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (master%compute_real_trees) then
       if (allocated (flv_real)) then
          allocate (blha_flavor (size (flv_real, 2)))
          do i_flv = 1, size (flv_real, 2)
             allocate (blha_flavor(i_flv)%flavors (size (flv_real(:,i_flv))))
             blha_flavor(i_flv)%flavors = flv_real(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 1
          end do
          master%suffix(i_file) = "_REAL"
          call blha_init_real (master%blha_cfg(i_file), blha_flavor, &
               n_in, alpha_power, alphas_power, &
               basename, model, master%blha_mode(3))
          i_file = i_file + 1
       else
          call msg_fatal ("BLHA Trees requested but "&
                           // "Real flavor not existing")
       end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (master%compute_borns) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (n_flv_born))
          do i_flv = 1, n_flv_born
             allocate (blha_flavor(i_flv)%flavors (size (flv_born(:,i_flv))))
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 1
          end do
          master%suffix(i_file) = "_BORN"
          call blha_init_born (master%blha_cfg(i_file), blha_flavor, &
               n_in, alpha_power, alphas_power, &
               basename, model, master%blha_mode(4))
       end if
    end if
  end subroutine blha_master_init

@ %def blha_master_init
@
<<BLHA config: blha master: TBP>>=
  procedure :: setup_additional_features => blha_master_setup_additional_features
<<BLHA config: procedures>>=
  subroutine blha_master_setup_additional_features (master, phs_tolerance, top_signal, beam_structure)
     class(blha_master_t), intent(inout) :: master
     integer, intent(in) :: phs_tolerance
     logical, intent(in), optional :: top_signal
     type(beam_structure_t), intent(in), optional :: beam_structure
     integer :: i_file
     logical :: polarized
     logical :: yorn

     yorn = .false.; if (present (top_signal)) yorn = top_signal     
     polarized = .false.
     if (present (beam_structure)) polarized = beam_structure%has_polarized_beams ()

     do i_file = 1, master%n_files
        if (phs_tolerance > 0) then
           select case (master%blha_mode(i_file))
           case (BLHA_MODE_GOSAM)
              if (polarized) &
                 call gosam_error_message () 
           case (BLHA_MODE_OPENLOOPS)
              master%blha_cfg(i_file)%openloops_phs_tolerance = phs_tolerance
              master%blha_cfg(i_file)%polarized = polarized
           end select
        end if
        master%blha_cfg(i_file)%openloops_top_signal = yorn
     end do
  contains
     subroutine gosam_error_message ()
        call msg_fatal ("You are trying to evaluate a process at NLO ", &
           [var_str ("which involves polarized beams using GoSam. "), &
            var_str ("This feature is not supported yet. "), &
            var_str ("Please use OpenLoops instead")])
     end subroutine gosam_error_message
  end subroutine blha_master_setup_additional_features

@ %def blha_master_setup_additional_features
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_gosam => blha_master_set_gosam
<<BLHA config: procedures>>=
  subroutine blha_master_set_gosam (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_GOSAM
  end subroutine blha_master_set_gosam

@ %def blha_master_set_gosam
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_openloops => blha_master_set_openloops
<<BLHA config: procedures>>=
  subroutine blha_master_set_openloops (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_OPENLOOPS
  end subroutine blha_master_set_openloops

@ %def blha_master_set_openloops
@
<<BLHA config: blha master: TBP>>=
  procedure :: reset_olp_modes => blha_master_reset_olp_modes
<<BLHA config: procedures>>=
  subroutine blha_master_reset_olp_modes (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_cfg(i)%mode = master%blha_mode(i)
  end subroutine blha_master_reset_olp_modes

@ %def blha_master_reset_olp_modes
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_polarization => blha_master_set_polarization
<<BLHA config: procedures>>=
  subroutine blha_master_set_polarization (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_cfg(i)%polarized = .true.
  end subroutine blha_master_set_polarization

@ %def blha_master_set_polarization
@
<<BLHA config: procedures>>=
  subroutine blha_init_born (blha_cfg, blha_flavor, n_in, &
        ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: n_in
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)))
    do i = 1, size (blha_flavor)
       amp_type(i) = BLHA_AMP_TREE
    end do
    call blha_configuration_init (blha_cfg, basename // "_BORN" , &
         model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, n_in, &
         blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_0
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, BLHA_VERSION_2, &
         correction_type = BLHA_CT_QCD, &
         irreg = BLHA_IRREG_CDR, alphas_power = asp, &
         alpha_power = ap, ew_scheme = ew_scheme, &
         debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_born

  subroutine blha_init_virtual (blha_cfg, blha_flavor, n_in, &
     ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: n_in
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*2))
    do i = 1, size (blha_flavor)
       amp_type(2*i-1) = BLHA_AMP_LOOP
       amp_type(2*i) = BLHA_AMP_CC
    end do
    call blha_configuration_init (blha_cfg, basename // "_LOOP" , &
         model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, n_in, &
         blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_0
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, BLHA_VERSION_2, &
         correction_type = BLHA_CT_QCD, &
         irreg = BLHA_IRREG_CDR, &
         alphas_power = asp, &
         alpha_power = ap, &
         ew_scheme = ew_scheme, &
         debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_virtual

  subroutine blha_init_subtraction (blha_cfg, blha_flavor, n_in, &
     ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: n_in
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*3))
    do i = 1, size (blha_flavor)
       amp_type(3*i-2) = BLHA_AMP_TREE
       amp_type(3*i-1) = BLHA_AMP_CC
       amp_type(3*i) = BLHA_AMP_SC
    end do
    call blha_configuration_init (blha_cfg, basename // "_SUB" , &
         model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, n_in, &
         blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_0
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, BLHA_VERSION_2, &
         correction_type = BLHA_CT_QCD, &
         irreg = BLHA_IRREG_CDR, &
         alphas_power = asp, &
         alpha_power = ap, &
         ew_scheme = ew_scheme, &
         debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_subtraction

  subroutine blha_init_real (blha_cfg, blha_flavor, n_in, & 
     ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: n_in
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)))
    do i = 1, size (blha_flavor)
       amp_type(i) = BLHA_AMP_TREE
    end do
    call blha_configuration_init (blha_cfg, basename // "_REAL" , &
         model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, n_in, &
         blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_0
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, BLHA_VERSION_2, &
         correction_type = BLHA_CT_QCD, &
         irreg = BLHA_IRREG_CDR, &
         alphas_power = asp+1, &
         alpha_power = ap, &
         ew_scheme = ew_scheme, &
         ! debug = .true.)
         debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_real

@ %def blha_master_init_virtual blha_master_init_real
@ %def blha_master_init_subtraction
@
<<BLHA config: blha master: TBP>>=
  procedure :: generate => blha_master_generate
<<BLHA config: procedures>>=
  subroutine blha_master_generate (master, basename)
    class(blha_master_t), intent(in) :: master
    type(string_t), intent(in) :: basename
    integer :: unit
    type(string_t) :: filename
    integer :: i_file
    do i_file = 1, master%n_files
       filename = basename // master%suffix(i_file) // ".olp"
       unit = free_unit ()
       open (unit, file = char (filename), status = 'replace', action = 'write')
       call blha_configuration_write (master%blha_cfg(i_file), unit)
       close (unit)
    end do
  end subroutine blha_master_generate

@ %def blha_master_generate
@    
<<BLHA config: blha master: TBP>>=
  procedure :: final => blha_master_final
<<BLHA config: procedures>>=
  subroutine blha_master_final (master)
    class(blha_master_t), intent(inout) :: master
    master%n_files = 0
    deallocate (master%suffix)
    deallocate (master%blha_cfg)
  end subroutine blha_master_final

@ %def blha_master_final
@
<<BLHA config: public>>=
  public :: blha_configuration_init
<<BLHA config: procedures>>=
  subroutine blha_configuration_init (cfg, name, model, mode)
    type(blha_configuration_t), intent(inout) :: cfg
    type(string_t), intent(in) :: name
    class(model_data_t), target, intent(in) :: model
    integer, intent(in), optional :: mode
    if (.not. associated (cfg%model)) then
       cfg%name = name
       cfg%model => model
    end if
    if (present (mode)) cfg%mode = mode
  end subroutine blha_configuration_init

@ %def blha_configuration_init
@ Create an array of massive particle indices, to be used by the 
"MassiveParticle"-statement of the order file.
<<BLHA config: procedures>>=
  subroutine blha_configuration_get_massive_particles &
             (cfg, massive, i_massive)
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out) :: massive
    integer, intent(out), dimension(:), allocatable :: i_massive
    integer, parameter :: max_particles = 10
    integer, dimension(max_particles) :: i_massive_tmp
    integer, dimension(max_particles) :: checked
    type(blha_cfg_process_node_t), pointer :: current_process 
    integer :: k
    integer :: n_massive
    n_massive = 0; k = 1
    checked = 0
    if (associated (cfg%processes)) then
       current_process => cfg%processes
    else
       call msg_fatal ("BLHA, massive particles: " // &
                       "No processes allocated!")
    end if
    do
       call check_pdg_list (current_process%pdg_in%pdg)
       call check_pdg_list (current_process%pdg_out%pdg)
       if (k > max_particles) &
          call msg_fatal ("BLHA, massive particles: " // &
                          "Max. number of particles exceeded!")
       if (associated (current_process%next)) then
          current_process => current_process%next
       else
          exit
       end if
    end do       
    if (n_massive > 0) then
       allocate (i_massive (n_massive))
       i_massive = i_massive_tmp (1:n_massive)
       massive = .true.
    else
       massive = .false.
    end if
  contains
    subroutine check_pdg_list (pdg_list)
       integer, dimension(:), intent(in) :: pdg_list
       integer :: i, i_pdg
       type(flavor_t) :: flv
       do i = 1, size (pdg_list)
          i_pdg = abs (pdg_list(i))
          call flv%init (i_pdg, cfg%model)
          if (flv%get_mass () > 0._default) then 
             !!! Avoid duplicates in output
             if (.not. any (checked == i_pdg)) then
                i_massive_tmp(k) = i_pdg
                checked(k) = i_pdg  
                k=k+1
                n_massive=n_massive+1
             end if
          end if
       end do
    end subroutine check_pdg_list
  end subroutine blha_configuration_get_massive_particles

@ %def blha_configuration_get_massive_particles
@
<<BLHA config: public>>=
  public :: blha_configuration_append_processes
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_processes (cfg, n_in, flavor, amp_type)
    type(blha_configuration_t), intent(inout) :: cfg
    integer, intent(in) :: n_in
    type(blha_flv_state_t), dimension(:), intent(in) :: flavor
    integer, dimension(:), intent(in), optional :: amp_type
    integer :: n_tot
    type(blha_cfg_process_node_t), pointer :: current_node
    integer :: i_process, i_flv
    integer, dimension(:), allocatable :: pdg_in, pdg_out
    integer, dimension(:), allocatable :: flavor_state
    integer :: proc_offset, n_proc_tot
    integer :: h1, h2
    proc_offset = 0; n_proc_tot = 0
    do i_flv = 1, size (flavor)
       n_proc_tot = n_proc_tot + flavor(i_flv)%flv_mult
    end do
    if (.not. associated (cfg%processes)) &
      allocate (cfg%processes)
    current_node => cfg%processes
    do i_flv = 1, size (flavor)
       n_tot = size (flavor(i_flv)%flavors)
       allocate (pdg_in (n_in), pdg_out (n_tot - n_in))
       allocate (flavor_state (n_tot))
       flavor_state = flavor(i_flv)%flavors
       do i_process = 1, flavor(i_flv)%flv_mult
          pdg_in = flavor_state (1:n_in)
          pdg_out = flavor_state (n_in+1:)
          if (cfg%polarized) then
             select case (cfg%mode)
             case (BLHA_MODE_OPENLOOPS)
                call allocate_and_init_pdg_and_helicities (current_node, &
                   pdg_in, pdg_out, amp_type (proc_offset+i_process))
             case (BLHA_MODE_GOSAM)
                !!! Nothing special for GoSam yet. This exception is already caught
                !!! in blha_master_setup_additional_features
             end select
          else
             call allocate_and_init_pdg (current_node, pdg_in, pdg_out, &
                amp_type (proc_offset + i_process)) 
          end if
          if (proc_offset+i_process /= n_proc_tot) then
            allocate (current_node%next)
            current_node => current_node%next
          end if
          if (i_process == flavor(i_flv)%flv_mult) &
             proc_offset = proc_offset + flavor(i_flv)%flv_mult
       end do
       deallocate (pdg_in, pdg_out)
       deallocate (flavor_state)
    end do
  contains
    subroutine allocate_and_init_pdg (node, pdg_in, pdg_out, amp_type)
      type(blha_cfg_process_node_t), intent(inout), pointer :: node
      integer, intent(in), dimension(:), allocatable :: pdg_in, pdg_out
      integer, intent(in) :: amp_type
      allocate (node%pdg_in (size (pdg_in)))
      allocate (node%pdg_out (size (pdg_out)))
      node%pdg_in%pdg = pdg_in
      node%pdg_out%pdg = pdg_out
      node%amplitude_type = amp_type  
    end subroutine allocate_and_init_pdg

    subroutine allocate_and_init_pdg_and_helicities (node, pdg_in, pdg_out, amp_type)
      type(blha_cfg_process_node_t), intent(inout), pointer :: node
      integer, intent(in), dimension(:), allocatable :: pdg_in, pdg_out
      integer, intent(in) :: amp_type
      integer :: h1, h2
      do h1 = -1, 1
         do h2 = -1, 1
            if (h1 == 0 .or. h2 == 0) cycle 
            call allocate_and_init_pdg (current_node, pdg_in, pdg_out, amp_type) 
            current_node%pdg_in(1)%polarized = .true.
            current_node%pdg_in(2)%polarized = .true.
            current_node%pdg_in(1)%hel = h1
            current_node%pdg_in(2)%hel = h2
            if (h1 + h2 /= 2) then
               allocate (current_node%next)
               current_node => current_node%next
            end if
         end do
      end do
    end subroutine allocate_and_init_pdg_and_helicities
      
  end subroutine blha_configuration_append_processes

@ %def blha_configuration_append_processes
@ Change parameter(s).
<<BLHA config: public>>=
  public :: blha_configuration_set
<<BLHA config: procedures>>=
  subroutine blha_configuration_set (cfg, &
       version, correction_type, irreg, massive_particle_scheme, &
       model_file, alphas_power, alpha_power, ew_scheme, width_scheme, &
       accuracy, debug)
    type(blha_configuration_t), intent(inout) :: cfg
    integer, optional, intent(in) :: version
    integer, optional, intent(in) :: correction_type
    integer, optional, intent(in) :: irreg
    integer, optional, intent(in) :: massive_particle_scheme
    type(string_t), optional, intent(in) :: model_file
    integer, optional, intent(in) :: alphas_power, alpha_power
    integer, optional, intent(in) :: ew_scheme
    integer, optional, intent(in) :: width_scheme
    real(default), optional, intent(in) :: accuracy
    logical, optional, intent(in) :: debug
    if (present (version)) &
       cfg%version = version
    if (present (correction_type)) &
       cfg%correction_type = correction_type
    if (present (irreg)) &
       cfg%irreg = irreg
    if (present (massive_particle_scheme)) &
       cfg%massive_particle_scheme = massive_particle_scheme
    if (present (model_file)) &
       cfg%model_file = model_file
    if (present (alphas_power)) &
       cfg%alphas_power = alphas_power
    if (present (alpha_power)) &
       cfg%alpha_power = alpha_power
    if (present (ew_scheme)) &
       cfg%ew_scheme = ew_scheme
    if (present (width_scheme)) &
       cfg%width_scheme = width_scheme
    if (present (accuracy)) &
       cfg%accuracy_target = accuracy
    if (present (debug)) &
       cfg%debug_unstable = debug
    cfg%dirty = .false.
  end subroutine blha_configuration_set

@ %def blha_configuration_set
@
<<BLHA config: public>>=
  public :: blha_configuration_get_n_proc
<<BLHA config: procedures>>=
  function blha_configuration_get_n_proc (cfg) result (n_proc)
    type(blha_configuration_t), intent(in) :: cfg
    integer :: n_proc
    n_proc = cfg%n_proc
  end function blha_configuration_get_n_proc

@ %def blha_configuration_get_n_proc
@
Write the BLHA file. Internal mode is intented for md5summing only. 
<<BLHA config: public>>=
  public :: blha_configuration_write
<<BLHA config: procedures>>=
  subroutine blha_configuration_write (cfg, unit, internal, no_version)
    type(blha_configuration_t), intent(in) :: cfg
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: internal, no_version
    integer :: u
    logical :: full
    type(string_t) :: buf
    type(blha_cfg_process_node_t), pointer :: node
    integer :: i
    character(3) :: pdg_char
    character(4) :: hel_char
    character(len=25), parameter :: pad = ""
    logical :: write_process, no_v
    no_v = .false. ; if (present (no_version))  no_v = no_version
    u = given_output_unit (unit); if (u < 0) return
    full = .true.; if (present (internal)) full = .not. internal
    if (full .and. cfg%dirty) call msg_bug ( &
       "BUG: attempted to write out a dirty BLHA configuration")
    if (full) then
       if (no_v) then
          write (u, "(A)") "# BLHA order written by WHIZARD [version]"
       else
          write (u, "(A)") "# BLHA order written by WHIZARD <<Version>>"
       end if
       write (u, "(A)")
    end if
    select case (cfg%mode)
       case (BLHA_MODE_GOSAM); buf = "GoSam"
       case (BLHA_MODE_OPENLOOPS); buf = "OpenLoops"
       case default; buf = "vanilla"
    end select
    write (u, "(A)") "# BLHA interface mode: " // char (buf)
    write (u, "(A)") "# process: " // char (cfg%name)
    write (u, "(A)") "# model: " // char (cfg%model%get_name ())
    select case (cfg%version)
       case (1); buf = "BLHA1"
       case (2); buf = "BLHA2"
    end select
    write (u, '(A25,A)') "InterfaceVersion " // pad, char (buf)
    select case (cfg%correction_type)
       case (BLHA_CT_QCD); buf = "QCD"
       case (BLHA_CT_EW); buf = "EW"
       case (BLHA_CT_QED); buf = "QED"
       case default; buf = cfg%correction_type_other
    end select
    write (u,'(A25,A)') "CorrectionType" // pad, char (buf)

    select case (cfg%mode)
    case (BLHA_MODE_OPENLOOPS)
       buf = cfg%name // '.olc'
       write (u, '(A25,A)') "Extra AnswerFile" // pad, char (buf)
    end select

    select case (cfg%irreg)
       case (BLHA_IRREG_CDR); buf = "CDR"
       case (BLHA_IRREG_DRED); buf = "DRED"
       case (BLHA_IRREG_THV); buf = "tHV"
       case (BLHA_IRREG_MREG); buf = "MassReg"
       case default; buf = cfg%irreg_other
    end select
    write (u,'(A25,A)') "IRregularisation" // pad, char (buf)
    select case (cfg%massive_particle_scheme)
       case (BLHA_MPS_ONSHELL); buf = "OnShell"
       case default; buf = cfg%massive_particle_scheme_other
    end select
    if (cfg%mode == BLHA_MODE_GOSAM) &
       write (u,'(A25,A)') "MassiveParticleScheme" // pad, char (buf)
    select case (cfg%version)
    case (1)
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "AlphasPower" // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u,'(A25,A)') &
         "AlphaPower " // pad, int2char (cfg%alpha_power)
    case (2) 
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "CouplingPower QCD " // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u, '(A25,A)') &
         "CouplingPower QED " // pad, int2char (cfg%alpha_power)
    end select
    select case (cfg%ew_scheme)
       case (BLHA_EW_GF); buf = "alphaGF"
       case (BLHA_EW_MZ); buf = "alphaMZ"
       case (BLHA_EW_MSBAR); buf = "alphaMSbar"
       case (BLHA_EW_0); buf = "alpha0"
       case (BLHA_EW_RUN); buf = "alphaRUN"
       case (BLHA_EW_DEFAULT); buf = "OLPDefined"
    end select
    select case (cfg%mode)
    case (BLHA_MODE_GOSAM)
!       write (u, '(A25, A)') "EWScheme " // pad, char (buf)
    case (BLHA_MODE_OPENLOOPS)
!       write (u, '(A25, A)') "ewscheme " // pad, char (buf)
    endselect
    select case (cfg%mode)
    case (BLHA_MODE_GOSAM)
       write (u, '(A25)', advance='no') "MassiveParticles " // pad
       do i = 1, size (OLP_MASSIVE_PARTICLES)
          if (OLP_MASSIVE_PARTICLES(i) > 0) &
             write (u, '(I2,1X)', advance='no') OLP_MASSIVE_PARTICLES(i)
       end do
       write (u,*) 
    case (BLHA_MODE_OPENLOOPS)
       write (u, '(A25,I1)') "extra use_cms " // pad, 0
       write (u, '(A25,I1)') "extra me_cache " // pad, 0
       if (cfg%openloops_phs_tolerance > 0) then
          write (u, '(A25,A4,I0)') "extra psp_tolerance " // pad, "10e-", &
             cfg%openloops_phs_tolerance
       end if
       if (cfg%openloops_top_signal) &
          write (u, '(A)') "extra approx top"
    end select
    if (full) then
       write (u, "(A)")
       write (u, "(A)") "# Process definitions"
       write (u, "(A)")
    end if
    if (cfg%debug_unstable) &
      write (u, '(A25,A)') "DebugUnstable " // pad, "True"
    write (u, *)
    node => cfg%processes
    do while (associated (node))
       write_process = .true.
       select case (node%amplitude_type)
         case (BLHA_AMP_LOOP); buf = "Loop"
         case (BLHA_AMP_CC); buf = "ccTree"
         case (BLHA_AMP_SC) 
            buf = "scTree"
            if (cfg%mode == BLHA_MODE_OPENLOOPS) write_process = .false. 
         case (BLHA_AMP_TREE); buf = "Tree"
         case (BLHA_AMP_LOOPINDUCED); buf = "LoopInduced"
       end select
       if (write_process) then
          write (u, '(A25, A)') "AmplitudeType " // pad, char (buf)
   
          buf = ""
          do i = 1, size (node%pdg_in)
             call node%pdg_in(i)%write_pdg (pdg_char)
             if (node%pdg_in(i)%polarized) then
                call node%pdg_in(i)%write_helicity (hel_char)
                buf = (buf // pdg_char // hel_char) // " "
             else
                buf = (buf // pdg_char) // " "
             end if
          end do
          buf = buf // "-> "
          do i = 1, size (node%pdg_out)
             call node%pdg_out(i)%write_pdg (pdg_char)
             buf = (buf // pdg_char) // " "
          end do
          write (u, "(A)") char (trim (buf))
          write (u, *)
       end if
       node => node%next
    end do

  end subroutine blha_configuration_write

@ %def blha_configuration_write
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[blha_ut.f90]]>>=
<<File header>>

module blha_ut
  use unit_tests
  use blha_uti

<<Standard module head>>

<<BLHA: public tests>>

contains

<<BLHA: test driver>>

end module blha_ut

@ %def blha_ut
@
<<[[blha_uti.f90]]>>=
<<File header>>

module blha_uti

<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use models
  use blha_config
  

<<Standard module head>>

<<BLHA: test declarations>>

contains

<<BLHA: procedures>>

<<BLHA: tests>>

end module blha_uti

@ %def blha_uti
@ API: driver for the unit tests below.
<<BLHA: public tests>>=
  public :: blha_test
<<BLHA: test driver>>=
  subroutine blha_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test(blha_1, "blha_1", "Test the creation of BLHA-OLP files", u, results)
    call test(blha_2, "blha_2", "Test the creation of BLHA-OLP files for "&
       &"multiple flavor structures", u, results)
    call test(blha_3, "blha_3", "Test helicity-information in OpenLoops OLP files", &
       u, results)
  end subroutine blha_test

@ %def blha_test
@
<<BLHA: procedures>>=
  subroutine setup_and_write_blha_configuration (u, single, polarized)
    integer, intent(in) :: u
    logical, intent(in), optional :: single
    logical, intent(in), optional :: polarized
    logical :: yorn1, yorn2
    type(blha_master_t) :: blha_master
    integer :: i
    integer :: n_in, n_out
    integer :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(string_t) :: proc_id
    type(os_data_t) :: os_data
    type(model_list_t) :: model_list
    type(model_t), pointer :: model => null ()
    integer :: openloops_phs_tolerance
    
    yorn1 = .false.; if (present (polarized)) yorn1 = polarized
    yorn2 = .true.; if (present (single)) yorn2 = single

    if (yorn2) then
       write (u, "(A)") "* Process: e+ e- -> W+ W- b b~"
       n_in = 2; n_out = 4
       alpha_power = 4; alphas_power = 0
       allocate (flv_born (n_in + n_out, 1))
       allocate (flv_real (n_in + n_out + 1, 1))
       flv_born(1,1) = 11; flv_born(2,1) = -11
       flv_born(3,1) = 24; flv_born(4,1) = -24  
       flv_born(5,1) = 5; flv_born(6,1) = -5   
       flv_real(1:6,1) = flv_born(:,1)
       flv_real(7,1) = 21
    else
       write (u, "(A)") "* Process: e+ e- -> u:d:s U:D:S"
       n_in = 2; n_out = 2
       alpha_power = 2; alphas_power = 0
       allocate (flv_born (n_in + n_out, 3))
       allocate (flv_real (n_in + n_out + 1, 3))
       flv_born(1,:) = 11; flv_born(2,:) = -11
       flv_born(3,1) = 1; flv_born(4,1) = -1
       flv_born(3,2) = 2; flv_born(4,2) = -2
       flv_born(3,3) = 3; flv_born(4,3) = -3
       flv_real(1:4,:) = flv_born
       flv_real(5,:) = 21
    end if
    proc_id = var_str ("BLHA_Test")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model &
       (var_str ("SM"), var_str ("SM.mdl"), os_data, model) 

    write (u, "(A)") "* BLHA matrix elements assumed for all process components"
    write (u, "(A)") "* Mode: GoSam"

    do i = 1, 4
       call blha_master%set_gosam (i)
    end do 

    call blha_master%set_methods (.true., .true., .true., .true.)
    call blha_master%allocate_config_files ()
    call blha_master%init (proc_id, model, n_in, &
       alpha_power, alphas_power, flv_born, flv_real) 
     
    do i = 1, 4
       call write_separator (u)
       call write_component_type (i, u)
       call write_separator (u)
       call blha_configuration_write &
            (blha_master%blha_cfg(i), u, no_version = .true.)
    end do

    write (u, "(A)") "* Switch to OpenLoops"
    openloops_phs_tolerance = 7
    call blha_master%final ()
    
    do i = 1, 4
       call blha_master%set_openloops (i)
    end do

    call blha_master%set_methods (.true., .true., .true., .true.)
    call blha_master%allocate_config_files ()
    call blha_master%init (proc_id, model, n_in, &
       alpha_power, alphas_power, flv_born, flv_real)

    if (yorn1) then
       do i = 1, 4
          call blha_master%set_polarization (i)
       end do
    end if
    call blha_master%setup_additional_features (openloops_phs_tolerance)

    do i = 1, 4
       call write_separator(u)
       call write_component_type (i, u)
       call write_separator (u)
       call blha_configuration_write &
            (blha_master%blha_cfg(i), u, no_version = .true.)
    end do
     
  contains
    subroutine write_component_type (i, u)
      integer, intent(in) :: i, u
      type(string_t) :: message, component_type
      message = var_str ("OLP-File content for ")
      select case (i)
      case (1)
         component_type = var_str ("loop")
      case (2) 
         component_type = var_str ("subtraction")
      case (3) 
         component_type = var_str ("real")
      case (4) 
         component_type = var_str ("born")
      end select
      message = message // component_type // " matrix elements"
      write (u, "(A)") char (message) 
    end subroutine write_component_type
  end subroutine setup_and_write_blha_configuration

@ %def setup_and_write_blha_configuration
@
<<BLHA: test declarations>>=
  public :: blha_1
<<BLHA: tests>>=
  subroutine blha_1 (u)
    integer, intent(in) :: u
    
    write (u, "(A)") "* Test output: blha_1"
    write (u, "(A)") "* Purpose: Test the creation of olp-files for single "&
       &"and unpolarized flavor structures"
    write (u, "(A)")

    call setup_and_write_blha_configuration (u, single = .true., polarized = .false.)
  end subroutine blha_1

@ %def blha_1
@
<<BLHA: test declarations>>=
  public :: blha_2
<<BLHA: tests>>=
  subroutine blha_2 (u)
    integer, intent(in) :: u

    write (u, "(A)") "* Test output: blha_2"
    write (u, "(A)") "* Purpose: Test the creation of olp-files for multiple "&
      &"and unpolarized flavor structures"
    write (u, "(A)")
   
    call setup_and_write_blha_configuration (u, single = .false., polarized = .false.)
  end subroutine blha_2

@ %def blha_2
@
<<BLHA: test declarations>>=
  public :: blha_3
<<BLHA: tests>>=
  subroutine blha_3 (u)
    integer, intent(in) :: u

    write (u, "(A)") "* Test output: blha_3"
    write (u, "(A)") "* Purpose: Test the creation of olp-files for single "&
      &"and polarized flavor structures"
    write (u, "(A)")
   
    call setup_and_write_blha_configuration (u, single = .true., polarized = .true.)
  end subroutine blha_3

@ %def blha_3
@




