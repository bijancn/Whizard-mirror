% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{BLHA Interface}

The code in this chapter implements support for the BLHA record that
communicates data for NLO processes.

These are the modules:
\begin{description}
\item[blha\_config]
\item[blha\_interface]
\item[blha\_driver]
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module definition}

These modules implement the communication with one loop matrix element providers
according to the Binoth LesHouches Accord Interface. The actual matrix
element(s) are loaded as a dynamic library.

This module defines the common OLP-interfaces defined through the Binoth Les-Houches 
accord.

<<[[blha_olp_interfaces.f90]]>>=
<<File header>>

module blha_olp_interfaces

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
<<Use strings>>
  use lorentz
  use diagnostics

<<Standard module head>>

<<BLHA OLP interfaces: public>>

<<BLHA OLP interfaces: public parameters>>

<<BLHA OLP interfaces: interfaces>>

contains

<<BLHA OLP interfaces: procedures>>

end module blha_olp_interfaces

@ %def module blha_olp_interfaces
@
<<BLHA OLP interfaces: public parameters>>=
  integer, parameter, public :: OLP_PARAMETER_LIMIT = 10
  integer, parameter, public :: OLP_MOMENTUM_LIMIT = 25
  integer, parameter, public :: OLP_RESULTS_LIMIT = 20 

<<BLHA OLP interfaces: public>>=
  public :: olp_start
<<BLHA OLP interfaces: interfaces>>=
  interface 
    subroutine olp_start (contract_file_name, ierr) bind (C,name="OLP_Start")
      import
      character(kind=c_char, len=1), intent(in) :: contract_file_name
      integer(kind=c_int), intent(out) :: ierr
    end subroutine olp_start
  end interface

@ %def olp_start_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval (label, momenta, mu, parameters, res) &
         bind (C,name="OLP_EvalSubProcess")
      import
      integer(kind=c_int), value, intent(in) :: label
      real(kind=c_double), value, intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: &
           momenta
      real(kind=c_double), dimension(OLP_PARAMETER_LIMIT), intent(in) :: &
           parameters
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
    end subroutine olp_eval
  end interface

@ %def olp_eval interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_info
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_info (olp_file, olp_version, message) bind(C)
      import
      character(kind=c_char), intent(inout), dimension(15) :: olp_file
      character(kind=c_char), intent(inout), dimension(15) :: olp_version
      character(kind=c_char), intent(inout), dimension(255) :: message
    end subroutine olp_info
  end interface

@ %def olp_info interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_set_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_set_parameter &
         (variable_name, real_part, complex_part, success) bind(C)
      import
      character(kind=c_char,len=1), intent(in) :: variable_name
      real(kind=c_double), intent(in) :: real_part, complex_part
      integer(kind=c_int), intent(out) :: success
    end subroutine olp_set_parameter
  end interface

@ %def olp_set_parameter_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval2
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval2 (label, momenta, mu, res, acc) bind(C)
      import
      integer(kind=c_int), intent(in) :: label
      real(kind=c_double), intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
      real(kind=c_double), intent(out) :: acc
    end subroutine olp_eval2
  end interface

@ %def olp_eval2_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_option
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_option (line, stat) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: line
      integer(kind=c_int), intent(out) :: stat
    end subroutine
  end interface

@ %def olp_option_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_polvec
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_polvec (p, q, eps) bind(C)
      import
      real(kind=c_double), dimension(0:3), intent(in) :: p, q
      real(kind=c_double), dimension(0:7), intent(out) :: eps
    end subroutine
  end interface

@ %def olp_polvec_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_finalize
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_finalize () bind(C)
      import
    end subroutine olp_finalize
  end interface

@ %def olp_finalize_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_print_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_print_parameter (filename) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: filename
    end subroutine olp_print_parameter
  end interface

@ %def olp_print_parameter_interface
@
<<BLHA OLP interfaces: public>>=
  public :: create_blha_momentum_array
<<BLHA OLP interfaces: procedures>>=
  function create_blha_momentum_array (p) result (mom)
    type(vector4_t), intent(in), dimension(:) :: p
    real(double), dimension(OLP_MOMENTUM_LIMIT) :: mom
    integer :: n, i, k

    n = size (p)
    if (n > 10) call msg_fatal ("Number of external particles exceeeds" &
                                 // "size of GoSam-internal momentum array")
    k = 1
    do i = 1, n
       mom(k:k+3) = vector4_get_components (p(i))
       mom(k+4) = invariant_mass (p(i))
       k = k+5
    end do
    mom (k:50) = 0.0
  end function create_blha_momentum_array

@ %def create_blha_momentum_array
@
\clearplage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The module is split into a configuration interface which manages configuration
and handles the request and contract files, a module which interfaces the OLP
matrix elements and a driver.

<<[[blha_config.f90]]>>=
<<File header>>

module blha_config

  use kinds
<<Use strings>>
  use io_units
  use constants
  use string_utils
  use system_defs, only: EOF
  use diagnostics
  use md5
  use model_data
  use flavors
  use quantum_numbers
  use pdg_arrays
  use sorting
  use lexers
  use parser
  use syntax_rules
  use ifiles

<<Standard module head>>

<<BLHA config: public>>

<<BLHA config: parameters>>

<<BLHA config: types>>

<<BLHA config: variables>>

<<BLHA config: interfaces>>

contains

<<BLHA config: procedures>>

end module blha_config

@ %def blha_config
@
<<[[blha_interface.f90]]>>=
<<File header>>

module blha_interface

<<Use strings>>
  use io_units
  use string_utils
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use model_data
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use, intrinsic :: iso_c_binding !NODEP!
  use os_interface

<<Standard module head>>

<<BLHA interface: public>>

<<BLHA interface: types>>

<<BLHA interface: interfaces>>

contains

<<BLHA interface: procedures>>

end module blha_interface
@ %def blha_interface
@ %
<<[[blha_driver.f90]]>>=
<<File header>>

module blha_driver

<<Use strings>>
  use io_units
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use model_data
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use blha_interface

<<Standard module head>>

<<BLHA driver: public>>

contains

<<BLHA driver: procedures>>

end module blha_driver
@ %def blha_driver
@ %

\section{Configuration}

Parameters to enumerate the different options in the order.
<<BLHA config: parameters>>=
  integer, public, parameter :: &
       BLHA_MEST_SUM=1, BLHA_MEST_AVG=2, BLHA_MEST_OTHER=3
  integer, public, parameter :: &
       BLHA_CT_QCD=1, BLHA_CT_EW=2, BLHA_CT_QED=3, BLHA_CT_OTHER=4
  integer, public, parameter :: &
       BLHA_IRREG_CDR=1, BLHA_IRREG_DRED=2, BLHA_IRREG_THV=3, &
       BLHA_IRREG_MREG=4, BLHA_IRREG_OTHER=5
  integer, public, parameter :: &
       BLHA_SUBMODE_NONE = 1, BLHA_SUBMODE_OTHER = 2
  integer, public, parameter :: &
       BLHA_MPS_ONSHELL=1, BLHA_MPS_OTHER=2
  integer, public, parameter :: &
       BLHA_MODE_GOSAM=1, BLHA_MODE_FEYNARTS = 2, BLHA_MODE_GENERIC=3, &
       BLHA_MODE_OPENLOOPS=4
  integer, public, parameter :: &
       BLHA_OM_NONE=1, BLHA_OM_NOCPL=2, BLHA_OM_OTHER=3
   integer, public, parameter :: &
       BLHA_VERSION_1 = 1, BLHA_VERSION_2 = 2
  integer, public, parameter :: &
       BLHA_AMP_LOOP = 1, BLHA_AMP_CC = 2, BLHA_AMP_SC = 3, &
       BLHA_AMP_TREE = 4, BLHA_AMP_LOOPINDUCED = 5
  integer, public, parameter :: &
       BLHA_EW_GF = 1, BLHA_EW_MZ = 2, BLHA_EW_MSBAR = 3, &
       BLHA_EW_0 = 4, BLHA_EW_RUN = 5, BLHA_EW_DEFAULT = 6
  integer, public, parameter :: &
       BLHA_WIDTH_COMPLEX = 1, BLHA_WIDTH_FIXED = 2, &
       BLHA_WIDTH_RUNNING = 3, BLHA_WIDTH_POLE = 4, &
       BLHA_WIDTH_DEFAULT = 5 

@ %def blha_mest_sum blha_mest_avg blha_mest_other
@ %def blha_ct_qcd blha_ct_ew blha_ct_qed blha_ct_other
@ %def blha_irreg_cdr blha_irreg_dred blha_irreg_thv blha_irreg_mreg blha_irreg_other
@ %def blha_submode_none blha_submode_other
@ %def blha_mps_onshell blha_mps_other
@ %def blha_mode_gosam blha_mode_feynarts blha_mode_generic
@ %def blha_om_none blha_om_nocpl blha_om_other
@ %def blha version blha_amp blha_ew blha_width
@
This type encapsulates a BLHA request.
<<BLHA config: public>>=
  public :: blha_configuration_t
  public :: blha_cfg_process_node_t
<<BLHA config: types>>=
  type :: blha_cfg_process_node_t
     integer, dimension(:), allocatable :: pdg_in, pdg_out
     integer, dimension(:), allocatable :: fingerprint
     integer :: nsub
     integer, dimension(:), allocatable :: ids
     integer :: amplitude_type
     type(blha_cfg_process_node_t), pointer :: next => null ()
  end type blha_cfg_process_node_t

  type :: blha_configuration_t
     type(string_t) :: name
     class(model_data_t), pointer :: model => null ()
     type(string_t) :: md5
     integer :: version = 2
     logical :: dirty = .false.
     integer :: n_proc = 0
     real(default) :: accuracy_target
     logical :: debug_unstable
     integer :: mode = BLHA_MODE_GENERIC
     type(blha_cfg_process_node_t), pointer :: processes => null ()
     integer, dimension(2) :: matrix_element_square_type = BLHA_MEST_SUM
     !!! !!! !!! Triggers gfortran 4.9.0 ICE     
     ! type(string_t), dimension (2) :: matrix_element_square_type_other
     integer :: correction_type = BLHA_CT_QCD
     type(string_t) :: correction_type_other
     integer :: irreg = BLHA_IRREG_THV
     type(string_t) :: irreg_other
     integer :: massive_particle_scheme = BLHA_MPS_ONSHELL
     type(string_t) :: massive_particle_scheme_other
     integer :: subtraction_mode = BLHA_SUBMODE_NONE
     type(string_t) :: subtraction_mode_other
     type(string_t) :: model_file
     logical :: subdivide_subprocesses = .false.
     integer :: alphas_power = -1, alpha_power = -1
     integer :: ew_scheme = BLHA_EW_DEFAULT
     integer :: width_scheme = BLHA_WIDTH_DEFAULT
     integer :: operation_mode = BLHA_OM_NONE
     type(string_t) :: operation_mode_other
  end type blha_configuration_t

@ %def blha_cffg_process_node_t blha_configuration_t
@
This types control the creation of BLHA-interface files
<<BLHA config: public>>=
  public :: blha_flv_state_t
  public :: blha_master_t
<<BLHA config: types>>=
  type:: blha_flv_state_t
    integer, dimension(:), allocatable :: flavors
    integer :: flv_mult
    logical :: flv_real = .false.
  end type blha_flv_state_t

  type :: blha_master_t
    integer, dimension(3) :: blha_mode
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    integer :: n_in, n_out
    logical :: compute_loops = .true.
    logical :: compute_correlations = .false.
    logical :: compute_real_trees = .false.
    integer :: alpha_power, alphas_power
    type(string_t) :: basename
    type(string_t), dimension(:), allocatable :: suffix
    type(blha_configuration_t), dimension(:), allocatable :: blha_cfg
    integer :: n_files = 0
  contains
  <<BLHA config: blha master: TBP>>
  end type blha_master_t

@ %def blha_flv_state_t, blha_master_t
@ Master-Routines
<<BLHA config: blha master: TBP>>=
  procedure :: init => blha_master_init 
<<BLHA config: procedures>>=
  subroutine blha_master_init (master, basename, model, &
                               n_in, n_out, &
                               cmp_loops, cmp_corr, cmp_real, &
                               alpha_power, alphas_power, &
                               flv_born, flv_real)
    class(blha_master_t), intent(inout) :: master
    type(string_t), intent(in) :: basename
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    logical, intent(in) :: cmp_loops, cmp_corr, cmp_real
    integer, intent(in) :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable, intent(in) :: &
                             flv_born, flv_real
    integer :: n_proc, n_proc_real, n_flv
    type(blha_flv_state_t), dimension(:), allocatable :: blha_flavor
    integer :: i, i_flv
    integer :: i_file
    integer, dimension(:), allocatable :: amp_type

    n_proc = 0; n_flv = 1; n_proc_real = 0
    master%compute_real_trees = cmp_real
    if (cmp_loops) master%n_files = master%n_files+1
    if (cmp_corr) master%n_files = master%n_files+1
    if (cmp_real) then
       if (allocated (flv_real)) then
         master%n_files = master%n_files+1
         n_proc_real = size (flv_real, 2)
         n_flv = n_flv + n_proc_real
       end if
    end if
    allocate (master%blha_cfg (master%n_files))
    allocate (master%suffix (master%n_files))
    i_file = 1
    if (cmp_loops) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 2
          end do
          master%suffix(i_file) = "_LOOP"
          call blha_init_virtual (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(1))
          i_file = i_file+1
        else
          call msg_fatal ("GoSam Loops requested but " &
                           // "Born flavor not existing")
        end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (cmp_corr) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 3
          end do
          master%suffix(i_file) = "_SUB"
          call blha_init_subtraction (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(2))
          i_file = i_file+1
       else
          call msg_fatal ("GoSam Correlations requested but "&
                           // "Born flavor not existing")
       end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (cmp_real) then
       if (allocated (flv_real)) then
          allocate (blha_flavor (size (flv_real, 2)))
          do i_flv = 1, size (flv_real, 2)
             blha_flavor(i_flv)%flavors = flv_real(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 1
          end do
          master%suffix(i_file) = "_REAL"
          call blha_init_real (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(3))
       else
          call msg_fatal ("GoSam Trees requested but "&
                           // "Real flavor not existing")
       end if
    end if
  end subroutine blha_master_init

@ %def blha_master_init
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_gosam => blha_master_set_gosam
<<BLHA config: procedures>>=
  subroutine blha_master_set_gosam (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_GOSAM
  end subroutine blha_master_set_gosam

@ %def blha_master_set_gosam
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_openloops => blha_master_set_openloops
<<BLHA config: procedures>>=
  subroutine blha_master_set_openloops (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_OPENLOOPS
  end subroutine blha_master_set_openloops

@ %def blha_master_set_openloops
@
<<BLHA config: procedures>>=
  subroutine blha_init_virtual (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*2))
    do i = 1, size (blha_flavor)
       amp_type(2*i-1) = BLHA_AMP_LOOP
       amp_type(2*i) = BLHA_AMP_CC
    end do
    call blha_configuration_init (blha_cfg, basename // "_VIRT" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_virtual

  subroutine blha_init_subtraction (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*3))
    do i = 1, size (blha_flavor)
       amp_type(3*i-2) = BLHA_AMP_TREE
       amp_type(3*i-1) = BLHA_AMP_CC
       amp_type(3*i) = BLHA_AMP_SC
    end do
    call blha_configuration_init (blha_cfg, basename // "_SUB" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
!                                 debug = .true.)
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_subtraction

  subroutine blha_init_real (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)))
    do i = 1, size (blha_flavor)
       amp_type(i) = BLHA_AMP_TREE
    end do
    call blha_configuration_init (blha_cfg, basename // "_REAL" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp+1, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
!                                 debug = .true.)
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_real

@ %def blha_master_init_virtual, blha_master_init_real, blha_master_init_subtraction
@
<<BLHA config: blha master: TBP>>=
  procedure :: generate => blha_master_generate
<<BLHA config: procedures>>=
  subroutine blha_master_generate (master, basename)
    class(blha_master_t), intent(in) :: master
    type(string_t), intent(in) :: basename
    integer :: unit
    type(string_t) :: filename
    integer :: i_file
    do i_file = 1, master%n_files
       filename = basename // master%suffix(i_file) // ".olp"
       unit = free_unit ()
       open (unit, file = char (filename), status = 'replace', action = 'write')
       call blha_configuration_write (master%blha_cfg(i_file), unit)
       close (unit)
    end do
  end subroutine blha_master_generate

@ %def blha_master_generate
@    
Initializer.
<<BLHA config: public>>=
  public :: blha_configuration_init
<<BLHA config: procedures>>=
  subroutine blha_configuration_init (cfg, name, model, mode)
    type(blha_configuration_t), intent(inout) :: cfg
    type(string_t), intent(in) :: name
    class(model_data_t), target, intent(in) :: model
    integer, intent(in), optional :: mode
    if (.not. associated (cfg%model)) then
       cfg%name = name
       cfg%model => model
    end if
    if (present (mode)) cfg%mode = mode
  end subroutine blha_configuration_init

@ %def blha_configuration_init
@
Finalizer.
<<BLHA config: public>>=
  public :: blha_configuration_final
<<BLHA config: procedures>>=
  subroutine blha_configuration_final (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_cfg_process_node_t), pointer :: cur, next
    cur => cfg%processes
    do while (associated (cur))
       next => cur%next
       deallocate (cur)
       nullify (cur)
       cur => next
    end do
  end subroutine blha_configuration_final

@ %def blha_configuration_final
@
Merge sort a process list w.r.t. to the process fingerprints. This is
necessary for canonicalizing the process list prior to calculating the
MD5 sum. 
<<BLHA config: procedures>>=
  subroutine sort_processes (list, n)
    type(blha_cfg_process_node_t), pointer :: list
    integer, intent(in), optional :: n
    type :: pnode
       type(blha_cfg_process_node_t), pointer :: p
    end type pnode
    type(pnode), dimension(:), allocatable :: array
    integer :: count, i, s, i1, i2, i3
    type(blha_cfg_process_node_t), pointer :: node
    if (present (n)) then
       count = n
    else
       node => list
       count = 0
       do while (associated (node))
          node => node%next
          count = count + 1
       end do
    end if
    ! Store list nodes into an array
    if (count == 0) return
    allocate (array(count))
    i = 1
    node => list
    do i = 1, count
       array(i)%p => node
       node => node%next
    end do
    s = 1
    ! Merge sort the array
    do while (s < count)
       i = 0
       i1 = 1
       i2 = s
       do while (i2 < count)
          i3 = min (s*(i+2), count)
          array(i1:i3) = merge (array(i1:i2), array(i2+1:i3))
          i = i + 2
          i1 = s*i+1
          i2 = s*(i+1)
       end do
       s = s * 2
    end do
    ! Relink according to their new order
    list => array(1)%p
    nullify (array(count)%p%next)
    node => list
    do i = 2, count
       node%next => array(i)%p
       node => node%next
    end do

  contains

    ! .le. comparision
    function lt (n1, n2) result (predicate)
      type(blha_cfg_process_node_t), intent(in) :: n1, n2
      logical :: predicate
      integer :: i
      predicate = .true.
      do i = 1, size (n1%fingerprint)
         if (n1%fingerprint(i) < n2%fingerprint(i)) return
         if (n1%fingerprint(i) > n2%fingerprint(i)) then
            predicate = .false.
            return
         end if
      end do
    end function lt

    ! Sorting core --- merge two sorted chunks
    function merge (l1, l2) result (lo)
      type(pnode), dimension(:), intent(in) :: l1, l2
      type(pnode), dimension(size (l1) + size (l2)) :: lo
      integer :: i, i1, i2
      i1 = 1
      i2 = 1
      do i = 1, size (lo)
         if (i1 > size (l1)) then
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         elseif (i2 > size (l2)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         elseif (lt (l1(i1)%p, l2(i2)%p)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         else
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         end if
      end do
    end function merge

  end subroutine sort_processes
  
@ %def sort_processes
@
Create an array of massive particle indices, to be used by the 
"MassiveParticle"-statement of the order file.
<<BLHA config: procedures>>=
  subroutine blha_configuration_get_massive_particles &
             (cfg, massive, i_massive)
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out) :: massive
    integer, intent(out), dimension(:), allocatable :: i_massive
    integer, parameter :: max_particles = 10
    integer, dimension(max_particles) :: i_massive_tmp
    integer, dimension(max_particles) :: checked
    type(blha_cfg_process_node_t), pointer :: current_process 
    integer :: k
    integer :: n_massive
    n_massive = 0; k = 1
    checked = 0
    if (associated (cfg%processes)) then
       current_process => cfg%processes
    else
       call msg_fatal ("BLHA, massive particles: " // &
                       "No processes allocated!")
    end if
    do
       call check_pdg_list (current_process%pdg_in)
       call check_pdg_list (current_process%pdg_out)
       if (k > max_particles) &
          call msg_fatal ("BLHA, massive particles: " // &
                          "Max. number of particles exceeded!")
       if (associated (current_process%next)) then
          current_process => current_process%next
       else
          exit
       end if
    end do       
    if (n_massive > 0) then
       allocate (i_massive (n_massive))
       i_massive = i_massive_tmp (1:n_massive)
       massive = .true.
    else
       massive = .false.
    end if
  contains
    subroutine check_pdg_list (pdg_list)
       integer, dimension(:), intent(in) :: pdg_list
       integer :: i, i_pdg
       type(flavor_t) :: flv
       do i = 1, size (pdg_list)
          i_pdg = abs (pdg_list(i))
          call flv%init (i_pdg, cfg%model)
          if (flv%get_mass () > 0._default) then 
             !!! Avoid duplicates in output
             if (.not. any (checked == i_pdg)) then
                i_massive_tmp(k) = i_pdg
                checked(k) = i_pdg  
                k=k+1
                n_massive=n_massive+1
             end if
          end if
       end do
    end subroutine check_pdg_list
  end subroutine blha_configuration_get_massive_particles

@ %def blha_configuration_get_massive_particles
@
Append a process. This expands the flavor sum, sorts it and then
eliminates any duplicates.
<<BLHA config: public>>=
  public :: blha_configuration_append_process
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_process (cfg, pdg_in, pdg_out, nsub, ids)
    type(blha_configuration_t), intent(inout) :: cfg
    type(pdg_array_t), dimension(:), intent(in) :: pdg_in, pdg_out
    integer, optional, intent(in) :: nsub
    integer, optional, dimension(:), intent(in) :: ids
    type(blha_cfg_process_node_t), pointer :: root, node, tmp
    ! Multiindex for counting through the PDG numbers
    integer, dimension(size (pdg_in)) :: i_in
    integer, dimension(size (pdg_out)) :: i_out
    ! Handle the list of lists
    type :: ilist
       integer, dimension(:), allocatable :: i
    end type ilist
    type(ilist), dimension(size (pdg_in)) :: ilist_i
    type(ilist), dimension(size (pdg_out)) :: ilist_o
    integer :: i, j, nproc
    logical :: inc
    ! Extract PDGs into integer lists
    do i = 1, size (pdg_in)
       ilist_i(i)%i = pdg_in(i)
    end do
    do i = 1, size (pdg_out)
       ilist_o(i)%i = pdg_out(i)
    end do
    i_in = 1
    i_out = 1
    allocate (root)
    node => root
    ! Perform the expansion
    nproc = 0
    EXPAND: do
       ! Transfer the PDG selection...
       allocate (node%pdg_in(size (pdg_in)))
       allocate (node%pdg_out(size (pdg_out)))
       allocate (node%fingerprint (size (pdg_in) + size (pdg_out)))
       if (present (nsub)) node%nsub = nsub
       if (present (ids)) then
          allocate (node%ids(size (ids)))
          node%ids = ids
       end if
       forall (j=1:size(ilist_i)) &
          node%pdg_in(j) = ilist_i(j)%i(i_in(j))
       forall (j=1:size(ilist_o)) &
          node%pdg_out(j) = ilist_o(j)%i(i_out(j))
       node%fingerprint = [ node%pdg_in, sort (node%pdg_out) ]
       nproc = nproc + 1
       inc = .false.
       ! ... and increment the multiindex
       do j = 1, size (i_out)
          if (i_out(j) < size (ilist_o(j)%i)) then
             i_out(j) = i_out(j) + 1
             inc = .true.
             exit
          else
             i_out(j) = 1
          end if
       end do
       if (.not. inc) then
          do j = 1, size (i_in)
             if (i_in(j) < size (ilist_i(j)%i)) then
                i_in(j) = i_in(j) + 1
                inc = .true.
                exit
             else
                i_in(j) = 1
             end if
          end do
       end if
       if (.not. inc) exit EXPAND
       allocate (node%next)
       node => node%next
    end do EXPAND
    ! Do the sorting
    call sort_processes (root, nproc)
    ! Kill duplicates
    node => root
    do while (associated (node))
       if (.not. associated (node%next)) exit
       if (all (node%fingerprint == node%next%fingerprint)) then
          tmp => node%next%next
          deallocate (node%next)
          node%next => tmp
          nproc = nproc - 1
       else
          node => node%next
       end if
    end do
    ! Append the remaining list
    if (associated (cfg%processes)) then
       node => cfg%processes
       do while (associated (node%next))
          node => node%next
       end do
       node%next => root
    else
       cfg%processes => root
    end if
    cfg%n_proc = cfg%n_proc + nproc
    cfg%dirty = .true.
    
  end subroutine blha_configuration_append_process

@ %def blha_configuration_append_process
@
<<BLHA config: public>>=
  public :: blha_configuration_append_processes
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_processes (cfg, flavor, amp_type)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_flv_state_t), dimension(:), intent(in) :: flavor
    integer, dimension(:), intent(in), optional :: amp_type
    integer :: n_tot
    type(blha_cfg_process_node_t), pointer :: current_node
    integer :: i_process, i_flv
    integer, dimension(:), allocatable :: pdg_in, pdg_out
    integer, dimension(:), allocatable :: flavor_state
    integer :: proc_offset, n_proc_tot
    proc_offset = 0; n_proc_tot = 0
    do i_flv = 1, size (flavor)
       n_proc_tot = n_proc_tot + flavor(i_flv)%flv_mult
    end do
    if (.not. associated (cfg%processes)) &
      allocate (cfg%processes)
    current_node => cfg%processes
    do i_flv = 1, size (flavor)
       n_tot = size (flavor(i_flv)%flavors)
       allocate (pdg_in (2), pdg_out (n_tot - 2))
       allocate (flavor_state (n_tot))
       flavor_state = flavor(i_flv)%flavors
       do i_process = 1, flavor(i_flv)%flv_mult
          pdg_in = flavor_state (1:2)
          pdg_out = flavor_state (3:)
          current_node%pdg_in = pdg_in
          current_node%pdg_out = pdg_out
          current_node%amplitude_type = amp_type (proc_offset+i_process)
          if (proc_offset+i_process /= n_proc_tot) then
            allocate (current_node%next)
            current_node => current_node%next
          end if
          if (i_process == flavor(i_flv)%flv_mult) &
             proc_offset = proc_offset + flavor(i_flv)%flv_mult
       end do
       deallocate (pdg_in, pdg_out)
       deallocate (flavor_state)
    end do
  end subroutine blha_configuration_append_processes

@ %def blha_configuration_append_processes
@ Change parameter(s).
<<BLHA config: public>>=
  public :: blha_configuration_set
<<BLHA config: procedures>>=
!  subroutine blha_configuration_set ( cfg, &
!       matrix_element_square_type_hel, matrix_element_square_type_hel_other, &
!       matrix_element_square_type_col, matrix_element_square_type_col_other, &
!       correction_type, correction_type_other, &
!       irreg, irreg_other, &
!       massive_particle_scheme, massive_particle_scheme_other, &
!       subtraction_mode, subtraction_mode_other, &
!       model_file, subdivide_subprocesses, alphas_power, alpha_power, &
!       operation_mode, operation_mode_other)
  subroutine blha_configuration_set (cfg, &
!       version, amplitude_type, correction_type, irreg, massive_particle_scheme, &
       version, correction_type, irreg, massive_particle_scheme, &
       model_file, alphas_power, alpha_power, ew_scheme, width_scheme, &
       accuracy, debug)
    type(blha_configuration_t), intent(inout) :: cfg
    integer, optional, intent(in) :: version
!    integer, optional, intent(in) :: amplitude_type
!    integer, optional, intent(in) :: matrix_element_square_type_hel
!    type(string_t), optional, intent(in) :: matrix_element_square_type_hel_other
!    integer, optional, intent(in) :: matrix_element_square_type_col
!    type(string_t), optional, intent(in) :: matrix_element_square_type_col_other
    integer, optional, intent(in) :: correction_type
!    type(string_t), optional, intent(in) :: correction_type_other
    integer, optional, intent(in) :: irreg
!    type(string_t), optional, intent(in) :: irreg_other
    integer, optional, intent(in) :: massive_particle_scheme
!    type(string_t), optional, intent(in) :: massive_particle_scheme_other
!    integer, optional, intent(in) :: subtraction_mode
!    type(string_t), optional, intent(in) :: subtraction_mode_other
    type(string_t), optional, intent(in) :: model_file
!    logical, optional, intent(in) :: subdivide_subprocesses
    integer, optional, intent(in) :: alphas_power, alpha_power
    integer, optional, intent(in) :: ew_scheme
    integer, optional, intent(in) :: width_scheme
    real(default), optional, intent(in) :: accuracy
    logical, optional, intent(in) :: debug
!    integer, intent(in), optional :: operation_mode
!    type(string_t), intent(in), optional :: operation_mode_other
!    if (present (matrix_element_square_type_hel)) &
!       cfg%matrix_element_square_type(1) = matrix_element_square_type_hel
!    if (present (matrix_element_square_type_hel_other)) &
!       cfg%matrix_element_square_type_other(1) = matrix_element_square_type_hel_other
!    if (present (matrix_element_square_type_col)) &
!       cfg%matrix_element_square_type(2) = matrix_element_square_type_col
!    if (present (matrix_element_square_type_col_other)) &
!       cfg%matrix_element_square_type_other(2) = matrix_element_square_type_col_other
    if (present (version)) &
       cfg%version = version
!    if (present (amplitude_type)) &
!       cfg%amplitude_type = amplitude_type
    if (present (correction_type)) &
       cfg%correction_type = correction_type
!    if (present (correction_type_other)) &
!       cfg%correction_type_other = correction_type_other
    if (present (irreg)) &
       cfg%irreg = irreg
!    if (present (irreg_other)) &
!       cfg%irreg_other = irreg_other
    if (present (massive_particle_scheme)) &
       cfg%massive_particle_scheme = massive_particle_scheme
!    if (present (massive_particle_scheme_other)) &
!       cfg%massive_particle_scheme_other = massive_particle_scheme_other
!    if (present (subtraction_mode)) &
!       cfg%subtraction_mode = subtraction_mode
!    if (present (subtraction_mode_other)) &
!       cfg%subtraction_mode_other = subtraction_mode_other
    if (present (model_file)) &
       cfg%model_file = model_file
!    if (present (subdivide_subprocesses)) &
!       cfg%subdivide_subprocesses = subdivide_subprocesses
    if (present (alphas_power)) &
       cfg%alphas_power = alphas_power
    if (present (alpha_power)) &
       cfg%alpha_power = alpha_power
!    if (present (operation_mode)) &
!       cfg%operation_mode = operation_mode
!    if (present (operation_mode_other)) &
!       cfg%operation_mode_other = operation_mode_other
    if (present (ew_scheme)) &
       cfg%ew_scheme = ew_scheme
    if (present (width_scheme)) &
       cfg%width_scheme = width_scheme
    if (present (accuracy)) &
       cfg%accuracy_target = accuracy
    if (present (debug)) &
       cfg%debug_unstable = debug
    cfg%dirty = .false.
  end subroutine blha_configuration_set

@ %def blha_configuration_set
@
<<BLHA config: public>>=
  public :: blha_configuration_get_n_proc
<<BLHA config: procedures>>=
  function blha_configuration_get_n_proc (cfg) result (n_proc)
    type(blha_configuration_t), intent(in) :: cfg
    integer :: n_proc
    n_proc = cfg%n_proc
  end function blha_configuration_get_n_proc

@ %def blha_configuration_get_n_proc
@
Write the BLHA file. Internal mode is intented for md5summing only. 
<<BLHA config: public>>=
  public :: blha_configuration_write
<<BLHA config: procedures>>=
  subroutine blha_configuration_write (cfg, unit, internal)
    type(blha_configuration_t), intent(in) :: cfg
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: internal
    integer :: u
    logical :: full
    type(string_t) :: buf
    type(blha_cfg_process_node_t), pointer :: node
    integer :: i
    character(3) :: pdg_char
    character(6) :: accuracy
    character(len=25), parameter :: pad = ""
    integer, dimension(:), allocatable :: i_massive
    logical :: massive_particles
    u = given_output_unit (unit)
    full = .true.; if (present (internal)) full = .not. internal
    if (full .and. cfg%dirty) call msg_bug ( &
       "BUG: attempted to write out a dirty BLHA configuration")
    if (full) then
       write (u,'(A)') "# BLHA order written by WHIZARD <<Version>>"
       write (u,'(A)')
    end if
    select case (cfg%mode)
       case (BLHA_MODE_GOSAM); buf = "GoSam"
       case (BLHA_MODE_OPENLOOPS); buf = "OpenLoops"
       case default; buf = "vanilla"
    end select
    write (u,'(A)') "# BLHA interface mode: " // char (buf)
    write (u,'(A)') "# process: " // char (cfg%name)
    write (u,'(A)') "# model: " // char (cfg%model%get_name ())
!    if (full) then
!       write (u,'(A)')
!       write (u,'(A)') '#@WO MD5 "' // char (cfg%md5) // '"'
!       write (u,'(A)')
!    end if
!    if (all (cfg%matrix_element_square_type == BLHA_MEST_SUM)) then
!       buf = "CHsummed"
!    elseif (all (cfg%matrix_element_square_type == BLHA_MEST_AVG)) then
!       buf = "CHaveraged"
!    else
!       buf = (render_mest ("H", cfg%matrix_element_square_type(1), &
!             cfg%matrix_element_square_type_other(1)) // " ") // &
!          render_mest ("C", cfg%matrix_element_square_type(2), &
!             cfg%matrix_element_square_type_other(2))
!    end if
!    write (u,'(A25,A)') "MatrixElementSquareType" // pad, char (buf)
    select case (cfg%version)
       case (1); buf = "BLHA1"
       case (2); buf = "BLHA2"
    end select
    write (u, '(A25,A)') "InterfaceVersion " // pad, char (buf)
    select case (cfg%correction_type)
       case (BLHA_CT_QCD); buf = "QCD"
       case (BLHA_CT_EW); buf = "EW"
       case (BLHA_CT_QED); buf = "QED"
       case default; buf = cfg%correction_type_other
    end select
    write (u,'(A25,A)') "CorrectionType" // pad, char (buf)
    select case (cfg%irreg)
       case (BLHA_IRREG_CDR); buf = "CDR"
       case (BLHA_IRREG_DRED); buf = "DRED"
       case (BLHA_IRREG_THV); buf = "tHV"
       case (BLHA_IRREG_MREG); buf = "MassReg"
       case default; buf = cfg%irreg_other
    end select
    write (u,'(A25,A)') "IRregularisation" // pad, char (buf)
    select case (cfg%massive_particle_scheme)
       case (BLHA_MPS_ONSHELL); buf = "OnShell"
       case default; buf = cfg%massive_particle_scheme_other
    end select
    if (cfg%mode == BLHA_MODE_GOSAM) &
       write (u,'(A25,A)') "MassiveParticleScheme" // pad, char (buf)
!    select case (cfg%subtraction_mode)
!       case (BLHA_SUBMODE_NONE); buf = "None"
!       case default; buf = cfg%subtraction_mode_other
!    end select
!    write (u,'(A25,A)') "IRsubtractionMethod" // pad, char (buf)
!    write (u,'(A25,A)') "ModelFile" // pad, char (cfg%model_file)
!    if (cfg%subdivide_subprocesses) then
!       write (u,'(A25,A)') "SubdivideSubprocesses" // pad, "yes"
!    else
!       write (u,'(A25,A)') "SubdivideSubprocess" // pad, "no"
!    end if
    select case (cfg%version)
    case (1)
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "AlphasPower" // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u,'(A25,A)') &
         "AlphaPower " // pad, int2char (cfg%alpha_power)
    case (2) 
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "CouplingPower QCD " // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u, '(A25,A)') &
         "CouplingPower QED " // pad, int2char (cfg%alpha_power)
    end select
    select case (cfg%ew_scheme)
       case (BLHA_EW_GF); buf = "alphaGF"
       case (BLHA_EW_MZ); buf = "alphaMZ"
       case (BLHA_EW_MSBAR); buf = "alphaMSbar"
       case (BLHA_EW_0); buf = "alpha0"
       case (BLHA_EW_RUN); buf = "alphaRUN"
       case (BLHA_EW_DEFAULT); buf = "OLPDefined"
    end select
    write (u, '(A25, A)') "EWScheme " // pad, char (buf)
    call blha_configuration_get_massive_particles &
         (cfg, massive_particles, i_massive)
    if (massive_particles) then
       write (u, '(A25,10I2)') "MassiveParticles " // pad, i_massive
    end if
    if (full) then
       write (u,'(A)')
       write (u,'(A)') "# Process definitions"
       write (u,'(A)')
    end if
!    if (cfg%accuracy_target /= 0) then
!      write (accuracy, '(f6.5)') cfg%accuracy_target
!      write (u, '(A25,A)') "AccuracyTarget " // pad , accuracy 
!    end if
!    if (cfg%debug_unstable) then
!      buf = "True"
!    else
!      buf = "False"
!    end if
!   write (u, '(A25,A)') "DebugUnstable " // pad, char (buf)
    if (cfg%debug_unstable) &
      write (u, '(A25,A)') "DebugUnstable " // pad, "True"
    write (u, *)
    node => cfg%processes
    do while (associated (node))
       select case (node%amplitude_type)
         case (BLHA_AMP_LOOP); buf = "Loop"
         case (BLHA_AMP_CC); buf = "ccTree"
         case (BLHA_AMP_SC); buf = "scTree"
         case (BLHA_AMP_TREE); buf = "Tree"
         case (BLHA_AMP_LOOPINDUCED); buf = "LoopInduced"
       end select
       write (u, '(A25, A)') "AmplitudeType " // pad, char (buf)

       buf = ""
       do i = 1, size (node%pdg_in)
          write (pdg_char,'(I3)') node%pdg_in(i)
          buf = (buf // pdg_char) // " "
       end do
       buf = buf // "-> "
       do i = 1, size (node%pdg_out)
          write (pdg_char,'(I3)') node%pdg_out(i)
          buf = (buf // pdg_char) // " "
       end do
       write (u,'(A)') char (trim (buf))
       write (u, *)
       node => node%next
    end do

  contains

    function render_mest (prefix, mest, other) result (tag)
      character, intent(in) :: prefix
      integer, intent(in) :: mest
      type(string_t), intent(in) :: other
      type(string_t) :: tag
      select case (mest)
      case (BLHA_MEST_AVG); tag = prefix // "averaged"
      case (BLHA_MEST_SUM); tag = prefix // "summed"
      case default; tag = other
      end select
    end function render_mest

  end subroutine blha_configuration_write

@ %def blha_configuration_write
@
``Freeze'' the configuration by calculating the MD5 sum.
<<BLHA config: public>>=
  public :: blha_configuration_freeze
<<BLHA config: procedures>>=
  subroutine blha_configuration_freeze (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    integer :: u
    if (.not. cfg%dirty) return
    call sort_processes (cfg%processes)
    u = free_unit ()
    open (unit=u, status="scratch", action="readwrite")
    call blha_configuration_write (cfg, u, internal=.true.)
    rewind (u)
    cfg%md5 = md5sum (u)
    cfg%dirty = .false.
    close (u)
  end subroutine blha_configuration_freeze

@ %def blha_configuration_freeze
@
Read a contract file, again creating a [[blha_configuration_t]]
object. 
<<BLHA config: public>>=
  public :: blha_read_contract
<<BLHA config: interfaces>>=
  interface blha_read_contract
     module procedure blha_read_contract_unit, &
          blha_read_contract_file
  end interface blha_read_contract 
  
<<BLHA config: procedures>>=
  subroutine blha_read_contract_file (cfg, ok, fname, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(string_t), intent(in) :: fname
    logical, intent(out), optional :: success
    integer :: u, stat
    u = free_unit ()
    open (u, file=char (fname), status="old", action="read", iostat=stat)
    if (stat /= 0) then
       if (present (success)) then
          success = .false.
          return
       else
          call msg_bug ('Unable to open contract file "' // char (fname) // '"')
       end if
    end if
    call blha_read_contract_unit (cfg, ok, u, success)
    close (u)
  end subroutine blha_read_contract_file

  subroutine blha_read_contract_unit (cfg, ok, u, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    integer, intent(in) :: u
    logical, intent(out), optional :: success
    type(stream_t) :: stream
    type(ifile_t) :: preprocessed
    type(lexer_t) :: lexer
    type(parse_tree_t) :: parse_tree
    type(string_t) :: md5
    call stream_init (stream, u)
    call contract_preprocess (stream, preprocessed)
    call stream_final (stream)
    call stream_init (stream, preprocessed)
    call blha_init_lexer (lexer)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_blha_contract, lexer)
    call blha_transfer_contract (cfg, ok, parse_tree, success)
    call blha_configuration_write (cfg, internal=.true.)
    call lexer_final (lexer)
    call stream_final (stream)
    call ifile_final (preprocessed)
    if (ok) then
       md5 = cfg%md5
       call blha_configuration_freeze (cfg)
       if (char (trim (md5 )) /= "") then
          if (md5 /= cfg%md5) then
             call msg_warning ("BLHA contract does not match the recorded " &
                // "checksum --- this counts as an error!")
             ok = .false.
          end if
       else
          call msg_warning ("It seems the OLP scrubbed our checksum, unable " &
             // "to check contract consistency.")
       end if
    end if
  end subroutine blha_read_contract_unit

@ %def blha_read_contract blha_read_contract_file 
@ %def blha_read_contract_unit
@
Walk the parse tree and transfer the results to the
[[blha_configuration]] object. The [[goto]] is a poor man's
replacement for exceptions which would be an appropiate error handling  
mechanism here. 
<<BLHA config: procedures>>=
  subroutine blha_transfer_contract (cfg, ok, parse_tree, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(parse_tree_t), intent(in), target :: parse_tree
    logical, intent(out), optional :: success
    type(parse_node_t), pointer :: pn_root, pn_line, pn_request, &
         pn_result, pn_key, pn_opt, pn_state_in, pn_state_out, pn_pdg
    type(string_t) :: emsg
    integer :: nopt, i, nsub
    integer, dimension(:), allocatable :: ids
    logical, dimension(2) :: flags
    type(pdg_array_t), dimension(:), allocatable :: pdg_in, pdg_out
    ok = .true.
    pn_root => parse_tree_get_root_ptr (parse_tree)
    pn_line => parse_node_get_sub_ptr (pn_root)
    do while (associated (pn_line))
       pn_request => parse_node_get_sub_ptr (pn_line)
       if (.not. associated (pn_request)) cycle
       if (char (parse_node_get_rule_key (pn_request)) == "process") then
          pn_result => parse_node_get_sub_ptr (pn_line, 2)
          pn_state_in => parse_node_get_sub_ptr (pn_request, 1)
          pn_state_out => parse_node_get_sub_ptr (pn_request, 3)
          allocate (pdg_in (parse_node_get_n_sub (pn_state_in)))
          allocate (pdg_out (parse_node_get_n_sub (pn_state_out)))
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_in)
          do while (associated (pn_pdg))
             pdg_in(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_out)
          do while (associated (pn_pdg))
             pdg_out(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = parse_node_get_n_sub (pn_result)
          emsg = "broken process line"
          if (i < 2) goto 10
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          do while (associated (pn_opt))
             if (char (parse_node_get_rule_key (pn_opt)) == "string") then
                call msg_warning ("While reading the BLHA contract: " // &
                   'the OLP returned an error for a process: "' // &
                   char (parse_node_get_string (pn_opt)) // '"')
                ok = .false.
                return
             end if
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          nsub = get_int (pn_opt)
          if (nsub /= i - 2) goto 10
          allocate (ids(nsub))
          i = 1
          pn_opt => parse_node_get_next_ptr (pn_opt)
          do while (associated (pn_opt))
             ids(i) = get_int (pn_opt)
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          call blha_configuration_append_process (cfg, pdg_in, pdg_out, &
             nsub=nsub, ids=ids)
          deallocate (pdg_in, pdg_out, ids)
       else
          pn_result => parse_node_get_sub_ptr (parse_node_get_next_ptr (pn_request), 2)
          pn_key => parse_node_get_sub_ptr (pn_request)
          pn_opt => parse_node_get_next_ptr (pn_key)
          nopt = parse_node_get_n_sub (pn_request) - 1
          select case (char (parse_node_get_rule_key (pn_key)))
             case ("md5")
                cfg%md5 = parse_node_get_string (pn_opt)
             case ("modelfile")
                cfg%model_file = get_fname (pn_opt)
                call check_result (pn_result, "ModelFile")
             case ("irregularisation")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("cdr"); cfg%irreg = BLHA_IRREG_CDR
                   case ("dred"); cfg%irreg = BLHA_IRREG_DRED
                   case ("thv"); cfg%irreg = BLHA_IRREG_THV
                   case ("mreg"); cfg%irreg = BLHA_IRREG_MREG
                   case default
                      cfg%irreg = BLHA_IRREG_OTHER 
                      cfg%irreg_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "IRRegularisation")
             case ("irsubtractionmethod")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("none"); cfg%subtraction_mode = BLHA_SUBMODE_NONE
                   case default
                      cfg%subtraction_mode = BLHA_SUBMODE_OTHER
                      cfg%subtraction_mode_other = parse_node_get_string(pn_opt)
                end select
                call check_result (pn_result, "IRSubtractionMethod")
             case ("massiveparticlescheme")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("onshell")
                      cfg%massive_particle_scheme = BLHA_MPS_ONSHELL
                   case default
                      cfg%massive_particle_scheme = BLHA_MPS_OTHER
                      cfg%massive_particle_scheme_other = &
                         parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "MassiveParticleScheme")
             case ("matrixelementsquaretype")
                select case (nopt)
                   case (1)
                      select case (lower_case (char (parse_node_get_string (pn_opt))))
                         case ("chsummed")
                            cfg%matrix_element_square_type = BLHA_MEST_SUM
                         case ("chaveraged")
                            cfg%matrix_element_square_type = BLHA_MEST_AVG
                         case default
                            emsg = "invalid MatrixElementSquareType: " // &
                               parse_node_get_string (pn_opt)
                            goto 10
                      end select
                   case (2)
                      do i = 1, 2
                         pn_opt => parse_node_get_next_ptr (pn_key, i)
                         select case (lower_case (char (parse_node_get_string ( &
                               pn_opt))))
                            case ("csummed")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_SUM
                               flags(2) = .true.
                            case ("caveraged")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_AVG
                               flags(2) = .true.
                            case ("hsummed")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_SUM
                               flags(1) = .true.
                            case ("haveraged")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_AVG
                               flags(1) = .true.
                            case default
                               emsg = "invalid MatrixElementSquareType: " // &
                                  parse_node_get_string (pn_opt)
                               goto 10
                         end select
                      end do
                      if (.not. all (flags)) then
                         emsg = "MatrixElementSquareType: setup not exhaustive"
                         goto 10
                      end if
                   case default
                      emsg = "MatrixElementSquareType: too many options"
                      goto 10
                end select
                call check_result (pn_result, "MatrixElementSquareType")
             case ("correctiontype")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("qcd"); cfg%correction_type = BLHA_CT_QCD
                   case ("qed"); cfg%correction_type = BLHA_CT_QED
                   case ("ew"); cfg%correction_type = BLHA_CT_EW
                   case default
                      cfg%correction_type = BLHA_CT_OTHER
                      cfg%correction_type_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "CorrectionType")
             case ("alphaspower")
                cfg%alphas_power = get_int (pn_opt)
                call check_result (pn_result, "AlphasPower")
             case ("alphapower")
                cfg%alpha_power = get_int (pn_opt)
                call check_result (pn_result, "AlphaPower")
             case ("subdividesubprocess")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("yes"); cfg%subdivide_subprocesses = .true.
                   case ("no"); cfg%subdivide_subprocesses = .false.
                   case default
                      emsg = 'SubdivideSubprocess: invalid argument "' // &
                         parse_node_get_string (pn_opt) // '"'
                      goto 10
                end select
                call check_result (pn_result, "SubdivideSubprocess")
             case default
                emsg = "unknown statement: " // parse_node_get_rule_key (pn_key)
                goto 10
          end select
       end if
       pn_line => parse_node_get_next_ptr (pn_line)
    end do
    if (present (success)) success = .true.
    return
10  continue
    if (present (success)) then
       call msg_error ("Error reading BLHA contract: " // char (emsg))
       success = .false.
       return
    else
       call msg_fatal ("Error reading BLHA contract: " // char (emsg))
    end if

  contains

    function get_int (pn) result (i)
      type(parse_node_t), pointer :: pn
      integer :: i
      if (char (parse_node_get_rule_key (pn)) == "integer") then
         i = parse_node_get_integer (pn)
      else
         i = parse_node_get_integer (parse_node_get_sub_ptr (pn, 2))
         if (char (parse_node_get_rule_key (parse_node_get_sub_ptr (pn))) &
              == "-") i = -i
      end if
    end function get_int

    subroutine check_result (pn, step)
      type(parse_node_t), pointer :: pn
      character(*), intent(in) :: step
      type(string_t) :: res
      res = parse_node_get_string (pn)
      if (char (trim (res)) == "") then
         call msg_warning ("BLHA contract file: " // step // &
              ": OLP didn't return a status --- assuming an error")
         ok = .false.
      elseif (char (upper_case (res)) /= "OK") then
         call msg_warning ("BLHA contract file: " // step // &
              ': OLP error "' // char (res) // '"')
         ok = .false.
      end if
    end subroutine check_result

    function get_fname (pn) result (fname)
      type(parse_node_t), pointer :: pn
      type(string_t) :: fname
      type(parse_node_t), pointer :: pn_component
      if (char (parse_node_get_rule_key (pn)) == "string") then
         fname = parse_node_get_string (pn)
      else
         fname = ""
         pn_component => parse_node_get_sub_ptr (pn)
         do while (associated (pn_component))
            if (char (parse_node_get_rule_key (pn_component)) == "id") then
               fname = fname // parse_node_get_string (pn_component)
            else
               fname = fname // parse_node_get_key (pn_component)
            end if
            pn_component => parse_node_get_next_ptr (pn_component)
         end do
      end if
    end function get_fname

  end subroutine blha_transfer_contract

@ %def blha_transfer_contract
@
Initialize the lexer.
<<BLHA config: procedures>>=
  subroutine blha_init_lexer (lexer)
    type(lexer_t), intent(inout) :: lexer
    call lexer_init (lexer, &
       comment_chars = "#", &
       quote_chars = '"', &
       quote_match = '"', &
       single_chars = '{}|./\:', &
       special_class = ["->"], &
       keyword_list = syntax_get_keyword_list_ptr (syntax_blha_contract), &
       upper_case_keywords = .false. &
       ) 
  end subroutine blha_init_lexer

@ %def blha_init_lexer
@
Define the parser syntax table.
<<BLHA config: variables>>=
  type(syntax_t), target, save :: syntax_blha_contract
<<BLHA config: public>>=
  public :: syntax_blha_contract_init
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_init ()
    type(ifile_t) :: ifile
    call ifile_append (ifile, "SEQ contract = line*")
    call ifile_append (ifile, "KEY '->'")
    call ifile_append (ifile, "KEY '.'")
    call ifile_append (ifile, "KEY '/'")
    call ifile_append (ifile, "KEY '\'")
    call ifile_append (ifile, "KEY '+'")
    call ifile_append (ifile, "KEY '-'")
    call ifile_append (ifile, "KEY '|'")
    call ifile_append (ifile, "KEY ':'")
    call ifile_append (ifile, "IDE id")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "ALT sign = '+' | '-'")
    call ifile_append (ifile, "SEQ signed_integer = sign integer")
    call ifile_append (ifile, "QUO string = '""'...'""'")
    call ifile_append (ifile, "GRO line = '{' line_contents '}'")
    call ifile_append (ifile, "SEQ line_contents = request result?")
    call ifile_append (ifile, "ALT request = definition | process")
    call ifile_append (ifile, "ALT definition = option_unary | option_nary | " &
       // "option_path | option_numeric")
    call ifile_append (ifile, "KEY matrixelementsquaretype")
    call ifile_append (ifile, "KEY irregularisation")
    call ifile_append (ifile, "KEY massiveparticlescheme")
    call ifile_append (ifile, "KEY irsubtractionmethod")
    call ifile_append (ifile, "KEY modelfile")
    call ifile_append (ifile, "KEY operationmode")
    call ifile_append (ifile, "KEY subdividesubprocess")
    call ifile_append (ifile, "KEY alphaspower")
    call ifile_append (ifile, "KEY alphapower")
    call ifile_append (ifile, "KEY correctiontype")
    call ifile_append (ifile, "KEY md5")
    call ifile_append (ifile, "SEQ option_unary = key_unary arg")
    call ifile_append (ifile, "SEQ option_nary = key_nary arg+")
    call ifile_append (ifile, "SEQ option_path = key_path arg_path")
    call ifile_append (ifile, "SEQ option_numeric = key_numeric arg_numeric")
    call ifile_append (ifile, "ALT key_unary = irregularisation | " &
       // "massiveparticlescheme | irsubtractionmethod | subdividesubprocess | " &
       // "correctiontype | md5")
    call ifile_append (ifile, "ALT key_nary = matrixelementsquaretype | " &
       // "operationmode")
    call ifile_append (ifile, "ALT key_numeric = alphaspower | alphapower")
    call ifile_append (ifile, "ALT key_path = modelfile")
    call ifile_append (ifile, "ALT arg = id | string")
    call ifile_append (ifile, "ALT arg_numeric = integer | signed_integer")
    call ifile_append (ifile, "ALT arg_path = filename | string")
    call ifile_append (ifile, "SEQ filename = filename_atom+")
    call ifile_append (ifile, "ALT filename_atom = id | '.' | '/' | '\' | ':'")
    call ifile_append (ifile, "SEQ process = state '->' state")
    call ifile_append (ifile, "SEQ state = pdg+")
    call ifile_append (ifile, "ALT pdg = integer | signed_integer")
    call ifile_append (ifile, "SEQ result = '|' result_atom+")
    call ifile_append (ifile, "ALT result_atom = integer | string")
    call syntax_init (syntax_blha_contract, ifile)
    call ifile_final (ifile)
  end subroutine syntax_blha_contract_init

@ %def syntax_blha_contract_init
@
<<BLHA config: public>>=
  public :: syntax_blha_contract_final
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_final
    call syntax_final (syntax_blha_contract)
  end subroutine syntax_blha_contract_final

@ %def syntax_blha_contract_final
@
As the contract file is line-oriented, we apply a preprocessing step which
reformats the file in a way suitable for our free-form parser.
<<BLHA config: procedures>>=
  subroutine contract_preprocess (stream, ifile)
    type(stream_t), intent(inout) :: stream
    type(ifile_t), intent(out) :: ifile
    type(string_t) :: buf, reg, transformed
    integer :: stat, n
    buf = ""
    LINES: do
       call stream_get_record (stream, reg, stat)
       select case (stat)
          case (0)
          case (EOF); exit LINES
          case default
             call msg_bug ("I/O error while reading BLHA contract file")
       end select
       buf = buf // trim (reg)
       ! Take care of continuation lines
       if (char (extract (buf, len (buf), len(buf))) == '&') then
          buf = extract (buf, 1, len (buf) - 1) // " "
          cycle LINES
       end if
       buf = adjustl (buf)
       ! Transform #@WO comments into ordinary statements
       if (char (extract (buf, 1, 4)) == "#@WO") &
          buf = extract (buf, 5)
       ! Kill comments and blank lines
       if ((char (trim (buf)) == "") .or. &
          (char (extract (buf, 1, 1)) == "#")) then
             buf = ""
             cycle LINES
          end if
       ! Chop off any end-of-line comments
       call split (buf, reg, "#")
       ! Split line into order and result
       call split (reg, buf, "|")
       reg = trim (adjustl (reg))
       buf = trim (adjustl (buf))
       ! Check whether the order is a process definition
       n = scan (buf, ">")
       if (n == 0) then
          ! No -> quote result
          reg = ('"' // reg) // '"'
       else
          ! Yes -> leave any numbers as they are, quote any leftovers
          n = scan (reg, "0123456789", back=.true.)
          if (n < len (reg)) &
             reg = char (extract (reg, 1, n)) // ' "' // &
                char (trim (adjustl (extract (reg, n+1)))) // '"'
       end if
       ! Enclose the line into curly brackets
       transformed = "{" // char (buf) // " | " // char (reg) // "}"
       call ifile_append (ifile, transformed)
       buf = ""
    end do LINES
  end subroutine contract_preprocess

@ %def contract_preprocess
@
Test.
<<BLHA config: public>>=
  public :: blha_config_test
<<BLHA config: procedures>>=
  subroutine blha_config_test (model, cfg, ok)
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(4) :: pdg_out
    class(model_data_t), pointer :: model
    type(blha_configuration_t), intent(out) :: cfg
    logical, intent(out) :: ok
    integer :: u
    logical :: flag
    ok = .false.
    pdg_in(1) = [1, 2, -1, -2]
    pdg_in(2) = pdg_in(1)
    pdg_out(1) = pdg_in(1)
    pdg_out(2) = [11]
    pdg_out(3) = [-11]
    pdg_out(4) = pdg_out(1)
    call blha_configuration_init (cfg, var_str ("test"), model)
    call blha_configuration_set (cfg, alphas_power = 2, alpha_power = 3)
    call blha_configuration_append_process (cfg, pdg_in, pdg_out)
    call blha_configuration_freeze (cfg)
    print *
    call blha_configuration_write (cfg)
    print *
    call blha_configuration_final (cfg)
    call blha_configuration_init (cfg, var_str ("test"), model, &
       mode=BLHA_MODE_GOSAM)
    call blha_configuration_set (cfg, alphas_power = 0, &
       model_file = var_str ("test.slha"))
    pdg_in(1) = [1]
    pdg_in(2) = [-1]
    pdg_out(1) = [22]
    pdg_out(2) = [22]   
    call blha_configuration_append_process (cfg, pdg_in, pdg_out(1:2))
    call blha_configuration_freeze (cfg)
    u = free_unit ()
    open (u, file="test.blha.order", action="write", status="replace")
    call blha_configuration_write (cfg, u)
    call blha_configuration_final (cfg)
    inquire (file="test.blha.contract", exist=flag)
    if (.not. flag) return
    call blha_configuration_init (cfg, var_str ("test"), model, mode=BLHA_MODE_GOSAM)
    call blha_read_contract (cfg, ok, var_str ("test.blha.contract"), success=flag)
    print *, "Reading back processed configuration: success? ", ok
  end subroutine blha_config_test

@ %def blha_config_test
@

\section{OLP matrix element interface}

The prototypes of the OLP functions.
<<BLHA interface: interfaces>>=
  abstract interface
     subroutine ext_olp_start (file, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: file
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_Start

     subroutine ext_olp_evalsubprocess &
          (label, momenta, scale, parameters, amp) bind(c)
       import
       integer(c_int), intent(in), value :: label
       real(c_double), dimension(*), intent(in) :: momenta
       real(c_double), intent(in), value :: scale
       real(c_double), dimension(*), intent(in) :: parameters
       real(c_double), dimension(*), intent(out) :: amp
     end subroutine ext_olp_evalsubprocess

     subroutine ext_olp_finalize () bind(c)
     end subroutine ext_olp_finalize

     subroutine ext_olp_option (assignment, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: assignment
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_option
  end interface

@ %def ext_olp_start ext_olp_evalsubprocess ext_olp_finalize
@ %def ext_olp_option
@
The OLP library is encapsulated together with the configuration in
derived type: 
<<BLHA interface: public>>=
  public :: blha_olp_t
<<BLHA interface: types>>=
  type :: blha_olp_t
     private
     type(blha_configuration_t) :: cfg
     type(string_t) :: library
     integer :: n_in, n_out, n_flv, n_hel, n_col
     integer, dimension(:,:), allocatable :: flv_state
     logical :: color_summed = .true., flavor_summed = .true.
     logical :: loaded = .false.
     type(dlaccess_t) :: lib_handle
     procedure(ext_olp_start), pointer, nopass :: olp_start => null ()
     procedure(ext_olp_evalsubprocess), pointer, nopass :: &
        olp_evalsubprocess => null ()
     procedure(ext_olp_finalize), pointer, nopass :: olp_finalize => null ()
     procedure(ext_olp_option), pointer, nopass :: olp_option => null ()
  end type blha_olp_t

@ %def blha_olpt_t
@
Init the [[blha_olp_t]] object and try to dlopen the library. 
<<BLHA interface: public>>=
  public :: blha_olp_init
<<BLHA interface: procedures>>=
  subroutine blha_olp_init (olp, cfg, library, success)
    type(blha_olp_t), intent(out) :: olp
    type(string_t), intent(in), optional :: library
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out), optional :: success
    type(blha_cfg_process_node_t), pointer :: node
    type(string_t) :: prefix, libname
    type(c_funptr) :: fptr
    integer :: olp_status
    success = .true.
    node => cfg%processes
    if (.not. associated (node)) then
       call error ("blha_interface_init: empty process list")
       return
    end if
    olp%n_in = size (node%pdg_in)
    olp%n_out = size (node%pdg_out)
    do while (associated (node))
       if ((olp%n_in /= size (node%pdg_in)) .or. &
             (olp%n_out /= size (node%pdg_out))) then
          call error ("blha_interface_init: inconsistent process list")
          return
       end if
       node => node%next
    end do
    if (present (library)) then
       olp%library = library
    else
       olp%library = cfg%name // ".so"
    end if
    if (char (extract (olp%library, 1, 1)) == "/") then
       prefix = ""
       libname = extract (olp%library, 2)
    else
       prefix = "."
       libname = olp%library
    end if
    call dlaccess_init (olp%lib_handle, prefix, libname)
    if (dlaccess_has_error (olp%lib_handle)) then
       call error ("blha_interface_init: error opening library: " // &
          char (dlaccess_get_error (olp%lib_handle)))
       call dlaccess_final (olp%lib_handle)
       return
    end if
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Start"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_start)
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_EvalSubProcess"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_evalsubprocess)
    if (olp%cfg%mode == BLHA_MODE_GOSAM) then
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Finalize"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_finalize)
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Option"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_option)
    end if
    call olp%olp_start (string_f2c (cfg%model_file), olp_status)
    if (olp_status /= 1) then
       call error ("blha_interface_init: OLP initialization failed")
       call dlaccess_final (olp%lib_handle)
    end if
    success = .true.
    olp%loaded = .true.

  contains

    function check_dlstate () result (ok)
      logical :: ok
      ok = .not. dlaccess_has_error (olp%lib_handle)
      if (.not. ok) then
         call error ("blha_interface_init: error loading library: " // &
              char (dlaccess_get_error (olp%lib_handle)))
         call dlaccess_final (olp%lib_handle)
      end if
    end function check_dlstate
   
    subroutine error (msg)
      character(*), intent(in) :: msg
      if (present (success)) then
         call msg_error (msg)
         success = .false.
      else
         call msg_fatal (msg)
      end if
    end subroutine error

  end subroutine blha_olp_init

@ %def blha_olp_init
@ Finalizer.
<<BLHA interface: public>>=
  public :: blha_olp_final
<<BLHA interface: procedures>>=
  subroutine blha_olp_final (olp)
    type(blha_olp_t), intent(inout) :: olp
    if (.not. olp%loaded) return
    if (associated (olp%olp_finalize)) call olp%olp_finalize
    call dlaccess_final (olp%lib_handle)
    olp%loaded = .false.
  end subroutine blha_olp_final

@ %def blha_olp_final
@ Test.
<<BLHA interface: public>>=
  public :: blha_interface_test
<<BLHA interface: procedures>>=
  subroutine blha_interface_test (cfg, ok)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_olp_t) :: olp
    logical, intent(out) :: ok
    call blha_olp_init (olp, cfg, library=var_str ("blha_test.so"), success=ok)
    print *, "loading OLP library: success?", ok
    call blha_olp_final (olp)
  end subroutine blha_interface_test

@ %def blha_interface_test
@
\section{OLP driver}

<<BLHA driver: public>>=
  public :: blha_test
<<BLHA driver: procedures>>=
  subroutine blha_test (model)
    class(model_data_t), pointer :: model
    type (blha_configuration_t) :: cfg
    logical :: ok
    call blha_config_test (model, cfg, ok)
    if (ok) call blha_interface_test (cfg, ok)
  end subroutine blha_test

@ %def blha_test
