% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{BLHA Interface}

The code in this chapter implements support for the BLHA record that
communicates data for NLO processes.

These are the modules:
\begin{description}
\item[blha\_config]
\item[blha\_interface]
\item[blha\_driver]
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module definition}

These modules implement the communication with one loop matrix element providers
according to the Binoth LesHouches Accord Interface. The actual matrix
element(s) are loaded as a dynamic library.

This module defines the common OLP-interfaces defined through the Binoth Les-Houches 
accord.

<<[[blha_olp_interfaces.f90]]>>=
<<File header>>

module blha_olp_interfaces

  use, intrinsic :: iso_c_binding !NODEP!
  use, intrinsic :: iso_fortran_env

  use kinds
<<Use strings>>
  use system_defs, only: TAB
  use io_units
  use string_utils
  use physics_defs
  use diagnostics
  use os_interface
  use lorentz
  use sm_qcd
  use interactions
  use flavors
  use model_data

  use prclib_interfaces
  use process_libraries
  use prc_core_def
  use prc_core

  use blha_config

<<Standard module head>>

<<BLHA OLP interfaces: public>>

<<BLHA OLP interfaces: public parameters>>

<<BLHA OLP interfaces: types>>

<<BLHA OLP interfaces: interfaces>>

contains

<<BLHA OLP interfaces: procedures>>

end module blha_olp_interfaces

@ %def module blha_olp_interfaces
@
<<BLHA OLP interfaces: public>>=
  public :: blha_template_t
<<BLHA OLP interfaces: types>>=
  type :: blha_template_t
    integer :: I_REAL = 1
    integer :: I_LOOP = 2
    integer :: I_SUB = 3
    logical, dimension(3) :: compute_component
  contains
  <<BLHA OLP interfaces: blha template: TBP>>
  end type blha_template_t

@ %def blha_template_t
@
<<BLHA OLP interfaces: public>>=
  public :: prc_blha_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_core_t) :: prc_blha_t
    type(qcd_t) :: qcd
    integer :: n_flv
    integer :: n_particles
    real(default) :: maximum_accuracy = 10000.0
    integer, dimension(:), allocatable :: i_born, i_sc, i_cc
    integer, dimension(:), allocatable :: i_real
    integer, dimension(:), allocatable :: i_virt
  contains
  <<BLHA OLP interfaces: prc blha: TBP>>
  end type prc_blha_t

@ 
@ %def prc_blha_t
<<BLHA OLP interfaces: public>>=
  public :: blha_driver_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_core_driver_t) :: blha_driver_t 
    type(string_t) :: contract_file
    procedure(olp_start),nopass,  pointer :: &
              blha_olp_start => null ()
    procedure(olp_eval), nopass, pointer :: &
              blha_olp_eval => null()
    procedure(olp_info), nopass, pointer :: &
              blha_olp_info => null ()
    procedure(olp_set_parameter), nopass, pointer :: &
              blha_olp_set_parameter => null ()
    procedure(olp_eval2), nopass, pointer :: &
              blha_olp_eval2 => null ()
    procedure(olp_option), nopass, pointer :: &
              blha_olp_option => null ()
    procedure(olp_polvec), nopass, pointer :: &
              blha_olp_polvec => null ()
    procedure(olp_finalize), nopass, pointer :: &
              blha_olp_finalize => null ()
    procedure(olp_print_parameter), nopass, pointer :: &
              blha_olp_print_parameter => null ()
@ We have to add two O'Mega-routines to the GoSam driver to ensure
  proper process setup.
<<BLHA OLP interfaces: types>>=
    procedure(omega_update_alpha_s), nopass, pointer :: &
              update_alpha_s => null ()
    procedure(omega_is_allowed), nopass, pointer :: &
              is_allowed => null ()
  contains
  <<BLHA OLP interfaces: blha driver: TBP>>
  end type blha_driver_t

@ 
@ %def blha_driver_t
<<BLHA OLP interfaces: public>>=
  public :: prc_blha_writer_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_writer_f_module_t) :: prc_blha_writer_t
    type(blha_configuration_t) :: blha_cfg
    type(string_t) :: model_name
    type(string_t) :: process_mode
    type(string_t) :: process_string
  contains
  <<BLHA OLP interfaces: blha writer: TBP>>
  end type prc_blha_writer_t

@ 
@ %def prc_blha_writer_t
<<BLHA OLP interfaces: public>>=
  public :: blha_def_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_core_def_t) :: blha_def_t
    type(string_t) :: basename
    type(string_t) :: suffix
  contains
  <<BLHA OLP interfaces: blha def: TBP>>
  end type blha_def_t

@ 
@ %def blha_def_t
<<BLHA OLP interfaces: public>>=
  public :: blha_state_t
<<BLHA OLP interfaces: types>>=
  type, abstract, extends (prc_core_state_t) :: blha_state_t
    logical :: new_kinematics = .true.
    real(default) :: alpha_qcd = -1
  contains
  <<BLHA OLP interfaces: blha state: TBP>>
  end type blha_state_t

@ %def blha_state_t
@
<<BLHA OLP interfaces: blha state: TBP>>=
  procedure :: reset_new_kinematics => blha_state_reset_new_kinematics
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_state_reset_new_kinematics (object)
    class(blha_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine blha_state_reset_new_kinematics

@ %def blha_state_reset_new_kinematics
@
<<BLHA OLP interfaces: blha def: TBP>>=
  procedure, nopass :: needs_code => blha_def_needs_code
<<BLHA OLP interfaces: procedures>>=
  function blha_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function blha_def_needs_code

@  %def blha_def_needs_code
@
<<BLHA OLP interfaces: blha def: TBP>>=
  procedure, nopass :: get_features => blha_def_get_features
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine blha_def_get_features 

@
@ %def blha_def_get_features
<<BLHA OLP interfaces: blha def: TBP>>=
  procedure :: connect => blha_def_connect
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_def_connect (def, lib_driver, i, proc_driver)   
    class(blha_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    integer :: pid, fid
    class(prc_core_driver_t), intent(inout) :: proc_driver
    type(c_funptr) :: fptr
    select type (proc_driver)
    class is (blha_driver_t)       
       pid = i
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
       fid = 4
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%is_allowed)
    end select
  end subroutine blha_def_connect

@ 
@ %def blha_def_connect
<<BLHA OLP interfaces: public parameters>>=
  integer, parameter, public :: OLP_PARAMETER_LIMIT = 10
  integer, parameter, public :: OLP_MOMENTUM_LIMIT = 50
  integer, parameter, public :: OLP_RESULTS_LIMIT = 60

<<BLHA OLP interfaces: public>>=
  public :: olp_start
<<BLHA OLP interfaces: interfaces>>=
  interface 
    subroutine olp_start (contract_file_name, ierr) bind (C,name="OLP_Start")
      import
      character(kind=c_char, len=1), intent(in) :: contract_file_name
      integer(kind=c_int), intent(out) :: ierr
    end subroutine olp_start
  end interface

@ %def olp_start_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval (label, momenta, mu, parameters, res) &
         bind (C,name="OLP_EvalSubProcess")
      import
      integer(kind=c_int), value, intent(in) :: label
      real(kind=c_double), value, intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: &
           momenta
      real(kind=c_double), dimension(OLP_PARAMETER_LIMIT), intent(in) :: &
           parameters
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
    end subroutine olp_eval
  end interface

@ %def olp_eval interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_info
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_info (olp_file, olp_version, message) bind(C)
      import
      character(kind=c_char), intent(inout), dimension(15) :: olp_file
      character(kind=c_char), intent(inout), dimension(15) :: olp_version
      character(kind=c_char), intent(inout), dimension(255) :: message
    end subroutine olp_info
  end interface

@ %def olp_info interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_set_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_set_parameter &
         (variable_name, real_part, complex_part, success) bind(C)
      import
      character(kind=c_char,len=1), intent(in) :: variable_name
      real(kind=c_double), intent(in) :: real_part, complex_part
      integer(kind=c_int), intent(out) :: success
    end subroutine olp_set_parameter
  end interface

@ %def olp_set_parameter_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_eval2
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_eval2 (label, momenta, mu, res, acc) bind(C)
      import
      integer(kind=c_int), intent(in) :: label
      real(kind=c_double), intent(in) :: mu
      real(kind=c_double), dimension(OLP_MOMENTUM_LIMIT), intent(in) :: momenta
      real(kind=c_double), dimension(OLP_RESULTS_LIMIT), intent(out) :: res
      real(kind=c_double), intent(out) :: acc
    end subroutine olp_eval2
  end interface

@ %def olp_eval2_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_option
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_option (line, stat) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: line
      integer(kind=c_int), intent(out) :: stat
    end subroutine
  end interface

@ %def olp_option_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_polvec
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_polvec (p, q, eps) bind(C)
      import
      real(kind=c_double), dimension(0:3), intent(in) :: p, q
      real(kind=c_double), dimension(0:7), intent(out) :: eps
    end subroutine
  end interface

@ %def olp_polvec_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_finalize
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_finalize () bind(C)
      import
    end subroutine olp_finalize
  end interface

@ %def olp_finalize_interface
@
<<BLHA OLP interfaces: public>>=
  public :: olp_print_parameter
<<BLHA OLP interfaces: interfaces>>=
  interface
    subroutine olp_print_parameter (filename) bind(C)
      import
      character(kind=c_char, len=1), intent(in) :: filename
    end subroutine olp_print_parameter
  end interface

@ %def olp_print_parameter_interface
@
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
     subroutine omega_update_alpha_s (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine omega_update_alpha_s
  end interface
  
  abstract interface
     subroutine omega_is_allowed (flv, hel, col, flag) bind(C)
       import
       integer(c_int), intent(in) :: flv, hel, col
       logical(c_bool), intent(out) :: flag
     end subroutine omega_is_allowed
  end interface

@ %def omega-interfaces
@
<<BLHA OLP interfaces: public>>=
  public :: blha_result_array_size
<<BLHA OLP interfaces: procedures>>=
  pure function blha_result_array_size (n_part, amp_type) result (rsize)
    integer, intent(in) :: n_part, amp_type
    integer :: rsize
    select case (amp_type)
       case (BLHA_AMP_TREE)
          rsize = 1
       case (BLHA_AMP_LOOP)
          rsize = 4
       case (BLHA_AMP_CC)
          rsize = n_part*(n_part-1)/2
       case (BLHA_AMP_SC)
          rsize = 2*n_part**2
     end select
  end function blha_result_array_size

@ %def blha_result_array_size
@     
<<BLHA OLP interfaces: public>>=
!  public :: create_blha_momentum_array
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: create_momentum_array => prc_blha_create_momentum_array
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_create_momentum_array (object, p) result (mom)
    class(prc_blha_t), intent(in) :: object
    type(vector4_t), intent(in), dimension(:) :: p
    real(double), dimension(5*object%n_particles) :: mom
    integer :: n, i, k

    n = size (p)
    if (n > 10) call msg_fatal ("Number of external particles exceeeds" &
                                 // "size of GoSam-internal momentum array")
    k = 1
    do i = 1, n
       mom(k:k+3) = vector4_get_components (p(i))
       mom(k+4) = invariant_mass (p(i))
       k = k+5
    end do
!    mom (k:50) = 0.0
  end function prc_blha_create_momentum_array

@ %def prc_blha_create_momentum_array
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: init => blha_template_init
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_init (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component = .false.
  end subroutine blha_template_init

@ %def blha_template_init
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: set_loop => blha_template_set_loop
  procedure :: set_subtraction => blha_template_set_subtraction
  procedure :: set_real_trees => blha_template_set_real_trees
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_set_loop (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component(template%I_LOOP) = .true.
  end subroutine blha_template_set_loop

  subroutine blha_template_set_subtraction (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component (template%I_SUB) = .true.
  end subroutine blha_template_set_subtraction

  subroutine blha_template_set_real_trees (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component (template%I_REAL) = .true.
  end subroutine blha_template_set_real_trees

@ %def blha_template_set_components
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: compute_loop => blha_template_compute_loop
  procedure :: compute_subtraction => blha_template_compute_subtraction
  procedure :: compute_real_trees => blha_template_compute_real_trees
<<BLHA OLP interfaces: procedures>>=
  function blha_template_compute_loop (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_LOOP)
  end function blha_template_compute_loop  

  function blha_template_compute_subtraction (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_SUB)
  end function blha_template_compute_subtraction

  function blha_template_compute_real_trees (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = template%compute_component (template%I_REAL)
  end function blha_template_compute_real_trees

@ %def blha_template_compute
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: check => blha_template_check
<<BLHA OLP interfaces: procedures>>=
  function blha_template_check (template) result (val)
    class(blha_template_t), intent(in) :: template
    logical :: val
    val = count (template%compute_component) == 1
  end function blha_template_check

@ %def blha_template_check
@
<<BLHA OLP interfaces: blha template: TBP>>=
  procedure :: reset => blha_template_reset
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_template_reset (template)
    class(blha_template_t), intent(inout) :: template
    template%compute_component = .false.
  end subroutine blha_template_reset

@ %def blha_template_reset
@
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write_wrapper => prc_blha_writer_write_wrapper
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_writer_write_wrapper (writer, unit, id, feature)
    class(prc_blha_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature    
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select

  end subroutine prc_blha_writer_write_wrapper

@
@ %def prc_blha_writer_write_wrapper
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write_interface => prc_blha_writer_write_interface
<<BLHA OLP interfaces: procedures>>= 
  subroutine prc_blha_writer_write_interface (writer, unit, id, feature)
    class(prc_blha_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine prc_blha_writer_write_interface

@
@ %def prc_blha_writer_write_interface
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write_source_code => prc_blha_writer_write_source_code
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_writer_write_source_code (writer, id)
    class(prc_blha_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
    !!! This is a dummy
  end subroutine prc_blha_writer_write_source_code

@ 
@ %def prc_blha_writer_write_source_code
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write_makefile_code => prc_blha_writer_write_makefile_code
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_writer_write_makefile_code (writer, unit, id, os_data, testflag)
    class(prc_blha_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    omega_binary = "omega_" // writer%model_name // ".opt"
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".f90:"
    write (unit, "(99A)")  TAB, char (omega_path), &
         " -o ", char (id), ".f90", &
         " -target:whizard", &
         " -target:parameter_module parameters_", char (writer%model_name), &
         " -target:module opr_", char (id), &
         " -target:md5sum '", writer%md5sum, "'", &
         char (writer%process_mode), char (writer%process_string)
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"    
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"       
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"

  end subroutine prc_blha_writer_write_makefile_code

@
@ %def prc_blha_writer_write_makefile_code
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure, nopass:: get_procname => prc_blha_writer_writer_get_procname
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function prc_blha_writer_writer_get_procname

@ %def prc_blha_writer_writer_get_procname
@ 
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure, nopass :: get_module_name => prc_blha_writer_get_module_name
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function prc_blha_writer_get_module_name

@ %def prc_blha_writer_get_module_name
@
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: write => prc_blha_writer_write
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_writer_write (writer, unit)
    class(prc_blha_writer_t), intent(in) :: writer
    integer, intent(in) :: unit    
    write (unit, "(1x,A)")  char (writer%get_process_string ())
  end subroutine prc_blha_writer_write

@
@ %def prc_blha_writer_write
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: get_process_string => prc_blha_writer_get_process_string
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_get_process_string (writer) result (s_proc)
    class(prc_blha_writer_t), intent(in) :: writer
    type(string_t) :: s_proc
    !!! This is a dummy
  end function prc_blha_writer_get_process_string

@ %def gosam_writer_get_process_string
@
<<BLHA OLP interfaces: blha writer: TBP>>=
  procedure :: get_n_proc => prc_blha_writer_get_n_proc
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_writer_get_n_proc (writer) result (n_proc)
    class(prc_blha_writer_t), intent(in) :: writer
    integer :: n_proc
    n_proc = blha_configuration_get_n_proc (writer%blha_cfg)
  end function prc_blha_writer_get_n_proc

@ %def prc_blha_writer_get_n_proc
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: set_alpha_qed => blha_driver_set_alpha_qed
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_set_alpha_qed (driver, alpha)
    class(blha_driver_t), intent(inout) :: driver
    real(default), intent(in) :: alpha
    integer :: ierr
    call driver%blha_olp_set_parameter &
       (c_char_'alpha_qed'//c_null_char, &
        dble (alpha), 0._double, ierr)
  end subroutine blha_driver_set_alpha_qed

@ %def blha_driver_set_alpha_qed
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_set_alpha_s), deferred :: &
     set_alpha_s
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_set_alpha_s (driver, alpha_s)
       import
       class(blha_driver_t), intent(inout) :: driver
       real(default), intent(in) :: alpha_s
    end subroutine blha_driver_set_alpha_s
  end interface

@ %def set_alpha_s interface
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_print_alpha_s), deferred :: &
     print_alpha_s
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_print_alpha_s (object)
      import
      class(blha_driver_t), intent(in) :: object
    end subroutine blha_driver_print_alpha_s
  end interface

@ %def print_alpha_s interface
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: set_mass_and_width => blha_driver_set_mass_and_width
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_set_mass_and_width (driver, &
                                       i_pdg, mass, width)
    class(blha_driver_t), intent(inout) :: driver
    integer, intent(in) :: i_pdg
    real(default), intent(in), optional :: mass
    real(default), intent(in), optional :: width
    type(string_t) :: buf
    character(kind=c_char,len=20) :: c_string
    integer :: ierr
    if (present (mass)) then
       buf = 'mass(' // str (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%blha_olp_set_parameter &
                (c_string, dble(mass), 0._double, ierr)
       if (ierr == 0) then
          buf = "BLHA driver: Attempt to set mass of particle " // &
                str (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
    if (present (width)) then
       buf = 'width(' // str (abs(i_pdg)) // ')'
       c_string = char(buf)//c_null_char
       call driver%blha_olp_set_parameter &
                (c_string, dble(width), 0._double, ierr)
       if (ierr == 0) then
          buf = "BLHA driver: Attempt to set width of particle " // &
                str (abs(i_pdg)) // "failed"
          call msg_fatal (char(buf))
       end if
    end if
  end subroutine blha_driver_set_mass_and_width

@ %def blha_driver_set_mass_and_width
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure(blha_driver_init_dlaccess_to_library), deferred :: &
    init_dlaccess_to_library
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine blha_driver_init_dlaccess_to_library &
       (object, os_data, dlaccess, success)
      import
      class(blha_driver_t), intent(in) :: object
      type(os_data_t), intent(in) :: os_data
      type(dlaccess_t), intent(out) :: dlaccess
      logical, intent(out) :: success
    end subroutine blha_driver_init_dlaccess_to_library
  end interface
      
@ %def interface blha_driver_init_dlaccess_to_library
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: load => blha_driver_load
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_load (object, os_data, success)
    class(blha_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: success
    type(dlaccess_t) :: dlaccess
    type(c_funptr) :: c_fptr
    logical :: init_success

    call object%init_dlaccess_to_library (os_data, dlaccess, init_success)

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Start"))
       call c_f_procpointer (c_fptr, object%blha_olp_start)
       call check_for_error (var_str ("OLP_Start"))
       
       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess"))
       call c_f_procpointer (c_fptr, object%blha_olp_eval)
       call check_for_error (var_str ("OLP_EvalSubProcess"))

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Info"))
       call c_f_procpointer (c_fptr, object%blha_olp_info)
       call check_for_error (var_str ("OLP_Info"))

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_SetParameter"))
       call c_f_procpointer (c_fptr, object%blha_olp_set_parameter)
       call check_for_error (var_str ("OLP_SetParameter"))

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess2"))
       call c_f_procpointer (c_fptr, object%blha_olp_eval2)
       call check_for_error (var_str ("OLP_EvalSubProcess2"))

       !!! Is OLP_Option really not implemented in OpenLoops?
       !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Option"))
       !!! call c_f_procpointer (c_fptr, object%blha_olp_option)
       !!! call check_for_error (var_str ("OLP_Option"))

       !!! Is OLP_Polvec really not implemented in OpenLoops?
       !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Polvec"))
       !!! call c_f_procpointer (c_fptr, object%blha_olp_polvec)
       !!! call check_for_error (var_str ("OLP_Polvec"))

       !!! Is OLP_Polvec really not implemented in OpenLoops?
       !!! c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Finalize"))
       !!! call c_f_procpointer (c_fptr, object%blha_olp_finalize)
       !!! call check_for_error (var_str ("OLP_Finalize"))

       c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_PrintParameter"))
       call c_f_procpointer (c_fptr, object%blha_olp_print_parameter)
       call check_for_error (var_str ("OLP_PrintParameter"))

       success = .true.
    contains
      subroutine check_for_error (function_name)
        type(string_t), intent(in) :: function_name
        if (dlaccess_has_error (dlaccess)) &
           call msg_fatal (char ("Loading of " // function_name // " failed!"))
     end subroutine check_for_error
  end subroutine blha_driver_load

@ %def blha_driver_load
@
<<BLHA OLP interfaces: blha driver: TBP>>=
  procedure :: read_contract_file => blha_driver_read_contract_file
<<BLHA OLP interfaces: procedures>>=
  subroutine blha_driver_read_contract_file (driver, flavors, amp_type, flv_index, label)
    class(blha_driver_t), intent(inout) :: driver
    integer, intent(in), dimension(:,:) :: flavors
    integer, intent(out), dimension(20) :: amp_type, flv_index, label
    integer :: unit, filestat
    character(len=100) :: rd_line 
    logical :: read_flavor, born_found
    integer :: k, i_flv, i_part
    integer :: i_next, n_entries
    integer, dimension(size(flavors, 1) + 2) :: i_array
    integer, parameter :: NO_NUMBER = -1000

    amp_type = -1; flv_index = -1; label = -1
    n_entries = size(flavors, 1) + 2
    unit = free_unit ()
    open (unit, file=char(driver%contract_file), status="old") 
    read_flavor=.false.
    k = 1
    do
      read (unit, '(A)', iostat = filestat) rd_line
      if (filestat == iostat_end) then
         exit
      else
         if (rd_line(1:13) == 'AmplitudeType') then
            i_next = find_next_word_index (rd_line, 13) 
            if (rd_line(i_next:i_next+4) == 'Loop') then
               amp_type(k) = BLHA_AMP_LOOP
            else if (rd_line(i_next:i_next+4) == 'Tree') then
               amp_type(k) = BLHA_AMP_TREE
            else if (rd_line(i_next:i_next+6) == 'ccTree') then
               amp_type(k) = BLHA_AMP_CC
            else if (rd_line(i_next:i_next+6) == 'scTree') then
               amp_type(k) = BLHA_AMP_SC
            else
               call msg_fatal ("AmplitudeType present but &
                               &AmpType not known!")
            end if
            read_flavor = .true.
         else if (read_flavor) then
            born_found = .false.
            i_array = create_flavor_string (rd_line, n_entries)           
            do i_flv = 1, size (flavors, 2)
               if (all (i_array (1:n_entries-2) == flavors (:,i_flv))) then
                  label(k) = i_array (n_entries)
                  flv_index (k) = i_flv
                  born_found = .true.
                  k = k+1
                  read_flavor = .false.
                  exit
               end if
            end do
            if (.not. born_found) call msg_fatal & 
                     ("No underlying Born found")
         end if   
      end if
    end do
    close(unit)
  contains
    function create_flavor_string (s, n_entries) result (i_array)
      character(len=100), intent(in) :: s
      integer, intent(in) :: n_entries
      integer, dimension(n_entries) :: i_array
      character(len=10) :: buf
      integer :: k, current_position
      logical :: valid_buffer
      integer :: i_entry
      k = 1; current_position = 1
      do
         if (current_position > 100) &
            call msg_fatal ("Read OLC File: Current position exceeds maximum value")
         if (s(current_position:current_position) /= " ") then
            call create_integer (s, i_entry, current_position)
            if (i_entry /= NO_NUMBER) then
               i_array(k) = i_entry
               k = k+1
               if (k > n_entries) then
                  return
               else
                  current_position = find_next_word_index (s, current_position)
               end if
            else
               current_position = find_next_word_index (s, current_position)
            end if
         else
            current_position = find_next_word_index (s, current_position)
         end if
      end do
    end function create_flavor_string
        
    subroutine create_integer (s, i_particle, current_position)
      character(len=100), intent(in) :: s
      integer, intent(out) :: i_particle
      integer, intent(inout) :: current_position
      character(len=10) :: buf
      integer :: i
      logical :: valid
      i = 1
      do
        if (s(current_position:current_position) /= " ") then
           buf(i:i) = s(current_position:current_position)
           i = i+1; current_position = current_position+1
        else
           exit
        end if
      end do
      valid = (buf(1:i-1) /= "->" .and. buf(1:i-1) /= "|")
      if (valid) then
         i_particle = read_ival (var_str (buf(1:i-1)))
      else
         i_particle = NO_NUMBER
      end if
    end subroutine create_integer
            
    function find_next_word_index (blub, i_start) result (i_next)
      character(len=100), intent(in) :: blub
      integer, intent(in) :: i_start
      integer :: i_next
      i_next = i_start + 1
      do
         if (blub(i_next:i_next) /= " ") then
            exit
         else
            i_next = i_next + 1
         end if
         if (i_next > 100) call msg_fatal ("Find next word: line limit exceeded")
      end do
    end function find_next_word_index

  end subroutine blha_driver_read_contract_file

@ %def blha_driver_read_contract_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: needs_mcset => prc_blha_needs_mcset
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_needs_mcset (object) result (flag)
    class(prc_blha_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function prc_blha_needs_mcset

@
@ %def prc_blha_needs_mc_set
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: get_n_terms => prc_blha_get_n_terms
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_get_n_terms (object) result (n)
    class(prc_blha_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_blha_get_n_terms

@  
@ %def prc_blha_get_n_termsi
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: is_allowed => prc_blha_is_allowed
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_blha_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    logical(c_bool) :: cflag
    select type (driver => object%driver)
    class is (blha_driver_t)
!       call driver%is_allowed (f, h, c, cflag)
!       flag = cflag
       flag = .true.
    class default
       call msg_fatal &
            ("BLHA instance created, but driver is not a BLHA driver!")
    end select
  end function prc_blha_is_allowed

@
@ %def prc_blha_is_allowed
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: update_alpha_s => prc_blha_update_alpha_s
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_update_alpha_s (object, core_state, fac_scale) 
    class(prc_blha_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    real(default), intent(in) :: fac_scale
    real(default) :: alpha_qcd
    if (allocated (object%qcd%alpha)) then
       alpha_qcd = object%qcd%alpha%get (fac_scale)
       select type (driver => object%driver)
       class is (blha_driver_t)
          call driver%update_alpha_s (alpha_qcd)
       end select 
    end if
  end subroutine prc_blha_update_alpha_s

@ %def prc_blha_update_alpha_s
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: get_alpha_s => prc_blha_get_alpha_s
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_get_alpha_s (object, core_state) result (alpha)
    class(prc_blha_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha
    if (allocated (core_state)) then
      select type (core_state)
      class is (blha_state_t)
        alpha = core_state%alpha_qcd
      end select
    else
      alpha = 0._default 
    end if
  end function prc_blha_get_alpha_s

@ %def prc_blha_get_alpha_s
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_alpha_qed => prc_blha_set_alpha_qed
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_alpha_qed (object, alpha)
    class(prc_blha_t), intent(inout) :: object
    real(default), intent(in) :: alpha
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%set_alpha_qed (alpha)
    end select
  end subroutine prc_blha_set_alpha_qed

@ %def prc_blha_set_alpha_qed
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: read_contract_file => prc_blha_read_contract_file
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_read_contract_file (object, flavors)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in), dimension(:,:) :: flavors
    integer, dimension(20) :: amp_type, flv_index, label
    integer :: i_proc
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%read_contract_file (flavors, amp_type, flv_index, label)
    end select
    do i_proc = 1, size (amp_type)
       if (amp_type (i_proc) < 0) exit
       select case (amp_type (i_proc))
       case (BLHA_AMP_TREE)
          if (allocated (object%i_born)) then
             object%i_born(flv_index(i_proc)) = label(i_proc)
          
          else if (allocated (object%i_real)) then
             object%i_real(flv_index(i_proc)) = label(i_proc)
          else 
             call msg_fatal ("Tree matrix element present, &
                             &but neither Born nor real indices are allocated!")
          end if
       case (BLHA_AMP_CC)
          if (allocated (object%i_cc)) then
             object%i_cc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Color-correlated matrix element present, &
                              &but cc-indices are not allocated!")
          end if
       case (BLHA_AMP_SC)
          if (allocated (object%i_sc)) then
             object%i_sc(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Spin-correlated matrix element present, &
                             &but sc-indices are not allocated!")
          end if
       case (BLHA_AMP_LOOP)
          if (allocated (object%i_virt)) then
             object%i_virt(flv_index(i_proc)) = label(i_proc)
          else
             call msg_fatal ("Loop matrix element present, &
                             &but virt-indices are not allocated!")
          end if
       case default
          call msg_fatal ("Undefined amplitude type")
       end select
    end do
  end subroutine prc_blha_read_contract_file

@ %def prc_blha_read_contract_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: print_parameter_file => prc_blha_print_parameter_file
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_print_parameter_file (object)
    class(prc_blha_t), intent(in) :: object
    type(string_t) :: filename
    
    select type (def => object%def)
    class is (blha_def_t)
       filename = def%basename // '.olp_parameters'
    end select
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%blha_olp_print_parameter (char(filename)//c_null_char)
    end select
  end subroutine prc_blha_print_parameter_file

@ %def prc_blha_print_parameter_file
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_hard_kinematics => prc_blha_compute_hard_kinematics
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(prc_blha_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state 
    call int_hard%set_momenta (p_seed)
    if (allocated (core_state)) then
      select type (core_state)
      class is (blha_state_t); core_state%new_kinematics = .true.
      end select
    end if
  end subroutine prc_blha_compute_hard_kinematics

@ 
@ %def prc_blha_compute_hard_kinematics
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_eff_kinematics => prc_blha_compute_eff_kinematics
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_blha_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_blha_compute_eff_kinematics

@
@ %def prc_blha_compute_eff_kinematics
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_amplitude => prc_blha_compute_amplitude
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
       core_state)  result (amp)
    class(prc_blha_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    class is (blha_state_t)
      core_state%alpha_qcd = object%qcd%alpha%get (fac_scale)
    end select
    amp = 0.0
  end function prc_blha_compute_amplitude

@
@ %def prc_blha_compute_amplitude
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: recover_kinematics => prc_blha_recover_kinematics
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_recover_kinematics &
       (object, p_seed, int_hard, int_eff, core_state)
    class(prc_blha_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard, int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_in
    n_in = int_eff%get_n_in ()
    call int_eff%set_momenta (p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = int_eff%get_momenta (outgoing = .true.)
  end subroutine prc_blha_recover_kinematics

@ 
@ %def prc_blha_recover_kinematics
<<BLHA OLP interfaces: prc blha: TBP>>=
   procedure :: init_blha => prc_blha_init_blha
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_init_blha (object, blha_template)
    class(prc_blha_t), intent(inout) :: object
    type(blha_template_t), intent(inout) :: blha_template
    integer :: i_flv

    object%n_particles = size (object%data%flv_state, 1)
    object%n_flv = size (object%data%flv_state, 2)
   
    if (blha_template%compute_loop ()) then
       allocate (object%i_virt (object%n_flv), &
                 object%i_cc (object%n_flv))
    else if (blha_template%compute_subtraction ()) then
       allocate (object%i_born (object%n_flv), &
                 object%i_cc (object%n_flv) , &
                 object%i_sc (object%n_flv))
    else if (blha_template%compute_real_trees ()) then
       allocate (object%i_real (object%n_flv))
    end if
  end subroutine prc_blha_init_blha
@ %def prc_blha_init_blha
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: get_nflv => prc_blha_get_nflv
<<BLHA OLP interfaces: procedures>>=
  function prc_blha_get_nflv (object) result (n_flv)
    class(prc_blha_t), intent(in) :: object
    integer :: n_flv
    n_flv = object%n_flv
  end function prc_blha_get_nflv

@ %def prc_blha_get_nflv
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_parameters => prc_blha_set_parameters
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_parameters (object, qcd, use_color_factors)
    class(prc_blha_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    logical, intent(in) :: use_color_factors
    object%qcd = qcd
    object%use_color_factors = use_color_factors

  end subroutine prc_blha_set_parameters

@ %def prc_blha_set_parameters
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_particle_properties => prc_blha_set_particle_properties
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_particle_properties (object, model) 
    class(prc_blha_t), intent(inout) :: object
    class(model_data_t), intent(in), target :: model
    integer :: i, i_pdg
    type(flavor_t) :: flv
    real(default) :: mass, width
    do i = 1, OLP_N_MASSIVE_PARTICLES
       i_pdg = OLP_MASSIVE_PARTICLES(i)
       call flv%init (i_pdg, model)
       mass = flv%get_mass (); width = flv%get_width ()
       select type (driver => object%driver)
       class is (blha_driver_t)
          call driver%set_mass_and_width (i_pdg, mass=mass, width=width)
       end select
    end do
  end subroutine prc_blha_set_particle_properties

@ %def prc_blha_set_particle_properties
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: set_bquark_mass => prc_blha_set_bquark_mass
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_set_bquark_mass (object, model)
    class(prc_blha_t), intent(inout) :: object
    class(model_data_t), intent(in), target :: model
    type(flavor_t) :: flv
    real(default) :: mass, width
    integer :: ierr
    call flv%init (5, model)
    mass = flv%get_mass (); width = flv%get_width ()
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%set_mass_and_width (5, mass=mass, width=width)
       call driver%blha_olp_set_parameter ('yuk(5)'//c_null_char, &
          dble(mass), 0._double, ierr)
    end select
  end subroutine prc_blha_set_bquark_mass

@ %def prc_blha_set_bquark_mass
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_sqme_virt => prc_blha_compute_sqme_virt
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_sqme_virt (object, &
                i_flv, p, ren_scale, sqme, bad_point)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    logical, intent(out) :: bad_point
    real(default), dimension(4), intent(out) :: sqme
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(blha_result_array_size (object%n_particles, &
                                                    BLHA_AMP_LOOP)) :: r
    real(double) :: mu_dble
    real(default) :: mu
    real(double) :: acc_dble
    real(default) :: acc
    real(default) :: alpha_s

    mom = object%create_momentum_array (p)
    if (ren_scale == 0.0) then
      mu = sqrt (2* (p(1)*p(2)))
    else
      mu = ren_scale
    end if
    mu_dble = dble(mu)
    alpha_s = object%qcd%alpha%get (mu)
    select type (driver => object%driver)
    class is (blha_driver_t)
      call driver%set_alpha_s (alpha_s)
      call driver%blha_olp_eval2 (object%i_virt(i_flv), &
                                   mom, mu_dble, r, acc_dble) 
    end select
    acc = acc_dble
    sqme = r(1:4)
    if (acc > object%maximum_accuracy) then
       bad_point = .true.
    else
       bad_point = .false.
    end if
  end subroutine prc_blha_compute_sqme_virt

@ %def prc_blha_compute_sqme_virt
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_compute_sqme_real), deferred :: &
      compute_sqme_real
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_compute_sqme_real (object, i_flv, &
          p, ren_scale, sqme, bad_point)
      import
      class(prc_blha_t), intent(inout) :: object
      integer, intent(in) :: i_flv
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: ren_scale
      real(default), intent(out) :: sqme
      logical, intent(out) :: bad_point
    end subroutine prc_blha_compute_sqme_real
  end interface 

@ %def prc_blha_compute_sqme_real interface
@ Compute the Born matrix element. This will always occur in connection to a subtraction
term, so scales and couplings have already been set, and the momenta are in the BLHA format
Hence, the interface is simpler than in the other routines.
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_compute_sqme_born), deferred :: &
      compute_sqme_born
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_compute_sqme_born (object, i_born, &
          mom, mu, sqme, acc_born)
      import
      class(prc_blha_t), intent(inout) :: object
      integer, intent(in) :: i_born
      real(double), intent(in), dimension(5*object%n_particles) :: mom
      real(double), intent(in) :: mu
      real(default), intent(out) :: sqme
      real(default), intent(out) :: acc_born
    end subroutine prc_blha_compute_sqme_born
  end interface 

@ %def prc_blha_compute_sqme_born interface
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure :: compute_sqme_cc => prc_blha_compute_sqme_cc
<<BLHA OLP interfaces: procedures>>=
  subroutine prc_blha_compute_sqme_cc &
         (object, i_flv, p, ren_scale, &
          born_out, born_cc, bad_point)
    class(prc_blha_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(out), optional :: born_out
    real(default), intent(inout), dimension(:,:) :: born_cc
    logical, intent(out) :: bad_point
    real(double), dimension(5*object%n_particles) :: mom
    real(double), dimension(blha_result_array_size (object%n_particles, &
                                              BLHA_AMP_CC)) :: r
    real(default) :: mu
    real(double) :: mu_dble
    real(default) :: alpha_s
    integer :: i, j, pos
    integer :: im1, jm1
    real(double) :: acc_dble
    real(default) :: acc1, acc2
    real(default) :: born

    mom = object%create_momentum_array (p)
    if (ren_scale == 0.0) then
       mu = sqrt (2*p(1)*p(2))
    else
       mu = ren_scale
    end if
    mu_dble = dble(mu)
    alpha_s = object%qcd%alpha%get (mu)
    select type (driver => object%driver)
    class is (blha_driver_t)
       call driver%set_alpha_s (alpha_s)
       if (allocated (object%i_born)) then
       call object%compute_sqme_born (object%i_born(i_flv), &
                                      mom, mu_dble, born, acc1)
       else
          born = 0._default
          acc1 = 0._default
       end if
       if (present (born_out)) born_out = born
       call driver%blha_olp_eval2 (object%i_cc(i_flv), &
                                    mom, mu_dble, r, acc_dble)
    end select
    do j = 1, size (p)
      do i = 1, j
        if (i <= 2 .or. j <= 2) then
          born_cc (i,j) = 0._default
        else if (i == j) then
          born_cc (i,j) = -cf*born
        else
          im1 = i-1; jm1 = j-1
          pos = im1 + jm1*(jm1-1)/2 + 1
          born_cc (i,j) = -r(pos)
        end if
        born_cc (j,i) = born_cc (i,j)
      end do
    end do
    acc2 = acc_dble
    if (acc1 > object%maximum_accuracy .or. &
        acc2 > object%maximum_accuracy) then
      bad_point = .true.
    end if
  end subroutine prc_blha_compute_sqme_cc

@ %def prc_blha_compute_sqme_cc
@
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_compute_sqme_sc), deferred :: &
      compute_sqme_sc
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_compute_sqme_sc (object, &
         i_flv, em, p, ren_scale_in, me_sc, bad_point)
      import
      class(prc_blha_t), intent(inout) :: object
      integer, intent(in) :: i_flv, em
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: ren_scale_in
      complex(default), intent(out) :: me_sc
      logical, intent(out) :: bad_point 
    end subroutine prc_blha_compute_sqme_sc
  end interface

@ %def interface prc_blha_compute_sqme_sc
@   
<<BLHA OLP interfaces: prc blha: TBP>>=
  procedure(prc_blha_init_driver), deferred :: &
      init_driver
<<BLHA OLP interfaces: interfaces>>=
  abstract interface
    subroutine prc_blha_init_driver (object, os_data)
      import
      class(prc_blha_t), intent(inout) :: object
      type(os_data_t), intent(in) :: os_data
    end subroutine prc_blha_init_driver
  end interface
@ %def prc_blha_init_driver interface
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The module is split into a configuration interface which manages configuration
and handles the request and contract files, a module which interfaces the OLP
matrix elements and a driver.

<<[[blha_config.f90]]>>=
<<File header>>

module blha_config

  use kinds
<<Use strings>>
  use io_units
  use constants
  use string_utils
  use system_defs, only: EOF
  use diagnostics
  use md5
  use model_data
  use flavors
  use quantum_numbers
  use pdg_arrays
  use sorting
  use lexers
  use parser
  use syntax_rules
  use ifiles

  use fks_regions, only: flv_structure_t

<<Standard module head>>

<<BLHA config: public>>

<<BLHA config: parameters>>

<<BLHA config: types>>

<<BLHA config: variables>>

<<BLHA config: interfaces>>

contains

<<BLHA config: procedures>>

end module blha_config

@ %def blha_config
@
<<[[blha_interface.f90]]>>=
<<File header>>

module blha_interface

<<Use strings>>
  use io_units
  use string_utils
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use model_data
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use, intrinsic :: iso_c_binding !NODEP!
  use os_interface

<<Standard module head>>

<<BLHA interface: public>>

<<BLHA interface: types>>

<<BLHA interface: interfaces>>

contains

<<BLHA interface: procedures>>

end module blha_interface
@ %def blha_interface
@ %
<<[[blha_driver.f90]]>>=
<<File header>>

module blha_driver

<<Use strings>>
  use io_units
  use constants
  use diagnostics
  use sm_physics
  use md5
  use lorentz
  use model_data
  use flavors
  use quantum_numbers
  use interactions
  use evaluators
  use particles
  use quantum_numbers
  use blha_config
  use blha_interface

<<Standard module head>>

<<BLHA driver: public>>

contains

<<BLHA driver: procedures>>

end module blha_driver
@ %def blha_driver
@ %

\section{Configuration}

Parameters to enumerate the different options in the order.
<<BLHA config: parameters>>=
  integer, public, parameter :: &
       BLHA_MEST_SUM=1, BLHA_MEST_AVG=2, BLHA_MEST_OTHER=3
  integer, public, parameter :: &
       BLHA_CT_QCD=1, BLHA_CT_EW=2, BLHA_CT_QED=3, BLHA_CT_OTHER=4
  integer, public, parameter :: &
       BLHA_IRREG_CDR=1, BLHA_IRREG_DRED=2, BLHA_IRREG_THV=3, &
       BLHA_IRREG_MREG=4, BLHA_IRREG_OTHER=5
  integer, public, parameter :: &
       BLHA_SUBMODE_NONE = 1, BLHA_SUBMODE_OTHER = 2
  integer, public, parameter :: &
       BLHA_MPS_ONSHELL=1, BLHA_MPS_OTHER=2
  integer, public, parameter :: &
       BLHA_MODE_GOSAM=1, BLHA_MODE_FEYNARTS = 2, BLHA_MODE_GENERIC=3, &
       BLHA_MODE_OPENLOOPS=4
  integer, public, parameter :: &
       BLHA_OM_NONE=1, BLHA_OM_NOCPL=2, BLHA_OM_OTHER=3
   integer, public, parameter :: &
       BLHA_VERSION_1 = 1, BLHA_VERSION_2 = 2
  integer, public, parameter :: &
       BLHA_AMP_LOOP = 1, BLHA_AMP_CC = 2, BLHA_AMP_SC = 3, &
       BLHA_AMP_TREE = 4, BLHA_AMP_LOOPINDUCED = 5
  integer, public, parameter :: &
       BLHA_EW_GF = 1, BLHA_EW_MZ = 2, BLHA_EW_MSBAR = 3, &
       BLHA_EW_0 = 4, BLHA_EW_RUN = 5, BLHA_EW_DEFAULT = 6
  integer, public, parameter :: &
       BLHA_WIDTH_COMPLEX = 1, BLHA_WIDTH_FIXED = 2, &
       BLHA_WIDTH_RUNNING = 3, BLHA_WIDTH_POLE = 4, &
       BLHA_WIDTH_DEFAULT = 5 

@ %def blha_mest_sum blha_mest_avg blha_mest_other
@ %def blha_ct_qcd blha_ct_ew blha_ct_qed blha_ct_other
@ %def blha_irreg_cdr blha_irreg_dred blha_irreg_thv blha_irreg_mreg blha_irreg_other
@ %def blha_submode_none blha_submode_other
@ %def blha_mps_onshell blha_mps_other
@ %def blha_mode_gosam blha_mode_feynarts blha_mode_generic
@ %def blha_om_none blha_om_nocpl blha_om_other
@ %def blha version blha_amp blha_ew blha_width
@ 
Those are the default pdg codes for massive particles in BLHA programs
<<BLHA config: parameters>>=
  integer, parameter, public :: OLP_N_MASSIVE_PARTICLES = 10
  integer, dimension(OLP_N_MASSIVE_PARTICLES), public :: &
    OLP_MASSIVE_PARTICLES = [5,-5,6,-6,15,-15,23,24,-24,25]

@ %def OLP_MASSIVE_PARTICLES
@
This type encapsulates a BLHA request.
<<BLHA config: public>>=
  public :: blha_configuration_t
  public :: blha_cfg_process_node_t
<<BLHA config: types>>=
  type :: blha_cfg_process_node_t
     integer, dimension(:), allocatable :: pdg_in, pdg_out
     integer, dimension(:), allocatable :: fingerprint
     integer :: nsub
     integer, dimension(:), allocatable :: ids
     integer :: amplitude_type
     type(blha_cfg_process_node_t), pointer :: next => null ()
  end type blha_cfg_process_node_t

  type :: blha_configuration_t
     type(string_t) :: name
     class(model_data_t), pointer :: model => null ()
     type(string_t) :: md5
     integer :: version = 2
     logical :: dirty = .false.
     integer :: n_proc = 0
     real(default) :: accuracy_target
     logical :: debug_unstable
     integer :: mode = BLHA_MODE_GENERIC
     type(blha_cfg_process_node_t), pointer :: processes => null ()
     integer, dimension(2) :: matrix_element_square_type = BLHA_MEST_SUM
     integer :: correction_type = BLHA_CT_QCD
     type(string_t) :: correction_type_other
     integer :: irreg = BLHA_IRREG_THV
     type(string_t) :: irreg_other
     integer :: massive_particle_scheme = BLHA_MPS_ONSHELL
     type(string_t) :: massive_particle_scheme_other
     integer :: subtraction_mode = BLHA_SUBMODE_NONE
     type(string_t) :: subtraction_mode_other
     type(string_t) :: model_file
     logical :: subdivide_subprocesses = .false.
     integer :: alphas_power = -1, alpha_power = -1
     integer :: ew_scheme = BLHA_EW_DEFAULT
     integer :: width_scheme = BLHA_WIDTH_DEFAULT
     integer :: operation_mode = BLHA_OM_NONE
     type(string_t) :: operation_mode_other
  end type blha_configuration_t

@ %def blha_cffg_process_node_t blha_configuration_t
@
This types control the creation of BLHA-interface files
<<BLHA config: public>>=
  public :: blha_flv_state_t
  public :: blha_master_t
<<BLHA config: types>>=
  type:: blha_flv_state_t
    integer, dimension(:), allocatable :: flavors
    integer :: flv_mult
    logical :: flv_real = .false.
  end type blha_flv_state_t

  type :: blha_master_t
    integer, dimension(3) :: blha_mode
!    integer, dimension(:,:), allocatable :: flv_born, flv_real
    integer :: n_in, n_out
    logical :: compute_loops = .true.
    logical :: compute_correlations = .false.
    logical :: compute_real_trees = .false.
    integer :: alpha_power, alphas_power
    type(string_t) :: basename
    type(string_t), dimension(:), allocatable :: suffix
    type(blha_configuration_t), dimension(:), allocatable :: blha_cfg
    integer :: n_files = 0
  contains
  <<BLHA config: blha master: TBP>>
  end type blha_master_t

@ %def blha_flv_state_t, blha_master_t
@ Master-Routines
<<BLHA config: blha master: TBP>>=
  procedure :: init => blha_master_init 
<<BLHA config: procedures>>=
  subroutine blha_master_init (master, basename, model, &
                               n_in, n_out, &
                               cmp_loops, cmp_corr, cmp_real, &
                               alpha_power, alphas_power, &
                               flv_born, flv_real)
    class(blha_master_t), intent(inout) :: master
    type(string_t), intent(in) :: basename
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    logical, intent(in) :: cmp_loops, cmp_corr, cmp_real
    integer, intent(in) :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable, intent(in) :: &
                             flv_born, flv_real
    integer :: n_proc, n_proc_real, n_flv
    type(blha_flv_state_t), dimension(:), allocatable :: blha_flavor
    integer :: i, i_flv
    integer :: i_file
    integer, dimension(:), allocatable :: amp_type

    n_proc = 0; n_flv = 1; n_proc_real = 0
    master%compute_real_trees = cmp_real
    if (cmp_loops) master%n_files = master%n_files+1
    if (cmp_corr) master%n_files = master%n_files+1
    if (cmp_real) then
       if (allocated (flv_real)) then
         master%n_files = master%n_files+1
         n_proc_real = size (flv_real, 2)
         n_flv = n_flv + n_proc_real
       end if
    end if
    allocate (master%blha_cfg (master%n_files))
    allocate (master%suffix (master%n_files))
    i_file = 1
    if (cmp_loops) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 2
          end do
          master%suffix(i_file) = "_LOOP"
          call blha_init_virtual (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(1))
          i_file = i_file+1
        else
          call msg_fatal ("GoSam Loops requested but " &
                           // "Born flavor not existing")
        end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (cmp_corr) then
       if (allocated (flv_born)) then
          allocate (blha_flavor (size (flv_born, 2)))
          do i_flv = 1, size (flv_born, 2)
             blha_flavor(i_flv)%flavors = flv_born(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 3
          end do
          master%suffix(i_file) = "_SUB"
          call blha_init_subtraction (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(2))
          i_file = i_file+1
       else
          call msg_fatal ("GoSam Correlations requested but "&
                           // "Born flavor not existing")
       end if
    end if
    if (allocated (blha_flavor)) deallocate (blha_flavor)
    if (cmp_real) then
       if (allocated (flv_real)) then
          allocate (blha_flavor (size (flv_real, 2)))
          do i_flv = 1, size (flv_real, 2)
             blha_flavor(i_flv)%flavors = flv_real(:,i_flv)
             blha_flavor(i_flv)%flv_mult = 1
          end do
          master%suffix(i_file) = "_REAL"
          call blha_init_real (master%blha_cfg(i_file), blha_flavor, &
                                  alpha_power, alphas_power, &
                                  basename, model, master%blha_mode(3))
       else
          call msg_fatal ("GoSam Trees requested but "&
                           // "Real flavor not existing")
       end if
    end if
  end subroutine blha_master_init

@ %def blha_master_init
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_gosam => blha_master_set_gosam
<<BLHA config: procedures>>=
  subroutine blha_master_set_gosam (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_GOSAM
  end subroutine blha_master_set_gosam

@ %def blha_master_set_gosam
@
<<BLHA config: blha master: TBP>>=
  procedure :: set_openloops => blha_master_set_openloops
<<BLHA config: procedures>>=
  subroutine blha_master_set_openloops (master, i)
    class(blha_master_t), intent(inout) :: master
    integer, intent(in) :: i
    master%blha_mode(i) = BLHA_MODE_OPENLOOPS
  end subroutine blha_master_set_openloops

@ %def blha_master_set_openloops
@
<<BLHA config: procedures>>=
  subroutine blha_init_virtual (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*2))
    do i = 1, size (blha_flavor)
       amp_type(2*i-1) = BLHA_AMP_LOOP
       amp_type(2*i) = BLHA_AMP_CC
    end do
    call blha_configuration_init (blha_cfg, basename // "_LOOP" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_virtual

  subroutine blha_init_subtraction (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)*3))
    do i = 1, size (blha_flavor)
       amp_type(3*i-2) = BLHA_AMP_TREE
       amp_type(3*i-1) = BLHA_AMP_CC
       amp_type(3*i) = BLHA_AMP_SC
    end do
    call blha_configuration_init (blha_cfg, basename // "_SUB" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
!                                 debug = .true.)
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_subtraction

  subroutine blha_init_real (blha_cfg, blha_flavor, ap, asp, basename, model, blha_mode)
    type(blha_configuration_t), intent(inout) :: blha_cfg
    type(blha_flv_state_t), intent(in), dimension(:) :: blha_flavor
    integer, intent(in) :: ap, asp
    type(string_t), intent(in) :: basename
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: blha_mode
    integer, dimension(:), allocatable :: amp_type
    integer :: i, ew_scheme

    allocate (amp_type (size (blha_flavor)))
    do i = 1, size (blha_flavor)
       amp_type(i) = BLHA_AMP_TREE
    end do
    call blha_configuration_init (blha_cfg, basename // "_REAL" , &
                                  model, blha_mode)
    call blha_configuration_append_processes (blha_cfg, &
                                  blha_flavor, amp_type)
    select case (blha_cfg%mode)
    case (BLHA_MODE_GOSAM)
       ew_scheme = BLHA_EW_GF
    case (BLHA_MODE_OPENLOOPS)
       ew_scheme = BLHA_EW_0
    end select 
    call blha_configuration_set (blha_cfg, 2, &
                                 correction_type = BLHA_CT_QCD, &
                                 irreg = BLHA_IRREG_CDR, &
                                 alphas_power = asp+1, &
                                 alpha_power = ap, &
                                 ew_scheme = ew_scheme, &
!                                 debug = .true.)
                                 debug = blha_mode == BLHA_MODE_GOSAM)
  end subroutine blha_init_real

@ %def blha_master_init_virtual, blha_master_init_real, blha_master_init_subtraction
@
<<BLHA config: blha master: TBP>>=
  procedure :: generate => blha_master_generate
<<BLHA config: procedures>>=
  subroutine blha_master_generate (master, basename)
    class(blha_master_t), intent(in) :: master
    type(string_t), intent(in) :: basename
    integer :: unit
    type(string_t) :: filename
    integer :: i_file
    do i_file = 1, master%n_files
       filename = basename // master%suffix(i_file) // ".olp"
       unit = free_unit ()
       open (unit, file = char (filename), status = 'replace', action = 'write')
       call blha_configuration_write (master%blha_cfg(i_file), unit)
       close (unit)
    end do
  end subroutine blha_master_generate

@ %def blha_master_generate
@    
Initializer.
<<BLHA config: public>>=
  public :: blha_configuration_init
<<BLHA config: procedures>>=
  subroutine blha_configuration_init (cfg, name, model, mode)
    type(blha_configuration_t), intent(inout) :: cfg
    type(string_t), intent(in) :: name
    class(model_data_t), target, intent(in) :: model
    integer, intent(in), optional :: mode
    if (.not. associated (cfg%model)) then
       cfg%name = name
       cfg%model => model
    end if
    if (present (mode)) cfg%mode = mode
  end subroutine blha_configuration_init

@ %def blha_configuration_init
@
Finalizer.
<<BLHA config: public>>=
  public :: blha_configuration_final
<<BLHA config: procedures>>=
  subroutine blha_configuration_final (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_cfg_process_node_t), pointer :: cur, next
    cur => cfg%processes
    do while (associated (cur))
       next => cur%next
       deallocate (cur)
       nullify (cur)
       cur => next
    end do
  end subroutine blha_configuration_final

@ %def blha_configuration_final
@
Merge sort a process list w.r.t. to the process fingerprints. This is
necessary for canonicalizing the process list prior to calculating the
MD5 sum. 
<<BLHA config: procedures>>=
  subroutine sort_processes (list, n)
    type(blha_cfg_process_node_t), pointer :: list
    integer, intent(in), optional :: n
    type :: pnode
       type(blha_cfg_process_node_t), pointer :: p
    end type pnode
    type(pnode), dimension(:), allocatable :: array
    integer :: count, i, s, i1, i2, i3
    type(blha_cfg_process_node_t), pointer :: node
    if (present (n)) then
       count = n
    else
       node => list
       count = 0
       do while (associated (node))
          node => node%next
          count = count + 1
       end do
    end if
    ! Store list nodes into an array
    if (count == 0) return
    allocate (array(count))
    i = 1
    node => list
    do i = 1, count
       array(i)%p => node
       node => node%next
    end do
    s = 1
    ! Merge sort the array
    do while (s < count)
       i = 0
       i1 = 1
       i2 = s
       do while (i2 < count)
          i3 = min (s*(i+2), count)
          array(i1:i3) = merge (array(i1:i2), array(i2+1:i3))
          i = i + 2
          i1 = s*i+1
          i2 = s*(i+1)
       end do
       s = s * 2
    end do
    ! Relink according to their new order
    list => array(1)%p
    nullify (array(count)%p%next)
    node => list
    do i = 2, count
       node%next => array(i)%p
       node => node%next
    end do

  contains

    ! .le. comparision
    function lt (n1, n2) result (predicate)
      type(blha_cfg_process_node_t), intent(in) :: n1, n2
      logical :: predicate
      integer :: i
      predicate = .true.
      do i = 1, size (n1%fingerprint)
         if (n1%fingerprint(i) < n2%fingerprint(i)) return
         if (n1%fingerprint(i) > n2%fingerprint(i)) then
            predicate = .false.
            return
         end if
      end do
    end function lt

    ! Sorting core --- merge two sorted chunks
    function merge (l1, l2) result (lo)
      type(pnode), dimension(:), intent(in) :: l1, l2
      type(pnode), dimension(size (l1) + size (l2)) :: lo
      integer :: i, i1, i2
      i1 = 1
      i2 = 1
      do i = 1, size (lo)
         if (i1 > size (l1)) then
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         elseif (i2 > size (l2)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         elseif (lt (l1(i1)%p, l2(i2)%p)) then
            lo(i)%p => l1(i1)%p
            i1 = i1 + 1
         else
            lo(i)%p => l2(i2)%p
            i2 = i2 + 1
         end if
      end do
    end function merge

  end subroutine sort_processes
  
@ %def sort_processes
@
Create an array of massive particle indices, to be used by the 
"MassiveParticle"-statement of the order file.
<<BLHA config: procedures>>=
  subroutine blha_configuration_get_massive_particles &
             (cfg, massive, i_massive)
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out) :: massive
    integer, intent(out), dimension(:), allocatable :: i_massive
    integer, parameter :: max_particles = 10
    integer, dimension(max_particles) :: i_massive_tmp
    integer, dimension(max_particles) :: checked
    type(blha_cfg_process_node_t), pointer :: current_process 
    integer :: k
    integer :: n_massive
    n_massive = 0; k = 1
    checked = 0
    if (associated (cfg%processes)) then
       current_process => cfg%processes
    else
       call msg_fatal ("BLHA, massive particles: " // &
                       "No processes allocated!")
    end if
    do
       call check_pdg_list (current_process%pdg_in)
       call check_pdg_list (current_process%pdg_out)
       if (k > max_particles) &
          call msg_fatal ("BLHA, massive particles: " // &
                          "Max. number of particles exceeded!")
       if (associated (current_process%next)) then
          current_process => current_process%next
       else
          exit
       end if
    end do       
    if (n_massive > 0) then
       allocate (i_massive (n_massive))
       i_massive = i_massive_tmp (1:n_massive)
       massive = .true.
    else
       massive = .false.
    end if
  contains
    subroutine check_pdg_list (pdg_list)
       integer, dimension(:), intent(in) :: pdg_list
       integer :: i, i_pdg
       type(flavor_t) :: flv
       do i = 1, size (pdg_list)
          i_pdg = abs (pdg_list(i))
          call flv%init (i_pdg, cfg%model)
          if (flv%get_mass () > 0._default) then 
             !!! Avoid duplicates in output
             if (.not. any (checked == i_pdg)) then
                i_massive_tmp(k) = i_pdg
                checked(k) = i_pdg  
                k=k+1
                n_massive=n_massive+1
             end if
          end if
       end do
    end subroutine check_pdg_list
  end subroutine blha_configuration_get_massive_particles

@ %def blha_configuration_get_massive_particles
@
Append a process. This expands the flavor sum, sorts it and then
eliminates any duplicates.
<<BLHA config: public>>=
  public :: blha_configuration_append_process
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_process (cfg, pdg_in, pdg_out, nsub, ids)
    type(blha_configuration_t), intent(inout) :: cfg
    type(pdg_array_t), dimension(:), intent(in) :: pdg_in, pdg_out
    integer, optional, intent(in) :: nsub
    integer, optional, dimension(:), intent(in) :: ids
    type(blha_cfg_process_node_t), pointer :: root, node, tmp
    ! Multiindex for counting through the PDG numbers
    integer, dimension(size (pdg_in)) :: i_in
    integer, dimension(size (pdg_out)) :: i_out
    ! Handle the list of lists
    type :: ilist
       integer, dimension(:), allocatable :: i
    end type ilist
    type(ilist), dimension(size (pdg_in)) :: ilist_i
    type(ilist), dimension(size (pdg_out)) :: ilist_o
    integer :: i, j, nproc
    logical :: inc
    ! Extract PDGs into integer lists
    do i = 1, size (pdg_in)
       ilist_i(i)%i = pdg_in(i)
    end do
    do i = 1, size (pdg_out)
       ilist_o(i)%i = pdg_out(i)
    end do
    i_in = 1
    i_out = 1
    allocate (root)
    node => root
    ! Perform the expansion
    nproc = 0
    EXPAND: do
       ! Transfer the PDG selection...
       allocate (node%pdg_in(size (pdg_in)))
       allocate (node%pdg_out(size (pdg_out)))
       allocate (node%fingerprint (size (pdg_in) + size (pdg_out)))
       if (present (nsub)) node%nsub = nsub
       if (present (ids)) then
          allocate (node%ids(size (ids)))
          node%ids = ids
       end if
       forall (j=1:size(ilist_i)) &
          node%pdg_in(j) = ilist_i(j)%i(i_in(j))
       forall (j=1:size(ilist_o)) &
          node%pdg_out(j) = ilist_o(j)%i(i_out(j))
       node%fingerprint = [ node%pdg_in, sort (node%pdg_out) ]
       nproc = nproc + 1
       inc = .false.
       ! ... and increment the multiindex
       do j = 1, size (i_out)
          if (i_out(j) < size (ilist_o(j)%i)) then
             i_out(j) = i_out(j) + 1
             inc = .true.
             exit
          else
             i_out(j) = 1
          end if
       end do
       if (.not. inc) then
          do j = 1, size (i_in)
             if (i_in(j) < size (ilist_i(j)%i)) then
                i_in(j) = i_in(j) + 1
                inc = .true.
                exit
             else
                i_in(j) = 1
             end if
          end do
       end if
       if (.not. inc) exit EXPAND
       allocate (node%next)
       node => node%next
    end do EXPAND
    ! Do the sorting
    call sort_processes (root, nproc)
    ! Kill duplicates
    node => root
    do while (associated (node))
       if (.not. associated (node%next)) exit
       if (all (node%fingerprint == node%next%fingerprint)) then
          tmp => node%next%next
          deallocate (node%next)
          node%next => tmp
          nproc = nproc - 1
       else
          node => node%next
       end if
    end do
    ! Append the remaining list
    if (associated (cfg%processes)) then
       node => cfg%processes
       do while (associated (node%next))
          node => node%next
       end do
       node%next => root
    else
       cfg%processes => root
    end if
    cfg%n_proc = cfg%n_proc + nproc
    cfg%dirty = .true.
    
  end subroutine blha_configuration_append_process

@ %def blha_configuration_append_process
@
<<BLHA config: public>>=
  public :: blha_configuration_append_processes
<<BLHA config: procedures>>=
  subroutine blha_configuration_append_processes (cfg, flavor, amp_type)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_flv_state_t), dimension(:), intent(in) :: flavor
    integer, dimension(:), intent(in), optional :: amp_type
    integer :: n_tot
    type(blha_cfg_process_node_t), pointer :: current_node
    integer :: i_process, i_flv
    integer, dimension(:), allocatable :: pdg_in, pdg_out
    integer, dimension(:), allocatable :: flavor_state
    integer :: proc_offset, n_proc_tot
    proc_offset = 0; n_proc_tot = 0
    do i_flv = 1, size (flavor)
       n_proc_tot = n_proc_tot + flavor(i_flv)%flv_mult
    end do
    if (.not. associated (cfg%processes)) &
      allocate (cfg%processes)
    current_node => cfg%processes
    do i_flv = 1, size (flavor)
       n_tot = size (flavor(i_flv)%flavors)
       allocate (pdg_in (2), pdg_out (n_tot - 2))
       allocate (flavor_state (n_tot))
       flavor_state = flavor(i_flv)%flavors
       do i_process = 1, flavor(i_flv)%flv_mult
          pdg_in = flavor_state (1:2)
          pdg_out = flavor_state (3:)
          current_node%pdg_in = pdg_in
          current_node%pdg_out = pdg_out
          current_node%amplitude_type = amp_type (proc_offset+i_process)
          if (proc_offset+i_process /= n_proc_tot) then
            allocate (current_node%next)
            current_node => current_node%next
          end if
          if (i_process == flavor(i_flv)%flv_mult) &
             proc_offset = proc_offset + flavor(i_flv)%flv_mult
       end do
       deallocate (pdg_in, pdg_out)
       deallocate (flavor_state)
    end do
  end subroutine blha_configuration_append_processes

@ %def blha_configuration_append_processes
@ Change parameter(s).
<<BLHA config: public>>=
  public :: blha_configuration_set
<<BLHA config: procedures>>=
!  subroutine blha_configuration_set ( cfg, &
!       matrix_element_square_type_hel, matrix_element_square_type_hel_other, &
!       matrix_element_square_type_col, matrix_element_square_type_col_other, &
!       correction_type, correction_type_other, &
!       irreg, irreg_other, &
!       massive_particle_scheme, massive_particle_scheme_other, &
!       subtraction_mode, subtraction_mode_other, &
!       model_file, subdivide_subprocesses, alphas_power, alpha_power, &
!       operation_mode, operation_mode_other)
  subroutine blha_configuration_set (cfg, &
!       version, amplitude_type, correction_type, irreg, massive_particle_scheme, &
       version, correction_type, irreg, massive_particle_scheme, &
       model_file, alphas_power, alpha_power, ew_scheme, width_scheme, &
       accuracy, debug)
    type(blha_configuration_t), intent(inout) :: cfg
    integer, optional, intent(in) :: version
!    integer, optional, intent(in) :: amplitude_type
!    integer, optional, intent(in) :: matrix_element_square_type_hel
!    type(string_t), optional, intent(in) :: matrix_element_square_type_hel_other
!    integer, optional, intent(in) :: matrix_element_square_type_col
!    type(string_t), optional, intent(in) :: matrix_element_square_type_col_other
    integer, optional, intent(in) :: correction_type
!    type(string_t), optional, intent(in) :: correction_type_other
    integer, optional, intent(in) :: irreg
!    type(string_t), optional, intent(in) :: irreg_other
    integer, optional, intent(in) :: massive_particle_scheme
!    type(string_t), optional, intent(in) :: massive_particle_scheme_other
!    integer, optional, intent(in) :: subtraction_mode
!    type(string_t), optional, intent(in) :: subtraction_mode_other
    type(string_t), optional, intent(in) :: model_file
!    logical, optional, intent(in) :: subdivide_subprocesses
    integer, optional, intent(in) :: alphas_power, alpha_power
    integer, optional, intent(in) :: ew_scheme
    integer, optional, intent(in) :: width_scheme
    real(default), optional, intent(in) :: accuracy
    logical, optional, intent(in) :: debug
!    integer, intent(in), optional :: operation_mode
!    type(string_t), intent(in), optional :: operation_mode_other
!    if (present (matrix_element_square_type_hel)) &
!       cfg%matrix_element_square_type(1) = matrix_element_square_type_hel
!    if (present (matrix_element_square_type_hel_other)) &
!       cfg%matrix_element_square_type_other(1) = matrix_element_square_type_hel_other
!    if (present (matrix_element_square_type_col)) &
!       cfg%matrix_element_square_type(2) = matrix_element_square_type_col
!    if (present (matrix_element_square_type_col_other)) &
!       cfg%matrix_element_square_type_other(2) = matrix_element_square_type_col_other
    if (present (version)) &
       cfg%version = version
!    if (present (amplitude_type)) &
!       cfg%amplitude_type = amplitude_type
    if (present (correction_type)) &
       cfg%correction_type = correction_type
!    if (present (correction_type_other)) &
!       cfg%correction_type_other = correction_type_other
    if (present (irreg)) &
       cfg%irreg = irreg
!    if (present (irreg_other)) &
!       cfg%irreg_other = irreg_other
    if (present (massive_particle_scheme)) &
       cfg%massive_particle_scheme = massive_particle_scheme
!    if (present (massive_particle_scheme_other)) &
!       cfg%massive_particle_scheme_other = massive_particle_scheme_other
!    if (present (subtraction_mode)) &
!       cfg%subtraction_mode = subtraction_mode
!    if (present (subtraction_mode_other)) &
!       cfg%subtraction_mode_other = subtraction_mode_other
    if (present (model_file)) &
       cfg%model_file = model_file
!    if (present (subdivide_subprocesses)) &
!       cfg%subdivide_subprocesses = subdivide_subprocesses
    if (present (alphas_power)) &
       cfg%alphas_power = alphas_power
    if (present (alpha_power)) &
       cfg%alpha_power = alpha_power
!    if (present (operation_mode)) &
!       cfg%operation_mode = operation_mode
!    if (present (operation_mode_other)) &
!       cfg%operation_mode_other = operation_mode_other
    if (present (ew_scheme)) &
       cfg%ew_scheme = ew_scheme
    if (present (width_scheme)) &
       cfg%width_scheme = width_scheme
    if (present (accuracy)) &
       cfg%accuracy_target = accuracy
    if (present (debug)) &
       cfg%debug_unstable = debug
    cfg%dirty = .false.
  end subroutine blha_configuration_set

@ %def blha_configuration_set
@
<<BLHA config: public>>=
  public :: blha_configuration_get_n_proc
<<BLHA config: procedures>>=
  function blha_configuration_get_n_proc (cfg) result (n_proc)
    type(blha_configuration_t), intent(in) :: cfg
    integer :: n_proc
    n_proc = cfg%n_proc
  end function blha_configuration_get_n_proc

@ %def blha_configuration_get_n_proc
@
Write the BLHA file. Internal mode is intented for md5summing only. 
<<BLHA config: public>>=
  public :: blha_configuration_write
<<BLHA config: procedures>>=
  subroutine blha_configuration_write (cfg, unit, internal)
    type(blha_configuration_t), intent(in) :: cfg
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: internal
    integer :: u
    logical :: full
    type(string_t) :: buf
    type(blha_cfg_process_node_t), pointer :: node
    integer :: i
    character(3) :: pdg_char
    character(6) :: accuracy
    character(len=25), parameter :: pad = ""
    integer, dimension(:), allocatable :: i_massive
    logical :: massive_particles
    u = given_output_unit (unit)
    full = .true.; if (present (internal)) full = .not. internal
    if (full .and. cfg%dirty) call msg_bug ( &
       "BUG: attempted to write out a dirty BLHA configuration")
    if (full) then
       write (u,'(A)') "# BLHA order written by WHIZARD <<Version>>"
       write (u,'(A)')
    end if
    select case (cfg%mode)
       case (BLHA_MODE_GOSAM); buf = "GoSam"
       case (BLHA_MODE_OPENLOOPS); buf = "OpenLoops"
       case default; buf = "vanilla"
    end select
    write (u,'(A)') "# BLHA interface mode: " // char (buf)
    write (u,'(A)') "# process: " // char (cfg%name)
    write (u,'(A)') "# model: " // char (cfg%model%get_name ())
!    if (full) then
!       write (u,'(A)')
!       write (u,'(A)') '#@WO MD5 "' // char (cfg%md5) // '"'
!       write (u,'(A)')
!    end if
!    if (all (cfg%matrix_element_square_type == BLHA_MEST_SUM)) then
!       buf = "CHsummed"
!    elseif (all (cfg%matrix_element_square_type == BLHA_MEST_AVG)) then
!       buf = "CHaveraged"
!    else
!       buf = (render_mest ("H", cfg%matrix_element_square_type(1), &
!             cfg%matrix_element_square_type_other(1)) // " ") // &
!          render_mest ("C", cfg%matrix_element_square_type(2), &
!             cfg%matrix_element_square_type_other(2))
!    end if
!    write (u,'(A25,A)') "MatrixElementSquareType" // pad, char (buf)
    select case (cfg%version)
       case (1); buf = "BLHA1"
       case (2); buf = "BLHA2"
    end select
    write (u, '(A25,A)') "InterfaceVersion " // pad, char (buf)
    select case (cfg%correction_type)
       case (BLHA_CT_QCD); buf = "QCD"
       case (BLHA_CT_EW); buf = "EW"
       case (BLHA_CT_QED); buf = "QED"
       case default; buf = cfg%correction_type_other
    end select
    write (u,'(A25,A)') "CorrectionType" // pad, char (buf)

    select case (cfg%mode)
    case (BLHA_MODE_OPENLOOPS)
       buf = cfg%name // '.olc'
       write (u, '(A25,A)') "Extra AnswerFile" // pad, char (buf)
    end select

    select case (cfg%irreg)
       case (BLHA_IRREG_CDR); buf = "CDR"
       case (BLHA_IRREG_DRED); buf = "DRED"
       case (BLHA_IRREG_THV); buf = "tHV"
       case (BLHA_IRREG_MREG); buf = "MassReg"
       case default; buf = cfg%irreg_other
    end select
    write (u,'(A25,A)') "IRregularisation" // pad, char (buf)
    select case (cfg%massive_particle_scheme)
       case (BLHA_MPS_ONSHELL); buf = "OnShell"
       case default; buf = cfg%massive_particle_scheme_other
    end select
    if (cfg%mode == BLHA_MODE_GOSAM) &
       write (u,'(A25,A)') "MassiveParticleScheme" // pad, char (buf)
!    select case (cfg%subtraction_mode)
!       case (BLHA_SUBMODE_NONE); buf = "None"
!       case default; buf = cfg%subtraction_mode_other
!    end select
!    write (u,'(A25,A)') "IRsubtractionMethod" // pad, char (buf)
!    write (u,'(A25,A)') "ModelFile" // pad, char (cfg%model_file)
!    if (cfg%subdivide_subprocesses) then
!       write (u,'(A25,A)') "SubdivideSubprocesses" // pad, "yes"
!    else
!       write (u,'(A25,A)') "SubdivideSubprocess" // pad, "no"
!    end if
    select case (cfg%version)
    case (1)
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "AlphasPower" // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u,'(A25,A)') &
         "AlphaPower " // pad, int2char (cfg%alpha_power)
    case (2) 
      if (cfg%alphas_power >= 0) write (u,'(A25,A)') &
         "CouplingPower QCD " // pad, int2char (cfg%alphas_power)
      if (cfg%alpha_power >= 0) write (u, '(A25,A)') &
         "CouplingPower QED " // pad, int2char (cfg%alpha_power)
    end select
    select case (cfg%ew_scheme)
       case (BLHA_EW_GF); buf = "alphaGF"
       case (BLHA_EW_MZ); buf = "alphaMZ"
       case (BLHA_EW_MSBAR); buf = "alphaMSbar"
       case (BLHA_EW_0); buf = "alpha0"
       case (BLHA_EW_RUN); buf = "alphaRUN"
       case (BLHA_EW_DEFAULT); buf = "OLPDefined"
    end select
    select case (cfg%mode)
    case (BLHA_MODE_GOSAM)
       write (u, '(A25, A)') "EWScheme " // pad, char (buf)
    case (BLHA_MODE_OPENLOOPS)
!       write (u, '(A25, A)') "ewscheme " // pad, char (buf)
    endselect
    select case (cfg%mode)
    case (BLHA_MODE_GOSAM)
       write (u, '(A25)', advance='no') "MassiveParticles " // pad
       do i = 1, size (OLP_MASSIVE_PARTICLES)
          if (OLP_MASSIVE_PARTICLES(i) > 0) &
              write (u, '(I2,1X)', advance='no') OLP_MASSIVE_PARTICLES(i)
       end do
       write (u,*) 
    case (BLHA_MODE_OPENLOOPS)
       write (u, '(A25,I1)') "extra use_cms " // pad, 0
    end select
    if (full) then
       write (u,'(A)')
       write (u,'(A)') "# Process definitions"
       write (u,'(A)')
    end if
!    if (cfg%accuracy_target /= 0) then
!      write (accuracy, '(f6.5)') cfg%accuracy_target
!      write (u, '(A25,A)') "AccuracyTarget " // pad , accuracy 
!    end if
!    if (cfg%debug_unstable) then
!      buf = "True"
!    else
!      buf = "False"
!    end if
!   write (u, '(A25,A)') "DebugUnstable " // pad, char (buf)
    if (cfg%debug_unstable) &
      write (u, '(A25,A)') "DebugUnstable " // pad, "True"
    write (u, *)
    node => cfg%processes
    do while (associated (node))
       select case (node%amplitude_type)
         case (BLHA_AMP_LOOP); buf = "Loop"
         case (BLHA_AMP_CC); buf = "ccTree"
         case (BLHA_AMP_SC); buf = "scTree"
         case (BLHA_AMP_TREE); buf = "Tree"
         case (BLHA_AMP_LOOPINDUCED); buf = "LoopInduced"
       end select
       write (u, '(A25, A)') "AmplitudeType " // pad, char (buf)

       buf = ""
       do i = 1, size (node%pdg_in)
          write (pdg_char,'(I3)') node%pdg_in(i)
          buf = (buf // pdg_char) // " "
       end do
       buf = buf // "-> "
       do i = 1, size (node%pdg_out)
          write (pdg_char,'(I3)') node%pdg_out(i)
          buf = (buf // pdg_char) // " "
       end do
       write (u,'(A)') char (trim (buf))
       write (u, *)
       node => node%next
    end do

  contains

    function render_mest (prefix, mest, other) result (tag)
      character, intent(in) :: prefix
      integer, intent(in) :: mest
      type(string_t), intent(in) :: other
      type(string_t) :: tag
      select case (mest)
      case (BLHA_MEST_AVG); tag = prefix // "averaged"
      case (BLHA_MEST_SUM); tag = prefix // "summed"
      case default; tag = other
      end select
    end function render_mest

  end subroutine blha_configuration_write

@ %def blha_configuration_write
@
``Freeze'' the configuration by calculating the MD5 sum.
<<BLHA config: public>>=
  public :: blha_configuration_freeze
<<BLHA config: procedures>>=
  subroutine blha_configuration_freeze (cfg)
    type(blha_configuration_t), intent(inout) :: cfg
    integer :: u
    if (.not. cfg%dirty) return
    call sort_processes (cfg%processes)
    u = free_unit ()
    open (unit=u, status="scratch", action="readwrite")
    call blha_configuration_write (cfg, u, internal=.true.)
    rewind (u)
    cfg%md5 = md5sum (u)
    cfg%dirty = .false.
    close (u)
  end subroutine blha_configuration_freeze

@ %def blha_configuration_freeze
@
Read a contract file, again creating a [[blha_configuration_t]]
object. 
<<BLHA config: public>>=
  public :: blha_read_contract
<<BLHA config: interfaces>>=
  interface blha_read_contract
     module procedure blha_read_contract_unit, &
          blha_read_contract_file
  end interface blha_read_contract 
  
<<BLHA config: procedures>>=
  subroutine blha_read_contract_file (cfg, ok, fname, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(string_t), intent(in) :: fname
    logical, intent(out), optional :: success
    integer :: u, stat
    u = free_unit ()
    open (u, file=char (fname), status="old", action="read", iostat=stat)
    if (stat /= 0) then
       if (present (success)) then
          success = .false.
          return
       else
          call msg_bug ('Unable to open contract file "' // char (fname) // '"')
       end if
    end if
    call blha_read_contract_unit (cfg, ok, u, success)
    close (u)
  end subroutine blha_read_contract_file

  subroutine blha_read_contract_unit (cfg, ok, u, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    integer, intent(in) :: u
    logical, intent(out), optional :: success
    type(stream_t) :: stream
    type(ifile_t) :: preprocessed
    type(lexer_t) :: lexer
    type(parse_tree_t) :: parse_tree
    type(string_t) :: md5
    call stream_init (stream, u)
    call contract_preprocess (stream, preprocessed)
    call stream_final (stream)
    call stream_init (stream, preprocessed)
    call blha_init_lexer (lexer)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_blha_contract, lexer)
    call blha_transfer_contract (cfg, ok, parse_tree, success)
    call blha_configuration_write (cfg, internal=.true.)
    call lexer_final (lexer)
    call stream_final (stream)
    call ifile_final (preprocessed)
    if (ok) then
       md5 = cfg%md5
       call blha_configuration_freeze (cfg)
       if (char (trim (md5 )) /= "") then
          if (md5 /= cfg%md5) then
             call msg_warning ("BLHA contract does not match the recorded " &
                // "checksum --- this counts as an error!")
             ok = .false.
          end if
       else
          call msg_warning ("It seems the OLP scrubbed our checksum, unable " &
             // "to check contract consistency.")
       end if
    end if
  end subroutine blha_read_contract_unit

@ %def blha_read_contract blha_read_contract_file 
@ %def blha_read_contract_unit
@
Walk the parse tree and transfer the results to the
[[blha_configuration]] object. The [[goto]] is a poor man's
replacement for exceptions which would be an appropiate error handling  
mechanism here. 
<<BLHA config: procedures>>=
  subroutine blha_transfer_contract (cfg, ok, parse_tree, success)
    type(blha_configuration_t), intent(inout) :: cfg
    logical, intent(out) :: ok
    type(parse_tree_t), intent(in), target :: parse_tree
    logical, intent(out), optional :: success
    type(parse_node_t), pointer :: pn_root, pn_line, pn_request, &
         pn_result, pn_key, pn_opt, pn_state_in, pn_state_out, pn_pdg
    type(string_t) :: emsg
    integer :: nopt, i, nsub
    integer, dimension(:), allocatable :: ids
    logical, dimension(2) :: flags
    type(pdg_array_t), dimension(:), allocatable :: pdg_in, pdg_out
    ok = .true.
    pn_root => parse_tree_get_root_ptr (parse_tree)
    pn_line => parse_node_get_sub_ptr (pn_root)
    do while (associated (pn_line))
       pn_request => parse_node_get_sub_ptr (pn_line)
       if (.not. associated (pn_request)) cycle
       if (char (parse_node_get_rule_key (pn_request)) == "process") then
          pn_result => parse_node_get_sub_ptr (pn_line, 2)
          pn_state_in => parse_node_get_sub_ptr (pn_request, 1)
          pn_state_out => parse_node_get_sub_ptr (pn_request, 3)
          allocate (pdg_in (parse_node_get_n_sub (pn_state_in)))
          allocate (pdg_out (parse_node_get_n_sub (pn_state_out)))
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_in)
          do while (associated (pn_pdg))
             pdg_in(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = 1
          pn_pdg => parse_node_get_sub_ptr (pn_state_out)
          do while (associated (pn_pdg))
             pdg_out(i) = [get_int (pn_pdg)]
             pn_pdg => parse_node_get_next_ptr (pn_pdg)
             i = i + 1
          end do
          i = parse_node_get_n_sub (pn_result)
          emsg = "broken process line"
          if (i < 2) goto 10
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          do while (associated (pn_opt))
             if (char (parse_node_get_rule_key (pn_opt)) == "string") then
                call msg_warning ("While reading the BLHA contract: " // &
                   'the OLP returned an error for a process: "' // &
                   char (parse_node_get_string (pn_opt)) // '"')
                ok = .false.
                return
             end if
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          pn_opt => parse_node_get_sub_ptr (pn_result, 2)
          nsub = get_int (pn_opt)
          if (nsub /= i - 2) goto 10
          allocate (ids(nsub))
          i = 1
          pn_opt => parse_node_get_next_ptr (pn_opt)
          do while (associated (pn_opt))
             ids(i) = get_int (pn_opt)
             pn_opt => parse_node_get_next_ptr (pn_opt)
          end do
          call blha_configuration_append_process (cfg, pdg_in, pdg_out, &
             nsub=nsub, ids=ids)
          deallocate (pdg_in, pdg_out, ids)
       else
          pn_result => parse_node_get_sub_ptr (parse_node_get_next_ptr (pn_request), 2)
          pn_key => parse_node_get_sub_ptr (pn_request)
          pn_opt => parse_node_get_next_ptr (pn_key)
          nopt = parse_node_get_n_sub (pn_request) - 1
          select case (char (parse_node_get_rule_key (pn_key)))
             case ("md5")
                cfg%md5 = parse_node_get_string (pn_opt)
             case ("modelfile")
                cfg%model_file = get_fname (pn_opt)
                call check_result (pn_result, "ModelFile")
             case ("irregularisation")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("cdr"); cfg%irreg = BLHA_IRREG_CDR
                   case ("dred"); cfg%irreg = BLHA_IRREG_DRED
                   case ("thv"); cfg%irreg = BLHA_IRREG_THV
                   case ("mreg"); cfg%irreg = BLHA_IRREG_MREG
                   case default
                      cfg%irreg = BLHA_IRREG_OTHER 
                      cfg%irreg_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "IRRegularisation")
             case ("irsubtractionmethod")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("none"); cfg%subtraction_mode = BLHA_SUBMODE_NONE
                   case default
                      cfg%subtraction_mode = BLHA_SUBMODE_OTHER
                      cfg%subtraction_mode_other = parse_node_get_string(pn_opt)
                end select
                call check_result (pn_result, "IRSubtractionMethod")
             case ("massiveparticlescheme")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("onshell")
                      cfg%massive_particle_scheme = BLHA_MPS_ONSHELL
                   case default
                      cfg%massive_particle_scheme = BLHA_MPS_OTHER
                      cfg%massive_particle_scheme_other = &
                         parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "MassiveParticleScheme")
             case ("matrixelementsquaretype")
                select case (nopt)
                   case (1)
                      select case (lower_case (char (parse_node_get_string (pn_opt))))
                         case ("chsummed")
                            cfg%matrix_element_square_type = BLHA_MEST_SUM
                         case ("chaveraged")
                            cfg%matrix_element_square_type = BLHA_MEST_AVG
                         case default
                            emsg = "invalid MatrixElementSquareType: " // &
                               parse_node_get_string (pn_opt)
                            goto 10
                      end select
                   case (2)
                      do i = 1, 2
                         pn_opt => parse_node_get_next_ptr (pn_key, i)
                         select case (lower_case (char (parse_node_get_string ( &
                               pn_opt))))
                            case ("csummed")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_SUM
                               flags(2) = .true.
                            case ("caveraged")
                               cfg%matrix_element_square_type(2) = BLHA_MEST_AVG
                               flags(2) = .true.
                            case ("hsummed")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_SUM
                               flags(1) = .true.
                            case ("haveraged")
                               cfg%matrix_element_square_type(1) = BLHA_MEST_AVG
                               flags(1) = .true.
                            case default
                               emsg = "invalid MatrixElementSquareType: " // &
                                  parse_node_get_string (pn_opt)
                               goto 10
                         end select
                      end do
                      if (.not. all (flags)) then
                         emsg = "MatrixElementSquareType: setup not exhaustive"
                         goto 10
                      end if
                   case default
                      emsg = "MatrixElementSquareType: too many options"
                      goto 10
                end select
                call check_result (pn_result, "MatrixElementSquareType")
             case ("correctiontype")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("qcd"); cfg%correction_type = BLHA_CT_QCD
                   case ("qed"); cfg%correction_type = BLHA_CT_QED
                   case ("ew"); cfg%correction_type = BLHA_CT_EW
                   case default
                      cfg%correction_type = BLHA_CT_OTHER
                      cfg%correction_type_other = parse_node_get_string (pn_opt)
                end select
                call check_result (pn_result, "CorrectionType")
             case ("alphaspower")
                cfg%alphas_power = get_int (pn_opt)
                call check_result (pn_result, "AlphasPower")
             case ("alphapower")
                cfg%alpha_power = get_int (pn_opt)
                call check_result (pn_result, "AlphaPower")
             case ("subdividesubprocess")
                select case (lower_case (char (parse_node_get_string (pn_opt))))
                   case ("yes"); cfg%subdivide_subprocesses = .true.
                   case ("no"); cfg%subdivide_subprocesses = .false.
                   case default
                      emsg = 'SubdivideSubprocess: invalid argument "' // &
                         parse_node_get_string (pn_opt) // '"'
                      goto 10
                end select
                call check_result (pn_result, "SubdivideSubprocess")
             case default
                emsg = "unknown statement: " // parse_node_get_rule_key (pn_key)
                goto 10
          end select
       end if
       pn_line => parse_node_get_next_ptr (pn_line)
    end do
    if (present (success)) success = .true.
    return
10  continue
    if (present (success)) then
       call msg_error ("Error reading BLHA contract: " // char (emsg))
       success = .false.
       return
    else
       call msg_fatal ("Error reading BLHA contract: " // char (emsg))
    end if

  contains

    function get_int (pn) result (i)
      type(parse_node_t), pointer :: pn
      integer :: i
      if (char (parse_node_get_rule_key (pn)) == "integer") then
         i = parse_node_get_integer (pn)
      else
         i = parse_node_get_integer (parse_node_get_sub_ptr (pn, 2))
         if (char (parse_node_get_rule_key (parse_node_get_sub_ptr (pn))) &
              == "-") i = -i
      end if
    end function get_int

    subroutine check_result (pn, step)
      type(parse_node_t), pointer :: pn
      character(*), intent(in) :: step
      type(string_t) :: res
      res = parse_node_get_string (pn)
      if (char (trim (res)) == "") then
         call msg_warning ("BLHA contract file: " // step // &
              ": OLP didn't return a status --- assuming an error")
         ok = .false.
      elseif (char (upper_case (res)) /= "OK") then
         call msg_warning ("BLHA contract file: " // step // &
              ': OLP error "' // char (res) // '"')
         ok = .false.
      end if
    end subroutine check_result

    function get_fname (pn) result (fname)
      type(parse_node_t), pointer :: pn
      type(string_t) :: fname
      type(parse_node_t), pointer :: pn_component
      if (char (parse_node_get_rule_key (pn)) == "string") then
         fname = parse_node_get_string (pn)
      else
         fname = ""
         pn_component => parse_node_get_sub_ptr (pn)
         do while (associated (pn_component))
            if (char (parse_node_get_rule_key (pn_component)) == "id") then
               fname = fname // parse_node_get_string (pn_component)
            else
               fname = fname // parse_node_get_key (pn_component)
            end if
            pn_component => parse_node_get_next_ptr (pn_component)
         end do
      end if
    end function get_fname

  end subroutine blha_transfer_contract

@ %def blha_transfer_contract
@
Initialize the lexer.
<<BLHA config: procedures>>=
  subroutine blha_init_lexer (lexer)
    type(lexer_t), intent(inout) :: lexer
    call lexer_init (lexer, &
       comment_chars = "#", &
       quote_chars = '"', &
       quote_match = '"', &
       single_chars = '{}|./\:', &
       special_class = ["->"], &
       keyword_list = syntax_get_keyword_list_ptr (syntax_blha_contract), &
       upper_case_keywords = .false. &
       ) 
  end subroutine blha_init_lexer

@ %def blha_init_lexer
@
Define the parser syntax table.
<<BLHA config: variables>>=
  type(syntax_t), target, save :: syntax_blha_contract
<<BLHA config: public>>=
  public :: syntax_blha_contract_init
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_init ()
    type(ifile_t) :: ifile
    call ifile_append (ifile, "SEQ contract = line*")
    call ifile_append (ifile, "KEY '->'")
    call ifile_append (ifile, "KEY '.'")
    call ifile_append (ifile, "KEY '/'")
    call ifile_append (ifile, "KEY '\'")
    call ifile_append (ifile, "KEY '+'")
    call ifile_append (ifile, "KEY '-'")
    call ifile_append (ifile, "KEY '|'")
    call ifile_append (ifile, "KEY ':'")
    call ifile_append (ifile, "IDE id")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "ALT sign = '+' | '-'")
    call ifile_append (ifile, "SEQ signed_integer = sign integer")
    call ifile_append (ifile, "QUO string = '""'...'""'")
    call ifile_append (ifile, "GRO line = '{' line_contents '}'")
    call ifile_append (ifile, "SEQ line_contents = request result?")
    call ifile_append (ifile, "ALT request = definition | process")
    call ifile_append (ifile, "ALT definition = option_unary | option_nary | " &
       // "option_path | option_numeric")
    call ifile_append (ifile, "KEY matrixelementsquaretype")
    call ifile_append (ifile, "KEY irregularisation")
    call ifile_append (ifile, "KEY massiveparticlescheme")
    call ifile_append (ifile, "KEY irsubtractionmethod")
    call ifile_append (ifile, "KEY modelfile")
    call ifile_append (ifile, "KEY operationmode")
    call ifile_append (ifile, "KEY subdividesubprocess")
    call ifile_append (ifile, "KEY alphaspower")
    call ifile_append (ifile, "KEY alphapower")
    call ifile_append (ifile, "KEY correctiontype")
    call ifile_append (ifile, "KEY md5")
    call ifile_append (ifile, "SEQ option_unary = key_unary arg")
    call ifile_append (ifile, "SEQ option_nary = key_nary arg+")
    call ifile_append (ifile, "SEQ option_path = key_path arg_path")
    call ifile_append (ifile, "SEQ option_numeric = key_numeric arg_numeric")
    call ifile_append (ifile, "ALT key_unary = irregularisation | " &
       // "massiveparticlescheme | irsubtractionmethod | subdividesubprocess | " &
       // "correctiontype | md5")
    call ifile_append (ifile, "ALT key_nary = matrixelementsquaretype | " &
       // "operationmode")
    call ifile_append (ifile, "ALT key_numeric = alphaspower | alphapower")
    call ifile_append (ifile, "ALT key_path = modelfile")
    call ifile_append (ifile, "ALT arg = id | string")
    call ifile_append (ifile, "ALT arg_numeric = integer | signed_integer")
    call ifile_append (ifile, "ALT arg_path = filename | string")
    call ifile_append (ifile, "SEQ filename = filename_atom+")
    call ifile_append (ifile, "ALT filename_atom = id | '.' | '/' | '\' | ':'")
    call ifile_append (ifile, "SEQ process = state '->' state")
    call ifile_append (ifile, "SEQ state = pdg+")
    call ifile_append (ifile, "ALT pdg = integer | signed_integer")
    call ifile_append (ifile, "SEQ result = '|' result_atom+")
    call ifile_append (ifile, "ALT result_atom = integer | string")
    call syntax_init (syntax_blha_contract, ifile)
    call ifile_final (ifile)
  end subroutine syntax_blha_contract_init

@ %def syntax_blha_contract_init
@
<<BLHA config: public>>=
  public :: syntax_blha_contract_final
<<BLHA config: procedures>>=
  subroutine syntax_blha_contract_final
    call syntax_final (syntax_blha_contract)
  end subroutine syntax_blha_contract_final

@ %def syntax_blha_contract_final
@
As the contract file is line-oriented, we apply a preprocessing step which
reformats the file in a way suitable for our free-form parser.
<<BLHA config: procedures>>=
  subroutine contract_preprocess (stream, ifile)
    type(stream_t), intent(inout) :: stream
    type(ifile_t), intent(out) :: ifile
    type(string_t) :: buf, reg, transformed
    integer :: stat, n
    buf = ""
    LINES: do
       call stream_get_record (stream, reg, stat)
       select case (stat)
          case (0)
          case (EOF); exit LINES
          case default
             call msg_bug ("I/O error while reading BLHA contract file")
       end select
       buf = buf // trim (reg)
       ! Take care of continuation lines
       if (char (extract (buf, len (buf), len(buf))) == '&') then
          buf = extract (buf, 1, len (buf) - 1) // " "
          cycle LINES
       end if
       buf = adjustl (buf)
       ! Transform #@WO comments into ordinary statements
       if (char (extract (buf, 1, 4)) == "#@WO") &
          buf = extract (buf, 5)
       ! Kill comments and blank lines
       if ((char (trim (buf)) == "") .or. &
          (char (extract (buf, 1, 1)) == "#")) then
             buf = ""
             cycle LINES
          end if
       ! Chop off any end-of-line comments
       call split (buf, reg, "#")
       ! Split line into order and result
       call split (reg, buf, "|")
       reg = trim (adjustl (reg))
       buf = trim (adjustl (buf))
       ! Check whether the order is a process definition
       n = scan (buf, ">")
       if (n == 0) then
          ! No -> quote result
          reg = ('"' // reg) // '"'
       else
          ! Yes -> leave any numbers as they are, quote any leftovers
          n = scan (reg, "0123456789", back=.true.)
          if (n < len (reg)) &
             reg = char (extract (reg, 1, n)) // ' "' // &
                char (trim (adjustl (extract (reg, n+1)))) // '"'
       end if
       ! Enclose the line into curly brackets
       transformed = "{" // char (buf) // " | " // char (reg) // "}"
       call ifile_append (ifile, transformed)
       buf = ""
    end do LINES
  end subroutine contract_preprocess

@ %def contract_preprocess
@
Test.
<<BLHA config: public>>=
  public :: blha_config_test
<<BLHA config: procedures>>=
  subroutine blha_config_test (model, cfg, ok)
    type(pdg_array_t), dimension(2) :: pdg_in
    type(pdg_array_t), dimension(4) :: pdg_out
    class(model_data_t), pointer :: model
    type(blha_configuration_t), intent(out) :: cfg
    logical, intent(out) :: ok
    integer :: u
    logical :: flag
    ok = .false.
    pdg_in(1) = [1, 2, -1, -2]
    pdg_in(2) = pdg_in(1)
    pdg_out(1) = pdg_in(1)
    pdg_out(2) = [11]
    pdg_out(3) = [-11]
    pdg_out(4) = pdg_out(1)
    call blha_configuration_init (cfg, var_str ("test"), model)
    call blha_configuration_set (cfg, alphas_power = 2, alpha_power = 3)
    call blha_configuration_append_process (cfg, pdg_in, pdg_out)
    call blha_configuration_freeze (cfg)
    print *
    call blha_configuration_write (cfg)
    print *
    call blha_configuration_final (cfg)
    call blha_configuration_init (cfg, var_str ("test"), model, &
       mode=BLHA_MODE_GOSAM)
    call blha_configuration_set (cfg, alphas_power = 0, &
       model_file = var_str ("test.slha"))
    pdg_in(1) = [1]
    pdg_in(2) = [-1]
    pdg_out(1) = [22]
    pdg_out(2) = [22]   
    call blha_configuration_append_process (cfg, pdg_in, pdg_out(1:2))
    call blha_configuration_freeze (cfg)
    u = free_unit ()
    open (u, file="test.blha.order", action="write", status="replace")
    call blha_configuration_write (cfg, u)
    call blha_configuration_final (cfg)
    inquire (file="test.blha.contract", exist=flag)
    if (.not. flag) return
    call blha_configuration_init (cfg, var_str ("test"), model, mode=BLHA_MODE_GOSAM)
    call blha_read_contract (cfg, ok, var_str ("test.blha.contract"), success=flag)
    print *, "Reading back processed configuration: success? ", ok
  end subroutine blha_config_test

@ %def blha_config_test
@

\section{OLP matrix element interface}

The prototypes of the OLP functions.
<<BLHA interface: interfaces>>=
  abstract interface
     subroutine ext_olp_start (file, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: file
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_Start

     subroutine ext_olp_evalsubprocess &
          (label, momenta, scale, parameters, amp) bind(c)
       import
       integer(c_int), intent(in), value :: label
       real(c_double), dimension(*), intent(in) :: momenta
       real(c_double), intent(in), value :: scale
       real(c_double), dimension(*), intent(in) :: parameters
       real(c_double), dimension(*), intent(out) :: amp
     end subroutine ext_olp_evalsubprocess

     subroutine ext_olp_finalize () bind(c)
     end subroutine ext_olp_finalize

     subroutine ext_olp_option (assignment, status) bind(c)
       import
       character(c_char), dimension(*), intent(in) :: assignment
       integer(c_int), intent(out) :: status
     end subroutine ext_olp_option
  end interface

@ %def ext_olp_start ext_olp_evalsubprocess ext_olp_finalize
@ %def ext_olp_option
@
The OLP library is encapsulated together with the configuration in
derived type: 
<<BLHA interface: public>>=
  public :: blha_olp_t
<<BLHA interface: types>>=
  type :: blha_olp_t
     private
     type(blha_configuration_t) :: cfg
     type(string_t) :: library
     integer :: n_in, n_out, n_flv, n_hel, n_col
     integer, dimension(:,:), allocatable :: flv_state
     logical :: color_summed = .true., flavor_summed = .true.
     logical :: loaded = .false.
     type(dlaccess_t) :: lib_handle
     procedure(ext_olp_start), pointer, nopass :: olp_start => null ()
     procedure(ext_olp_evalsubprocess), pointer, nopass :: &
        olp_evalsubprocess => null ()
     procedure(ext_olp_finalize), pointer, nopass :: olp_finalize => null ()
     procedure(ext_olp_option), pointer, nopass :: olp_option => null ()
  end type blha_olp_t

@ %def blha_olpt_t
@
Init the [[blha_olp_t]] object and try to dlopen the library. 
<<BLHA interface: public>>=
  public :: blha_olp_init
<<BLHA interface: procedures>>=
  subroutine blha_olp_init (olp, cfg, library, success)
    type(blha_olp_t), intent(out) :: olp
    type(string_t), intent(in), optional :: library
    type(blha_configuration_t), intent(in) :: cfg
    logical, intent(out), optional :: success
    type(blha_cfg_process_node_t), pointer :: node
    type(string_t) :: prefix, libname
    type(c_funptr) :: fptr
    integer :: olp_status
    success = .true.
    node => cfg%processes
    if (.not. associated (node)) then
       call error ("blha_interface_init: empty process list")
       return
    end if
    olp%n_in = size (node%pdg_in)
    olp%n_out = size (node%pdg_out)
    do while (associated (node))
       if ((olp%n_in /= size (node%pdg_in)) .or. &
             (olp%n_out /= size (node%pdg_out))) then
          call error ("blha_interface_init: inconsistent process list")
          return
       end if
       node => node%next
    end do
    if (present (library)) then
       olp%library = library
    else
       olp%library = cfg%name // ".so"
    end if
    if (char (extract (olp%library, 1, 1)) == "/") then
       prefix = ""
       libname = extract (olp%library, 2)
    else
       prefix = "."
       libname = olp%library
    end if
    call dlaccess_init (olp%lib_handle, prefix, libname)
    if (dlaccess_has_error (olp%lib_handle)) then
       call error ("blha_interface_init: error opening library: " // &
          char (dlaccess_get_error (olp%lib_handle)))
       call dlaccess_final (olp%lib_handle)
       return
    end if
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Start"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_start)
    fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_EvalSubProcess"))
    if (.not. check_dlstate ()) return
    call c_f_procpointer (fptr, olp%olp_evalsubprocess)
    if (olp%cfg%mode == BLHA_MODE_GOSAM) then
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Finalize"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_finalize)
       fptr = dlaccess_get_c_funptr (olp%lib_handle, var_str ("OLP_Option"))
       if (.not. check_dlstate ()) return
       call c_f_procpointer (fptr, olp%olp_option)
    end if
    call olp%olp_start (string_f2c (cfg%model_file), olp_status)
    if (olp_status /= 1) then
       call error ("blha_interface_init: OLP initialization failed")
       call dlaccess_final (olp%lib_handle)
    end if
    success = .true.
    olp%loaded = .true.

  contains

    function check_dlstate () result (ok)
      logical :: ok
      ok = .not. dlaccess_has_error (olp%lib_handle)
      if (.not. ok) then
         call error ("blha_interface_init: error loading library: " // &
              char (dlaccess_get_error (olp%lib_handle)))
         call dlaccess_final (olp%lib_handle)
      end if
    end function check_dlstate
   
    subroutine error (msg)
      character(*), intent(in) :: msg
      if (present (success)) then
         call msg_error (msg)
         success = .false.
      else
         call msg_fatal (msg)
      end if
    end subroutine error

  end subroutine blha_olp_init

@ %def blha_olp_init
@ Finalizer.
<<BLHA interface: public>>=
  public :: blha_olp_final
<<BLHA interface: procedures>>=
  subroutine blha_olp_final (olp)
    type(blha_olp_t), intent(inout) :: olp
    if (.not. olp%loaded) return
    if (associated (olp%olp_finalize)) call olp%olp_finalize
    call dlaccess_final (olp%lib_handle)
    olp%loaded = .false.
  end subroutine blha_olp_final

@ %def blha_olp_final
@ Test.
<<BLHA interface: public>>=
  public :: blha_interface_test
<<BLHA interface: procedures>>=
  subroutine blha_interface_test (cfg, ok)
    type(blha_configuration_t), intent(inout) :: cfg
    type(blha_olp_t) :: olp
    logical, intent(out) :: ok
    call blha_olp_init (olp, cfg, library=var_str ("blha_test.so"), success=ok)
    print *, "loading OLP library: success?", ok
    call blha_olp_final (olp)
  end subroutine blha_interface_test

@ %def blha_interface_test
@
\section{OLP driver}

<<BLHA driver: public>>=
  public :: blha_test
<<BLHA driver: procedures>>=
  subroutine blha_test (model)
    class(model_data_t), pointer :: model
    type (blha_configuration_t) :: cfg
    logical :: ok
    call blha_config_test (model, cfg, ok)
    if (ok) call blha_interface_test (cfg, ok)
  end subroutine blha_test

@ %def blha_test
