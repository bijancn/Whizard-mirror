%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: event handling objects

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Generic Event Handling}

Event records allow the MC to communicate with the outside world.  The
event record should exhibit the observable contents of a physical
event.  We should be able to read and write events.  The actual
implementation of the event need not be defined yet, for that purpose.

We have the following basic modules:
\begin{description}
\item[event\_base]
  Abstract base type for event records.  The base type contains a
  reference to a [[particle_set_t]] object as the event core, and it
  holds some data that we should always expect, such as the squared
  matrix element and event weight.
\item[eio\_data]
  Transparent container for the metadata of an event sample.
\item[eio\_base]
  Abstract base type for event-record input and output.  The
  implementations of this base type represent specific event I/O
  formats.
\end{description}

These are the implementation modules:
\begin{description}
\item[eio\_checkpoints]
  Auxiliary output format.  The only purpose is to provide screen
  diagnostics during event output.
\item[eio\_weights]
  Print some event summary data, no details.  The main use if for
  testing purposes.
\item[hep\_common]
  Implements traditional HEP common blocks that are (still) used by
  some of the event I/O formats below.
\item[hep\_events]
  Interface between the event record and the common blocks.
\item[eio\_ascii]
  Collection of event output formats that write ASCII files.
\item[eio\_lhef]
  LHEF for input and output.
\item[eio\_stdhep]
  Support for the StdHEP format (binary, machine-independent).
\item[eio\_hepmc]
  Support for the HepMC format (C++).
\item[eio\_lcio]
  Support for the LCIO format (C++).
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generic Event Handling}
We introduce events first in form of an abstract type, together with
some utilities.  Abstract events can be used by other modules, in
particular event I/O, without introducing an explicit dependency on
the event implementation.
<<[[event_base.f90]]>>=
<<File header>>

module event_base
  
  use kinds
<<Use strings>>
  use string_utils, only: lower_case
  use diagnostics
  use model_data
  use particles

<<Standard module head>>

<<Event base: public>>

<<Event base: parameters>>

<<Event base: types>>

<<Event base: interfaces>>

contains
  
<<Event base: procedures>>

end module event_base
@ %def event_base
@
\subsection{generic event type}
<<Event base: public>>=
  public :: generic_event_t
<<Event base: types>>=
  type, abstract :: generic_event_t
     private
     logical :: particle_set_is_valid = .false.
     type(particle_set_t), pointer :: particle_set => null ()
     logical :: sqme_ref_known = .false.
     real(default) :: sqme_ref = 0
     logical :: sqme_prc_known = .false.
     real(default) :: sqme_prc = 0
     logical :: weight_ref_known = .false.
     real(default) :: weight_ref = 0
     logical :: weight_prc_known = .false.
     real(default) :: weight_prc = 0
     logical :: excess_prc_known = .false.
     real(default) :: excess_prc = 0
     integer :: n_alt = 0
     logical :: sqme_alt_known = .false.
     real(default), dimension(:), allocatable :: sqme_alt
     logical :: weight_alt_known = .false.
     real(default), dimension(:), allocatable :: weight_alt
   contains
   <<Event base: generic event: TBP>>
  end type generic_event_t
  
@ %def generic_event_t
@
\subsection{Initialization}
This determines the number of alternate weights and sqme values.
<<Event base: generic event: TBP>>=
  procedure :: base_init => generic_event_init
<<Event base: procedures>>=
  subroutine generic_event_init (event, n_alt)
    class(generic_event_t), intent(out) :: event
    integer, intent(in) :: n_alt
    event%n_alt = n_alt
    allocate (event%sqme_alt (n_alt))
    allocate (event%weight_alt (n_alt))
  end subroutine generic_event_init
  
@ %def generic_event_init
@
\subsection{Access particle set}
The particle set is the core of the event.  We allow access to it via
a pointer, and we maintain the information whether the particle set
is valid, i.e., has been filled with meaningful data.
<<Event base: generic event: TBP>>=
  procedure :: has_valid_particle_set => generic_event_has_valid_particle_set
  procedure :: accept_particle_set => generic_event_accept_particle_set
  procedure :: discard_particle_set => generic_event_discard_particle_set
<<Event base: procedures>>=
  function generic_event_has_valid_particle_set (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%particle_set_is_valid
  end function generic_event_has_valid_particle_set
  
  subroutine generic_event_accept_particle_set (event)
    class(generic_event_t), intent(inout) :: event
    event%particle_set_is_valid = .true.
  end subroutine generic_event_accept_particle_set
  
  subroutine generic_event_discard_particle_set (event)
    class(generic_event_t), intent(inout) :: event
    event%particle_set_is_valid = .false.
  end subroutine generic_event_discard_particle_set
  
@ %def generic_event_has_valid_particle_set
@ %def generic_event_accept_particle_set
@ %def generic_event_discard_particle_set
@ 
These procedures deal with the particle set directly.  Return the pointer:
<<Event base: generic event: TBP>>=
  procedure :: get_particle_set_ptr => generic_event_get_particle_set_ptr
<<Event base: procedures>>=
  function generic_event_get_particle_set_ptr (event) result (ptr)
    class(generic_event_t), intent(in) :: event
    type(particle_set_t), pointer :: ptr
    ptr => event%particle_set
  end function generic_event_get_particle_set_ptr
  
@ %def generic_event_get_particle_set_ptr
@ 
Let it point to some existing particle set:
<<Event base: generic event: TBP>>=
  procedure :: link_particle_set => generic_event_link_particle_set
<<Event base: procedures>>=
  subroutine generic_event_link_particle_set (event, particle_set)
    class(generic_event_t), intent(inout) :: event
    type(particle_set_t), intent(in), target :: particle_set
    event%particle_set => particle_set
    call event%accept_particle_set ()
  end subroutine generic_event_link_particle_set

@ %def generic_event_link_particle_set
@
\subsection{Access sqme and weight}
There are several incarnations: the current value, a reference value,
alternate values.
<<Event base: generic event: TBP>>=
  procedure :: sqme_prc_is_known => generic_event_sqme_prc_is_known
  procedure :: sqme_ref_is_known => generic_event_sqme_ref_is_known
  procedure :: sqme_alt_is_known => generic_event_sqme_alt_is_known
  procedure :: weight_prc_is_known => generic_event_weight_prc_is_known
  procedure :: weight_ref_is_known => generic_event_weight_ref_is_known
  procedure :: weight_alt_is_known => generic_event_weight_alt_is_known
  procedure :: excess_prc_is_known => generic_event_excess_prc_is_known
<<Event base: procedures>>=
  function generic_event_sqme_prc_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%sqme_prc_known
  end function generic_event_sqme_prc_is_known

  function generic_event_sqme_ref_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%sqme_ref_known
  end function generic_event_sqme_ref_is_known

  function generic_event_sqme_alt_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%sqme_alt_known
  end function generic_event_sqme_alt_is_known

  function generic_event_weight_prc_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%weight_prc_known
  end function generic_event_weight_prc_is_known

  function generic_event_weight_ref_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%weight_ref_known
  end function generic_event_weight_ref_is_known

  function generic_event_weight_alt_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%weight_alt_known
  end function generic_event_weight_alt_is_known

  function generic_event_excess_prc_is_known (event) result (flag)
    class(generic_event_t), intent(in) :: event
    logical :: flag
    flag = event%excess_prc_known
  end function generic_event_excess_prc_is_known

@ %def generic_event_sqme_prc_is_known
@ %def generic_event_sqme_ref_is_known
@ %def generic_event_sqme_alt_is_known
@ %def generic_event_weight_prc_is_known
@ %def generic_event_weight_ref_is_known
@ %def generic_event_weight_alt_is_known
@ %def generic_event_excess_prc_is_known
@
<<Event base: generic event: TBP>>=
  procedure :: get_n_alt => generic_event_get_n_alt
<<Event base: procedures>>=
  function generic_event_get_n_alt (event) result (n)
    class(generic_event_t), intent(in) :: event
    integer :: n
    n = event%n_alt
  end function generic_event_get_n_alt
  
@ %def generic_event_get_n_alt
@ 
<<Event base: generic event: TBP>>=
  procedure :: get_sqme_prc => generic_event_get_sqme_prc
  procedure :: get_sqme_ref => generic_event_get_sqme_ref
  generic :: get_sqme_alt => &
       generic_event_get_sqme_alt_0, generic_event_get_sqme_alt_1
  procedure :: generic_event_get_sqme_alt_0
  procedure :: generic_event_get_sqme_alt_1
  procedure :: get_weight_prc => generic_event_get_weight_prc
  procedure :: get_weight_ref => generic_event_get_weight_ref
  generic :: get_weight_alt => &
       generic_event_get_weight_alt_0, generic_event_get_weight_alt_1
  procedure :: generic_event_get_weight_alt_0
  procedure :: generic_event_get_weight_alt_1
  procedure :: get_excess_prc => generic_event_get_excess_prc
<<Event base: procedures>>=
  function generic_event_get_sqme_prc (event) result (sqme)
    class(generic_event_t), intent(in) :: event
    real(default) :: sqme
    if (event%sqme_prc_known) then
       sqme = event%sqme_prc
    else
       sqme = 0
    end if
  end function generic_event_get_sqme_prc

  function generic_event_get_sqme_ref (event) result (sqme)
    class(generic_event_t), intent(in) :: event
    real(default) :: sqme
    if (event%sqme_ref_known) then
       sqme = event%sqme_ref
    else
       sqme = 0
    end if
  end function generic_event_get_sqme_ref

  function generic_event_get_sqme_alt_0 (event, i) result (sqme)
    class(generic_event_t), intent(in) :: event
    integer, intent(in) :: i
    real(default) :: sqme
    if (event%sqme_alt_known) then
       sqme = event%sqme_alt(i)
    else
       sqme = 0
    end if
  end function generic_event_get_sqme_alt_0

  function generic_event_get_sqme_alt_1 (event) result (sqme)
    class(generic_event_t), intent(in) :: event
    real(default), dimension(event%n_alt) :: sqme
    sqme = event%sqme_alt
  end function generic_event_get_sqme_alt_1

  function generic_event_get_weight_prc (event) result (weight)
    class(generic_event_t), intent(in) :: event
    real(default) :: weight
    if (event%weight_prc_known) then
       weight = event%weight_prc
    else
       weight = 0
    end if
  end function generic_event_get_weight_prc

  function generic_event_get_weight_ref (event) result (weight)
    class(generic_event_t), intent(in) :: event
    real(default) :: weight
    if (event%weight_ref_known) then
       weight = event%weight_ref
    else
       weight = 0
    end if
  end function generic_event_get_weight_ref

  function generic_event_get_weight_alt_0 (event, i) result (weight)
    class(generic_event_t), intent(in) :: event
    integer, intent(in) :: i
    real(default) :: weight
    if (event%weight_alt_known) then
       weight = event%weight_alt(i)
    else
       weight = 0
    end if
  end function generic_event_get_weight_alt_0

  function generic_event_get_weight_alt_1 (event) result (weight)
    class(generic_event_t), intent(in) :: event
    real(default), dimension(event%n_alt) :: weight
    weight = event%weight_alt
  end function generic_event_get_weight_alt_1

  function generic_event_get_excess_prc (event) result (excess)
    class(generic_event_t), intent(in) :: event
    real(default) :: excess
    if (event%excess_prc_known) then
       excess = event%excess_prc
    else
       excess = 0
    end if
  end function generic_event_get_excess_prc

@ %def generic_event_get_sqme_prc
@ %def generic_event_get_sqme_ref
@ %def generic_event_get_sqme_alt
@ %def generic_event_get_weight_prc
@ %def generic_event_get_weight_ref
@ %def generic_event_get_weight_alt
@ %def generic_event_get_excess_prc
@
<<Event base: generic event: TBP>>=
  procedure :: set_sqme_prc => generic_event_set_sqme_prc
  procedure :: set_sqme_ref => generic_event_set_sqme_ref
  procedure :: set_sqme_alt => generic_event_set_sqme_alt
  procedure :: set_weight_prc => generic_event_set_weight_prc
  procedure :: set_weight_ref => generic_event_set_weight_ref
  procedure :: set_weight_alt => generic_event_set_weight_alt
  procedure :: set_excess_prc => generic_event_set_excess_prc
<<Event base: procedures>>=
  subroutine generic_event_set_sqme_prc (event, sqme)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in) :: sqme
    event%sqme_prc = sqme
    event%sqme_prc_known = .true.
  end subroutine generic_event_set_sqme_prc

  subroutine generic_event_set_sqme_ref (event, sqme)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in) :: sqme
    event%sqme_ref = sqme
    event%sqme_ref_known = .true.
  end subroutine generic_event_set_sqme_ref

  subroutine generic_event_set_sqme_alt (event, sqme)
    class(generic_event_t), intent(inout) :: event
    real(default), dimension(:), intent(in) :: sqme
    event%sqme_alt = sqme
    event%sqme_alt_known = .true.
  end subroutine generic_event_set_sqme_alt

  subroutine generic_event_set_weight_prc (event, weight)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in) :: weight
    event%weight_prc = weight
    event%weight_prc_known = .true.
  end subroutine generic_event_set_weight_prc

  subroutine generic_event_set_weight_ref (event, weight)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in) :: weight
    event%weight_ref = weight
    event%weight_ref_known = .true.
  end subroutine generic_event_set_weight_ref

  subroutine generic_event_set_weight_alt (event, weight)
    class(generic_event_t), intent(inout) :: event
    real(default), dimension(:), intent(in) :: weight
    event%weight_alt = weight
    event%weight_alt_known = .true.
  end subroutine generic_event_set_weight_alt

  subroutine generic_event_set_excess_prc (event, excess)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in) :: excess
    event%excess_prc = excess
    event%excess_prc_known = .true.
  end subroutine generic_event_set_excess_prc

@ %def generic_event_set_sqme_prc
@ %def generic_event_set_sqme_ref
@ %def generic_event_set_sqme_alt
@ %def generic_event_set_weight_prc
@ %def generic_event_set_weight_ref
@ %def generic_event_set_weight_alt
@ %def generic_event_set_excess_prc
@
Set the appropriate entry directly.
<<Event base: generic event: TBP>>=
  procedure :: set => generic_event_set
<<Event base: procedures>>=
  subroutine generic_event_set (event, &
       weight_ref, weight_prc, weight_alt, &
       excess_prc, &
       sqme_ref, sqme_prc, sqme_alt)
    class(generic_event_t), intent(inout) :: event
    real(default), intent(in), optional :: weight_ref, weight_prc
    real(default), intent(in), optional :: sqme_ref, sqme_prc
    real(default), dimension(:), intent(in), optional :: sqme_alt, weight_alt
    real(default), intent(in), optional :: excess_prc
    if (present (sqme_prc)) then
       call event%set_sqme_prc (sqme_prc)
    end if
    if (present (sqme_ref)) then
       call event%set_sqme_ref (sqme_ref)
    end if 
    if (present (sqme_alt)) then
       call event%set_sqme_alt (sqme_alt)
    end if
    if (present (weight_prc)) then
       call event%set_weight_prc (weight_prc)
    end if
    if (present (weight_ref)) then
       call event%set_weight_ref (weight_ref)
    end if
    if (present (weight_alt)) then
       call event%set_weight_alt (weight_alt)
    end if
    if (present (excess_prc)) then
       call event%set_excess_prc (excess_prc)
    end if
  end subroutine generic_event_set
  
@ %def generic_event_set
@
\subsection{Pure Virtual Methods}
These procedures can only implemented in the concrete implementation.

Output (verbose, depending on parameters).
<<Event base: generic event: TBP>>=
  procedure (generic_event_write), deferred :: write
<<Event base: interfaces>>=
  abstract interface
     subroutine generic_event_write (object, unit, &
          show_process, show_transforms, &
          show_decay, verbose, testflag)
       import
       class(generic_event_t), intent(in) :: object
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: show_process
       logical, intent(in), optional :: show_transforms
       logical, intent(in), optional :: show_decay
       logical, intent(in), optional :: verbose
       logical, intent(in), optional :: testflag
     end subroutine generic_event_write
  end interface

@ %def generic_event_write
@
Generate an event, based on a selector index [[i_mci]], and optionally on an
extra set of random numbers [[r]].  For the main bunch of random numbers that
the generator needs, the event object should contain its own generator.
<<Event base: generic event: TBP>>=
  procedure (generic_event_generate), deferred :: generate
<<Event base: interfaces>>=
  abstract interface
     subroutine generic_event_generate (event, i_mci, r)
       import
       class(generic_event_t), intent(inout) :: event
       integer, intent(in) :: i_mci
       real(default), dimension(:), intent(in), optional :: r
     end subroutine generic_event_generate
  end interface
     
@ %def event_generate
@
Alternative : inject a particle set that is supposed to represent the hard
process. 
How this determines the event, is dependent on the event structure,
therefore this is a deferred method.
<<Event base: generic event: TBP>>=
  procedure (generic_event_set_hard_particle_set), deferred :: &
       set_hard_particle_set 
<<Event base: interfaces>>=
  abstract interface
     subroutine generic_event_set_hard_particle_set (event, particle_set)
       import
       class(generic_event_t), intent(inout) :: event
       type(particle_set_t), intent(in) :: particle_set
     end subroutine generic_event_set_hard_particle_set
  end interface

@ %def generic_event_set_hard_particle_set
@ Evaluate any expressions associated with the event.  No argument needed.
<<Event base: generic event: TBP>>=
  procedure (generic_event_handler), deferred :: evaluate_expressions
<<Event base: interfaces>>=
  abstract interface
     subroutine generic_event_handler (event)
       import
       class(generic_event_t), intent(inout) :: event
     end subroutine generic_event_handler
  end interface
  
@ %def generic_event_handler
@
Select internal parameters
<<Event base: generic event: TBP>>=
  procedure (generic_event_select), deferred :: select
<<Event base: interfaces>>=
  abstract interface
     subroutine generic_event_select (event,  i_mci, i_term, channel)
       import
       class(generic_event_t), intent(inout) :: event
       integer, intent(in) :: i_mci, i_term, channel
     end subroutine generic_event_select
  end interface
  
@ %def generic_event_select
@ Return a pointer to the model for the currently active process.
<<Event base: generic event: TBP>>=
  procedure (generic_event_get_model_ptr), deferred :: get_model_ptr
<<Event base: interfaces>>=
  abstract interface
     function generic_event_get_model_ptr (event) result (model)
       import
       class(generic_event_t), intent(in) :: event
       class(model_data_t), pointer :: model
     end function generic_event_get_model_ptr
  end interface
  
@ %def generic_event_get_model_ptr
@ Return data used by external event formats.
<<Event base: generic event: TBP>>=
  procedure (generic_event_get_index), deferred :: get_index
  procedure (generic_event_get_fac_scale), deferred :: get_fac_scale
  procedure (generic_event_get_alpha_s), deferred :: get_alpha_s
<<Event base: interfaces>>=
  abstract interface
     function generic_event_get_index (event) result (index)
       import
       class(generic_event_t), intent(in) :: event
       integer :: index
     end function generic_event_get_index
  end interface
    
  abstract interface
     function generic_event_get_fac_scale (event) result (fac_scale)
       import
       class(generic_event_t), intent(in) :: event
       real(default) :: fac_scale
     end function generic_event_get_fac_scale
  end interface
    
  abstract interface
     function generic_event_get_alpha_s (event) result (alpha_s)
       import
       class(generic_event_t), intent(in) :: event
       real(default) :: alpha_s
     end function generic_event_get_alpha_s
  end interface

@ %def generic_event_get_index
@ %def generic_event_get_fac_scale
@ %def generic_event_get_alpha_s
@
\subsection{Utilities}
Applying this, current event contents are marked as incomplete but
are not deleted.  In particular, the initialization is kept.
<<Event base: generic event: TBP>>=
  procedure :: reset => generic_event_reset
  procedure :: base_reset => generic_event_reset
<<Event base: procedures>>=
  subroutine generic_event_reset (event)
    class(generic_event_t), intent(inout) :: event
    call event%discard_particle_set ()
    event%sqme_ref_known = .false.
    event%sqme_prc_known = .false.
    event%sqme_alt_known = .false.
    event%weight_ref_known = .false.
    event%weight_prc_known = .false.
    event%weight_alt_known = .false.
    event%excess_prc_known = .false.
  end subroutine generic_event_reset
  
@ %def generic_event_reset
@ Pacify particle set.
<<Event base: generic event: TBP>>=
  procedure :: pacify_particle_set => generic_event_pacify_particle_set
<<Event base: procedures>>=
  subroutine generic_event_pacify_particle_set (event)
    class(generic_event_t), intent(inout) :: event
    if (event%has_valid_particle_set ())  call pacify (event%particle_set)
  end subroutine generic_event_pacify_particle_set

@ %def generic_event_pacify_particle_set
@
\subsection{Event normalization}
The parameters for event normalization.  For unweighted events,
[[NORM_UNIT]] is intended as default, while for weighted events, it is
[[NORM_SIGMA]].

Note: the unit test for this is in [[eio_data_2]] below.
<<Event base: parameters>>=
  integer, parameter, public :: NORM_UNDEFINED = 0
  integer, parameter, public :: NORM_UNIT = 1
  integer, parameter, public :: NORM_N_EVT = 2
  integer, parameter, public :: NORM_SIGMA = 3
  integer, parameter, public :: NORM_S_N = 4

@ %def NORM_UNDEFINED NORM_UNIT NORM_N_EVT NORM_SIGMA NORM_S_N
@ These functions translate between the user representation and the
internal one.
<<Event base: public>>=
  public :: event_normalization_mode
  public :: event_normalization_string
<<Event base: procedures>>=
  function event_normalization_mode (string, unweighted) result (mode)
    integer :: mode
    type(string_t), intent(in) :: string
    logical, intent(in) :: unweighted
    select case (lower_case (char (string)))
    case ("auto")
       if (unweighted) then
          mode = NORM_UNIT
       else
          mode = NORM_SIGMA
       end if
    case ("1")
       mode = NORM_UNIT
    case ("1/n")
       mode = NORM_N_EVT
    case ("sigma")
       mode = NORM_SIGMA
    case ("sigma/n")
       mode = NORM_S_N
    case default
       call msg_fatal ("Event normalization: unknown value '" &
            // char (string) // "'")
    end select
  end function event_normalization_mode
  
  function event_normalization_string (norm_mode) result (string)
    integer, intent(in) :: norm_mode
    type(string_t) :: string
    select case (norm_mode)
    case (NORM_UNDEFINED); string = "[undefined]"
    case (NORM_UNIT);      string = "'1'"
    case (NORM_N_EVT);     string = "'1/n'"
    case (NORM_SIGMA);     string = "'sigma'"
    case (NORM_S_N);       string = "'sigma/n'"
    case default;          string = "???"
    end select
  end function event_normalization_string
  
@ %def event_normalization_mode
@ %def event_normalization_string
@ We place this here as a generic helper, so we can update event
weights whenever we need, not just in connection with an event sample
data object.
<<Event base: public>>=
  public :: event_normalization_update
<<Event base: procedures>>=
  subroutine event_normalization_update (weight, sigma, n, mode_new, mode_old)
    real(default), intent(inout) :: weight
    real(default), intent(in) :: sigma
    integer, intent(in) :: n
    integer, intent(in) :: mode_new, mode_old
    if (mode_new /= mode_old) then
       if (sigma > 0 .and. n > 0) then
          weight = weight / factor (mode_old) * factor (mode_new)
       else
          call msg_fatal ("Event normalization update: null sample")
       end if
    end if
  contains
    function factor (mode)
      real(default) :: factor
      integer, intent(in) :: mode
      select case (mode)
      case (NORM_UNIT);   factor = 1._default
      case (NORM_N_EVT);  factor = 1._default / n
      case (NORM_SIGMA);  factor = sigma
      case (NORM_S_N);    factor = sigma / n
      case default
         call msg_fatal ("Event normalization update: undefined mode")
      end select
    end function factor
  end subroutine event_normalization_update
  
@ %def event_normalization_update
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Sample Data}
We define a simple and transparent container for (meta)data that are
associated with an event sample.
<<[[eio_data.f90]]>>=
<<File header>>

module eio_data
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use event_base

<<Standard module head>>

<<EIO data: public>>

<<EIO data: types>>

contains
  
<<EIO data: procedures>>

<<EIO data: tests>>

end module eio_data
@ %def eio_data
@
\subsection{Event Sample Data}
These are data that apply to an event sample as a whole.  They are
given in an easily portable form (no fancy structure) and are used for
initializing event formats.

There are two MD5 sums here.  [[md5sum_proc]] depends only on the
definition of the contributing processes.  A sample with matching
checksum can be rescanned with modified model parameters, beam
structure etc, to recalculate observables.  [[md5sum_config]] includes
all relevant data.  Rescanning a sample with matching checksum will
produce identical observables.  (A third checksum might be added which
depends on the event sample itself.  This is not needed, so far.)

If alternate weights are part of the event sample ([[n_alt]] nonzero),
there is a configuration MD5 sum for each of them.
<<EIO data: public>>=
  public :: event_sample_data_t
<<EIO data: types>>=
  type :: event_sample_data_t
     character(32) :: md5sum_prc = ""
     character(32) :: md5sum_cfg = ""
     logical :: unweighted = .true.
     logical :: negative_weights = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: n_beam = 0
     integer, dimension(2) :: pdg_beam = 0
     real(default), dimension(2) :: energy_beam = 0
     integer :: n_proc = 0
     integer :: n_evt = 0
     integer :: split_n_evt = 0
     integer :: split_index = 0
     real(default) :: total_cross_section = 0
     integer, dimension(:), allocatable :: proc_num_id
     integer :: n_alt = 0
     character(32), dimension(:), allocatable :: md5sum_alt
     real(default), dimension(:), allocatable :: cross_section
     real(default), dimension(:), allocatable :: error
   contains
   <<EIO data: event sample data: TBP>>
  end type event_sample_data_t
  
@ %def event_sample_data_t
@ Initialize: allocate for the number of processes
<<EIO data: event sample data: TBP>>=
  procedure :: init => event_sample_data_init
<<EIO data: procedures>>=
  subroutine event_sample_data_init (data, n_proc, n_alt)
    class(event_sample_data_t), intent(out) :: data
    integer, intent(in) :: n_proc
    integer, intent(in), optional :: n_alt
    data%n_proc = n_proc
    allocate (data%proc_num_id (n_proc), source = 0)
    allocate (data%cross_section (n_proc), source = 0._default)
    allocate (data%error (n_proc), source = 0._default)
    if (present (n_alt)) then
       data%n_alt = n_alt
       allocate (data%md5sum_alt (n_alt))
       data%md5sum_alt = ""
    end if
  end subroutine event_sample_data_init
  
@ %def event_sample_data_init
@ Output.
<<EIO data: event sample data: TBP>>=
  procedure :: write => event_sample_data_write
<<EIO data: procedures>>=
  subroutine event_sample_data_write (data, unit)
    class(event_sample_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event sample properties:"
    write (u, "(3x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(3x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    write (u, "(3x,A,L1)")  "unweighted       = ", data%unweighted
    write (u, "(3x,A,L1)")  "negative weights = ", data%negative_weights
    write (u, "(3x,A,A)")   "normalization    = ", &
         char (event_normalization_string (data%norm_mode))
    write (u, "(3x,A,I0)")  "number of beams  = ", data%n_beam
    write (u, "(5x,A,2(1x,I19))")  "PDG    = ", &
         data%pdg_beam(:data%n_beam)
    write (u, "(5x,A,2(1x,ES19.12))")  "Energy = ", &
         data%energy_beam(:data%n_beam)
    if (data%n_evt > 0) then
       write (u, "(3x,A,I0)")  "number of events = ", data%n_evt
    end if
    if (data%total_cross_section /= 0) then
       write (u, "(3x,A,ES19.12)")  "total cross sec. = ", &
            data%total_cross_section
    end if
    write (u, "(3x,A,I0)")  "num of processes = ", data%n_proc
    do i = 1, data%n_proc
       write (u, "(3x,A,I0)")  "Process #", data%proc_num_id (i)
       select case (data%n_beam)
       case (1)
          write (u, "(5x,A,ES19.12)")  "Width = ", data%cross_section(i)
       case (2)
          write (u, "(5x,A,ES19.12)")  "CSec  = ", data%cross_section(i)
       end select
       write (u, "(5x,A,ES19.12)")  "Error = ", data%error(i)
    end do
    if (data%n_alt > 0) then
       write (u, "(3x,A,I0)")  "num of alt wgt   = ", data%n_alt
       do i = 1, data%n_alt
          write (u, "(5x,A,A,A,1x,I0)")  "MD5 sum (cfg)  = '", &
               data%md5sum_alt(i), "'", i
       end do
    end if
  end subroutine event_sample_data_write
    
@ %def event_sample_data_write
@
\subsection{Unit tests}
<<EIO data: public>>=
  public :: eio_data_test
<<EIO data: tests>>=
  subroutine eio_data_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO data: execute tests>>
  end subroutine eio_data_test
  
@ %def eio_data_test 
@
\subsubsection{Event Sample Data}
Print the contents of a sample data block.
<<EIO data: execute tests>>=
  call test (eio_data_1, "eio_data_1", &
       "event sample data", &
       u, results)
<<EIO data: tests>>=
  subroutine eio_data_1 (u)
    integer, intent(in) :: u
    type(event_sample_data_t) :: data

    write (u, "(A)")  "* Test output: eio_data_1"
    write (u, "(A)")  "*   Purpose:  display event sample data"
    write (u, "(A)")

    write (u, "(A)")  "* Decay process, one component"
    write (u, "(A)")
 
    call data%init (1, 1)
    data%n_beam = 1
    data%pdg_beam(1) = 25
    data%energy_beam(1) = 125

    data%norm_mode = NORM_UNIT
    
    data%proc_num_id = [42]
    data%cross_section = [1.23e-4_default]
    data%error = 5e-6_default
    
    data%md5sum_prc = "abcdefghijklmnopabcdefghijklmnop"
    data%md5sum_cfg = "12345678901234561234567890123456"
    data%md5sum_alt(1) = "uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu"
    
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Scattering process, two components"
    write (u, "(A)")
    
    call data%init (2)
    data%n_beam = 2
    data%pdg_beam = [2212, -2212]
    data%energy_beam = [8._default, 10._default]
    
    data%norm_mode = NORM_SIGMA
    
    data%proc_num_id = [12, 34]
    data%cross_section = [100._default, 88._default]
    data%error = [1._default, 0.1_default]
    
    call data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_data_1"
    
  end subroutine eio_data_1
  
@ %def eio_data_1
@
\subsubsection{Event Normalization}
Check the functions for translating modes and updating weights.
<<EIO data: execute tests>>=
  call test (eio_data_2, "eio_data_2", &
       "event normalization", &
       u, results)
<<EIO data: tests>>=
  subroutine eio_data_2 (u)
    integer, intent(in) :: u
    type(string_t) :: s
    logical :: unweighted
    real(default) :: w, w0, sigma
    integer :: n

    write (u, "(A)")  "* Test output: eio_data_2"
    write (u, "(A)")  "*   Purpose:  handle event normalization"
    write (u, "(A)")

    write (u, "(A)")  "* Normalization strings"
    write (u, "(A)")

    s = "auto"
    unweighted = .true.
    write (u, "(1x,A,1x,L1,1x,A)")  char (s), unweighted, &
         char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "AUTO"
    unweighted = .false.
    write (u, "(1x,A,1x,L1,1x,A)")  char (s), unweighted, &
         char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))

    unweighted = .true.
    
    s = "1"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "1/n"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "Sigma"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))
    s = "sigma/N"
    write (u, "(2(1x,A))") char (s), char (event_normalization_string &
         (event_normalization_mode (s, unweighted)))

    write (u, "(A)")
    write (u, "(A)")  "* Normalization update"
    write (u, "(A)")
    
    sigma = 5
    n = 2

    w0 = 1

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_UNIT)
    write (u, "(2(F6.3))")  w0, w

    write (u, *)
    
    w0 = 0.5

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_N_EVT)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, *)
    
    w0 = 5.0

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_SIGMA)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, *)
    
    w0 = 2.5

    w = w0
    call event_normalization_update (w, sigma, n, NORM_UNIT, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_N_EVT, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_SIGMA, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    w = w0
    call event_normalization_update (w, sigma, n, NORM_S_N, NORM_S_N)
    write (u, "(2(F6.3))")  w0, w
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_data_2"
    
  end subroutine eio_data_2
  
@ %def eio_data_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract I/O Handler}

This module defines an abstract object for event I/O and the
associated methods.  

There are [[output]] and [[input]] methods which
write or read a single event from/to the I/O stream, respectively.
The I/O stream itself may be a file, a common block, or an externally
linked structure, depending on the concrete implementation.

A [[write]] method prints the current content of the
implementation-dependent event record in human-readable form.

The [[init_in]]/[[init_out]] and [[final]] prepare
and finalize the I/O stream, respectively.  There is also a
[[switch_inout]] method which turns an input stream into an output
stream where events can be appended.

Optionally, output files can be split in chunks of well-defined size.  The
[[split_out]] method takes care of this.
<<[[eio_base.f90]]>>=
<<File header>>

module eio_base
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics
  use lorentz
  use model_data
  use particles
  use event_base
  use eio_data

<<Standard module head>>

<<EIO base: public>>

<<EIO base: types>>

<<EIO base: interfaces>>

<<EIO base: test types>>

contains
  
<<EIO base: procedures>>

<<EIO base: tests>>

end module eio_base
@ %def eio_base
@
\subsection{Type}
We can assume that most implementations will need the file extension as a
fixed string and, if they support file splitting, the current file index.

The fallback model is useful for implementations that are able to read
unknown files which may contain hadrons etc., not in the current
hard-interaction model.
<<EIO base: public>>=
  public :: eio_t
<<EIO base: types>>=
  type, abstract :: eio_t
     type(string_t) :: sample
     type(string_t) :: extension
     type(string_t) :: filename
     logical :: split = .false.
     integer :: split_n_evt = 0
     integer :: split_index = 0
     class(model_data_t), pointer :: fallback_model => null ()
   contains
   <<EIO base: eio: TBP>>
  end type eio_t
  
@ %def eio_t
@ Write to screen.  If possible, this should display the contents of the
current event, i.e., the last one that was written or read.
<<EIO base: eio: TBP>>=
  procedure (eio_write), deferred :: write
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_write (object, unit)
       import
       class(eio_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine eio_write
  end interface
  
@ %def eio_write
@ Finalize.  This should write/read footer data and close input/output
channels.
<<EIO base: eio: TBP>>=
  procedure (eio_final), deferred :: final
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_final (object)
       import
       class(eio_t), intent(inout) :: object
     end subroutine eio_final
  end interface
  
@ %def eio_final
@ Determine splitting parameters from the event sample data.
<<EIO base: eio: TBP>>=
  procedure :: set_splitting => eio_set_splitting
<<EIO base: procedures>>=
  subroutine eio_set_splitting (eio, data)
    class(eio_t), intent(inout) :: eio
    type(event_sample_data_t), intent(in) :: data
    eio%split = data%split_n_evt > 0
    if (eio%split) then
       eio%split_n_evt = data%split_n_evt
       eio%split_index = data%split_index
    end if
  end subroutine eio_set_splitting
    
@ %def eio_set_splitting
@ Generate a filename, taking a possible split index into account.
<<EIO base: eio: TBP>>=
  procedure :: set_filename => eio_set_filename
<<EIO base: procedures>>=
  subroutine eio_set_filename (eio)
    class(eio_t), intent(inout) :: eio
    character(32) :: buffer
    if (eio%split) then
       write (buffer, "(I0,'.')")  eio%split_index
       eio%filename = eio%sample // "." // trim (buffer) // eio%extension
    else
       eio%filename = eio%sample // "." // eio%extension
    end if
  end subroutine eio_set_filename

@ %def eio_set_filename
@ Set the fallback model.
<<EIO base: eio: TBP>>=
  procedure :: set_fallback_model => eio_set_fallback_model
<<EIO base: procedures>>=
  subroutine eio_set_fallback_model (eio, model)
    class(eio_t), intent(inout) :: eio
    class(model_data_t), intent(in), target :: model
    eio%fallback_model => model
  end subroutine eio_set_fallback_model
  
@ %def eio_set_fallback_model
@ Initialize for output.  We provide process names.  This should
open an event file if appropriate and write header data.  Some methods
may require event sample data.
<<EIO base: eio: TBP>>=
  procedure (eio_init_out), deferred :: init_out
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_init_out (eio, sample, data, success, extension)
       import
       class(eio_t), intent(inout) :: eio
       type(string_t), intent(in) :: sample
       type(event_sample_data_t), intent(in), optional :: data
       logical, intent(out), optional :: success
       type(string_t), intent(in), optional :: extension       
     end subroutine eio_init_out
  end interface

@ %def eio_init_out
@ Initialize for input.  We provide process names.  This should open an event
file if appropriate and read header data.  The [[md5sum]] can be used to check
the integrity of the configuration, it it provides a checksum to compare with.
In case the extension has changed the extension is also given as an argument.

The [[data]] argument is [[intent(inout)]]: we may read part of it and
keep other parts and/or check them against the data in the file.
<<EIO base: eio: TBP>>=
  procedure (eio_init_in), deferred :: init_in
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_init_in (eio, sample, data, success, extension)
       import
       class(eio_t), intent(inout) :: eio
       type(string_t), intent(in) :: sample
       type(event_sample_data_t), intent(inout), optional :: data
       logical, intent(out), optional :: success
       type(string_t), intent(in), optional :: extension
     end subroutine eio_init_in
  end interface

@ %def eio_init_in
@ Re-initialize for output.  This should change the status of any event file
from input to output and position it for appending new events.
<<EIO base: eio: TBP>>=
  procedure (eio_switch_inout), deferred :: switch_inout
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_switch_inout (eio, success)
       import
       class(eio_t), intent(inout) :: eio
       logical, intent(out), optional :: success
     end subroutine eio_switch_inout
  end interface

@ %def eio_switch_inout
@ This is similar: split the output, i.e., close the current file and open a
new one.  The default implementation does nothing.  For the feature to work,
an implementation must override this.
<<EIO base: eio: TBP>>=
  procedure :: split_out => eio_split_out
<<EIO base: procedures>>=
  subroutine eio_split_out (eio)
    class(eio_t), intent(inout) :: eio
  end subroutine eio_split_out

@ %def eio_split_out
@ 
@ Output an event.  All data can be taken from the [[event]] record.
The index [[i_prc]] identifies the process among the processes that
are contained in the current sample.  The [[reading]] flag, if present,
indicates that the event was read from file, not generated.
<<EIO base: eio: TBP>>=
  procedure (eio_output), deferred :: output
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_output (eio, event, i_prc, reading, pacify)
       import
       class(eio_t), intent(inout) :: eio
       class(generic_event_t), intent(in), target :: event
       integer, intent(in) :: i_prc
       logical, intent(in), optional :: reading, pacify
     end subroutine eio_output
  end interface
  
@ %def eio_output
@ Input an event.  This should fill all event data that cannot be inferred
from the associated process.

The input is broken down into two parts.  First we read the [[i_prc]]
index.  So we know which process to expect in the subsequent event.
If we have reached end of file, we also will know.
Then, we read the event itself.

The parameter [[iostat]] is supposed to be set as the Fortran standard
requires, negative for EOF and positive for error.
<<EIO base: eio: TBP>>=
  procedure (eio_input_i_prc), deferred :: input_i_prc
  procedure (eio_input_event), deferred :: input_event
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_input_i_prc (eio, i_prc, iostat)
       import
       class(eio_t), intent(inout) :: eio
       integer, intent(out) :: i_prc
       integer, intent(out) :: iostat
     end subroutine eio_input_i_prc
  end interface
  
  abstract interface
     subroutine eio_input_event (eio, event, iostat)
       import
       class(eio_t), intent(inout) :: eio
       class(generic_event_t), intent(inout), target :: event
       integer, intent(out) :: iostat
     end subroutine eio_input_event
  end interface
  
@ %def eio_input
@
\subsection{Unit tests}
<<EIO base: public>>=
  public :: eio_base_test
<<EIO base: tests>>=
  subroutine eio_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO base: execute tests>>
  end subroutine eio_base_test
  
@ %def eio_base_test 
@ The caller has to provide procedures that prepare and cleanup the test
environment.  They depend on modules that are not available here.
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_prepare_event (event, unweighted, n_alt)
       import
       class(generic_event_t), intent(inout), pointer :: event
       logical, intent(in), optional :: unweighted
       integer, intent(in), optional :: n_alt
     end subroutine eio_prepare_event
  end interface
  
  abstract interface
     subroutine eio_cleanup_event (event)
       import
       class(generic_event_t), intent(inout), pointer :: event
     end subroutine eio_cleanup_event
  end interface
  
@ We store pointers to the test-environment handlers as module variables.
This allows us to call them from the test routines themselves, which don't
allow for extra arguments.
<<EIO base: public>>=
  public :: eio_prepare_test, eio_cleanup_test
<<EIO base: test types>>=
  procedure(eio_prepare_event), pointer :: eio_prepare_test => null ()
  procedure(eio_cleanup_event), pointer :: eio_cleanup_test => null ()
  
@ %def eio_prepare_test eio_cleanup_test
@ Similarly, for the fallback (hadron) model that some eio tests require:
<<EIO base: interfaces>>=
  abstract interface
     subroutine eio_prepare_model (model)
       import
       class(model_data_t), intent(inout), pointer :: model
     end subroutine eio_prepare_model
  end interface
  
  abstract interface
     subroutine eio_cleanup_model (model)
       import
       class(model_data_t), intent(inout), pointer :: model
     end subroutine eio_cleanup_model
  end interface
  
<<EIO base: public>>=
  public :: eio_prepare_fallback_model, eio_cleanup_fallback_model
<<EIO base: test types>>=
  procedure(eio_prepare_model), pointer :: eio_prepare_fallback_model => null ()
  procedure(eio_cleanup_model), pointer :: eio_cleanup_fallback_model => null ()
  
@ %def eio_prepare_fallback_model eio_cleanup_fallback_model
@ 
\subsubsection{Test type for event I/O}
The contents simulate the contents of an external file.  We have the
[[sample]] string as the file name and the array of momenta
[[event_p]] as the list of events.  The 
second index is the event index.  The [[event_i]] component is the pointer
to the current event, [[event_n]] is the total number of stored events.
<<EIO base: test types>>=
  type, extends (eio_t) :: eio_test_t
     integer :: event_n = 0
     integer :: event_i = 0
     integer :: i_prc = 0
     type(vector4_t), dimension(:,:), allocatable :: event_p
   contains
   <<EIO base: eio test: TBP>>
  end type eio_test_t

@ %def eio_test_t
@ Write to screen.  Pretend that this is an actual event format.
<<EIO base: eio test: TBP>>=
  procedure :: write => eio_test_write
<<EIO base: procedures>>=
  subroutine eio_test_write (object, unit)
    class(eio_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Test event stream"
    if (object%event_i /= 0) then
       write (u, "(1x,A,I0,A)")  "Event #", object%event_i, ":"
       do i = 1, size (object%event_p, 1)
          call vector4_write (object%event_p(i, object%event_i), u)
       end do
    end if
  end subroutine eio_test_write
    
@ %def eio_test_write
@ Finalizer.  For the test case, we just reset the event count,
but keep the stored ``events''.  For the real implementations, the events
would be stored on an external medium, so we would delete the object
contents.
<<EIO base: eio test: TBP>>=
  procedure :: final => eio_test_final
<<EIO base: procedures>>=
  subroutine eio_test_final (object)
    class(eio_test_t), intent(inout) :: object
    object%event_i = 0
  end subroutine eio_test_final
    
@ %def eio_test_final
@ Initialization: We store the process IDs and the energy from the beam-data
object.  We also allocate the momenta (i.e., the simulated event record) for a
fixed maximum size of 10 events, 2 momenta each.  There is only a single
process.
<<EIO base: eio test: TBP>>=
  procedure :: init_out => eio_test_init_out
<<EIO base: procedures>>=
  subroutine eio_test_init_out (eio, sample, data, success, extension)
    class(eio_test_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    eio%sample = sample
    eio%event_n = 0
    eio%event_i = 0
    allocate (eio%event_p (2, 10))
    if (present (success))  success = .true.
  end subroutine eio_test_init_out
  
@ %def eio_test_init_out
@ Initialization for input.  Nothing to do for the test type.
<<EIO base: eio test: TBP>>=
  procedure :: init_in => eio_test_init_in
<<EIO base: procedures>>=
  subroutine eio_test_init_in (eio, sample, data, success, extension)
    class(eio_test_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    if (present (success))  success = .true.
  end subroutine eio_test_init_in
  
@ %def eio_test_init_in
@ Switch from output to input.  Again, nothing to do for the test type.
<<EIO base: eio test: TBP>>=
  procedure :: switch_inout => eio_test_switch_inout
<<EIO base: procedures>>=
  subroutine eio_test_switch_inout (eio, success)
    class(eio_test_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    if (present (success))  success = .true.
  end subroutine eio_test_switch_inout
  
@ %def eio_test_switch_inout
@ Output.  Increment the event counter and store the momenta of the current
event.
<<EIO base: eio test: TBP>>=
  procedure :: output => eio_test_output
<<EIO base: procedures>>=
  subroutine eio_test_output (eio, event, i_prc, reading, pacify)
    class(eio_test_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    logical, intent(in), optional :: reading, pacify
    integer, intent(in) :: i_prc
    type(particle_set_t), pointer :: pset
    type(particle_t) :: prt
    eio%event_n = eio%event_n + 1
    eio%event_i = eio%event_n
    eio%i_prc = i_prc
    pset => event%get_particle_set_ptr ()
    prt = particle_set_get_particle (pset, 3)
    eio%event_p(1, eio%event_i) = particle_get_momentum (prt)
    prt = particle_set_get_particle (pset, 4)
    eio%event_p(2, eio%event_i) = particle_get_momentum (prt)
  end subroutine eio_test_output

@ %def eio_test_output
@ Input.  Increment the event counter and retrieve the momenta of the current
event.  For the test case, we do not actually modify the current event.
<<EIO base: eio test: TBP>>=
  procedure :: input_i_prc => eio_test_input_i_prc
  procedure :: input_event => eio_test_input_event
<<EIO base: procedures>>=
  subroutine eio_test_input_i_prc (eio, i_prc, iostat)
    class(eio_test_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    i_prc = eio%i_prc
    iostat = 0
  end subroutine eio_test_input_i_prc

  subroutine eio_test_input_event (eio, event, iostat)
    class(eio_test_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    eio%event_i = eio%event_i + 1
    iostat = 0
  end subroutine eio_test_input_event

@ %def eio_test_input_i_prc
@ %def eio_test_input_event
@
\subsubsection{Test I/O methods}
<<EIO base: execute tests>>=
  call test (eio_base_1, "eio_base_1", &
       "read and write event contents", &
       u, results)
<<EIO base: tests>>=
  subroutine eio_base_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    class(eio_t), allocatable :: eio
    integer :: i_prc,  iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_base_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"

    call eio_prepare_test (event, unweighted = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_test1"
 
    allocate (eio_test_t :: eio)
    
    call eio%init_out (sample)
    call event%generate (1, [0._default, 0._default])
    call eio%output (event, 42)
    call eio%write (u)
    call eio%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample)
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%write (u)
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i = ", i_prc
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")
    
    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call eio%output (event, 5)
    call eio%write (u)
    call eio%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")
    
    call eio%init_in (sample)
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%input_i_prc (i_prc, iostat)
    call eio%input_event (event, iostat)
    call eio%write (u)
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i = ", i_prc
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_base_1"
    
  end subroutine eio_base_1
  
@ %def eio_base_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Event Generation Checkpoints}
This is an output-only format.  Its only use is to write screen
messages every $n$ events, to inform the user about progress.
<<[[eio_checkpoints.f90]]>>=
<<File header>>

module eio_checkpoints
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use cputime
  use model_data
  use event_base
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO checkpoints: public>>

<<EIO checkpoints: parameters>>

<<EIO checkpoints: types>>

contains
  
<<EIO checkpoints: procedures>>

<<EIO checkpoints: tests>>

end module eio_checkpoints
@ %def eio_checkpoints
@
\subsection{Type}
<<EIO checkpoints: public>>=
  public :: eio_checkpoints_t
<<EIO checkpoints: types>>=
  type, extends (eio_t) :: eio_checkpoints_t
     logical :: active = .false.
     logical :: running = .false.
     integer :: val = 0
     integer :: n_events = 0
     integer :: n_read = 0
     integer :: i_evt = 0
     logical :: blank = .false.
     type(timer_t) :: timer
   contains
   <<EIO checkpoints: eio checkpoints: TBP>>
  end type eio_checkpoints_t
  
@ %def eio_checkpoints_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LHEF.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: set_parameters => eio_checkpoints_set_parameters
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_set_parameters (eio, checkpoint, blank)
    class(eio_checkpoints_t), intent(inout) :: eio
    integer, intent(in) :: checkpoint
    logical, intent(in), optional :: blank
    eio%val = checkpoint
    if (present (blank))  eio%blank = blank
  end subroutine eio_checkpoints_set_parameters
  
@ %def eio_checkpoints_set_parameters
@ 
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current status.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: write => eio_checkpoints_write
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_write (object, unit)
    class(eio_checkpoints_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%active) then
       write (u, "(1x,A)")  "Event-sample checkpoints:  active"
       write (u, "(3x,A,I0)")  "interval  = ", object%val
       write (u, "(3x,A,I0)")  "n_events  = ", object%n_events
       write (u, "(3x,A,I0)")  "n_read    = ", object%n_read
       write (u, "(3x,A,I0)")  "n_current = ", object%i_evt
       write (u, "(3x,A,L1)")  "blanking  = ", object%blank
       call object%timer%write (u)
    else
       write (u, "(1x,A)")  "Event-sample checkpoints:  off"
    end if
  end subroutine eio_checkpoints_write
  
@ %def eio_checkpoints_write
@ Finalizer: trivial.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: final => eio_checkpoints_final
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_final (object)
    class(eio_checkpoints_t), intent(inout) :: object
    object%active = .false.
  end subroutine eio_checkpoints_final
  
@ %def eio_checkpoints_final
@ Activate checkpointing for event generation or writing.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: init_out => eio_checkpoints_init_out
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_init_out (eio, sample, data, success, extension)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    if (present (data)) then
       if (eio%val > 0) then
          eio%active = .true.
          eio%i_evt = 0
          eio%n_read = 0
          eio%n_events = data%n_evt
       end if
    end if
    if (present (success))  success = .true.
  end subroutine eio_checkpoints_init_out
    
@ %def eio_checkpoints_init_out
@ No checkpointing for event reading.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: init_in => eio_checkpoints_init_in
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_init_in (eio, sample, data, success, extension)
    class(eio_checkpoints_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("Event checkpoints: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_checkpoints_init_in
    
@ %def eio_checkpoints_init_in
@ Switch from input to output: also not supported.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: switch_inout => eio_checkpoints_switch_inout
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_switch_inout (eio, success)
    class(eio_checkpoints_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("Event checkpoints: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_checkpoints_switch_inout
  
@ %def eio_checkpoints_switch_inout
@ Checkpoints: display progress for the current event, if applicable.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: output => eio_checkpoints_output
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_output (eio, event, i_prc, reading, pacify)
    class(eio_checkpoints_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    logical :: rd
    rd = .false.;  if (present (reading))  rd = reading
    if (eio%active) then
       if (.not. eio%running)  call eio%startup ()
       if (eio%running) then
          eio%i_evt = eio%i_evt + 1
          if (rd) then
             eio%n_read = eio%n_read + 1
          else if (mod (eio%i_evt, eio%val) == 0) then
             call eio%message (eio%blank)
          end if
          if (eio%i_evt == eio%n_events)  call eio%shutdown ()
       end if
    end if
  end subroutine eio_checkpoints_output

@ %def eio_checkpoints_output
@ When the first event is called, we have to initialize the screen output.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: startup => eio_checkpoints_startup
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_startup (eio)
    class(eio_checkpoints_t), intent(inout) :: eio
    if (eio%active .and. eio%i_evt < eio%n_events) then
       call msg_message ("")
       call msg_message (checkpoint_bar)
       call msg_message (checkpoint_head)
       call msg_message (checkpoint_bar)
       write (msg_buffer, checkpoint_fmt) 0., 0, eio%n_events - eio%i_evt, "???"
       call msg_message ()
       eio%running = .true.
       call eio%timer%start ()
    end if
  end subroutine eio_checkpoints_startup
  
@ %def eio_checkpoints_startup
@ This message is printed at every checkpoint.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: message => eio_checkpoints_message
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_message (eio, testflag)
    class(eio_checkpoints_t), intent(inout) :: eio
    logical, intent(in), optional :: testflag
    real :: t
    type(time_t) :: time_remaining
    type(string_t) :: time_string
    call eio%timer%stop ()
    t = eio%timer
    call eio%timer%restart ()
    time_remaining = &
         nint (t / (eio%i_evt - eio%n_read) * (eio%n_events - eio%i_evt))
    time_string = time_remaining%to_string_ms (blank = testflag)
    write (msg_buffer, checkpoint_fmt) &
         100 * (eio%i_evt - eio%n_read) / real (eio%n_events - eio%n_read), &
         eio%i_evt - eio%n_read, &
         eio%n_events - eio%i_evt, &
         char (time_string)
    call msg_message ()
  end subroutine eio_checkpoints_message

@ %def eio_checkpoints_message
@ When the last event is called, wrap up.
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: shutdown => eio_checkpoints_shutdown
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_shutdown (eio)
    class(eio_checkpoints_t), intent(inout) :: eio
    if (mod (eio%i_evt, eio%val) /= 0) then
       write (msg_buffer, checkpoint_fmt) &
            100., eio%i_evt - eio%n_read, 0, "0m:00s"
       call msg_message ()
    end if
    call msg_message (checkpoint_bar)
    call msg_message ("")
    eio%running = .false.
  end subroutine eio_checkpoints_shutdown

@ %def eio_checkpoints_shutdown
<<EIO checkpoints: eio checkpoints: TBP>>=
  procedure :: input_i_prc => eio_checkpoints_input_i_prc
  procedure :: input_event => eio_checkpoints_input_event
<<EIO checkpoints: procedures>>=
  subroutine eio_checkpoints_input_i_prc (eio, i_prc, iostat)
    class(eio_checkpoints_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("Event checkpoints: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_checkpoints_input_i_prc

  subroutine eio_checkpoints_input_event (eio, event, iostat)
    class(eio_checkpoints_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("Event checkpoints: event input not supported")
    iostat = 1
  end subroutine eio_checkpoints_input_event

@ %def eio_checkpoints_input_i_prc
@ %def eio_checkpoints_input_event
@
\subsection{Message header}
<<EIO checkpoints: parameters>>=
  character(*), parameter :: &
     checkpoint_head = "| % complete | events generated | events remaining &
     &| time remaining"
  character(*), parameter :: &
     checkpoint_bar  = "|==================================================&
     &=================|"
  character(*), parameter :: &
     checkpoint_fmt  = "('   ',F5.1,T16,I9,T35,I9,T58,A)"
@ %def checkpoint_head
@ %def checkpoint_bar
@ %def checkpoint_fmt
@ %def checkpointing_t
@
\subsection{Unit tests}
<<EIO checkpoints: public>>=
  public :: eio_checkpoints_test
<<EIO checkpoints: tests>>=
  subroutine eio_checkpoints_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO checkpoints: execute tests>>
  end subroutine eio_checkpoints_test
  
@ %def eio_checkpoints_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO checkpoints: execute tests>>=
  call test (eio_checkpoints_1, "eio_checkpoints_1", &
       "read and write event contents", &
       u, results)
<<EIO checkpoints: tests>>=
  subroutine eio_checkpoints_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    class(eio_t), allocatable :: eio
    type(event_sample_data_t) :: data
    type(string_t) :: sample
    integer :: i, n_events

    write (u, "(A)")  "* Test output: eio_checkpoints_1"
    write (u, "(A)")  "*   Purpose: generate a number of events &
         &with screen output"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Generate events"
    write (u, "(A)")
 
    sample = "eio_checkpoints_1"
 
    allocate (eio_checkpoints_t :: eio)

    n_events = 10
    call data%init (1, 0)
    data%n_evt = n_events

    select type (eio)
    type is (eio_checkpoints_t)
       call eio%set_parameters (checkpoint = 4)
    end select

    call eio%init_out (sample, data)

    do i = 1, n_events
       call event%generate (1, [0._default, 0._default])
       call eio%output (event, i_prc = 0)
    end do
    
    write (u, "(A)")  "* Checkpointing status"
    write (u, "(A)")

    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_checkpoints_1"
    
  end subroutine eio_checkpoints_1
  
@ %def eio_checkpoints_1
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Event Weight Output}
This is an output-only format.  For each event, we print the indices
that identify process, process part (MCI group), and term.  As
numerical information we print the squared matrix element (trace) and
the event weight.
<<[[eio_weights.f90]]>>=
<<File header>>

module eio_weights
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use model_data
  use particles
  use event_base
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO weights: public>>

<<EIO weights: types>>

contains
  
<<EIO weights: procedures>>

<<EIO weights: tests>>

end module eio_weights
@ %def eio_weights
@
\subsection{Type}
<<EIO weights: public>>=
  public :: eio_weights_t
<<EIO weights: types>>=
  type, extends (eio_t) :: eio_weights_t
     logical :: writing = .false.
     integer :: unit = 0
     logical :: pacify = .false.
   contains
   <<EIO weights: eio weights: TBP>>
  end type eio_weights_t
  
@ %def eio_weights_t
@
\subsection{Specific Methods}
Set pacify flags.
<<EIO weights: eio weights: TBP>>=
  procedure :: set_parameters => eio_weights_set_parameters
<<EIO weights: procedures>>=
  subroutine eio_weights_set_parameters (eio, pacify)
    class(eio_weights_t), intent(inout) :: eio
    logical, intent(in), optional :: pacify
    if (present (pacify))  eio%pacify = pacify    
    eio%extension = "weights.dat"
  end subroutine eio_weights_set_parameters
  
@ %def eio_weights_set_parameters
@ 
\subsection{Common Methods}
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO weights: eio weights: TBP>>=
  procedure :: write => eio_weights_write
<<EIO weights: procedures>>=
  subroutine eio_weights_write (object, unit)
    class(eio_weights_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Weight stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
       write (u, "(3x,A,L1)") "Reduced I/O prec. = ", object%pacify 
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_weights_write
  
@ %def eio_weights_write
@ Finalizer: close any open file.
<<EIO weights: eio weights: TBP>>=
  procedure :: final => eio_weights_final
<<EIO weights: procedures>>=
  subroutine eio_weights_final (object)
    class(eio_weights_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing weight stream file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%writing = .false.
    end if
  end subroutine eio_weights_final
  
@ %def eio_weights_final
@ Initialize event writing.
<<EIO weights: eio weights: TBP>>=
  procedure :: init_out => eio_weights_init_out
<<EIO weights: procedures>>=
  subroutine eio_weights_init_out (eio, sample, data, success, extension)
    class(eio_weights_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    if (present(extension)) then
       eio%extension = extension
    else 
       eio%extension = "weights.dat"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to weight stream file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    open (eio%unit, file = char (eio%filename), &
         action = "write", status = "replace")
    if (present (success))  success = .true.
  end subroutine eio_weights_init_out
    
@ %def eio_weights_init_out
@ Initialize event reading.
<<EIO weights: eio weights: TBP>>=
  procedure :: init_in => eio_weights_init_in
<<EIO weights: procedures>>=
  subroutine eio_weights_init_in (eio, sample, data, success, extension)
    class(eio_weights_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("Weight stream: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_weights_init_in
    
@ %def eio_weights_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO weights: eio weights: TBP>>=
  procedure :: switch_inout => eio_weights_switch_inout
<<EIO weights: procedures>>=
  subroutine eio_weights_switch_inout (eio, success)
    class(eio_weights_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("Weight stream: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_weights_switch_inout
  
@ %def eio_weights_switch_inout
@ Output an event.  Write first the event indices, then weight and two
values of the squared matrix element: [[sqme_ref]] is the value stored
in the event record, and [[sqme_prc]] is the one stored in the process
instance.  (They can differ: when recalculating, the former is read
from file and the latter is the result of the new calculation.)

For the alternative entries, the [[sqme]] value is always obtained by
a new calculation, and thus qualifies as [[sqme_prc]].
<<EIO weights: eio weights: TBP>>=
  procedure :: output => eio_weights_output
<<EIO weights: procedures>>=
  subroutine eio_weights_output (eio, event, i_prc, reading, pacify)
    class(eio_weights_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    integer :: i_mci, i_term, n_alt, i
    real(default) :: weight, sqme_ref, sqme_prc
    if (eio%writing) then
!       i_mci = event%get_i_mci ()
!       i_term = event%get_i_term ()
       weight = event%get_weight_prc ()
       sqme_ref = event%get_sqme_ref ()
       sqme_prc = event%get_sqme_prc ()
       n_alt = event%get_n_alt ()
1      format (I0,3(1x,ES17.10),3(1x,I0))
2      format (I0,3(1x,ES15.8),3(1x,I0))       
       if (eio%pacify) then
          write (eio%unit, 2)  0, weight, sqme_prc, sqme_ref, &
               i_prc !, i_mci, i_term
       else
          write (eio%unit, 1)  0, weight, sqme_prc, sqme_ref, &
               i_prc !, i_mci, i_term
       end if
       do i = 1, n_alt
          weight = event%get_weight_alt(i)
          sqme_prc = event%get_sqme_alt(i)
          if (eio%pacify) then
             write (eio%unit, 2)  i, weight, sqme_prc
          else
             write (eio%unit, 1)  i, weight, sqme_prc          
          end if
       end do
    else
       call eio%write ()
       call msg_fatal ("Weight stream file is not open for writing")
    end if
  end subroutine eio_weights_output

@ %def eio_weights_output
@ Input an event.
<<EIO weights: eio weights: TBP>>=
  procedure :: input_i_prc => eio_weights_input_i_prc
  procedure :: input_event => eio_weights_input_event
<<EIO weights: procedures>>=
  subroutine eio_weights_input_i_prc (eio, i_prc, iostat)
    class(eio_weights_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("Weight stream: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_weights_input_i_prc

  subroutine eio_weights_input_event (eio, event, iostat)
    class(eio_weights_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("Weight stream: event input not supported")
    iostat = 1
  end subroutine eio_weights_input_event

@ %def eio_weights_input_i_prc
@ %def eio_weights_input_event
@
\subsection{Unit tests}
<<EIO weights: public>>=
  public :: eio_weights_test
<<EIO weights: tests>>=
  subroutine eio_weights_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO weights: execute tests>>
  end subroutine eio_weights_test
  
@ %def eio_weights_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO weights: execute tests>>=
  call test (eio_weights_1, "eio_weights_1", &
       "read and write event contents", &
       u, results)
<<EIO weights: tests>>=
  subroutine eio_weights_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_weights_1"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_weights_1"
 
    allocate (eio_weights_t :: eio)
    
    call eio%init_out (sample)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents: &
         &(weight, sqme(evt), sqme(prc), i_prc, i_mci, i_term)"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "eio_weights_1.weights.dat", &
         action = "read", status = "old")
    read (u_file, "(A)")  buffer
    write (u, "(A)") trim (buffer)
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event) 

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_weights_1"
  end subroutine eio_weights_1
  
@ %def eio_weights_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO weights: execute tests>>=
  call test (eio_weights_2, "eio_weights_2", &
       "multiple weights", &
       u, results)
<<EIO weights: tests>>=
  subroutine eio_weights_2 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, i
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_weights_2"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false., n_alt = 2)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_weights_2"
 
    allocate (eio_weights_t :: eio)
    
    call eio%init_out (sample)
    select type (eio)
    type is (eio_weights_t)
       call eio%set_parameters (pacify = .true.)
    end select
    call event%generate (1, [0._default, 0._default])
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = &
         [2 * event%get_weight_prc (), 3 * event%get_weight_prc ()])

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)") 
    write (u, "(A)")  "* File contents: &
         &(weight, sqme(evt), sqme(prc), i_prc, i_mci, i_term)"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "eio_weights_2.weights.dat", &
         action = "read", status = "old")
    do i = 1, 3
       read (u_file, "(A)")  buffer
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_weights_2"
    
  end subroutine eio_weights_2
  
@ %def eio_weights_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{ASCII File Formats}
Here, we implement several ASCII file formats. It is possible to
switch between them using flags.
<<[[eio_ascii.f90]]>>=
<<File header>>

module eio_ascii
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use model_data
  use particles
  use event_base
  use hep_common
  use hep_events
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO ascii: public>>

<<EIO ascii: types>>

contains
  
<<EIO ascii: procedures>>

<<EIO ascii: tests>>

end module eio_ascii
@ %def eio_ascii
@
\subsection{Type}
<<EIO ascii: public>>=
  public :: eio_ascii_t
<<EIO ascii: types>>=
  type, abstract, extends (eio_t) :: eio_ascii_t
     logical :: writing = .false.
     integer :: unit = 0
     logical :: keep_beams = .false.     
   contains
   <<EIO ascii: eio ascii: TBP>>
  end type eio_ascii_t
  
@ %def eio_ascii_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_ascii_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_ascii_t
  end type eio_ascii_ascii_t
  
@ %def eio_ascii_ascii_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_athena_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_athena_t
  end type eio_ascii_athena_t
  
@ %def eio_ascii_athena_t
@ The debug format has a few options that can be controlled by
Sindarin variables.
<<EIO ascii: public>>=
  public :: eio_ascii_debug_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_debug_t
     logical :: show_process = .true.
     logical :: show_transforms = .true.
     logical :: show_decay = .true.
     logical :: verbose = .true.
  end type eio_ascii_debug_t
  
@ %def eio_ascii_debug_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_hepevt_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_hepevt_t
  end type eio_ascii_hepevt_t
  
@ %def eio_ascii_hepevt_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_hepevt_verb_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_hepevt_verb_t
  end type eio_ascii_hepevt_verb_t
  
@ %def eio_ascii_hepevt_verb_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_lha_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_lha_t
  end type eio_ascii_lha_t
  
@ %def eio_ascii_lha_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_lha_verb_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_lha_verb_t
  end type eio_ascii_lha_verb_t
   
@ %def eio_ascii_lha_verb_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_long_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_long_t
  end type eio_ascii_long_t
  
@ %def eio_ascii_long_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_mokka_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_mokka_t
  end type eio_ascii_mokka_t
  
@ %def eio_ascii_mokka_t
@
<<EIO ascii: public>>=
  public :: eio_ascii_short_t
<<EIO ascii: types>>=
  type, extends (eio_ascii_t) :: eio_ascii_short_t
  end type eio_ascii_short_t
  
@ %def eio_ascii_short_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with ASCII file formats.  In
particular, this is the file extension.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: set_parameters => eio_ascii_set_parameters
<<EIO ascii: procedures>>=
  subroutine eio_ascii_set_parameters (eio, keep_beams, extension, &
       show_process, show_transforms, show_decay, verbose)
    class(eio_ascii_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    type(string_t), intent(in), optional :: extension
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (extension)) then
       eio%extension = extension
    else
       select type (eio)
       type is (eio_ascii_ascii_t)
          eio%extension = "evt"
       type is (eio_ascii_athena_t)
          eio%extension = "athena.evt"
       type is (eio_ascii_debug_t)
          eio%extension = "debug"
       type is (eio_ascii_hepevt_t)
          eio%extension = "hepevt"
       type is (eio_ascii_hepevt_verb_t)
          eio%extension = "hepevt.verb"          
       type is (eio_ascii_lha_t)
          eio%extension = "lha"
       type is (eio_ascii_lha_verb_t)
          eio%extension = "lha.verb"          
       type is (eio_ascii_long_t)
          eio%extension = "long.evt"
       type is (eio_ascii_mokka_t)
          eio%extension = "mokka.evt"
       type is (eio_ascii_short_t)
          eio%extension = "short.evt"
       end select
    end if
    select type (eio)
    type is (eio_ascii_debug_t)
       if (present (show_process))  eio%show_process = show_process
       if (present (show_transforms))  eio%show_transforms = show_transforms
       if (present (show_decay))  eio%show_decay = show_decay
       if (present (verbose))  eio%verbose = verbose
    end select
  end subroutine eio_ascii_set_parameters
  
@ %def eio_ascii_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: write => eio_ascii_write
<<EIO ascii: procedures>>=
  subroutine eio_ascii_write (object, unit)
    class(eio_ascii_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    select type (object)
    type is (eio_ascii_ascii_t)
       write (u, "(1x,A)")  "ASCII event stream (default format):"
    type is (eio_ascii_athena_t)
       write (u, "(1x,A)")  "ASCII event stream (ATHENA format):"
    type is (eio_ascii_debug_t)
       write (u, "(1x,A)")  "ASCII event stream (Debugging format):"
    type is (eio_ascii_hepevt_t)
       write (u, "(1x,A)")  "ASCII event stream (HEPEVT format):"
    type is (eio_ascii_hepevt_verb_t)
       write (u, "(1x,A)")  "ASCII event stream (verbose HEPEVT format):"
    type is (eio_ascii_lha_t)
       write (u, "(1x,A)")  "ASCII event stream (LHA format):"
    type is (eio_ascii_lha_verb_t)
       write (u, "(1x,A)")  "ASCII event stream (verbose LHA format):"
    type is (eio_ascii_long_t)
       write (u, "(1x,A)")  "ASCII event stream (long format):"
    type is (eio_ascii_mokka_t)
       write (u, "(1x,A)")  "ASCII event stream (MOKKA format):"
    type is (eio_ascii_short_t)
       write (u, "(1x,A)")  "ASCII event stream (short format):"
    end select
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    select type (object)
    type is (eio_ascii_debug_t)
       write (u, "(3x,A,L1)")    "Show process      = ", object%show_process
       write (u, "(3x,A,L1)")    "Show transforms   = ", object%show_transforms
       write (u, "(3x,A,L1)")    "Show decay tree   = ", object%show_decay
       write (u, "(3x,A,L1)")    "Verbose output    = ", object%verbose
    end select
  end subroutine eio_ascii_write
  
@ %def eio_ascii_write
@ Finalizer: close any open file.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: final => eio_ascii_final
<<EIO ascii: procedures>>=
  subroutine eio_ascii_final (object)
    class(eio_ascii_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing ASCII file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%writing = .false.
    end if
  end subroutine eio_ascii_final
  
@ %def eio_ascii_final
@ Initialize event writing.

Check weight normalization.  This applies to all ASCII-type files that
use the HEPRUP common block.  We can't allow normalization conventions
that are not covered by the HEPRUP definition.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: init_out => eio_ascii_init_out
<<EIO ascii: procedures>>=
  subroutine eio_ascii_init_out (eio, sample, data, success, extension)
    class(eio_ascii_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: i
    if (.not. present (data)) &
         call msg_bug ("ASCII initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("ASCII: defined for scattering processes only")
    eio%sample = sample
    call eio%check_normalization (data)
    call eio%set_splitting (data)
    call eio%set_filename ()
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to ASCII file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    open (eio%unit, file = char (eio%filename), &
         action = "write", status = "replace")
    select type (eio)
    type is (eio_ascii_lha_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))
       end do
       call heprup_write_ascii (eio%unit)    
    type is (eio_ascii_lha_verb_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))
       end do
       call heprup_write_verbose (eio%unit)        
    end select
    if (present (success))  success = .true.
  end subroutine eio_ascii_init_out
    
@ %def eio_ascii_init_out
@ Some event properties do not go well with some output formats.  In
particular, many formats require unweighted events.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: check_normalization => eio_ascii_check_normalization
<<EIO ascii: procedures>>=
  subroutine eio_ascii_check_normalization (eio, data)
    class(eio_ascii_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    if (data%unweighted) then
    else
       select type (eio)
       type is (eio_ascii_athena_t);  call msg_fatal &
            ("Event output (Athena format): events must be unweighted.")
       type is (eio_ascii_hepevt_t);  call msg_fatal &
            ("Event output (HEPEVT format): events must be unweighted.")
       type is (eio_ascii_hepevt_verb_t);  call msg_fatal &
            ("Event output (HEPEVT format): events must be unweighted.")
       end select
       select case (data%norm_mode)
       case (NORM_SIGMA)
       case default
          select type (eio)
          type is (eio_ascii_lha_t)
             call msg_fatal &
                  ("Event output (LHA): normalization for weighted events &
                  &must be 'sigma'")
          type is (eio_ascii_lha_verb_t)
             call msg_fatal &
                  ("Event output (LHA): normalization for weighted events &
                  &must be 'sigma'")
          end select
       end select
    end if
  end subroutine eio_ascii_check_normalization
  
@ %def check_normalization
@ Initialize event reading.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: init_in => eio_ascii_init_in
<<EIO ascii: procedures>>=
  subroutine eio_ascii_init_in (eio, sample, data, success, extension)
    class(eio_ascii_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    call msg_bug ("ASCII: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_ascii_init_in
    
@ %def eio_ascii_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: switch_inout => eio_ascii_switch_inout
<<EIO ascii: procedures>>=
  subroutine eio_ascii_switch_inout (eio, success)
    class(eio_ascii_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("ASCII: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_ascii_switch_inout
  
@ %def eio_ascii_switch_inout
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO ascii: eio ascii: TBP>>=
  procedure :: split_out => eio_ascii_split_out
<<EIO ascii: procedures>>=
  subroutine eio_ascii_split_out (eio)
    class(eio_ascii_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to ASCII file '", &
            char (eio%filename), "'"
       call msg_message ()
       close (eio%unit)
       open (eio%unit, file = char (eio%filename), &
            action = "write", status = "replace")
       select type (eio)
       type is (eio_ascii_lha_t)
          call heprup_write_ascii (eio%unit)    
       type is (eio_ascii_lha_verb_t)
          call heprup_write_verbose (eio%unit)        
       end select
    end if
  end subroutine eio_ascii_split_out
  
@ %def eio_ascii_split_out
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: output => eio_ascii_output
<<EIO ascii: procedures>>=
  subroutine eio_ascii_output (eio, event, i_prc, reading, pacify)
    class(eio_ascii_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    if (eio%writing) then
       select type (eio)
       type is (eio_ascii_lha_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call hepeup_write_lha (eio%unit)
       type is (eio_ascii_lha_verb_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call hepeup_write_verbose (eio%unit)          
       type is (eio_ascii_ascii_t)
          call event%write (eio%unit, &
               show_process = .false., &
               show_transforms = .false., &
               show_decay = .false., &
               verbose = .false., testflag = pacify)
       type is (eio_ascii_athena_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &          
               keep_beams = eio%keep_beams)
          call hepevt_write_athena (eio%unit)                    
       type is (eio_ascii_debug_t)
          call event%write (eio%unit, &
               show_process = eio%show_process, &
               show_transforms = eio%show_transforms, &
               show_decay = eio%show_decay, &
               verbose = eio%verbose)
       type is (eio_ascii_hepevt_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_hepevt (eio%unit)                              
       type is (eio_ascii_hepevt_verb_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_verbose (eio%unit)
       type is (eio_ascii_long_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), & 
               keep_beams = eio%keep_beams)
          call hepevt_write_ascii (eio%unit, .true.)                           
       type is (eio_ascii_mokka_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &                         
               keep_beams = eio%keep_beams)
          call hepevt_write_mokka (eio%unit)                              
       type is (eio_ascii_short_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &  
               keep_beams = eio%keep_beams)
          call hepevt_write_ascii (eio%unit, .false.)                    
       end select       
    else
       call eio%write ()
       call msg_fatal ("ASCII file is not open for writing")
    end if
  end subroutine eio_ascii_output

@ %def eio_ascii_output
@ Input an event.
<<EIO ascii: eio ascii: TBP>>=
  procedure :: input_i_prc => eio_ascii_input_i_prc
  procedure :: input_event => eio_ascii_input_event
<<EIO ascii: procedures>>=
  subroutine eio_ascii_input_i_prc (eio, i_prc, iostat)
    class(eio_ascii_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("ASCII: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_ascii_input_i_prc

  subroutine eio_ascii_input_event (eio, event, iostat)
    class(eio_ascii_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("ASCII: event input not supported")
    iostat = 1
  end subroutine eio_ascii_input_event

@ %def eio_ascii_input_i_prc
@ %def eio_ascii_input_event
@
\subsection{Unit tests}
<<EIO ascii: public>>=
  public :: eio_ascii_test
<<EIO ascii: tests>>=
  subroutine eio_ascii_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO ascii: execute tests>>
  end subroutine eio_ascii_test
  
@ %def eio_ascii_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods, method [[ascii]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_1, "eio_ascii_1", &
       "read and write event contents, format [ascii]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_1"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII ascii format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)

    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_1"
 
    allocate (eio_ascii_ascii_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_ascii_t :: eio)
    
    select type (eio)
    type is (eio_ascii_ascii_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_1"
    
  end subroutine eio_ascii_1
  
@ %def eio_ascii_1
@ 
We test the implementation of all I/O methods, method [[athena]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_2, "eio_ascii_2", &
       "read and write event contents, format [athena]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_2 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_2"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII athena format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_2"
 
    allocate (eio_ascii_athena_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char(sample // ".athena.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_athena_t :: eio)
    
    select type (eio)
    type is (eio_ascii_athena_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_2"
    
  end subroutine eio_ascii_2
  
@ %def eio_ascii_2
@ 
We test the implementation of all I/O methods, method [[debug]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_3, "eio_ascii_3", &
       "read and write event contents, format [debug]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_3 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_3"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII debug format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_3"
 
    allocate (eio_ascii_debug_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".debug"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_debug_t :: eio)
    
    select type (eio)
    type is (eio_ascii_debug_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_3"
    
  end subroutine eio_ascii_3
  
@ %def eio_ascii_3
@ 
We test the implementation of all I/O methods, method [[hepevt]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_4, "eio_ascii_4", &
       "read and write event contents, format [hepevt]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_4 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_4"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII hepevt format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_4"
 
    allocate (eio_ascii_hepevt_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepevt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_hepevt_t :: eio)
    
    select type (eio)
    type is (eio_ascii_hepevt_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_4"
    
  end subroutine eio_ascii_4
  
@ %def eio_ascii_4
@ 
We test the implementation of all I/O methods, method [[lha]] (old LHA):
<<EIO ascii: execute tests>>=
  call test (eio_ascii_5, "eio_ascii_5", &
       "read and write event contents, format [lha]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_5 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_5"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII LHA format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_5"
 
    allocate (eio_ascii_lha_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lha"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_lha_t :: eio)
    
    select type (eio)
    type is (eio_ascii_lha_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_5"
    
  end subroutine eio_ascii_5
  
@ %def eio_ascii_5
@ 
We test the implementation of all I/O methods, method [[long]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_6, "eio_ascii_6", &
       "read and write event contents, format [long]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_6 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_6"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII long format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_6"
 
    allocate (eio_ascii_long_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".long.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_long_t :: eio)
    
    select type (eio)
    type is (eio_ascii_long_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_6"
    
  end subroutine eio_ascii_6
  
@ %def eio_ascii_6
@ 
We test the implementation of all I/O methods, method [[mokka]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_7, "eio_ascii_7", &
       "read and write event contents, format [mokka]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_7 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_7"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII mokka format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_7"
 
    allocate (eio_ascii_mokka_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".mokka.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_mokka_t :: eio)
    
    select type (eio)
    type is (eio_ascii_mokka_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_7"
    
  end subroutine eio_ascii_7
  
@ %def eio_ascii_7
@ 
We test the implementation of all I/O methods, method [[short]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_8, "eio_ascii_8", &
       "read and write event contents, format [short]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_8 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_8"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII short format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_8"
 
    allocate (eio_ascii_short_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".short.evt"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_short_t :: eio)
    
    select type (eio)
    type is (eio_ascii_short_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_8"
    
  end subroutine eio_ascii_8
  
@ %def eio_ascii_8
@ 
We test the implementation of all I/O methods, method [[lha]]  (old
LHA) in verbose version:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_9, "eio_ascii_9", &
       "read and write event contents, format [lha_verb]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_9 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_9"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII LHA verbose format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_9"
 
    allocate (eio_ascii_lha_verb_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lha.verb"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_lha_verb_t :: eio)
    
    select type (eio)
    type is (eio_ascii_lha_verb_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_9"
    
  end subroutine eio_ascii_9
  
@ %def eio_ascii_9 
@ 
We test the implementation of all I/O methods, method [[hepevt_verb]]:
<<EIO ascii: execute tests>>=
  call test (eio_ascii_10, "eio_ascii_10", &
       "read and write event contents, format [hepevt_verb]", &
       u, results)
<<EIO ascii: tests>>=
  subroutine eio_ascii_10 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_ascii_10"
    write (u, "(A)")  "*   Purpose: generate an event in ASCII hepevt verbose format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_ascii_10"
 
    allocate (eio_ascii_hepevt_verb_t :: eio)
    
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepevt.verb"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_ascii_hepevt_verb_t :: eio)
    
    select type (eio)
    type is (eio_ascii_hepevt_verb_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_ascii_10"
    
  end subroutine eio_ascii_10
  
@ %def eio_ascii_10
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HEP Common Blocks}

Long ago, to transfer data between programs one had to set up a common
block and link both programs as libraries to the main executable.  The
HEP community standardizes several of those common blocks.

The modern way of data exchange uses data files with standard
formats.  However, the LHEF standard data format derives from a common
block (actually, two).

\whizard\ used to support those common blocks, and LHEF was
implemented via writing/reading blocks.  We still keep this
convention, but intend to eliminate common blocks (or any other static
storage) from the workflow in the future.  This will gain flexibility
towards concurrent running of program images.

We encapsulate everything here in a module.  The module holds the
variables which are part of the common block.  To access the common
block variables, we just have to [[use]] this module.  (They are
nevertheless in the common block, since external software may access
it in this way.)

Note: This code is taken essentially unchanged from \whizard\ 2.1 and
does not (yet) provide unit tests.
<<[[hep_common.f90]]>>=
<<File header>>

module hep_common
  
  use kinds
  use io_units
<<Use strings>>
  use diagnostics
  use physics_defs, only: HADRON_REMNANT
  use physics_defs, only: HADRON_REMNANT_SINGLET
  use physics_defs, only: HADRON_REMNANT_TRIPLET
  use physics_defs, only: HADRON_REMNANT_OCTET
  use lorentz
  use flavors
  use colors
  use polarizations
  use model_data
  use particles
  use subevents

<<Standard module head>>

<<HEP common: public>>

<<HEP common: interfaces>>

<<HEP common: parameters>>

<<HEP common: variables>>

<<HEP common: common blocks>>

contains
  
<<HEP common: procedures>>

end module hep_common
@ %def hep_common
@
\subsection{Event characteristics}
The maximal number of particles in an event record.
<<HEP common: parameters>>=
  integer, parameter, public :: MAXNUP = 500
@ %def MAXNUP
@ The number of particles in this event.
<<HEP common: variables>>=
  integer, public :: NUP
@ %def NUP
@ The process ID for this event.
<<HEP common: variables>>=
  integer, public :: IDPRUP
@ %def IDPRUP
@ The weight of this event ($\pm 1$ for unweighted events).
<<HEP common: variables>>=
  double precision, public :: XWGTUP
@ %def XWGTUP
@ The factorization scale that is used for PDF calculation ($-1$ if
undefined).
<<HEP common: variables>>=
  double precision, public :: SCALUP
@ %def SCALUP
@ The QED and QCD couplings $\alpha$ used for this event ($-1$ if
undefined).
<<HEP common: variables>>=
  double precision, public :: AQEDUP
  double precision, public :: AQCDUP
@ %def AQEDUP AQCDUP
@ 

\subsection{Particle characteristics}
The PDG code:
<<HEP common: variables>>=
  integer, dimension(MAXNUP) :: IDUP
@ %def IDUP
@ The status code.  Incoming: $-1$, outgoing: $+1$.  Intermediate
t-channel propagator: $-2$ (currently not used by WHIZARD).
Intermediate resonance whose mass should be preserved: $2$.
Intermediate resonance for documentation: $3$ (currently not used).
Beam particles: $-9$.
<<HEP common: variables>>=
  integer, dimension(MAXNUP), public :: ISTUP
@ %def ISTUP
@ Index of first and last mother.
<<HEP common: variables>>=
  integer, dimension(2,MAXNUP), public :: MOTHUP
@ %def MOTHUP
@ Color line index of the color and anticolor entry for the particle.
The standard recommends using large numbers; we start from MAXNUP+1. 
<<HEP common: variables>>=
  integer, dimension(2,MAXNUP), public :: ICOLUP
@ %def ICOLUP
@ Momentum, energy, and invariant mass: $(p_x,p_y,p_z,E,M)$.  For
space-like particles, $M$ is the negative square root of the absolute
value of the invariant mass.
<<HEP common: variables>>=
  double precision, dimension(5,MAXNUP), public :: PUP
@ %def PUP
@ Invariant lifetime (distance) from production to decay in mm.
<<HEP common: variables>>=
  double precision, dimension(MAXNUP), public :: VTIMUP
@ %def VTIMUP
@ Cosine of the angle between the spin-vector and a particle and the
3-momentum of its mother, given in the lab frame.  If
undefined/unpolarized: $9$.
<<HEP common: variables>>=
  double precision, dimension(MAXNUP), public :: SPINUP
@ %def SPINUP
@ 
\subsection{The HEPRUP common block}
This common block is filled once per run.

\subsubsection{Run characteristics}
The maximal number of different processes.
<<HEP common: parameters>>=
  integer, parameter, public :: MAXPUP = 100
@ %def MAXPUP
@ The beam PDG codes.
<<HEP common: variables>>=
  integer, dimension(2), public :: IDBMUP
@ %def IDBMUP
@ The beam energies in GeV.
<<HEP common: variables>>=
  double precision, dimension(2), public :: EBMUP
@ %def EBMUP
@ The PDF group and set for the two beams.  (Undefined: use $-1$;
LHAPDF: use group = $0$).
<<HEP common: variables>>=
  integer, dimension(2), public :: PDFGUP
  integer, dimension(2), public :: PDFSUP
@ %def PDFGUP PDFSUP
@ The (re)weighting model.  1: events are weighted, the shower
generator (SHG) selects processes according to the maximum weight (in
pb) and unweights events.  2: events are weighted, the SHG selects
processes according to their cross section (in pb) and unweights
events.  3: events are unweighted and simply run through the SHG.  4:
events are weighted, and the SHG keeps the weight.  Negative numbers:
negative weights are allowed (and are reweighted to $\pm 1$ by the
SHG, if allowed).

\whizard\ only supports modes 3 and 4, as the SHG is not given control
over process selection.  This is consistent with writing events to
file, for offline showering.
<<HEP common: variables>>=
  integer, public :: IDWTUP
@ %def IDWTUP
@ The number of different processes.
<<HEP common: variables>>=
  integer, public :: NPRUP
@ %def NPRUP
@
\subsubsection{Process characteristics}
Cross section and error in pb.  (Cross section is needed only for
$[[IDWTUP]] = 2$, so here both values are given for informational
purposes only.)
<<HEP common: variables>>=
  double precision, dimension(MAXPUP), public :: XSECUP
  double precision, dimension(MAXPUP), public :: XERRUP
@ %def XSECUP XERRUP
@ Maximum weight, i.e., the maximum value that [[XWGTUP]] can take.
Also unused for the supported weighting models. It is $\pm 1$ for
unweighted events.
<<HEP common: variables>>=
  double precision, dimension(MAXPUP), public :: XMAXUP
@ %def XMAXUP
@ Internal ID of the selected process, matches [[IDPRUP]] below.
<<HEP common: variables>>=
  integer, dimension(MAXPUP), public :: LPRUP
@ %def LPRUP
@
\subsubsection{The common block}
<<HEP common: common blocks>>=
  common /HEPRUP/ &
       IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP, &
       XSECUP, XERRUP, XMAXUP, LPRUP
  save /HEPRUP/

@ %def HEPRUP
@ Fill the run characteristics of the common block.  The
initialization sets the beam properties, number of processes, and
weighting model.
<<HEP common: public>>=
  public :: heprup_init
<<HEP common: procedures>>=
  subroutine heprup_init &
       (beam_pdg, beam_energy, n_processes, unweighted, negative_weights)
    integer, dimension(2), intent(in) :: beam_pdg
    real(default), dimension(2), intent(in) :: beam_energy
    integer, intent(in) :: n_processes
    logical, intent(in) :: unweighted
    logical, intent(in) :: negative_weights
    IDBMUP = beam_pdg
    EBMUP = beam_energy
    PDFGUP = -1
    PDFSUP = -1
    if (unweighted) then
       IDWTUP = 3
    else
       IDWTUP = 4
    end if
    if (negative_weights)  IDWTUP = - IDWTUP
    NPRUP = n_processes
  end subroutine heprup_init

@ %def heprup_init
@ Extract parameters from the common block.  We leave it to the caller
to specify which parameters it actually needs.

[[PDFGUP]] and [[PDFSUP]] are not extracted.  [[IDWTUP=1,2]] are not
supported by \whizard, but correspond to weighted events.
<<HEP common: public>>=
  public :: heprup_get_run_parameters
<<HEP common: procedures>>=
  subroutine heprup_get_run_parameters &
       (beam_pdg, beam_energy, n_processes, unweighted, negative_weights)
    integer, dimension(2), intent(out), optional :: beam_pdg
    real(default), dimension(2), intent(out), optional :: beam_energy
    integer, intent(out), optional :: n_processes
    logical, intent(out), optional :: unweighted
    logical, intent(out), optional :: negative_weights
    if (present (beam_pdg))  beam_pdg = IDBMUP
    if (present (beam_energy))  beam_energy = EBMUP
    if (present (n_processes))  n_processes = NPRUP
    if (present (unweighted)) then
       select case (abs (IDWTUP))
       case (3)
          unweighted = .true.
       case (4)
          unweighted = .false.
       case (1,2)  ! not supported by WHIZARD
          unweighted = .false.
       case default
          call msg_fatal ("HEPRUP: unsupported IDWTUP value")
       end select
    end if
    if (present (negative_weights)) then
       negative_weights = IDWTUP < 0
    end if
  end subroutine heprup_get_run_parameters

@ %def heprup_get_run_parameters
@ Specify PDF set info.  Since we support only LHAPDF, the group entry
is zero.
<<HEP common: public>>=
  public :: heprup_set_lhapdf_id
<<HEP common: procedures>>=
  subroutine heprup_set_lhapdf_id (i_beam, pdf_id)
    integer, intent(in) :: i_beam, pdf_id
    PDFGUP(i_beam) = 0
    PDFSUP(i_beam) = pdf_id
  end subroutine heprup_set_lhapdf_id

@ %def heprup_set_lhapdf_id
@ Fill the characteristics for a particular process.  Only the process
ID is mandatory.  Note that \whizard\ computes cross sections in fb,
so we have to rescale to pb.  The maximum weight is meaningless for
unweighted events.
<<HEP common: public>>=
  public :: heprup_set_process_parameters
<<HEP common: procedures>>=
  subroutine heprup_set_process_parameters &
       (i, process_id, cross_section, error, max_weight)
    integer, intent(in) :: i, process_id
    real(default), intent(in), optional :: cross_section, error, max_weight
    real(default), parameter :: pb_per_fb = 1.e-3_default
    LPRUP(i) = process_id
    if (present (cross_section)) then
       XSECUP(i) = cross_section * pb_per_fb
    else
       XSECUP(i) = 0
    end if
    if (present (error)) then
       XERRUP(i) = error * pb_per_fb
    else
       XERRUP(i) = 0
    end if
    select case (IDWTUP)
    case (3);  XMAXUP(i) = 1
    case (4)
       if (present (max_weight)) then
          XMAXUP(i) = max_weight * pb_per_fb
       else
          XMAXUP(i) = 0
       end if
    end select
  end subroutine heprup_set_process_parameters

@ %def heprup_set_process_parameters
@ Extract the process parameters, as far as needed.
<<HEP common: public>>=
  public :: heprup_get_process_parameters
<<HEP common: procedures>>=
  subroutine heprup_get_process_parameters  &
       (i, process_id, cross_section, error, max_weight)
    integer, intent(in) :: i
    integer, intent(out), optional :: process_id
    real(default), intent(out), optional :: cross_section, error, max_weight
    real(default), parameter :: pb_per_fb = 1.e-3_default
    if (present (process_id))  process_id = LPRUP(i)
    if (present (cross_section)) then
       cross_section = XSECUP(i) / pb_per_fb
    end if
    if (present (error)) then
       error = XERRUP(i) / pb_per_fb
    end if
    if (present (max_weight)) then
       select case (IDWTUP)
       case (3)
          max_weight = 1
       case (4)
          max_weight = XMAXUP(i) / pb_per_fb
       case (1,2)   ! not supported by WHIZARD
          max_weight = 0
       case default
          call msg_fatal ("HEPRUP: unsupported IDWTUP value")
       end select
    end if
  end subroutine heprup_get_process_parameters

@ %def heprup_get_process_parameters
@
\subsection{Run parameter output (verbose)}
This is a verbose output of the HEPRUP block.
<<HEP common: public>>=
  public :: heprup_write_verbose
<<HEP common: procedures>>=
  subroutine heprup_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPRUP Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "IDBMUP", IDBMUP, &
         "PDG code of beams"
    write (u, "(3x,A6,' = ',G12.5,1x,G12.5,8x,A)")  "EBMUP ", EBMUP, &
         "Energy of beams in GeV"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "PDFGUP", PDFGUP, &
         "PDF author group [-1 = undefined]"
    write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "PDFSUP", PDFSUP, &
         "PDF set ID       [-1 = undefined]"
    write (u, "(3x,A6,' = ',I9,3x,1x,9x,3x,8x,A)")  "IDWTUP", IDWTUP, &
         "LHA code for event weight mode"
    write (u, "(3x,A6,' = ',I9,3x,1x,9x,3x,8x,A)")  "NPRUP ", NPRUP, &
         "Number of user subprocesses"
    do i = 1, NPRUP
       write (u, "(1x,A,I0)")  "Subprocess #", i
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XSECUP", XSECUP(i), &
            "Cross section in pb"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XERRUP", XERRUP(i), &
            "Cross section error in pb"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "XMAXUP", XMAXUP(i), &
            "Maximum event weight (cf. IDWTUP)"
       write (u, "(3x,A6,' = ',I9,3x,1x,12x,8x,A)")  "LPRUP ", LPRUP(i), &
            "Subprocess ID"
    end do
  end subroutine heprup_write_verbose

@ %def heprup_write_verbose
@
\subsection{Run parameter output (other formats)}
This routine writes the initialization block according to the LHEF
standard.  It uses the current contents of the HEPRUP block.
<<HEP common: public>>=
  public :: heprup_write_lhef
<<HEP common: procedures>>=
  subroutine heprup_write_lhef (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),2(1x,ES17.10),6(1x,I0))") &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       write (u, "(3(1x,ES17.10),1x,I0)") &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_write_lhef
  
@ %def heprup_write_lhef
@
This routine is a complete dummy at the moment. It uses the current
contents of the HEPRUP block. At the end, it should depend on certain
input flags for the different ASCII event formats.
<<HEP common: public>>=
  public :: heprup_write_ascii
<<HEP common: procedures>>=
  subroutine heprup_write_ascii (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),2(1x,ES17.10),6(1x,I0))") &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       write (u, "(3(1x,ES17.10),1x,I0)") &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_write_ascii
  
@ %def heprup_write_ascii
@
\subsubsection{Run parameter input (LHEF)}
In a LHEF file, the parameters are written in correct order on
separate lines, but we should not count on the precise format.
List-directed input should just work.
<<HEP common: public>>=
  public :: heprup_read_lhef
<<HEP common: procedures>>=
  subroutine heprup_read_lhef (u)
    integer, intent(in) :: u
    integer :: i
    read (u, *) &
         IDBMUP, EBMUP, PDFGUP, PDFSUP, IDWTUP, NPRUP
    do i = 1, NPRUP
       read (u, *) &
            XSECUP(i), XERRUP(i), XMAXUP(i), LPRUP(i)
    end do
  end subroutine heprup_read_lhef
    
@ %def heprup_read_lhef
@
\subsection{The HEPEUP common block}
<<HEP common: common blocks>>=
  common /HEPEUP/ &
       NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP, &
       IDUP, ISTUP, MOTHUP, ICOLUP, PUP, VTIMUP, SPINUP
  save /HEPEUP/

@ %def HEPEUP
@ 
\subsubsection{Initialization}
Fill the event characteristics of the common block.  The
initialization sets only the number of particles and initializes the
rest with default values.  The other routine sets the optional
parameters.
<<HEP common: public>>=
  public :: hepeup_init
  public :: hepeup_set_event_parameters
<<HEP common: procedures>>=
  subroutine hepeup_init (n_tot)
    integer, intent(in) :: n_tot
    NUP = n_tot
    IDPRUP = 0
    XWGTUP = 1
    SCALUP = -1
    AQEDUP = -1
    AQCDUP = -1
  end subroutine hepeup_init

  subroutine hepeup_set_event_parameters &
       (proc_id, weight, scale, alpha_qed, alpha_qcd)
    integer, intent(in), optional :: proc_id
    real(default), intent(in), optional :: weight, scale, alpha_qed, alpha_qcd
    if (present (proc_id))   IDPRUP = proc_id
    if (present (weight))    XWGTUP = weight
    if (present (scale))     SCALUP = scale
    if (present (alpha_qed)) AQEDUP = alpha_qed
    if (present (alpha_qcd)) AQCDUP = alpha_qcd
  end subroutine hepeup_set_event_parameters

@ %def hepeup_init hepeup_set_event_parameters
@ 
Extract event information.  The caller determines the parameters.
<<HEP common: public>>=
  public :: hepeup_get_event_parameters
<<HEP common: procedures>>=
  subroutine hepeup_get_event_parameters &
       (proc_id, weight, scale, alpha_qed, alpha_qcd)
    integer, intent(out), optional :: proc_id
    real(default), intent(out), optional :: weight, scale, alpha_qed, alpha_qcd
    if (present (proc_id))   proc_id   = IDPRUP
    if (present (weight))    weight    = XWGTUP
    if (present (scale))     scale     = SCALUP
    if (present (alpha_qed)) alpha_qed = AQEDUP
    if (present (alpha_qcd)) alpha_qcd = AQCDUP
  end subroutine hepeup_get_event_parameters

@ %def hepeup_get_event_parameters
@ 
\subsubsection{Particle data}
Below we need the particle status codes which are actually defined
in the [[subevents]] module.

Set the entry for a specific particle.  All parameters are set with
the exception of lifetime and spin, where default values are stored.
<<HEP common: public>>=
  public :: hepeup_set_particle
<<HEP common: procedures>>=
  subroutine hepeup_set_particle (i, pdg, status, parent, col, p, m2)
    integer, intent(in) :: i
    integer, intent(in) :: pdg, status
    integer, dimension(:), intent(in) :: parent
    type(vector4_t), intent(in) :: p
    integer, dimension(2), intent(in) :: col
    real(default), intent(in) :: m2
    if (i > MAXNUP) then
       call msg_error (arr=[ &
            var_str ("Too many particles in HEPEUP common block. " // &
                            "If this happened "), &
            var_str ("during event output, your events will be " // &
                            "invalid; please consider "), &
            var_str ("switching to a modern event format like HEPMC. " // &
                            "If you are not "), &
            var_str ("using an old, HEPEUP based format and " // &
                            "nevertheless get this error,"), &
            var_str ("please notify the WHIZARD developers,") ])
       return
    end if
    IDUP(i) = pdg
    select case (status)
    case (PRT_BEAM);         ISTUP(i) = -9
    case (PRT_INCOMING);     ISTUP(i) = -1
    case (PRT_BEAM_REMNANT); ISTUP(i) =  3
    case (PRT_OUTGOING);     ISTUP(i) =  1
    case (PRT_RESONANT);     ISTUP(i) =  2
    case (PRT_VIRTUAL);      ISTUP(i) =  3
    case default;            ISTUP(i) =  0
    end select
    select case (size (parent))
    case (0);      MOTHUP(:,i) = 0
    case (1);      MOTHUP(1,i) = parent(1); MOTHUP(2,i) = 0
    case default;  MOTHUP(:,i) = [ parent(1), parent(size (parent)) ]
    end select
    if (col(1) > 0) then
       ICOLUP(1,i) = 500 + col(1)
    else
       ICOLUP(1,i) = 0
    end if
    if (col(2) > 0) then
       ICOLUP(2,i) = 500 + col(2)
    else
       ICOLUP(2,i) = 0
    end if
    PUP(1:3,i) = vector3_get_components (space_part (p))
    PUP(4,i) = energy (p)
    PUP(5,i) = sign (sqrt (abs (m2)), m2)
    VTIMUP(i) = 0
    SPINUP(i) = 9
  end subroutine hepeup_set_particle

@ %def hepeup_set_particle
@ Set the lifetime, actually $c\tau$ measured im mm, where $\tau$ is
the invariant lifetime.
<<HEP common: public>>=
  public :: hepeup_set_particle_lifetime
<<HEP common: procedures>>=
  subroutine hepeup_set_particle_lifetime (i, lifetime)
    integer, intent(in) :: i
    real(default), intent(in) :: lifetime
    VTIMUP(i) = lifetime
  end subroutine hepeup_set_particle_lifetime

@ %def hepeup_set_particle_lifetime
@ Set the particle spin entry.  We need the cosine of the angle of the
spin axis with respect to the three-momentum of the parent particle.

If the particle has a full polarization density matrix given, we need
the particle momentum and polarization as well as the mother-particle
momentum.  The polarization is transformed into a spin vector (which
is sensible only for spin-1/2 or massless particles), which then is
transformed into the lab frame (by a rotation of the 3-axis to the
particle momentum axis).  Finally, we compute the scalar product of
this vector with the mother-particle three-momentum.

This puts severe restrictions on the applicability of this definition,
and Lorentz invariance is lost.  Unfortunately, the Les Houches Accord
requires this computation.
<<HEP common: public>>=
  public :: hepeup_set_particle_spin
<<HEP common: interfaces>>=
  interface hepeup_set_particle_spin
     module procedure hepeup_set_particle_spin_pol
  end interface
<<HEP common: procedures>>=
  subroutine hepeup_set_particle_spin_pol (i, p, pol, p_mother)
    integer, intent(in) :: i
    type(vector4_t), intent(in) :: p
    type(polarization_t), intent(in) :: pol
    type(vector4_t), intent(in) :: p_mother
    type(vector3_t) :: s3, p3
    type(vector4_t) :: s4
    s3 = vector3_moving (polarization_get_axis (pol))
    p3 = space_part (p)
    s4 = rotation_to_2nd (3, p3) * vector4_moving (0._default, s3)
    SPINUP(i) = enclosed_angle_ct (s4, p_mother)
  end subroutine hepeup_set_particle_spin_pol
    
@ %def hepeup_set_particle_spin
@
Extract particle data.  The caller decides which ones to retrieve.

Status codes: beam remnants share the status code with virtual particles.
However, for the purpose of WHIZARD we should identify them.  We
use the PDG code for this.
<<HEP common: public>>=
  public :: hepeup_get_particle
<<HEP common: procedures>>=
  subroutine hepeup_get_particle (i, pdg, status, parent, col, p, m2)
    integer, intent(in) :: i
    integer, intent(out), optional :: pdg, status
    integer, dimension(:), intent(out), optional :: parent
    type(vector4_t), intent(out), optional :: p
    integer, dimension(2), intent(out), optional :: col
    real(default), dimension(5,MAXNUP) :: pup_def
    real(default), intent(out), optional :: m2
    if (present (pdg))  pdg = IDUP(i)
    if (present (status)) then
       select case (ISTUP(i))
       case (-9);  status = PRT_BEAM
       case (-1);  status = PRT_INCOMING
       case (1);   status = PRT_OUTGOING
       case (2);   status = PRT_RESONANT
       case (3);
          select case (abs (IDUP(i)))
          case (HADRON_REMNANT, HADRON_REMNANT_SINGLET, &
               HADRON_REMNANT_TRIPLET, HADRON_REMNANT_OCTET)
             status = PRT_BEAM_REMNANT
          case default
             status = PRT_VIRTUAL
          end select
       case default
          status = PRT_UNDEFINED
       end select
    end if
    if (present (parent)) then
       select case (size (parent))
       case (0)
       case (1);    parent(1) = MOTHUP(1,i)
       case (2);    parent = MOTHUP(:,i)
       end select
    end if
    if (present (col)) then
       col = ICOLUP(:,i)
    end if
    if (present (p)) then
       pup_def = PUP
       p = vector4_moving (pup_def(4,i), vector3_moving (pup_def(1:3,i)))
    end if
    if (present (m2)) then
       m2 = sign (PUP(5,i) ** 2, PUP(5,i))
    end if
  end subroutine hepeup_get_particle

@ %def hepeup_get_particle
@
\subsection{The HEPEVT common block}

For the LEP Monte Carlos, a standard common block has been proposed
in AKV89.  We strongly recommend its use.  (The description is an
abbreviated transcription of AKV89, Vol. 3, pp. 327-330).

[[NMXHEP]] is the maximum number of entries:
<<HEP common: variables>>=
  integer, parameter :: NMXHEP = 4000

@ %def NMXHEP 
@ [[NEVHEP]] is normally the event number, but may take special
values as follows:

   0   the program does not keep track of event numbers.
  -1   a special initialization record.
  -2   a special final record.
<<HEP common: variables>>=
  integer :: NEVHEP

@ %def NEVHEP
@  [[NHEP]] holds the number of entries for this event.
<<HEP common: variables>>=
  integer :: NHEP

@ %def NHEP
@ The entry [[ISTHEP(N)]] gives the status code for the [[N]]th entry,
with the following semantics:
   0       a null entry.
   1       an existing entry, which has not decayed or fragmented.
   2       a decayed or fragmented entry, which is retained for
           event history information.
   3       documentation line.
   4- 10   reserved for future standards.
  11-200   at the disposal of each model builder.
 201-      at the disposal of users.
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: ISTHEP

@ %def ISTHEP 
@ 
The Particle Data Group has proposed standard particle codes,
which are to be stored in [[IDHEP(N)]].
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: IDHEP

@ %def IDHEP
@ [[JMOHEP(1,N)]] points to the mother of the [[N]]th entry, if any.
It is set to zero for initial entries.
[[JMOHEP(2,N)]] points to the second mother, if any.
<<HEP common: variables>>=
  integer, dimension(2, NMXHEP) :: JMOHEP

@ %def JMOHEP
@ [[JDAHEP(1,N)]] and [[JDAHEP(2,N)]] point to the first and last daughter 
of the [[N]]th entry, if any.  These are zero for entries which have not
yet decayed.  The other daughters are stored in between these two.
<<HEP common: variables>>=
  integer, dimension(2, NMXHEP) :: JDAHEP

@ %def JDAHEP
@ In [[PHEP]] we store the momentum of the particle, more specifically
this means that [[PHEP(1,N)]], [[PHEP(2,N)]], and [[PHEP(3,N)]] contain the
momentum in the $x$, $y$, and $z$ direction (as defined by the machine
people), measured in GeV/c.  [[PHEP(4,N)]] contains the energy in GeV
and [[PHEP(5,N)]] the mass in GeV$/c^2$.  The latter may be negative for
spacelike partons.
<<HEP common: variables>>=
  double precision, dimension(5, NMXHEP) :: PHEP
  
@ %def PHEP
@ Finally [[VHEP]] is the place to store the position of the production
vertex.  [[VHEP(1,N)]], [[VHEP(2,N)]], and [[VHEP(3,N)]] contain the $x$, $y$,
and $z$ coordinate (as defined by the machine people), measured in mm.
[[VHEP(4,N)]] contains the production time in mm/c.
<<HEP common: variables>>=
  double precision, dimension(4, NMXHEP) :: VHEP
  
@ %def VHEP 
@ As an amendment to the proposed standard common block HEPEVT, we
also have a polarisation common block HEPSPN, as described in
AKV89.  [[SHEP(1,N)]], [[SHEP(2,N)]], and [[SHEP(3,N)]] give the $x$, $y$, and $z$
component of the spinvector $s$ of a fermion in the fermions restframe.

Furthermore, we add the polarization of the corresponding outgoing
particles:
<<HEP common: variables>>=
  integer, dimension(NMXHEP) :: hepevt_pol

@ %def hepevt_pol  
@
By convention, [[SHEP(4,N)]] is always 1. All this is taken from StdHep
4.06 manual and written using Fortran90 conventions.
<<HEP common: common blocks>>=
  common /HEPEVT/ &
       NEVHEP, NHEP, ISTHEP, IDHEP, &
       JMOHEP, JDAHEP, PHEP, VHEP
  save /HEPEVT/
  
@ %def HEPEVT
@ Here we store HEPEVT parameters of the WHIZARD 1 realization which
are not part of the HEPEVT common block. 
<<HEP common: variables>>=
  integer :: hepevt_n_out, hepevt_n_remnants

@ %def hepevt_n_out, hepevt_n_remnants
@  
<<HEP common: variables>>=
  double precision :: hepevt_weight, hepevt_function_value
  double precision :: hepevt_function_ratio
  
@ %def hepevt_weight hepevt_function_value
@ Filling HEPEVT: If the event count is not provided, set [[NEVHEP]]
to zero.  If the event count is [[-1]] or [[-2]], the record
corresponds to initialization and finalization, and the event is
irrelevant.

Note that the event count may be larger than $2^{31}$ (2 GEvents).  In
that case, cut off the upper bits since [[NEVHEP]] is probably limited
to default integer. 
<<HEP common: public>>=
  public :: hepevt_init
  public :: hepevt_set_event_parameters
<<HEP common: procedures>>=
  subroutine hepevt_init (n_tot, n_out)
    integer, intent(in) :: n_tot, n_out
    NHEP              = n_tot
    NEVHEP            = 0
    hepevt_n_out      = n_out
    hepevt_n_remnants = 0
    hepevt_weight     = 1
    hepevt_function_value = 0
    hepevt_function_ratio = 1
  end subroutine hepevt_init
  
  subroutine hepevt_set_event_parameters &
       (weight, function_value, function_ratio, i_evt)
    integer, intent(in), optional :: i_evt
    real(default), intent(in), optional :: weight, function_value, &
       function_ratio
    if (present (i_evt)) NEVHEP = i_evt
    if (present (weight)) hepevt_weight = weight
    if (present (function_value)) hepevt_function_value = &
         function_value
    if (present (function_ratio)) hepevt_function_ratio = &
         function_ratio
  end subroutine hepevt_set_event_parameters

@ %def hepevt_init hepevt_set_event_parameters
@ Set the entry for a specific particle.  All parameters are set with
the exception of lifetime and spin, where default values are stored.
<<HEP common: public>>=
  public :: hepevt_set_particle
<<HEP common: procedures>>=
  subroutine hepevt_set_particle (i, pdg, status, parent, child, p, m2, hel)
    integer, intent(in) :: i
    integer, intent(in) :: pdg, status
    integer, dimension(:), intent(in) :: parent
    integer, dimension(:), intent(in) :: child
    type(vector4_t), intent(in) :: p
    real(default), intent(in) :: m2
    integer, intent(in) :: hel
    IDHEP(i) = pdg
    select case (status)
      case (PRT_BEAM);      ISTHEP(i) = 2
      case (PRT_INCOMING);  ISTHEP(i) = 2
      case (PRT_OUTGOING);  ISTHEP(i) = 1
      case (PRT_VIRTUAL);   ISTHEP(i) = 2
      case (PRT_RESONANT);  ISTHEP(i) = 2
      case default;         ISTHEP(i) = 0
    end select
    select case (size (parent))
    case (0);      JMOHEP(:,i) = 0
    case (1);      JMOHEP(1,i) = parent(1); JMOHEP(2,i) = 0
    case default;  JMOHEP(:,i) = [ parent(1), parent(size (parent)) ]
    end select
    select case (size (child))
    case (0);      JDAHEP(:,i) = 0
    case (1);      JDAHEP(:,i) = child(1)
    case default;  JDAHEP(:,i) = [ child(1), child(size (child)) ]
    end select
    PHEP(1:3,i) = vector3_get_components (space_part (p))
    PHEP(4,i) = energy (p)
    PHEP(5,i) = sign (sqrt (abs (m2)), m2)
    VHEP(1:4,i) = 0
    hepevt_pol(i) = hel
  end subroutine hepevt_set_particle

@ %def hepevt_set_particle
@
\subsection{Event output}
This is a verbose output of the HEPEVT block.
<<HEP common: public>>=
  public :: hepevt_write_verbose
<<HEP common: procedures>>=
  subroutine hepevt_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPEVT Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NEVHEP", NEVHEP, &
         "Event number"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NHEP  ", NHEP, &
         "Number of particles in event"
    do i = 1, NHEP
       write (u, "(1x,A,I0)")  "Particle #", i
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)", advance="no") &
            "ISTHEP", ISTHEP(i), "Status code: "
       select case (ISTHEP(i))
       case ( 0);  write (u, "(A)")  "null entry"
       case ( 1);  write (u, "(A)")  "outgoing"
       case ( 2);  write (u, "(A)")  "decayed"
       case ( 3);  write (u, "(A)")  "documentation"
       case (4:10);  write (u, "(A)")  "[unspecified]"
       case (11:200);  write (u, "(A)")  "[model-specific]"
       case (201:);  write (u, "(A)")  "[user-defined]"
       case default;  write (u, "(A)")  "[undefined]"
       end select
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDHEP ", IDHEP(i), &
            "PDG code of particle"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "JMOHEP", JMOHEP(:,i), &
            "Index of first/second mother"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "JDAHEP", JDAHEP(:,i), &
            "Index of first/last daughter"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "PHEP12", &
            PHEP(1:2,i), "Transversal momentum (x/y) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP3 ", PHEP(3,i), &
            "Longitudinal momentum (z) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP4 ", PHEP(4,i), &
            "Energy in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PHEP5 ", PHEP(5,i), &
            "Invariant mass in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "VHEP12", VHEP(1:2,i), &
            "Transversal displacement (xy) in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VHEP3 ", VHEP(3,i), &
            "Longitudinal displacement (z) in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VHEP4 ", VHEP(4,i), &
            "Production time in mm"
    end do
  end subroutine hepevt_write_verbose

@ %def hepevt_write_verbose
@
This is a verbose output of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_write_verbose
<<HEP common: procedures>>=
  subroutine hepeup_write_verbose (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)")  "HEPEUP Common Block"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "NUP   ", NUP, &
         "Number of particles in event"
    write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDPRUP", IDPRUP, &
         "Subprocess ID"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "XWGTUP", XWGTUP, &
         "Event weight"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "SCALUP", SCALUP, &
         "Event energy scale in GeV"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "AQEDUP", AQEDUP, &
         "QED coupling [-1 = undefined]"
    write (u, "(3x,A6,' = ',ES12.5,1x,20x,A)")  "AQCDUP", AQCDUP, &
         "QCD coupling [-1 = undefined]"
    do i = 1, NUP
       write (u, "(1x,A,I0)")  "Particle #", i
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)")  "IDUP  ", IDUP(i), &
            "PDG code of particle"
       write (u, "(3x,A6,' = ',I9,3x,1x,20x,A)", advance="no") &
            "ISTUP ", ISTUP(i), "Status code: "
       select case (ISTUP(i))
       case (-1);  write (u, "(A)")  "incoming"
       case ( 1);  write (u, "(A)")  "outgoing"
       case (-2);  write (u, "(A)")  "spacelike"
       case ( 2);  write (u, "(A)")  "resonance"
       case ( 3);  write (u, "(A)")  "resonance (doc)"
       case (-9);  write (u, "(A)")  "beam"
       case default;  write (u, "(A)")  "[undefined]"
       end select
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "MOTHUP", MOTHUP(:,i), &
            "Index of first/last mother"
       write (u, "(3x,A6,' = ',I9,3x,1x,I9,3x,8x,A)")  "ICOLUP", ICOLUP(:,i), &
            "Color/anticolor flow index"
       write (u, "(3x,A6,' = ',ES12.5,1x,ES12.5,8x,A)")  "PUP1/2", PUP(1:2,i), &
            "Transversal momentum (x/y) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP3  ", PUP(3,i), &
            "Longitudinal momentum (z) in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP4  ", PUP(4,i), &
            "Energy in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "PUP5  ", PUP(5,i), &
            "Invariant mass in GeV"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "VTIMUP", VTIMUP(i), &
            "Invariant lifetime in mm"
       write (u, "(3x,A6,' = ',ES12.5,1x,12x,8x,A)")  "SPINUP", SPINUP(i), &
            "cos(spin angle) [9 = undefined]"
    end do
  end subroutine hepeup_write_verbose

@ %def hepeup_write_verbose
@
\subsection{Event output in various formats}
This routine writes event output according to the LHEF standard.  It
uses the current contents of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_write_lhef
  public :: hepeup_write_lha
<<HEP common: procedures>>=
  subroutine hepeup_write_lhef (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0),4(1x,ES17.10))") &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    do i = 1, NUP
       write (u, "(6(1x,I0),7(1x,ES17.10))") &
            IDUP(i), ISTUP(i), MOTHUP(:,i), ICOLUP(:,i), &
            PUP(:,i), VTIMUP(i), SPINUP(i)
    end do
  end subroutine hepeup_write_lhef

  subroutine hepeup_write_lha (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    integer, dimension(MAXNUP) :: spin_up
    spin_up = SPINUP
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I5),1x,ES17.10,3(1x,ES13.6))") &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    write (u, "(500(1x,I5))") IDUP(:NUP)
    write (u, "(500(1x,I5))") MOTHUP(1,:NUP)
    write (u, "(500(1x,I5))") MOTHUP(2,:NUP)
    write (u, "(500(1x,I5))") ICOLUP(1,:NUP)
    write (u, "(500(1x,I5))") ICOLUP(2,:NUP)
    write (u, "(500(1x,I5))") ISTUP(:NUP)
    write (u, "(500(1x,I5))") spin_up(:NUP)
    do i = 1, NUP
            write (u, "(1x,I5,4(1x,ES17.10))") i, PUP([ 4,1,2,3 ], i)
    end do

  end subroutine hepeup_write_lha  

@ %def hepeup_write_lhef hepeup_write_lha 
@ This routine writes event output according to the HEPEVT standard.  It
uses the current contents of the HEPEVT block and some additional
parameters according to the standard in WHIZARD 1. For the long ASCII
format, the value of the sample function (i.e. the product of squared
matrix element, structure functions and phase space factor is printed out).
The option of reweighting matrix elements with respect to some
reference cross section is not implemented in WHIZARD 2 for this event
format, therefore the second entry in the long ASCII format (the
function ratio) is always one. The ATHENA format is an implementation
of the HEPEVT format that is readable by the ATLAS ATHENA software
framework. It is very similar to the WHIZARD 1 HEPEVT format, except
that it contains an event counter, a particle counter inside the
event, and has the HEPEVT [[ISTHEP]] status before the PDG code. The
MOKKA format is a special ASCII format  that contains the information
to be parsed to the MOKKA LC fast simulation software.
<<HEP common: public>>=
  public :: hepevt_write_hepevt
  public :: hepevt_write_ascii
  public :: hepevt_write_athena
  public :: hepevt_write_mokka  
<<HEP common: procedures>>=
  subroutine hepevt_write_hepevt (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       write (u, "(7(1x,I0))") &
            ISTHEP(i), IDHEP(i), JMOHEP(:,i), JDAHEP(:,i), hepevt_pol(i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
       write (u, "(5(1x,ES17.10))") VHEP(:,i), 0.d0
    end do
  end subroutine hepevt_write_hepevt
  
  subroutine hepevt_write_ascii (unit, long)
    integer, intent(in), optional :: unit
    logical, intent(in) :: long   
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       if (ISTHEP(i) /= 1)  cycle
       write (u, "(2(1x,I0))") IDHEP(i), hepevt_pol(i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
    end do
    if (long) then 
       write (u, "(2(1x,ES17.10))") &
            hepevt_function_value, hepevt_function_ratio
    end if
  end subroutine hepevt_write_ascii
  
  subroutine hepevt_write_athena (unit, i_evt)
    integer, intent(in), optional :: unit, i_evt
    integer :: u, i, num_event
    num_event = 0
    if (present (i_evt)) num_event = i_evt
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(2(1x,I0))") num_event, NHEP
    do i = 1, NHEP
       write (u, "(7(1x,I0))") &
            i, ISTHEP(i), IDHEP(i), JMOHEP(:,i), JDAHEP(:,i)
       write (u, "(5(1x,ES17.10))") PHEP(:,i)
       write (u, "(5(1x,ES17.10))") VHEP(1:4,i)
    end do
  end subroutine hepevt_write_athena
  
  subroutine hepevt_write_mokka (unit)
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3(1x,I0),(1x,ES17.10))") &
         NHEP, hepevt_n_out, hepevt_n_remnants, hepevt_weight
    do i = 1, NHEP
       write (u, "(4(1x,I0),4(1x,ES17.10))") &
            ISTHEP(i), IDHEP(i), JDAHEP(1,i), JDAHEP(2,i), &
            PHEP(1:3,i), PHEP(5,i)
    end do
  end subroutine hepevt_write_mokka
  
@ %def hepevt_write_hepevt hepevt_write_ascii
@ %def hepevt_write_athena 
@
\subsection{Event input in various formats}
This routine writes event output according to the LHEF standard.  It
uses the current contents of the HEPEUP block.
<<HEP common: public>>=
  public :: hepeup_read_lhef
<<HEP common: procedures>>=
  subroutine hepeup_read_lhef (u)
    integer, intent(in) :: u
    integer :: i
    read (u, *) &
         NUP, IDPRUP, XWGTUP, SCALUP, AQEDUP, AQCDUP
    do i = 1, NUP
       read (u, *) &
            IDUP(i), ISTUP(i), MOTHUP(:,i), ICOLUP(:,i), &
            PUP(:,i), VTIMUP(i), SPINUP(i)
    end do
  end subroutine hepeup_read_lhef

@ %def hepeup_read_lhef
@ 
\subsection{Data Transfer: particle sets}
The \whizard\ format for handling particle data in events is
[[particle_set_t]].  We have to interface this to the common blocks.

We first create a new particle set that contains only the particles
that are supported by the LHEF format.  These are: beam, incoming,
resonant, outgoing.  We drop particles with unknown, virtual or
beam-remnant status.

From this set we fill the common block.  Event information such as
process ID and weight is not transferred here; this has to be done by
the caller.  The spin information is set only if the particle has a
unique mother, and if its polarization is fully defined.
<<HEP common: public>>=
  public :: hepeup_from_particle_set
<<HEP common: procedures>>=
  subroutine hepeup_from_particle_set (particle_set, keep_beams)
    type(particle_set_t), intent(in), target :: particle_set
    logical, intent(in), optional :: keep_beams  
    type(particle_t), pointer :: prt
    type(particle_set_t), target :: pset_hepevt
    integer :: i, n_parents
    integer, dimension(1) :: i_mother
    call particle_set_to_hepevt_form (particle_set, pset_hepevt, keep_beams)
    call hepeup_init (pset_hepevt%n_tot)
    do i = 1, pset_hepevt%n_tot
       prt => pset_hepevt%prt(i)
       call hepeup_set_particle (i, &
            particle_get_pdg (prt), &
            particle_get_status (prt), &
            particle_get_parents (prt), &
	    particle_get_color (prt), &
            particle_get_momentum (prt), &
            particle_get_p2 (prt))
       n_parents = particle_get_n_parents (prt)
       if (n_parents == 1) then
          i_mother = particle_get_parents (prt)
          select case (particle_get_polarization_status (prt))
          case (PRT_GENERIC_POLARIZATION)
             call hepeup_set_particle_spin (i, &
                  particle_get_momentum (prt), &
                  particle_get_polarization (prt), &
                  particle_get_momentum (pset_hepevt%prt(i_mother(1))))
          end select
       end if
    end do
    call particle_set_final (pset_hepevt)
  end subroutine hepeup_from_particle_set

@ %def hepeup_from_particle_set
@ Input.  The particle set should be allocated properly, but we
replace the particle contents.

If there are no beam particles in the event, we try to reconstruct beam
particles and beam remnants.  We assume for simplicity that the beam
particles, if any, are the first two particles.  If they are absent, the first
two particles should be the incoming partons.
<<HEP common: public>>=
  public :: hepeup_to_particle_set
<<HEP common: procedures>>=
  subroutine hepeup_to_particle_set &
       (particle_set, recover_beams, model, alt_model)
    type(particle_set_t), intent(inout), target :: particle_set
    logical, intent(in), optional :: recover_beams
    class(model_data_t), intent(in), target :: model, alt_model
    type(particle_t), dimension(:), allocatable :: prt
    integer, dimension(2) :: parent
    integer, dimension(:), allocatable :: child
    integer :: i, j, k, pdg, status
    type(flavor_t) :: flv
    type(color_t) :: col
    integer, dimension(2) :: c
    type(vector4_t) :: p
    real(default) :: p2
    logical :: reconstruct
    integer :: off
    if (present (recover_beams)) then
       reconstruct = recover_beams .and. .not. all (ISTUP(1:2) == PRT_BEAM)
    else
       reconstruct = .false.
    end if
    if (reconstruct) then
       off = 4
    else
       off = 0
    end if
    allocate (prt (NUP + off), child (NUP + off))
    do i = 1, NUP
       k = i + off
       call hepeup_get_particle (i, pdg, status, col = c, p = p, m2 = p2)
       call flavor_init (flv, pdg, model, alt_model)
       call particle_set_flavor (prt(k), flv)
       call particle_reset_status (prt(k), status)
       call color_init (col, c)
       call particle_set_color (prt(k), col)
       call particle_set_momentum (prt(k), p, p2)
       where (MOTHUP(:,i) /= 0)
          parent = MOTHUP(:,i) + off
       elsewhere
          parent = 0
       end where
       call particle_set_parents (prt(k), parent)
       child = [(j, j = 1 + off, NUP + off)]
       where (MOTHUP(1,:NUP) /= i .and. MOTHUP(2,:NUP) /= i)  child = 0
       call particle_set_children (prt(k), child)
    end do
    if (reconstruct) then
       do k = 1, 2
          call particle_reset_status (prt(k), PRT_BEAM)
          call particle_set_children (prt(k), [k+2,k+4])
       end do
       do k = 3, 4
          call particle_reset_status (prt(k), PRT_BEAM_REMNANT)
          call particle_set_parents (prt(k), [k-2])
       end do
       do k = 5, 6
          call particle_set_parents (prt(k), [k-4])
       end do
!     else
!        call handle_beams (prt)
    end if
    call particle_set_replace (particle_set, prt)
  end subroutine hepeup_to_particle_set
  
@ %def hepeup_to_particle_set
@ [Obsolete:] Beams and beam remnants require a special handling.  \whizard's interactions
are set up such that in the list of children of beam particles, the remnant
comes before the interacting parton.  To enforce this, we may have to reorder
things.

The beam particles will always be the first two particles.
<<XXX HEP common: procedures>>=
  subroutine handle_beams (prt)
    type(particle_t), dimension(:), intent(inout) :: prt
    integer :: i
    integer, dimension(2) :: child
    do i = 1, 2
       select case (particle_get_status (prt(i)))
       case (PRT_BEAM)
          child = particle_get_children (prt(i))
          if (particle_get_status (prt(child(2))) == PRT_BEAM_REMNANT) then
             call particle_set_children (prt(i), child([2,1]))
          end if
       end select
    end do
  end subroutine handle_beams
    
@ %def handle_beams
@ 
The HEPEVT common block is quite similar, but does contain less
information, e.g. no color flows (it was LEP time). The spin
information is set only if the particle has a unique mother, and if
its polarization is fully defined. 
<<HEP common: public>>=
  public :: hepevt_from_particle_set
<<HEP common: procedures>>=
  subroutine hepevt_from_particle_set (particle_set, keep_beams)
    type(particle_set_t), intent(in), target :: particle_set
    type(particle_t), pointer :: prt
    type(particle_set_t), target :: pset_hepevt
    logical, intent(in), optional :: keep_beams
    integer :: i
    call particle_set_to_hepevt_form (particle_set, pset_hepevt, keep_beams)
    call hepevt_init (pset_hepevt%n_tot, pset_hepevt%n_out)    
    do i = 1, pset_hepevt%n_tot
       prt => pset_hepevt%prt(i)
       call hepevt_set_particle (i, &
            particle_get_pdg (prt), &
            particle_get_status (prt), &
            particle_get_parents (prt), &
            particle_get_children (prt), &
            particle_get_momentum (prt), &
            particle_get_p2 (prt), &
	    particle_get_helicity (prt))
    end do
    call particle_set_final (pset_hepevt)
  end subroutine hepevt_from_particle_set

@ %def hepevt_from_particle_set
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HEP Common and Events}

This is a separate module that manages data exchange between the common blocks
and [[event_t]] objects.  We separate this from the previous module in order
to avoid a circular module dependency. It also contains the functions
necessary for communication between [[hepmc_event_t]] and
[[event_t]] or [[lcio_event_t]] and [[event_t]] objects.
<<[[hep_events.f90]]>>=
<<File header>>

module hep_events
  
  use kinds
  use io_units
  use diagnostics

  use model_data
  use particles
  use hep_common
  use hepmc_interface
  use lcio_interface
  use event_base

<<Standard module head>>

<<HEP events: public>>

contains
  
<<HEP events: procedures>>

end module hep_events
@ %def hep_events
@
\subsection{Data Transfer: events}
Fill the HEPEUP block, given a \whizard\ event object.
<<HEP events: public>>=
  public :: hepeup_from_event
<<HEP events: procedures>>=
  subroutine hepeup_from_event (event, keep_beams, process_index)
    class(generic_event_t), intent(in), target :: event
    logical, intent(in), optional :: keep_beams
    integer, intent(in), optional :: process_index
    type(particle_set_t), pointer :: particle_set
    real(default) :: scale, alpha_qcd
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call hepeup_from_particle_set (particle_set, keep_beams)
       if (present (process_index)) &
            call hepeup_set_event_parameters (proc_id = process_index)
       scale = event%get_fac_scale ()
       if (scale /= 0) &
            call hepeup_set_event_parameters (scale = scale)
       alpha_qcd = event%get_alpha_s ()       
       if (alpha_qcd /= 0) &
            call hepeup_set_event_parameters (alpha_qcd = alpha_qcd)
       if (event%weight_prc_is_known ()) then
          call hepeup_set_event_parameters (weight = event%get_weight_prc ())
       else
          call msg_bug ("HEPEUP: process weight is unknown")
       end if
    else
       call msg_bug ("HEPEUP: event incomplete")
    end if
  end subroutine hepeup_from_event

@ %def hepeup_from_event
@ Reverse.  

Note: The current implementation sets the particle set of the hard
process and is therefore not useful if the event on file is dressed.
This should be reconsidered.

Note: setting of scale or alpha is not yet supported by the
[[event_t]] object.  Ticket \#628.
<<HEP events: public>>=
  public :: hepeup_to_event
<<HEP events: procedures>>=
  subroutine hepeup_to_event &
       (event, fallback_model, process_index, recover_beams)
    class(generic_event_t), intent(inout), target :: event
    class(model_data_t), intent(in), target :: fallback_model
    integer, intent(out), optional :: process_index
    logical, intent(in), optional :: recover_beams
    class(model_data_t), pointer :: model
    real(default) :: weight, scale, alpha_qcd
    type(particle_set_t) :: particle_set
    model => event%get_model_ptr ()
    call hepeup_to_particle_set &
         (particle_set, recover_beams, model, fallback_model)
    call event%set_hard_particle_set (particle_set)
    call particle_set_final (particle_set)
    if (present (process_index)) then
       call hepeup_get_event_parameters (proc_id = process_index)
    end if
    call hepeup_get_event_parameters (weight = weight, &
         scale = scale, alpha_qcd = alpha_qcd)
    call event%set_weight_ref (weight)
!!! Not implemented yet:
!     if (scale > 0)  call event%set_scales (scale)
!     if (alpha_qcd > 0)  call event%set_alpha_qcd (alpha_qcd)
  end subroutine hepeup_to_event

@ %def hepeup_to_event
@ Fill the HEPEVT (event) common block:
<<HEP events: public>>=
  public :: hepevt_from_event
<<HEP events: procedures>>=
  subroutine hepevt_from_event (event, i_evt, keep_beams)
    class(generic_event_t), intent(in), target :: event
    integer, intent(in), optional :: i_evt
    logical, intent(in), optional :: keep_beams  
    type(particle_set_t), pointer :: particle_set
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call hepevt_from_particle_set (particle_set, keep_beams)
       if (event%weight_prc_is_known () .and. event%sqme_prc_is_known ()) then
          call hepevt_set_event_parameters ( &
               weight = event%get_weight_prc (), &
               function_value = event%get_sqme_prc ())
       else
          call msg_bug ("HEPEVT: event weight and/or sqme unknown")
       end if
       if (present (i_evt)) &
            call hepevt_set_event_parameters (i_evt = i_evt)
    else
       call msg_bug ("HEPEVT: event incomplete")
    end if
  end subroutine hepevt_from_event

@ %def hepevt_from_event
@ Fill a WHIZARD event from a HepMC event record.  Recall that
HepMC events are always unweighted, so the weight is unity.
<<HEP events: public>>=
  public :: hepmc_to_event
<<HEP events: procedures>>=
  subroutine hepmc_to_event &
       (event, hepmc_event, fallback_model, process_index, recover_beams)
    class(generic_event_t), intent(inout), target :: event
    type(hepmc_event_t), intent(inout) :: hepmc_event
    class(model_data_t), intent(in), target :: fallback_model
    integer, intent(out), optional :: process_index
    logical, intent(in), optional :: recover_beams
    class(model_data_t), pointer :: model
    real(default) :: weight, scale, alpha_qcd
    type(particle_set_t) :: particle_set
    model => event%get_model_ptr ()
    call particle_set_init &
         (particle_set, hepmc_event, model, fallback_model, PRT_DEFINITE_HELICITY)
    call event%set_hard_particle_set (particle_set)
    call particle_set_final (particle_set)
    call event%set_weight_ref (1._default)
!!! Not implemented yet:
!     if (scale > 0)  call event%set_scales (scale)
!     if (alpha_qcd > 0)  call event%set_alpha_qcd (alpha_qcd)
  end subroutine hepmc_to_event
  
@ %def hepmc_to_event
@
<<HEP events: public>>=
  public :: lcio_to_event
<<HEP events: procedures>>=
  subroutine lcio_to_event &
       (event, lcio_event, fallback_model, process_index, recover_beams)
    class(generic_event_t), intent(inout), target :: event
    type(lcio_event_t), intent(inout) :: lcio_event
    class(model_data_t), intent(in), target :: fallback_model
    integer, intent(out), optional :: process_index
    logical, intent(in), optional :: recover_beams
    class(model_data_t), pointer :: model
    real(default) :: weight, scale, alpha_qcd
    type(particle_set_t) :: particle_set
    model => event%get_model_ptr ()
    call particle_set_init &
         (particle_set, lcio_event, model, fallback_model, PRT_DEFINITE_HELICITY)
    call event%set_hard_particle_set (particle_set)
    call particle_set_final (particle_set)
    !!! Not implemented yet:
    ! if (scale > 0)  call event%set_scales (scale)
    ! if (alpha_qcd > 0)  call event%set_alpha_qcd (alpha_qcd)
  end subroutine lcio_to_event
  
@ %def lcio_to_event
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{LHEF Input/Output}
The LHEF event record is standardized.  It is an ASCII format.  We try
our best at using it for both input and output.
<<[[eio_lhef.f90]]>>=
<<File header>>

module eio_lhef
  
  use kinds
  use io_units
<<Use strings>>
  use string_utils
  use unit_tests
  use diagnostics
  use os_interface

  use xml
  use lorentz
  use model_data
  use particles
  use event_base
  use eio_data
  use eio_base
  use hep_common
  use hep_events

<<Standard module head>>

<<EIO LHEF: public>>

<<EIO LHEF: types>>

<<EIO LHEF: interfaces>>

contains
  
<<EIO LHEF: procedures>>

<<EIO LHEF: tests>>

end module eio_lhef
@ %def eio_lhef
@
\subsection{Type}
With sufficient confidence that it will always be three characters, we
can store the version string with a default value.
<<EIO LHEF: public>>=
  public :: eio_lhef_t
<<EIO LHEF: types>>=
  type, extends (eio_t) :: eio_lhef_t
     logical :: writing = .false.
     logical :: reading = .false.
     integer :: unit = 0
     type(event_sample_data_t) :: data
     type(cstream_t) :: cstream
     character(3) :: version = "1.0"
     logical :: keep_beams = .false.
     logical :: recover_beams = .true.
     logical :: unweighted = .true.
     logical :: write_sqme_ref = .false.
     logical :: write_sqme_prc = .false.
     logical :: write_sqme_alt = .false.
     integer :: n_alt = 0
     integer, dimension(:), allocatable :: proc_num_id
     integer :: i_weight_sqme = 0
     type(xml_tag_t) :: tag_lhef, tag_head, tag_init, tag_event
     type(xml_tag_t), allocatable :: tag_gen_n, tag_gen_v
     type(xml_tag_t), allocatable :: tag_generator, tag_xsecinfo
     type(xml_tag_t), allocatable :: tag_sqme_ref, tag_sqme_prc
     type(xml_tag_t), dimension(:), allocatable :: tag_sqme_alt, tag_wgts_alt
     type(xml_tag_t), allocatable :: tag_weight, tag_weightinfo, tag_weights
   contains
   <<EIO LHEF: eio lhef: TBP>>
  end type eio_lhef_t
  
@ %def eio_lhef_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LHEF.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: set_parameters => eio_lhef_set_parameters
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_set_parameters (eio, keep_beams, recover_beams, &
       version, extension, write_sqme_ref, write_sqme_prc, write_sqme_alt)
    class(eio_lhef_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams
    character(*), intent(in), optional :: version
    type(string_t), intent(in), optional :: extension
    logical, intent(in), optional :: write_sqme_ref
    logical, intent(in), optional :: write_sqme_prc
    logical, intent(in), optional :: write_sqme_alt
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (version)) then
       select case (version)
       case ("1.0", "2.0", "3.0")
          eio%version = version
       case default
          call msg_error ("LHEF version " // version &
               // " is not supported.  Inserting 2.0")
          eio%version = "2.0"
       end select
    end if
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "lhe"
    end if
    if (present (write_sqme_ref))  eio%write_sqme_ref = write_sqme_ref
    if (present (write_sqme_prc))  eio%write_sqme_prc = write_sqme_prc
    if (present (write_sqme_alt))  eio%write_sqme_alt = write_sqme_alt
  end subroutine eio_lhef_set_parameters
  
@ %def eio_lhef_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write => eio_lhef_write
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write (object, unit)
    class(eio_lhef_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "LHEF event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A)")     "Version           = ", object%version
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if
  end subroutine eio_lhef_write
  
@ %def eio_lhef_write
@ Finalizer: close any open file.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: final => eio_lhef_final
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_final (object)
    class(eio_lhef_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LHEF file '", &
            char (object%filename), "'"
       call msg_message ()
       call object%write_footer ()
       close (object%unit)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LHEF file '", &
            char (object%filename), "'"
       call msg_message ()
       call object%cstream%final ()
       object%reading = .false.
    end if
  end subroutine eio_lhef_final
  
@ %def eio_lhef_final
@ Common initialization for input and output.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: common_init => eio_lhef_common_init
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_common_init (eio, sample, data, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("LHEF initialization: missing data")
    eio%data = data
    if (data%n_beam /= 2) &
         call msg_fatal ("LHEF: defined for scattering processes only")
    eio%unweighted = data%unweighted
    if (eio%unweighted) then
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default;  call msg_fatal &
            ("LHEF: normalization for unweighted events must be '1'")
       end select
    else
       select case (data%norm_mode)
       case (NORM_SIGMA)
       case default;  call msg_fatal &
            ("LHEF: normalization for weighted events must be 'sigma'")
       end select
    end if
    eio%n_alt = data%n_alt
    eio%sample = sample
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    eio%unit = free_unit ()
    call eio%init_tags (data)
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_lhef_common_init
  
@ %def eio_lhef_common_init
@ Initialize the tag objects.  Some tags depend on the LHEF
version.  In particular, the tags that in LHEF 2.0 identify
individual weights by name in each event block, in LHEF 3.0 are
replaced by info tags in the init block and a single \texttt{weights}
tag in the event block.  The name attributes of those tags
are specific for \whizard.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_tags => eio_lhef_init_tags
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_tags (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(in) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    integer :: i
    call eio%tag_lhef%init ( &
         var_str ("LesHouchesEvents"), &
         [xml_attribute (var_str ("version"), var_str (eio%version))], &
         .true.)
    call eio%tag_head%init ( &
         var_str ("header"), &
         .true.)
    call eio%tag_init%init ( &
         var_str ("init"), &
         .true.)
    call eio%tag_event%init (var_str ("event"), &
         .true.)
    select case (eio%version)
    case ("1.0")
       allocate (eio%tag_gen_n)
       call eio%tag_gen_n%init ( &
            var_str ("generator_name"), &
            .true.)
       allocate (eio%tag_gen_v)
       call eio%tag_gen_v%init ( &
            var_str ("generator_version"), &
            .true.)
    end select
    select case (eio%version)
    case ("2.0", "3.0")
       allocate (eio%tag_generator)
       call eio%tag_generator%init ( &
            var_str ("generator"), &
            [xml_attribute (var_str ("version"), var_str ("<<Version>>"))], &
            .true.)
       allocate (eio%tag_xsecinfo)
       call eio%tag_xsecinfo%init ( &
            var_str ("xsecinfo"), &
            [xml_attribute (var_str ("neve"), str (data%n_evt)), &
             xml_attribute (var_str ("totxsec"), &
                            str (data%total_cross_section * pb_per_fb))])
    end select
    select case (eio%version)
    case ("2.0")
       allocate (eio%tag_weight)
       call eio%tag_weight%init (var_str ("weight"), &
            [xml_attribute (var_str ("name"))])
       if (eio%write_sqme_ref) then
          allocate (eio%tag_sqme_ref)
          call eio%tag_sqme_ref%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_ref"))], &
               .true.)
       end if
       if (eio%write_sqme_prc) then
          allocate (eio%tag_sqme_prc)
          call eio%tag_sqme_prc%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_prc"))], &
               .true.)
       end if
       if (eio%n_alt > 0) then
          if (eio%write_sqme_alt) then
             allocate (eio%tag_sqme_alt (1))
             call eio%tag_sqme_alt(1)%init (var_str ("weight"), &
                  [xml_attribute (var_str ("name"), var_str ("sqme_alt"))], &
                  .true.)
          end if
          allocate (eio%tag_wgts_alt (1))
          call eio%tag_wgts_alt(1)%init (var_str ("weight"), &
               [xml_attribute (var_str ("name"), var_str ("wgts_alt"))], &
               .true.)
       end if
    case ("3.0")
       if (eio%write_sqme_ref) then
          allocate (eio%tag_sqme_ref)
          call eio%tag_sqme_ref%init (var_str ("weightinfo"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_ref"))])
       end if
       if (eio%write_sqme_prc) then
          allocate (eio%tag_sqme_prc)
          call eio%tag_sqme_prc%init (var_str ("weightinfo"), &
               [xml_attribute (var_str ("name"), var_str ("sqme_prc"))])
       end if
       if (eio%n_alt > 0) then
          if (eio%write_sqme_alt) then
             allocate (eio%tag_sqme_alt (eio%n_alt))
             do i = 1, eio%n_alt
                call eio%tag_sqme_alt(i)%init (var_str ("weightinfo"), &
                     [xml_attribute (var_str ("name"), &
                                     var_str ("sqme_alt") // str (i))])
             end do
          end if
          allocate (eio%tag_wgts_alt (eio%n_alt))
          do i = 1, eio%n_alt
             call eio%tag_wgts_alt(i)%init (var_str ("weightinfo"), &
                  [xml_attribute (var_str ("name"), &
                                  var_str ("wgts_alt") // str (i))])
          end do
       end if
       allocate (eio%tag_weightinfo)
       call eio%tag_weightinfo%init (var_str ("weightinfo"), &
            [xml_attribute (var_str ("name"))])
       allocate (eio%tag_weights)
       call eio%tag_weights%init (var_str ("weights"), .true.)
    end select
  end subroutine eio_lhef_init_tags
  
@ %def eio_lhef_init_tags
@ Initialize event writing.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_out => eio_lhef_init_out
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_out (eio, sample, data, success, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: u, i
    call eio%set_splitting (data)
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to LHEF file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    u = eio%unit
    open (u, file = char (eio%filename), &
         action = "write", status = "replace")
    call eio%write_header ()
    call heprup_init &
         (data%pdg_beam, &
          data%energy_beam, &
          n_processes = data%n_proc, &
          unweighted = data%unweighted, &
          negative_weights = data%negative_weights)	  	
    do i = 1, data%n_proc
       call heprup_set_process_parameters (i = i, &
            process_id = data%proc_num_id(i), &
            cross_section = data%cross_section(i), &
            error = data%error(i))
    end do
    call eio%tag_init%write (u);  write (u, *)
    call heprup_write_lhef (u)
    select case (eio%version)
    case ("2.0");  call eio%write_init_20 (data)
    case ("3.0");  call eio%write_init_30 (data)
    end select
    call eio%tag_init%close (u);  write (u, *)
    if (present (success))  success = .true.
  end subroutine eio_lhef_init_out
    
@ %def eio_lhef_init_out
@ Initialize event reading.  First read the LHEF tag and version, then
read the header and skip over its contents, then read the init block.
(We require the opening and closing tags of the init block to be placed
on separate lines without extra stuff.)

For input, we do not (yet?) support split event files.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: init_in => eio_lhef_init_in
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_init_in (eio, sample, data, success, extension)
    class(eio_lhef_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist, ok, closing
    type(event_sample_data_t) :: data_file
    type(string_t) :: string
    integer :: u
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from LHEF file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: LHEF file not found.")
    eio%reading = .true.
    u = eio%unit
    open (u, file = char (eio%filename), &
         action = "read", status = "old")
    call eio%cstream%init (u)
    call eio%read_header ()
    call eio%tag_init%read (eio%cstream, ok)
    if (.not. ok)  call err_init
    select case (eio%version)
    case ("1.0");  call eio%read_init_10 (data_file)
       call eio%tag_init%read_content (eio%cstream, string, closing)
       if (string /= "" .or. .not. closing)  call err_init
    case ("2.0");  call eio%read_init_20 (data_file)
    case ("3.0");  call eio%read_init_30 (data_file)
    end select
    call eio%merge_data (data, data_file)
    if (present (success))  success = .true.

  contains
    
    subroutine err_init
      call msg_fatal ("LHEF: syntax error in init tag")
    end subroutine err_init
      
  end subroutine eio_lhef_init_in
    
@ %def eio_lhef_init_in
@ Merge event sample data: we can check the data in the file against
our assumptions and set or reset parameters.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: merge_data => eio_merge_data
<<EIO LHEF: procedures>>=
  subroutine eio_merge_data (eio, data, data_file)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(inout) :: data
    type(event_sample_data_t), intent(in) :: data_file
    real, parameter :: tolerance = 1000 * epsilon (1._default)
    if (data%unweighted .neqv. data_file%unweighted)  call err_weights
    if (data%negative_weights .neqv. data_file%negative_weights) &
         call err_weights
    if (data%norm_mode /= data_file%norm_mode)  call err_norm
    if (data%n_beam /= data_file%n_beam)  call err_beams
    if (any (data%pdg_beam /= data_file%pdg_beam))  call err_beams
    if (any (abs ((data%energy_beam - data_file%energy_beam)) &
         > (data%energy_beam + data_file%energy_beam) * tolerance)) &
         call err_beams
    if (data%n_proc /= data_file%n_proc)  call err_proc
    if (any (data%proc_num_id /= data_file%proc_num_id))  call err_proc
    where (data%cross_section == 0)
       data%cross_section = data_file%cross_section
       data%error = data_file%error
    end where
    data%total_cross_section = sum (data%cross_section)
    if (data_file%n_evt > 0) then
       if (data%n_evt > 0 .and. data_file%n_evt /= data%n_evt)  call err_n_evt
       data%n_evt = data_file%n_evt
    end if
  contains
    subroutine err_weights
      call msg_fatal ("LHEF: mismatch in event weight properties")
    end subroutine err_weights
    subroutine err_norm
      call msg_fatal ("LHEF: mismatch in event normalization")
    end subroutine err_norm
    subroutine err_beams
      call msg_fatal ("LHEF: mismatch in beam properties")
    end subroutine err_beams
    subroutine err_proc
      call msg_fatal ("LHEF: mismatch in process definitions")
    end subroutine err_proc
    subroutine err_n_evt
      call msg_error ("LHEF: mismatch in specified number of events (ignored)")
    end subroutine err_n_evt
  end subroutine eio_merge_data
    
@ %def eio_merge_data
@ Switch from input to output: reopen the file for reading.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: switch_inout => eio_lhef_switch_inout
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_switch_inout (eio, success)
    class(eio_lhef_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("LHEF: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_lhef_switch_inout
  
@ %def eio_lhef_switch_inout
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: split_out => eio_lhef_split_out
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_split_out (eio)
    class(eio_lhef_t), intent(inout) :: eio
    integer :: u
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to LHEF file '", &
            char (eio%filename), "'"
       call msg_message ()
       call eio%write_footer ()
       u = eio%unit
       close (u)
       open (u, file = char (eio%filename), &
            action = "write", status = "replace")
       call eio%write_header ()
       call eio%tag_init%write (u);  write (u, *)
       call heprup_write_lhef (u)
       select case (eio%version)
       case ("2.0");  call eio%write_init_20 (eio%data)
       case ("3.0");  call eio%write_init_30 (eio%data)
       end select
       call eio%tag_init%close (u);  write (u, *)
    end if
  end subroutine eio_lhef_split_out
  
@ %def eio_lhef_split_out
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: output => eio_lhef_output
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_output (eio, event, i_prc, reading, pacify)
    class(eio_lhef_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    if (eio%writing) then
       call hepeup_from_event (event, &
            process_index = eio%proc_num_id (i_prc), &
            keep_beams = eio%keep_beams)
       write (u, '(A)') "<event>"
       call hepeup_write_lhef (eio%unit)
       select case (eio%version)
       case ("2.0");  call eio%write_event_20 (event)
       case ("3.0");  call eio%write_event_30 (event)
       end select
       write (u, '(A)') "</event>"
    else
       call eio%write ()
       call msg_fatal ("LHEF file is not open for writing")
    end if
  end subroutine eio_lhef_output

@ %def eio_lhef_output
@ Input an event.  Upon input of [[i_prc]], we can just read in the
whole HEPEUP common block.  These data are known to come first.  The
[[i_prc]] value can be deduced from the IDPRUP value by a table
lookup.

Reading the common block bypasses the [[cstream]] which accesses the
input unit.  This is consistent with the LHEF specification.  After
the common-block data have been swallowed, we can resume reading from
stream.

We don't catch actual I/O errors.  However, we return a negative value in
[[iostat]] if we reached the terminating [[</LesHouchesEvents>]] tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: input_i_prc => eio_lhef_input_i_prc
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_input_i_prc (eio, i_prc, iostat)
    class(eio_lhef_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    integer :: i, proc_num_id
    type(string_t) :: s
    logical :: ok
    iostat = 0
    call eio%tag_lhef%read_content (eio%cstream, s, ok)
    if (ok) then
       if (s == "") then
          iostat = -1
       else
          call err_close
       end if
       return
    else
       call eio%cstream%revert_record (s)
    end if
    call eio%tag_event%read (eio%cstream, ok)
    if (.not. ok) then
       call err_evt1
       return
    end if
    call hepeup_read_lhef (eio%unit)
    call hepeup_get_event_parameters (proc_id = proc_num_id)
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_close
      call msg_error ("LHEF: reading events: syntax error in closing tag")
      iostat = 1
    end subroutine
    subroutine err_evt1
      call msg_error ("LHEF: reading events: invalid event tag, &
           &aborting read")
      iostat = 2
    end subroutine err_evt1
    subroutine err_index
      call msg_error ("LHEF: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 3
    end subroutine err_index
  end subroutine eio_lhef_input_i_prc

@ %def eio_lhef_input_i_prc
@ Since we have already read the event information from file, this
input routine can transfer the common-block contents to the event
record.  Also, we read any further information in the event record.

Since LHEF doesn't give this information, we must assume that the MCI
group, term, and channel can all be safely set to 1.  This works if
there is only one MCI group and term.  The channel doesn't matter for
the matrix element.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: input_event => eio_lhef_input_event
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_input_event (eio, event, iostat)
    class(eio_lhef_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    type(string_t) :: s
    logical :: closing
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    call hepeup_to_event (event, eio%fallback_model, &
         recover_beams = eio%recover_beams)
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if
    select case (eio%version)
    case ("1.0")
       call eio%tag_event%read_content (eio%cstream, s, closing = closing)
       if (s /= "" .or. .not. closing)  call err_evt2
    case ("2.0");  call eio%read_event_20 (event)
    case ("3.0");  call eio%read_event_30 (event)
    end select
  contains
    subroutine err_evt2
      call msg_error ("LHEF: reading events: syntax error in event record, &
           &aborting read")
      iostat = 2
    end subroutine err_evt2

  end subroutine eio_lhef_input_event

@ %def eio_lhef_input_event
@ 
\subsection{Les Houches Event File: header/footer}
These two routines write the header and footer for the Les Houches
Event File format (LHEF).

The current version writes no information except for the generator
name and version (v.1.0 only).
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_header => eio_lhef_write_header
  procedure :: write_footer => eio_lhef_write_footer
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_header (eio)
    class(eio_lhef_t), intent(in) :: eio
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    call eio%tag_lhef%write (u);  write (u, *)
    call eio%tag_head%write (u);  write (u, *)
    select case (eio%version)
    case ("1.0")
       write (u, "(2x)", advance = "no")
       call eio%tag_gen_n%write (var_str ("WHIZARD"), u)
       write (u, *)
       write (u, "(2x)", advance = "no")
       call eio%tag_gen_v%write (var_str ("<<Version>>"), u)
       write (u, *)
    end select
    call eio%tag_head%close (u);  write (u, *)
  end subroutine eio_lhef_write_header

  subroutine eio_lhef_write_footer (eio)
    class(eio_lhef_t), intent(in) :: eio
    integer :: u
    u = given_output_unit (eio%unit);  if (u < 0)  return
    call eio%tag_lhef%close (u)
  end subroutine eio_lhef_write_footer

@ %def eio_lhef_write_header eio_lhef_write_footer
@ Reading the header just means finding the tags and ignoring any
contents.  When done, we should stand just after the header tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_header => eio_lhef_read_header
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_header (eio)
    class(eio_lhef_t), intent(inout) :: eio
    logical :: success, closing
    type(string_t) :: content
    call eio%tag_lhef%read (eio%cstream, success)
    if (.not. success .or. .not. eio%tag_lhef%has_content)  call err_lhef
    if (eio%tag_lhef%get_attribute (1) /= eio%version)  call err_version
    call eio%tag_head%read (eio%cstream, success)
    if (.not. success)  call err_header
    if (eio%tag_head%has_content) then
       SKIP_HEADER_CONTENT: do
          call eio%tag_head%read_content (eio%cstream, content, closing)
          if (closing)  exit SKIP_HEADER_CONTENT
       end do SKIP_HEADER_CONTENT
    end if
  contains
    subroutine err_lhef
      call msg_fatal ("LHEF: LesHouchesEvents tag absent or corrupted")
    end subroutine err_lhef
    subroutine err_header
      call msg_fatal ("LHEF: header tag absent or corrupted")
    end subroutine err_header
    subroutine err_version
       call msg_error ("LHEF: version mismatch: expected " &
            // eio%version // ", found " &
            // char (eio%tag_lhef%get_attribute (1)))
    end subroutine err_version
  end subroutine eio_lhef_read_header

@ %def eio_lhef_read_header
@
\subsection{Version-Specific Code: 1.0}
In version 1.0, the init tag contains just HEPRUP data.  While a
[[cstream]] is connected to the input unit, we bypass it temporarily
for the purpose of reading the HEPRUP contents.  This is consistent
with the LHEF standard.

This routine does not read the closing tag of the init block.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_10 => eio_lhef_read_init_10
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_10 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(out) :: data
    integer :: n_proc, i
    call heprup_read_lhef (eio%unit)
    call heprup_get_run_parameters (n_processes = n_proc)
    call data%init (n_proc)
    data%n_beam = 2
    call heprup_get_run_parameters ( &
         unweighted = data%unweighted, &
         negative_weights = data%negative_weights, &
         beam_pdg = data%pdg_beam, &
         beam_energy = data%energy_beam)
    if (data%unweighted) then
       data%norm_mode = NORM_UNIT
    else
       data%norm_mode = NORM_SIGMA
    end if
    do i = 1, n_proc
       call heprup_get_process_parameters (i, &
            process_id = data%proc_num_id(i), &
            cross_section = data%cross_section(i), &
            error = data%error(i))
    end do
  end subroutine eio_lhef_read_init_10
  
@ %def eio_lhef_read_init_10
@
\subsection{Version-Specific Code: 2.0}
This is the init information for the 2.0 format, after the HEPRUP
data.  We have the following tags:
\begin{itemize}
\item \texttt{generator}  Generator name and version.
\item \texttt{xsecinfo}  Cross section and weights data.  We have the
  total cross section and number of events (assuming that the event
  file is intact), but information on minimum and maximum weights is
  not available before the file is complete.  We just write the
  mandatory tags.  (Note that the default values of the other tags
  describe a uniform unit weight, but we can determine most values
  only after the sample is complete.)
\item \texttt{cutsinfo}  This optional tag is too specific to represent the
  possibilities of WHIZARD, so we skip it.
\item \texttt{procinfo}  This optional tag is useful for giving
  details of NLO calculations.  Skipped.
\item \texttt{mergetype}  Optional, also not applicable.
\end{itemize}
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_init_20 => eio_lhef_write_init_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_init_20 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    integer :: u
    u = eio%unit
    call eio%tag_generator%write (u)
    write (u, "(A)", advance="no")  "WHIZARD"
    call eio%tag_generator%close (u);  write (u, *)
    call eio%tag_xsecinfo%write (u);  write (u, *)
  end subroutine eio_lhef_write_init_20
    
@ %def eio_lhef_write_init_20
@ When reading the init block, we first call the 1.0 routine that
fills HEPRUP.  Then we consider the possible tags.  Only the
\texttt{generator} and \texttt{xsecinfo} tags are of interest.  We
skip everything else except for the closing tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_20 => eio_lhef_read_init_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_20 (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(out) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    type(string_t) :: content
    logical :: found, closing
    call eio_lhef_read_init_10 (eio, data)
    SCAN_INIT_TAGS: do
       call eio%tag_generator%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_generator%has_content)  call err_generator
          call eio%tag_generator%read_content (eio%cstream, content, closing)
          call msg_message ("LHEF: Event file has been generated by " &
               // char (content) // " " &
               // char (eio%tag_generator%get_attribute (1)))
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_xsecinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_xsecinfo%has_content)  call err_xsecinfo
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_init%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_init
          exit SCAN_INIT_TAGS
       end if
    end do SCAN_INIT_TAGS
    data%n_evt = &
         read_ival (eio%tag_xsecinfo%get_attribute (1))
    data%total_cross_section = &
         read_rval (eio%tag_xsecinfo%get_attribute (2)) / pb_per_fb
  contains
    subroutine err_generator
      call msg_fatal ("LHEF: invalid generator tag")
    end subroutine err_generator
    subroutine err_xsecinfo
      call msg_fatal ("LHEF: invalid xsecinfo tag")
    end subroutine err_xsecinfo
    subroutine err_init
      call msg_fatal ("LHEF: syntax error after init tag")
    end subroutine err_init
  end subroutine eio_lhef_read_init_20
  
@ %def eio_lhef_read_init_20
@ This is additional event-specific information for the 2.0 format,
after the HEPEUP data.  We can specify weights, starting from the
master weight and adding alternative weights.  The alternative weights
are collected in a common tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_event_20 => eio_lhef_write_event_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_event_20 (eio, event)
    class(eio_lhef_t), intent(in) :: eio
    class(generic_event_t), intent(in) :: event
    type(string_t) :: s
    integer :: i, u
    u = eio%unit
    if (eio%write_sqme_ref) then
       s = str (event%get_sqme_ref ())
       call eio%tag_sqme_ref%write (s, u);  write (u, *)
    end if
    if (eio%write_sqme_prc) then
       s = str (event%get_sqme_prc ())
       call eio%tag_sqme_prc%write (s, u);  write (u, *)
    end if
    if (eio%n_alt > 0) then
       if (eio%write_sqme_alt) then
          s = str (event%get_sqme_alt(1))
          do i = 2, eio%n_alt
             s = s // " " // str (event%get_sqme_alt(i));  write (u, *)
          end do
          call eio%tag_sqme_alt(1)%write (s, u)
       end if
       s = str (event%get_weight_alt(1))
       do i = 2, eio%n_alt
          s = s // " " // str (event%get_weight_alt(i));  write (u, *)
       end do
       call eio%tag_wgts_alt(1)%write (s, u)
    end if
  end subroutine eio_lhef_write_event_20
    
@ %def eio_lhef_write_event_20
@ Read extra event data.  If there is a weight entry labeled [[sqme_prc]], we
take this as the squared matrix-element value (the new
\emph{reference} value [[sqme_ref]]). Other tags, including
tags written by the above writer, are skipped.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_event_20 => eio_lhef_read_event_20
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_event_20 (eio, event)
    class(eio_lhef_t), intent(inout) :: eio
    class(generic_event_t), intent(inout) :: event
    type(string_t) :: content
    logical :: found, closing
    SCAN_EVENT_TAGS: do
       call eio%tag_weight%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_weight%has_content)  call err_weight
          call eio%tag_weight%read_content (eio%cstream, content, closing)
          if (.not. closing)  call err_weight
          if (eio%tag_weight%get_attribute (1) == "sqme_prc") then
             call event%set_sqme_ref (read_rval (content))
          end if
          cycle SCAN_EVENT_TAGS
       end if
       call eio%tag_event%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_event
          exit SCAN_EVENT_TAGS
       end if
    end do SCAN_EVENT_TAGS
  contains
    subroutine err_weight
      call msg_fatal ("LHEF: invalid weight tag in event record")
    end subroutine err_weight
    subroutine err_event
      call msg_fatal ("LHEF: syntax error after event tag")
    end subroutine err_event
  end subroutine eio_lhef_read_event_20
    
@ %def eio_lhef_read_event_20
@
\subsection{Version-Specific Code: 3.0}
This is the init information for the 3.0 format, after the HEPRUP
data.  We have the following tags:
\begin{itemize}
\item \texttt{generator}  Generator name and version.
\item \texttt{xsecinfo}  Cross section and weights data.  We have the
  total cross section and number of events (assuming that the event
  file is intact), but information on minimum and maximum weights is
  not available before the file is complete.  We just write the
  mandatory tags.  (Note that the default values of the other tags
  describe a uniform unit weight, but we can determine most values
  only after the sample is complete.)
\item \texttt{cutsinfo}  This optional tag is too specific to represent the
  possibilities of WHIZARD, so we skip it.
\item \texttt{procinfo}  This optional tag is useful for giving
  details of NLO calculations.  Skipped.
\item \texttt{weightinfo}  Determine the meaning of optional weights, whose
  values are given in the event record.
\end{itemize}
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_init_30 => eio_lhef_write_init_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_init_30 (eio, data)
    class(eio_lhef_t), intent(in) :: eio
    type(event_sample_data_t), intent(in) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    integer :: u, i
    u = given_output_unit (eio%unit)
    call eio%tag_generator%write (u)
    write (u, "(A)", advance="no")  "WHIZARD"
    call eiO%tag_generator%close (u);  write (u, *)
    call eio%tag_xsecinfo%write (u);  write (u, *)
    if (eio%write_sqme_ref) then
       call eio%tag_sqme_ref%write (u);  write (u, *)
    end if
    if (eio%write_sqme_prc) then
       call eio%tag_sqme_prc%write (u);  write (u, *)
    end if
    if (eio%write_sqme_alt) then
       do i = 1, eio%n_alt
          call eio%tag_sqme_alt(i)%write (u);  write (u, *)
       end do
    end if
    do i = 1, eio%n_alt
       call eio%tag_wgts_alt(i)%write (u);  write (u, *)
    end do
  end subroutine eio_lhef_write_init_30
    
@ %def eio_lhef_write_init_30
@ When reading the init block, we first call the 1.0 routine that
fills HEPRUP.  Then we consider the possible tags.  Only the
\texttt{generator} and \texttt{xsecinfo} tags are of interest.  We
skip everything else except for the closing tag.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_init_30 => eio_lhef_read_init_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_init_30 (eio, data)
    class(eio_lhef_t), intent(inout) :: eio
    type(event_sample_data_t), intent(out) :: data
    real(default), parameter :: pb_per_fb = 1.e-3_default
    type(string_t) :: content
    logical :: found, closing
    integer :: n_weightinfo
    call eio_lhef_read_init_10 (eio, data)
    n_weightinfo = 0
    eio%i_weight_sqme = 0
    SCAN_INIT_TAGS: do
       call eio%tag_generator%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_generator%has_content)  call err_generator
          call eio%tag_generator%read_content (eio%cstream, content, closing)
          call msg_message ("LHEF: Event file has been generated by " &
               // char (content) // " " &
               // char (eio%tag_generator%get_attribute (1)))
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_xsecinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_xsecinfo%has_content)  call err_xsecinfo
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_weightinfo%read (eio%cstream, found)
       if (found) then
          if (eio%tag_weightinfo%has_content)  call err_xsecinfo
          n_weightinfo = n_weightinfo + 1
          if (eio%tag_weightinfo%get_attribute (1) == "sqme_prc") then
             eio%i_weight_sqme = n_weightinfo
          end if
          cycle SCAN_INIT_TAGS
       end if
       call eio%tag_init%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_init
          exit SCAN_INIT_TAGS
       end if
    end do SCAN_INIT_TAGS
    data%n_evt = &
         read_ival (eio%tag_xsecinfo%get_attribute (1))
    data%total_cross_section = &
         read_rval (eio%tag_xsecinfo%get_attribute (2)) / pb_per_fb
  contains
    subroutine err_generator
      call msg_fatal ("LHEF: invalid generator tag")
    end subroutine err_generator
    subroutine err_xsecinfo
      call msg_fatal ("LHEF: invalid xsecinfo tag")
    end subroutine err_xsecinfo
    subroutine err_init
      call msg_fatal ("LHEF: syntax error after init tag")
    end subroutine err_init
  end subroutine eio_lhef_read_init_30
  
@ %def eio_lhef_read_init_30
@ This is additional event-specific information for the 3.0 format,
after the HEPEUP data.  We can specify weights, starting from the
master weight and adding alternative weights.  The weight tags are
already allocated, so we just have to transfer the weight values to
strings, assemble them and write them to file.  All weights are
collected in a single tag.

Note: If efficiency turns out to be an issue, we may revert to
traditional character buffer writing.  However, we need to know the
maximum length.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: write_event_30 => eio_lhef_write_event_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_write_event_30 (eio, event)
    class(eio_lhef_t), intent(in) :: eio
    class(generic_event_t), intent(in) :: event
    type(string_t) :: s
    integer :: u, i
    u = eio%unit
    s = ""
    if (eio%write_sqme_ref) then
       s = s // str (event%get_sqme_ref ()) // " "
    end if
    if (eio%write_sqme_prc) then
       s = s // str (event%get_sqme_prc ()) // " "
    end if
    if (eio%n_alt > 0) then
       if (eio%write_sqme_alt) then
          s = s // str (event%get_sqme_alt(1)) // " "
          do i = 2, eio%n_alt
             s = s // str (event%get_sqme_alt(i)) // " "
          end do
       end if
       s = s // str (event%get_weight_alt(1)) // " "
       do i = 2, eio%n_alt
          s = s // str (event%get_weight_alt(i)) // " "
       end do
    end if
    if (len_trim (s) > 0) then
       call eio%tag_weights%write (trim (s), u);  write (u, *)
    end if
  end subroutine eio_lhef_write_event_30
    
@ %def eio_lhef_write_event_30
@ Read extra event data.  If there is a [[weights]] tag and if there
was a [[weightinfo]] entry labeled [[sqme_prc]], we extract the
corresponding entry from the weights string and store this as the
event's  squared matrix-element value.  Other tags, including
tags written by the above writer, are skipped.
<<EIO LHEF: eio lhef: TBP>>=
  procedure :: read_event_30 => eio_lhef_read_event_30
<<EIO LHEF: procedures>>=
  subroutine eio_lhef_read_event_30 (eio, event)
    class(eio_lhef_t), intent(inout) :: eio
    class(generic_event_t), intent(inout) :: event
    type(string_t) :: content, string
    logical :: found, closing
    integer :: i
    SCAN_EVENT_TAGS: do
       call eio%tag_weights%read (eio%cstream, found)
       if (found) then
          if (.not. eio%tag_weights%has_content)  call err_weights
          call eio%tag_weights%read_content (eio%cstream, content, closing)
          if (.not. closing)  call err_weights
          if (eio%i_weight_sqme > 0) then
             SCAN_WEIGHTS: do i = 1, eio%i_weight_sqme
                call split (content, string, " ")
                content = adjustl (content)
                if (i == eio%i_weight_sqme) then
                   call event%set_sqme_ref (read_rval (string))
                   exit SCAN_WEIGHTS
                end if
             end do SCAN_WEIGHTS
          end if
          cycle SCAN_EVENT_TAGS
       end if
       call eio%tag_event%read_content (eio%cstream, content, closing)
       if (closing) then
          if (content /= "")  call err_event
          exit SCAN_EVENT_TAGS
       end if
    end do SCAN_EVENT_TAGS
  contains
    subroutine err_weights
      call msg_fatal ("LHEF: invalid weights tag in event record")
    end subroutine err_weights
    subroutine err_event
      call msg_fatal ("LHEF: syntax error after event tag")
    end subroutine err_event
  end subroutine eio_lhef_read_event_30
    
@ %def eio_lhef_read_event_30
@
\subsection{Unit tests}
<<EIO LHEF: public>>=
  public :: eio_lhef_test
<<EIO LHEF: tests>>=
  subroutine eio_lhef_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO LHEF: execute tests>>
  end subroutine eio_lhef_test
  
@ %def eio_lhef_test 
@
\subsubsection{Version 1.0 Output}
We test the implementation of all I/O methods.  We start with output
according to version 1.0.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_1, "eio_lhef_1", &
       "write version 1.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_1"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)

    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_1"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // "." // eio%extension), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters ()
    end select
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_1"
    
  end subroutine eio_lhef_1
  
@ %def eio_lhef_1
@
\subsubsection{Version 2.0 Output}
Version 2.0 has added a lot of options to the LHEF format.  We
implement some of them.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_2, "eio_lhef_2", &
       "write version 2.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_2"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)

    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_2"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "2.0", write_sqme_prc = .true.)
    end select
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])


    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // "." // eio%extension), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:10) == "<generator")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_2"
    
  end subroutine eio_lhef_2
  
@ %def eio_lhef_2
@
\subsubsection{Version 3.0 Output}
Version 3.0 is an update which removes some tags (which we didn't use anyway)
and suggests a new treatment of weights.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_3, "eio_lhef_3", &
       "write version 3.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_3 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_lhef_3"
    write (u, "(A)")  "*   Purpose: generate an event and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted = .false.)

    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lhef_3"
    
    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "3.0", write_sqme_prc = .true.)
    end select
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])


    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".lhe"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:10) == "<generator")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_3"
    
  end subroutine eio_lhef_3
  
@ %def eio_lhef_3
@
\subsubsection{Version 1.0 Input}
Check input of a version-1.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_4, "eio_lhef_4", &
       "read version 1.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_4 (u)
    integer, intent(in) :: u
    class(model_data_t), pointer :: fallback_model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_4"
    write (u, "(A)")  "*   Purpose: read a LHEF 1.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_4"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="1.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '  <arbitrary_tag opt="foo">content</arbitrary_tag>'
    write (u_file, "(A)")  '  Text'
    write (u_file, "(A)")  '  <another_tag />'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         & -1 -1 -1 -1 3 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 1.0000000000E+00 42'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         & -1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00  0.0000000000E+00 &
         & 4.8412291828E+02  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00  0.0000000000E+00 &
         &-4.8412291828E+02  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 -4.6042825611E+02 &
         & 0.0000000000E+00  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02  4.6042825611E+02 &
         & 0.0000000000E+00  5.0000000000E+02  1.2500000000E+02 &
         & 0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)
    

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event, unweighted = .false.)

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()

    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_4"
    
  end subroutine eio_lhef_4
  
@ %def eio_lhef_4
@
\subsubsection{Version 2.0 Input}
Check input of a version-2.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_5, "eio_lhef_5", &
       "read version 2.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_5 (u)
    integer, intent(in) :: u
    class(model_data_t), pointer :: fallback_model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_5"
    write (u, "(A)")  "*   Purpose: read a LHEF 2.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_5"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="2.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         &-1 -1 -1 -1 4 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 0.0000000000E+00 42'
    write (u_file, "(A)")  '<generator version="2.2.3">WHIZARD&
         &</generator>'
    write (u_file, "(A)")  '<xsecinfo neve="1" totxsec="1.0000000000E-01" />'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         &-1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00  4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00 -4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 &
         &-4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02 &
         & 4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '<weight name="sqme_prc">1.0000000000E+00</weight>'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event, unweighted = .false.)

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "2.0", recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()

    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_5"
    
  end subroutine eio_lhef_5
  
@ %def eio_lhef_5
@
\subsubsection{Version 3.0 Input}
Check input of a version-3.0 conforming LHEF file.
<<EIO LHEF: execute tests>>=
  call test (eio_lhef_6, "eio_lhef_6", &
       "read version 3.0", &
       u, results)
<<EIO LHEF: tests>>=
  subroutine eio_lhef_6 (u)
    integer, intent(in) :: u
    class(model_data_t), pointer :: fallback_model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lhef_6"
    write (u, "(A)")  "*   Purpose: read a LHEF 3.0 file"
    write (u, "(A)")

    write (u, "(A)")  "* Write a LHEF data file"
    write (u, "(A)")
 
    u_file = free_unit ()
    sample = "eio_lhef_6"
    open (u_file, file = char (sample // ".lhe"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  '<LesHouchesEvents version="3.0">'
    write (u_file, "(A)")  '<header>'
    write (u_file, "(A)")  '</header>'
    write (u_file, "(A)")  '<init>'
    write (u_file, "(A)")  ' 25 25  5.0000000000E+02  5.0000000000E+02 &
         &-1 -1 -1 -1 4 1'
    write (u_file, "(A)")  '  1.0000000000E-01  1.0000000000E-03 &
         & 0.0000000000E+00 42'
    write (u_file, "(A)")  '<generator version="2.2.3">WHIZARD&
         &</generator>'
    write (u_file, "(A)")  '<xsecinfo neve="1" totxsec="1.0000000000E-01" />'
    write (u_file, "(A)")  '<weightinfo name="sqme_prc" />'
    write (u_file, "(A)")  '</init>'
    write (u_file, "(A)")  '<event>'
    write (u_file, "(A)")  ' 4 42  3.0574068604E+08  1.0000000000E+03 &
         &-1.0000000000E+00 -1.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00  4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 -1 0 0 0 0  0.0000000000E+00 &
         & 0.0000000000E+00 -4.8412291828E+02  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0 -1.4960220911E+02 &
         &-4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  ' 25 1 1 2 0 0  1.4960220911E+02 &
         & 4.6042825611E+02  0.0000000000E+00  5.0000000000E+02 &
         & 1.2500000000E+02  0.0000000000E+00  9.0000000000E+00'
    write (u_file, "(A)")  '<weights>1.0000000000E+00</weights>'
    write (u_file, "(A)")  '</event>'
    write (u_file, "(A)")  '</LesHouchesEvents>'
    close (u_file)

    write (u, "(A)")  "* Initialize test process"
    write (u, "(A)")

    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event, unweighted = .false.)

    allocate (eio_lhef_t :: eio)
    select type (eio)
    type is (eio_lhef_t)
       call eio%set_parameters (version = "3.0", recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%unweighted = .false.
    data%norm_mode = NORM_SIGMA
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)

    write (u, "(A)")  "* Initialize and read header"
    write (u, "(A)")

    call eio%init_in (sample, data)
    call eio%write (u)
    
    write (u, *)
    
    select type (eio)
    type is (eio_lhef_t)
       call eio%tag_lhef%write (u);  write (u, *)
    end select

    write (u, *)
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    
    select type (eio)
    type is (eio_lhef_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
   
    call eio%input_event (event, iostat)

    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")

    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()

    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lhef_6"
    
  end subroutine eio_lhef_6
  
@ %def eio_lhef_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{STDHEP File Formats}
Here, we implement the two existing STDHEP file formats, one based on the
HEPRUP/HEPEUP common blocks, the other based on the HEPEVT common block.
The second one is actually the standard STDHEP format.
<<[[eio_stdhep.f90]]>>=
<<File header>>

module eio_stdhep
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use model_data
  use particles
  use event_base
  use hep_common
  use hep_events
  use eio_data
  use eio_base

<<Standard module head>>

<<EIO stdhep: public>>

<<EIO stdhep: types>>

<<EIO stdhep: variables>>

contains
  
<<EIO stdhep: procedures>>

<<EIO stdhep: tests>>

end module eio_stdhep
@ %def eio_stdhep
@
\subsection{Type}
<<EIO stdhep: public>>=
  public :: eio_stdhep_t
<<EIO stdhep: types>>=
  type, abstract, extends (eio_t) :: eio_stdhep_t
     logical :: writing = .false.
     logical :: reading = .false.
     integer :: unit = 0
     logical :: keep_beams = .false.     
     integer(i64) :: n_events_expected = 0
   contains
   <<EIO stdhep: eio stdhep: TBP>>
  end type eio_stdhep_t
  
@ %def eio_stdhep_t
@
<<EIO stdhep: public>>=
  public :: eio_stdhep_hepevt_t
<<EIO stdhep: types>>=
  type, extends (eio_stdhep_t) :: eio_stdhep_hepevt_t
  end type eio_stdhep_hepevt_t
  
@ %def eio_stdhep_hepevt_t
@
<<EIO stdhep: public>>=
  public :: eio_stdhep_hepeup_t
<<EIO stdhep: types>>=
  type, extends (eio_stdhep_t) :: eio_stdhep_hepeup_t
  end type eio_stdhep_hepeup_t
  
@ %def eio_stdhep_hepeup_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with STDHEP file formats.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: set_parameters => eio_stdhep_set_parameters
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_set_parameters (eio, keep_beams, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    type(string_t), intent(in), optional :: extension
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (extension)) then
       eio%extension = extension
    else
       select type (eio)
       type is (eio_stdhep_hepevt_t)
          eio%extension = "hep"
       type is (eio_stdhep_hepeup_t)
          eio%extension = "up.hep"
       end select
    end if
  end subroutine eio_stdhep_set_parameters
  
@ %def eio_ascii_stdhep_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: write => eio_stdhep_write
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_write (object, unit)
    class(eio_stdhep_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "STDHEP event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
  end subroutine eio_stdhep_write
  
@ %def eio_stdhep_write
@ Finalizer: close any open file.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: final => eio_stdhep_final
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_final (object)
    class(eio_stdhep_t), intent(inout) :: object
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing STDHEP file '", &
            char (object%filename), "'"
       call msg_message ()
       call stdhep_end
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing STDHEP file '", &
            char (object%filename), "'"
       call msg_message ()
       object%reading = .false.
    end if
  end subroutine eio_stdhep_final
  
@ %def eio_stdhep_final
@ Common initialization for input and output.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: common_init => eio_stdhep_common_init
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_common_init (eio, sample, data, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("STDHEP initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("STDHEP: defined for scattering processes only")
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()    
    eio%unit = free_unit ()    
  end subroutine eio_stdhep_common_init

@ %def eio_stdhep_common_init
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.  (We assume that
the common block contents are still intact.)
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: split_out => eio_stdhep_split_out
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_split_out (eio)
    class(eio_stdhep_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to STDHEP file '", &
            char (eio%filename), "'"
       call msg_message ()
       call stdhep_end
       select type (eio)
       type is (eio_stdhep_hepeup_t)
          call stdhep_init_out (char (eio%filename), &
               "WHIZARD event sample", eio%n_events_expected)
          call stdhep_write (STDHEP_HEPRUP)
       type is (eio_stdhep_hepevt_t)
          call stdhep_init_out (char (eio%filename), &
               "WHIZARD event sample", eio%n_events_expected) 
       end select
    end if
  end subroutine eio_stdhep_split_out
  
@ %def eio_stdhep_split_out
@ Initialize event writing.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: init_out => eio_stdhep_init_out
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_init_out (eio, sample, data, success, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    integer :: i
    if (.not. present (data)) &
         call msg_bug ("STDHEP initialization: missing data")        
    eio%sample = sample
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    eio%n_events_expected = data%n_evt
    write (msg_buffer, "(A,A,A)")  "Events: writing to STDHEP file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call heprup_init &
            (data%pdg_beam, &
            data%energy_beam, &
            n_processes = data%n_proc, &
            unweighted = data%unweighted, &
            negative_weights = data%negative_weights)	  	
       do i = 1, data%n_proc
          call heprup_set_process_parameters (i = i, &
               process_id = data%proc_num_id(i), &
               cross_section = data%cross_section(i), &
               error = data%error(i))          
       end do
       call stdhep_init_out (char (eio%filename), &
            "WHIZARD event sample", eio%n_events_expected)
       call stdhep_write (STDHEP_HEPRUP)
    type is (eio_stdhep_hepevt_t)
       call stdhep_init_out (char (eio%filename), &
            "WHIZARD event sample", eio%n_events_expected) 
    end select
    if (present (success))  success = .true.
  end subroutine eio_stdhep_init_out
    
@ %def eio_stdhep_init_out
@ Initialize event reading.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: init_in => eio_stdhep_init_in
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_init_in (eio, sample, data, success, extension)
    class(eio_stdhep_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    
    call msg_bug ("STDHEP: event input not supported")
    if (present (success))  success = .false.
  end subroutine eio_stdhep_init_in
    
@ %def eio_stdhep_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: switch_inout => eio_stdhep_switch_inout
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_switch_inout (eio, success)
    class(eio_stdhep_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("STDHEP: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_stdhep_switch_inout
  
@ %def eio_stdhep_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: output => eio_stdhep_output
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_output (eio, event, i_prc, reading, pacify)
    class(eio_stdhep_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    if (eio%writing) then
       select type (eio)
       type is (eio_stdhep_hepeup_t)
          call hepeup_from_event (event, &
               process_index = i_prc, &
               keep_beams = eio%keep_beams)
          call stdhep_write (STDHEP_HEPEUP)
       type is (eio_stdhep_hepevt_t)
          call hepevt_from_event (event, &
               i_evt = event%get_index (), &                         
               keep_beams = eio%keep_beams)
          call stdhep_write (STDHEP_HEPEVT)                              
       end select       
    else
       call eio%write ()
       call msg_fatal ("STDHEP file is not open for writing")
    end if
  end subroutine eio_stdhep_output

@ %def eio_stdhep_output
@ Input an event.
<<EIO stdhep: eio stdhep: TBP>>=
  procedure :: input_i_prc => eio_stdhep_input_i_prc
  procedure :: input_event => eio_stdhep_input_event
<<EIO stdhep: procedures>>=
  subroutine eio_stdhep_input_i_prc (eio, i_prc, iostat)
    class(eio_stdhep_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    call msg_bug ("STDHEP: event input not supported")
    i_prc = 0
    iostat = 1
  end subroutine eio_stdhep_input_i_prc

  subroutine eio_stdhep_input_event (eio, event, iostat)
    class(eio_stdhep_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    call msg_bug ("STDHEP: event input not supported")
    iostat = 1
  end subroutine eio_stdhep_input_event

@ %def eio_stdhep_input_i_prc
@ %def eio_stdhep_input_event
@ STDHEP speficic routines.
<<EIO stdhep: public>>=
  public :: stdhep_init_out
  public :: stdhep_init_in
  public :: stdhep_write 
  public :: stdhep_end  
<<EIO stdhep: procedures>>=
  subroutine stdhep_init_out (file, title, nevt)
    character(len=*), intent(in) :: file, title
    integer(i64), intent(in) :: nevt
    integer(i32) :: nevt32
    external stdxwinit, stdxwrt
    nevt32 = min (nevt, int (huge (1_i32), i64))
    call stdxwinit (file, title, nevt32, istr, lok)
    call stdxwrt (100, istr, lok)
  end subroutine stdhep_init_out

  subroutine stdhep_init_in (file, nevt)
    character(len=*), intent(in) :: file
    integer(i64), intent(in) :: nevt
    integer(i32) :: nevt32
    ! external stdx
  end subroutine stdhep_init_in
  
  subroutine stdhep_write (ilbl)
    integer, intent(in) :: ilbl
    external stdxwrt
    call stdxwrt (ilbl, istr, lok)
  end subroutine stdhep_write

  subroutine stdhep_read (ilbl, lok)
    integer, intent(out) :: ilbl
    logical, intent(out) :: lok
    external stdxrd
    call stdxrd (ilbl, istr, lok)
  end subroutine stdhep_read
  
  subroutine stdhep_end
    external stdxend, stdxwrt
    call stdxwrt (200, istr, lok)
    call stdxend (istr)
  end subroutine stdhep_end  
  
@  %def stdhep_init stdhep_read stdhep_write stdhep_end
@ 
\subsection{Variables}
<<EIO stdhep: variables>>=
  integer, save :: istr, lok
  integer, parameter :: &
       STDHEP_HEPEVT = 1, STDHEP_HEPEUP = 11, STDHEP_HEPRUP = 12
@ 
\subsection{Unit tests}
<<EIO stdhep: public>>=
  public :: eio_stdhep_test
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO stdhep: execute tests>>
  end subroutine eio_stdhep_test
  
@ %def eio_stdhep_test 
@
\subsubsection{Test I/O methods}
We test the implementation of the STDHEP HEPEVT I/O method:
<<EIO stdhep: execute tests>>=
  call test (eio_stdhep_1, "eio_stdhep_1", &
       "read and write event contents, format [stdhep]", &
       u, results)
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_stdhep_1"
    write (u, "(A)")  "*   Purpose: generate an event in STDHEP HEPEVT format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_stdhep_1"
 
    allocate (eio_stdhep_hepevt_t :: eio)
    select type (eio)
    type is (eio_stdhep_hepevt_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hep"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
    end do
    !!! JRR: WK please check: should be replaced by a XDR reader? (#530)
    !  write (u, "(A)") trim (buffer) 
    !  The number of lines is system-dependent!
    write (u, "(A)") "     Successfully read STDHEP HEPEVT file"    
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_stdhep_hepevt_t :: eio)
    
    select type (eio)
    type is (eio_stdhep_hepevt_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_stdhep_1"
    
  end subroutine eio_stdhep_1
  
@ %def eio_stdhep_1
@ 
We test the implementation of the STDHEP HEPEUP I/O method:
<<EIO stdhep: execute tests>>=
  call test (eio_stdhep_2, "eio_stdhep_2", &
       "read and write event contents, format [stdhep]", &
       u, results)
<<EIO stdhep: tests>>=
  subroutine eio_stdhep_2 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(model_data_t), pointer :: fallback_model
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: eio_stdhep_2"
    write (u, "(A)")  "*   Purpose: generate an event in STDHEP HEPEUP format"
    write (u, "(A)")  "*      and write weight to file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event, unweighted = .false.)
    
    call data%init (1)
    data%n_evt = 1
    data%n_beam = 2
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_stdhep_2"
 
    allocate (eio_stdhep_hepeup_t :: eio)
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call eio%set_parameters ()
    end select  
    call eio%set_fallback_model (fallback_model)
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char(sample // ".up.hep"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:21) == "  <generator_version>")  buffer = "[...]"
       if (iostat /= 0)  exit
    end do
    !!! JRR: WK please check: should be replaced by a XDR reader? (#530)
    !  write (u, "(A)") trim (buffer)
    !  The number of lines is system-dependent!    
    write (u, "(A)") "     Successfully read STDHEP HEPEUP file"    
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_stdhep_hepeup_t :: eio)
    
    select type (eio)
    type is (eio_stdhep_hepeup_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_stdhep_2"
    
  end subroutine eio_stdhep_2
  
@ %def eio_stdhep_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HepMC Output}
The HepMC event record is standardized.  It is an ASCII format.  We try
our best at using it for both input and output.
<<[[eio_hepmc.f90]]>>=
<<File header>>

module eio_hepmc
  
  use kinds
  use io_units
<<Use strings>>
  use string_utils
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use model_data
  use particles
  use subevents
  use event_base
  use hep_events
  use eio_data
  use eio_base
  use hepmc_interface

<<Standard module head>>

<<EIO HepMC: public>>

<<EIO HepMC: types>>

<<EIO HepMC: interfaces>>

contains
  
<<EIO HepMC: procedures>>

<<EIO HepMC: tests>>

end module eio_hepmc
@ %def eio_hepmc
@
\subsection{Type}
A type [[hepmc_event]] is introduced as container to store HepMC event
data, particularly for splitting the reading into read out of the process
index and the proper event data.
<<EIO HepMC: public>>=
  public :: eio_hepmc_t
<<EIO HepMC: types>>=
  type, extends (eio_t) :: eio_hepmc_t
     logical :: writing = .false.
     logical :: reading = .false.
     logical :: keep_beams = .false.
     logical :: recover_beams = .false.
     type(hepmc_iostream_t) :: iostream
     type(hepmc_event_t) :: hepmc_event
     integer, dimension(:), allocatable :: proc_num_id
   contains
   <<EIO HepMC: eio hepmc: TBP>>
  end type eio_hepmc_t
  
@ %def eio_hepmc_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with HepMC.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: set_parameters => eio_hepmc_set_parameters
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_set_parameters (eio, keep_beams, &
       recover_beams, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams 
    type(string_t), intent(in), optional :: extension    
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "hepmc"
    end if
  end subroutine eio_hepmc_set_parameters
  
@ %def eio_hepmc_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: write => eio_hepmc_write
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_write (object, unit)
    class(eio_hepmc_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "HepMC event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if    
  end subroutine eio_hepmc_write
  
@ %def eio_hepmc_write
@ Finalizer: close any open file.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: final => eio_hepmc_final
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_final (object)
    class(eio_hepmc_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing HepMC file '", &
            char (object%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (object%iostream)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing HepMC file '", &
            char (object%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (object%iostream)
       object%reading = .false.
    end if
  end subroutine eio_hepmc_final
  
@ %def eio_hepmc_final
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: split_out => eio_hepmc_split_out
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_split_out (eio)
    class(eio_hepmc_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to HepMC file '", &
            char (eio%filename), "'"
       call msg_message ()
       call hepmc_iostream_close (eio%iostream)
       call hepmc_iostream_open_out (eio%iostream, eio%filename)
    end if
  end subroutine eio_hepmc_split_out
  
@ %def eio_hepmc_split_out
@ Common initialization for input and output.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: common_init => eio_hepmc_common_init
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_common_init (eio, sample, data, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("HepMC initialization: missing data")
    if (data%n_beam /= 2) &
         call msg_fatal ("HepMC: defined for scattering processes only")    
    if (data%unweighted) then
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default; call msg_fatal &
            ("HepMC: normalization for unweighted events must be '1'")
       end select
    else
       call msg_fatal ("HepMC: events must be unweighted")    
    end if
    eio%sample = sample    
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_hepmc_common_init
  
@ %def eio_hepmc_common_init
@ Initialize event writing.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: init_out => eio_hepmc_init_out
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_init_out (eio, sample, data, success, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to HepMC file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    call hepmc_iostream_open_out (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_hepmc_init_out
    
@ %def eio_hepmc_init_out
@ Initialize event reading. For input, we do not (yet) support split
event files. 
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: init_in => eio_hepmc_init_in
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_init_in (eio, sample, data, success, extension)
    class(eio_hepmc_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from HepMC file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: HepMC file not found.")
    eio%reading = .true.
    call hepmc_iostream_open_in (eio%iostream, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_hepmc_init_in
    
@ %def eio_hepmc_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: switch_inout => eio_hepmc_switch_inout
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_switch_inout (eio, success)
    class(eio_hepmc_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("HepMC: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_hepmc_switch_inout
  
@ %def eio_hepmc_switch_inout
@ Output an event to the allocated HepMC output stream.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: output => eio_hepmc_output
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_output (eio, event, i_prc, reading, pacify)
    class(eio_hepmc_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    type(particle_set_t), pointer :: pset_ptr
    if (eio%writing) then
       pset_ptr => event%get_particle_set_ptr ()
       call hepmc_event_init (eio%hepmc_event, &
            proc_id = eio%proc_num_id (i_prc), &
            event_id = event%get_index ())
       call hepmc_event_from_particle_set (eio%hepmc_event, pset_ptr)
       call hepmc_event_set_scale (eio%hepmc_event, event%get_fac_scale ())
       call hepmc_event_set_alpha_qcd (eio%hepmc_event, event%get_alpha_s ())
       call hepmc_iostream_write_event (eio%iostream, eio%hepmc_event)
       call hepmc_event_final (eio%hepmc_event)
    else
       call eio%write ()
       call msg_fatal ("HepMC file is not open for writing")
    end if
  end subroutine eio_hepmc_output

@ %def eio_hepmc_output
@ Input an event.
<<EIO HepMC: eio hepmc: TBP>>=
  procedure :: input_i_prc => eio_hepmc_input_i_prc
  procedure :: input_event => eio_hepmc_input_event
<<EIO HepMC: procedures>>=
  subroutine eio_hepmc_input_i_prc (eio, i_prc, iostat)
    class(eio_hepmc_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    logical :: ok
    integer :: i, proc_num_id
    iostat = 0
    call hepmc_event_init (eio%hepmc_event)
    call hepmc_iostream_read_event (eio%iostream, eio%hepmc_event, ok)
    proc_num_id = hepmc_event_get_process_id (eio%hepmc_event)
    if (.not. ok) then 
       iostat = -1 
       return
    end if
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_index
      call msg_error ("HepMC: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 1
    end subroutine err_index
  end subroutine eio_hepmc_input_i_prc

  subroutine eio_hepmc_input_event (eio, event, iostat)
    class(eio_hepmc_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    logical :: ok    
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    call hepmc_to_event (event, eio%hepmc_event, eio%fallback_model, &
         recover_beams = eio%recover_beams) 
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if    
    call hepmc_event_final (eio%hepmc_event)
  end subroutine eio_hepmc_input_event

@ %def eio_hepmc_input_i_prc
@ %def eio_hepmc_input_event
@
\subsection{Unit tests}
<<EIO HepMC: public>>=
  public :: eio_hepmc_test
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO HepMC: execute tests>>
  end subroutine eio_hepmc_test
  
@ %def eio_hepmc_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO HepMC: execute tests>>=
  call test (eio_hepmc_1, "eio_hepmc_1", &
       "write event contents", &
       u, results)
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat
    character(116) :: buffer

    write (u, "(A)")  "* Test output: eio_hepmc_1"
    write (u, "(A)")  "*   Purpose: write a HepMC file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event, unweighted=.false.)

    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_hepmc_1"
 
    allocate (eio_hepmc_t :: eio)
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters ()
    end select
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* File contents (blanking out last two digits):"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = char (sample // ".hepmc"), &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       if (trim (buffer) == "")  cycle
       if (buffer(1:14) == "HepMC::Version")  cycle
       if (buffer(1:10) == "P 10001 25") &
            call buffer_blanker (buffer, 32, 55, 78)
       if (buffer(1:10) == "P 10002 25") &
            call buffer_blanker (buffer, 33, 56, 79)
       if (buffer(1:10) == "P 10003 25") &
            call buffer_blanker (buffer, 29, 53, 78, 101)
       if (buffer(1:10) == "P 10004 25") &
            call buffer_blanker (buffer, 28, 51, 76, 99)       
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_hepmc_t :: eio)
    
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_hepmc_1"
    
  contains
    
    subroutine buffer_blanker (buf, pos1, pos2, pos3, pos4)
      character(len=*), intent(inout) :: buf
      integer, intent(in) :: pos1, pos2, pos3
      integer, intent(in), optional :: pos4
      type(string_t) :: line
      line = var_str (trim (buf))
      line = replace (line, pos1, "XX")
      line = replace (line, pos2, "XX")
      line = replace (line, pos3, "XX")
      if (present (pos4)) then
         line = replace (line, pos4, "XX")
      end if
      line = replace (line, "4999999999999", "5000000000000")
      buf = char (line)
    end subroutine buffer_blanker
    
  end subroutine eio_hepmc_1
  
@ %def eio_hepmc_1
@ Test also the reading of HepMC events.
<<EIO HepMC: execute tests>>=
  call test (eio_hepmc_2, "eio_hepmc_2", &
       "read event contents", &
       u, results)
<<EIO HepMC: tests>>=
  subroutine eio_hepmc_2 (u)
    integer, intent(in) :: u
    class(model_data_t), pointer :: fallback_model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_hepmc_2"
    write (u, "(A)")  "*   Purpose: read a HepMC event"
    write (u, "(A)")

    write (u, "(A)")  "* Write a HepMC data file"
    write (u, "(A)")
    
    u_file = free_unit ()
    sample = "eio_hepmc_2"
    open (u_file, file = char (sample // ".hepmc"), &
         status = "replace", action = "readwrite")
    
    write (u_file, "(A)")  "HepMC::Version 2.06.09"
    write (u_file, "(A)")  "HepMC::IO_GenEvent-START_EVENT_LISTING"
    write (u_file, "(A)")  "E 0 -1 -1.0000000000000000e+00 &
         &-1.0000000000000000e+00 &
         &-1.0000000000000000e+00 42 0 1 10001 10002 0 0"
    write (u_file, "(A)")  "U GEV MM"
    write (u_file, "(A)")  "V -1 0 0 0 0 0 2 2 0"
    write (u_file, "(A)")  "P 10001 25 0 0 4.8412291827592713e+02 &
         &5.0000000000000000e+02 &
         &1.2499999999999989e+02 3 0 0 -1 0"
    write (u_file, "(A)")  "P 10002 25 0 0 -4.8412291827592713e+02 &
         &5.0000000000000000e+02 &
         &1.2499999999999989e+02 3 0 0 -1 0"
    write (u_file, "(A)")  "P 10003 25 -1.4960220911365536e+02 &
         &-4.6042825611414656e+02 &
         &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    write (u_file, "(A)")  "P 10004 25 1.4960220911365536e+02 &
         &4.6042825611414656e+02 &
         &0 5.0000000000000000e+02 1.2500000000000000e+02 1 0 0 0 0"
    write (u_file, "(A)")  "HepMC::IO_GenEvent-END_EVENT_LISTING"
    close (u_file)

    write (u, "(A)")  "* Initialize test process" 
    write (u, "(A)")
    
    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event, unweighted=.false.)

    allocate (eio_hepmc_t :: eio)
    select type (eio)
    type is (eio_hepmc_t)
       call eio%set_parameters (recover_beams = .false.)
    end select            
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)

    write (u, "(A)")    
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")
             
    call eio%init_in (sample, data)
    call eio%write (u)    
    
    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")
 
    call eio%input_i_prc (i_prc, iostat)

    select type (eio)
    type is (eio_hepmc_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
    
    call eio%input_event (event, iostat)
    
    call event%write (u)
        
    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")
    
    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()

    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_hepmc_2"
    
  end subroutine eio_hepmc_2
  
@ %def eio_hepmc_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LCIO Output}
The LCIO event record is standardized for the use with Linear $e^+e^-$
colliders. It is a binary event format.  We try our best at using it
for both input and output. 
<<[[eio_lcio.f90]]>>=
<<File header>>

module eio_lcio
  
  use kinds
  use io_units
<<Use strings>>
  use string_utils
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use model_data
  use particles
  use subevents
  use event_base
  use hep_events
  use eio_data
  use eio_base
  use lcio_interface

<<Standard module head>>

<<EIO LCIO: public>>

<<EIO LCIO: types>>

<<EIO LCIO: interfaces>>

contains
  
<<EIO LCIO: procedures>>

<<EIO LCIO: tests>>

end module eio_lcio
@ %def eio_lcio
@
\subsection{Type}
A type [[lcio_event]] is introduced as container to store LCIO event
data, particularly for splitting the reading into read out of the process
index and the proper event data.
<<EIO LCIO: public>>=
  public :: eio_lcio_t
<<EIO LCIO: types>>=
  type, extends (eio_t) :: eio_lcio_t
     logical :: writing = .false.
     logical :: reading = .false.
     logical :: keep_beams = .false.
     logical :: recover_beams = .false.
     type(lcio_writer_t) :: lcio_writer
     type(lcio_reader_t) :: lcio_reader
     type(lcio_run_header_t) :: lcio_run_hdr
     type(lcio_event_t) :: lcio_event
     integer, dimension(:), allocatable :: proc_num_id
   contains
   <<EIO LCIO: eio lcio: TBP>>
  end type eio_lcio_t
  
@ %def eio_lcio_t
@
\subsection{Specific Methods}
Set parameters that are specifically used with LCIO.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: set_parameters => eio_lcio_set_parameters
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_set_parameters (eio, keep_beams, &
       recover_beams, extension)
    class(eio_lcio_t), intent(inout) :: eio
    logical, intent(in), optional :: keep_beams
    logical, intent(in), optional :: recover_beams 
    type(string_t), intent(in), optional :: extension    
    if (present (keep_beams))  eio%keep_beams = keep_beams
    if (present (recover_beams))  eio%recover_beams = recover_beams
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "slcio"
    end if
  end subroutine eio_lcio_set_parameters
  
@ %def eio_lcio_set_parameters
@
\subsection{Common Methods}
Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: write => eio_lcio_write
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_write (object, unit)
    class(eio_lcio_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "LCIO event stream:"
    if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
    write (u, "(3x,A,L1)")    "Keep beams        = ", object%keep_beams
    write (u, "(3x,A,L1)")    "Recover beams     = ", object%recover_beams
    write (u, "(3x,A,A,A)")     "File extension    = '", &
         char (object%extension), "'"
    if (allocated (object%proc_num_id)) then
       write (u, "(3x,A)")  "Numerical process IDs:"
       do i = 1, size (object%proc_num_id)
          write (u, "(5x,I0,': ',I0)")  i, object%proc_num_id(i)
       end do
    end if    
  end subroutine eio_lcio_write
  
@ %def eio_lcio_write
@ Finalizer: close any open file.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: final => eio_lcio_final
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_final (object)
    class(eio_lcio_t), intent(inout) :: object
    if (allocated (object%proc_num_id))  deallocate (object%proc_num_id)
    if (object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LCIO file '", &
            char (object%filename), "'"
       call msg_message ()
       call lcio_writer_close (object%lcio_writer)
       object%writing = .false.
    else if (object%reading) then
       write (msg_buffer, "(A,A,A)")  "Events: closing LCIO file '", &
            char (object%filename), "'"
       call msg_message ()
       call lcio_reader_close (object%lcio_reader)
       object%reading = .false.
    end if
  end subroutine eio_lcio_final
  
@ %def eio_lcio_final
@ Split event file: increment the counter, close the current file, open a new
one.  If the file needs a header, repeat it for the new file.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: split_out => eio_lcio_split_out
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_split_out (eio)
    class(eio_lcio_t), intent(inout) :: eio
    if (eio%split) then
       eio%split_index = eio%split_index + 1
       call eio%set_filename ()
       write (msg_buffer, "(A,A,A)")  "Events: writing to LCIO file '", &
            char (eio%filename), "'"
       call msg_message ()
       call lcio_writer_close (eio%lcio_writer)
       call lcio_writer_open_out (eio%lcio_writer, eio%filename)       
    end if
  end subroutine eio_lcio_split_out
  
@ %def eio_lcio_split_out
@ Common initialization for input and output.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: common_init => eio_lcio_common_init
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_common_init (eio, sample, data, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    if (.not. present (data)) &
         call msg_bug ("LCIO initialization: missing data")
    !!! Is this really true?
    if (data%n_beam /= 2) &
         call msg_fatal ("LCIO: defined for scattering processes only")    
    if (data%unweighted) then
       !!! Check for this !
       select case (data%norm_mode)
       case (NORM_UNIT)
       case default; call msg_fatal &
            ("LCIO: normalization for unweighted events must be '1'")
       end select
    else
       !!! Check for this
       call msg_fatal ("LCIO: events must be unweighted")    
    end if
    eio%sample = sample    
    if (present (extension)) then
       eio%extension = extension
    end if
    call eio%set_filename ()
    allocate (eio%proc_num_id (data%n_proc), source = data%proc_num_id)
  end subroutine eio_lcio_common_init
  
@ %def eio_lcio_common_init
@ Initialize event writing.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: init_out => eio_lcio_init_out
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_init_out (eio, sample, data, success, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    call eio%set_splitting (data)    
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: writing to LCIO file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    call lcio_writer_open_out (eio%lcio_writer, eio%filename)
    call lcio_run_header_init (eio%lcio_run_hdr)
    call lcio_run_header_write (eio%lcio_writer, eio%lcio_run_hdr)
    if (present (success))  success = .true.
  end subroutine eio_lcio_init_out
    
@ %def eio_lcio_init_out
@ Initialize event reading. For input, we do not (yet) support split
event files. 
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: init_in => eio_lcio_init_in
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_init_in (eio, sample, data, success, extension)
    class(eio_lcio_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(string_t), intent(in), optional :: extension
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    logical :: exist
    eio%split = .false.
    call eio%common_init (sample, data, extension)
    write (msg_buffer, "(A,A,A)")  "Events: reading from LCIO file '", &
         char (eio%filename), "'"
    call msg_message ()
    inquire (file = char (eio%filename), exist = exist)
    if (.not. exist)  call msg_fatal ("Events: LCIO file not found.")
    eio%reading = .true.
    call lcio_open_file (eio%lcio_reader, eio%filename)
    if (present (success))  success = .true.
  end subroutine eio_lcio_init_in
    
@ %def eio_lcio_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: switch_inout => eio_lcio_switch_inout
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_switch_inout (eio, success)
    class(eio_lcio_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    call msg_bug ("LCIO: in-out switch not supported")
    if (present (success))  success = .false.
  end subroutine eio_lcio_switch_inout
  
@ %def eio_lcio_switch_inout
@ Output an event to the allocated LCIO writer.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: output => eio_lcio_output
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_output (eio, event, i_prc, reading, pacify)
    class(eio_lcio_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    integer, intent(in) :: i_prc
    logical, intent(in), optional :: reading, pacify
    type(particle_set_t), pointer :: pset_ptr
    if (eio%writing) then
       pset_ptr => event%get_particle_set_ptr ()
       call lcio_event_init (eio%lcio_event, &
             proc_id = eio%proc_num_id (i_prc), &
             event_id = event%get_index ())
       call lcio_event_from_particle_set (eio%lcio_event, pset_ptr)
       call lcio_event_set_scale (eio%lcio_event, event%get_fac_scale ())
       call lcio_event_set_alpha_qcd (eio%lcio_event, event%get_alpha_s ())
       call lcio_event_write (eio%lcio_writer, eio%lcio_event)
       call lcio_event_final (eio%lcio_event)
    else
       call eio%write ()
       call msg_fatal ("LCIO file is not open for writing")
    end if
  end subroutine eio_lcio_output

@ %def eio_lcio_output
@ Input an event.
<<EIO LCIO: eio lcio: TBP>>=
  procedure :: input_i_prc => eio_lcio_input_i_prc
  procedure :: input_event => eio_lcio_input_event
<<EIO LCIO: procedures>>=
  subroutine eio_lcio_input_i_prc (eio, i_prc, iostat)
    class(eio_lcio_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    logical :: ok
    integer :: i, proc_num_id
    iostat = 0
    call lcio_read_event (eio%lcio_reader, eio%lcio_event, ok)
    if (.not. ok) then 
       iostat = -1 
       return
    end if
    proc_num_id = lcio_event_get_process_id (eio%lcio_event)    
    i_prc = 0
    FIND_I_PRC: do i = 1, size (eio%proc_num_id)
       if (eio%proc_num_id(i) == proc_num_id) then
          i_prc = i
          exit FIND_I_PRC
       end if
    end do FIND_I_PRC
    if (i_prc == 0)  call err_index
  contains
    subroutine err_index
      call msg_error ("LCIO: reading events: undefined process ID " &
           // char (str (proc_num_id)) // ", aborting read")
      iostat = 1
    end subroutine err_index
  end subroutine eio_lcio_input_i_prc

  subroutine eio_lcio_input_event (eio, event, iostat)
    class(eio_lcio_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    type(particle_set_t), pointer :: pset
    logical :: ok    
    iostat = 0
    call event%reset ()
    call event%select (1, 1, 1)
    call lcio_to_event (event, eio%lcio_event, eio%fallback_model, &
         recover_beams = eio%recover_beams) 
    ! if (associated (event%process)) then
    !    pset => event%get_particle_set_ptr ()
    !    call particle_set_set_model (pset, event%process%get_model_ptr ())
    ! end if    
    call lcio_event_final (eio%lcio_event)
  end subroutine eio_lcio_input_event

@ %def eio_lcio_input_i_prc
@ %def eio_lcio_input_event
@
\subsection{Unit tests}
<<EIO LCIO: public>>=
  public :: eio_lcio_test
<<EIO LCIO: tests>>=
  subroutine eio_lcio_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO LCIO: execute tests>>
  end subroutine eio_lcio_test
  
@ %def eio_lcio_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO LCIO: execute tests>>=
  call test (eio_lcio_1, "eio_lcio_1", &
       "write event contents", &
       u, results)
<<EIO LCIO: tests>>=
  subroutine eio_lcio_1 (u)
    integer, intent(in) :: u
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(particle_set_t), pointer :: pset_ptr    
    type(string_t) :: sample
    integer :: u_file, iostat
    character(215) :: buffer

    write (u, "(A)")  "* Test output: eio_lcio_1"
    write (u, "(A)")  "*   Purpose: write a LCIO file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call eio_prepare_test (event)

    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lcio_1"
 
    allocate (eio_lcio_t :: eio)
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters ()
    end select

    call eio%init_out (sample, data)
    
    call event%generate (1, [0._default, 0._default])
    call event%pacify_particle_set ()
    
    call eio%output (event, i_prc = 1)    
    call eio%write (u)
    call eio%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Reset data"
    write (u, "(A)")
 
    deallocate (eio)
    allocate (eio_lcio_t :: eio)
    
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters (keep_beams = .true.)
    end select
    call eio%write (u)

    write (u, "(A)") 
    write (u, "(A)")  "* Write LCIO file contents to ASCII file"
    write (u, "(A)")

    select type (eio)    
    type is (eio_lcio_t)       
       call lcio_event_init (eio%lcio_event, &
            proc_id = 42, &
            event_id = event%get_index ())
       pset_ptr => event%get_particle_set_ptr ()
       call lcio_event_from_particle_set &
            (eio%lcio_event,  pset_ptr)
       call write_lcio_event (eio%lcio_event, var_str ("test_file.slcio"))
       call lcio_event_final (eio%lcio_event)       
    end select
    
    write (u, "(A)") 
    write (u, "(A)")  "* Read in ASCII contents of LCIO file"
    write (u, "(A)")    
    
    u_file = free_unit ()
    open (u_file, file = "test_file.slcio", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       if (trim (buffer) == "")  cycle
       if (buffer(1:12) == " - timestamp")  cycle
       if (buffer(1:6) == " date:")  cycle       
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio_cleanup_test (event)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lcio_1"

  end subroutine eio_lcio_1
  
@ %def eio_lcio_1
@ Test also the reading of LCIO events.
<<EIO LCIO: execute tests>>=
  call test (eio_lcio_2, "eio_lcio_2", &
       "read event contents", &
       u, results)
<<EIO LCIO: tests>>=
  subroutine eio_lcio_2 (u)
    integer, intent(in) :: u
    class(model_data_t), pointer :: fallback_model
    class(generic_event_t), pointer :: event
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    type(string_t) :: sample
    integer :: u_file, iostat, i_prc

    write (u, "(A)")  "* Test output: eio_lcio_2"
    write (u, "(A)")  "*   Purpose: read a LCIO event"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize test process" 
    
    call eio_prepare_fallback_model (fallback_model)
    call eio_prepare_test (event)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    data%cross_section(1) = 100
    data%error(1) = 1
    data%total_cross_section = sum (data%cross_section)    

    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_lcio_2"
 
    allocate (eio_lcio_t :: eio)
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters (recover_beams = .false.)
    end select            
    call eio%set_fallback_model (fallback_model)
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%pacify_particle_set ()

    call eio%output (event, i_prc = 1)
    call eio%write (u)
    call eio%final ()
    deallocate (eio)
    
    write (u, "(A)")    
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")
             
    allocate (eio_lcio_t :: eio)
    select type (eio)
    type is (eio_lcio_t)
       call eio%set_parameters (recover_beams = .false.)
    end select
    call eio%set_fallback_model (fallback_model)
    
    call data%init (1)
    data%n_beam = 2
    data%unweighted = .true.
    data%norm_mode = NORM_UNIT
    data%pdg_beam = 25
    data%energy_beam = 500
    data%proc_num_id = [42]
    call data%write (u)
    write (u, *)
    
    write (u, "(A)")  "* Initialize"
    write (u, "(A)")
    
    call eio%init_in (sample, data)
    call eio%write (u)        

    write (u, "(A)")
    write (u, "(A)")  "* Read event"
    write (u, "(A)")
 
    call eio%input_i_prc (i_prc, iostat)

    select type (eio)
    type is (eio_lcio_t)
       write (u, "(A,I0,A,I0)")  "Found process #", i_prc, &
            " with ID = ", eio%proc_num_id(i_prc)
    end select
    
    call eio%input_event (event, iostat)    
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Read closing"
    write (u, "(A)")
    
    call eio%input_i_prc (i_prc, iostat)
    write (u, "(A,I0)")  "iostat = ", iostat

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()

    call eio_cleanup_test (event)
    call eio_cleanup_fallback_model (fallback_model)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_lcio_2"
    
  end subroutine eio_lcio_2
  
@ %def eio_lcio_2
