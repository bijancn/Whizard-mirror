% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{FKS Subtraction Scheme}

The code in this chapter implements the FKS subtraction scheme for use
with \whizard.

These are the modules:
\begin{description}
\item[fks\_regions]
  Given a process definition, identify singular regions in the
  associated phase space.
\item[virtual]
  Handle the virtual correction matrix element.
\item[real\_subtraction]
  Handle the real-subtraction matrix element.
\item[nlo\_data]
  Manage the subtraction objects.
\item[phs\_fks]
  Phase-space parameterization with modifications for the FKS scheme.
\end{description}

This chapter deals with next-to-leading order contributions to cross sections.
Basically, there are three major issues to be adressed: The creation
of the $N+1$-particle flavor structure, the construction of the
$N+1$-particle phase space and the actual calculation of the real- and
virtual-subtracted matrix elements. The first is dealt with using the
[[auto_components]] class, and it will be shown that the second
and third issue are connected in FKS subtraction.

\section{Brief outline of FKS subtraction}
{\em In the current state, this discussion is only concerned with
  lepton collisions. For hadron collisions, renormalization of parton
  distributions has to be taken into account. Further, for QCD
  corrections, initial-state radiation is necessarily
  present. However, most quantities have so far been only constructed
  for final-state emissions}

The aim is to calculate the next-to-leading order cross section
according to
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \mathcal{V} +
  \mathcal{R}d\Phi_{\rm{rad}}.
\end{equation*}
Analytically, the divergences, in terms of poles in the complex
quantity $\varepsilon = 2-d/2$, cancel. However, this is in general
only valid in an arbitrary, comlex number of dimensions. This is,
roughly, the content of the KLN-theorem. \whizard, as any
other numerical program, is confined to four dimensions. We will
assume that the KLN-theorem is valid and that there exist subtraction
terms $\mathcal{C}$ such that
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \underbrace{\mathcal{V} +
    \mathcal{C}}_{\text{finite}} + \underbrace{\mathcal{R} -
    \mathcal{C}}_{\text{finite}},
\end{equation*}
i.e. the subtraction terms correspond to the divergent limits of the
real and virtual matrix element.

Because $\mathcal{C}$ subtracts the divergences of $\mathcal{R}$ as
well as those of $\mathcal{V}$, it suffices to consider one of them,
so we focus on $\mathcal{R}$. For this purpose, $\mathcal{R}$ is
rewritten,
\begin{equation*}
  \mathcal{R} = \frac{1}{\xi^2}\frac{1}{1-y} \left(\xi^2
    (1-y)\mathcal{R}\right) =
  \frac{1}{\xi^2}\frac{1}{1-y}\tilde{\mathcal{R}},
\end{equation*}
with $\xi = \left(2k_{\rm{rad}}^0\right)/\sqrt{s}$ and $y =
\cos\theta$, where $k_{\rm{rad}}^0$ denotes the energy of the radiated
parton and $\theta$ is the angle between emitter and radiated
parton. $\tilde{\mathcal{R}}$ is finite, therefore the whole
singularity structure is contained in the prefactor
$\xi^{-2}(1-y)^{-1}$. Combined with the d-dimensional phase space
element,
\begin{equation*}
  \frac{d^{d-1}k}{2k^0(2\pi)^{d-1}} =
  \frac{s^{1-\varepsilon}}{(4\pi)^{d-1}}\xi^{1-2\varepsilon}\left(1-y^2\right)^{-\varepsilon}
  d\xi dy d\Omega^{d-2},
\end{equation*}
this yields
\begin{equation*}
  d\Phi_{\rm{rad}} \mathcal{R} = dy (1-y)^{-1-\varepsilon} d\xi
  \xi^{-1-2\varepsilon} \tilde{R}.
\end{equation*}
This can further be rewritten in terms of plus-distributions,
\begin{align*}
\xi^{-1-2\varepsilon} &= -\frac{1}{2\varepsilon}\delta(\xi) +
\left(\frac{1}{\xi}\right)_+ -
2\varepsilon\left(\frac{\log\xi}{\xi}\right)_+ +
\mathcal{O}(\varepsilon^2),\\
(1-y)^{-1-\varepsilon} &= -\frac{2^{-\varepsilon}}{\varepsilon}
\delta(1-y) + \left(\frac{1}{1-y}\right)_+ - \varepsilon
\left(\frac{1}{1-y}\right)_+\log(1-y) + \mathcal{O}(\varepsilon^2),
\end{align*}
(imagine that all this is written inside of integrals, which are
spared for ease of notation) such that
\begin{align*}
d\Phi_{\rm{rad}} \mathcal{R} &= -\frac{1}{2\varepsilon} dy
(1-y)^{-1-\varepsilon}\tilde{R} (0,y) -
d\xi\left[\frac{2^{-\varepsilon}}{\varepsilon}\left(\frac{1}{\xi}\right)_+
  - 2\left(\frac{\log\xi}{\xi}\right)_+\right] \tilde{R}(\xi,1) \\
                              &+ dy d\xi \left(\frac{1}{\xi}\right)_+
                              \left(\frac{1}{1-y}\right)_+
                              \tilde{R}(\xi, y) +
                              \mathcal{O}(\varepsilon).\\
\end{align*}
The summand in the second line is of order $\mathcal{O}(1)$ and is the
only one to reproduce $\mathcal{R}{\xi,y}$. It thus constitutes the
sum of the real matrix element and the corresponding counterterms.
The first summand consequently consists of the subtraction terms to
the virtual matrix elements. Above formula thus allows to calculate
all quantities to render the matrix elements finite.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Identifying singular regions}
In the FKS subtraction scheme, the phase space is decomposed into
disjoint singular regions, such that
\begin{equation}
\label{eq:S_complete}
  \sum_i \mathcal{S}_i + \sum_{ij}\mathcal{S}_{ij} = 1.
\end{equation}
The quantities $\mathcal{S}_i$ and $\mathcal{S}_{ij}$ are functions of
phase space corresponding to a pair of particles indices which can
make up a divergent phase space region. We call such an index pair a
fundamental tuple. For example, the process $e^+ \, e^- \rightarrow u
\, \bar{u} \, g$ has two singular regions, $(3,5)$ and $(4,5)$,
indicating that the gluon can be soft or collinear with respect to
either the quark or the anti-quark. Therefore, the functions $S_{ij}$
have to be chosen in such a way that their contribution makes up most
of \eqref{eq:S_complete} in phase-space configurations where
(final-state) particle $j$ is collinear to particle $i$ or/and
particle $j$ is soft. The functions $S_i$ is the corresponding
quantity for initial-state divergences.

As a singular region we understand the collection of real flavor
structures associated with an emitter and a list of all possible
fundamental tuples. As an example, consider the process $e^+ \, e^-
\rightarrow u \, \bar{u} \, g$. At next-to-leading order, processes
with an additionally radiated particle have to be considered. In this
case, these are $e^+ \, e^- \rightarrow u \, \bar{u}, \, g \, g$,
and $e^+ \, e^- \rightarrow u \, \bar{u} \, u \, \bar{u}$ (or the same
process with any other quark). Table \ref{table:singular regions} sums
up all possible singular regions for this problem.
\begin{table}
\label{table:singular regions}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{flst\_alr} & \texttt{emi} &
  \texttt{ftuple\_list}\\ \hline
  1 & [-11,11,2,-2,21,21] & 3 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  2 & [-11,11,2,-2,21,21] & 4 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  3 & [-11,11,2,-2,21,21] & 5 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  4 & [-11,11,2,-2,2,-2]  & 5 & {(5,6)} \\
  \hline
\end{tabular}
\caption{List of singular regions. The particles are represented by
  their PDG codes. The third column contains the emitter for the
  specific singular region. For the process involving an additional
  gluon, the gluon can either be emitted from one of the quarks or
  from the first gluon. Each emitter yields the same list of
  fundamental tuples, five in total. The last singular region
  corresponds to the process where the gluon splits up into two
  quarks. Here, there is only one fundamental tuple, corresponding to
  a singular configuration of the momenta of the additional quarks.}
\end{table}
\\
\begin{table}
\label{table:ftuples and flavors}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{ftuple} & \texttt{emitter} &
  \texttt{flst\_alr} \\ \hline
  1 & $(3,5)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  2 & $(4,5)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  3 & $(3,6)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  4 & $(4,6)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  5 & $(5,6)$ & 5 & [-11,11,2,-2,21,21] \\ \hline
  6 & $(5,6)$ & 5 & [-11,11,2,-2,2,-2] \\ \hline
\end{tabular}
\caption{Initial list of singular regions}
\end{table}
Thus, during the preparation of a NLO-calculation, the possible
singular regions have to be identified. [[fks_regions.f90]] deals
with this issue.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FKS Regions}
<<[[fks_regions.f90]]>>=
<<File header>>

module fks_regions

<<Use kinds>>
  use format_utils, only: write_separator
  use io_units
<<Use strings>>
  use constants
  use diagnostics
  use flavors
  use process_constants
  use lorentz
  use pdg_arrays
  use model_data
  use physics_defs
  use cascades
  use nlo_data, only: phs_identifier_t, check_for_phs_identifier
  use nlo_data, only: FKS_DEFAULT, FKS_RESONANCES
  use nlo_data, only: NO_FACTORIZATION, FACTORIZATION_THRESHOLD

  use ttv_formfactors, only: THR_POS_B, THR_POS_BBAR
  use ttv_formfactors, only: THR_POS_WP, THR_POS_WM


<<Standard module head>>

<<fks regions: public>>

<<fks regions: parameters>>

<<fks regions: types>>

<<fks regions: interfaces>>

contains

<<fks regions: procedures>>

end module fks_regions
@ %def fks_regions
@ There are three fundamental splitting types: $q \rightarrow qg$, $g \rightarrow gg$ and
$g \rightarrow qq$.
<<fks regions: parameters>>=
  integer, parameter :: UNDEFINED_SPLITTING = 0
  integer, parameter :: Q_TO_QG = 1
  integer, parameter :: G_TO_GG = 2
  integer, parameter :: G_TO_QQ = 3

@
@ We group the indices of the emitting and the radiated particle in
the [[ftuple]]-object.
<<fks regions: public>>=
  public :: ftuple_t
<<fks regions: types>>=
  type :: ftuple_t
    integer, dimension(2) :: ireg
    integer :: i_res = 0
    integer :: splitting_type
    logical :: pseudo_isr = .false.
  contains
  <<fks regions: ftuple: TBP>>
  end type ftuple_t

@ %def ftuple_t
@
<<fks regions: ftuple: TBP>>=
  procedure :: write => ftuple_write
<<fks regions: procedures>>=
  subroutine ftuple_write (ftuple, unit)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    if (ftuple%i_res > 0) then
       print *, 'Check : ', ftuple%i_res
       write (u, "(A1,I1,A1,I1,A1,I1,A1)") &
         '(', ftuple%ireg(1), ',', ftuple%ireg(2), ';', ftuple%i_res, ')'
    else
       write (u, "(A1,I1,A1,I1,A1)") &
         '(', ftuple%ireg(1), ',', ftuple%ireg(2), ')'
    end if
  end subroutine ftuple_write

@ %def ftuple_write
@
<<fks regions: ftuple: TBP>>=
  procedure :: get => ftuple_get
<<fks regions: procedures>>=
  subroutine ftuple_get (ftuple, pos1, pos2)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(out) :: pos1, pos2
    pos1 = ftuple%ireg(1)
    pos2 = ftuple%ireg(2)
  end subroutine ftuple_get

@ %def ftuple_get
@
<<fks regions: ftuple: TBP>>=
  procedure :: set => ftuple_set
<<fks regions: procedures>>=
  subroutine ftuple_set (ftuple, pos1, pos2)
    class(ftuple_t), intent(inout) :: ftuple
    integer, intent(in) ::  pos1, pos2
    ftuple%ireg(1) = pos1
    ftuple%ireg(2) = pos2
  end subroutine ftuple_set

@ %def ftuple_set
@
<<fks regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_fsr => ftuple_determine_splitting_type_fsr
<<fks regions: procedures>>=
  subroutine ftuple_determine_splitting_type_fsr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    associate (flst => flv%flst)
       if (flst(i) == GLUON .and. flst(j) == GLUON) then
          ftuple%splitting_type = G_TO_GG
       else if (flst(i)+flst(j) == 0 &
             .and. is_quark (abs(flst(i)))) then
          ftuple%splitting_type = G_TO_QQ
       else if (is_quark(abs(flst(i))) .and. flst(j) == GLUON &
             .or. is_quark(abs(flst(j))) .and. flst(i) == GLUON) then
          ftuple%splitting_type = Q_TO_QG
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_fsr

@ %def ftuple_determine_splitting_type_fsr
@
<<fks regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_isr => ftuple_determine_splitting_type_isr
<<fks regions: procedures>>=
  subroutine ftuple_determine_splitting_type_isr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    integer :: em
    em = i; if (i == 0) em = 1
    associate (flst => flv%flst)
       if (flst(em) == GLUON .and. flst(j) == GLUON) then
          ftuple%splitting_type = G_TO_GG
       else if (flst(em) == GLUON .and. is_quark(abs(flst(j)))) then
          ftuple%splitting_type = G_TO_QQ
       else if (is_quark(abs(flst(em))) .and. flst(j) == GLUON) then
          ftuple%splitting_type = Q_TO_QG
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_isr

@ %def ftuple_determine_splitting_type_isr
@ Each singular region can have a different number of
emitter-radiation pairs. This is coped with using the linked list
[[ftuple_list]].
<<fks regions: types>>=
  type :: ftuple_list_t
    integer :: index = 0
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: next => null ()
    type(ftuple_list_t), pointer :: prev => null ()
    type(ftuple_list_t), pointer :: equiv => null ()
  contains
   <<fks regions: ftuple list: TBP>>
  end type ftuple_list_t

@ %def ftuple_list_t
@
<<fks regions: ftuple list: TBP>>=
  procedure :: write => ftuple_list_write
<<fks regions: procedures>>=
  subroutine ftuple_list_write (list)
    class(ftuple_list_t), intent(in), target :: list
    type(ftuple_list_t), pointer :: current
    select type (list)
    type is (ftuple_list_t)
       current => list
       do
          call current%ftuple%write
          if (associated (current%next)) then
             current => current%next
          else
             exit
          end if
       end do
    end select
  end subroutine ftuple_list_write

@ %def ftuple_list_write
@
<<fks regions: ftuple list: TBP>>=
  procedure :: append => ftuple_list_append
<<fks regions: procedures>>=
  subroutine ftuple_list_append (list, ftuple)
   class(ftuple_list_t), intent(inout), target :: list
   type(ftuple_t), intent(in) :: ftuple
   type(ftuple_list_t), pointer :: current

   select type (list)
   type is (ftuple_list_t)
   if (list%index == 0) then
      nullify(list%next)
      list%index = 1
      list%ftuple = ftuple
   else
      current => list
      do
       if (associated (current%next)) then
         current => current%next
       else
         allocate (current%next)
         nullify (current%next%next)
         nullify (current%next%equiv)
         current%next%prev => current
         current%next%index = current%index + 1
         current%next%ftuple = ftuple
         exit
       end if
     end do
   end if
   end select
  end subroutine ftuple_list_append

@ %def ftuple_list_append
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_n_tuples => ftuple_list_get_n_tuples
<<fks regions: procedures>>=
  function ftuple_list_get_n_tuples (list) result(n_tuples)
    class(ftuple_list_t), intent(in), target :: list
    integer :: n_tuples
    type(ftuple_list_t), pointer :: current
    n_tuples = 0
    select type (list)
    type is (ftuple_list_t)
       current => list
       if (current%index > 0) then
          n_tuples = 1
          do
             if (associated (current%next)) then
                current => current%next
                n_tuples = n_tuples + 1
             else
                exit
             end if
          end do
       end if
     end select
  end function ftuple_list_get_n_tuples

@ %def ftuple_list_get_n_tuples
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_entry => ftuple_list_get_entry
<<fks regions: procedures>>=
  function ftuple_list_get_entry (list, index) result (entry)
   class(ftuple_list_t), intent(in), target :: list
   integer, intent(in) :: index
   type(ftuple_list_t), pointer :: entry
   type(ftuple_list_t), pointer :: current
   integer :: i
   entry => null()
   select type (list)
   type is (ftuple_list_t)
      current => list
      if (index <= list%get_n_tuples ()) then
         if (index == 1) then
            !!! allocate (..., source = ...) behaves strange with some compilers
            allocate (entry)
            entry = current
         else
            do i = 1, index - 1
               current => current%next
            end do
            allocate (entry)
            entry = current
         end if
      else
         call msg_fatal &
              ("Index must be smaller or equal than the total number of regions!")
      end if
   end select
 end function ftuple_list_get_entry

@ %def ftuple_list_get_entry
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_ftuple => ftuple_list_get_ftuple
<<fks regions: procedures>>=
  function ftuple_list_get_ftuple (list, index)  result (ftuple)
    class(ftuple_list_t), intent(in), target :: list
    integer, intent(in) :: index
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: entry
    entry => list%get_entry (index)
    ftuple = entry%ftuple
  end function ftuple_list_get_ftuple

@ %def ftuple_list_get_ftuple
@
<<fks regions: ftuple list: TBP>>=
  procedure :: set_equiv => ftuple_list_set_equiv
<<fks regions: procedures>>=
  subroutine ftuple_list_set_equiv (list, i1, i2)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    type(ftuple_list_t), pointer :: list1, list2
    select type (list)
    type is (ftuple_list_t)
       list1 => list%get_entry (i1)
       list2 => list%get_entry (i2)
       do
          if (associated (list1%equiv)) then
             list1 => list1%equiv
          else
             exit
          end if
       end do
       list1%equiv => list2
    end select
  end subroutine ftuple_list_set_equiv

@ %def ftuple_list_set_equiv
@
<<fks regions: ftuple list: TBP>>=
  procedure :: check_equiv => ftuple_list_check_equiv
<<fks regions: procedures>>=
  function ftuple_list_check_equiv(list, i1, i2) result(eq)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    logical :: eq
    type(ftuple_list_t), pointer :: current
    eq = .false.
    select type (list)
    type is (ftuple_list_t)
       current => list%get_entry (i1)
       do
          if (associated (current%equiv)) then
             current => current%equiv
             if (current%index == i2) then
                eq = .true.
                exit
             end if
          else
             exit
          end if
       end do
    end select
  end function ftuple_list_check_equiv

@ %def ftuple_list_check_equiv
@ Class for working with the flavor specification arrays.
<<fks regions: public>>=
  public :: flv_structure_t
<<fks regions: types>>=
  type :: flv_structure_t
    integer, dimension(:), allocatable :: flst
    integer :: nlegs
    logical, dimension(:), allocatable :: massive
    logical, dimension(:), allocatable :: colored
  contains
  <<fks regions: flv structure: TBP>>
  end type flv_structure_t

@ %def flv_structure_t
@
Returns \texttt{true} if the two particles at position \texttt{i}
and \texttt{j} in the flavor array can originate from the same
splitting. For this purpose, the function first checks whether the splitting is
allowed at all. If this is the case, the emitter is removed from the
flavor array. If the resulting array is equivalent to the Born flavor
structure \texttt{flv\_born}, the pair is accepted as a valid
splitting.
<<fks regions: flv structure: TBP>>=
  procedure :: valid_pair => flv_structure_valid_pair
<<fks regions: procedures>>=
  function flv_structure_valid_pair &
       (flv_real,i,j, flv_born, model) result (valid)
    class(flv_structure_t), intent(in) :: flv_real
    integer, intent(in) :: i,j
    type(flv_structure_t), intent(in) :: flv_born
    type(model_data_t), intent(in) :: model
    logical :: valid
    integer :: k, n_orig
    type(flv_structure_t) :: flv_test
    integer, dimension(:), allocatable :: flv_orig, flv_orig2
    valid = .false.
@
First check whether the splitting is possible. The array
[[flv_orig]] contains all particles which share a vertex with the
particles at position [[i]] and [[j]]. If its size is equal to zero,
no splitting is possible and the subroutine is exited.
<<fks regions: procedures>>=
    call model%match_vertex &
         (flv_real%flst(i), flv_real%flst(j), flv_orig)
    n_orig = size (flv_orig)
    if (n_orig == 0) then
      return
    else
@
For a quark emitting a gluon, [[flv_orig]] contains the PDG code of
the anti-quark. To be on the safe side, a second array is created,
which contains both the positively and negatively signed PDG
codes. Then, the origial tuple $(i,j)$ is removed from the real flavor
structure and the particles in [[flv_orig2]] are inserted.
If the resulting Born configuration is equal to the underlying Born
configuration, up to a permutation of final-state particles, the tuple
$(i,j)$ is accepted as valid.
<<fks regions: procedures>>=
      allocate (flv_orig2 (2*n_orig))
      flv_orig2 (1:n_orig) = flv_orig
      flv_orig2 (n_orig+1 : 2*n_orig) = -flv_orig
      do k = 1, 2 * n_orig
        flv_test = flv_real%insert_particle (i, j, flv_orig2(k))
        valid = flv_born == flv_test
        if (valid) return
      end do
    end if
  end function flv_structure_valid_pair

@ %def flv_structure_valid_pair
@ This function checks whether two flavor arrays are the same up to a
permutation of the final-state particles
<<fks regions: procedures>>=
  function flv_structure_equivalent (flv1, flv2) result(equiv)
    type(flv_structure_t), intent(in) :: flv1, flv2
    logical :: equiv
    integer :: i, j, n
    logical, dimension(:), allocatable :: present, checked
    n = size (flv1%flst)
    equiv = .true.
    if (n /= size (flv2%flst)) then
       call msg_fatal &
            ('flv_structure_equivalent: flavor arrays do not have equal lengths')
    else
       allocate (present(n))
       allocate (checked(n))
       do i = 1 , n
          present(i) = .false.
          checked(i) = .false.
       end do
       do i = 1 , n
          do j = 1 ,n
             if (flv1%flst(i) == flv2%flst(j) .and. .not. checked(j)) then
                present(i) = .true.
                checked(j) = .true.
                exit
             end if
          end do
       end do
       do i = 1 , n
          if (.not.present(i)) equiv = .false.
       end do
    end if
  end function flv_structure_equivalent

@ %def flv_structure_equivalent
@ Returs a new flavor array with the particle at position
\texttt{index} removed.
<<fks regions: flv structure: TBP>>=
  procedure :: remove_particle => flv_structure_remove_particle
<<fks regions: procedures>>=
  function flv_structure_remove_particle (flv1, index) result(flv2)
    class(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: index
    type(flv_structure_t) :: flv2
    integer :: n1, n2
    n1 = size (flv1%flst)
    n2 = n1 - 1
    if (allocated (flv2%flst)) then
      deallocate (flv2%flst)
    end if
    allocate (flv2%flst (n2))
    if (index == 1) then
      flv2%flst(1 : n2) = flv1%flst(2 : n1)
    else if (index == n1) then
      flv2%flst(1 : n2) = flv1%flst(1 : n2)
    else
      flv2%flst(1 : index - 1) = flv1%flst(1 : index - 1)
      flv2%flst(index : n2) = flv1%flst(index + 1 : n1)
    end if
  end function flv_structure_remove_particle

@ %def flv_structure_remove_particle
@ Removes the paritcles at position i1 and i2 and inserts a new
particle at position i1.
<<fks regions: flv structure: TBP>>=
  procedure :: insert_particle => flv_structure_insert_particle
<<fks regions: procedures>>=
  function flv_structure_insert_particle (flv1, i1, i2, particle) result (flv2)
    class(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: i1, i2, particle
    type(flv_structure_t) :: flv2
    type(flv_structure_t) :: flv_tmp
    integer :: n1, n2
    n1 = size (flv1%flst)
    n2 = n1 - 1
    allocate (flv2%flst(n2))
    if (i1 < i2) then
      flv_tmp = flv1%remove_particle (i1)
      flv_tmp = flv_tmp%remove_particle (i2-1)
    else if(i2 < i1) then
      flv_tmp = flv1%remove_particle(i2)
      flv_tmp = flv_tmp%remove_particle(i1-1)
    else
      call msg_fatal ("Trying to set ftuple with i1 = i2!")
    end if
    if (i1 == 1) then
      flv2%flst(1) = particle
      flv2%flst(2 : n2) = flv_tmp%flst(1 : n2 - 1)
    else if (i1 == n1 .or. i1 == n2) then
      flv2%flst(1 : n2 - 1) = flv_tmp%flst(1 : n2 - 1)
      flv2%flst(n2) = particle
    else
      flv2%flst(1 : i1 - 1) = flv_tmp%flst(1 : i1 - 1)
      flv2%flst(i1) = particle
      flv2%flst(i1 + 1 : n2) = flv_tmp%flst(i1 : n2 - 1)
    end if
  end function flv_structure_insert_particle

@ %def flv_structure_insert_particle
@ Returns the number of particles in a flavor array
<<fks regions: flv structure: TBP>>=
  procedure :: get_nlegs => flv_structure_get_nlegs
<<fks regions: procedures>>=
  function flv_structure_get_nlegs (flv) result(n)
    class(flv_structure_t), intent(in) :: flv
    integer :: n
    n = size (flv%flst)
  end function flv_structure_get_nlegs

@ %def flv_structure_get_nlegs
@ Counts the number of occurances of a particle in a
flavor array
<<fks regions: flv structure: TBP>>=
  procedure :: count_particle => flv_structure_count_particle
<<fks regions: procedures>>=
  function flv_structure_count_particle (flv, part) result (n)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: part
    integer :: n
    n = count (flv%flst == part)
  end function flv_structure_count_particle

@ %def flv_structure_count_particle
@ Initializer for flavor structures
<<fks regions: flv structure: TBP>>=
  procedure :: init => flv_structure_init
<<fks regions: procedures>>=
  subroutine flv_structure_init (flv, aval)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in), dimension(:) :: aval
    integer :: n
    n = size (aval)
    allocate (flv%flst (n))
    flv%flst(1:n) = aval(1:n)
    flv%nlegs = n
  end subroutine flv_structure_init

@ %def flv_structure_init
@
<<fks regions: flv structure: TBP>>=
  procedure :: write => flv_structure_write
<<fks regions: procedures>>=
  subroutine flv_structure_write (flv, unit)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (unit); if (u < 0) return
    write (u, '(A1)',advance = 'no') '['
    do i = 1, size(flv%flst)-1
      write (u, '(I3,A1)', advance = 'no') flv%flst(i), ','
    end do
    write (u, '(I3,A1)') flv%flst(i), ']'
  end subroutine flv_structure_write

@ %def flv_structure_write
@ Creates the underlying Born flavor structure for a given real flavor
structure if the particle at position \texttt{emitter} is removed
<<fks regions: flv structure: TBP>>=
  procedure :: create_uborn => flv_structure_create_uborn
<<fks regions: procedures>>=
  function flv_structure_create_uborn (flst_alr, emitter) result(flst_uborn)
    class(flv_structure_t), intent(in) :: flst_alr
    integer, intent(in) :: emitter
    type(flv_structure_t) :: flst_uborn
    integer n_alr, n_uborn
    n_alr = size(flst_alr%flst)
    n_uborn = n_alr-1
    allocate (flst_uborn%flst (n_uborn))
    if (emitter > 2) then
      if (flst_alr%flst(n_alr) == 21) then
         !!! Emitted particle is a gluon => just remove it
         flst_uborn = flst_alr%remove_particle(n_alr)
         !!! Emission type is a gluon splitting into two quars
      else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
               is_quark (abs(flst_alr%flst(n_alr-1))) .and. &
               flst_alr%flst(n_alr) + flst_alr%flst(n_alr-1) == 0) then
         flst_uborn = flst_alr%insert_particle(n_alr-1,n_alr,21)
      else
         call msg_fatal ("Create underlying Born: Unsupported splitting type.")
      end if
     else
        if (flst_alr%flst(n_alr) == 21) then
           flst_uborn = flst_alr%remove_particle(n_alr)
        else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
                  is_gluon (abs(flst_alr%flst(emitter)))) then
           flst_uborn = &
                flst_alr%insert_particle (emitter,n_alr,-flst_alr%flst(n_alr))
        else if (is_quark (abs(flst_alr%flst(n_alr))) .and. &
                  is_quark (abs(flst_alr%flst(emitter))) .and. &
                  flst_alr%flst(n_alr) == flst_alr%flst(emitter)) then
           flst_uborn = flst_alr%insert_particle(emitter,n_alr,21)
        end if
     end if
  end function flv_structure_create_uborn

@ %def flv_structure_create_uborn
@
<<fks regions: flv structure: TBP>>=
  procedure :: evaluate => flv_structure_evaluate
<<fks regions: procedures>>=
  subroutine flv_structure_evaluate (flv, n, model)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in) :: n
    type(model_data_t), intent(in) :: model
    integer :: i
    type(flavor_t) :: flavor
    allocate (flv%massive (n), flv%colored(n))
    do i = 1, n
       call flavor%init (flv%flst(i), model)
       flv%massive(i) = flavor%get_mass () > 0
       flv%colored(i) = is_quark (abs(flv%flst(i))) .or. &
                        is_gluon (flv%flst(i))
    end do
  end subroutine flv_structure_evaluate

@ %def flv_structure_evaluate
@ A singular region is a partition of phase space which is associated with
an individual emitter and, if relevant, resonance. It is associated with 
an $\alpha_r$- and resonance-index, with a real flavor structure and 
its underlying Born flavor structure. To compute the FKS weights, it is 
relevant to know all the other particle indices which can result in a 
divergenent phase space configuration, which are collected in the 
[[ftuples]]-array.\\
Some singular regions might behave physically identical. E.g. a real
flavor structure associated with three-jet production is $[11,-11,0,2-2,0]$.
Here, there are two possible [[ftuples]] which contribute to the same
$u \rightarrow u g$ splitting, namely $(3,4)$ and $(4,6)$. The resulting 
singular regions will be identical. To avoid this, one singular region
is associated with the multiplicity factor [[mult]]. When computing the
subtraction terms for each singular region, the result is then simply 
multiplied by this factor.\\
The [[double_fsr]]-flag indicates whether the singular region should
also be supplied by a symmetry factor, explained below.
<<fks regions: public>>=
  public :: singular_region_t
<<fks regions: types>>=
  type :: singular_region_t
    integer :: alr
    integer :: i_res
    type(flv_structure_t) :: flst_real
    type(flv_structure_t) :: flst_uborn
    integer :: mult
    integer :: emitter
    integer :: nregions
    integer :: real_index
    type(ftuple_t), dimension(:), allocatable :: ftuples
    integer :: uborn_index
    logical :: double_fsr
    logical :: soft_divergence
    logical :: coll_divergence
    integer, dimension(:), allocatable :: i_reg_to_i_con
    logical :: pseudo_isr = .false.
  contains
  <<fks regions: singular region: TBP>>
  end type singular_region_t

@ %def singular_region_t
@
<<fks regions: singular region: TBP>>=
  procedure :: init => singular_region_init
<<fks regions: procedures>>=
  subroutine singular_region_init (sregion, alr, mult, i_res, &
         flst_real, flst_uborn, flv_born, emitter, ftuples, index)
    class(singular_region_t), intent(out) :: sregion
    integer, intent(in) :: alr, mult, i_res
    type(flv_structure_t), intent(in) :: flst_real
    type(flv_structure_t), intent(in) :: flst_uborn
    type(flv_structure_t), dimension(:), intent(in) :: flv_born
    integer, intent(in) :: emitter
    type(ftuple_list_t), intent(in), dimension(:) :: ftuples
    integer, dimension(:), intent(in) :: index
    type(ftuple_list_t), pointer :: current_region
    integer :: i, i1, i2, nlegs
    call msg_debug (D_SUBTRACTION, "singular_region_init")
    call debug_input_values ()
    sregion%alr = alr
    sregion%mult = mult
    sregion%i_res = i_res
    sregion%flst_real = flst_real
    sregion%flst_uborn = flst_uborn
    sregion%emitter = emitter
    sregion%nregions = ftuples (index(alr))%get_n_tuples ()
    nlegs = size (flst_real%flst)
    allocate (sregion%ftuples (sregion%nregions))
    do i = 1, sregion%nregions
       current_region => ftuples (index(i))%get_entry (i)
       if (.not. associated (current_region%equiv)) then
          call current_region%ftuple%get (i1, i2)
          if (i2 /= nlegs) &
               call current_region%ftuple%set (i1, nlegs)
       end if
       sregion%ftuples (i) = current_region%ftuple
    end do
    do i = 1, size(flv_born)
       if (flv_born (i) == sregion%flst_uborn) then
          sregion%uborn_index = i
          exit
       end if
    end do
  contains
    subroutine debug_input_values()
      if (debug2_active (D_SUBTRACTION)) then
         print *, 'alr =    ', alr
         print *, 'mult =    ', mult
         print *, 'i_res =    ', i_res
         call flst_real%write ()
         call flst_uborn%write ()
         do i = 1, size (flv_born)
            call flv_born(i)%write ()
         end do
         print *, 'emitter =    ', emitter
         do i = 1, size (ftuples)
            call ftuples(i)%write ()
         end do
         print *, 'index =    ', index
      end if
    end subroutine debug_input_values
  end subroutine singular_region_init

@ %def singular_region_init
<<fks regions: singular region: TBP>>=
  procedure :: write => singular_region_write
<<fks regions: procedures>>=
  subroutine singular_region_write (sregion, unit, maxnregions)
    class(singular_region_t), intent(in) :: sregion
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: maxnregions
    character(len=7), parameter :: flst_format = "(I3,A1)"
    character(len=16), parameter :: ireg_format = "(A1,I1,A1,I1,A3)"
    character(len=22), parameter :: &
       ireg_format_resonant = "(A1,I1,A1,I1,A1,I1,A3)"
    character(len=7), parameter :: ireg_space_format = "(7X,A1)"
    integer :: nreal, nborn, i, u, mr, i1, i2
    integer :: nleft, nright, nreg, nreg_diff
    integer :: i_res
    character(len=3) :: closing_bracket
    u = given_output_unit (unit); if (u < 0) return
    mr = sregion%nregions; if (present (maxnregions))  mr = maxnregions
    nreal = size (sregion%flst_real%flst)
    nborn = size (sregion%flst_uborn%flst)
    call write_vline (u)
    write (u, '(A1)', advance = 'no') '['
    do i = 1, nreal - 1
       write (u, flst_format, advance = 'no') sregion%flst_real%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_real%flst(nreal), ']'
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%emitter
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%mult
    call write_vline (u)
    write (u, '(I4)', advance = 'no') sregion%nregions
    call write_vline (u)
    if (sregion%i_res > 0) then
       write (u, '(I3)', advance = 'no') sregion%i_res
       call write_vline (u)
    end if
    nreg = sregion%nregions
    if (nreg == mr) then
       nleft = 0
       nright = 0
    else
       nreg_diff = mr - nreg
       nleft = nreg_diff / 2
       if (mod(nreg_diff , 2) == 0) then
          nright = nleft
       else
          nright = nleft + 1
       end if
    end if
    if (nleft > 0) then
       do i = 1, nleft
          write(u, ireg_space_format, advance='no') ' '
       end do
    end if
    write (u,'(A1)', advance = 'no') '{'
    if (nreg > 1) then
       do i = 1, nreg - 1
          call sregion%ftuples(i)%get (i1, i2)
          if (sregion%ftuples(i)%pseudo_isr) then
             closing_bracket = ')*'
          else
             closing_bracket = ')'
          end if
          i_res = sregion%ftuples(i)%i_res
          if (i_res > 0) then
             write (u, ireg_format_resonant, advance = 'no') &
                '(', i1, ',', i2, ';', i_res, closing_bracket
          else
             write(u, ireg_format, advance = 'no') '(', i1, ',', i2, closing_bracket
          end if
       end do
    end if
    call sregion%ftuples(nreg)%get (i1, i2)
    i_res = sregion%ftuples(nreg)%i_res
    if (sregion%ftuples(nreg)%pseudo_isr) then
       closing_bracket = ')*}'
    else
       closing_bracket = ')}'
    end if
    if (i_res > 0) then
       write (u, ireg_format_resonant, advance = 'no') &
          '(', i1, ',', i2, '; ', i_res, closing_bracket
    else
       write (u, ireg_format, advance = 'no') '(', i1, ',', i2, closing_bracket
    end if
    if (nright > 0) then
       do i = 1, nright
          write(u, ireg_space_format, advance='no') ' '
       end do
    end if
    call write_vline (u)
    write (u,'(A1)',advance = 'no') '['
    do i = 1, nborn - 1
       write(u, flst_format, advance = 'no') sregion%flst_uborn%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_uborn%flst(nborn), ']'
    call write_vline (u)
    write (u, '(I7)', advance = 'no') sregion%uborn_index
    write (u, '(A)')
  end subroutine singular_region_write

@ %def singular_region_write
@ In case of a $g \rightarrow gg$ or $g \rightarrow qq$ splitting, the factor
\begin{equation*}
 \frac{2E_{\rm{em}}}{E_{\rm{em}} + E_{\rm{rad}}}
\end{equation*}
is multiplied to the real matrix element. This way, the symmetry of the splitting is used
and only one singular region has to be taken into account. However, the factor ensures that
there is only a soft singularity if the radiated parton becomes soft.
<<fks regions: singular region: TBP>>=
  procedure :: set_splitting_info => singular_region_set_splitting_info
<<fks regions: procedures>>=
  subroutine singular_region_set_splitting_info (region)
    class(singular_region_t), intent(inout) :: region
    integer :: i1, i2
    integer :: reg
    region%double_fsr = .false.
    associate (ftuple => region%ftuples)
       do reg = 1, region%nregions
          call ftuple(reg)%get (i1, i2)
          if (i1 /= region%emitter) then
             cycle
          else
             region%soft_divergence = &
                ftuple(reg)%splitting_type /= G_TO_QQ

             if (i1 == 0) then
               region%coll_divergence = .true.
             else
               region%coll_divergence = &
                    .not. region%flst_real%massive(i1)
             end if

             if (ftuple(reg)%splitting_type > 1) then
                region%double_fsr = .true.
                exit
             else if (ftuple(reg)%splitting_type == UNDEFINED_SPLITTING) then
                call msg_fatal ("All splittings should be defined!")
             end if
          end if
       end do
     end associate
  end subroutine singular_region_set_splitting_info

@ %def singular_region_set_splitting_info
@
<<fks regions: singular region: TBP>>=
  procedure :: double_fsr_factor => singular_region_double_fsr_factor
<<fks regions: procedures>>=
  function singular_region_double_fsr_factor (region, p) result (val)
    class(singular_region_t), intent(in) :: region
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: val
    real(default) :: E_rad, E_em
    if (region%double_fsr) then
      E_em = energy (p(region%emitter))
      E_rad = energy (p(region%flst_real%get_nlegs()))
      val = two * E_em / (E_em + E_rad)
    else
      val = one
    end if
  end function singular_region_double_fsr_factor

@ %def singular_region_double_fsr_factor
@
<<fks regions: singular region: TBP>>=
  procedure :: has_soft_divergence => singular_region_has_soft_divergence
<<fks regions: procedures>>=
  function singular_region_has_soft_divergence (region) result (div)
     class(singular_region_t), intent(in) :: region
     logical :: div
     div = region%soft_divergence
  end function singular_region_has_soft_divergence

@ %def singular_region_has_soft_divergence
@
<<fks regions: singular region: TBP>>=
  procedure :: has_collinear_divergence => &
            singular_region_has_collinear_divergence
<<fks regions: procedures>>=
  function singular_region_has_collinear_divergence (region) result (div)
    class(singular_region_t), intent(in) :: region
    logical :: div
    div = region%coll_divergence
  end function singular_region_has_collinear_divergence

@ %def singular_region_has_collinear_divergence
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure singular_region_assign
  end interface
 
<<fks regions: procedures>>=
  subroutine singular_region_assign (reg_out, reg_in)
    type(singular_region_t), intent(out) :: reg_out
    type(singular_region_t), intent(in) :: reg_in
    reg_out%alr = reg_in%alr
    reg_out%flst_real = reg_in%flst_real
    reg_out%flst_uborn = reg_in%flst_uborn
    reg_out%mult = reg_in%mult
    reg_out%emitter = reg_in%emitter
    reg_out%nregions = reg_in%nregions
    reg_out%real_index = reg_in%real_index
    reg_out%uborn_index = reg_in%uborn_index
    reg_out%double_fsr = reg_in%double_fsr
    reg_out%soft_divergence = reg_in%soft_divergence
    reg_out%coll_divergence = reg_in%coll_divergence
    if (allocated (reg_in%ftuples)) then
       allocate (reg_out%ftuples (size (reg_in%ftuples)))
       reg_out%ftuples = reg_in%ftuples
    else
       call msg_bug ("singular_region_assign: Trying to copy a singular region without allocated ftuples!")
    end if
  end subroutine singular_region_assign

@ %def singular_region_assign
@
<<fks regions: types>>=
  type :: resonance_mapping_t
    type(resonance_history_t), dimension(:), allocatable :: res_histories
    integer, dimension(:), allocatable :: alr_to_i_res
    integer, dimension(:,:), allocatable :: i_res_to_alr
    type(vector4_t), dimension(:), allocatable :: p_res
  contains
  <<fks regions: resonance mapping: TBP>>
  end type resonance_mapping_t

@ %def resonance_mapping_t
@ Testing: Init resonance mapping for $\mu \mu b b$ final state.
<<fks regions: resonance mapping: TBP>>=
  procedure :: init => resonance_mapping_init
<<fks regions: procedures>>=
  subroutine resonance_mapping_init (res_map, res_hist)
    class(resonance_mapping_t), intent(inout) :: res_map
    type(resonance_history_t), intent(in), dimension(:) :: res_hist
    integer :: nleg_out
    integer :: n_hist, i_hist1, i_hist2, n_contributors
    n_contributors = 0
    n_hist = size (res_hist)
    allocate (res_map%res_histories (n_hist))
    do i_hist1 = 1, n_hist
       if (i_hist1 + 1 <= n_hist) then
          do i_hist2 = i_hist1 + 1, n_hist
             if (.not. res_hist(i_hist1) > res_hist(i_hist2)) &
                n_contributors = n_contributors + res_hist(i_hist2)%n_resonances
          end do
       else
          n_contributors = n_contributors + res_hist(i_hist1)%n_resonances
       end if
    end do
    allocate (res_map%p_res (n_contributors))
    res_map%res_histories = res_hist
    res_map%p_res = vector4_null
  end subroutine resonance_mapping_init

@ %def resonance_mapping_init
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: set_alr_to_i_res => resonance_mapping_set_alr_to_i_res
<<fks regions: procedures>>=
  subroutine resonance_mapping_set_alr_to_i_res (res_map, regions, alr_new_to_old)
     class(resonance_mapping_t), intent(inout) :: res_map
     type(singular_region_t), intent(in), dimension(:) :: regions
     integer, intent(out), dimension(:), allocatable :: alr_new_to_old
     integer :: alr, i_res
     integer :: alr_new, n_alr_res
     integer :: k
     call msg_debug (D_SUBTRACTION, "resonance_mapping_set_alr_to_i_res")
     n_alr_res = 0
     do alr = 1, size (regions)
        do i_res = 1, size (res_map%res_histories)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) &
              n_alr_res = n_alr_res + 1
        end do
     end do

     allocate (res_map%alr_to_i_res (n_alr_res))
     allocate (res_map%i_res_to_alr (size (res_map%res_histories), 10))
     res_map%i_res_to_alr = 0
     allocate (alr_new_to_old (n_alr_res))
     alr_new = 1
     do alr = 1, size (regions)
        do i_res = 1, size (res_map%res_histories)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) then
              res_map%alr_to_i_res (alr_new) = i_res
              alr_new_to_old (alr_new) = alr
              alr_new = alr_new  + 1
           end if
        end do
     end do

     do i_res = 1, size (res_map%res_histories)
        k = 1
        do alr = 1, size (regions)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) then
              res_map%i_res_to_alr (i_res, k) = alr
              k = k + 1
           end if
        end do
     end do
     if (debug_active (D_SUBTRACTION)) then
        print *, 'i_res_to_alr:'
        do i_res = 1, size(res_map%i_res_to_alr, dim=1)
           print *, res_map%i_res_to_alr (i_res, :)
        end do
        print *, 'alr_new_to_old:', alr_new_to_old
     end if
  end subroutine resonance_mapping_set_alr_to_i_res

@ %def resonance_mapping_set_alr_to_i_res
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_history => resonance_mapping_get_resonance_history
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_history (res_map, alr) result (res_hist)
     type(resonance_history_t) :: res_hist
     class(resonance_mapping_t), intent(in) :: res_map
     integer, intent(in) :: alr
     res_hist = res_map%res_histories(res_map%alr_to_i_res (alr))
  end function resonance_mapping_get_resonance_history

@ %def resonance_mapping_get_resonance_history
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: write => resonance_mapping_write
<<fks regions: procedures>>=
  subroutine resonance_mapping_write (res_map)
    class(resonance_mapping_t), intent(in) :: res_map
    integer :: i_res
    do i_res = 1, size (res_map%res_histories)
       call res_map%res_histories(i_res)%write ()
    end do
  end subroutine resonance_mapping_write

@ %def resonance_mapping_write
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_value => resonance_mapping_get_resonance_value
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_value (res_map, i_res, p, emitter, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: i_res
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: emitter
    integer, intent(in), optional :: i_gluon
    p_map = res_map%res_histories(i_res)%mapping (p, emitter, i_gluon)
  end function resonance_mapping_get_resonance_value

@ %def resonance_mapping_get_resonance_value
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_all => resonance_mapping_get_resonance_all
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_all (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    p_map = zero
    do i_res = 1, size (res_map%res_histories)
       associate (res => res_map%res_histories(i_res))
          if (any (res_map%i_res_to_alr (i_res, :) == alr)) &
             p_map = p_map + res%mapping (p, i_gluon)
       end associate
    end do
  end function resonance_mapping_get_resonance_all

@ %def resonance_mapping_get_resonance_all
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_alr => resonance_mapping_get_resonance_alr
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_alr (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    i_res = res_map%alr_to_i_res (alr)
    p_map = res_map%res_histories(i_res)%mapping (p, i_gluon)
  end function resonance_mapping_get_resonance_alr

@ %def resonance_mapping_get_resonance_alr
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure resonance_mapping_assign
  end interface

<<fks regions: procedures>>=
  subroutine resonance_mapping_assign (res_map_out, res_map_in)
    type(resonance_mapping_t), intent(out) :: res_map_out
    type(resonance_mapping_t), intent(in) :: res_map_in
    if (allocated (res_map_in%res_histories)) then
       allocate (res_map_out%res_histories (size (res_map_in%res_histories)))
       res_map_out%res_histories = res_map_in%res_histories
    end if
    if (allocated (res_map_in%alr_to_i_res)) then
       allocate (res_map_out%alr_to_i_res (size (res_map_in%alr_to_i_res)))
       res_map_out%alr_to_i_res = res_map_in%alr_to_i_res
    end if
    if (allocated (res_map_in%i_res_to_alr)) then
       allocate (res_map_out%i_res_to_alr &
          (size (res_map_in%i_res_to_alr, 1), size (res_map_in%i_res_to_alr, 2)))
       res_map_out%i_res_to_alr = res_map_in%i_res_to_alr
    end if
    if (allocated (res_map_in%p_res)) then
       allocate (res_map_out%p_res (size (res_map_in%p_res)))
       res_map_out%p_res = res_map_in%p_res
    end if
  end subroutine resonance_mapping_assign

@ %def resonance_mapping_assign
@
<<fks regions: types>>=
  type, abstract :: fks_mapping_t
     real(default) :: sumdij
     real(default) :: sumdij_soft
  contains
  <<fks regions: fks mapping: TBP>>
  end type fks_mapping_t

@ %def fks_mapping_t
@
<<fks regions: public>>=
  public :: fks_mapping_default_t
<<fks regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_default_t
    real(default) :: exp_1, exp_2
    integer :: n_in
  contains
  <<fks regions: fks mapping default: TBP>>
  end type fks_mapping_default_t

@ %def fks_mapping_default_t
@
<<fks regions: public>>=
  public :: fks_mapping_resonances_t
<<fks regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_resonances_t
    real(default) :: exp_1, exp_2
    type(resonance_mapping_t) :: res_map
    integer :: emitter = -1
    integer :: i_con = 0
    logical :: pseudo_isr = .false.
  contains
  <<fks regions: fks mapping resonances: TBP>>
  end type fks_mapping_resonances_t

@ %def fks_mapping_resonances_t
@
<<fks regions: interfaces>>=
  interface operator(==)
    module procedure flv_structure_equivalent
  end interface

@ %def operator_equiv
@
<<fks regions: public>>=
  public :: region_data_t
<<fks regions: types>>=
  type :: region_data_t
    type(singular_region_t), dimension(:), allocatable :: regions
    type(flv_structure_t), dimension(:), allocatable :: flv_born
    type(flv_structure_t), dimension(:), allocatable :: flv_real
    integer, dimension(:), allocatable :: emitters
    integer :: n_regions
    integer :: n_emitters
    integer :: n_flv_born
    integer :: n_flv_real
    integer :: n_in
    integer :: nlegs_born
    integer :: nlegs_real
    integer, dimension(:), allocatable :: underlying_borns
    type(flavor_t) :: flv_extra
    class(fks_mapping_t), allocatable :: fks_mapping
    integer, dimension(:), allocatable :: resonances
    integer :: n_phs
    type(resonance_contributors_t), dimension(:), allocatable :: alr_contributors
    integer, dimension(:), allocatable :: alr_to_i_contributor
  contains
  <<fks regions: reg data: TBP>>
  end type region_data_t

@ %def region_data_t
@
<<fks regions: reg data: TBP>>=
  procedure :: allocate_fks_mappings => region_data_allocate_fks_mappings
<<fks regions: procedures>>=
  subroutine region_data_allocate_fks_mappings (reg_data, mapping_type)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: mapping_type

    select case (mapping_type)
    case (FKS_DEFAULT)
       allocate (fks_mapping_default_t :: reg_data%fks_mapping)
    case (FKS_RESONANCES)
       allocate (fks_mapping_resonances_t :: reg_data%fks_mapping)
    case default
       call msg_fatal ("Init region_data: FKS mapping not implemented!")
    end select
  end subroutine region_data_allocate_fks_mappings

@ %def region_data_allocate_fks_mappings
@
<<fks regions: reg data: TBP>>=
  procedure :: init => region_data_init
<<fks regions: procedures>>=
  subroutine region_data_init (reg_data, n_in, model, flavor_born, &
    flavor_real)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: n_in
    type(model_data_t), intent(in) :: model
    integer, intent(inout), dimension(:,:), allocatable :: &
         flavor_born, flavor_real
    integer, dimension(:), allocatable :: current_flavor
    type(ftuple_list_t), dimension(:), allocatable :: ftuples
    integer, dimension(:), allocatable :: emitter
    type(flv_structure_t), dimension(:), allocatable :: flst_alr
    integer :: i
    reg_data%n_in = n_in
    reg_data%n_flv_born = size (flavor_born(1,:))
    reg_data%n_flv_real = size (flavor_real(1,:))
    reg_data%nlegs_born = size (flavor_born(:,1))
    reg_data%nlegs_real = reg_data%nlegs_born + 1
    allocate (reg_data%flv_born (reg_data%n_flv_born))
    allocate (reg_data%flv_real (reg_data%n_flv_real))
    allocate (current_flavor (reg_data%nlegs_born))
    do i = 1, reg_data%n_flv_born
       current_flavor = flavor_born(:,i)
       call reg_data%flv_born(i)%init (current_flavor)
    end do
    deallocate (current_flavor)
    allocate (current_flavor (reg_data%nlegs_real))
    do i = 1, reg_data%n_flv_real
       current_flavor = flavor_real(:,i)
       call reg_data%flv_real(i)%init (current_flavor)
    end do

    call reg_data%flv_extra%init &
         (reg_data%flv_real(1)%flst(reg_data%nlegs_real), &
         model)
    call reg_data%find_regions (model, ftuples, emitter, flst_alr)
    call reg_data%init_singular_regions (ftuples, emitter, flst_alr)
    call reg_data%find_emitters ()
    call reg_data%set_underlying_borns ()
    call reg_data%evaluate_flavors (model)
    call reg_data%set_splitting_info ()
  end subroutine region_data_init

@ %def region_data_init
@
<<fks regions: reg data: TBP>>=
  procedure :: init_resonance_information => region_data_init_resonance_information
<<fks regions: procedures>>=
  subroutine region_data_init_resonance_information (reg_data, factorization_mode)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: factorization_mode
    call reg_data%enlarge_singular_regions_with_resonances ()
    call reg_data%find_resonances ()
    select type (map => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       call map%res_map%write ()
    end select
    if (factorization_mode == FACTORIZATION_THRESHOLD) &
       call reg_data%set_isr_pseudo_regions ()
  end subroutine region_data_init_resonance_information

@ %def region_data_init_resonance_information
@ So far, we have only created singular regions for a non-resonant case. When
resonance mappings are required, we have more singular regions, since they
must now be identified by their emitter-resonance pair index, where the emitter
must be compatible with the resonance.
<<fks regions: reg data: TBP>>=
  procedure :: enlarge_singular_regions_with_resonances &
     => region_data_enlarge_singular_regions_with_resonances
<<fks regions: procedures>>=
  subroutine region_data_enlarge_singular_regions_with_resonances (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer, dimension(:), allocatable :: alr_new_to_old
    integer :: n_alr_new
    integer, parameter :: n_max_resonances = 10
    type(singular_region_t), dimension(:), allocatable :: save_regions
    call msg_debug (D_SUBTRACTION, "region_data_enlarge_singular_regions_with_resonances")
    call debug_input_values ()
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       return
    type is (fks_mapping_resonances_t) 
       allocate (save_regions (reg_data%n_regions))
       do alr = 1, reg_data%n_regions
          save_regions(alr) = reg_data%regions(alr)
       end do

       associate (res_map => fks_mapping%res_map)
          call res_map%set_alr_to_i_res (reg_data%regions, alr_new_to_old)
          deallocate (reg_data%regions)
          n_alr_new = size (alr_new_to_old)
          reg_data%n_regions = n_alr_new
          allocate (reg_data%regions (n_alr_new))
          do alr = 1, n_alr_new
             reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
             reg_data%regions(alr)%i_res = res_map%alr_to_i_res (alr)
          end do
       end associate
    end select

  contains

    subroutine debug_input_values ()
      if (debug2_active (D_SUBTRACTION)) then
         call reg_data%write ()
      end if
    end subroutine debug_input_values

  end subroutine region_data_enlarge_singular_regions_with_resonances

@ %def region_data_enlarge_singular_regions_with_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: set_isr_pseudo_regions => region_data_set_isr_pseudo_regions
<<fks regions: procedures>>=
  subroutine region_data_set_isr_pseudo_regions (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer :: n_alr_new
    !!! Subroutine called for threshold factorization ->
    !!! Size of singular regions at this point is fixed
    type(singular_region_t), dimension(2) :: save_regions 
    integer, dimension(4) :: alr_new_to_old
    integer, dimension(2) :: alr_to_i_con_old
    do alr = 1, reg_data%n_regions
       save_regions(alr) = reg_data%regions(alr)
    end do
    n_alr_new = reg_data%n_regions * 2
    alr_new_to_old = [1, 1, 2, 2]
    alr_to_i_con_old = reg_data%alr_to_i_contributor
    deallocate (reg_data%regions)
    deallocate (reg_data%alr_to_i_contributor)
    allocate (reg_data%regions (n_alr_new))
    allocate (reg_data%alr_to_i_contributor (n_alr_new))
    reg_data%n_regions = n_alr_new
    print *, 'n_regions: ', n_alr_new
    do alr = 1, n_alr_new
       reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
       call add_pseudo_emitters (reg_data%regions(alr))
       if (mod (alr, 2) == 0) reg_data%regions(alr)%pseudo_isr = .true.
       reg_data%regions(alr)%i_res = 1
       reg_data%alr_to_i_contributor(alr) = alr_to_i_con_old (alr_new_to_old (alr))
       allocate (reg_data%regions(alr)%i_reg_to_i_con(4))
       reg_data%regions(alr)%i_reg_to_i_con = [1, 1, 2, 2]
    end do
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       deallocate (fks_mapping%res_map%alr_to_i_res)
       allocate (fks_mapping%res_map%alr_to_i_res (4))
       fks_mapping%res_map%alr_to_i_res = [1, 1, 1, 1]
    end select
  contains
    subroutine add_pseudo_emitters (sregion)
      type(singular_region_t), intent(inout) :: sregion
      type(ftuple_t), dimension(2) :: ftuples_save
      integer :: alr
      do alr = 1, 2
         ftuples_save(alr) = sregion%ftuples(alr)
      end do
      deallocate (sregion%ftuples)
      sregion%nregions = sregion%nregions * 2
      allocate (sregion%ftuples (sregion%nregions))
      do alr = 1, sregion%nregions
         sregion%ftuples(alr) = ftuples_save (alr_new_to_old(alr))
         if (mod (alr, 2) == 0) sregion%ftuples(alr)%pseudo_isr = .true.
      end do
    end subroutine add_pseudo_emitters
  end subroutine region_data_set_isr_pseudo_regions

@ %def region_data_set_isr_pseudo_regions
@
<<fks regions: reg data: TBP>>=
  procedure :: evaluate_flavors => region_data_evaluate_flavors
<<fks regions: procedures>>=
  subroutine region_data_evaluate_flavors (reg_data, model)
    class(region_data_t), intent(inout) :: reg_data
    type(model_data_t), intent(in) :: model
    integer :: i
    do i = 1, reg_data%n_regions
       associate (region => reg_data%regions(i))
          call region%flst_uborn%evaluate (reg_data%nlegs_born, model)
          call region%flst_real%evaluate (reg_data%nlegs_real, model)
       end associate
    end do
    do i = 1, reg_data%n_flv_born
       call reg_data%flv_born(i)%evaluate (reg_data%nlegs_born, model)
    end do
    do i = 1, reg_data%n_flv_real
       call reg_data%flv_real(i)%evaluate (reg_data%nlegs_real, model)
    end do
  end subroutine region_data_evaluate_flavors

@ %def region_data_evaluate_flavors
@
<<fks regions: reg data: TBP>>=
  procedure :: uses_resonances => region_data_uses_resonances
<<fks regions: procedures>>=
  function region_data_uses_resonances (reg_data) result (val)
    logical :: val
    class(region_data_t), intent(in) :: reg_data
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       val = .true.
    class default
       val = .false.
    end select
  end function region_data_uses_resonances

@ %def region_data_uses_resonances
@ Creates a list containing the emitter of each singular region.
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter_list => region_data_get_emitter_list
<<fks regions: procedures>>=
  pure function region_data_get_emitter_list (reg_data) result(emitters)
    class(region_data_t), intent(in) :: reg_data
    integer, dimension(:), allocatable :: emitters
    integer :: i
    allocate (emitters (reg_data%n_regions))
    do i = 1, reg_data%n_regions
       emitters(i) = reg_data%regions(i)%emitter
    end do
  end function region_data_get_emitter_list

@ %def region_data_get_emitter_list
@
<<fks regions: reg data: TBP>>=
  procedure :: get_associated_resonances => region_data_get_associated_resonances
<<fks regions: procedures>>=
  function region_data_get_associated_resonances (reg_data, emitter) result (res)
    integer, dimension(:), allocatable :: res
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: emitter
    integer :: alr, i
    integer :: n_res
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       n_res = 0

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) &
             n_res = n_res + 1
       end do

       if (n_res > 0) then
          allocate (res (n_res))
       else
          return
       end if
       i = 1

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) then
             res (i) = fks_mapping%res_map%alr_to_i_res (alr)
             i = i + 1
          end if
       end do
    end select
  end function region_data_get_associated_resonances

@ %def region_data_get_associated_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: emitter_is_compatible_with_resonance => &
     region_data_emitter_is_compatible_with_resonance
<<fks regions: procedures>>=
  function region_data_emitter_is_compatible_with_resonance &
     (reg_data, i_res, emitter) result (compatible)
     logical :: compatible
     class(region_data_t), intent(in) :: reg_data
     integer, intent(in) :: i_res, emitter
     integer :: i_res_alr, alr
     compatible = .false.
     select type (fks_mapping => reg_data%fks_mapping)
     type is (fks_mapping_resonances_t)
        do alr = 1, reg_data%n_regions
           i_res_alr = fks_mapping%res_map%alr_to_i_res (alr)
           if (i_res_alr == i_res .and. reg_data%get_emitter(alr) == emitter) then
              compatible = .true.
              exit
           end if
        end do
     end select
  end function region_data_emitter_is_compatible_with_resonance

@ %def region_data_emitter_is_compatible_with_resonance
@
<<fks regions: reg data: TBP>>=
  procedure :: emitter_is_in_resonance => region_data_emitter_is_in_resonance
<<fks regions: procedures>>=
  function region_data_emitter_is_in_resonance (reg_data, i_res, emitter) result (exist)
    logical :: exist
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer :: i
    exist = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories(i_res))
          do i = 1, res_history%n_resonances
             exist = exist .or. any (res_history%resonances(i)%contributors%c == emitter)
          end do
      end associate
    end select
  end function region_data_emitter_is_in_resonance

@ %def region_data_emitter_is_in_resonance
@
<<fks regions: reg data: TBP>>=
  procedure :: get_contributors => region_data_get_contributors
<<fks regions: procedures>>=
  subroutine region_data_get_contributors (reg_data, i_res, emitter, c, success)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer, intent(inout), dimension(:), allocatable :: c
    logical, intent(out) :: success
    integer :: i
    success = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories (i_res))
          do i = 1, res_history%n_resonances
             if (any (res_history%resonances(i)%contributors%c == emitter)) then
                allocate (c (size (res_history%resonances(i)%contributors%c)))
                c = res_history%resonances(i)%contributors%c
                success = .true.
                exit
             end if
          end do
       end associate
    end select
  end subroutine region_data_get_contributors

@ %def region_data_get_contributors
@
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter => region_data_get_emitter
<<fks regions: procedures>>=
  pure function region_data_get_emitter (reg_data, alr) result (emitter)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: alr
    integer :: emitter
    emitter = reg_data%regions(alr)%emitter
  end function region_data_get_emitter

@ %def region_data_get_emitter
@ Returns $S_i = \frac{1}{\mathcal{D}d_i}$ or $S_{ij} =
\frac{1}{\mathcal{D}d_{ij}}$ for one particular singular region.  At
this point, the flavor array should be rearranged in such a way that
the emitted particle is at the last position of
the flavor structure list.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue => region_data_get_svalue
<<fks regions: procedures>>=
  function region_data_get_svalue (reg_data, p, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: alr, emitter
    integer, intent(in) :: i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       !!!map%sumdij = map%compute_sumdij (reg_data%regions(alr), p)
       call map%compute_sumdij (reg_data%regions(alr), p)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%emitter = emitter
          map%i_con = reg_data%alr_to_i_contributor (alr)
          map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       end select
       sval = map%svalue (p, emitter, reg_data%nlegs_real, i_res)
    end associate
  end function region_data_get_svalue

@ %def region_data_get_svalue
@ The same as above, but for the soft limit.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue_soft => region_data_get_svalue_soft
<<fks regions: procedures>>=
  function region_data_get_svalue_soft &
       (reg_data, p, p_soft, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       !!!map%sumdij_soft = &
       !!!   map%compute_sumdij_soft (reg_data%regions(alr), p, p_soft)
       call map%compute_sumdij_soft (reg_data%regions(alr), p, p_soft)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%i_con = reg_data%alr_to_i_contributor (alr)
          map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       end select
       sval = map%svalue_soft (p, p_soft, emitter, i_res)
    end associate
  end function region_data_get_svalue_soft

@ %def region_data_get_svalue_soft
@ This subroutine starts with a specification of $N$- and
$N+1$-particle configurations, [[flst_born]] and [[flst_real]], saved
in [[reg_data]]. From these, it creates a list of fundamental tuples,
a list of emitters and a list containing the $N+1$-particle
configuration, rearranged  in such a way that the emitter-radiation
pair is last ([[flst_alr]]). For the $e^+ \, e^- \, \rightarrow u \,
\bar{u} \, g$- example, the generated objects are shown in table
\ref{table:ftuples and flavors}. Note that at this point, [[flst_alr]]
is arranged in such a way that the emitter can only be equal to
$n_{legs}-1$ for final-state radiation or 0, 1, or 2 for initial-state
radiation. Further, it occurs that regions can be equivalent. For
example in table \ref{table:ftuples and flavors} the regions
correpsonding to \texttt{alr} = 1 and \texttt{alr} = 3 as well as
\texttt{alr} = 2 and \texttt{alr} = 4 describe the same physics and
are therefore equivalent.
@
<<fks regions: reg data: TBP>>=
  procedure :: find_regions => region_data_find_regions
<<fks regions: procedures>>=
  subroutine region_data_find_regions &
       (reg_data, model, ftuples, emitter, flst_alr)
    class(region_data_t), intent(in) :: reg_data
    type(model_data_t), intent(in) :: model
    type(ftuple_list_t), intent(out), dimension(:), allocatable :: ftuples
    integer, intent(out), dimension(:), allocatable :: emitter
    type(flv_structure_t), intent(out), dimension(:), allocatable :: flst_alr
    type(ftuple_t) :: current_ftuple
    integer, dimension(:), allocatable :: emitter_tmp
    type(flv_structure_t), dimension(:), allocatable :: flst_alr_tmp
    integer :: nreg, nborn, nreal
    integer :: nlegreal
    integer, parameter :: maxnregions = 200
    integer :: i, j, k, l, m, n
    logical :: valid1, valid2

    associate (flv_born => reg_data%flv_born)
      associate (flv_real => reg_data%flv_real)
        nborn = size (flv_born)
        nreal = size (flv_real)
        nlegreal = size (flv_real(1)%flst)
        allocate (ftuples (nreal))
        allocate (emitter_tmp (maxnregions))
        allocate (flst_alr_tmp (maxnregions))
        n = 0

        ITERATE_REAL_FLAVOR: do l = 1, nreal
         <<fks: check final state emissions>>
         <<fks: check initial state emissions>>
        end do ITERATE_REAL_FLAVOR

        nreg = n

      end associate
    end associate

    allocate (flst_alr (nreg))
    allocate (emitter (nreg))
    flst_alr(1:nreg) = flst_alr_tmp(1:nreg)
    emitter(1:nreg) = emitter_tmp(1:nreg)
  end subroutine region_data_find_regions

@ %def region_data_find_regions
@
<<fks: check final state emissions>>=
  do i = reg_data%n_in + 1, nlegreal
     do j = i+1, nlegreal
        do k = 1, nborn
           if (flv_real(l)%valid_pair(i, j, flv_born(k), model) &
                .or. flv_real(l)%valid_pair(j, i, flv_born(k), model)) then
              n = n + 1
              if(flv_real(l)%valid_pair(i, j, flv_born(k), model)) then
                 flst_alr_tmp(n) = create_alr (flv_real(l), reg_data%n_in, i, j)
              else
                 flst_alr_tmp(n) = create_alr (flv_real(l), reg_data%n_in, j, i)
              end if
              call current_ftuple%set (i, j)
              call current_ftuple%determine_splitting_type_fsr (flv_real(l), i, j)
              call ftuples(l)%append (current_ftuple)
              emitter_tmp(n) = nlegreal - 1
              exit
           end if
        end do
     end do
  end do
@ It suffices to just check the final-state of the first and the
initial-state of the second array.
<<fks: check initial state emissions>>=
  do i = reg_data%n_in + 1, nlegreal
     do k = 1, nborn
        valid1 = flv_real(l)%valid_pair(1, i, flv_born(k), model)
        if (reg_data%n_in > 1) then
           valid2 = flv_real(l)%valid_pair(2, i, flv_born(k), model)
        else
           valid2 = .false.
        end if
        if (valid1 .and. valid2) then
           m = 0
        else if (valid1 .and. .not. valid2) then
           m = 1
        else if (.not. valid1 .and. valid2) then
           m = 2
        end if
        if (valid1 .or. valid2) then
           n = n + 1
           call current_ftuple%set(m, i)
           call current_ftuple%determine_splitting_type_isr (flv_real(l), m, i)
           call ftuples(l)%append (current_ftuple)
           emitter_tmp(n) = m
           flst_alr_tmp(n) = create_alr (flv_real(l), reg_data%n_in, m, i)
           exit
        end if
     end do
  end do
@ Creates singular regions according to table \ref{table:singular
regions}. It scans all regions in table \ref{table:ftuples and
flavors} and records the real flavor structures. If they are
equivalent, the flavor structure is not recorded, but the multiplicity
of the present one is increased.
<<fks regions: reg data: TBP>>=
  procedure :: init_singular_regions => region_data_init_singular_regions
<<fks regions: procedures>>=
  subroutine region_data_init_singular_regions &
         (reg_data, ftuples, emitter, flst_alr)
    class(region_data_t), intent(inout) :: reg_data
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
    integer :: n_valid_ftuples
    integer, intent(in), dimension(:), allocatable :: emitter
    type(flv_structure_t), intent(in), dimension(:), allocatable :: flst_alr
    type(flv_structure_t), dimension(:), allocatable :: flst_uborn, flst_alr2
    integer, dimension(:), allocatable :: mult
    integer, dimension(:), allocatable :: flst_emitter
    integer :: nregions, maxregions
    integer, dimension(:,:), allocatable :: perm_list
    integer, dimension(:), allocatable :: index
    integer :: i, j, k, l
    integer :: nlegs
    logical :: equiv
    integer :: i_first, j_first, i_res
    integer, dimension(:), allocatable :: &
         region_to_ftuple, ftuple_limits, k_index
    type(flv_structure_t) :: flst_save

    maxregions = size (emitter)
    nlegs = size (flst_alr(1)%flst)

    allocate (flst_uborn (maxregions))
    allocate (flst_alr2 (maxregions))
    allocate (mult (maxregions))
    allocate (flst_emitter (maxregions))
    allocate (index (maxregions))
    allocate (region_to_ftuple (maxregions))
    allocate (k_index (maxregions))

    mult = 0
    n_valid_ftuples = 0
    do i = 1, size (ftuples)
       if (ftuples(i)%get_n_tuples() > 0) &
          n_valid_ftuples = n_valid_ftuples + 1
    end do
    allocate (ftuple_limits (n_valid_ftuples))

    j = 1
    do i = 1, size (ftuples)
       if (ftuples(i)%get_n_tuples() > 0) then
          ftuple_limits(j) = ftuples(i)%get_n_tuples ()
          j = j+ 1
       end if
    end do
    if (.not. (sum (ftuple_limits) == maxregions)) &
       call msg_fatal ("Too many regions!")
    k = 1
    do j = 1, n_valid_ftuples
       do i = 1, ftuple_limits(j)
          region_to_ftuple(k) = i
          k = k + 1
       end do
    end do
    i_first = 1
    j_first = 1
    j = 1
    SCAN_REGIONS: do l = 1, n_valid_ftuples
       SCAN_FTUPLES: do i = i_first, i_first + ftuple_limits (l) - 1
          equiv = .false.
          if (i == i_first) then
             if (allocated (flst_alr2(j)%flst)) &
                deallocate (flst_alr2(j)%flst)
             allocate (flst_alr2(j)%flst (size (flst_alr(i)%flst)))
             flst_alr2(j)%flst = flst_alr(i)%flst
             mult(j) = mult(j) + 1
             flst_uborn(j) = flst_alr(i)%create_uborn (emitter(i))
             flst_emitter(j) = emitter(i)
             index (j) = region_to_index(ftuples, i)
             k_index (j) = region_to_ftuple(i)
             j = j + 1
          else
             !!! Check for equivalent flavor structures
             do k = j_first, j - 1
                if (emitter(i) == emitter(k) .and. emitter(i) > reg_data%n_in) then
                   if (flst_alr(i) == flst_alr2(k) .and. &
                      flst_alr(i)%flst(nlegs-1) == flst_alr2(k)%flst(nlegs-1) &
                      .and. flst_alr(i)%flst(nlegs) == flst_alr2(k)%flst(nlegs)) then
                      mult(k) = mult(k) + 1
                      equiv = .true.
                      call ftuples (region_to_index(ftuples, i))%set_equiv &
                         (k_index(k), region_to_ftuple(i))
                      exit
                   end if
                else if (emitter(i) == emitter(k) .and. emitter(i) <= reg_data%n_in) then
                   if (flst_alr(i) == flst_alr2(k)) then
                      mult(k) = mult(k) + 1
                      equiv = .true.
                      call ftuples (region_to_index(ftuples,i))%set_equiv &
                         (k_index(k), region_to_ftuple(i))
                      exit
                   end if
                end if
             end do
          if (.not. equiv) then
             if (allocated (flst_alr2(j)%flst)) &
                  deallocate (flst_alr2(j)%flst)
             allocate (flst_alr2(j)%flst (size (flst_alr(i)%flst)))
             flst_alr2(j)%flst = flst_alr(i)%flst
             mult(j) = mult(j) + 1
             flst_uborn(j) = flst_alr(i)%create_uborn (emitter(i))
             flst_emitter(j) = emitter(i)
             index (j) = region_to_index (ftuples, i)
             k_index (j) = region_to_ftuple(i)
             j = j + 1
          end if
       end if
    end do SCAN_FTUPLES
    i_first = i_first + ftuple_limits(l)
    j_first = j_first + j - 1
    end do SCAN_REGIONS
    nregions = j - 1
    allocate (reg_data%regions (nregions))
    reg_data%n_regions = nregions
    do j = 1, nregions
       do i = 1, reg_data%n_flv_born
          if (reg_data%flv_born (i) == flst_uborn (j)) then
             if (allocated (perm_list)) deallocate (perm_list)
             call fks_permute_born &
                (reg_data%flv_born (i), reg_data%n_in, flst_uborn (j), perm_list)
             call fks_apply_perm (flst_alr2(j), flst_emitter(j), perm_list)
          end if
       end do
    end do
    do i = 1, nregions
       i_res = 0
       call reg_data%regions(i)%init (i, mult(i), i_res, flst_alr2(i), &
          flst_uborn(i), reg_data%flv_born, flst_emitter(i), ftuples, &
          index)
    end do
    ! TODO: (bcn 2015-12-15) can this be put in singular_region_init?
    k = 1
    associate (regions => reg_data%regions)
       do i = 1, nregions
          if (i == 1) then
             regions(i)%real_index = 1
             flst_save = flst_alr2(1)
             cycle
          end if
          if (flst_alr2(i) == flst_save) then
             regions(i)%real_index = k
          else
             k = k + 1
             regions(i)%real_index = k
             flst_save = flst_alr2(i)
          end if
       end do
    end associate

  end subroutine region_data_init_singular_regions

@ %def region_data_init_singular_regions
@ Create an array containing all emitters and resonances of [[region_data]].
<<fks regions: reg data: TBP>>=
  procedure :: find_emitters => region_data_find_emitters
<<fks regions: procedures>>=
  subroutine region_data_find_emitters (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, n_em, em
    integer, dimension(10) :: em_count
    em_count = -1
    n_em = 0

    !!!Count the number of different emitters
    do alr = 1, reg_data%n_regions
       em = reg_data%regions(alr)%emitter
       if (.not. any (em_count == em)) then
          n_em = n_em + 1
          em_count(alr) = em
       end if
    end do

    if (n_em < 1) call msg_fatal ("region_data_find_emitters: No emitters found!")
    reg_data%n_emitters = n_em
    allocate (reg_data%emitters (reg_data%n_emitters))
    reg_data%emitters = -1

    j = 1
    do alr = 1, size (reg_data%regions)
       em = reg_data%regions(alr)%emitter
       if (.not. any (reg_data%emitters == em)) then
          reg_data%emitters(j) = em
          j = j + 1
       end if
    end do
  end subroutine region_data_find_emitters

@ %def region_data_find_emitters
@
<<fks regions: reg data: TBP>>=
  procedure :: find_resonances => region_data_find_resonances
<<fks regions: procedures>>=
  subroutine region_data_find_resonances (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, k, n_res, n_contr
    integer :: res
    integer, dimension(10) :: res_count
    type(resonance_contributors_t), dimension(10) :: contributors_count
    type(resonance_contributors_t) :: contributors
    integer :: i_res, emitter
    logical :: share_emitter
    res_count = -1
    n_res = 0; n_contr = 0

    !!! Count the number of different resonances
    do alr = 1, reg_data%n_regions
       select type (fks_mapping => reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (res_count == res)) then
             n_res = n_res + 1
             res_count(alr) = res
          end if
       end select
    end do

    if (n_res > 0) allocate (reg_data%resonances (n_res))

    j = 1
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       do alr = 1, size (reg_data%regions)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (reg_data%resonances == res)) then
             reg_data%resonances(j) = res
             j = j + 1
          end if
       end do

       allocate (reg_data%alr_to_i_contributor (size (reg_data%regions)))
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (contributors_count == contributors)) then 
             n_contr = n_contr + 1
             contributors_count(alr) = contributors
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
       allocate (reg_data%alr_contributors (n_contr))
       j = 1
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (reg_data%alr_contributors == contributors)) then
             reg_data%alr_contributors(j) = contributors
             reg_data%alr_to_i_contributor (alr) = j
             j = j + 1
          else
             do k = 1, size (reg_data%alr_contributors)
                if (reg_data%alr_contributors(k) == contributors) exit
             end do
             reg_data%alr_to_i_contributor (alr) = k
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
    end select
    call reg_data%extend_ftuples (n_res)
    call reg_data%set_contributors ()
    
  end subroutine region_data_find_resonances

@ %def region_data_find_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: set_contributors => region_data_set_contributors
<<fks regions: procedures>>=
  subroutine region_data_set_contributors (reg_data)
     class(region_data_t), intent(inout) :: reg_data
     integer :: alr, i_res, i_reg, i_con
     integer :: i1, i2, i_em
     integer, dimension(:), allocatable :: contributors 
     logical :: share_emitter
     do alr = 1, size (reg_data%regions)
        associate (sregion => reg_data%regions(alr))
           allocate (sregion%i_reg_to_i_con (sregion%nregions))
           do i_reg = 1, sregion%nregions
              call sregion%ftuples(i_reg)%get (i1, i2)
              i_em = get_emitter_index (i1, i2, reg_data%nlegs_real)
              i_res = sregion%ftuples(i_reg)%i_res
              call reg_data%get_contributors (i_res, i_em, contributors, share_emitter)
	      !!! Lookup contributor index
              do i_con = 1, size (reg_data%alr_contributors)
                 if (all (reg_data%alr_contributors(i_con)%c == contributors)) then
                    sregion%i_reg_to_i_con (i_reg) = i_con
                    exit
                 end if
              end do
              deallocate (contributors)
           end do
        end associate
     end do
  contains
     function get_emitter_index (i1, i2, n) result (i_em)
       integer :: i_em
       integer, intent(in) :: i1, i2, n
       if (i1 == n) then
          i_em = i2
       else
          i_em = i1
       end if 
     end function get_emitter_index
  end subroutine region_data_set_contributors

@ %def region_data_set_contributors
@ This extension of the ftuples is still too naive as it assumes that the same
resonances are possible for all ftuples
<<fks regions: reg data: TBP>>=
  procedure :: extend_ftuples => region_data_extend_ftuples
<<fks regions: procedures>>=
  subroutine region_data_extend_ftuples (reg_data, n_res)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: n_res
    integer :: alr, n_reg_save
    integer :: i_reg, i_res, i_em, k
    type(ftuple_t), dimension(:), allocatable :: ftuple_save
    integer :: n_new
    do alr = 1, size (reg_data%regions)
       associate (sregion => reg_data%regions(alr))
          n_reg_save = sregion%nregions
          allocate (ftuple_save (n_reg_save))
          ftuple_save = sregion%ftuples 
          n_new = count_n_new_ftuples (sregion, n_res)
          deallocate (sregion%ftuples)
          sregion%nregions = n_new
          allocate (sregion%ftuples (n_new))
          k = 1
          do i_res = 1, n_res
             do i_reg = 1, n_reg_save
                associate (ftuple_new => sregion%ftuples(k))
                   i_em = ftuple_save(i_reg)%ireg(1)
                   if (reg_data%emitter_is_in_resonance (i_res, i_em)) then
                      call ftuple_new%set (i_em, ftuple_save(i_reg)%ireg(2))
                      ftuple_new%i_res = i_res
                      ftuple_new%splitting_type = ftuple_save(i_reg)%splitting_type
                      k = k + 1
                   end if
                end associate
             end do
          end do    
       end associate
       deallocate (ftuple_save)
    end do
  contains
    function count_n_new_ftuples (sregion, n_res) result (n_new)
      integer :: n_new
      type(singular_region_t), intent(in) :: sregion
      integer, intent(in) :: n_res
      integer :: i_reg, i_res, i_em
      n_new = 0
      do i_reg = 1, sregion%nregions
         do i_res = 1, n_res 
            i_em = sregion%ftuples(i_reg)%ireg(1)
            if (reg_data%emitter_is_in_resonance (i_res, i_em)) &
               n_new = n_new + 1
         end do
      end do
    end function count_n_new_ftuples
  end subroutine region_data_extend_ftuples

@ %def region_data_extend_ftuples
@ Create the map real flavor -> underlying Born
<<fks regions: reg data: TBP>>=
  procedure :: set_underlying_borns => region_data_set_underlying_borns
<<fks regions: procedures>>=
  subroutine region_data_set_underlying_borns (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i, alr
    integer, dimension(:), allocatable :: flst_real
    allocate (reg_data%underlying_borns (reg_data%n_flv_real))
    do i = 1, reg_data%n_flv_real
       if (allocated (flst_real))  deallocate (flst_real)
       allocate (flst_real (size (reg_data%flv_real(i)%flst)))
       flst_real = reg_data%flv_real(i)%flst
       do alr = 1, reg_data%n_regions
          if (all (reg_data%regions(alr)%flst_real%flst == flst_real)) then
             reg_data%underlying_borns(i) = reg_data%regions(alr)%uborn_index
             exit
          end if
       end do
    end do
  end subroutine region_data_set_underlying_borns

@ %def region_data_set_underlying_borns
@
<<fks regions: reg data: TBP>>=
  procedure :: compute_number_of_phase_spaces &
     => region_data_compute_number_of_phase_spaces
<<fks regions: procedures>>=
  subroutine region_data_compute_number_of_phase_spaces (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    integer, parameter :: n_max_phs = 10
    type(phs_identifier_t), dimension(n_max_phs) :: phs_id_tmp
    logical :: share_emitter, phs_exist
    if (allocated (reg_data%resonances)) then
       reg_data%n_phs = 0
       do i_em = 1, size (reg_data%emitters)
          emitter = reg_data%emitters(i_em)
          do i_res = 1, size (reg_data%resonances)
             if (reg_data%emitter_is_compatible_with_resonance (i_res, emitter)) then 
                !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
                call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
                if (.not. share_emitter) cycle
                call check_for_phs_identifier &
                   (phs_id_tmp, emitter, contributors%c, phs_exist, i_phs)
                if (.not. phs_exist) then
                   reg_data%n_phs = reg_data%n_phs + 1
                   if (reg_data%n_phs > n_max_phs) call msg_fatal &
                      ("Buffer of phase space identifieres: Too much phase spaces!")
                   call phs_id_tmp(i_phs)%init (emitter, contributors%c)
                end if
             end if
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       end do
    else
       reg_data%n_phs = reg_data%n_emitters
    end if
  end subroutine region_data_compute_number_of_phase_spaces

@ %def region_data_compute_number_of_phase_spaces
@
<<fks regions: reg data: TBP>>=
  procedure :: set_splitting_info => region_data_set_splitting_info
<<fks regions: procedures>>=
  subroutine region_data_set_splitting_info (reg_data)
     class(region_data_t), intent(inout) :: reg_data
     integer :: alr
     do alr = 1, reg_data%n_regions
        call reg_data%regions(alr)%set_splitting_info ()
     end do
   end subroutine region_data_set_splitting_info

@ %def region_data_set_splitting_info
@
<<fks regions: reg data: TBP>>=
  procedure :: write_to_file => region_data_write_to_file
<<fks regions: procedures>>=
  subroutine region_data_write_to_file (reg_data, proc_id)
     class(region_data_t), intent(inout) :: reg_data
     type(string_t), intent(in) :: proc_id
     type(string_t) :: filename
     integer :: u

     filename = proc_id // "_fks_regions.log"
     u = free_unit ()
     open (u, file=char(filename), action = "write", status="replace")
     call reg_data%write (u)
     close (u)
  end subroutine region_data_write_to_file

@ %def region_data_write_to_file
@ Creates a table with information about all singular regions and
writes it to a file.
@ Returns the index of the real flavor structure an ftuple belongs to.
<<fks regions: reg data: TBP>>=
  procedure :: write => region_data_write
<<fks regions: procedures>>=
  subroutine region_data_write (reg_data, unit)
     class(region_data_t), intent(in) :: reg_data
     integer, intent(in), optional :: unit
     integer :: j
     integer :: maxnregions
     type(string_t) :: flst_title, ftuple_title
     character(len=7), parameter :: flst_format = "(I3,A1)"
     character(len=16), parameter :: ireg_format = "(A1,I3,A1,I3,A2)"
     character(len=7), parameter :: ireg_space_format = "(7X,A1)"
     integer :: n_res, u
     u = given_output_unit (unit); if (u < 0) return
     maxnregions = 1
     do j = 1, reg_data%n_regions
        if (size (reg_data%regions(j)%ftuples) > maxnregions) &
             maxnregions = reg_data%regions(j)%nregions
     end do
     flst_title = '(A' // flst_title_format(reg_data%nlegs_real) // ')'
     ftuple_title = '(A' // ftuple_title_format() // ')'
     write (u,'(A,1X,I2)') 'Total number of regions: ', size(reg_data%regions)
     write (u, '(A3)', advance = 'no') 'alr'
     call write_vline (u)
     write (u, char (flst_title), advance = 'no') 'flst_real'
     call write_vline (u)
     write (u, '(A3)', advance = 'no') 'em'
     call write_vline (u)
     write (u, '(A3)', advance = 'no') 'mult'
     call write_vline (u)
     write (u, '(A4)', advance = 'no') 'nreg'
     call write_vline (u)
     select type (fks_mapping => reg_data%fks_mapping)
     type is (fks_mapping_resonances_t)
        write (u, '(A3)', advance = 'no') 'res'
        call write_vline (u)
     end select
     write (u, char (ftuple_title), advance = 'no') 'ftuples'
     call write_vline (u)
     flst_title = '(A' // flst_title_format(reg_data%nlegs_born) // ')'
     write (u, char (flst_title), advance = 'no') 'flst_born'
     call write_vline (u)
     write (u, '(A7)') 'i_uborn'
     do j = 1, reg_data%n_regions
        write (u, '(I3)', advance = 'no') j
        call reg_data%regions(j)%write (u, maxnregions)
     end do
     call write_separator (u)
     select type (fks_mapping => reg_data%fks_mapping)
     type is (fks_mapping_resonances_t)
        write (u, '(A)')
        write (u, '(A)') "The FKS regions are combined with resonance information: "
        n_res = size (fks_mapping%res_map%res_histories)
        write (u, '(A,1X,I1)') "Number of QCD resonance histories: ", n_res
        do j = 1, n_res
           write (u, '(A,1X,I1)') "i_res = ", j
           call fks_mapping%res_map%res_histories(j)%write (u)
           call write_separator (u)
        end do
     end select

   contains

     function flst_title_format (n) result (frmt)
       integer, intent(in) :: n
       type(string_t) :: frmt
       character(len=2) :: frmt_char
       write (frmt_char, '(I2)') 4 * n + 1
       frmt = var_str (frmt_char)
     end function flst_title_format

    function ftuple_title_format () result (frmt)
       type(string_t) :: frmt
       character(len=2) :: frmt_char
       write (frmt_char, '(I2)') 10 * maxnregions + 1
       frmt = var_str (frmt_char)
    end function ftuple_title_format

  end subroutine region_data_write

@ %def region_data_write
@
<<fks regions: procedures>>=
  subroutine write_vline (u)
    integer, intent(in) :: u
    character(len=10), parameter :: sep_format = "(1X,A2,1X)"
    write (u, sep_format, advance = 'no') '||'
  end subroutine write_vline

@ %def write_vline
@
<<fks regions: public>>=
  public :: assignment(=)
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure region_data_assign
  end interface

<<fks regions: procedures>>=
  subroutine region_data_assign (reg_data_out, reg_data_in)
    type(region_data_t), intent(out) :: reg_data_out
    type(region_data_t), intent(in) :: reg_data_in
    integer :: i
    if (allocated (reg_data_in%regions)) then
       allocate (reg_data_out%regions (size (reg_data_in%regions)))
       do i = 1, size (reg_data_in%regions)
          reg_data_out%regions(i) = reg_data_in%regions(i)
       end do
    else
       call msg_warning ("Copying region data without allocated singular regions!")
    end if
    if (allocated (reg_data_in%flv_born)) then
       allocate (reg_data_out%flv_born (size (reg_data_in%flv_born)))
       do i = 1, size (reg_data_in%flv_born)
          reg_data_out%flv_born(i) = reg_data_in%flv_born(i)
       end do
    else
       call msg_warning ("Copying region data without allocated born flavor structure!")
    end if
    if (allocated (reg_data_in%flv_real)) then
       allocate (reg_data_out%flv_real (size (reg_data_in%flv_real)))
       do i = 1, size (reg_data_in%flv_real)
          reg_data_out%flv_real(i) = reg_data_in%flv_real(i)
       end do
    else
       call msg_warning ("Copying region data without allocated real flavor structure!")
    end if
    if (allocated (reg_data_in%emitters)) then
       allocate (reg_data_out%emitters (size (reg_data_in%emitters)))
       do i = 1, size (reg_data_in%emitters)
          reg_data_out%emitters(i) = reg_data_in%emitters(i)
       end do
    else
       call msg_warning ("Copying region data without allocated emitters!")
    end if
    reg_data_out%n_regions = reg_data_in%n_regions
    reg_data_out%n_emitters = reg_data_in%n_emitters
    reg_data_out%n_flv_born = reg_data_in%n_flv_born
    reg_data_out%n_flv_real = reg_data_in%n_flv_real
    reg_data_out%n_in = reg_data_in%n_in
    reg_data_out%nlegs_born = reg_data_in%nlegs_born
    reg_data_out%nlegs_real = reg_data_in%nlegs_real
    if (allocated (reg_data_in%underlying_borns)) then
       allocate (reg_data_out%underlying_borns (size (reg_data_in%underlying_borns)))
       reg_data_out%underlying_borns = reg_data_in%underlying_borns
    else
       call msg_warning ("Copying region data without allocated underlying born flavor indices!")
    end if
    reg_data_out%flv_extra = reg_data_in%flv_extra
    if (allocated (reg_data_in%fks_mapping)) then
       select type (fks_mapping_in => reg_data_in%fks_mapping)
       type is (fks_mapping_default_t)
          allocate (fks_mapping_default_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_default_t)
             fks_mapping_out = fks_mapping_in
          end select
       type is (fks_mapping_resonances_t)
          allocate (fks_mapping_resonances_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_resonances_t)
             fks_mapping_out = fks_mapping_in
          end select
       end select
    else
       call msg_warning ("Copying region data without allocated FKS regions!")
    end if
    if (allocated (reg_data_in%resonances)) then
       allocate (reg_data_out%resonances (size (reg_data_in%resonances)))
       reg_data_out%resonances = reg_data_in%resonances
    end if
    reg_data_out%n_phs = reg_data_in%n_phs
    if (allocated (reg_data_in%alr_contributors)) then
       allocate (reg_data_out%alr_contributors (size (reg_data_in%alr_contributors)))
       reg_data_out%alr_contributors = reg_data_in%alr_contributors
    end if
    if (allocated (reg_data_in%alr_to_i_contributor)) then
       allocate (reg_data_out%alr_to_i_contributor &
          (size (reg_data_in%alr_to_i_contributor)))
       reg_data_out%alr_to_i_contributor = reg_data_in%alr_to_i_contributor
    end if
  end subroutine region_data_assign

@ %def region_data_assign
@ Returns the index of the real flavor structure an ftuple belogs to.
<<fks regions: procedures>>=
  function region_to_index (list, i) result(index)
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: list
    integer, intent(in) :: i
    integer :: index, nlist, j
    integer, dimension(:), allocatable :: nreg
    nlist = size(list)
    allocate (nreg (nlist))
    index = 0
    do j = 1, nlist
       if (j == 1) then
          nreg(j) = list(j)%get_n_tuples ()
       else
          nreg(j) = nreg(j-1) + list(j)%get_n_tuples ()
       end if
    end do
    do j = 1, nlist
       if (j == 1) then
          if (i <= nreg(j)) then
             index = j
             exit
          end if
       else
          if (i > nreg(j-1) .and. i <= nreg(j)) then
             index = j
             exit
          end if
       end if
    end do
  end function region_to_index

@ %def region_to_index
@ Final state emission: Rearrange the flavor array in such a way that
the emitted particle is last and the emitter is second last. [[i1]] is
the index of the emitter, [[i2]] is the index of the emitted particle.

Initial state emission: Just put the emitted particle to the last
position.
<<fks regions: procedures>>=
  function create_alr (flv1, n_in, i_em, i_rad) result(flv2)
    type(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: n_in
    integer, intent(in) :: i_em, i_rad
    type(flv_structure_t) :: flv2
    integer :: n
    n = size (flv1%flst)
    allocate (flv2%flst (n))
    if (i_em > n_in) then
       flv2%flst(1:2) = flv1%flst(1:2)
       flv2%flst(n-1) = flv1%flst(i_em)
       flv2%flst(n) = flv1%flst(i_rad)
       call fill_remaining_flavors (n_in, .true.)
    else
       flv2%flst(1:2) = flv1%flst(1:2)
       flv2%flst(n) = flv1%flst(i_rad)
       call fill_remaining_flavors (n_in, .false.)
    end if
  contains
@ Order remaining particles according to their original position
<<fks regions: procedures>>=
    subroutine fill_remaining_flavors (n_in, final_final)
      integer, intent(in) :: n_in
      logical, intent(in) :: final_final
      integer :: i, j
      logical :: check
      j = n_in + 1
      do i = n_in + 1, n
         if (final_final) then
            check = (i /= i_em .and. i /= i_rad)
         else
            check = (i /= i_rad)
         end if
         if (check) then
            flv2%flst(j) = flv1%flst(i)
            j = j+1
         end if
      end do
    end subroutine fill_remaining_flavors
  end function create_alr

@ %def create_alr
@ Explain
<<fks regions: procedures>>=
  subroutine fks_permute_born (flv_in, n_in, flv_out, perm_list)
    type(flv_structure_t), intent(in) :: flv_in
    integer, intent(in) :: n_in
    type(flv_structure_t), intent(inout) :: flv_out
    integer, intent(out), dimension(:,:), allocatable :: perm_list
    integer, dimension(:,:), allocatable :: perm_list_tmp
    integer :: n_perms, n_perms_max
    integer :: nlegs
    integer :: flv1, flv2, tmp
    integer :: i, j, j_min
    n_perms_max = 100
    !!! actually (n-1)!, but there seems to be no intrinsic function
    !!! of this type in fortran
    if (allocated (perm_list_tmp)) deallocate (perm_list_tmp)
    allocate (perm_list_tmp (n_perms_max,2))
    n_perms = 0
    j_min = n_in + 1
    nlegs = size (flv_in%flst)
    do i = n_in + 1, nlegs
       flv1 = flv_in%flst(i)
       do j = j_min, nlegs
          flv2 = flv_out%flst(j)
          if (flv1 == flv2 .and. i /= j) then
             n_perms = n_perms + 1
             tmp = flv_out%flst(i)
             flv_out%flst(i) = flv2
             flv_out%flst(j) = tmp
             perm_list_tmp (n_perms, 1) = j
             perm_list_tmp (n_perms, 2) = i
             j_min = j_min + 1
             exit
          end if
       end do
    end do
    allocate (perm_list (n_perms, 2))
    perm_list (1:n_perms, :) = perm_list_tmp (1:n_perms, :)
  end subroutine fks_permute_born

@ %def fks_permute_born
@ Explain
<<fks regions: procedures>>=
  subroutine fks_apply_perm (flv, emitter, perm_list)
    type(flv_structure_t), intent(inout) :: flv
    integer, intent(inout) :: emitter
    integer, intent(in), dimension(:,:), allocatable :: perm_list
    integer :: i
    integer :: i1, i2
    integer :: tmp
    do i = 1, size (perm_list (:,1))
       i1 = perm_list (i,1)
       i2 = perm_list (i,2)
       tmp = flv%flst (i1)
       flv%flst (i1) = flv%flst (i2)
       flv%flst (i2) = tmp
       if (i1 == emitter) emitter = i2
    end do
  end subroutine fks_apply_perm

@ %def fks_apply_perm
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij), deferred :: dij
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij (map, p, i, j, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij
  end interface

@ %def fks_mapping_dij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij), deferred :: compute_sumdij
<<fks regions: interfaces>>=
  abstract interface
    !!!function fks_mapping_compute_sumdij (map, sregion, p) result (d)
    subroutine fks_mapping_compute_sumdij (map, sregion, p)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p
      !!!real(default) :: d
    !!!end function fks_mapping_compute_sumdij
    end subroutine fks_mapping_compute_sumdij
  end interface

@ %def fks_mapping_compute_sumdij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue), deferred :: svalue
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue (map, p, i, j, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue
  end interface

@ %def fks_mapping_svalue
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij_soft), deferred :: dij_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij_soft (map, p_born, p_soft, em, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij_soft
  end interface

@ %def fks_mapping_dij_soft
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij_soft), deferred :: compute_sumdij_soft
<<fks regions: interfaces>>=
  abstract interface
    !!!function fks_mapping_compute_sumdij_soft (map, sregion, p_born, p_soft) result (d)
    subroutine fks_mapping_compute_sumdij_soft (map, sregion, p_born, p_soft)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      !!!real(default) :: d
    !!!end function
    end subroutine fks_mapping_compute_sumdij_soft
  end interface
@ %def fks_mapping_compute_sumdij_soft
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue_soft), deferred :: svalue_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue_soft
  end interface

@ %def fks_mapping_svalue_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: set_parameter => fks_mapping_default_set_parameter
<<fks regions: procedures>>=
  subroutine fks_mapping_default_set_parameter (map, n_in, dij_exp1, dij_exp2)
    class(fks_mapping_default_t), intent(inout) :: map
    integer, intent(in) :: n_in
    real(default), intent(in) :: dij_exp1, dij_exp2
    map%n_in = n_in
    map%exp_1 = dij_exp1
    map%exp_2 = dij_exp2
  end subroutine fks_mapping_default_set_parameter

@ %def fks_mapping_default_set_parameter
@ Computes the $d_{ij}$-quantities defined als follows:
\begin{align*}
  d_{0i} &= \left[E_i^2\left(1-y_i\right)\right]^{p_1}\\,
  d_{1i} &= \left[2E_i^2\left(1-y_i\right)\right]^{p_1}\\,
  d_{2i} &= \left[2E_i^2\left(1+y_i\right)\right]^{p_1}\\,
\end{align*}
for initial state regions and
\begin{align*}
  d_{ij} = \left[2(k_i \cdot k_j) \frac{E_i E_j}{(E_i+E_j)^2}\right]^{p_2}
\end{align*}
for final state regions. The exponents $p_1$ and $p_2$ can be used for
tuning the efficiency of the mapping and are set to $1$ per default.
<<fks regions: fks mapping default: TBP>>=
  procedure :: dij => fks_mapping_default_dij
<<fks regions: procedures>>=
  function fks_mapping_default_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    real(default) :: y, E1, E2
    d = 0
    !!! FSR Region
    if (i /= j) then
        if (i > map%n_in .and. j > map%n_in) then
           E1 = p(i)%p(0); E2 = p(j)%p(0)
           d = (two * p(i) * p(j) * E1 * E2 / (E1 + E2)**2)**map%exp_1
        else
           select case (map%n_in)
           case (1)
              call get_emitter_variables (1, i, j, p, E1, y)
              d = ( E1**2 * (one - y**2) )**map%exp_2
           case (2)
              if ((i == 0 .and. j > 2) .or. (j == 0 .and. i > 2)) then
                 call get_emitter_variables (0, i, j, p, E1, y)
                 d = ( E1**2 * (one - y**2) )**map%exp_2
              else if ((i == 1 .and. j > 2) .or. (j == 1 .and. i > 2)) then
                 call get_emitter_variables (1, i, j, p, E1, y)
                 d = ( 2 * E1**2 * (one - y) )**map%exp_2
              else if ((i == 2 .and. j > 2) .or. (j == 2 .and. i > 2)) then
                 call get_emitter_variables (2, i, j, p, E1, y)
                 d = (2 * E1**2 * (one + y) )**map%exp_2
              else
                 call msg_fatal ("FKS: Region with i, j <= 2 encountered")
              end if
           end select
        end if
    else
      call msg_fatal ("Invalid FKS region: Emitter equals FKS parton!")
    end if
  contains
    subroutine get_emitter_variables (i_check, i, j, p, E, y)
       integer, intent(in) :: i_check, i, j
       type(vector4_t), intent(in), dimension(:) :: p
       real(default), intent(out) :: E, y
       if (j == i_check) then
           E = energy (p(i))
           y = polar_angle_ct (p(i))
       else
           E = energy (p(j))
           y = polar_angle_ct(p(j))
       end if
    end subroutine get_emitter_variables

  end function fks_mapping_default_dij

@  %def fks_mapping_default_dij
@ Computes the quantity
\begin{equation*}
  \mathcal{D} = \sum_k \frac{1}{d_{0k}} + \sum_{kl} \frac{1}{d_{kl}}.
\end{equation*}
<<fks regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij => fks_mapping_default_compute_sumdij
<<fks regions: procedures>>=
  subroutine fks_mapping_default_compute_sumdij (map, sregion, p)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: d, dij
    integer :: alr, i, j
    integer :: nlegreal

    associate (ftuples => sregion%ftuples)
      d = zero
      do alr = 1, sregion%nregions
        call ftuples(alr)%get (i, j)
        dij = map%dij (p, i, j)
        d = d + one / dij
      end do
    end associate
    map%sumdij = d
  end subroutine fks_mapping_default_compute_sumdij

@ %def fks_mapping_default_compute_sumdij
@ Computes
\begin{equation*}
  S_i = \frac{1}{\mathcal{D} d_{0i}}
\end{equation*}
or
\begin{equation*}
  S_{ij} = \frac{1}{\mathcal{D} d_{ij}},
\end{equation*}
respectively.
<<fks regions: fks mapping default: TBP>>=
  procedure :: svalue => fks_mapping_default_svalue
<<fks regions: procedures>>=
  function fks_mapping_default_svalue (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    value = one / (map%dij (p, i, j) * map%sumdij)
  end function fks_mapping_default_svalue

@ %def fks_mapping_default_svalue
@ In the soft limit, our treatment of the divergences requires a
modification of the mapping functions. Recall that there, the ratios of
the $d$-functions must approach either $1$ or $0$. This means
\begin{equation*}
  \frac{d_{lm}}{d_{0m}} = \frac{(2k_l \cdot k_m) \left[E_lE_m /(E_l + E_m)^2\right]}{E_m^2 (1-y^2)} =
    \overset {k_m = E_m \hat{k}} {=} \frac{E_l E_m^2}{(E_l + E_m)^2} \frac{2k_l \cdot \hat{k}}{E_m^2 (1-y^2)}
    \overset {E_m \rightarrow 0}{=} \frac{2}{k_l \cdot \hat{k}}{(1-y^2)E_l},
\end{equation*}
where we have written the gluon momentum in terms of the soft momentum
$\hat{k}$. In the same limit
\begin{equation*}
  \frac{d_{lm}}{d_{nm}} = \frac{k_l \cdot \hat{k}}{k_n \cdot \hat{k}} \frac{E_n}{E_l}.
\end{equation*}
From these equations we can deduce the soft limit of $d$:
\begin{align*}
  d_0^{\rm{soft}} &= 1 - y^2,\\
  d_1^{\rm{soft}} &= 2(1-y),\\
  d_2^{\rm{soft}} &= 2(1+y),\\
  d_i^{\rm{soft}} &= \frac{2 k_i \cdot \hat{k}}{E_i}.
\end{align*}
<<fks regions: fks mapping default: TBP>>=
  procedure :: dij_soft => fks_mapping_default_dij_soft
<<fks regions: procedures>>=
  function fks_mapping_default_dij_soft (map, p_born, p_soft, em, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_con
    real(default) :: y
    if (em <= map%n_in) then
       y = polar_angle_ct (p_soft)
       select case (map%n_in)
       case (1)
          d = one - y**2
       case (2)
          select case (em)
          case (0)
             d = one - y**2
          case (1)
             d = two * (one - y)
          case (2)
             d = two * (one + y)
          case default
             d = zero
             call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
          end select
       case default
          d = zero
          call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
       end select
       d = d**map%exp_2
    else
       d = (two * p_born(em) * p_soft / p_born(em)%p(0))**map%exp_1
    end if
  end function fks_mapping_default_dij_soft

@ %def fks_mapping_default_dij_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_default_compute_sumdij_soft
<<fks regions: procedures>>=
  subroutine fks_mapping_default_compute_sumdij_soft (map, sregion, p_born, p_soft)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d, dij
    integer :: alr, i, j
    integer :: nlegs
    d = zero
    nlegs = size (sregion%flst_real%flst)
    associate (ftuples => sregion%ftuples)
      do alr = 1, sregion%nregions
        call ftuples(alr)%get (i ,j)
        if (j == nlegs) then
          dij = map%dij_soft (p_born, p_soft, i)
          d = d + one / dij
        end if
      end do
    end associate
    map%sumdij_soft = d
  !!!end function fks_mapping_default_compute_sumdij_soft
  end subroutine fks_mapping_default_compute_sumdij_soft

@ %def fks_mapping_default_compute_sumdij_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: svalue_soft => fks_mapping_default_svalue_soft
<<fks regions: procedures>>=
  function fks_mapping_default_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    value = one / (map%sumdij_soft * map%dij_soft (p_born, p_soft, em))
  end function fks_mapping_default_svalue_soft

@ %def fks_mapping_default_svalue_soft
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_default_assign
  end interface

<<fks regions: procedures>>=
  subroutine fks_mapping_default_assign (fks_map_out, fks_map_in)
    type(fks_mapping_default_t), intent(out) :: fks_map_out
    type(fks_mapping_default_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%n_in = fks_map_in%n_in
  end subroutine fks_mapping_default_assign

@ %def fks_mapping_default_assign
@ The $d_{ij,k}$-functions for the resonance mapping are basically the same
as in the default case, but the kinematical values here must be evaluated
in the resonance frame of reference. The energy of parton $i$ in a given
resonance frame with momentum $p_{res}$ is
\begin{equation*}
   E_i = \frac{p_i^0 \cdot p_{res}}{m_{res}}.
\end{equation*}
However, since the expressions only depend on ratios of four-momenta, we 
leave out the denominator because it will cancel out anyway.
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: dij => fks_mapping_resonances_dij
<<fks regions: procedures>>=
  function fks_mapping_resonances_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    real(default) :: E1, E2
    integer :: ii_con
    if (present (i_con)) then
       ii_con = i_con
    else
       call msg_fatal ("Resonance mappings require resonance index as input!")
    end if
    d = 0
    if (map%pseudo_isr) then
       associate (p_res => map%res_map%p_res (ii_con))
          E1 = p_res**2; E2 = p(j) * p_res
          d = two * p_res * p(j) * E1 * E2 / (E1 + E2)**2
       end associate
    else
       if (i /= j) then
          if (i > 2 .and. j > 2) then
             associate (p_res => map%res_map%p_res (ii_con))
                E1 = p(i) * p_res
                E2 = p(j) * p_res
                d = two * p(i) * p(j) * E1 * E2 / (E1 + E2)**2 
             end associate
          else
             call msg_fatal ("Resonance mappings are not implemented for ISR")
          end if
       end if
    end if
  end function fks_mapping_resonances_dij

@ %def fks_mapping_resonances_dij
@ Computes
\begin{equation*}
  S_\alpha = \frac{P^{f_r(\alpha)}d^{-1}(\alpha)}
     {\sum_{f_r' \in T(F_r(\alpha))}P^{f_r'}\sum_{\alpha' \in Sr(f_r')}d^{-1}(\alpha)}.
\end{equation*}
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij => fks_mapping_resonances_compute_sumdij
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_compute_sumdij (map, sregion, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: d, dij, pfr
    integer :: i_res, i_reg, i, j, i_con, i_em
    integer :: nlegreal

    nlegreal = size (p)
    d = zero
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get (i, j)
          i_res = ftuple%i_res
       end associate
       i_em = get_emitter_index (i, j, nlegreal)
       pfr = map%res_map%get_resonance_value (i_res, p, i_em, nlegreal) 
       i_con = sregion%i_reg_to_i_con (i_reg) 
       map%pseudo_isr = sregion%pseudo_isr
       d = d + pfr / map%dij (p, i, j, i_con)
    end do
    map%sumdij = d
  contains
    function get_emitter_index (i1, i2, n) result (i_em)
       integer :: i_em
       integer, intent(in) :: i1, i2, n
       if (i1 == n) then
          i_em = i2
       else
          i_em = i1
       end if
    end function get_emitter_index
  end subroutine fks_mapping_resonances_compute_sumdij

@ %def fks_mapping_resonances_compute_sumdij
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: svalue => fks_mapping_resonances_svalue
<<fks regions: procedures>>=
  function fks_mapping_resonances_svalue (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    integer :: i_gluon
    i_gluon = size (p)
    pfr = map%res_map%get_resonance_value (i_res, p, map%emitter, i_gluon)
    value = pfr / (map%dij (p, i, j, map%i_con) * map%sumdij)
  end function fks_mapping_resonances_svalue

@ %def fks_mapping_resonances_svalue
@ As above, the soft limit of $d_{ij,k}$ must be computed in the resonance frame of
reference. 
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: dij_soft => fks_mapping_resonances_dij_soft
<<fks regions: procedures>>=
  function fks_mapping_resonances_dij_soft (map, p_born, p_soft, em, i_con) result (d)
     real(default) :: d
     class(fks_mapping_resonances_t), intent(in) :: map
     type(vector4_t), intent(in), dimension(:) :: p_born
     type(vector4_t), intent(in) :: p_soft
     integer, intent(in) :: em
     integer, intent(in), optional :: i_con
     real(default) :: E1, E2
     integer :: ii_con
     integer :: i
     type(vector4_t) :: pb
     if (present (i_con)) then
        ii_con = i_con
     else
        call msg_fatal ("fks_mapping_resonances requires resonance index")
     end if
     associate (p_res => map%res_map%p_res(ii_con))
        if (map%pseudo_isr) then
           pb = p_res
        else
           pb = p_born(em)
        end if
        E1 = pb * p_res
        E2 = p_soft * p_res
        d = two * pb * p_soft * E1 * E2 / E1**2
     end associate
  end function fks_mapping_resonances_dij_soft

@ %def fks_mapping_resonances_dij_soft
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_resonances_compute_sumdij_soft
<<fks regions: procedures>>=
  !!!function fks_mapping_resonances_compute_sumdij_soft (map, sregion, p_born, p_soft) result (d)
  subroutine fks_mapping_resonances_compute_sumdij_soft (map, sregion, p_born, p_soft)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    real(default) :: pfr
    integer :: i_res, i_alr, i, j, i_reg, i_con
    integer :: nlegs

    d = zero
    nlegs = size (sregion%flst_real%flst)
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get(i, j)
          i_res = ftuple%i_res
       end associate
       pfr = map%res_map%get_resonance_value (i_res, p_born) 
       i_con = sregion%i_reg_to_i_con (i_reg)
       map%pseudo_isr = sregion%pseudo_isr
       if (j == nlegs) d = d + pfr / map%dij_soft (p_born, p_soft, i, i_con)
    end do
    map%sumdij_soft = d
  end subroutine fks_mapping_resonances_compute_sumdij_soft

@ %def fks_mapping_resonances_compute_sumdij_soft
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: svalue_soft => fks_mapping_resonances_svalue_soft
<<fks regions: procedures>>=
  function fks_mapping_resonances_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    pfr = map%res_map%get_resonance_value (i_res, p_born)
    value = pfr / (map%sumdij_soft * map%dij_soft (p_born, p_soft, em, map%i_con))
  end function fks_mapping_resonances_svalue_soft

@ %def fks_mapping_resonances_svalue_soft
@ 
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momentum => fks_mapping_resonances_set_resonance_momentum
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_set_resonance_momentum (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momentum

@ %def fks_mapping_resonances_set_resonance_momentum
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momenta => fks_mapping_resonances_set_resonance_momenta
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_set_resonance_momenta (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momenta

@ %def fks_mapping_resonances_set_resonance_momenta
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_resonances_assign
  end interface

<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_assign (fks_map_out, fks_map_in)
    type(fks_mapping_resonances_t), intent(out) :: fks_map_out
    type(fks_mapping_resonances_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%res_map = fks_map_in%res_map
  end subroutine fks_mapping_resonances_assign

@ %def fks_mapping_resonances_assign
@ 
<<fks regions: public>>=
  public :: create_resonance_histories_for_threshold
<<fks regions: procedures>>=
  function create_resonance_histories_for_threshold () result (res_history)
    type(resonance_history_t) :: res_history
    res_history%n_resonances = 2  
    allocate (res_history%resonances (2))
    allocate (res_history%resonances(1)%contributors%c(2))
    allocate (res_history%resonances(2)%contributors%c(2))
    res_history%resonances(1)%contributors%c = [THR_POS_WP, THR_POS_B]
    res_history%resonances(2)%contributors%c = [THR_POS_WM, THR_POS_BBAR]
  end function create_resonance_histories_for_threshold
    
@ %def create_resonance_histories_for_threshold
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Virtual contribution to the cross section}
<<[[virtual.f90]]>>=
<<File header>>

module virtual

<<Use kinds>>
<<Use strings>>
  use numeric_utils
  use constants
  use diagnostics
  use pdg_arrays
  use model_data
  use physics_defs
  use sm_physics
  use lorentz
  use flavors
  use nlo_data, only: NO_FACTORIZATION, FACTORIZATION_THRESHOLD
  use ttv_formfactors, only: THR_POS_B, THR_POS_BBAR
  use ttv_formfactors, only: THR_POS_WP, THR_POS_WM
  use fks_regions

<<Standard module head>>

<<virtual: public>>

<<virtual: types>>

contains

<<virtual: procedures>>

end module virtual
@ %def virtual
@
<<virtual: public>>=
  public :: virtual_t
<<virtual: types>>=
  type :: virtual_t
    real(default) :: Q
    real(default), dimension(:,:), allocatable :: I
    real(default) :: vfin
    real(default) :: sqme_cc
    real(default) :: sqme_virt
    real(default), dimension(:,:), allocatable :: gamma_0, gamma_p, c_flv
    real(default) :: ren_scale2, fac_scale
    integer, dimension(:), allocatable :: n_is_neutrinos
    integer :: n_in, nlegs, nflv
    logical :: bad_point
    logical :: use_internal_color_correlations
    integer :: factorization_mode = NO_FACTORIZATION
  contains
  <<virtual: virtual: TBP>>
  end type virtual_t

@ %def virtual_t
@
<<virtual: virtual: TBP>>=
  procedure :: init => virtual_init
<<virtual: procedures>>=
 subroutine virtual_init (virt, flv_born, n_in)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer, intent(in) :: n_in
    integer :: i_flv
    virt%nlegs = size (flv_born, 1); virt%nflv = size (flv_born, 2)
    virt%n_in = n_in
    allocate (virt%I (virt%nlegs, virt%nlegs))
    allocate (virt%gamma_0 (virt%nlegs, virt%nflv), &
              virt%gamma_p (virt%nlegs, virt%nflv), &
              virt%c_flv (virt%nlegs, virt%nflv))
    call virt%init_constants (flv_born)
    allocate (virt%n_is_neutrinos (virt%nflv))
    virt%n_is_neutrinos = 0
    do i_flv = 1, virt%nflv
       if (is_neutrino (flv_born(1, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
       if (is_neutrino (flv_born(2, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
    end do
  contains
    function is_neutrino (flv) result (neutrino)
      integer, intent(in) :: flv
      logical :: neutrino
      neutrino = (abs(flv) == 12 .or. abs(flv) == 14 .or. abs(flv) == 16)
    end function is_neutrino
  end subroutine virtual_init

@ %def virtual_init
@ Write down constant definition somewhere
<<virtual: virtual: TBP>>=
  procedure :: init_constants => virtual_init_constants
<<virtual: procedures>>=
  subroutine virtual_init_constants (virt, flv_born)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer :: i_part, i_flv
    integer, parameter :: nf = 1
    do i_flv = 1, size (flv_born, 2)
       do i_part = 1, size (flv_born, 1)
          if (is_gluon (flv_born(i_part, i_flv))) then
             virt%gamma_0(i_part, i_flv) = (11 * ca - 2 * nf) / 6
             virt%gamma_p(i_part, i_flv) = (67.0 / 9 - 2 * pi**2 / 3) * ca &
                - 23.0 / 18 * nf
             virt%c_flv(i_part, i_flv) = ca
          else if (is_quark (abs(flv_born(i_part, i_flv)))) then
             virt%gamma_0(i_part, i_flv) = 1.5 * cf
             virt%gamma_p(i_part, i_flv) = (6.5 - 2 * pi**2 / 3) * cf
             virt%c_flv(i_part, i_flv) = cf
          else
             virt%gamma_0(i_part, i_flv) = zero
             virt%gamma_p(i_part, i_flv) = zero
             virt%c_flv(i_part, i_flv) = zero
          end if
       end do
    end do
  end subroutine virtual_init_constants

@ %def virtual_init_constants
@ Set the renormalization scale. If the input is zero, use the
center-of-mass energy.
<<virtual: virtual: TBP>>=
  procedure :: set_ren_scale => virtual_set_ren_scale
<<virtual: procedures>>=
  subroutine virtual_set_ren_scale (virt, p, ren_scale)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    if (ren_scale > 0) then
      virt%ren_scale2 = ren_scale**2
    else
      virt%ren_scale2 = (p(1) + p(2))**2
    end if
  end subroutine virtual_set_ren_scale

@ %def virtual_set_ren_scale
@
<<virtual: virtual: TBP>>=
  procedure :: set_fac_scale => virtual_set_fac_scale
<<virtual: procedures>>=
  subroutine virtual_set_fac_scale (virt, p, fac_scale)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), optional :: fac_scale
    if (present (fac_scale)) then
       virt%fac_scale = fac_scale
    else
       virt%fac_scale = (p(1) + p(2))**1
    end if
  end subroutine virtual_set_fac_scale

@ %def virtual_set_fac_scale
@ The virtual-subtracted matrix element is given by the equation
\begin{equation}
  \label{virt_sub}
  \mathcal{V} = \frac{\alpha_s}{2\pi}\left(\mathcal{Q}\mathcal{B} +
  \sum \mathcal{I}_{ij}\mathcal{B}_{ij} + \mathcal{V}_{fin}\right),
\end{equation}
where the quantity $\mathcal{Q}$ is given by
\begin{equation}
  \begin{split}
    \mathcal{Q} = \sum_{i=3}^n&\left[\gamma'_{f_i} - \log\frac{s}{Q^2}
                  \left(\gamma_{f_i} - 2C_{f_i}\log\frac{2E_i}{\sqrt{s}}\right)\right.\\
                  &\left. +2C_{f_i}\log^2\frac{2E_i}{\sqrt{s}} - 2\gamma_{f_i}\frac{2E_i}{\sqrt{s}}\right]\\
                  &- \log\frac{\mu_F^2}{Q^2}\left(\gamma_{f+} + \gamma_{f-}\right).
  \end{split}
  \label{virt_Q}
\end{equation}
Note that the summation only runs over final-state particles.
The expressions for $\mathcal{I}_{ij}$ can be found in equations
(\ref{I_00}), (\ref{I_mm}), (\ref{I_0m}), depending on whether the
particles involved in the radiation process are massive or massless.
<<virtual: virtual: TBP>>=
  procedure :: evaluate => virtual_evaluate
<<virtual: procedures>>=
  subroutine virtual_evaluate &
       (virt, reg_data, i_flv, alpha_s, p_born, born, b_ij)
    class(virtual_t), intent(inout) :: virt
    type(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_flv
    real(default), intent(in) :: alpha_s
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in) :: born
    real(default), intent(in), dimension(:,:,:), allocatable :: b_ij
    integer :: alr
    real(default) :: s, BI, s_o_mu2
    virt%sqme_virt = zero
    virt%Q = zero
    if (virt%bad_point) return
    alr = find_first_matching_uborn (reg_data, i_flv)
    if (debug2_active (D_VIRTUAL)) then
       print *, 'Compute virtual component using phase space point: '
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       print *, 'Compute virtual component using alpha_s = ', alpha_s
    end if
    associate (flst_born => reg_data%regions(alr)%flst_uborn)
       s = sum (p_born(1:virt%n_in))**2
       s_o_mu2 = s / virt%ren_scale2
       call virt%evaluate_initial_state (sqrt(s), i_flv)
       call virt%compute_collinear_contribution &
          (p_born, sqrt(s), i_flv, flst_born%massive) 

       select case (virt%factorization_mode)
       case (FACTORIZATION_THRESHOLD)
          BI = virt%compute_eikonals_threshold (p_born, s, s_o_mu2, &
               i_flv, alr, reg_data, flst_born, b_ij)
       case default
          BI = virt%compute_eikonals (p_born, s, s_o_mu2, &
               i_flv, alr, reg_data, flst_born, b_ij)
       end select

       if (debug2_active (D_VIRTUAL)) then
         call msg_debug2 (D_VIRTUAL, "Compute Q")
         print *, 'massive flavors: ', flst_born%massive
         print *, 'Q: ', virt%Q
       end if
    end associate
    if (virt%use_internal_color_correlations) BI = BI * born
    !!! A factor of alpha_s/twopi is assumed to be included in vfin
    virt%sqme_virt = alpha_s / twopi * (virt%Q * born + BI) + virt%vfin

    if (debug2_active (D_VIRTUAL)) then
       call msg_debug2 (D_VIRTUAL, "virtual-subtracted matrix element: ")
       print *, 'Q * born: ', virt%Q * born
       print *, 'BI: ', BI
       print *, 'vfin: ', virt%vfin
       print *, 'Result: ', virt%sqme_virt
    end if

    if (virt%n_is_neutrinos(i_flv) > 0) &
        virt%sqme_virt = virt%sqme_virt * virt%n_is_neutrinos(i_flv) * two

  contains

    function find_first_matching_uborn (reg_data, i_proc) result (alr_out)
       type(region_data_t), intent(in) :: reg_data
       integer, intent(in) :: i_proc
       integer :: alr_out
       integer :: k
       alr_out = 0
       do k = 1, reg_data%n_regions
          alr_out = alr_out+1
          if (reg_data%regions(k)%uborn_index == i_proc) exit
       end do
    end function find_first_matching_uborn

  end subroutine virtual_evaluate

@ %def virtual_evaluate
@
@
<<virtual: virtual: TBP>>=
  procedure :: compute_eikonals => virtual_compute_eikonals
<<virtual: procedures>>=
  function virtual_compute_eikonals (virtual, p_born, s, s_o_mu2, i_flv, &
         alr, reg_data, flst_born, b_ij) result (BI)
    real(default) :: BI
    class(virtual_t), intent(inout) :: virtual
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in) :: s, s_o_mu2
    integer, intent(in) :: i_flv, alr
    type(region_data_t), intent(in) :: reg_data
    type(flv_structure_t), intent(in) :: flst_born
    real(default), intent(in), dimension(:,:,:), allocatable :: b_ij
    integer :: i, j
    BI = zero
    call virtual%compute_massive_self_eikonals &
         (p_born, s, i_flv, flst_born%massive)
    do i = 1, virtual%nlegs
       do j = 1, virtual%nlegs
          if (i /= j) then
             if (flst_born%colored(i) .and. flst_born%colored(j)) then
                call virtual%compute_eikonal_factor (p_born, flst_born%massive, i, j, s_o_mu2)
                BI = BI + b_ij (i, j, reg_data%regions(alr)%uborn_index) * virtual%I(i, j)
                if (debug2_active (D_VIRTUAL)) &
                   print *, 'b_ij: ', b_ij (i,j, reg_data%regions(alr)%uborn_index), &
                          'I_ij: ', virtual%I(i,j)
             end if
          end if
       end do
    end do
  end function virtual_compute_eikonals

@ %def virtual_compute_eikonals
@
<<virtual: virtual: TBP>>=
  procedure :: compute_eikonals_threshold => virtual_compute_eikonals_threshold
<<virtual: procedures>>=
  function virtual_compute_eikonals_threshold (virtual, p_born, s, &
         s_o_mu2, i_flv, alr, reg_data, flst_born, b_ij) result (BI)
    real(default) :: BI
    class(virtual_t), intent(inout) :: virtual
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in) :: s, s_o_mu2
    integer, intent(in) :: i_flv, alr
    type(region_data_t), intent(in) :: reg_data
    type(flv_structure_t), intent(in) :: flst_born
    real(default), intent(in), dimension(:,:,:), allocatable :: b_ij
    type(vector4_t), dimension(4) :: p
    integer :: i, j
    p(1) = p_born(THR_POS_WP) + p_born(THR_POS_B)
    p(2) = p_born(THR_POS_B)
    p(3) = p_born(THR_POS_WM) + p_born(THR_POS_BBAR)
    p(4) = p_born(THR_POS_BBAR)
    BI = evaluate_leg_pair (1) + evaluate_leg_pair (3)

  contains

    function evaluate_leg_pair (i_start) result (b_ij_times_I)
      real(default) :: b_ij_times_I
      integer, intent(in) :: i_start
      real(default) :: term1, term2
      b_ij_times_I = zero
      do i = i_start, i_start + 1
         do j = i_start, i_start + 1
            if (i /= j) then
               call virtual%compute_eikonal_factor (p, [.true., .true., .true., .true.], i, j, s_o_mu2)
               b_ij_times_I = b_ij_times_I + b_ij (i, j, reg_data%regions(alr)%uborn_index) * virtual%I(i, j)
               if (debug2_active (D_VIRTUAL)) &
                  print *, 'b_ij: ', b_ij (i,j, reg_data%regions(alr)%uborn_index), &
                         'I_ij: ', virtual%I(i,j)
            else
               !!! massive self eikonals
               term1 = log(s_o_mu2)
               term2 = 0.5_default * I_m_eps (p(i))
               virtual%Q = virtual%Q - cf * (term1 - term2)
            end if
         end do
      end do
      if (debug2_active (D_VIRTUAL)) then
         print *, 'b_ij_times_I =    ', b_ij_times_I
         print *, 'virtual%Q =    ', virtual%Q
      end if
    end function evaluate_leg_pair

  end function virtual_compute_eikonals_threshold

@ %def virtual_compute_eikonals_threshold
<<virtual: virtual: TBP>>=
  procedure :: set_vfin => virtual_set_vfin
<<virtual: procedures>>=
  subroutine virtual_set_vfin (virt, vfin)
    class(virtual_t), intent(inout) :: virt
    real(default) :: vfin
    virt%vfin = vfin
  end subroutine virtual_set_vfin

@ %def virtual_set_vfin
@
<<virtual: virtual: TBP>>=
  procedure :: set_bad_point => virtual_set_bad_point
<<virtual: procedures>>=
  subroutine virtual_set_bad_point (virt, value)
     class(virtual_t), intent(inout) :: virt
     logical, intent(in) :: value
     virt%bad_point = value
  end subroutine virtual_set_bad_point

@  %def virtual_set_bad_point
@ Note that this implementation only works for lepton collisions. This implies that both the
summand containing $\log\left(s/q^2\right)$ and the $\gamma$-factors vanish.\\
The loop over the initial-state particles obviously is only executed if we are 
dealing with a scattering process, because for decays there are no virtual
initial-initial interactions.
<<virtual: virtual: TBP>>=
  procedure :: evaluate_initial_state => virtual_evaluate_initial_state
<<virtual: procedures>>=
  subroutine virtual_evaluate_initial_state (virt, sqrts, i_flv)
    class(virtual_t), intent(inout) :: virt
    real(default), intent(in) :: sqrts
    integer, intent(in) :: i_flv
    integer :: i
    if (virt%n_in == 2) then
       do i = 1, virt%n_in
          virt%Q = virt%Q - virt%gamma_0 (i, i_flv) * &
             two * log(virt%fac_scale / sqrts)
       end do
    end if
  end subroutine virtual_evaluate_initial_state

@ %def virtual_evaluate_initial_state
@
<<virtual: virtual: TBP>>=
  procedure :: compute_collinear_contribution &
     => virtual_compute_collinear_contribution
<<virtual: procedures>>=
  subroutine virtual_compute_collinear_contribution (virt, p_born, sqrts, i_flv, massive)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), dimension(:), intent(in) :: p_born
    real(default), intent(in) :: sqrts
    integer, intent(in) :: i_flv
    logical, dimension(:), intent(in) :: massive
    real(default) :: s1, s2, s3, s4
    integer :: i
    real(default) :: twoE

    do i = 1, virt%nlegs
       !!! Not a colored particle
       if (vanishes (virt%c_flv(i, i_flv))) cycle
       !!! Collinear terms only for massless particles
       if (massive(i)) cycle
       s1 = virt%gamma_p(i, i_flv)
       twoE = two * p_born(i)%p(0)
       s2 = log (sqrts**2 / virt%ren_scale2)* &
          (virt%gamma_0(i, i_flv) - &
           two * virt%c_flv(i, i_flv) * log (twoE / sqrts))
       s3 = two * log(twoE / sqrts)**2 * virt%c_flv(i, i_flv)
       s4 = two * log(twoE / sqrts) * virt%gamma_0(i, i_flv)
       virt%Q = virt%Q + s1 - s2 + s3 - s4
    end do
  end subroutine virtual_compute_collinear_contribution

@ %def virtual_compute_collinear_contribution
@
<<virtual: virtual: TBP>>=
  procedure :: compute_massive_self_eikonals => virtual_compute_massive_self_eikonals
<<virtual: procedures>>=
  subroutine virtual_compute_massive_self_eikonals (virt, p_born, s, i_flv, massive)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: s
    integer, intent(in) :: i_flv
    logical, intent(in), dimension(:) :: massive
    real(default) :: term1, term2
    integer :: i
    do i = 1, virt%nlegs
       if (massive(i)) then
          term1 = log(s / virt%ren_scale2)
          term2 = 0.5_default * I_m_eps (p_born(i))
          virt%Q = virt%Q - virt%c_flv (i, i_flv) * (term1 - term2)
       end if
    end do
  end subroutine virtual_compute_massive_self_eikonals

@ %def virtual_compute_massive_self_eikonals
@ The following code implements the $\mathcal{I}_{ij}$-function appearing in eq. blub.
They are defined as follows:
\begin{itemize}
\item[Massles-Massles Case]
  \begin{equation}
    \begin{split}
    \mathcal{I}_{ij} &= \frac{1}{2}\log^2\frac{s}{Q^2} + \log\frac{s}{Q^2}\log\frac{k_ik_j}{2E_iE_j}
                                                       - \rm{Li}_2\left(\frac{k_ik_j}{2E_iE_j}\right) \\
                     &+ \frac{1}{2}\log^2\frac{k_ik_j}{2E_iE_j} - \log\left(1-\frac{k_ik_j}{2E_iE_j}\right)
                        \log\frac{k_ik_j}{2E_iE_j}.
    \end{split}
    \label{I_00}
  \end{equation}
\item[Massive-Massive Case]
  \begin{equation}
     \mathcal{I}_{ij} = -\frac{1}{2}I_0(k_i, k_j)\log\frac{Q^2}{s} - \frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_mm}
  \end{equation}
  with
  \begin{equation*}
    I_0(k_i, k_j) = \frac{1}{\beta}\log\frac{1+\beta}{1-\beta}, \qquad
                    \beta = \sqrt{1-\frac{k_i^2k_j^2}{(k_i \cdot k_j)^2}}
  \end{equation*}
  and a rather involved expression for $I_\epsilon$:
  \begin{align*}
    I_\epsilon(k_i, k_j) &= \left(K(z_j)-K(z_i)\right) \frac{1-\vec{\beta_i}\cdot\vec{\beta_j}}{\sqrt{a(1-b)}}, \\
    \vec{\beta_i} &= \frac{\vec{k}_i}{k_i^0}, \\
    a &= \beta_i^2 + \beta_j^2 - 2\vec{\beta}_i \cdot \vec{\beta}_j, \\
    x_i &= \frac{\beta_i^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a}, \\
    x_j &= \frac{\beta_j^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a} = 1-x_j, \\
    b &= \frac{\beta_i^2\beta_j^2 - (\vec{\beta}_i\cdot\vec{\beta}_j)^2}{a}, \\
    c &= \sqrt{\frac{b}{4a}}, \\
    z_+ &= \frac{1+\sqrt{1-b}}{\sqrt{b}}, \\
    z_- &= \frac{1-\sqrt{1-b}}{\sqrt{b}}, \\
    z_i &= \frac{\sqrt{x_i^2 + 4c^2} - x_i}{2c}, \\
    z_j &= \frac{\sqrt{x_j^2 + 4c^2} + x_j}{2c}, \\
    K(z) = &-\frac{1}{2}\log^2\frac{(z-z_-)(z_+-z)}{(z_++z)(z_-+z)} - 2Li_2\left(\frac{2z_-(z_+-z)}{(z_+-z_-)(z_-+z)}\right) \\
           &-2Li_2\left(-\frac{2z_+(z_-+z)}{(z_+-z_-)(z_+-z)}\right)
  \end{align*}

\item[Massive-Massless Case]
  \begin{equation}
     \mathcal{I}_{ij} = \frac{1}{2}\left[\log^2\frac{Q}{s} - \frac{\pi^2}{6}\right] -\frac{1}{2}I_0(k_i,k_j)\log\frac{Q^2}{s}
                       -\frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_0m}
  \end{equation}
  with
  \begin{align*}
     I_0(p,k) &= \log\frac{(\hat{p}\cdot\hat{k})^2}{\hat{k}^2}, \\
     I_\varepsilon(p,k) &= -2\left[\frac{1}{4}\log^2\frac{1-\beta}{1+\beta} + \log\frac{\hat{p}\cdot\hat{k}}{1+\beta}\log\frac{\hat{p}\cdot\hat{k}}{1-\beta}
                           +Li_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1+\beta}\right) + Li_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1-\beta}\right)\right]
  \end{align*}
  using
  \begin{equation*}
     \hat{p} = \frac{p}{p^0}, \quad \hat{k} = \frac{k}{k^0}, \quad \beta = \frac{|\vec{k}|}{k_0}.
  \end{equation*}

\end{itemize}

<<virtual: virtual: TBP>>=
  procedure :: compute_eikonal_factor => virtual_compute_eikonal_factor
<<virtual: procedures>>=
  subroutine virtual_compute_eikonal_factor (virt, p_born, massive, i, j, s_o_mu2)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), intent(in), dimension(:) :: p_born
    logical, dimension(:), intent(in) :: massive
    integer, intent(in) :: i, j
    real(default), intent(in) :: s_o_mu2
    if (massive(i) .and. massive(j)) then
       virt%I(i,j) = compute_Imm (p_born(i), p_born(j), s_o_mu2)
    else if (.not. massive(i) .and. massive(j)) then
       virt%I(i,j) = compute_I0m (p_born(i), p_born(j), s_o_mu2)
    else if (massive(i) .and. .not. massive(j)) then
       virt%I(i,j) = compute_I0m (p_born(j), p_born(i), s_o_mu2)
    else
       virt%I(i,j) = compute_I00 (p_born(i), p_born(j), s_o_mu2)
    end if
  end subroutine virtual_compute_eikonal_factor

  function compute_I00 (pi, pj, s_o_mu2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_mu2
    real(default) :: I
    real(default) :: Ei, Ej
    real(default) :: pij, Eij
    real(default) :: s1, s2, s3, s4, s5
    real(default) :: arglog
    real(default), parameter :: tiny_value = epsilon(1.0)
    s1 = 0; s2 = 0; s3 = 0; s4 = 0; s5 = 0
    Ei = pi%p(0); Ej = pj%p(0)
    pij = pi * pj; Eij = Ei * Ej
    s1 = 0.5 * log(s_o_mu2)**2
    s2 = log(s_o_mu2) * log(pij / (two * Eij))
    s3 = Li2 (pij / (two * Eij))
    s4 = 0.5 * log (pij / (two * Eij))**2
    arglog = one - pij / (2*Eij)
    if (arglog > tiny_value) then
      s5 = log(arglog) * log(pij / (two * Eij))
    else
      s5 = 0
    end if
    I = s1 + s2 - s3 + s4 - s5
  end function compute_I00

  function compute_I0m (ki, kj, s_o_mu2) result (I)
    type(vector4_t), intent(in) :: ki, kj
    real(default), intent(in) :: s_o_mu2
    real(default) :: I
    real(default) :: logsomu
    real(default) :: s1, s2, s3
    s1 = 0; s2 = 0; s3 = 0
    logsomu = log(s_o_mu2)
    s1 = 0.5 * (0.5 * logsomu**2 - pi**2 / 6)
    s2 = 0.5 * I_0m_0 (ki, kj) * logsomu
    s3 = 0.5 * I_0m_eps (ki, kj)
    I = s1 + s2 - s3
  end function compute_I0m

  function compute_Imm (pi, pj, s_o_mu2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_mu2
    real(default) :: I
    real(default) :: s1, s2
    s1 = 0.5 * log(s_o_mu2) * I_mm_0(pi, pj)
    s2 = 0.5 * I_mm_eps(pi, pj)
    I = s1 - s2
  end function compute_Imm

@ %def virtual_compute_I
@
<<virtual: procedures>>=
  function I_m_eps (p) result (I)
    type(vector4_t), intent(in) :: p
    real(default) :: I
    real(default) :: beta
    beta = space_part_norm (p)/p%p(0)
    if (beta < tiny_07) then
       I = four * (one + beta**2/3 + beta**4/5 + beta**6/7)
    else
       I = two * log((one + beta) / (one - beta)) / beta
    end if
  end function I_m_eps

@ %def I_m_eps
@ For $p^2=0$ and $k^2 \neq 0$, this computes the expression
\begin{equation*}
  I_\epsilon(p,k) = -2\left[\frac{1}{4}\log^2\frac{1-\beta}{1+\beta}
                    +\log \frac{\hat{p} \cdot k}{1+\beta}\log{\hat{p} \cdot k}{1-\beta}
                    +Li_2\left(1-\frac{\hat{p} \cdot k}{1+\beta}\right)
                    +Li_2\left(1-\frac{\hat{p} \cdot k}{1-\beta}\right)\right],
\end{equation*}
with $\hat{p} = \frac{p}{p^0}$ and $\beta = \frac{|\vec{k}|}{k^0}$.
<<virtual: procedures>>=
  function I_0m_eps (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp
    real(default) :: beta

    pp = p / p%p(0); kp = k / k%p(0)

    beta = sqrt (one - kp*kp)
    I = -2*(log((one - beta) / (one + beta))**2/4 + log((pp*kp) / (one + beta))*log((pp*kp) / (one - beta)) &
        + Li2(one - (pp*kp) / (one + beta)) + Li2(one - (pp*kp) / (one - beta)))
  end function I_0m_eps

@ %def I_0m_eps
@ For $p^2=0$ and $k^2 \neq 0$, computes the expression
\begin{equation*}
  I_0(p,k) = \log\frac{(\hat{p}\cdot\hat{k})^2}{\hat{k}^2}
\end{equation*}
<<virtual: procedures>>=
  function I_0m_0 (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp

    pp = p / p%p(0); kp = k / k%p(0)
    I = log((pp*kp)**2 / kp**2)
  end function I_0m_0

@ %def I_0m_0
@ For $k_1^2 \neq 0$ and $k_2^2 \neq 0$, computes the expression
\begin{equation*}
  I_\epsilon(k_1, k_2) = \left[K(z_2) - K(z_1)\right]
                         \frac{1-\vec{\beta}_1\cdot\vec{\beta}_2}{\sqrt{a(1-b)}},
\end{equation*}
where $\vec{\beta}_i = \frac{\vec{k}_i}{k_i^0}$. Further
\begin{align*}
  a &= \beta_1^2 + \beta_2^2 - 2\vec{\beta}_1\cdot\vec{\beta}_2, \\
  b &= \frac{\beta_1^2\beta_2^2 - \left(\vec{\beta}_1\cdot\vec{\beta}_2\right)^2}{a}, \\
  c &= \sqrt{\frac{b}{4a}}, \\
  K(z) = &-\frac{1}{2}\log^2\frac{(z-z_-)(z_+-z)}{(z_++z)(z_-+z)}
          - 2Li_2\left(\frac{2z_-(z_+-z)}{(z_+-z_-)(z_-+z)}\right) \\
         &-2Li_2\left(-\frac{2z_+(z_-+z)}{(z_+-z_-)(z_+-z)}\right),\\
  z_+ &= \frac{1+\sqrt{1-b}}{\sqrt{b}}, \\
  z_- &= \frac{1-\sqrt{1-b}}{\sqrt{b}}, \\
  x_1 &= \frac{\beta_1^2-\vec{\beta}_1\cdot \vec{\beta}_2}{a}, \\
  x_2 &= 1-x_1
  z_1 &= \frac{\sqrt{x_1^2+4c^2}-x_1}{2c}, \\
  z_2 &= \frac{\sqrt{x_2^2+4c^2}+x_2}{2c}.
\end{align*}
<<virtual: procedures>>=
  function I_mm_eps (p1, p2) result (I)
    type(vector4_t), intent(in) :: p1, p2
    real(default) :: I
    type(vector3_t) :: beta1, beta2
    real(default) :: a, b, b2
    real(default) :: zp, zm, z1, z2, x1, x2
    real(default) :: zmb, z1b
    real(default) :: K1, K2

    beta1 = space_part (p1)/energy(p1)
    beta2 = space_part (p2)/energy(p2)
    a = beta1**2 + beta2**2 - 2*beta1*beta2
    b = beta1**2 * beta2**2 - (beta1 * beta2)**2
    if (beta1**1 > beta2**1) call switch_beta (beta1, beta2)
    if (beta1 == vector3_null) then
       b2 = beta2**1
       I = (-0.5 * log ((one - b2) / (one + b2))**2 - two * Li2 (-two * b2 / (one - b2))) &
           * one / sqrt (a - b)
       return
    end if
    x1 = beta1**2 - beta1 * beta2
    x2 = beta2**2 - beta1 * beta2
    zp = sqrt (a) + sqrt (a - b)
    zm = sqrt (a) - sqrt (a - b)
    zmb = one  / zp
    z1 = sqrt (x1**2 + b) - x1
    z2 = sqrt (x2**2 + b) + x2
    z1b = one / (sqrt (x1**2 + b) + x1)
    K1 = - 0.5 * log (((z1b - zmb) * (zp - z1)) / ((zp + z1) * (z1b + zmb)))**2 &
          - two * Li2 ((two * zmb * (zp - z1)) / ((zp - zm) * (zmb + z1b))) &
          - two *Li2 ((-two * zp * (zm + z1)) / ((zp - zm) * (zp - z1)))
    K2 = - 0.5 * log ((( z2 - zm) * (zp - z2)) / ((zp + z2) * (z2 + zm)))**2 &
          - two *Li2 ((two * zm * (zp - z2)) / ((zp - zm) * (zm + z2))) &
          -two *Li2 ((-two * zp * (zm + z2)) / ((zp - zm) * (zp - z2)))
    I = (K2 - K1) * (one - beta1 * beta2) / sqrt (a - b)
  contains
    subroutine switch_beta (beta1, beta2)
      type(vector3_t), intent(inout) :: beta1, beta2
      type(vector3_t) :: beta_tmp
      beta_tmp = beta1
      beta1 = beta2
      beta2 = beta_tmp
    end subroutine switch_beta
  end function I_mm_eps

@ %def I_mm_eps
@ For $k_1^2 \neq 0$ and $k_2^2 \neq 0$ ,computes the expression
\begin{equation*}
  I_0(k_1, k_2) = \frac{1}{\beta} \log\frac{1+\beta}{1-\beta},
  \quad
  \beta = \sqrt{1-\frac{k_1^2k_2^2}{(k_1 \cdot k_2)^2}}
\end{equation*}
<<virtual: procedures>>=
  function I_mm_0 (k1, k2) result (I)
    type(vector4_t), intent(in) :: k1, k2
    real(default) :: I
    real(default) :: beta
    beta = sqrt (one - k1**2 * k2**2 / (k1 * k2)**2)
    I = log ((one + beta) / (one - beta)) / beta
  end function I_mm_0

@ %def I_mm_0
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Real Subtraction}
<<[[real_subtraction.f90]]>>=
<<File header>>

module real_subtraction

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use string_utils
  use constants
  use numeric_utils
  use diagnostics
  use pdg_arrays
  use model_data
  use physics_defs
  use sm_physics
  use sf_lhapdf
  use pdf
  use lorentz
  use flavors
  use fks_regions
  use nlo_data
  use ttv_formfactors, only: THR_POS_B, THR_POS_BBAR
  use ttv_formfactors, only: THR_POS_WP, THR_POS_WM

<<Standard module head>>

<<real subtraction: public>>

<<real subtraction: parameters>>

<<real subtraction: types>>

contains

<<real subtraction: procedures>>

end module real_subtraction
@ %def real_subtraction
@
\subsubsection{Soft subtraction terms}
<<real subtraction: parameters>>=
  integer, parameter, public :: INTEGRATION = 0
  integer, parameter, public :: FIXED_ORDER_EVENTS = 1
  integer, parameter, public :: POWHEG = 2


@ %def real subtraction parameters
@
In the soft limit, the real matrix element behaves as
\begin{equation*}
  \mathcal{R}_{\rm{soft}} = 4\pi\alpha_s \left[\sum_{i \neq j} \mathcal{B}_{ij} \frac{k_i \cdot k_j}{(k_i \cdot k)(k_j \cdot k)} - \mathcal{B} \sum_{i} \frac{k_i^2}{(k_i \cdot k)^2}C_i\right],
\end{equation*}
where $k$ denotes the momentum of the emitted parton. The quantity $\mathcal{B}_{ij}$ is called the color-correlated Born matrix element defined as
\begin{equation*}
  \mathcal{B}_{ij} = \frac{1}{2s} \sum_{\stackrel{colors}{spins}} \mathcal{M}_{\{c_k\}}\left(\mathcal{M}^\dagger_{\{c_k\}}\right)_{\stackrel{c_i \rightarrow c_i'}{c_j \rightarrow c_j'}} T^a_{c_i,c_i'} T^a_{c_j,c_j'}.
\end{equation*}
<<real subtraction: types>>=
  type :: soft_subtraction_t
    real(default), dimension(:), allocatable :: value
    type(region_data_t), pointer :: reg_data => null ()
    integer :: n_in, nlegs_born, nlegs_real
    real(default), dimension(:,:), allocatable :: momentum_matrix
    logical :: use_resonance_mappings = .false.
    type(vector4_t) :: p_soft = vector4_null
    logical :: use_internal_color_correlations = .true.
    logical :: use_internal_spin_correlations = .false.
    type(pdf_container_t), pointer :: pdf_born_plus => null ()
    type(pdf_container_t), pointer :: pdf_born_minus => null ()
    logical :: xi2_expanded = .true.
    integer :: factorization_mode = NO_FACTORIZATION
  contains
  <<real subtraction: soft sub: TBP>>
  end type soft_subtraction_t

@ %def soft_subtraction_t
@
<<real subtraction: soft sub: TBP>>=
  procedure :: init => soft_subtraction_init
<<real subtraction: procedures>>=
  subroutine soft_subtraction_init (sub_soft, reg_data, &
      n_in, nlegs_born, nlegs_real)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(region_data_t), intent(in), target :: reg_data
    integer, intent(in) :: n_in, nlegs_born, nlegs_real
    call msg_debug (D_SUBTRACTION, "soft_subtraction_init")
    sub_soft%reg_data => reg_data
    sub_soft%n_in = n_in
    sub_soft%nlegs_born = nlegs_born
    sub_soft%nlegs_real = nlegs_real
    allocate (sub_soft%value (reg_data%n_regions))
    allocate (sub_soft%momentum_matrix (nlegs_born, nlegs_born))
  end subroutine soft_subtraction_init

@ %def soft_subtraction_init
@ The treatment of the momentum $k$ follows the discussion about the
soft limit of the partition functions (ref????).  The parton momentum is
pulled out, $k = E \hat{k}$. In fact, we will substitute $\hat{k}$ for
$k$ throughout the code, because the energy will factor out of the
equation when the soft $\mathcal{S}$-function is multiplied.  The soft
momentum is a unit vector, because $k^2 = \left(k^0\right)^2 -
\left(k^0\right)^2\hat{\vec{k}}^2 = 0$.

The soft momentum is constructed by first creating a unit vector
parallel to the emitter's Born momentum. This unit vector is then
rotated about the corresponding angles $y$ and $\phi$.
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_fsr => soft_subtraction_create_softvec_fsr 
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_fsr &
     (sub_soft, p_born, y, phi, emitter, xi_ref_momentum)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: y, phi
    integer, intent(in) :: emitter
    type(vector4_t), intent(in) :: xi_ref_momentum
    type(vector3_t) :: dir
    type(vector4_t) :: p_em
    type(lorentz_transformation_t) :: rot
    type(lorentz_transformation_t) :: boost_to_rest_frame
    sub_soft%p_soft%p(0) = one
    if (sub_soft%use_resonance_mappings) then
       boost_to_rest_frame = inverse (boost (xi_ref_momentum, xi_ref_momentum**1))
       p_em = boost_to_rest_frame * p_born(emitter)
    else
       p_em = p_born(emitter)
    end if
    sub_soft%p_soft%p(1:3) = p_em%p(1:3) / space_part_norm (p_em)
    dir = create_orthogonal (space_part (p_em))
    rot = rotation (y, sqrt(one - y**2), dir)
    sub_soft%p_soft = rot * sub_soft%p_soft
    if (.not. vanishes (phi)) then
      dir = space_part (p_em) / space_part_norm (p_em)
      rot = rotation (cos(phi), sin(phi), dir)
      sub_soft%p_soft = rot * sub_soft%p_soft
    end if
    if (sub_soft%use_resonance_mappings) &
       sub_soft%p_soft = inverse (boost_to_rest_frame) * sub_soft%p_soft
  end subroutine soft_subtraction_create_softvec_fsr

@ %def soft_subtraction_create_softvec_fsr
@ For initial-state emissions, the soft vector is just a unit vector
with the same direction as the radiated particle.
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_isr => soft_subtraction_create_softvec_isr
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_isr (sub_soft, y, phi)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: y, phi
    real(default) :: sin_theta
    sin_theta = sqrt(one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = one
       p(1) = sin_theta * sin(phi)
       p(2) = sin_theta * cos(phi)
       p(3) = y
    end associate
  end subroutine soft_subtraction_create_softvec_isr

@ %def soft_subtraction_create_softvec_isr
@ The soft vector for the real mismatch is basically the same as for usual FSR, 
except for the scaling with the total gluon energy. Moreover, the resulting
vector is rotated into the frame where the 3-axis points along the direction
of the emitter. This is necessary because in the collinear limit, the approximation
\begin{equation*}
  k_i = \frac{k_i^0}{\bar{k}_j^0} \bar{k}_j = \frac{\xi\sqrt{s}}{2\bar{k}_j^0}\bar{k}_j
\end{equation*}
is used. The collinear limit is not included in the soft mismatch yet, but we keep
the rotation for future usage here already (the performance loss is negligible).
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_mismatch => &
     soft_subtraction_create_softvec_mismatch
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_mismatch (sub_soft, E, y, phi, p_em)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: E, phi, y
    type(vector4_t), intent(in) :: p_em
    real(default) :: sin_theta
    type(lorentz_transformation_t) :: rot_em_off_3_axis
    sin_theta = sqrt (one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = E
       p(1) = E * sin_theta * sin(phi)
       p(2) = E * sin_theta * cos(phi)
       p(3) = E * y
    end associate
    rot_em_off_3_axis = rotation_to_2nd (3, space_part (p_em))
    sub_soft%p_soft = rot_em_off_3_axis * sub_soft%p_soft
  end subroutine soft_subtraction_create_softvec_mismatch

@ %def soft_subtraction_create_softvec_mismatch
@ Computation of the soft limit of $R_\alpha$. Note that what we are
actually integrating (in the case of final-state radiation) is the
quantity $f(0,y) / \xi$, where
\begin{equation*}
  f(\xi,y) = \frac{J(\xi,y,\phi)}{\xi} \xi^2 R_\alpha.
\end{equation*}
$J/\xi$ is computed by the phase space generator. The additional factor
of $\xi^{-1}$ is supplied in the [[evaluate_region_fsr]]-routine. Thus,
we are left with a factor of $\xi^2$. A look on the expression for the
soft limit of $R_\alpha$ below reveals that we are factoring out the gluon
energy $E_i$ in the denominator. Therefore, we have a factor
$\xi^2 / E_i^2 = q^2 / 4$.\\
Note that the same routine is used also for the computation of the soft
mismatch. There, the gluon energy is not factored out from the soft vector,
so that we are left with the $\xi^2$-factor, which will eventually be
cancelled out again. So, we just multiply with 1. Both cases are
distinguished by the flag [[xi2_expanded]].
<<real subtraction: soft sub: TBP>>=
  procedure :: compute => soft_subtraction_compute
<<real subtraction: procedures>>=
  subroutine soft_subtraction_compute (sub_soft, p_born, &
     born_ij, y, q2, alpha_s, alr, emitter, i_res)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    real(default), intent(in) :: y
    real(default), intent(in) :: q2, alpha_s
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: s_alpha_soft
    real(default) :: kb
    real(default) :: xi2_factor

    if (.not. vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       call msg_fatal ("Soft subtraction: phase space point must be in CMS")
    end if
    if (debug2_active (D_SUBTRACTION)) then
       print *, 'Compute soft subtraction using alpha_s = ', alpha_s
    end if

    s_alpha_soft = sub_soft%reg_data%get_svalue_soft &
        (p_born, sub_soft%p_soft, alr, emitter, i_res)
    sub_soft%value(alr) = 4 * pi * alpha_s * s_alpha_soft
    select case (sub_soft%factorization_mode)
    case (NO_FACTORIZATION)
       kb = sub_soft%evaluate_factorization_default (p_born, born_ij)
    case (FACTORIZATION_THRESHOLD)
       kb = sub_soft%evaluate_factorization_threshold (p_born, born_ij)
    end select
    call msg_debug2 (D_SUBTRACTION, 'KB', kb)
    sub_soft%value(alr) = sub_soft%value(alr) * kb
    if (sub_soft%xi2_expanded) then
       xi2_factor = 4 / q2
    else
       xi2_factor = one
    end if
    if (emitter <= sub_soft%n_in) then
       sub_soft%value(alr) = xi2_factor * (one - y**2) * sub_soft%value(alr)
    else
       sub_soft%value(alr) = xi2_factor * (one - y) * sub_soft%value(alr)
    end if
  end subroutine soft_subtraction_compute

@ %def soft_subtraction_compute
@ We loop over all external legs and do not take care to leave out non-colored
ones because [[born_ij]] is constructed in such a way that it is only
non-zero for colored entries.
<<real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_default => &
     soft_subtraction_evaluate_factorization_default
<<real subtraction: procedures>>=
  function soft_subtraction_evaluate_factorization_default &
     (sub_soft, p, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in), dimension(:,:) :: born_ij
    integer :: i, j
    kb = zero
    call sub_soft%compute_momentum_matrix (p)
    do i = 1, size (p)
       do j = 1, size (p)
          kb = kb + sub_soft%momentum_matrix (i, j) * born_ij (i, j)
       end do
    end do
  end function soft_subtraction_evaluate_factorization_default

@ %def soft_subtraction_evaluate_factorization_default
@ We have to multiply this with $\xi^2(1-y)$. Further, when applying
the soft $\mathcal{S}$-function, the energy of the radiated particle
is factored out. Thus we have $\xi^2/E_{em}^2(1-y) = 4/q_0^2(1-y)$.
Computes the quantity $\mathcal{K}_{ij} = \frac{k_i \cdot
k_j}{(k_i\cdot k)(k_j\cdot k)}$.
<<real subtraction: soft sub: TBP>>=
  procedure :: compute_momentum_matrix => &
       soft_subtraction_compute_momentum_matrix
<<real subtraction: procedures>>=
  subroutine soft_subtraction_compute_momentum_matrix &
       (sub_soft, p_born)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default) :: num, deno1, deno2
    integer :: i, j
    do i = 1, sub_soft%nlegs_born
      do j = 1, sub_soft%nlegs_born
        if (i <= j) then
           num = p_born(i) * p_born(j)
           deno1 = p_born(i) * sub_soft%p_soft
           deno2 = p_born(j) * sub_soft%p_soft
           sub_soft%momentum_matrix(i,j) = num / (deno1 * deno2)
        else
           !!! momentum matrix is symmetric.
          sub_soft%momentum_matrix(i, j) = sub_soft%momentum_matrix(j, i)
        end if
      end do
    end do
  end subroutine soft_subtraction_compute_momentum_matrix

@ %def soft_subtraction_compute_momentum_matrx
@
<<real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_threshold => &
     soft_subtraction_evaluate_factorization_threshold
<<real subtraction: procedures>>=
  function soft_subtraction_evaluate_factorization_threshold &
     (sub_soft, p_born, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    type(vector4_t), dimension(4) :: p
    p(1) = p_born(THR_POS_WP) + p_born(THR_POS_B)
    p(2) = p_born(THR_POS_B)
    p(3) = p_born(THR_POS_WM) + p_born(THR_POS_BBAR)
    p(4) = p_born(THR_POS_BBAR)
    kb = evaluate_leg_pair (1) + evaluate_leg_pair (3)
    if (debug2_active (D_SUBTRACTION))  call show_debug ()

  contains

    function evaluate_leg_pair (i_start) result (kbb)
      real(default) :: kbb
      integer, intent(in) :: i_start
      integer :: i1, i2
      real(default) :: numerator, deno1, deno2
      kbb = zero
      do i1 = i_start, i_start + 1
         do i2 = i_start, i_start + 1
            numerator = p(i1) * p(i2)
            deno1 = p(i1) * sub_soft%p_soft
            deno2 = p(i2) * sub_soft%p_soft
            kbb = kbb +  numerator * born_ij (i1, i2) / deno1 / deno2
         end do
      end do
      if (debug2_active (D_SUBTRACTION)) then
      do i1 = i_start, i_start + 1
         do i2 = i_start, i_start + 1
            call msg_print_color('i1', i1, COL_PEACH)
            call msg_print_color('i2', i2, COL_PEACH)
            call msg_print_color('born_ij(i1,i2)', born_ij(i1,i2), COL_PINK)
            numerator = p(i1) * p(i2)
            deno1 = p(i1) * sub_soft%p_soft
            deno2 = p(i2) * sub_soft%p_soft
            kbb = kbb +  numerator * born_ij (i1, i2) / deno1 / deno2
         end do
      end do
      end if
    end function evaluate_leg_pair

    subroutine show_debug ()
      integer :: i
      call msg_print_color ('soft_subtraction_evaluate_factorization_threshold', COL_GREEN)
      do i = 1, 4
         print *, 'sqrt(p(i)**2) =    ', sqrt(p(i)**2)
      end do
      print *, 'p_soft =    ', sub_soft%p_soft
    end subroutine show_debug

  end function soft_subtraction_evaluate_factorization_threshold

@ %def soft_subtraction_evaluate_factorization_threshold
@
\subsection{Soft mismatch}
<<real subtraction: public>>=
  public :: soft_mismatch_t
<<real subtraction: types>>=
  type :: soft_mismatch_t
    logical :: active = .true.
    type(region_data_t), pointer :: reg_data => null ()
    real(default), dimension(:), pointer :: sqme_born => null ()
    real(default), dimension(:,:,:), pointer :: sqme_born_cc => null ()
    type(real_kinematics_t), pointer :: real_kinematics => null ()
    type(soft_subtraction_t) :: sub_soft
  contains
  <<real subtraction: soft mismatch: TBP>>
  end type soft_mismatch_t

@ %def soft_mismatch_t
@
<<real subtraction: soft mismatch: TBP>>=
  procedure :: init => soft_mismatch_init
<<real subtraction: procedures>>=
  subroutine soft_mismatch_init (soft_mismatch, n_in, nlegs_born, &
     reg_data, sqme_collector, real_kinematics)
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    integer, intent(in) :: n_in, nlegs_born
    type(region_data_t), intent(in), target :: reg_data
    type(sqme_collector_t), intent(in), target :: sqme_collector
    type(real_kinematics_t), intent(in), target :: real_kinematics
    select type (mapping => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       soft_mismatch%active = .false.
    type is (fks_mapping_resonances_t)
       soft_mismatch%reg_data => reg_data
       soft_mismatch%sqme_born => sqme_collector%sqme_subtraction_born_list
       soft_mismatch%sqme_born_cc => sqme_collector%sqme_born_cc
       call soft_mismatch%sub_soft%init (reg_data, n_in, nlegs_born, nlegs_born + 1)
       soft_mismatch%sub_soft%xi2_expanded = .false.
       soft_mismatch%real_kinematics => real_kinematics
    end select
  end subroutine soft_mismatch_init

@ %def soft_mismatch_init
@ Main routine to compute the soft mismatch. Loops over all singular regions.
There, it first creates the soft vector, then the necessary soft real matrix element. 
These inputs are then used to get the numerical value of the soft mismatch.
<<real subtraction: soft mismatch: TBP>>=
  procedure :: evaluate => soft_mismatch_evaluate
<<real subtraction: procedures>>=
  function soft_mismatch_evaluate (soft_mismatch, alpha_s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    real(default), intent(in) :: alpha_s
    integer :: alr, i_uborn, emitter, i_res, i_phs, i_con
    real(default) :: xi, y, q2, s
    real(default) :: E_gluon
    type(vector4_t) :: p_em
    real(default) :: sqme_alr
    sqme_mismatch = zero
    if (.not. soft_mismatch%active) return
    associate (real_kinematics => soft_mismatch%real_kinematics)
       xi = real_kinematics%xi_mismatch
       y = real_kinematics%y_mismatch
       s = real_kinematics%cms_energy2
       E_gluon = sqrt (s) * xi / two

       if (debug_active (D_MISMATCH)) then
          print *, 'Evaluating soft mismatch: '
          print *, 'Phase space: '
          call vector4_write_set (real_kinematics%p_born_cms%get_momenta(1), &
             show_mass = .true.)
          print *, 'xi: ', xi, 'y: ', y, 's: ', s, 'E_gluon: ', E_gluon
       end if

       do alr = 1, soft_mismatch%reg_data%n_regions

          i_phs = real_kinematics%alr_to_i_phs (alr)
          i_con = soft_mismatch%reg_data%alr_to_i_contributor (alr)
          q2 = real_kinematics%xi_ref_momenta(i_con)**2
          emitter = soft_mismatch%reg_data%regions(alr)%emitter
          p_em = real_kinematics%p_born_cms%get_momentum (1, emitter)
          i_res = soft_mismatch%reg_data%regions(alr)%i_res
          i_uborn = soft_mismatch%reg_data%regions(alr)%uborn_index

          call print_debug_alr ()

          call soft_mismatch%sub_soft%create_softvec_mismatch &
             (E_gluon, y, real_kinematics%phi, p_em)
          if (debug_active (D_MISMATCH)) &
             print *, 'Created soft vector: ', soft_mismatch%sub_soft%p_soft%p

          select type (fks_mapping => soft_mismatch%reg_data%fks_mapping)
          type is (fks_mapping_resonances_t)
             call fks_mapping%set_resonance_momentum &
                (real_kinematics%xi_ref_momenta(i_con))
          end select

          call soft_mismatch%sub_soft%compute (real_kinematics%p_born_cms%get_momenta(1), &
             soft_mismatch%sqme_born_cc(:,:,i_uborn), y, q2, alpha_s, alr, emitter, i_res)

          sqme_alr = soft_mismatch%compute (alr, xi, y, p_em, &
             real_kinematics%xi_ref_momenta(i_con), soft_mismatch%sub_soft%p_soft, &
             soft_mismatch%sqme_born(i_uborn), soft_mismatch%sub_soft%value(alr), &
             alpha_s, s)

          call msg_debug (D_MISMATCH, 'sqme_alr: ', sqme_alr)
          sqme_mismatch = sqme_mismatch + sqme_alr

       end do
    end associate
  contains
    subroutine print_debug_alr ()
      if (debug_active (D_MISMATCH)) then
         print *, 'alr: ', alr
         print *, 'i_phs: ', i_phs, 'i_con: ', i_con, 'i_res: ', i_res
         print *, 'emitter: ', emitter, 'i_uborn: ', i_uborn
         print *, 'emitter momentum: ', p_em%p
         print *, 'resonance momentum: ', &
            soft_mismatch%real_kinematics%xi_ref_momenta(i_con)%p
         print *, 'q2: ', q2
      end if
    end subroutine print_debug_alr
  end function soft_mismatch_evaluate

@ %def soft_mismatch_evaluate
@ Computes the soft mismatch in a given $\alpha_r$,
\begin{align*}
  I_{s+,\alpha_r} &= \int d\Phi_B \int_0^\infty d\xi \int_{-1}^1 dy \int_0^{2\pi} d\phi
     \frac{s\xi}{(4\pi)^3} \\
   &\times \left\lbrace\tilde{R}_{\alpha_r}
    \left(e^{-\frac{2k_\gamma \cdot k_{res}}{k_{res}}^2} - e^{-\xi}\right)
  - \frac{32 \pi \alpha_s C_{em}}{s\xi^2} B_{f_b(\alpha_r)} (1-y)^{-1}
    \left[e^{-\frac{2\bar{k}_{em} \cdot k_{res}}{k_{res}^2} \frac{k_\gamma^0}{k_{em}^0}} - e^{-\xi}\right]\right\rbrace.
\end{align*}
<<real subtraction: soft mismatch: TBP>>=
  procedure :: compute => soft_mismatch_compute
<<real subtraction: procedures>>=
  function soft_mismatch_compute (soft_mismatch, alr, xi, y, p_em, p_res, p_soft, &
     sqme_born, sqme_soft, alpha_s, s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(in) :: soft_mismatch
    integer, intent(in) :: alr
    real(default), intent(in) :: xi, y
    type(vector4_t), intent(in) :: p_em, p_res, p_soft
    real(default), intent(in) :: sqme_born, sqme_soft
    real(default), intent(in) :: alpha_s, s
    real(default) :: q2, expo, sm1, sm2, jacobian

    q2 = p_res**2
    expo = - two * p_soft * p_res / q2
    !!! Divide by 1 - y to factor out the corresponding
    !!! factor in the soft matrix element
    sm1 = sqme_soft / (one - y) * ( exp(expo) - exp(- xi) )

    sm2 = zero
    if (soft_mismatch%reg_data%regions(alr)%has_collinear_divergence ()) then
       expo = - two * p_em * p_res / q2 * &
          p_soft%p(0) / p_em%p(0)
       sm2 = 32 * pi * alpha_s * cf / (s * xi**2) * sqme_born * &
          ( exp(expo) - exp(- xi) ) / (one - y)
    end if

    jacobian = soft_mismatch%real_kinematics%jac_mismatch * s * xi / (8 * twopi3)
    sqme_mismatch = (sm1 - sm2) * jacobian

  end function soft_mismatch_compute

@ %def soft_mismatch_compute
@
\subsection{Collinear and soft-collinear subtraction terms}
This data type deals with the calculation of the collinear and
soft-collinear contribution to the cross section.
<<real subtraction: types>>=
  type :: coll_subtraction_t
    real(default), dimension(:), allocatable :: value
    real(default), dimension(:), allocatable :: value_soft
    integer :: n_in, n_alr
    logical :: use_resonance_mappings = .false.
    type(pdf_container_t), pointer :: pdf_born_plus => null ()
    type(pdf_container_t), pointer :: pdf_born_minus => null ()
    type(pdf_container_t), pointer :: pdf_scaled_plus => null ()
    type(pdf_container_t), pointer :: pdf_scaled_minus => null ()
  contains
  <<real subtraction: coll sub: TBP>>
  end type coll_subtraction_t

@ %def coll_subtraction_t
@
<<real subtraction: coll sub: TBP>>=
  procedure :: init => coll_subtraction_init
<<real subtraction: procedures>>=
  subroutine coll_subtraction_init (coll_sub, n_alr, n_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    integer, intent(in) :: n_alr, n_in
    coll_sub%n_in = n_in
    coll_sub%n_alr = n_alr
    allocate (coll_sub%value (n_alr))
    allocate (coll_sub%value_soft (n_alr))
  end subroutine coll_subtraction_init

@ %def coll_subtraction_init
@ To compute the collinear limit of $\mathcal{R}$, we follow the
original FKS-paper. Here, the real amplitude is supposed to factorize
in the collinear limit. considering a splitting $g \rightarrow g(i)g(j)$,
\begin{equation*}
  \mathcal{A}^{(n)}(h_i,h_j,\{h_l\} \stackrel{i \parallel j}{\rightarrow}
  g_s \sum_{d_e} \sum_{h_e} C(d_e, b, c)
  S_{gg}^{h_eh_ih_j}(z)\mathcal{A}_{d_e}^{(n-1)} (h_e, \{h_l\})
\end{equation*}
\textbf{Explain quantities.} Evaluating this expression leads to
\begin{equation*}
  |\mathcal{A}^{(n)}(h_i,h_j,\{h_l\})|^2 \stackrel{i \parallel
  j}{\rightarrow}  |\mathcal{N}^{(n)}(h_i,h_j,\{h_l\}|^2 +
  \mathcal{R}(h_i,h_j,\{h_l\})|^2,
\end{equation*}
where $\mathcal{R}$ contains all contributions with spin-correlated
amplitudes, i.e. terms like
$\mathcal{A}_{d_e}^{(n-1)}(+,\{h_l\})\left(\mathcal{A}_{d_e}^{(n-1)}(-,\{h_l\})\right)^*$.
   Explicitly,
\begin{equation*}
  \sum_{h_i,h_j,\{h_l\}}\sum_{\{d_l\}} |\mathcal{N}^{(n)}(h_i,h_j,\{h_l\})|^2 =
  \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{gg}(z)|\mathcal{A}^{(n-1)}|^2,
\end{equation*}
and
\begin{align*}
  \sum_{h_i,h_j,\{h_l\}}\sum_{\{d_l\}} &\mathcal{R}(h_i,h_j,\{h_l\}) =
    32\pi\alpha_s C_A z(1-z) \\
  &\times \underbrace{Re\left\{\frac{\langle ij \rangle}{[ij]}
    \sum_{\{h_l\}}\sum_{d_e, \{d_l\}}\mathcal{A}^{(n-1)}_{d_e}(+,\{h_l\})
    \left(\mathcal{A}^{(n-1)}_{d_e}(-,\{h_l\})\right)^*\right\}}
   _{-\tilde{\mathcal{M}}^{(n-1)}/(2k_i\cdot k_j)}.
\end{align*}
This yields
\begin{equation}
  \mathcal{M}^{(n)} \stackrel{i \parallel j}{\rightarrow}
  \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{gg}(z)\mathcal{M}^{(n-1)} -
  \frac{16\pi\alpha_s}{k_i \cdot k_j} C_A z(1-z)\tilde{\mathcal{M}}^{(n-1)}.
  \label{coll1}
\end{equation}
The equivalent expression for a $g \rightarrow qq$-splitting is given by
\begin{equation}
  \mathcal{M}^{(n)} \stackrel{i \parallel j}{\rightarrow} \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{qg}(z)\mathcal{M}^{(n-1)} + \frac{16\pi\alpha_s}{k_i \cdot k_j} T_F z(1-z)\tilde{\mathcal{M}}^{(n-1)}.
  \label{coll2}
\end{equation}
The function obtains a flag to indicate whether the limit to be computed
is also soft. Moreover, this consideration explains the structure of the
code. In the soft limit, we find $z \rightarrow 0$ as well as $\xi
\rightarrow 0$. However, the quantity $z/\xi$ is finite, because
\begin{equation*}
  \frac{z}{\xi} = \frac{p_{rad}^0}{\bar{p}_{em}^0} \frac{q^0}{2p_{em}^0} = \frac{q^0}{2\bar{p}^0_{em}}.
\end{equation*}
Thus, all expressions are written in terms of this well-behaved
quantity. Recalling that there is a prefactor of $(\xi^2z)^{-1}$, it is
necessary to expand with $z$ once.
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_fsr => coll_subtraction_compute_fsr
<<real subtraction: procedures>>=
  subroutine coll_subtraction_compute_fsr &
       (coll_sub, sregion, p_res, p_born, sqme_born, sqme_born_sc, &
        xi, alpha_s, alr, soft_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in) :: p_res
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born, sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr
    logical, intent(in), optional :: soft_in
    real(default) :: value
    real(default) :: q0, z, p0
    real(default) :: z_o_xi, onemz
    real(default) :: pggz, pqgz
    integer :: nlegs, emitter
    integer :: flv_em, flv_rad
    logical :: soft

    if (.not. vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true., n_in = coll_sub%n_in)
       call msg_fatal ("Collinear subtraction, FSR: Phase space point &
          &must be in CMS")
    end if

    if (present (soft_in)) then
      soft = soft_in
    else
      soft = .false.
    end if
    nlegs = size (sregion%flst_real%flst)
    emitter = sregion%emitter
    flv_rad = sregion%flst_real%flst(nlegs)
    flv_em = sregion%flst_real%flst(emitter)
    q0 = p_res**1
    p0 = p_res * p_born(emitter) / q0
    !!! Here, z corresponds to 1-z in the formulas of arXiv:1002.2581;
    !!! the integrand is symmetric under this variable change
    z_o_xi = q0 / (two * p0)
    z = xi * z_o_xi; onemz = one - z
    if (is_gluon(flv_em) .and. is_gluon(flv_rad)) then
       !!! Implementation of equation (\ref{coll1}). Note that an
       !!! additional factor $z$, so that in the last step, the whole
       !!! expression is divided by $z/\xi$.
       pggz = two * CA * (z**2 * onemz + z**2 / onemz + onemz)
       value = pggz * sqme_born - 4 * CA * z**2 * onemz * sqme_born_sc
       value = value / z_o_xi
    else if (is_quark(abs(flv_em)) .and. is_quark (abs(flv_rad))) then
       !!! Equation \ref{coll2}
       pqgz = TR * z * (one - two * z * onemz)
       value = pqgz * sqme_born + 4 * TR * z**2 * onemz * sqme_born_sc
       value = value / z_o_xi
    else if (is_quark (abs(flv_em)) .and. is_gluon (flv_rad)) then
       value = sqme_born * CF * (one + onemz**2) / z_o_xi
    else
       value = zero
       call msg_fatal ('Impossible flavor structure in collinear counterterm!')
    end if
    value = value / (p0**2 * onemz * z_o_xi)
    value = value * 4*pi * alpha_s

    if (soft) then
      coll_sub%value_soft (alr) = value
    else
      coll_sub%value (alr) = value
    end if
  end subroutine coll_subtraction_compute_fsr

@ %def coll_subtraction_compute_fsr
@ Here, $\xi = 0$ is already required.
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_soft_limit_fsr => coll_subtraction_compute_soft_limit_fsr
<<real subtraction: procedures>>=
  subroutine coll_subtraction_compute_soft_limit_fsr &
       (coll_sub, sregion, p_res, p_born, sqme_born, &
        sqme_born_sc, xi, alpha_s, alr)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in) :: p_res
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in) :: sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr
    call coll_sub%compute_fsr (sregion, p_res, p_born, sqme_born, &
       sqme_born_sc, xi, alpha_s, alr, .true.)
  end subroutine coll_subtraction_compute_soft_limit_fsr

@ %def coll_subtraction_compute_soft_limit_fsr
@
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_isr => coll_subtraction_compute_isr
<<real subtraction: procedures>>=
  subroutine coll_subtraction_compute_isr &
    (coll_sub, sregion, p_born, sqme_born, sqme_born_sc, &
     xi, alpha_s, alr, isr_mode, soft_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in) :: sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr, isr_mode
    logical, intent(in), optional :: soft_in
    logical :: soft
    real(default) :: z, onemz
    real(default) :: p02
    integer :: flv_em, flv_rad
    integer :: nlegs
    real(default) :: res

    if (vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       call msg_fatal ("Collinear subtraction, ISR: Phase space point &
          &must be in lab frame")
    end if

    if (present (soft_in)) then
      soft = soft_in
    else
      soft = .false.
    end if

    nlegs = size (sregion%flst_real%flst)
    flv_rad = sregion%flst_real%flst(nlegs)
    flv_em = sregion%flst_real%flst(isr_mode)
    !!! No need to pay attention to n_in = 1, because this case always has a
    !!! massive initial-state particle and thus no collinear divergence.
    p02 = p_born(1)%p(0) * p_born(2)%p(0) / two
    z = one - xi; onemz = xi

    if (is_quark(abs(flv_em)) .and. is_gluon(flv_rad)) then
       res = CF * (one + z**2) * sqme_born
    else if (is_gluon(flv_em) .and. is_quark (abs(flv_rad))) then
       res = TR* (z**2 + onemz**2) * onemz * sqme_born
    else
       res = 0
       call msg_bug ("coll_subtraction_compute_isr: result undefined")
    end if
    res = res * z / p02
    res = res * 4 * pi * alpha_s

    if (soft) then
       coll_sub%value_soft(alr) = res
    else
       coll_sub%value(alr) = res
    end if
  end subroutine coll_subtraction_compute_isr

@ %def coll_subtraction_compute_isr
@
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_soft_limit_isr => coll_subtraction_compute_soft_limit_isr
<<real subtraction: procedures>>=
  subroutine coll_subtraction_compute_soft_limit_isr &
     (coll_sub, sregion, p_born, sqme_born, sqme_born_sc, &
      xi, alpha_s, alr, isr_mode)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born, sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr, isr_mode
    call coll_sub%compute_isr (sregion, p_born, sqme_born, sqme_born_sc, &
       zero, alpha_s, alr, isr_mode, .true. )
  end subroutine coll_subtraction_compute_soft_limit_isr

@ %def coll_subtraction_compute_soft_limit_isr
@
\subsection{Real Subtraction}
<<real subtraction: public>>=
  public :: real_subtraction_t
<<real subtraction: types>>=
  type :: real_subtraction_t
    type(region_data_t), pointer :: reg_data => null ()
    type(pdf_data_t) :: pdf_data
    type(real_kinematics_t), pointer :: real_kinematics => null ()
    type(isr_kinematics_t), pointer :: isr_kinematics => null ()
    type(real_scales_t) :: scales
    integer :: current_alr = 0
    integer :: current_i_res = 0
    real(default), dimension(:,:), pointer :: sqme_real_non_sub => null ()
    real(default), dimension(:), pointer :: sqme_born => null ()
    real(default), dimension(:,:,:), pointer :: sqme_born_cc => null ()
    complex(default), dimension(:), pointer :: sqme_born_sc => null ()
    type(soft_subtraction_t) :: sub_soft
    type(coll_subtraction_t) :: sub_coll
    logical, dimension(:), allocatable :: sc_required
    integer :: purpose = INTEGRATION
    logical :: radiation_active = .true.
    logical :: subtraction_active = .true.
    type(pdf_container_t), dimension(2) :: pdf_born, pdf_scaled
    logical, dimension(:), pointer :: passed_real_cuts => null ()
    logical, pointer :: passed_born_cuts => null ()
    logical :: test_limit = .false.
    integer :: fixed_alr = 0
  contains
  <<real subtraction: real subtraction: TBP>>
  end type real_subtraction_t

@ %def real_subtraction_t
@ Initializer
<<real subtraction: real subtraction: TBP>>=
  procedure :: init => real_subtraction_init
<<real subtraction: procedures>>=
  subroutine real_subtraction_init (rsub, reg_data, n_in, &
      nlegs_born, nlegs_real, sqme_collector, &
      nlo_cuts)
    class(real_subtraction_t), intent(inout), target :: rsub
    type(region_data_t), intent(in), target :: reg_data
    integer, intent(in) :: n_in, nlegs_born, nlegs_real
    type(sqme_collector_t), intent(in), target :: sqme_collector
    type(nlo_cuts_t), intent(in), target :: nlo_cuts
    integer :: alr, i_uborn
    call msg_debug (D_SUBTRACTION, "real_subtraction_init")
    call msg_debug (D_SUBTRACTION, "n_in", n_in)
    call msg_debug (D_SUBTRACTION, "nlegs_born", nlegs_born)
    call msg_debug (D_SUBTRACTION, "nlegs_real", nlegs_real)
    call msg_debug (D_SUBTRACTION, "reg_data%n_regions", reg_data%n_regions)

    if (debug2_active (D_SUBTRACTION))  &
         call reg_data%write ()
    rsub%reg_data => reg_data
    rsub%sqme_real_non_sub => sqme_collector%sqme_real_non_sub
    rsub%sqme_born => sqme_collector%sqme_subtraction_born_list
    rsub%sqme_born_cc => sqme_collector%sqme_born_cc
    rsub%sqme_born_sc => sqme_collector%sqme_born_sc
    allocate (rsub%sc_required (reg_data%n_regions))
    do alr = 1, reg_data%n_regions
       i_uborn = reg_data%regions(alr)%uborn_index
       rsub%sc_required(alr) = &
          reg_data%flv_born(i_uborn)%count_particle (GLUON) > 0
    end do

    rsub%passed_born_cuts => nlo_cuts%passed_born
    rsub%passed_real_cuts => nlo_cuts%passed_real

    call rsub%sub_soft%init (reg_data, n_in, nlegs_born, nlegs_real)
    call rsub%sub_coll%init (reg_data%n_regions, n_in)

    if (rsub%reg_data%n_in > 1 .and. any (rsub%reg_data%get_emitter_list () <= 2)) then
       call rsub%init_pdfs ()
       rsub%sub_soft%pdf_born_plus => rsub%pdf_born(I_PLUS)
       rsub%sub_soft%pdf_born_minus => rsub%pdf_born(I_MINUS)
       rsub%sub_coll%pdf_born_plus => rsub%pdf_born(I_PLUS)
       rsub%sub_coll%pdf_born_minus => rsub%pdf_born(I_MINUS)
       rsub%sub_coll%pdf_scaled_plus => rsub%pdf_scaled(I_PLUS)
       rsub%sub_coll%pdf_scaled_minus => rsub%pdf_scaled(I_MINUS)
    end if
  end subroutine real_subtraction_init

@ %def real_subtraction_init
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: init_pdfs => real_subtraction_init_pdfs
<<real subtraction: procedures>>=
  subroutine real_subtraction_init_pdfs (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    type(string_t) :: lhapdf_dir, lhapdf_file
    integer :: lhapdf_member
    call msg_debug (D_SUBTRACTION, "real_subtraction_init_pdfs")
    lhapdf_dir = ""
    lhapdf_file = ""
    lhapdf_member = 0
    if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
          (1, lhapdf_dir, lhapdf_file, lhapdf_member, rsub%pdf_data%pdf)
       associate (pdf_data => rsub%pdf_data)
          pdf_data%type = STRF_LHAPDF6
          pdf_data%xmin = pdf_data%pdf%getxmin ()
          pdf_data%xmax = pdf_data%pdf%getxmax ()
          pdf_data%qmin = sqrt (pdf_data%pdf%getq2min ())
          pdf_data%qmax = sqrt (pdf_data%pdf%getq2max ())
       end associate
    else
       call msg_fatal ("Real subtraction: PDFs must be initialized")
    end if
  end subroutine real_subtraction_init_pdfs

@ %def real_subtraction_init_pdfs
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_resonance_mappings => real_subtraction_set_resonance_mappings
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_resonance_mappings (rsub, use_mappings)
    class(real_subtraction_t), intent(inout) :: rsub
    logical, intent(in) :: use_mappings
    rsub%sub_soft%use_resonance_mappings = use_mappings
    rsub%sub_coll%use_resonance_mappings = use_mappings
  end subroutine real_subtraction_set_resonance_mappings

@ %def real_subtraction_set_resonance_mappings
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_real_kinematics => real_subtraction_set_real_kinematics
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_real_kinematics (rsub, real_kinematics)
    class(real_subtraction_t), intent(inout) :: rsub
    type(real_kinematics_t), intent(in), target :: real_kinematics
    rsub%real_kinematics => real_kinematics
  end subroutine real_subtraction_set_real_kinematics

@ %def real_subtraction_set_real_kinematics
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_isr_kinematics => real_subtraction_set_isr_kinematics
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_isr_kinematics (rsub, fractions)
    class(real_subtraction_t), intent(inout) :: rsub
    type(isr_kinematics_t), intent(in), target :: fractions
    rsub%isr_kinematics => fractions
  end subroutine real_subtraction_set_isr_kinematics

@ %def real_subtraction_set_isr_kinematics
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_alr => real_subtraction_set_alr
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_alr (rsub, alr)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr
    rsub%current_alr = alr
  end subroutine real_subtraction_set_alr

@ %def real_subtraction_set_alr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_i_res => real_subtraction_set_i_res
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_i_res (rsub, alr)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr
    select type (fks_mapping => rsub%reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       rsub%current_i_res = fks_mapping%res_map%alr_to_i_res (alr)
    class default
       rsub%current_i_res = 0
    end select
  end subroutine real_subtraction_set_i_res

@ %def real_subtraction_set_i_res
@\subsection{The real contribution to the cross section}
In each singular region $\alpha$, the real contribution to $\sigma$ is
given by the second summand of eqn. \ref{fks: sub: complete},
\begin{equation}
  \sigma^\alpha_{\text{real}} = \int d\Phi_n \int_0^{2\pi} d\phi
  \int_{-1}^1 dy \int_0^{\xi_{\text{max}}} d\xi
  \left(\frac{1}{\xi}\right)_+ \left(\frac{1}{1-y}\right)_+
  \underbrace{\frac{J(\Phi_n, \xi, y, \phi)}{\xi}
    \left[(1-y)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]}_{g^\alpha(\xi,y)}.
\end{equation}
Writing out the plus-distribution and introducing $\tilde{\xi} =
\xi/\xi_{\text{max}}$ to set the upper integration limit to 1,  this
turns out to be equal to
\begin{equation}
  \begin{split}
    \sigma^\alpha_{\rm{real}} &= \int d\Phi_n \int_0^{2/pi}d\phi
    \int_{-1}^1 \frac{dy}{1-y} \Bigg\{\int_0^1
    d\tilde{\xi}\Bigg[\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},y)}{\tilde{\xi}}
    - \underbrace{\frac{g^\alpha(0,y)}{\tilde{\xi}}}_{\text{soft}} -
    \underbrace{\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},1)}{\tilde{\xi}}}_{\text{coll.}}
    +
    \underbrace{\frac{g^\alpha(0,1)}{\tilde{\xi}}}_{\text{coll.+soft}}\Bigg]
    \\
&+ \left[\log\xi_{\rm{max}}(y)g^\alpha(0,y) - \log\xi_{\rm{max}}(1)g^\alpha(0,1)\right]\Bigg\}.
  \end{split}
\end{equation}
This formula is implemented in \texttt{compute\_sqme\_real\_fin}
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute => real_subtraction_compute
<<real subtraction: procedures>>=
  function real_subtraction_compute (rsub, emitter, i_phs, i_flv, alpha_s) result (sqme)
    real(default) :: sqme
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs, i_flv
    real(default) :: sqme_alr, alpha_s
    integer :: alr, i_con

    sqme = zero
    do alr = 1, size (rsub%reg_data%regions)
       if (rsub%fixed_alr > 0 .and. rsub%fixed_alr /= alr) cycle
       sqme_alr = zero
       if (emitter == rsub%reg_data%regions(alr)%emitter .and. &
          i_phs == rsub%real_kinematics%alr_to_i_phs (alr) .and. &
          i_flv == rsub%reg_data%regions(alr)%real_index) then
          call rsub%set_alr (alr)
          call rsub%set_i_res (alr)
          sqme_alr = rsub%evaluate_emitter_region (emitter, i_phs, alpha_s)
          i_con = rsub%get_i_contributor (alr)
          if (rsub%purpose == INTEGRATION .or. rsub%purpose == FIXED_ORDER_EVENTS) &
             sqme_alr = sqme_alr * rsub%get_phs_factor (i_con)
       end if
       sqme = sqme + sqme_alr
    end do
  end function real_subtraction_compute

@ %def real_subtraction_compute
@ The emitter is fixed. We now have to decide whether we evaluate in ISR or FSR
region, and also if resonances are used.
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_emitter_region => real_subtraction_evaluate_emitter_region
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_emitter_region (rsub, emitter, i_phs, alpha_s) &
     result (sqme)
    real(default) :: sqme
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    integer :: i_con
    if (emitter <= rsub%isr_kinematics%n_in) then
       sqme = rsub%evaluate_region_isr (emitter, i_phs, alpha_s)
    else
       select type (fks_mapping => rsub%reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          i_con = rsub%reg_data%alr_to_i_contributor (rsub%current_alr)
          call fks_mapping%set_resonance_momenta &
             (rsub%real_kinematics%xi_ref_momenta )
          sqme = rsub%evaluate_region_fsr (emitter, i_phs, alpha_s)
       class default
          sqme = rsub%evaluate_region_fsr (emitter, i_phs, alpha_s)
       end select
    end if
  end function real_subtraction_evaluate_emitter_region

@ %def real_subtraction_evaluate_emitter_region
@ This subroutine computes the finite part of the real matrix element in
an individual singular region.
First, the radiation variables are fetched and $\mathcal{R}$ is
multiplied by the appropriate $S_\alpha$-factors,
region multiplicities and double-FSR factors.
Then, it computes the soft, collinear, soft-collinear and remnant matrix
elements and supplies the corresponding factor $1/\xi/(1-y)$ as well as
the corresponding jacobians.
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_fsr => real_subtraction_evaluate_region_fsr
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_region_fsr (rsub, emitter, i_phs, &
     alpha_s) result (sqme)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default) :: sqme
    integer :: i_real
    real(default) :: sqme0, sqme_soft, sqme_coll, sqme_cs, sqme_remn
    real(default) :: s_alpha
    real(default) :: xi, xi_max, xi_tilde, y, onemy
    real(default) :: s
    sqme0 = zero; sqme_soft = zero; sqme_coll = zero
    sqme_cs = zero; sqme_remn = zero
    xi_tilde = rsub%real_kinematics%xi_tilde
    xi_max = rsub%real_kinematics%xi_max(i_phs)
    xi = xi_tilde * xi_max
    y = rsub%real_kinematics%y(i_phs)
    onemy = one - y
    associate (region => rsub%reg_data%regions(rsub%current_alr))
      if (rsub%radiation_active .and. rsub%passed_real_cuts (i_phs)) then
         i_real = region%real_index
         sqme0 = rsub%sqme_real_non_sub (i_real, i_phs)
         s_alpha = rsub%reg_data%get_svalue (rsub%real_kinematics%p_real_cms%get_momenta(i_phs), &
             rsub%current_alr, emitter, rsub%current_i_res)
         sqme0 = sqme0 * s_alpha
         sqme0 = sqme0 * region%mult
         sqme0 = sqme0 * region%double_fsr_factor (rsub%real_kinematics%p_real_cms%get_momenta(i_phs))
         select case (rsub%purpose)
         case (INTEGRATION, FIXED_ORDER_EVENTS)
            sqme0 = sqme0 * xi**2 / xi_tilde * rsub%real_kinematics%jac(i_phs)%jac(1)
         case (POWHEG)
            s = rsub%real_kinematics%cms_energy2
            sqme0 = sqme0*rsub%real_kinematics%jac(i_phs)%jac(1) * s / (8 * twopi3) * xi
         end select
      end if
      if (rsub%subtraction_active .and. rsub%passed_born_cuts) then
         call rsub%evaluate_subtraction_terms_fsr (emitter, i_phs, alpha_s, &
            sqme_soft, sqme_coll, sqme_cs)
         sqme_soft = sqme_soft / onemy / xi_tilde
         sqme_coll = sqme_coll / onemy / xi_tilde
         sqme_cs = sqme_cs / onemy / xi_tilde
         associate (jac => rsub%real_kinematics%jac)
            sqme_soft = sqme_soft * jac(i_phs)%jac(2)
            sqme_coll = sqme_coll * jac(i_phs)%jac(3)
            sqme_cs = sqme_cs * jac(i_phs)%jac(2)
         end associate
         sqme_remn = (sqme_soft - sqme_cs) * log(xi_max) * xi_tilde
         select case (rsub%purpose)
         case (INTEGRATION)
            sqme = sqme0 - sqme_soft - sqme_coll + sqme_cs + sqme_remn
         case (FIXED_ORDER_EVENTS)
            sqme = - sqme_soft - sqme_coll + sqme_cs + sqme_remn
         case default
            sqme = 0
            call msg_bug ("real_subtraction_evaluate_region_fsr: " // &
                 "Undefined rsub%purpose")
         end select
      else
         sqme = sqme0
      end if
      sqme = sqme * rsub%real_kinematics%jac_rand(i_phs)
    end associate

    call debug_output ()

  contains

    subroutine debug_output ()
       logical :: print_all, soft, collinear
       type(vector4_t) :: p_gluon
       integer, save :: n_soft = 0, passed_soft = 0, n_coll = 0, passed_coll = 0
       logical :: write_histo = .true.
       if (debug_active (D_SUBTRACTION)) then
          print_all = debug2_active (D_SUBTRACTION)
          if (print_all) then
             call msg_debug2 (D_SUBTRACTION, "real_subtraction_evaluate_region_fsr")
             call write_computation_status ()
          else
             associate (p_real => rsub%real_kinematics%p_real_cms)
                p_gluon = p_real%get_momentum (i_phs, p_real%get_n_momenta (i_phs))
                soft = p_gluon%p(0) < 0.1_default
             end associate
             collinear = abs (y - 1) < 0.01_default
             if (soft) then
                if (write_histo)  call write_point_to_file (p_gluon%p(0), sqme0, sqme_soft)
                n_soft = n_soft + 1
                if (sqme_soft < zero)  call msg_warning ("Soft < 0")
                if (abs (sqme0 - sqme_soft) > sqme0 .and. sqme_soft > tiny_10 .and. sqme0 > tiny_10) then
                   call msg_warning ("Soft MEs do not match in this soft region")
                   call write_computation_status (passed_soft, n_soft, "soft")
                else
                   passed_soft = passed_soft + 1
                end if
             end if
             if (collinear) then
                n_coll = n_coll + 1
                if (abs (sqme0 - sqme_coll) > sqme0 .and. sqme_coll > tiny_10 .and. sqme0 > tiny_10) then
                   call msg_warning ("Collinear MEs do not match in this collinear region")
                   call write_computation_status (passed_coll, n_coll, "collinear")
                else
                   passed_coll = passed_coll + 1
                end if
             end if
          end if
       end if
    end subroutine debug_output

    subroutine write_computation_status (passed, total, region_type)
       integer, intent(in), optional :: passed, total
       character(*), intent(in), optional :: region_type
       integer :: i_uborn
       integer :: u
       u = given_output_unit (); if (u < 0) return
       i_uborn = rsub%reg_data%regions(rsub%current_alr)%uborn_index
       write (u,'(A,I2)') 'rsub%purpose: ', rsub%purpose
       write (u,'(A,I3)') 'alr: ', rsub%current_alr
       write (u,'(A,I3)') 'emitter: ', emitter
       write (u,'(A,I3)') 'i_phs: ', i_phs 
       write (u,'(A,F6.4)') 'xi_max: ', xi_max
       write (u,'(A,F6.4,2X,A,F6.4)') 'xi: ', xi, 'y: ', y
       write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_uborn)
       write (u,'(A,ES16.9)')  'sqme_real: ', sqme0
       write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
       write (u,'(A,ES16.9)')  'sqme_coll: ', sqme_coll
       write (u,'(A,ES16.9)')  'sqme_coll-soft: ', sqme_cs
       write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
       write (u,'(A,ES16.9)')  'sqme_tot: ', sqme
       if (present (passed) .and. present (total) .and. &
            present (region_type)) &
          write (u,'(A)') char (str (passed) // " of " // str (total) // &
               " " // region_type // " points passed in total")
    end subroutine write_computation_status

    subroutine write_point_to_file (E_gluon, sqme0, sqme_soft)
      real(default), intent(in) :: E_gluon, sqme0, sqme_soft
      integer, save :: funit = 0
      type(string_t) :: filename
      filename = var_str ("soft.log")
      if (funit == 0) then
         funit = free_unit ()
         open (funit, file=char(filename), action = "write", status="replace")
         write (funit, "(A,5X,A,5X,A)") "# E_gluon", "Real", "Soft Approx"
      end if
      write (funit,'(3(ES16.9,1X))') E_gluon, sqme0, sqme_soft
    end subroutine write_point_to_file

  end function real_subtraction_evaluate_region_fsr

@ %def real_subtraction_evalute_region_fsr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_isr => real_subtraction_evaluate_region_isr
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_region_isr (rsub, emitter, i_phs, alpha_s) &
     result (sqme)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default) :: sqme
    real(default) :: xi_max, xi_max_plus, xi_max_minus
    real(default) :: xi_tilde, xi, xi_plus, xi_minus
    real(default) :: y, phi
    integer :: i_real
    real(default) :: sqme0, sqme_soft, sqme_coll_plus, sqme_coll_minus
    real(default) :: sqme_cs_plus, sqme_cs_minus
    real(default) :: sqme_remn
    real(default) :: s_alpha
    real(default) :: onemy, onepy
    logical :: proc_scatter

    proc_scatter = rsub%isr_kinematics%n_in == 2

    xi_tilde = rsub%real_kinematics%xi_tilde
    xi_max = rsub%real_kinematics%xi_max(i_phs)
    xi = xi_tilde * xi_max
    if (proc_scatter) then
       xi_max_plus = one - rsub%isr_kinematics%x(I_PLUS)
       xi_max_minus = one - rsub%isr_kinematics%x(I_MINUS)
       xi_plus = xi_max_plus * xi_tilde
       xi_minus = xi_max_minus * xi_tilde
    else
       xi_max_plus = xi_max
       xi_max_minus = xi_max
       xi_plus =  xi
       xi_minus = xi
    end if
    y = rsub%real_kinematics%y(i_phs)
    onemy = one - y; onepy = one + y
    phi = rsub%real_kinematics%phi

    if (proc_scatter) call rsub%compute_pdfs ()

    associate (region => rsub%reg_data%regions(rsub%current_alr))
      i_real = region%real_index
      sqme0 = rsub%sqme_real_non_sub (i_real, i_phs)
      s_alpha = rsub%reg_data%get_svalue (rsub%real_kinematics%p_real_cms%get_momenta(i_phs), &
          rsub%current_alr, emitter, rsub%current_i_res)
      sqme0 = sqme0 * s_alpha
      sqme0 = sqme0 * region%mult
      if (proc_scatter) then
         call rsub%reweight_pdfs (sqme0, i_real, I_PLUS)
         call rsub%reweight_pdfs (sqme0, i_real, I_MINUS)
      end if

      select case (rsub%purpose)
      case (INTEGRATION, FIXED_ORDER_EVENTS)
         sqme0 = sqme0 * xi**2 / xi_tilde * rsub%real_kinematics%jac(emitter)%jac(1)
      case (POWHEG)
         call msg_fatal ("POWHEG with initial-state radiation not implemented yet")
      end select

      if (rsub%subtraction_active) then
         call rsub%evaluate_subtraction_terms_isr (emitter, i_phs, alpha_s, &
            sqme_soft, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
         if (proc_scatter) then
            call rsub%reweight_pdfs (sqme_coll_plus, i_real, I_PLUS)
            call rsub%reweight_pdfs (sqme_coll_minus, i_real, I_MINUS)
         end if
         associate (jac => rsub%real_kinematics%jac(i_phs))
           sqme_soft = sqme_soft / (one - y**2) / xi_tilde * jac%jac(2)
           sqme_coll_plus = sqme_coll_plus / onemy / xi_tilde / two * jac%jac(3)
           sqme_coll_minus = sqme_coll_minus / onepy / xi_tilde / two * jac%jac(4)
           sqme_cs_plus = sqme_cs_plus / onemy / xi_tilde / two * jac%jac(2)
           sqme_cs_minus = sqme_cs_minus / onepy / xi_tilde / two * jac%jac(2)
         end associate
         sqme_remn = log(xi_max) * xi_tilde * sqme_soft
         sqme_remn = sqme_remn - log (xi_max_plus) * xi_tilde * sqme_cs_plus &
                               - log (xi_max_minus) * xi_tilde * sqme_cs_minus

         sqme = sqme0 - sqme_soft - sqme_coll_plus - sqme_coll_minus &
              + sqme_cs_plus + sqme_cs_minus + sqme_remn
      else
         sqme = sqme0
      end if
    end associate

    sqme = sqme * rsub%real_kinematics%jac_rand (i_phs)

    call debug_output ()

  contains

    subroutine debug_output ()
       logical :: soft, collinear
       type(vector4_t) :: p_gluon
       if (debug_active (D_SUBTRACTION)) then
          call msg_debug2 (D_SUBTRACTION, "real_subtraction_evaluate_region_fsr")
          if (debug2_active (D_SUBTRACTION)) then
             call write_computation_status ()
          else
             associate (p_real => rsub%real_kinematics%p_real_cms)
                p_gluon = p_real%get_momentum (i_phs, p_real%get_n_momenta (i_phs))
                soft = p_gluon%p(0) < 2.0_default
             end associate
             collinear = abs (y - 1) < 0.01_default
             if (soft) then
                if (abs (sqme0 - sqme_soft) > sqme0 .and. sqme_soft > tiny_10) then
                   call msg_warning ("Soft MEs do not match in soft region")
                   call write_computation_status ()
                end if
             end if
             ! TODO: (bcn 2016-01-13) check coll_plus and coll_minus
             !if (collinear) then
                !if (abs (sqme0 - sqme_coll) > sqme0 .and. sqme_coll > tiny_10) then
                   !call msg_warning ("Collinear MEs do not match in collinear region")
                   !call write_computation_status ()
                !end if
             !end if
          end if
       end if
    end subroutine debug_output

    subroutine write_computation_status (unit)
       integer, intent(in), optional :: unit
       integer :: i_uborn
       integer :: u
       u = given_output_unit (unit); if (u < 0) return
       i_uborn = rsub%reg_data%regions(rsub%current_alr)%uborn_index
       write (u,'(A,I2)') 'alr: ', rsub%current_alr
       write (u,'(A,I2)') 'emitter: ', emitter
       write (u,'(A,F4.2)') 'xi_max: ', xi_max
       print *, 'xi: ', xi, 'y: ', y
       print *, 'phi: ', phi
       print *, 'xb1: ', rsub%isr_kinematics%x(1), 'xb2: ', rsub%isr_kinematics%x(2)
       write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_uborn)
       write (u,'(A,ES16.9)')  'sqme_real: ', sqme0
       write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
       write (u,'(A,ES16.9)')  'sqme_coll_plus: ', sqme_coll_plus
       write (u,'(A,ES16.9)')  'sqme_coll_minus: ', sqme_coll_minus
       write (u,'(A,ES16.9)')  'sqme_cs_plus: ', sqme_cs_plus
       write (u,'(A,ES16.9)')  'sqme_cs_minus: ', sqme_cs_minus
       write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
    end subroutine write_computation_status

  end function real_subtraction_evaluate_region_isr

@ %def real_subtraction_evaluate_region_isr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_fsr => &
                       real_subtraction_evaluate_subtraction_terms_fsr
<<real subtraction: procedures>>=
  subroutine real_subtraction_evaluate_subtraction_terms_fsr (rsub, &
                  emitter, i_phs, alpha_s, &
                  sqme_soft, sqme_coll, sqme_cs)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default), intent(out) :: sqme_soft, sqme_coll, sqme_cs
    integer :: alr
    alr = rsub%current_alr
    call rsub%compute_sub_soft (emitter, i_phs, alpha_s)
    call rsub%compute_sub_coll (emitter, i_phs, alpha_s)
    call rsub%compute_sub_coll_soft (emitter, alpha_s)
    sqme_soft = rsub%sub_soft%value(alr)
    sqme_coll = rsub%sub_coll%value(alr)
    sqme_cs = rsub%sub_coll%value_soft(alr)
  end subroutine real_subtraction_evaluate_subtraction_terms_fsr

@ %def real_subtraction_evaluate_subtraction_terms_fsr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_isr => &
                       real_subtraction_evaluate_subtraction_terms_isr
<<real subtraction: procedures>>=
  subroutine real_subtraction_evaluate_subtraction_terms_isr (rsub, &
    emitter, i_phs, alpha_s, sqme_soft, sqme_coll_plus, sqme_coll_minus, &
    sqme_cs_plus, sqme_cs_minus)

    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default), intent(out) :: sqme_soft
    real(default), intent(out) :: sqme_coll_plus, sqme_coll_minus
    real(default), intent(out) :: sqme_cs_plus, sqme_cs_minus
    integer :: alr
    alr = rsub%current_alr
    call rsub%compute_sub_soft (emitter, i_phs, alpha_s)
    sqme_soft = rsub%sub_soft%value(alr)
    if (emitter /= 2) then
       call rsub%compute_sub_coll (1, i_phs, alpha_s)
       call rsub%compute_sub_coll_soft (1, alpha_s)
       sqme_coll_plus = rsub%sub_coll%value(alr)
       sqme_cs_plus = rsub%sub_coll%value_soft(alr)
    else
       sqme_coll_plus = zero
       sqme_cs_plus = zero
    end if
    if (emitter /= 1) then
       call rsub%compute_sub_coll (2, i_phs, alpha_s)
       call rsub%compute_sub_coll_soft (2, alpha_s)
       sqme_coll_minus = rsub%sub_coll%value(alr)
       sqme_cs_minus = rsub%sub_coll%value_soft(alr)
    else
       sqme_coll_minus = zero
       sqme_cs_minus = zero
    end if
  end subroutine real_subtraction_evaluate_subtraction_terms_isr

@ %def real_subtraction_evaluate_subtraction_terms_isr
@ This is basically the part of the real jacobian corresponding to 
\begin{equation*}
  \frac{q^2}{8 (2\pi)^3}.
\end{equation*}
We interpret it as the additional phase space factor of the real component, 
to be more consistent with the evaluation of the Born phase space.
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_phs_factor => real_subtraction_get_phs_factor
<<real subtraction: procedures>>=
  function real_subtraction_get_phs_factor (rsub, i_con) result (factor)
    real(default) :: factor
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: i_con
    real(default) :: s
    s = rsub%real_kinematics%xi_ref_momenta (i_con)**2
    factor = s / (8 * twopi3)
  end function real_subtraction_get_phs_factor

@ %def real_subtraction_get_phs_factor
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_i_contributor => real_subtraction_get_i_contributor
<<real subtraction: procedures>>=
  function real_subtraction_get_i_contributor (rsub, alr) result (i_con)
    integer :: i_con
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr
    if (allocated (rsub%reg_data%alr_to_i_contributor)) then
       i_con = rsub%reg_data%alr_to_i_contributor (alr)
    else
       i_con = 1
    end if
  end function real_subtraction_get_i_contributor

@ %def real_subtraction_get_i_contributor
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_soft => real_subtraction_compute_sub_soft
<<real subtraction: procedures>>=
  subroutine real_subtraction_compute_sub_soft &
     (rsub, emitter, i_phs, alpha_s)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    integer :: alr, i_con, i_uborn
    real(default) :: q2

    alr = rsub%current_alr
       associate (real_kinematics => rsub%real_kinematics)
       if (rsub%reg_data%regions(alr)%has_soft_divergence ()) then
          if (rsub%sub_soft%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          q2 = real_kinematics%xi_ref_momenta (i_con)**2
          if (emitter > rsub%sub_soft%n_in) then
             call rsub%sub_soft%create_softvec_fsr &
                (real_kinematics%p_born_cms%get_momenta(1), &
                real_kinematics%y_soft (i_phs), &
                real_kinematics%phi, emitter, &
                real_kinematics%xi_ref_momenta(i_con))
          else
             call rsub%sub_soft%create_softvec_isr &
                (real_kinematics%y_soft(i_phs), real_kinematics%phi)
          end if
          i_uborn = rsub%reg_data%regions(alr)%uborn_index
          call rsub%sub_soft%compute (real_kinematics%p_born_cms%get_momenta(1), &
             rsub%sqme_born_cc(:,:,i_uborn), real_kinematics%y(i_phs), &
             q2, alpha_s, alr, emitter, rsub%current_i_res)
       else
          rsub%sub_soft%value(alr) = zero
       end if
    end associate
  end subroutine real_subtraction_compute_sub_soft

@ %def real_subtraction_compute_sub_soft
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_sc_matrix_element => real_subtraction_get_sc_matrix_element
<<real subtraction: procedures>>=
  function real_subtraction_get_sc_matrix_element (rsub, alr, em, uborn_index) result (sqme_sc)
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr, em, uborn_index
    real(default) :: sqme_sc
    complex(default) :: prod1, prod2

    if (rsub%sc_required(alr)) then
       associate (p => rsub%real_kinematics%p_real_cms%phs_point(1)%p)
          call spinor_product (p(em), p(rsub%reg_data%nlegs_real), prod1, prod2)
       end associate
       sqme_sc = real (prod1 / prod2 * rsub%sqme_born_sc(uborn_index))
    else
       sqme_sc = zero
    end if
  end function real_subtraction_get_sc_matrix_element

@ %def real_subtraction_get_sc_matrix_element
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll => real_subtraction_compute_sub_coll
<<real subtraction: procedures>>=
  subroutine real_subtraction_compute_sub_coll (rsub, em, i_phs, alpha_s)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: em, i_phs
    real(default), intent(in) :: alpha_s
    real(default) :: xi, sqme_sc
    integer :: alr, i_con
    alr = rsub%current_alr
    associate (sregion => rsub%reg_data%regions(alr))
       if (sregion%has_collinear_divergence ()) then
          xi = rsub%real_kinematics%xi_tilde * rsub%real_kinematics%xi_max (i_phs)
          if (rsub%sub_coll%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          sqme_sc = rsub%get_sc_matrix_element (alr, em, sregion%uborn_index)
          if (em <= rsub%sub_coll%n_in) then
             call rsub%sub_coll%compute_isr (sregion, &
                  rsub%real_kinematics%p_born_lab%phs_point(1)%p, &
                  rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr, em)
          else
             call rsub%sub_coll%compute_fsr (sregion, &
                  rsub%real_kinematics%xi_ref_momenta (i_con), &
                  rsub%real_kinematics%p_born_cms%get_momenta(1), &
                  rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr)
          end if
       else
          rsub%sub_coll%value(alr) = zero
       end if
    end associate
  end subroutine real_subtraction_compute_sub_coll

@ %def real_subtraction_compute_sub_coll
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll_soft => real_subtraction_compute_sub_coll_soft
<<real subtraction: procedures>>=
  subroutine real_subtraction_compute_sub_coll_soft (rsub, em, alpha_s)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: em
    real(default), intent(in) :: alpha_s
    real(default) :: sqme_sc
    real(default) :: xi
    integer :: alr, i_con
    alr = rsub%current_alr
    xi = zero
    associate (sregion => rsub%reg_data%regions(alr))
       if (sregion%has_collinear_divergence ()) then
          if (rsub%sub_coll%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          sqme_sc = rsub%get_sc_matrix_element (alr, em, sregion%uborn_index)
          if (em <= rsub%sub_coll%n_in) then
             call rsub%sub_coll%compute_soft_limit_isr (sregion, &
                  rsub%real_kinematics%p_born_lab%phs_point(1)%p, &
                  rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr, em)
          else
             call rsub%sub_coll%compute_soft_limit_fsr &
                  (sregion, rsub%real_kinematics%xi_ref_momenta(i_con), &
                  rsub%real_kinematics%p_born_cms%phs_point(1)%p, &
                  rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr)
          end if
       else
          rsub%sub_coll%value_soft(alr) = zero
       end if
    end associate
  end subroutine real_subtraction_compute_sub_coll_soft

@ %def real_subtraction_compute_sub_coll_soft
@ Gets the pdf value from the [[pdf_data]] object. Note that LHAPDF
delivers $x \cdot f(x)$ as output, so that $x$ has to be factored out.
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_pdfs => real_subtraction_compute_pdfs
<<real subtraction: procedures>>=
  subroutine real_subtraction_compute_pdfs (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    integer :: i
    real(default) :: z, x, Q
    real(default) :: x_scaled
    real(double), dimension(-6:6) :: f_dble = 0._double
    Q = rsub%isr_kinematics%fac_scale
    do i = 1, 2
       x = rsub%isr_kinematics%x(i)
       z = rsub%isr_kinematics%z(i)
       x_scaled = x / z
       call rsub%pdf_data%evolve (dble(x), dble(Q), f_dble)
       rsub%pdf_born(i)%f = f_dble / dble(x)
       call rsub%pdf_data%evolve (dble(x_scaled), dble(Q), f_dble)
       rsub%pdf_scaled(i)%f = f_dble / dble(x_scaled)
    end do
  end subroutine real_subtraction_compute_pdfs

@ %def real_subtraction_compute_pdfs
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: reweight_pdfs => real_subtraction_reweight_pdfs
<<real subtraction: procedures>>=
  subroutine real_subtraction_reweight_pdfs (rsub, sqme, i_real, i_part)
    class(real_subtraction_t), intent(inout) :: rsub
    real(default), intent(inout) :: sqme
    integer, intent(in) :: i_part, i_real
    integer :: flv
    real(default) :: pdfs, pdfb
    flv = rsub%reg_data%flv_real(i_real)%flst(i_part)
    if (flv == GLUON) flv = 0
    pdfb = rsub%pdf_born(i_part)%f(flv)
    pdfs = rsub%pdf_scaled(i_part)%f(flv)
    sqme = sqme*pdfs/pdfb
  end subroutine real_subtraction_reweight_pdfs

@ %def real_subtraction_reweight_pdfs
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combining the FKS Pieces}
<<[[nlo_data.f90]]>>=
<<File header>>

module nlo_data

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use constants, only: zero, one, two, twopi
  use io_units
  use lorentz

<<Standard module head>>

<<nlo data: public>>

<<nlo data: parameters>>

<<nlo data: types>>

<<nlo data: interfaces>>

contains

<<nlo data: procedures>>

end module nlo_data

@ %def nlo_data
@
<<nlo data: parameters>>=
  integer, parameter, public :: I_PLUS = 1
  integer, parameter, public :: I_MINUS = 2

@ %def parameters
@
<<nlo data: parameters>>=
  integer, parameter, public :: FKS_DEFAULT = 1
  integer, parameter, public :: FKS_RESONANCES = 2

  integer, parameter, public :: NO_FACTORIZATION = 0
  integer, parameter, public :: FACTORIZATION_THRESHOLD = 1

@ %def parameters
@
<<nlo data: public>>=
  public :: fks_template_t
<<nlo data: types>>=
  type :: fks_template_t
    type(string_t) :: id
    logical :: subtraction_disabled = .false.
    integer :: mapping_type = FKS_DEFAULT
    logical :: count_kinematics = .false.
    real(default) :: fks_dij_exp1
    real(default) :: fks_dij_exp2
  contains
  <<nlo data: fks template: TBP>>
  end type fks_template_t

@ %def fks_template_t
@
<<nlo data: fks template: TBP>>=
  procedure :: write => fks_template_write
<<nlo data: procedures>>=
  subroutine fks_template_write (template, unit)
    class(fks_template_t), intent(in) :: template
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,'(1x,A)') 'FKS Template: '
    write (u,'(1x,A,I0)') 'Mapping Type: ', template%mapping_type
    write (u,'(1x,A,ES4.3,ES4.3)') 'd_ij exponentials: ', &
       template%fks_dij_exp1, template%fks_dij_exp2
  end subroutine fks_template_write

@ %def fks_template_write
@
<<nlo data: fks template: TBP>>=
  procedure :: set_dij_exp => fks_template_set_dij_exp
<<nlo data: procedures>>=
  subroutine fks_template_set_dij_exp (template, exp1, exp2)
    class(fks_template_t), intent(inout) :: template
    real(default), intent(in) :: exp1, exp2
    template%fks_dij_exp1 = exp1
    template%fks_dij_exp2 = exp2
  end subroutine fks_template_set_dij_exp

@ %def fks_template_set_dij_exp
@
<<nlo data: fks template: TBP>>=
  procedure :: set_mapping_type => fks_template_set_mapping_type
<<nlo data: procedures>>=
  subroutine fks_template_set_mapping_type (template, val)
    class(fks_template_t), intent(inout) :: template
    integer, intent(in) :: val
    template%mapping_type = val
  end subroutine fks_template_set_mapping_type

@ %def fks_template_set_mapping_type
@
<<nlo data: fks template: TBP>>=
  procedure :: set_counter => fks_template_set_counter
<<nlo data: procedures>>=
  subroutine fks_template_set_counter (template)
    class(fks_template_t), intent(inout) :: template
    template%count_kinematics = .true.
  end subroutine fks_template_set_counter

@ %def fks_template_set_counter
@
<<nlo data: fks template: TBP>>=
  procedure :: disable_subtraction => fks_template_disable_subtraction
<<nlo data: procedures>>=
  subroutine fks_template_disable_subtraction (template)
    class(fks_template_t), intent(inout) :: template
    template%subtraction_disabled = .true.
  end subroutine fks_template_disable_subtraction

@ %def fks_template_disable_subtraction
@ A resonance phase space is uniquely specified via the resonance contributors and the
corresponding emitters. The [[phs_identifier]] type also checks whether 
the given contributor-emitter configuration has already been evaluated to 
avoid duplicate computations.
<<nlo data: public>>=
  public :: phs_identifier_t
<<nlo data: types>>=
  type :: phs_identifier_t
     integer, dimension(:), allocatable :: contributors
     integer :: emitter = -1
     logical :: evaluated = .false.
  contains
  <<nlo data: phs identifier: TBP>>
  end type phs_identifier_t

@ %def phs_identifier_t
@
<<nlo data: phs identifier: TBP>>=
  generic :: init => init_from_emitter, init_from_emitter_and_contributors
  procedure :: init_from_emitter => phs_identifier_init_from_emitter
  procedure :: init_from_emitter_and_contributors &
     => phs_identifier_init_from_emitter_and_contributors
<<nlo data: procedures>>=
  subroutine phs_identifier_init_from_emitter (phs_id, emitter)
    class(phs_identifier_t), intent(out) :: phs_id
    integer, intent(in) :: emitter
    phs_id%emitter = emitter
  end subroutine phs_identifier_init_from_emitter

  subroutine phs_identifier_init_from_emitter_and_contributors &
     (phs_id, emitter, contributors)
     class(phs_identifier_t), intent(out) :: phs_id
     integer, intent(in) :: emitter
     integer, intent(in), dimension(:) :: contributors
     allocate (phs_id%contributors (size (contributors)))
     phs_id%contributors = contributors
     phs_id%emitter = emitter
  end subroutine phs_identifier_init_from_emitter_and_contributors
@ %def phs_identifier_init_from_emitter
@ %def phs_identifier_init_from_emitter_and_contributors
@
<<nlo data: phs identifier: TBP>>=
  procedure :: check => phs_identifier_check
<<nlo data: procedures>>=
  function phs_identifier_check (phs_id, emitter, contributors) result (check)
    logical :: check
    class(phs_identifier_t), intent(in) :: phs_id
    integer, intent(in) :: emitter
    integer, intent(in), dimension(:), optional :: contributors
    check = phs_id%emitter == emitter
    if (present (contributors)) then
       if (.not. allocated (phs_id%contributors)) &
          call msg_fatal ("Phs identifier: contributors not allocated!")
       check = check .and. all (phs_id%contributors == contributors)
    end if
  end function phs_identifier_check

@ %def phs_identifier_check
@
<<nlo data: phs identifier: TBP>>=
  procedure :: write => phs_identifier_write
<<nlo data: procedures>>=
  subroutine phs_identifier_write (phs_id, unit)
    class(phs_identifier_t), intent(in) :: phs_id
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit); if (u < 0) return
    write (u, '(A)') 'phs_identifier: '
    write (u, '(A,1X,I1)') 'Emitter: ', phs_id%emitter
    if (allocated (phs_id%contributors)) then
       write (u, '(A)', advance = 'no') 'Resonance contributors: '
       do i = 1, size (phs_id%contributors)
          write (u, '(I1,1X)', advance = 'no') phs_id%contributors(i)
       end do
    else
       write (u, '(A)') 'No Contributors allocated'
    end if
  end subroutine phs_identifier_write

@ %def phs_identifier_write
@
<<nlo data: public>>=
  public :: check_for_phs_identifier
<<nlo data: procedures>>=
  subroutine check_for_phs_identifier (phs_id, emitter, contributors, phs_exist, i_phs)
     type(phs_identifier_t), intent(in), dimension(:) :: phs_id
     integer, intent(in) :: emitter
     integer, intent(in), dimension(:), optional :: contributors
     logical, intent(out) :: phs_exist
     integer, intent(out) :: i_phs
     integer :: i
     phs_exist = .false.
     i_phs = -1
     do i = 1, size (phs_id)
        if (phs_id(i)%emitter < 0) then
           i_phs = i
           exit
        end if 
        phs_exist = phs_id(i)%emitter == emitter
        if (present (contributors)) &
           phs_exist = phs_exist .and. all (phs_id(i)%contributors == contributors)
        if (phs_exist) then
           i_phs = i
           exit
        end if
     end do
  end subroutine check_for_phs_identifier

@ %def check_for_phs_identifier
@
<<nlo data: public>>=
  public :: phs_point_set_t
<<nlo data: types>>=
  type :: phs_point_set_t
     type(phs_point_t), dimension(:), allocatable :: phs_point
     logical :: initialized = .false.
  contains
  <<nlo data: phs point set: TBP>>
  end type phs_point_set_t

@ %def phs_point_set_t
@
<<nlo data: phs point set: TBP>>=
  procedure :: init => phs_point_set_init
<<nlo data: procedures>>=
  subroutine phs_point_set_init (phs_point_set, n_particles, n_phs)
    class(phs_point_set_t), intent(out) :: phs_point_set
    integer, intent(in) :: n_particles, n_phs
    integer :: i_phs
    allocate (phs_point_set%phs_point (n_phs))
    do i_phs = 1, n_phs
       phs_point_set%phs_point(i_phs) = n_particles
    end do
    phs_point_set%initialized = .true.
  end subroutine phs_point_set_init

@ %def phs_point_set_init
@
<<nlo data: phs point set: TBP>>=
  procedure :: write => phs_point_set_write
<<nlo data: procedures>>=
  subroutine phs_point_set_write (phs_point_set, i_phs, contributors, unit)
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in), optional :: i_phs
    integer, intent(in), dimension(:), optional :: contributors
    integer, intent(in), optional :: unit
    integer :: i, u
    type(vector4_t) :: p_sum
    u = given_output_unit (unit); if (u < 0) return
    if (present (i_phs)) then
       call phs_point_set%phs_point(i_phs)%write (u, show_mass = .true.)
    else
       do i = 1, size(phs_point_set%phs_point)
          call phs_point_set%phs_point(i_phs)%write (u, show_mass = .true.)
       end do
    end if
    if (present (contributors)) then
       p_sum = vector4_null
       call msg_debug (D_SUBTRACTION, "Invariant masses for real emission: ")
       associate (p => phs_point_set%phs_point(i_phs)%p)
          do i = 1, size (contributors)
             p_sum = p_sum + p(contributors(i))
          end do
          p_sum = p_sum + p(size(p))
       end associate
       if (debug_active (D_SUBTRACTION)) call vector4_write (p_sum, show_mass = .true.)
    end if
  end subroutine phs_point_set_write

@ %def phs_point_set_write
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_n_momenta => phs_point_set_get_n_momenta
<<nlo data: procedures>>=
  elemental function phs_point_set_get_n_momenta (phs_point_set, i_res) result (n)
    integer :: n
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_res
    n = phs_point_set%phs_point(i_res)%n_momenta
  end function phs_point_set_get_n_momenta

@ %def phs_point_set_get_n_momenta
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_momenta => phs_point_set_get_momenta
<<nlo data: procedures>>=
  function phs_point_set_get_momenta (phs_point_set, i_phs) result (p)
    type(vector4_t), dimension(:), allocatable :: p
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_phs
    allocate (p (phs_point_set%phs_point(i_phs)%n_momenta), &
       source = phs_point_set%phs_point(i_phs)%p)
  end function phs_point_set_get_momenta

@ %def phs_point_set_get_momenta
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_momentum => phs_point_set_get_momentum
<<nlo data: procedures>>=
  pure function phs_point_set_get_momentum (phs_point_set, i_phs, i_mom) result (p)
    type(vector4_t) :: p
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_phs, i_mom
    p = phs_point_set%phs_point(i_phs)%p(i_mom)
  end function phs_point_set_get_momentum

@ %def phs_point_set_get_momentum
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_energy => phs_point_set_get_energy
<<nlo data: procedures>>=
  pure function phs_point_set_get_energy (phs_point_set, i_phs, i_mom) result (E)
    real(default) :: E
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_phs, i_mom
    E = phs_point_set%phs_point(i_phs)%p(i_mom)%p(0)
  end function phs_point_set_get_energy

@ %def phs_point_set_get_energy
@ 
<<nlo data: phs point set: TBP>>=
  procedure :: set_momenta => phs_point_set_set_momenta
<<nlo data: procedures>>=
  subroutine phs_point_set_set_momenta (phs_point_set, i_phs, p)
    class(phs_point_set_t), intent(inout) :: phs_point_set
    integer, intent(in) :: i_phs
    type(vector4_t), intent(in), dimension(:) :: p
    phs_point_set%phs_point(i_phs)%p = p
  end subroutine phs_point_set_set_momenta

@ %def phs_point_set_set_momenta
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_n_particles => phs_point_set_get_n_particles
<<nlo data: procedures>>=
  function phs_point_set_get_n_particles (phs_point_set, i) result (n_particles)
    integer :: n_particles
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in), optional :: i
    integer :: j
    j = 1; if (present (i)) j = i
    n_particles = size (phs_point_set%phs_point(j)%p)
  end function phs_point_set_get_n_particles

@ %def phs_point_set_get_n_particles
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_n_phs => phs_point_set_get_n_phs
<<nlo data: procedures>>=
  function phs_point_set_get_n_phs (phs_point_set) result (n_phs)
    integer :: n_phs
    class(phs_point_set_t), intent(in) :: phs_point_set
    n_phs = size (phs_point_set%phs_point)
  end function phs_point_set_get_n_phs

@ %def phs_point_set_get_n_phs
@
<<nlo data: phs point set: TBP>>=
  procedure :: get_invariant_mass => phs_point_set_get_invariant_mass
<<nlo data: procedures>>=
  function phs_point_set_get_invariant_mass (phs_point_set, i_phs, i_part) result (m2)
    real(default) :: m2
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_phs
    integer, intent(in), dimension(:) :: i_part
    type(vector4_t) :: p
    integer :: i
    p = vector4_null
    do i = 1, size (i_part)
       p = p + phs_point_set%phs_point(i_phs)%p(i_part(i))
    end do
    m2 = p**2
  end function phs_point_set_get_invariant_mass

@ %def phs_point_set_get_invariant_mass
@
<<nlo data: phs point set: TBP>>=
  procedure :: write_phs_point => phs_point_set_write_phs_point
<<nlo data: procedures>>=
  subroutine phs_point_set_write_phs_point (phs_point_set, i_phs, unit, show_mass, &
     testflag, check_conservation, ultra, n_in)
    class(phs_point_set_t), intent(in) :: phs_point_set
    integer, intent(in) :: i_phs
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_mass
    logical, intent(in), optional :: testflag, ultra
    logical, intent(in), optional :: check_conservation
    integer, intent(in), optional :: n_in
    call phs_point_set%phs_point(i_phs)%write (unit, show_mass, testflag, &
       check_conservation, ultra, n_in)
  end subroutine phs_point_set_write_phs_point

@ %def phs_point_set_write_phs_point
@
<<nlo data: types>>=
  type :: real_jacobian_t
    real(default), dimension(4) :: jac = 1._default
  contains
  <<nlo data: real jacobian: TBP>>
  end type real_jacobian_t

@ %def real_jacobian_t
@ Just a container for the real kinematics variables.
<<nlo data: public>>=
  public :: real_kinematics_t
<<nlo data: types>>=
  type :: real_kinematics_t
    logical :: supply_xi_max = .true.
    real(default) :: xi_tilde
    real(default) :: phi
    real(default), dimension(:), allocatable :: xi_max, y
    real(default) :: xi_mismatch, y_mismatch
    type(real_jacobian_t), dimension(:), allocatable :: jac
    real(default) :: jac_mismatch
    type(phs_point_set_t) :: p_born_cms
    type(phs_point_set_t) :: p_born_lab
    type(phs_point_set_t) :: p_real_cms
    type(phs_point_set_t) :: p_real_lab
    integer, dimension(:), allocatable :: alr_to_i_phs
    real(default), dimension(3) :: x_rad
    real(default), dimension(:), allocatable :: jac_rand
    real(default), dimension(:), allocatable :: y_soft
    real(default) :: cms_energy2
    type(vector4_t), dimension(:), allocatable :: k_perp
    type(vector4_t), dimension(:), allocatable :: xi_ref_momenta
  contains
  <<nlo data: real kinematics: TBP>>
  end type real_kinematics_t

@ %def real_kinematics_t
@
<<nlo data: real kinematics: TBP>>=
  procedure :: init => real_kinematics_init
<<nlo data: procedures>>=
  subroutine real_kinematics_init (r, n_tot, n_phs, n_alr, n_contr)
    class(real_kinematics_t), intent(inout) :: r
    integer, intent(in) :: n_tot, n_phs, n_alr, n_contr
    allocate (r%xi_max (n_phs))
    allocate (r%y (n_phs))
    allocate (r%y_soft (n_phs))
    call r%p_born_cms%init (n_tot, 1)
    call r%p_born_lab%init (n_tot, 1)
    call r%p_real_cms%init (n_tot + 1, n_phs)
    call r%p_real_lab%init (n_tot + 1, n_phs)
    allocate (r%jac (n_phs), r%jac_rand (n_phs))
    allocate (r%k_perp (n_tot))
    allocate (r%alr_to_i_phs (n_alr))
    allocate (r%xi_ref_momenta (n_contr))
    r%alr_to_i_phs = 0
    r%xi_tilde = zero; r%xi_mismatch = zero
    r%xi_max = zero
    r%y = zero; r%y_mismatch = zero
    r%y_soft = zero
    r%phi = zero
    r%cms_energy2 = zero
    r%xi_ref_momenta = vector4_null
    r%jac_mismatch = one
    r%jac_rand = one
  end subroutine real_kinematics_init

@ %def real_kinematics_init
@
<<nlo data: real kinematics: TBP>>=
  procedure :: write => real_kinematics_write
<<nlo data: procedures>>=
  subroutine real_kinematics_write (r, unit)
    class(real_kinematics_t), intent(in) :: r
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit); if (u < 0) return
    write (u,"(A)") "Real kinematics: "
    write (u,"(A,F5.3)") "xi_tilde: ", r%xi_tilde
    write (u,"(A,F5.3)") "phi: ", r%phi
    do i = 1, size (r%xi_max)
       write (u,"(A,I1,1X)") "i_phs: ", i
       write (u,"(A,100F5.3,1X)") "xi_max: ", r%xi_max(i)
       write (u,"(A,100F5.3,1X)") "y: ", r%y(i)
       write (u,"(A,100F5.3,1X)") "jac_rand: ", r%jac_rand(i)
       write (u,"(A,100F5.3,1X)") "y_soft: ", r%y_soft(i)
    end do
  end subroutine real_kinematics_write

@ %def real_kinematics_write
@ This routine computes the bounds of the Dalitz region for massive emitters, see below.
It is also used by [[Powheg]], so the routine is public.
The input parameter [[m2]] corresponds to the squared mass of the emitter and [[p]] is the
four-momentum of the emitter.
<<nlo data: public>>=
  public :: compute_dalitz_bounds
<<nlo data: procedures>>=
  pure subroutine compute_dalitz_bounds (q0, m2, mrec2, z1, z2, k0_rec_max)
    real(default), intent(in) :: q0, m2, mrec2
    real(default), intent(out) :: z1, z2, k0_rec_max
    k0_rec_max = (q0**2 - m2 + mrec2) / (two * q0)
    z1 = (k0_rec_max + sqrt(k0_rec_max**2 - mrec2)) / q0
    z2 = (k0_rec_max - sqrt(k0_rec_max**2 - mrec2)) / q0
  end subroutine compute_dalitz_bounds

@ %def compute_dalitz_bounds
@ Compute the [[kt2]] of a given emitter
<<nlo data: real kinematics: TBP>>=
  procedure :: kt2 => real_kinematics_kt2
<<nlo data: procedures>>=
  function real_kinematics_kt2 &
     (real_kinematics, i_phs, emitter, kt2_type, xi, y) result (kt2)
    real(default) :: kt2
    class(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: emitter, i_phs, kt2_type
    real(default), intent(in), optional :: xi, y
    real(default) :: xii, yy
    real(default) :: q, E_em, z, z1, z2, m2, mrec2, k0_rec_max
    type(vector4_t) :: p_emitter
    if (present (y)) then
       yy = y
    else
       yy = real_kinematics%y (i_phs)
    end if
    if (present (xi)) then
       xii = xi
    else
       xii = real_kinematics%xi_tilde * real_kinematics%xi_max (i_phs)
    end if
    select case (kt2_type)
    case (FSR_SIMPLE)
       kt2 = real_kinematics%cms_energy2 / two * xii**2 * (1 - yy)
    case (FSR_MASSIVE)
       q = sqrt (real_kinematics%cms_energy2)
       p_emitter = real_kinematics%p_born_cms%phs_point(1)%p(emitter)
       mrec2 = (q - p_emitter%p(0))**2 - sum (p_emitter%p(1:3)**2)
       m2 = p_emitter**2
       E_em = energy (p_emitter)
       call compute_dalitz_bounds (q, m2, mrec2, z1, z2, k0_rec_max)
       z = z2 - (z2 - z1) * (one + yy) / two
       kt2 = xii**2 * q**3 * (one - z) / &
          (two * E_em - z * xii * q)
    case (FSR_MASSLESS_RECOILER)
       kt2 = real_kinematics%cms_energy2 / two * xii**2 * (1 - yy**2) / two
    case default
       kt2 = zero
       call msg_bug ("kt2_type must be set to a known value")
    end select
  end function real_kinematics_kt2

@ %def real_kinematics_kt2
@
<<nlo data: parameters>>=
  integer, parameter, public :: FSR_SIMPLE = 1
  integer, parameter, public :: FSR_MASSIVE = 2
  integer, parameter, public :: FSR_MASSLESS_RECOILER = 3
@ %def FSR_SIMPLE FSR_MASSIVE FSR_MASSLESS_RECOILER
@ Another container for the $x_\oplus$- and $x_\ominus$-values for
initial-state phase spaces.
<<nlo data: real kinematics: TBP>>=
  procedure :: compute_k_perp_isr => real_kinematics_compute_k_perp_isr
<<nlo data: procedures>>=
  subroutine real_kinematics_compute_k_perp_isr (real_kin, emitter)
    class(real_kinematics_t), intent(inout) :: real_kin
    integer, intent(in) :: emitter
    associate (k => real_kin%k_perp(emitter))
       k%p(0) = zero
       k%p(1) = cos(real_kin%phi)
       k%p(2) = sin(real_kin%phi)
       k%p(3) = zero
    end associate
  end subroutine real_kinematics_compute_k_perp_isr

@ %def real_kinematics_compute_k_perp_isr
@
<<nlo data: real kinematics: TBP>>=
  procedure :: compute_k_perp_fsr => real_kinematics_compute_k_perp_fsr
<<nlo data: procedures>>=
  subroutine real_kinematics_compute_k_perp_fsr (real_kin, emitter)
    class(real_kinematics_t), intent(inout) :: real_kin
    integer, intent(in) :: emitter
    type(vector3_t) :: vec
    type(lorentz_transformation_t) :: rot
    associate (p => real_kin%p_born_cms%phs_point(1)%p(emitter), k => real_kin%k_perp(emitter))
       vec = p%p(1:3) / p%p(0)
       k%p(0) = zero
       k%p(1) = p%p(1); k%p(2) = p%p(2)
       k%p(3) = - (p%p(1)**2 + p%p(2)**2) / p%p(3)
       rot = rotation (cos(real_kin%phi), sin(real_kin%phi), vec)
       k = rot * k
       k%p(1:3) = k%p(1:3) / space_part_norm (k)
    end associate
  end subroutine real_kinematics_compute_k_perp_fsr

@ %def real_kinematics_compute_k_perp_fsr
@
<<nlo data: public>>=
  public :: real_scales_t
<<nlo data: types>>=
  type :: real_scales_t
     real(default) :: scale
     real(default) :: ren_scale
     real(default) :: fac_scale
  end type real_scales_t

@ %def real_scales_t
@ Another container for the $x_\oplus$- and $x_\ominus$-values for initial-state phase spaces.
<<nlo data: public>>=
  public :: isr_kinematics_t
<<nlo data: types>>=
  type :: isr_kinematics_t
    integer :: n_in
    real(default), dimension(2) :: x = 1._default
    real(default), dimension(2) :: z = 0._default
    real(default) :: sqrts_born = 0._default
    real(default) :: beam_energy = 0._default
    real(default) :: fac_scale = 0._default
    real(default), dimension(2) :: jacobian = 1._default
  end type isr_kinematics_t

@ %def type isr_kinematics_t
@ Keep score about the real kinematics.
<<nlo data: public>>=
  public :: kinematics_counter_t
<<nlo data: types>>=
  type :: kinematics_counter_t
    integer :: n_bins = 0
    integer, dimension(:), allocatable :: histo_xi
    integer, dimension(:), allocatable :: histo_xi_tilde
    integer, dimension(:), allocatable :: histo_xi_max
    integer, dimension(:), allocatable :: histo_y
    integer, dimension(:), allocatable :: histo_phi
  contains
  <<nlo data: kinematics counter: TBP>>
  end type kinematics_counter_t

@ %def kinematics_counter_t
@
<<nlo data: kinematics counter: TBP>>=
  procedure :: init => kinematics_counter_init
<<nlo data: procedures>>=
  subroutine kinematics_counter_init (counter, n_bins)
    class(kinematics_counter_t), intent(inout) :: counter
    integer, intent(in) :: n_bins
    counter%n_bins = n_bins
    allocate (counter%histo_xi (n_bins), counter%histo_xi_tilde (n_bins))
    allocate (counter%histo_y (n_bins), counter%histo_phi (n_bins))
    allocate (counter%histo_xi_max (n_bins))
    counter%histo_xi = 0
    counter%histo_xi_tilde = 0
    counter%histo_xi_max = 0
    counter%histo_y = 0
    counter%histo_phi = 0
  end subroutine kinematics_counter_init

@ %def kinematics_counter_init
@
<<nlo data: kinematics counter: TBP>>=
  procedure :: record => kinematics_counter_record
<<nlo data: procedures>>=
  subroutine kinematics_counter_record (counter, xi, xi_tilde, &
                                        xi_max, y, phi)
     class(kinematics_counter_t), intent(inout) :: counter
     real(default), intent(in), optional :: xi, xi_tilde, xi_max
     real(default), intent(in), optional :: y, phi

     if (counter%n_bins > 0) then
       if (present (xi)) then
          call fill_histogram (counter%histo_xi, xi, &
                               0.0_default, 1.0_default)
       end if
       if (present (xi_tilde)) then
          call fill_histogram (counter%histo_xi_tilde, xi_tilde, &
                               0.0_default, 1.0_default)
       end if
       if (present (xi_max)) then
          call fill_histogram (counter%histo_xi_max, xi_max, &
                               0.0_default, 1.0_default)
       end if
       if (present (y)) then
          call fill_histogram (counter%histo_y, y, -1.0_default, 1.0_default)
       end if
       if (present (phi)) then
          call fill_histogram (counter%histo_phi, phi, 0.0_default, twopi)
       end if
     end if
  contains
     subroutine fill_histogram (histo, value, val_min, val_max)
        integer, dimension(:), allocatable :: histo
        real(default), intent(in) :: value, val_min, val_max
        real(default) :: step, lo, hi
        integer :: bin
        step = (val_max-val_min) / counter%n_bins
        do bin = 1, counter%n_bins
           lo = (bin - 1) * step
           hi = bin * step
           if (value >= lo .and. value < hi) then
               histo (bin) = histo (bin) + 1
               exit
           end if
        end do
     end subroutine fill_histogram
  end subroutine kinematics_counter_record

@ %def kinematics_counter_record
<<nlo data: kinematics counter: TBP>>=
  procedure :: display => kinematics_counter_display
<<nlo data: procedures>>=
  subroutine kinematics_counter_display (counter)
     class(kinematics_counter_t), intent(in) :: counter
     print *, 'xi: ', counter%histo_xi
     print *, 'xi_tilde: ', counter%histo_xi_tilde
     print *, 'xi_max: ', counter%histo_xi_max
     print *, 'y: ', counter%histo_y
     print *, 'phi: ', counter%histo_phi
  end subroutine kinematics_counter_display

@ %def kinematics_counter_display
@
<<nlo data: public>>=
  public :: pdf_container_t
<<nlo data: types>>=
  type :: pdf_container_t
     real(default), dimension(-6:6) :: f
  contains
  <<nlo data: pdf container: TBP>>
  end type pdf_container_t

@ %def pdf_container_t
@
<<nlo data: public>>=
  public :: powheg_damping_t
<<nlo data: types>>=
  type, abstract :: powheg_damping_t
  contains
  <<nlo data: powheg damping: TBP>>
  end type powheg_damping_t

@ %def powheg_damping_t
@
<<nlo data: powheg damping: TBP>>=
  procedure (powheg_damping_get_f), deferred :: get_f
<<nlo data: interfaces>>=
  abstract interface
    function powheg_damping_get_f (damping, pt2) result (f)
       import
       real(default) :: f
       class(powheg_damping_t), intent(in) :: damping
       real(default), intent(in) :: pt2
    end function powheg_damping_get_f
  end interface

@ %def powheg_damping_get_f
@
<<nlo data: public>>=
  public :: powheg_damping_simple_t
<<nlo data: types>>=
  type, extends (powheg_damping_t) :: powheg_damping_simple_t
     real(default) :: h2 = 5._default
  contains
  <<nlo data: powheg damping simple: TBP>>
  end type powheg_damping_simple_t

@ %def powheg_damping_simple_t
@
<<nlo data: powheg damping simple: TBP>>=
  procedure :: get_f => powheg_damping_simple_get_f
<<nlo data: procedures>>=
  function powheg_damping_simple_get_f (damping, pt2) result (f)
    real(default) :: f
    class(powheg_damping_simple_t), intent(in) :: damping
    real(default), intent(in) :: pt2
    f = damping%h2 / (pt2 + damping%h2)
  end function powheg_damping_simple_get_f

@ %def powheg_damping_simple_get_f
@
<<[[nlo_controller.f90]]>>=
<<File header>>

module nlo_controller

<<Use kinds>>
  use io_units
  use constants
  use numeric_utils
  use diagnostics
  use physics_defs
  use process_constants !NODEP!
  use sm_physics
  use os_interface
  use model_data
  use pdg_arrays
  use particle_specifiers
  use phs_base
  use phs_single
  use cascades
  use prc_threshold, only: prc_threshold_t
  use state_matrices
  use interactions
  use lorentz
  use prc_core
  use prc_user_defined
  use sf_base
  use colors
  use phs_fks
  use flavors
  use fks_regions
  use nlo_data
  use virtual
  use real_subtraction
  use pdf_subtraction

<<Standard module head>>

<<nlo controller: public>>

<<nlo controller: public operators>>

<<nlo controller: types>>

<<nlo controller: interfaces>>

contains

<<nlo controller: procedures>>

end module nlo_controller
@ %def nlo_controller
@ We need to associate singular regions with compatible color flows.
<<nlo controller: types>>=
  type :: ftuple_color_map_t
    integer :: index
    integer :: color_index
    type(ftuple_color_map_t), pointer :: next
    type(ftuple_color_map_t), pointer :: prev
  contains
  <<nlo controller: color map: TBP>>
  end type ftuple_color_map_t

@ %def ftuple_color_map_t
@
<<nlo controller: color map: TBP>>=
  procedure :: init => ftuple_color_map_init
<<nlo controller: procedures>>=
  subroutine ftuple_color_map_init (icm)
    class(ftuple_color_map_t), intent(inout), target :: icm
    icm%index = 0
    icm%color_index = 0
    nullify (icm%next)
    nullify (icm%prev)
  end subroutine ftuple_color_map_init

@ %def ftuple_color_map_init
@ Explain
<<nlo controller: color map: TBP>>=
  procedure :: present => ftuple_color_map_present
<<nlo controller: procedures>>=
  function ftuple_color_map_present (icm, color_index) result(pres)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: color_index
    logical :: pres
    type(ftuple_color_map_t), pointer :: current
    pres = .false.
    select type (icm)
    type is (ftuple_color_map_t)
       current => icm
       do
          if (current%color_index == color_index) then
             pres = .true.
             exit
          else
             if (associated (current%next)) then
                current => current%next
             else
                exit
             end if
          end if
       end do
    end select
  end function ftuple_color_map_present

@ %def ftuple_color_map_present
@ Appends a color flow to the list
<<nlo controller: color map: TBP>>=
  procedure :: append => ftuple_color_map_append
<<nlo controller: procedures>>=
  subroutine ftuple_color_map_append (icm, val)
    class(ftuple_color_map_t), intent(inout), target :: icm
    integer, intent(in) :: val
    type(ftuple_color_map_t), pointer :: current
    select type (icm)
    type is (ftuple_color_map_t)
    if (.not. icm%present (val)) then
      if (icm%index == 0) then
        nullify(icm%next)
        icm%index = 1
        icm%color_index = val
      else
        current => icm
        do
          if (associated (current%next)) then
            current => current%next
          else
            allocate (current%next)
            nullify (current%next%next)
            current%next%prev => current
            current%next%index = current%index + 1
            current%next%color_index = val
            exit
          end if
        end do
      end if
    end if
    end select
  end subroutine ftuple_color_map_append

@ %def ftuple_color_map_append
@
<<nlo controller: color map: TBP>>=
  procedure :: get_n_entries => ftuple_color_map_get_n_entries
<<nlo controller: procedures>>=
  function ftuple_color_map_get_n_entries (icm) result(n_entries)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer :: n_entries
    type(ftuple_color_map_t), pointer :: current
    n_entries = 0
    select type (icm)
    type is (ftuple_color_map_t)
       current => icm
       do
          if (associated (current%next)) then
             current => current%next
          else
             n_entries = current%index
             exit
          end if
       end do
    end select
  end function ftuple_color_map_get_n_entries

@ %def ftuple_color_map_get_n_entries
@ Explain
<<nlo controller: color map: TBP>>=
  procedure :: get_index_array => ftuple_color_map_get_index_array
<<nlo controller: procedures>>=
  function ftuple_color_map_get_index_array (icm) result(iarr)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, dimension(:), allocatable :: iarr
    type(ftuple_color_map_t), pointer :: current
    integer :: n_entries
    integer :: i
    select type (icm)
    type is (ftuple_color_map_t)
    n_entries = icm%get_n_entries ()
    allocate (iarr(n_entries))
    do i = 1, n_entries
      if (i == 1) then
        current => icm
      else
        current => current%next
      end if
      iarr(i) = current%color_index
    end do
    end select
  end function ftuple_color_map_get_index_array

@ %def ftuple_color_map_get_index_array
@
<<nlo controller: color map: TBP>>=
  procedure :: get_entry => ftuple_color_map_get_entry
<<nlo controller: procedures>>=
  function ftuple_color_map_get_entry (icm, index) result(entry)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: index
    integer :: entry
    type(ftuple_color_map_t), pointer :: current
    integer :: i
    entry = 0
    select type (icm)
    type is (ftuple_color_map_t)
       if (index <= icm%get_n_entries ()) then
          do i = 1, icm%get_n_entries ()
             if (i == 1) then
                current => icm
             else
                current => current%next
             end if
             if (i == index) entry = current%color_index
          end do
       end if
    end select
  end function ftuple_color_map_get_entry

@ %def ftuple_color_map_get_entry
@ Explain
<<nlo controller: color map: TBP>>=
  procedure :: create_map => ftuple_color_map_create_map
<<nlo controller: procedures>>=
  recursive subroutine ftuple_color_map_create_map (icm, flst, &
       emitter, allreg, color_states_born, color_states_real, p_rad_in)
    class(ftuple_color_map_t), intent(inout) :: icm
    type(flv_structure_t), intent(in) :: flst
    integer, intent(in) :: emitter
    type(ftuple_t), intent(in), dimension(:) :: allreg
    integer, intent(in), dimension(:,:,:) :: color_states_born
    integer, intent(in), dimension(:,:,:) :: color_states_real
    integer, intent(in), optional :: p_rad_in
    integer :: nreg, region
    integer :: p1, p2, p_rad
    integer :: flv_em, flv_rad
    integer :: n_col_real
    integer, dimension(2) :: col_em, col_rad
    integer :: i
    !!! splitting type: 1 - q -> qg
    !!!                 2 - g -> qq
    !!!                 3 - g -> gg
    integer :: splitting_type_flv, splitting_type_col
    nreg = size (allreg)
    n_col_real = size (color_states_real (1,1,:))
    do region = 1, nreg
      call allreg(region)%get (p1, p2)
      if (p1 == emitter .or. p2 == emitter .or. present (p_rad_in)) then
        if (.not. present (p_rad_in)) then
          if (p1 == emitter) then
            p_rad = p2
          else
            p_rad = p1
          end if
        else
          p_rad = p_rad_in
        end if
        if (emitter /= 0) then
          flv_em = flst%flst (emitter)
        else
          call icm%create_map &
               (flst, 1, allreg, color_states_born, color_states_real, p_rad)
          call icm%create_map &
               (flst, 2, allreg, color_states_born, color_states_real, p_rad)
          return
        end if
        flv_rad = flst%flst (p_rad)
        if (is_quark (abs(flv_em)) .and. is_gluon (flv_rad)) then
           splitting_type_flv = 1
        else if (is_quark (abs(flv_em)) .and. flv_em + flv_rad == 0) then
           splitting_type_flv = 2
        else if (is_gluon (flv_em) .and. is_gluon (flv_rad)) then
           splitting_type_flv = 3
        else
          splitting_type_flv = 0
        end if
        do i = 1, n_col_real
           col_em = color_states_real(:,emitter,i)
           col_rad = color_states_real(:,p_rad,i)
          if (is_color_singlet (col_em(1), col_em(2)) &
              .and. (is_color_doublet (col_rad(1), col_rad(2)) &
              .or. is_color_ghost (col_rad(1), col_rad(2)))) then
            splitting_type_col = 1
          else if (is_color_singlet (col_em(1), col_em(2)) .and. &
                   is_color_singlet (col_rad(1), col_rad(2))) then
            splitting_type_col = 2
          else if (is_color_doublet (col_em(1), col_em(2)) .and. &
                   is_color_doublet (col_rad(1), col_rad(2))) then
            splitting_type_col = 3
          else
            splitting_type_col = 0
          end if
          if (splitting_type_flv == splitting_type_col .and. &
              splitting_type_flv /= 0) then
            call icm%append (i)
          end if
        end do
      end if
    end do
  contains
    function is_color_singlet (c1, c2) result (singlet)
      integer, intent(in) :: c1, c2
      logical :: singlet
      singlet = (c1 == 0 .and. c2 /= 0) .or. (c1 /= 0 .and. c2 == 0)
    end function is_color_singlet
    function is_color_doublet (c1, c2) result (doublet)
      integer, intent(in) :: c1, c2
      logical :: doublet
      doublet = c1 /= 0 .and. c2 /= 0
    end function is_color_doublet
    function is_color_ghost (c1, c2) result (ghost)
      integer, intent(in) :: c1, c2
      logical :: ghost
      ghost = c1 == 0 .and. c2 == 0
    end function is_color_ghost
  end subroutine ftuple_color_map_create_map

@ %def ftuple_color_map_create_map
@ This data type contains color information, necessary for both soft
and virtual counterterms.
<<nlo controller: types>>=
  type color_data_t
    type(ftuple_color_map_t), dimension(:), allocatable :: icm
    integer, dimension(:,:,:), allocatable :: col_state_born, col_state_real
    logical, dimension(:,:), allocatable :: ghost_flag_born, ghost_flag_real
    integer :: n_col_born, n_col_real
    type(color_t), dimension(:,:), allocatable :: color_real, color_born
    integer, dimension(:), allocatable :: col_born
    complex(default), dimension(:), allocatable :: color_factors_born
    integer, dimension(:,:), allocatable :: cf_index_real
    real(default), dimension(:,:,:), allocatable :: beta_ij
    logical :: color_is_conserved
  contains
  <<nlo controller: color data: TBP>>
  end type color_data_t

@ %def color_data_t
@
<<nlo controller: color data: TBP>>=
  procedure :: init => color_data_init
<<nlo controller: procedures>>=
  subroutine color_data_init (color_data, reg_data, prc_constants, &
     factorization_mode)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    integer, intent(in) :: factorization_mode
    integer :: nlegs_real
    integer :: i, n_in
    nlegs_real = reg_data%nlegs_real
    call prc_constants(1)%get_col_state (color_data%col_state_born)
    call prc_constants(2)%get_col_state (color_data%col_state_real)
    call prc_constants(2)%get_cf_index (color_data%cf_index_real)
    call prc_constants(1)%get_color_factors (color_data%color_factors_born)
    color_data%n_col_born = size (color_data%col_state_born(1,1,:))
    color_data%n_col_real = size (color_data%col_state_real(1,1,:))
    allocate (color_data%ghost_flag_born &
         (size (prc_constants(1)%get_ghost_flag (), 1), &
          size (prc_constants(1)%get_ghost_flag ())))
    allocate (color_data%ghost_flag_real &
         (size (prc_constants(2)%get_ghost_flag (), 1), &
          size (prc_constants(2)%get_ghost_flag ())))
    color_data%ghost_flag_born = prc_constants(1)%get_ghost_flag ()
    color_data%ghost_flag_real = prc_constants(2)%get_ghost_flag ()
    allocate (color_data%color_real (nlegs_real, color_data%n_col_real))
    allocate (color_data%icm (reg_data%n_regions))
    do i = 1, color_data%n_col_real
      call color_init_from_array (color_data%color_real (:,i), &
           color_data%col_state_real (:,:,i), &
           color_data%ghost_flag_real (:,i))
      n_in = prc_constants(1)%n_in
      call color_data%color_real (1:n_in,i)%invert ()
    end do
    do i = 1, size(reg_data%regions)
      call color_data%icm(i)%init
      associate (region => reg_data%regions(i))
        call color_data%icm(i)%create_map (region%flst_real, region%emitter, &
             region%ftuples, color_data%col_state_born, &
             color_data%col_state_real)
      end associate
    end do
    call color_data%init_betaij (reg_data, factorization_mode)
  end subroutine color_data_init

@ %def color_data_init
@ Allocate and compute $\beta_{ij}$:
<<nlo controller: color data: TBP>>=
  procedure :: init_betaij => color_data_init_betaij
<<nlo controller: procedures>>=
  subroutine color_data_init_betaij (color_data, reg_data, factorization_mode)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: factorization_mode
    integer :: i
    if (debug_active (D_SUBTRACTION)) then
       call msg_print_color ("color_data_init_betaij", COL_AQUA)
       call msg_print_color ("factorization_mode", factorization_mode, COL_AQUA)
    end if
    allocate (color_data%beta_ij (reg_data%nlegs_born, &
         reg_data%nlegs_born, reg_data%n_flv_born))
    select case (factorization_mode)
    case (NO_FACTORIZATION)
       do i = 1, reg_data%n_flv_born
          call color_data%fill_betaij_matrix (reg_data%nlegs_born, i, &
             reg_data%regions(1)%flst_real, reg_data)
       end do
    case (FACTORIZATION_THRESHOLD)
       call color_data%fill_betaij_matrix_threshold ()
    end select
  end subroutine color_data_init_betaij

@ %def color_data_init_betaij
@ Actual computation of $\beta_{ij}$.
<<nlo controller: color data: TBP>>=
  procedure :: fill_betaij_matrix => color_data_fill_betaij_matrix
<<nlo controller: procedures>>=
  subroutine color_data_fill_betaij_matrix &
       (color_data, n_legs, uborn_index, flst_real, reg_data)
    class(color_data_t), intent(inout) :: color_data
    integer, intent(in) :: n_legs, uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    type(region_data_t), intent(inout) :: reg_data
    integer :: em1, em2
    associate (flv_born => reg_data%flv_born (uborn_index))
       do em1 = 1, n_legs
          do em2 = 1, n_legs
             if (flv_born%colored(em1) .and. flv_born%colored(em2)) then
                if (em1 < em2) then
                   color_data%beta_ij (em1, em2, uborn_index) &
                      = color_data%compute_bij &
                      (reg_data, uborn_index, flst_real, em1, em2)
                else if (em1 > em2) then
                   !!! B_ij is symmetric
                   color_data%beta_ij (em1, em2, uborn_index) = &
                      color_data%beta_ij (em2, em1, uborn_index)
                else
                   if (is_quark (abs (flv_born%flst (em1)))) then
                       color_data%beta_ij (em1, em2, uborn_index) = - cf
                   else
                      color_data%beta_ij (em1, em2, uborn_index) = - ca
                   end if
                end if
             else
                color_data%beta_ij (em1, em2, uborn_index) = zero
             end if
          end do
       end do
    end associate
    call check_color_conservation (color_data%beta_ij (:,:,uborn_index), &
         n_legs, color_data%color_is_conserved)
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "color_data_fill_betaij_matrix")
       print *, 'uborn_index =    ', uborn_index
       do em1 = 1, n_legs
          do em2 = 1, n_legs
             print *, 'em1, em2, color_data%beta_ij(em1,em2,uborn_index) = ', &
                  em1, em2, color_data%beta_ij(em1,em2,uborn_index)
          end do
       end do
    end if
  contains
    subroutine check_color_conservation (bij_matrix, n_legs, success)
      real(default), intent(in), dimension(:,:) :: bij_matrix
      integer, intent(in) :: n_legs
      logical, intent(out) :: success
      logical, dimension(:), allocatable :: check
      integer :: i, j
      real(default) :: bcheck
      real(default), parameter :: tol = 0.0001_default
      allocate (check (n_legs))
      do i = 1, n_legs
         bcheck = 0.0
         do j = 1, n_legs
            if (i /= j) bcheck = bcheck + bij_matrix (i, j)
         end do
         if (is_quark (abs(flst_real%flst (i))) .or. &
             is_gluon (flst_real%flst (i))) then
            if (is_quark (abs(flst_real%flst (i))) .and. &
                 (bcheck - cf) < tol) then
               check (i) = .true.
            else if (is_gluon (flst_real%flst (i)) .and. &
                 (bcheck - ca) < tol) then
               check (i) = .true.
            else
               check (i) = .false.
            end if
         else
            if (bcheck < tol) then
               check (i) = .true.
            else
               check (i) = .false.
            end if
         end if
      end do
      success = all (check)
    end subroutine check_color_conservation
  end subroutine color_data_fill_betaij_matrix

@ %def color_data_fill_betaij_matrix
@
<<nlo controller: color data: TBP>>=
  procedure :: fill_betaij_matrix_threshold &
     => color_data_fill_betaij_matrix_threshold
<<nlo controller: procedures>>=
  subroutine color_data_fill_betaij_matrix_threshold (color_data)
    class(color_data_t), intent(inout) :: color_data
    integer :: i, j
    color_data%beta_ij = zero
    associate (beta_ij => color_data%beta_ij (:,:,1))
       do i = 1, 4
          beta_ij (i,i) = -CF
       end do
       beta_ij (1,2) = CF; beta_ij (2,1) = CF
       beta_ij (3,4) = CF; beta_ij (4,3) = CF
    end associate
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "color_data_fill_betaij_matrix_threshold")
       do i = 1, size(color_data%beta_ij, dim=1)
          do j = 1, size(color_data%beta_ij, dim=1)
             print *, 'i, j, color_data%beta_ij(i,j,1) = ', &
                  i, j, color_data%beta_ij(i,j,1)
          end do
       end do
    end if
  end subroutine color_data_fill_betaij_matrix_threshold

@ %def color_data_fill_betaij_matrix_threshold
@ 
<<nlo controller: color data: TBP>>=
  procedure :: compute_bij => color_data_compute_bij
<<nlo controller: procedures>>=
  function color_data_compute_bij &
       (color_data, reg_data, uborn_index, flst_real, em1, em2) result (bij)
    class(color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    integer, intent(in) :: em1, em2
    real(default) :: bij
    logical, dimension(:,:), allocatable :: cf_present
    type(singular_region_t), dimension(2,100) :: reg
    integer ::  i, j, k, l
    type(ftuple_color_map_t) :: icm1, icm2
    integer :: i1, i2
    real(default) :: color_factor, color_factor_born
    integer, dimension(2) :: i_reg
    logical , dimension(2) :: found
    integer, dimension(2,100) :: map_em_col_tmp
    integer, dimension(:), allocatable :: map_em_col1, map_em_col2
    integer, dimension(2) :: col1, col2
    integer, dimension(:), allocatable :: iarray1, iarray2
    integer, dimension(:), allocatable :: iisec1, iisec2
    integer :: sign
    color_factor = zero; color_factor_born = zero
    found = .false.
    !!! Include distinction between Born flavors
    do i = 1, size (color_data%color_factors_born)
       color_factor_born = color_factor_born + &
          real (color_data%color_factors_born (i))
    end do
    i1 = 1
    i2 = 1
    !!! Catch case em = 0
    if (em1 == 0 .or. em2 == 0) then
       !!! What to do?
       bij = zero
    else
       do i = 1, color_data%n_col_real
          col1 = color_data%col_state_real (:, em1, i)
          col2 = color_data%col_state_real (:, reg_data%nlegs_real, i)
          if (share_line (col1, col2)) then
             map_em_col_tmp(1, i1) = i
             i1 = i1 + 1
          end if
          col1 = color_data%col_state_real (:, em2, i)
          if (share_line (col1, col2)) then
             map_em_col_tmp(2, i2) = i
             i2 = i2 + 1
          end if
       end do
       allocate (map_em_col1 (i1), map_em_col2 (i2))
       map_em_col1 = map_em_col_tmp (1, 1 : i1 - 1)
       map_em_col2 = map_em_col_tmp (2, 1 : i2 - 1)

       i_reg = 1

       do i = 1, reg_data%n_regions
           if (uborn_index == reg_data%regions(i)%uborn_index) then
              if (em1 == reg_data%regions(i)%emitter .or. &
                 (em1 <= 2 .and. reg_data%regions(i)%emitter == 0)) then
                 reg(1, i_reg(1)) = reg_data%regions(i)
                 i_reg(1) = i_reg(1) + 1
                 found(1) = .true.
              end if
              if (em2 == reg_data%regions(i)%emitter .or. &
                 (em2 <= 2 .and. reg_data%regions(i)%emitter == 0)) then
                 reg(2, i_reg(2)) = reg_data%regions(i)
                 i_reg(2) = i_reg(2) + 1
                 found(2) = .true.
              end if
           end if
       end do
       if (.not. (found(1) .and. found(2))) then
          bij = 0
          return
       end if

       do i = 1, i_reg(1) - 1
          do j = 1, i_reg(2) - 1
             icm1 = color_data%icm (reg(1,i)%alr)
             icm2 = color_data%icm (reg(2,j)%alr)

             allocate (iarray1 (size (icm1%get_index_array ())))
             allocate (iarray2 (size (icm2%get_index_array ())))

             iarray1 = icm1%get_index_array ()
             iarray2 = icm2%get_index_array ()

             allocate (iisec1 (count (iarray1 == map_em_col1)))
             allocate (iisec2 (count (iarray2 == map_em_col2)))

             iisec1 = pack (iarray1, [ (any(iarray1(i) == map_em_col1), &
                  i = 1, size(iarray1)) ])
             iisec2 = pack (iarray2, [ (any(iarray2(i) == map_em_col2), &
                  i = 1, size(iarray2)) ])

             allocate (cf_present (size (color_index_present &
                (color_data%cf_index_real), 1), size (color_index_present &
                (color_data%cf_index_real), 2)))

             cf_present = color_index_present (color_data%cf_index_real)

             do k = 1, size (iisec1)
                do l = 1, size (iisec2)
                   i1 = iisec1(k)
                   i2 = iisec2(l)
                   if (cf_present (i1, i2)) then
                      if (is_gluon (flst_real%flst (em1)) .or. &
                         is_gluon (flst_real%flst (em2))) then
                         sign = get_sign (color_data%col_state_real (:, :, i1)) * &
                            get_sign (color_data%col_state_real (:, :, i2))
                      else
                         sign = 1
                      end if
                      color_factor = color_factor + sign*compute_color_factor &
                         (color_data%color_real(:, i1), &
                         color_data%color_real(:, i2))
                   end if
                end do
             end do
          deallocate (iarray1, iarray2, iisec1, iisec2, cf_present)
          end do
       end do
       !!! The real color factor always differs from the Born one
       !!! by one vertex factor. Thus, apply the factor 1/2
       bij = color_factor / (two * color_factor_born)
  end if

  contains
    function share_line (col1, col2) result (share)
      integer, intent(in), dimension(2) :: col1, col2
      logical :: share
      logical :: id1, id2, id3
      id1 = (abs(col1(1)) == abs(col2(1)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(2)) .and. col1(2) /= 0)
      id2 = (abs(col1(1)) == abs(col2(2)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(1)) .and. col1(2) /= 0)
      id3 = col2(1) == 0 .and. col2(2) == 0
      if (id1 .or. id2 .or. id3) then
        share = .true.
      else
        share = .false.
      end if
    end function share_line

    function get_sign (col) result (sign)
      integer, intent(in), dimension(:,:) :: col
      integer :: sign
      integer, dimension(:), allocatable :: iref, iperm
      integer :: iref1, iperm1
      integer :: n, i, i_first, j
      integer :: i1, i2
      integer :: p1, p2
      p1 = 2; p2 = 2
      iref1 = 0; iperm1 = 0; i_first = 0; i1 = 0
      do i = 1, size(col(1,:))
        if (.not. all (col(:,i) == 0)) then
          if (col(1,i) == 0) then
            i1 = col(2,i)
            iref1 = i; iperm1 = i
            i_first = i
          else
            i1 = col(1,i)
            iref1 = i; iperm1 = i
            i_first = i
          end if
          exit
        end if
      end do
      if (iref1 == 0 .or. iperm1 == 0 .or. i_first == 0) &
         call msg_fatal ("Invalid color structure")
      n = size(col(1,:)) - i_first + 1
      allocate (iref(n), iperm(n))
      iref(1) = iref1; iperm(1) = iperm1
      do i = i_first+1, size(col(1,:))
        if (all (col(:,i) == 0)) cycle
        if (i == size(col(1,:))) then
          iref(p1) = i_first + 1
        else
          iref(p1) = i + 1
          p1 = p1 + 1
        end if
        do j = i_first+1, size(col(1,:))
          if (col(1,j) == -i1) then
            i1 = col(2,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          else if (col(2,j) == -i1) then
            i1 = col(1,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          end if
        end do
      end do
      sign = 1
      do i = 1, n
        if (iperm(i) == iref(i)) then
          cycle
        else
          do j = i+1, n
            if (iperm(j) == iref(i)) then
              i1 = j
              exit
            end if
          end do
          i2 = iperm(i)
          iperm(i) = iperm(i1)
          iperm(i1) = i2
          sign = -sign
        end if
      end do
    end function get_sign

    function color_index_present (cf_index) result (cf_present)
      integer, intent(in), dimension(:,:), allocatable :: cf_index
      logical, dimension(:,:), allocatable :: cf_present
      integer :: n_col
      integer :: c, i1, i2
      n_col = size (cf_index(1,:))
      allocate (cf_present (n_col, n_col))
      cf_present = .false.
      do c = 1, n_col
        i1 = cf_index (1, c)
        i2 = cf_index (2, c)
        cf_present (i1, i2) = .true.
        if (i1 /= i2) cf_present(i2, i1) = .true.
      end do
    end function color_index_present
  end function color_data_compute_bij

@ %def color_data_compute_bij
@
<<nlo controller: color data: TBP>>=
  procedure :: write => color_data_write
<<nlo controller: procedures>>=
  subroutine color_data_write (color_data, unit)
    class(color_data_t), intent(in) :: color_data
    integer, intent(in), optional :: unit
    integer :: u, i, i1, i2
    integer :: n_legs
    u = given_output_unit (unit); if (u < 0) return
    n_legs = size (color_data%beta_ij, dim=2)
    write (u, "(1x,A)") "Color information: "
    write (u, "(1x,A,1x,I1)") "Number of Born color states: ", &
         color_data%n_col_born
    write (u, "(1x,A,1x,I1)") "Number of real color states: ", &
         color_data%n_col_real
    write (u, "(1x,A)") "Color correlation: "
    do i = 1, size (color_data%beta_ij, dim=3)
      write (u, "(1x,A,1x,I1)") "State nr. ", i
      write (u, "(1x,A)") "-------------"
      write (u, "(1x,A,1x,A,1x,A)") "i1", "i2", "color factor"
      do i1 = 1, n_legs
        do i2 = 1, i1
          write (u, "(1x,I1,1x,I1,1x,F5.2)") &
               i1, i2, color_data%beta_ij (i1,i2,i)
        end do
      end do
      write (u, "(1x,A)") "========================================"
    end do
    if (color_data%color_is_conserved) then
      write (u, "(1x,A)") "Color is conserved."
    else
      write (u, "(1x,A)") "Fatal error: Color conversation is violated."
    end if
  end subroutine color_data_write

@ %def color_data_write
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: evaluate_color_correlations => nlo_controller_evaluate_color_correlations
<<nlo controller: procedures>>=
  subroutine nlo_controller_evaluate_color_correlations (nlo_controller, core, &
     core_state, fac_scale, i_flv, i_flv_born, bad_point)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    class(prc_core_t), intent(inout) :: core
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    real(default), intent(in) :: fac_scale
    integer, intent(in) :: i_flv, i_flv_born
    logical, intent(out) :: bad_point
    call msg_debug2 (D_SUBTRACTION, "nlo_controller_evaluate_color_correlations: " // &
         "nlo_controller%settings%use_internal_color_correlations", &
         nlo_controller%settings%use_internal_color_correlations)
    call msg_debug2 (D_SUBTRACTION, "fac_scale", fac_scale)
    associate (collector => nlo_controller%sqme_collector)
       if (.not. nlo_controller%settings%use_internal_color_correlations) then
          select type (core)
          class is (prc_user_defined_base_t)
             call core%update_alpha_s (core_state, fac_scale)
             call core%compute_sqme_cc (i_flv, nlo_controller%int_born%get_momenta (), &
                fac_scale, collector%sqme_subtraction_born_list (i_flv_born), &
                collector%sqme_born_cc (:,:,i_flv_born), bad_point)
          end select
       else
          collector%sqme_born_cc (:,:,i_flv_born) = &
             collector%sqme_subtraction_born_list (i_flv_born) * &
             nlo_controller%color_data%beta_ij (:,:,i_flv_born)
          bad_point = .false.
       end if
    end associate 
  end subroutine nlo_controller_evaluate_color_correlations

@ %def nlo_controller_evaluate_color_correlations
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: compute_k_perp => nlo_controller_compute_k_perp
<<nlo controller: procedures>>=
  subroutine nlo_controller_compute_k_perp (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer :: emitter
    associate (real_kin => nlo_controller%real_kinematics)
       do emitter = 1, real_kin%p_born_cms%get_n_particles ()
          if (emitter <= 2) then
             call real_kin%compute_k_perp_isr (emitter)
          else
             call real_kin%compute_k_perp_fsr (emitter)
          end if
       end do
    end associate
  end subroutine nlo_controller_compute_k_perp

@ %def nlo_controller_compute_k_perp
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_k_perp => nlo_controller_get_k_perp
<<nlo controller: procedures>>=
  function nlo_controller_get_k_perp (nlo_controller) result (k_perp)
    type(vector4_t), dimension(:), allocatable :: k_perp
    class(nlo_controller_t), intent(in) :: nlo_controller
    k_perp = nlo_controller%real_kinematics%k_perp
  end function nlo_controller_get_k_perp

@ %def nlo_controller_get_k_perp
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: compute_sqme_mismatch => nlo_controller_compute_sqme_mismatch
<<nlo controller: procedures>>=
  subroutine nlo_controller_compute_sqme_mismatch (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%sqme_collector%sqme_mismatch = &
       nlo_controller%soft_mismatch%evaluate (nlo_controller%alpha_s_born)
  end subroutine nlo_controller_compute_sqme_mismatch

@ %def nlo_controller_sqme_mismatch
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: compute_sqme_real_fin => nlo_controller_compute_sqme_real_fin
<<nlo controller: procedures>>=
  function nlo_controller_compute_sqme_real_fin (nlo_controller) result (sqme_fin)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    real(default) :: sqme_fin
    integer :: emitter, i_flv, i_phs
    call msg_debug2 (D_SUBTRACTION, "nlo_controller_compute_sqme_real_fin")
    if (.not. nlo_controller%alpha_s_born_set) &
      call msg_fatal ("Strong coupling not set for real calculation")
    emitter = nlo_controller%get_active_emitter ()
    i_phs = nlo_controller%get_active_phase_space ()
    i_flv = nlo_controller%active_flavor_structure_real
    call nlo_controller%real_terms%set_real_kinematics &
         (nlo_controller%real_kinematics)
    call nlo_controller%real_terms%set_isr_kinematics &
         (nlo_controller%isr_kinematics)
    sqme_fin = nlo_controller%real_terms%compute &
         (emitter, i_phs, i_flv, nlo_controller%alpha_s_born)
  end function nlo_controller_compute_sqme_real_fin

@ %def nlo_controller_compute_sqme_real_fin
@ Check if there are massive emitters. Since the mass-structure of all
underlying Born configurations have to be the same, we just use the first
one to determine this.
<<nlo controller: nlo controller: TBP>>=
  procedure :: has_massive_emitter => nlo_controller_has_massive_emitter
<<nlo controller: procedures>>=
  function nlo_controller_has_massive_emitter (nlo_controller) result (val)
    class(nlo_controller_t), intent(in) :: nlo_controller
    logical :: val
    integer :: n_tot, i
    val = .false.
    associate (particle_data => nlo_controller%particle_data)
       n_tot = particle_data%n_in + particle_data%n_out_born
       do i = particle_data%n_in+1, n_tot
          if (any (i == nlo_controller%reg_data%emitters)) &
             val = val .or. nlo_controller%reg_data%flv_born(1)%massive(i)
       end do
    end associate
  end function nlo_controller_has_massive_emitter

@ %def nlo_controller_has_massive_emitter
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_mass_info => nlo_controller_get_mass_info
<<nlo controller: procedures>>=
  function nlo_controller_get_mass_info (nlo_controller, i_flv) result (massive)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i_flv
    logical, dimension(:), allocatable :: massive
    allocate (massive (size (nlo_controller%reg_data%flv_born(i_flv)%massive)))
    massive = nlo_controller%reg_data%flv_born(i_flv)%massive
  end function nlo_controller_get_mass_info

@ %def nlo_controller_get_mass_info
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_fixed_order_event_mode => nlo_controller_set_fixed_order_event_mode
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_fixed_order_event_mode (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%real_terms%purpose = FIXED_ORDER_EVENTS
  end subroutine nlo_controller_set_fixed_order_event_mode

<<nlo controller: nlo controller: TBP>>=
  procedure :: set_powheg_mode => nlo_controller_set_powheg_mode
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_powheg_mode (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%real_terms%purpose = POWHEG
  end subroutine nlo_controller_set_powheg_mode

@ %def nlo_controller_set_fixed_order_event_mode
@ %def nlo_controller_set_powheg_mode
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_real_sqme_born_pointer => nlo_controller_set_real_sqme_born_pointer
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_real_sqme_born_pointer (nlo_controller, sqme_born_list)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    real(default), intent(in), dimension(:), target :: sqme_born_list
    nlo_controller%real_terms%sqme_born => sqme_born_list
  end subroutine nlo_controller_set_real_sqme_born_pointer

@ %def nlo_controller_set_real_sqme_born_pointer
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_alr_to_i_phs => nlo_controller_set_alr_to_i_phs
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_alr_to_i_phs (nlo_controller, phs_identifiers)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    integer :: alr, i_phs
    integer :: emitter, i_res
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    do alr = 1, nlo_controller%reg_data%n_regions
       associate (region => nlo_controller%reg_data%regions(alr))
          emitter = region%emitter
          i_res = region%i_res
          if (i_res /= 0) then
             !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
             call nlo_controller%reg_data%get_contributors &
                (i_res, emitter, contributors%c, share_emitter)
             if (.not. share_emitter) cycle
          end if
          if (allocated (contributors%c)) then
             call check_for_phs_identifier (phs_identifiers, &
                emitter, contributors%c, phs_exist = phs_exist, i_phs = i_phs) 
          else
             call check_for_phs_identifier (phs_identifiers, &
                emitter, phs_exist = phs_exist, i_phs = i_phs)
          end if
          if (.not. phs_exist) &
             call msg_fatal ("phs identifiers are not set up correctly!")
          nlo_controller%real_kinematics%alr_to_i_phs(alr) = i_phs
       end associate
       if (allocated (contributors%c)) deallocate (contributors%c)
    end do
  end subroutine nlo_controller_set_alr_to_i_phs

@ %def nlo_controller_set_alr_to_i_phs
@                
\subsection{Putting it together}
<<nlo data: public>>=
  public :: nlo_settings_t
<<nlo data: types>>=
  type :: nlo_settings_t
     logical :: use_internal_color_correlations = .true.
     logical :: use_internal_spin_correlations = .false.
     logical :: use_resonance_mappings = .false.
     logical :: combined_integration = .false.
     logical :: test_soft_limit = .false.
     logical :: test_coll_limit = .false.
     integer :: fixed_alr = -1
     integer :: factorization_mode = NO_FACTORIZATION
  contains
  <<nlo data: nlo settings: TBP>>
  end type nlo_settings_t

@ %def nlo_settings_t
@
<<nlo data: public>>=
  public :: nlo_particle_data_t
<<nlo data: types>>=
  type :: nlo_particle_data_t
    integer :: n_in
    integer :: n_out_born, n_out_real
    integer :: n_flv_born, n_flv_real
  end type nlo_particle_data_t

@ %def nlo_particle_data_t
@
<<nlo data: public>>=
  public :: nlo_states_t
<<nlo data: types>>=
  type :: nlo_states_t
    integer, dimension(:,:), allocatable :: flv_state_born
    integer, dimension(:,:), allocatable :: flv_state_real
    integer, dimension(:), allocatable :: flv_born
    integer, dimension(:), allocatable :: hel_born
    integer, dimension(:), allocatable :: col_born
  end type nlo_states_t

@ %def nlo_states_t
@
<<nlo data: public>>=
  public :: sqme_collector_t
<<nlo data: types>>=
  type :: sqme_collector_t
    real(default) :: current_sqme_real
    real(default), dimension(:,:), allocatable :: sqme_real_per_phs
    real(default), dimension(:,:), allocatable :: sqme_real_non_sub
    real(default), dimension(:,:,:), allocatable :: sqme_born_cc
    complex(default), dimension(:), allocatable :: sqme_born_sc
    real(default) :: sqme_real_sum
    real(default), dimension(:), allocatable :: sqme_born_list
    real(default), dimension(:), allocatable :: sqme_subtraction_born_list
    real(default), dimension(:,:), allocatable :: sqme_virt_born_list
    real(default), dimension(:,:), allocatable :: sqme_virt_list
    real(default) :: sqme_mismatch
  contains
  <<nlo data: sqme collector: TBP>>
  end type sqme_collector_t

@ %def sqme_collector_t
@
<<nlo data: public>>=
  public :: nlo_cuts_t
<<nlo data: types>>=
  type :: nlo_cuts_t
    logical :: passed_born
    logical, dimension(:), allocatable :: passed_real
  end type nlo_cuts_t

@ %def nlo_cuts_t
@
<<nlo data: sqme collector: TBP>>=
  procedure :: get_sqme_sum => sqme_collector_get_sqme_sum
<<nlo data: procedures>>=
  function sqme_collector_get_sqme_sum (collector) result (sqme)
    class(sqme_collector_t), intent(in) :: collector
    real(default) :: sqme
    sqme = sum (collector%sqme_born_list) + &
           collector%sqme_real_sum + &
           sum (collector%sqme_virt_list) + &
           collector%sqme_mismatch
    if (debug2_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "Get content of sqme lists: ")
       call collector%write ()
       print *, 'Sum: ', sqme
    end if
  end function sqme_collector_get_sqme_sum

@ %def sqme_collector_get_sqme_sum
@
<<nlo data: sqme collector: TBP>>=
  procedure :: get_sqme_born => sqme_collector_get_sqme_born
<<nlo data: procedures>>=
  function sqme_collector_get_sqme_born (collector, i_flv) result (sqme)
    real(default) :: sqme
    class(sqme_collector_t), intent(in) :: collector
    integer, intent(in) :: i_flv
    sqme = collector%sqme_born_list (i_flv)
  end function sqme_collector_get_sqme_born

@ %def sqme_collector_get_sqme_born
@
<<nlo data: sqme collector: TBP>>=
  procedure :: reset => sqme_collector_reset
<<nlo data: procedures>>=
  subroutine sqme_collector_reset (collector)
    class(sqme_collector_t), intent(inout) :: collector
       collector%sqme_born_list = zero
       collector%sqme_real_sum = zero
       collector%sqme_virt_list = zero
       collector%sqme_mismatch = zero
  end subroutine sqme_collector_reset

@ %def sqme_collector_reset
@
<<nlo data: sqme collector: TBP>>=
  procedure :: write => sqme_collector_write
<<nlo data: procedures>>=
  subroutine sqme_collector_write (collector)
    class(sqme_collector_t), intent(in) :: collector
    print *, 'Born: ', collector%sqme_born_list 
    print *, 'Real: ', collector%sqme_real_sum
    print *, 'Virt: ', collector%sqme_virt_list
    print *, 'Mismatch: ', collector%sqme_mismatch
  end subroutine sqme_collector_write

@ %def sqme_collector_write
@
<<nlo controller: types>>=
  type :: polarization_data_t
    logical :: valid = .false.
    real(default) :: value = zero
    integer, dimension(:), allocatable :: h
    !!real(default), dimension(:), allocatable :: pmatrix_diag
  contains
  <<nlo controller: polarization data: TBP>>
  end type polarization_data_t

@ %def polarization_data_t
@
<<nlo controller: public operators>>=
  public :: operator(*)
<<nlo controller: interfaces>>=
  interface operator(*)
     module procedure polarization_data_multiply
  end interface

@ %def multipliy_interface
@
<<nlo controller: procedures>>=
  function polarization_data_multiply (p1, p2) result (prod)
    real(default) :: prod
    type(polarization_data_t), dimension(:), intent(in) :: p1, p2
    integer :: i, j
    prod = zero
    do i = 1, size (p1)
       do j = 1, size (p2)
          if (all (p1(i)%h == p2(j)%h)) then
             prod = prod + p1(i)%value * p2(j)%value
             exit
          end if
       end do
    end do
  end function polarization_data_multiply

@ %def polarization_data_multiply
@
<<nlo controller: polarization data: TBP>>=
  procedure :: set_helicities => polarization_data_set_helicities
<<nlo controller: procedures>>=
  subroutine polarization_data_set_helicities (pol_data, h)
    class(polarization_data_t), intent(inout) :: pol_data
    integer, dimension(:), intent(in) :: h
    integer :: i
    pol_data%h = h
    if (size (pol_data%h) == 2)  pol_data%h(2) = - pol_data%h(2) !!! why?
    pol_data%valid = .true.
    do i = 1, size (pol_data%h)
       pol_data%valid = pol_data%valid .and. &
                (pol_data%h(i) == 1 .or. pol_data%h(i) == -1)
    end do
  end subroutine polarization_data_set_helicities

@ %def polarization_data_init_helicities
@
<<nlo controller: polarization data: TBP>>=
  procedure :: set_value => polarization_data_set_value
<<nlo controller: procedures>>=
  subroutine polarization_data_set_value (pol_data, value)
     class(polarization_data_t), intent(inout) :: pol_data
     real(default), intent(in) :: value
     pol_data%value = value
  end subroutine polarization_data_set_value

@ %def polarization_data_set_value
@
<<nlo controller: polarization data: TBP>>=
  procedure :: is_active => polarization_data_is_valid
<<nlo controller: procedures>>=
  elemental function polarization_data_is_valid (pol_data) result (valid)
    logical :: valid
    class(polarization_data_t), intent(in) :: pol_data
    valid = pol_data%valid
  end function polarization_data_is_valid

@ %def polarization_data_is_valid
@
<<nlo controller: polarization data: TBP>>=
  procedure :: write => polarization_data_write
<<nlo controller: procedures>>=
  subroutine polarization_data_write (pol_data, unit)
    class(polarization_data_t), intent(in) :: pol_data
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(A,1x,L1)") "valid: ", pol_data%valid
    write (u, "(A,1x,F7.5)") "value: ", pol_data%value
    if (allocated (pol_data%h)) then
       write (u, "(A,1x)") "helicities: "
       do i = 1, size(pol_data%h)
          write (u, "(I0,1x)") pol_data%h(i)
       end do
    else
       write (u, "(A,1x)") "no helicities allocated "
    end if
  end subroutine polarization_data_write

@ %def polarization_data_write
@ This data type governs the whole calculation. It contains information
about color, spin and flavor as well as the information about the Born
process.
<<nlo controller: public>>=
  public :: nlo_controller_t
<<nlo controller: types>>=
  type :: nlo_controller_t
    logical :: needs_initialization = .true.
    type(region_data_t) :: reg_data
    type(nlo_particle_data_t) :: particle_data
    type(nlo_states_t) :: particle_states
    type(nlo_settings_t) :: settings
    type(sqme_collector_t), pointer :: sqme_collector => null ()
    type(polarization_data_t), dimension(:), allocatable :: pol_density_matrix
    type(polarization_data_t), dimension(:), allocatable :: pol_sqme
    integer :: n_allowed_born
    integer :: active_emitter, active_phase_space
    integer :: active_flavor_structure_real
    complex(default), dimension(:), allocatable :: amp_born
    type(color_data_t) :: color_data
    type(real_kinematics_t), pointer :: real_kinematics => null()
    type(isr_kinematics_t), pointer :: isr_kinematics => null()
    type(virtual_t) :: virtual_terms
    type(real_subtraction_t) :: real_terms
    type(soft_mismatch_t) :: soft_mismatch
    type(pdf_subtraction_t) :: pdf_terms
    real(default) :: alpha_s_born
    logical :: alpha_s_born_set
    complex(default) :: me_sc
    type(interaction_t), public :: int_born
    type(sf_chain_instance_t), pointer :: sf_born => null ()
    type(kinematics_counter_t), public :: counter
    logical, public :: counter_active = .false.
    class(powheg_damping_t), allocatable :: powheg_damping
    type(nlo_cuts_t) :: nlo_cuts
  contains
  <<nlo controller: nlo controller: TBP>>
  end type nlo_controller_t

@ %def nlo_controller_t
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init => nlo_controller_init
<<nlo controller: procedures>>=
  subroutine nlo_controller_init (nlo_controller, prc_constants, template, &
     phs_config, model)
     class(nlo_controller_t), intent(inout), target :: nlo_controller
     type(process_constants_t), intent(in), dimension(2) :: prc_constants
     type(fks_template_t), intent(inout) :: template
     !!! intent(inout) because the phase space might have to be generated new
     class(phs_config_t), intent(inout) :: phs_config
     type(model_data_t), intent(in) :: model
     integer :: n_in, n_tot_born, n_tot_real
     call msg_debug (D_SUBTRACTION, "nlo_controller_init")
     call nlo_controller%set_flv_states (prc_constants)
     call nlo_controller%set_particle_data (prc_constants)
     call nlo_controller%init_region_and_color_data (template, model, &
        prc_constants, phs_config)
     call nlo_controller%setup_matrix_elements ()
     nlo_controller%alpha_s_born_set = .false.
     call nlo_controller%init_real_and_isr_kinematics ()
     associate (particle_data => nlo_controller%particle_data)
        n_in = particle_data%n_in
        n_tot_born = n_in + particle_data%n_out_born
        n_tot_real = n_in + particle_data%n_out_real

        allocate (nlo_controller%nlo_cuts%passed_real (nlo_controller%reg_data%n_phs))
        nlo_controller%nlo_cuts%passed_real = .true.
        nlo_controller%nlo_cuts%passed_born = .true.

        call nlo_controller%init_real_subtraction (n_in, n_tot_born, n_tot_real)
        if (template%subtraction_disabled) call nlo_controller%disable_subtraction ()
        call nlo_controller%soft_mismatch%init (n_in, n_tot_born, nlo_controller%reg_data, &
           nlo_controller%sqme_collector, nlo_controller%real_kinematics)
     end associate
     nlo_controller%counter_active = template%count_kinematics
     if (nlo_controller%counter_active) call nlo_controller%counter%init(20)
     allocate (powheg_damping_simple_t :: nlo_controller%powheg_damping)
  end subroutine nlo_controller_init

@ %def nlo_controller_init
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: check_if_threshold_method => nlo_controller_check_if_threshold_method
<<nlo controller: procedures>>=
  subroutine nlo_controller_check_if_threshold_method (nlo_controller, core)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    class(prc_core_t), intent(in) :: core
    select type (core)
    type is (prc_threshold_t)
       nlo_controller%settings%factorization_mode = FACTORIZATION_THRESHOLD
    end select
  end subroutine nlo_controller_check_if_threshold_method

@ %def nlo_controller_check_if_threshold_method
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_pol_density_matrix => nlo_controller_init_pol_density_matrix
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_pol_density_matrix (nlo_controller, n_entries)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer :: n_entries
    allocate (nlo_controller%pol_density_matrix (n_entries))
  end subroutine nlo_controller_init_pol_density_matrix

@ %def nlo_controller_init_pol_density_matrix
@ Anti-particles need to have an opposite sign for the helicity index
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_polarized_sqmes => nlo_controller_init_polarized_sqmes
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_polarized_sqmes (nlo_controller, helicities)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in), dimension(:,:) :: helicities
    integer :: i_sqme, n_sqme
    integer, dimension(size(helicities, dim=2)) :: h
    integer, dimension(size(helicities, dim=2)) :: flavor_sign

    associate (flv => nlo_controller%particle_states%flv_state_born (:,1))
       flavor_sign(:) = sign (1, flv(1:size(flavor_sign)))
    end associate

    n_sqme = size (helicities, dim=1)
    allocate (nlo_controller%pol_sqme (n_sqme))
    associate (pol_sqme => nlo_controller%pol_sqme)
       do i_sqme = 1, n_sqme
          h = flavor_sign * helicities (i_sqme, :)
          call pol_sqme(i_sqme)%set_helicities (h)
       end do
    end associate
  end subroutine nlo_controller_init_polarized_sqmes

@ %def nlo_controller_init_polarized_sqmes
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: beams_are_polarized => nlo_controller_beams_are_polarized
<<nlo controller: procedures>>=
  elemental function nlo_controller_beams_are_polarized (nlo_controller) result (val)
    logical :: val
    class(nlo_controller_t), intent(in) :: nlo_controller
    val = allocated (nlo_controller%pol_density_matrix)
  end function nlo_controller_beams_are_polarized

@ %def nlo_controller_beams_are_polarized
@ This subroutine combines the outer product of the spin density
matrices with the polarized matrix elements. Note that there is a factor
of four to account for the fact that \texttt{OpenLoops} supplies the
averaging factor $1/4$ regardless whether the matrix elements are
polarized or not.
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_weighted_helicity_sum => nlo_controller_get_weighted_helicity_sum
<<nlo controller: procedures>>=
  function nlo_controller_get_weighted_helicity_sum (nlo_controller) result (sqme)
     real(default) :: sqme
     class(nlo_controller_t), intent(in) :: nlo_controller
     sqme = four * (nlo_controller%pol_sqme * nlo_controller%pol_density_matrix)
  end function nlo_controller_get_weighted_helicity_sum

@ %def nlo_controller_get_weighted_helicity_sum
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_real_subtraction => nlo_controller_init_real_subtraction
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_real_subtraction (nlo_controller, &
     n_in, n_tot_born, n_tot_real)
    class(nlo_controller_t), intent(inout), target :: nlo_controller
    integer, intent(in) :: n_in, n_tot_born, n_tot_real
    call nlo_controller%real_terms%init (nlo_controller%reg_data, &
       n_in, n_tot_born, n_tot_real, nlo_controller%sqme_collector, &
       nlo_controller%nlo_cuts)
    call nlo_controller%real_terms%set_resonance_mappings &
       (nlo_controller%settings%use_resonance_mappings)
    associate (settings => nlo_controller%settings)
       nlo_controller%real_terms%test_limit = &
          settings%test_soft_limit .or. settings%test_coll_limit
       nlo_controller%real_terms%fixed_alr = settings%fixed_alr
       nlo_controller%real_terms%sub_soft%factorization_mode &
          = settings%factorization_mode
    end associate
  end subroutine nlo_controller_init_real_subtraction

@ %def nlo_controller_init_real_subtraction
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_flv_states => nlo_controller_set_flv_states
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_flv_states (nlo_controller, prc_constants)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    associate (states => nlo_controller%particle_states)
      allocate (states%flv_state_born &
           (size (prc_constants(1)%get_flv_state (), 1), &
            size (prc_constants(1)%get_flv_state (), 2)))
      allocate (states%flv_state_real &
           (size (prc_constants(2)%get_flv_state (), 1), &
            size (prc_constants(2)%get_flv_state (), 2)))
      states%flv_state_born = prc_constants(1)%get_flv_state ()
      states%flv_state_real = prc_constants(2)%get_flv_state ()
    end associate
  end subroutine nlo_controller_set_flv_states

@ %def nlo_controller_set_flv_states
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_flv_state_real => nlo_controller_get_flv_state_real
<<nlo controller: procedures>>=
  function nlo_controller_get_flv_state_real (nlo_controller, i_uborn) result (flv_state)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i_uborn
    integer, dimension(:), allocatable :: flv_state
    allocate (flv_state (size (nlo_controller%particle_states%flv_state_real (:,i_uborn))))
    flv_state = nlo_controller%particle_states%flv_state_real (:,i_uborn)
  end function nlo_controller_get_flv_state_real

@ %def nlo_controller_get_flv_state_real
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_particle_data => nlo_controller_set_particle_data
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_particle_data (nlo_controller, prc_constants)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    associate (particle_data => nlo_controller%particle_data)
       particle_data%n_flv_born = size (nlo_controller%particle_states%flv_state_born(1,:))
       particle_data%n_flv_real = size (nlo_controller%particle_states%flv_state_real(1,:))
       particle_data%n_in = prc_constants(2)%n_in
       particle_data%n_out_born = prc_constants(1)%n_out
       particle_data%n_out_real = prc_constants(2)%n_out
    end associate
  end subroutine nlo_controller_set_particle_data

@ %def nlo_controller_set_particle_data
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: setup_matrix_elements => nlo_controller_setup_matrix_elements
<<nlo controller: procedures>>=
  subroutine nlo_controller_setup_matrix_elements (nlo_controller, n_hel)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in), optional :: n_hel
    integer :: n_tot_born
    associate (collector => nlo_controller%sqme_collector, &
         particle_data => nlo_controller%particle_data)
      if (present (n_hel)) then
         allocate (collector%sqme_virt_born_list (particle_data%n_flv_born, n_hel))
         allocate (collector%sqme_virt_list (particle_data%n_flv_born, n_hel))
      else
         allocate (collector%sqme_virt_born_list (particle_data%n_flv_born, 1))
         allocate (collector%sqme_virt_list (particle_data%n_flv_born, 1))
      end if
      allocate (collector%sqme_born_list (particle_data%n_flv_born))
      allocate (collector%sqme_subtraction_born_list (particle_data%n_flv_born))
      allocate (collector%sqme_real_non_sub (particle_data%n_flv_real, &
         nlo_controller%reg_data%n_phs))
      allocate (collector%sqme_real_per_phs &
         (nlo_controller%reg_data%n_flv_real, nlo_controller%reg_data%n_phs))
      n_tot_born = particle_data%n_in + particle_data%n_out_born
      allocate (collector%sqme_born_cc (n_tot_born, n_tot_born, particle_data%n_flv_born))
      allocate (collector%sqme_born_sc (particle_data%n_flv_born))
      collector%sqme_born_list = zero
      collector%sqme_subtraction_born_list = zero
      collector%sqme_real_non_sub = zero
      collector%sqme_real_per_phs = zero
      collector%sqme_born_cc = zero
      collector%sqme_born_sc = cmplx (zero, zero, kind=default)
      collector%current_sqme_real = zero
      collector%sqme_real_sum = zero
      collector%sqme_virt_born_list = zero
      collector%sqme_virt_list = zero
      collector%sqme_mismatch = zero
    end associate
  end subroutine nlo_controller_setup_matrix_elements

@ %def nlo_controller_setup_matrix_elements
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: setup_generator => nlo_controller_setup_generator
<<nlo controller: procedures>>=
  subroutine nlo_controller_setup_generator &
         (nlo_controller, generator, sqrts, singular_jacobian, mode)
    class(nlo_controller_t), intent(in) :: nlo_controller
    type(phs_fks_generator_t), intent(out) :: generator
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: singular_jacobian
    integer, intent(in), optional :: mode
    logical :: yorn
    yorn = .false.; if (present (singular_jacobian)) yorn = singular_jacobian
    call generator%connect_kinematics (nlo_controller%isr_kinematics, &
       nlo_controller%real_kinematics, &
       nlo_controller%has_massive_emitter ())
    generator%n_in = nlo_controller%particle_data%n_in
    call generator%set_beam_energy (sqrts)
    call generator%set_emitters (nlo_controller%reg_data%emitters)
    call generator%setup_masses (nlo_controller%particle_data%n_in + &
       nlo_controller%particle_data%n_out_born)
    generator%is_massive = nlo_controller%get_mass_info(1)
    generator%singular_jacobian = yorn
    if (present (mode)) generator%mode = mode
  end subroutine nlo_controller_setup_generator

@ %def nlo_controller_setup_generator
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_particles_real => nlo_controller_get_n_particles_real
<<nlo controller: procedures>>=
  pure function nlo_controller_get_n_particles_real (nlo_controller) result (n_particles)
    integer :: n_particles
    class(nlo_controller_t), intent(in) :: nlo_controller
    n_particles = nlo_controller%particle_data%n_in + nlo_controller%particle_data%n_out_real
  end function nlo_controller_get_n_particles_real

@ %def nlo_controller_get_n_particles_real
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_particles => nlo_controller_get_n_particles
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_n_particles (nlo_controller) result (n)
    integer :: n
    class(nlo_controller_t), intent(in) :: nlo_controller
    associate (particle_data => nlo_controller%particle_data)
       n = particle_data%n_in + particle_data%n_out_born
    end associate
  end function nlo_controller_get_n_particles

@ %def nlo_controller_get_n_particles
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_flv_born => nlo_controller_get_n_flv_born
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_n_flv_born (nlo_controller) result (n_flv)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer :: n_flv
    n_flv = nlo_controller%particle_data%n_flv_born
  end function nlo_controller_get_n_flv_born

@ %def nlo_controller_get_n_flv_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_flv_real => nlo_controller_get_n_flv_real
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_n_flv_real (nlo_controller) result (n_flv)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer :: n_flv
    n_flv = nlo_controller%particle_data%n_flv_real
  end function nlo_controller_get_n_flv_real

@ %def nlo_controller_get_n_flv_real
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_alr => nlo_controller_get_n_alr
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_n_alr (nlo_controller) result (n_alr)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer :: n_alr
    n_alr = nlo_controller%reg_data%n_regions
  end function nlo_controller_get_n_alr

@ %def nlo_controller_get_n_alr
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_in => nlo_controller_get_n_in
<<nlo controller: procedures>>=
  function nlo_controller_get_n_in (controller) result (n_in)
    integer :: n_in
    class(nlo_controller_t), intent(in) :: controller
    n_in = controller%particle_data%n_in
  end function nlo_controller_get_n_in

@ %def nlo_controller_get_n_in
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_n_res => nlo_controller_get_n_res
<<nlo controller: procedures>>=
  function nlo_controller_get_n_res (nlo_controller, emitter) result (n_res)
    integer :: n_res
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in), optional :: emitter
    integer :: em
    integer, dimension(:), allocatable :: resonances
    if (present (emitter)) then
       em = emitter
    else
       em = nlo_controller%get_active_emitter ()
    end if
    if (nlo_controller%settings%use_resonance_mappings) &
       resonances = nlo_controller%reg_data%get_associated_resonances (em)
    if (allocated (resonances)) then
       n_res = size (resonances)
    else
       n_res = 1
    end if
  end function nlo_controller_get_n_res

@ %def nlo_controller_get_n_res
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_region_and_color_data &
     => nlo_controller_init_region_and_color_data
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_region_and_color_data (nlo_controller, &
     template, model, prc_constants, phs_config)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(fks_template_t), intent(inout) :: template
    type(model_data_t), intent(in) :: model
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    class(phs_config_t), intent(inout) :: phs_config
    type(resonance_history_t), dimension(:), allocatable :: resonance_histories
    type(resonance_history_t), dimension(:), allocatable :: resonance_histories_clean
    logical :: success
    integer :: mapping_type
    mapping_type = template%mapping_type
    select case (mapping_type)
    case (FKS_RESONANCES) 
       select type (phs_config)
       type is (phs_fks_config_t)
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
	  select case (nlo_controller%settings%factorization_mode)
          case (NO_FACTORIZATION)
             allocate (resonance_histories (size (phs_config%get_resonance_histories ())))          
             resonance_histories = phs_config%get_resonance_histories ()
             call clean_resonance_histories (resonance_histories, &
                nlo_controller%particle_data%n_in, &
                nlo_controller%particle_states%flv_state_born (:,1), &
                resonance_histories_clean, success)
             if (.not. success) &
                template%mapping_type = FKS_DEFAULT
          case (FACTORIZATION_THRESHOLD)
             allocate (resonance_histories_clean (1))
             resonance_histories_clean = create_resonance_histories_for_threshold ()
          end select
       end select
    end select
    call nlo_controller%init_region_data (template, model)
    if (nlo_controller%settings%use_internal_color_correlations) &
       call nlo_controller%color_data%init (nlo_controller%reg_data, &
          prc_constants, nlo_controller%settings%factorization_mode)
    select case (template%mapping_type)
    case (FKS_RESONANCES)
       call nlo_controller%init_resonance_info (resonance_histories_clean)
       nlo_controller%settings%use_resonance_mappings = .true.
    end select
    call nlo_controller%reg_data%compute_number_of_phase_spaces ()
    call nlo_controller%reg_data%write_to_file (template%id)
  end subroutine nlo_controller_init_region_and_color_data

@ %def nlo_controller_init_region_and_color_data
@
<<nlo controller: procedures>>=
  subroutine clean_resonance_histories (res_hist, n_in, flv, res_hist_clean, success)
    type(resonance_history_t), intent(in), dimension(:) :: res_hist
    integer, intent(in) :: n_in
    integer, intent(in), dimension(:) :: flv
    type(resonance_history_t), intent(out), dimension(:), allocatable :: res_hist_clean
    logical, intent(out) :: success
    integer :: i_hist
    type(resonance_history_t), dimension(:), allocatable :: res_hist_colored, res_hist_contracted

    call msg_debug (D_SUBTRACTION, "resonance_mapping_init")
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "Original resonances:")
       do i_hist = 1, size(res_hist)
          call res_hist(i_hist)%write ()
       end do
    end if

    call remove_uncolored_resonances ()
    call contract_resonances (res_hist_colored, res_hist_contracted)
    call remove_subresonances (res_hist_contracted, res_hist_clean)
    !!! Here, we are still not sure whether we actually would rather use 
    !!! call remove_multiple_resonances (res_hist_contracted, res_hist_clean)
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "Resonances after removing uncolored and duplicates: ")
       do i_hist = 1, size (res_hist_clean)
          call res_hist_clean(i_hist)%write ()
       end do
    end if
    if (size (res_hist_clean) == 0) then
       call msg_warning ("No resonances found. Proceed in usual FKS mode.")
       success = .false.
    else
       success = .true.
    end if

  contains
    subroutine remove_uncolored_resonances ()
      type(resonance_history_t), dimension(:), allocatable :: res_hist_tmp
      integer :: n_hist, nleg_out, n_removed
      integer :: i_res, i_hist
      n_hist = size (res_hist)
      nleg_out = size (flv) - n_in
      allocate (res_hist_tmp (n_hist))
      allocate (res_hist_colored (n_hist))
      do i_hist = 1, n_hist
         res_hist_tmp(i_hist) = res_hist(i_hist)
         call res_hist_tmp(i_hist)%add_offset (n_in)
         n_removed = 0
         do i_res = 1, res_hist_tmp(i_hist)%n_resonances
            associate (resonance => res_hist_tmp(i_hist)%resonances(i_res - n_removed))
               if (.not. any (is_colored (flv (resonance%contributors%c))) &
                  .or. size (resonance%contributors%c) == nleg_out) then
                     call res_hist_tmp(i_hist)%remove_resonance (i_res - n_removed)
                     n_removed = n_removed + 1
               end if
            end associate
         end do
         if (allocated (res_hist_tmp(i_hist)%resonances)) then
            if (any (res_hist_colored == res_hist_tmp(i_hist))) then
               cycle
            else
               do i_res = 1, res_hist_tmp(i_hist)%n_resonances
                  associate (resonance => res_hist_tmp(i_hist)%resonances(i_res))
                     call res_hist_colored(i_hist)%add_resonance (resonance)
                  end associate
               end do
            end if
         end if
      end do
    end subroutine remove_uncolored_resonances

    subroutine contract_resonances (res_history_in, res_history_out)
      type(resonance_history_t), intent(in), dimension(:) :: res_history_in
      type(resonance_history_t), intent(out), dimension(:), allocatable :: res_history_out
      logical, dimension(:), allocatable :: i_non_zero
      integer :: n_hist_non_zero, n_hist
      integer :: i_hist_new
      n_hist = size (res_history_in); n_hist_non_zero = 0
      allocate (i_non_zero (n_hist))
      i_non_zero = .false.
      do i_hist = 1, n_hist
         if (res_history_in(i_hist)%n_resonances /= 0) then
            n_hist_non_zero = n_hist_non_zero + 1
            i_non_zero(i_hist) = .true.
         end if
      end do
      allocate (res_history_out (n_hist_non_zero))
      i_hist_new = 1
      do i_hist = 1, n_hist
         if (i_non_zero (i_hist)) then
            res_history_out (i_hist_new) = res_history_in (i_hist)
            i_hist_new = i_hist_new + 1
         end if
      end do
    end subroutine contract_resonances

    subroutine remove_subresonances (res_history_in, res_history_out)
      type(resonance_history_t), intent(in), dimension(:) :: res_history_in
      type(resonance_history_t), intent(out), dimension(:), allocatable :: res_history_out
      logical, dimension(:), allocatable :: i_non_sub_res
      integer :: n_hist, n_hist_non_sub_res
      integer :: i_hist1, i_hist2
      logical :: is_not_subres
      n_hist = size (res_history_in); n_hist_non_sub_res = 0
      allocate (i_non_sub_res (n_hist)); i_non_sub_res = .false.
      do i_hist1 = 1, n_hist
         is_not_subres = .true.
         do i_hist2 = 1, n_hist
            if (i_hist1 == i_hist2) cycle
            is_not_subres = is_not_subres .and. &
               .not. res_history_in (i_hist2) > res_history_in (i_hist1)
         end do
         if (is_not_subres) then
            n_hist_non_sub_res = n_hist_non_sub_res + 1
            i_non_sub_res (i_hist1) = .true.
         end if
      end do

      allocate (res_history_out (n_hist_non_sub_res))
      i_hist2 = 1
      do i_hist1 = 1, n_hist
         if (i_non_sub_res (i_hist1)) then
            res_history_out (i_hist2) = res_history_in (i_hist1)
            i_hist2 = i_hist2 + 1
         end if
      end do
    end subroutine remove_subresonances

    subroutine remove_multiple_resonances (res_history_in, res_history_out)
      type(resonance_history_t), intent(in), dimension(:) :: res_history_in
      type(resonance_history_t), intent(out), dimension(:), allocatable :: res_history_out
      integer :: n_hist, n_hist_single
      logical, dimension(:), allocatable :: i_hist_single
      integer :: i_hist, j
      n_hist = size (res_history_in)
      n_hist_single = 0
      allocate (i_hist_single (n_hist)); i_hist_single = .false.
      do i_hist = 1, n_hist
         if (res_history_in(i_hist)%n_resonances == 1) then
            n_hist_single = n_hist_single + 1 
            i_hist_single(i_hist) = .true.
         end if
      end do
  
      allocate (res_history_out (n_hist_single))
      j = 1
      do i_hist = 1, n_hist
         if (i_hist_single(i_hist)) then
            res_history_out(j) = res_history_in(i_hist)
            j = j + 1
         end if
      end do
    end subroutine remove_multiple_resonances 
  end subroutine clean_resonance_histories

@ %def clean_resonance_histories
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_region_data => nlo_controller_init_region_data
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_region_data (nlo_controller, template, &
     model)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(fks_template_t), intent(in) :: template
    type(model_data_t), intent(in) :: model
    integer :: n_in
    call msg_debug (D_SUBTRACTION, "nlo_controller_init_region_data")
    n_in = nlo_controller%particle_data%n_in
    call nlo_controller%reg_data%allocate_fks_mappings (template%mapping_type)

    select type (map => nlo_controller%reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       call map%set_parameter (n_in, template%fks_dij_exp1, template%fks_dij_exp2)
    end select

    associate (states => nlo_controller%particle_states)
       call nlo_controller%reg_data%init (n_in, model, &
          states%flv_state_born, states%flv_state_real)
    end associate
  end subroutine nlo_controller_init_region_data

@ %def nlo_controller_init_region_data
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_resonance_info => nlo_controller_init_resonance_info
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_resonance_info (nlo_controller, resonance_histories)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(resonance_history_t), intent(in), dimension(:) :: resonance_histories
    select type (map => nlo_controller%reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       call map%res_map%init (resonance_histories)
    end select
    call nlo_controller%reg_data%init_resonance_information &
       (nlo_controller%settings%factorization_mode)
  end subroutine nlo_controller_init_resonance_info

@ %def nlo_controller_init_resonance_info
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_xi_max => nlo_controller_get_xi_max
<<nlo controller: procedures>>=
  function nlo_controller_get_xi_max (nlo_controller, alr) result (xi_max)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: alr
    real(default) :: xi_max
    integer :: i_phs
    i_phs = nlo_controller%real_kinematics%alr_to_i_phs (alr)
    xi_max = nlo_controller%real_kinematics%xi_max (i_phs)
  end function nlo_controller_get_xi_max

@ %def nlo_controller_get_xi_max
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_born_amps => nlo_controller_init_born_amps
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_born_amps (nlo_controller, n)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in) :: n
    nlo_controller%n_allowed_born = n
    if (.not. allocated (nlo_controller%amp_born)) &
       allocate (nlo_controller%amp_born (n))
  end subroutine nlo_controller_init_born_amps

@ %def nlo_controller_init_born_amps
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_internal_procedures => nlo_controller_set_internal_procedures
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_internal_procedures (nlo_controller, flag_color, flag_spin)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    logical, intent(in) :: flag_color, flag_spin
    nlo_controller%settings%use_internal_color_correlations = flag_color
    nlo_controller%real_terms%sub_soft%use_internal_color_correlations = flag_color
    nlo_controller%virtual_terms%use_internal_color_correlations = flag_color
    nlo_controller%settings%use_internal_spin_correlations = flag_spin
  end subroutine nlo_controller_set_internal_procedures

@ %def nlo_controller_set_internal_procedures
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_x_rad => nlo_controller_set_x_rad
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_x_rad (controller, x_rad)
    class(nlo_controller_t), intent(inout) :: controller
    real(default), intent(in), dimension(:) :: x_rad
    integer :: n_par
    n_par = size (x_rad)
    if (associated (controller%real_kinematics)) &
       controller%real_kinematics%x_rad = x_rad (n_par-2:n_par)
  end subroutine nlo_controller_set_x_rad

@ %def nlo_controller_set_x_rad
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_virtual => nlo_controller_init_virtual
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_virtual (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    call nlo_controller%virtual_terms%init (nlo_controller%particle_states%flv_state_born, &
       nlo_controller%particle_data%n_in)
    nlo_controller%virtual_terms%factorization_mode &
       = nlo_controller%settings%factorization_mode
  end subroutine nlo_controller_init_virtual

@ %def nlo_controller_init_virtual
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_pdf_subtraction => nlo_controller_init_pdf_subtraction
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_pdf_subtraction (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    call nlo_controller%pdf_terms%init (nlo_controller%isr_kinematics, &
       nlo_controller%particle_states%flv_state_born, &
       nlo_controller%reg_data%n_regions, nlo_controller%sqme_collector)
  end subroutine nlo_controller_init_pdf_subtraction

@ %def nlo_controller_init_pdf_subtraction
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: pdf_subtraction_is_required => nlo_controller_pdf_subtraction_is_required
<<nlo controller: procedures>>=
  function nlo_controller_pdf_subtraction_is_required (nlo_controller) result (required)
    class(nlo_controller_t), intent(in) :: nlo_controller
    logical :: required
    required = nlo_controller%pdf_terms%required
  end function nlo_controller_pdf_subtraction_is_required

@ %def nlo_controller_pdf_subtraction_is_required
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: evaluate_pdf_subtraction => nlo_controller_evaluate_pdf_subtraction
<<nlo controller: procedures>>=
  subroutine nlo_controller_evaluate_pdf_subtraction (nlo_controller, sqme)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    real(default), intent(inout) :: sqme
    if (.not. nlo_controller%alpha_s_born_set) &
        call msg_fatal ("Strong coupling not set for pdf subtraction")
    call nlo_controller%pdf_terms%evaluate (nlo_controller%alpha_s_born, sqme, 1)
  end subroutine nlo_controller_evaluate_pdf_subtraction

@ %def evaluate_pdf_subtraction
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_emitter_list => nlo_controller_get_emitter_list
<<nlo controller: procedures>>=
  pure function nlo_controller_get_emitter_list (nlo_controller) result(emitters)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, dimension(:), allocatable :: emitters
    allocate (emitters (size (nlo_controller%reg_data%get_emitter_list ())))
    emitters = nlo_controller%reg_data%get_emitter_list ()
  end function nlo_controller_get_emitter_list

@ %def nlo_controller_get_emmiter_list
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_emitter => nlo_controller_get_emitter
<<nlo controller: procedures>>=
  pure function nlo_controller_get_emitter (nlo_controller, alr) result (emitter)
    integer :: emitter
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: alr
    emitter = nlo_controller%reg_data%get_emitter (alr)
  end function nlo_controller_get_emitter

@ %def nlo_controller_get_emitter
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_i_phs => nlo_controller_get_i_phs 
<<nlo controller: procedures>>=
  pure function nlo_controller_get_i_phs (nlo_controller, alr) result (i_phs)
    integer :: i_phs
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: alr
    i_phs = nlo_controller%real_kinematics%alr_to_i_phs (alr)
  end function nlo_controller_get_i_phs

@ %def nlo_controller_get_i_phs
@ 
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_active_emitter => nlo_controller_set_active_emitter
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_active_emitter (nlo_controller, emitter)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in) :: emitter
    nlo_controller%active_emitter = emitter
  end subroutine nlo_controller_set_active_emitter

@ %def nlo_controller_set_active_emitter
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_active_phase_space => nlo_controller_set_active_phase_space
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_active_phase_space (nlo_controller, i_phs)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in) :: i_phs
    nlo_controller%active_phase_space = i_phs
  end subroutine 

@ %def nlo_controller_set_active_phase_spac
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_active_emitter => nlo_controller_get_active_emitter
<<nlo controller: procedures>>=
  function nlo_controller_get_active_emitter (nlo_controller) result (emitter)
    integer :: emitter
    class(nlo_controller_t), intent(in) :: nlo_controller
    emitter = nlo_controller%active_emitter
  end function nlo_controller_get_active_emitter

@ %def nlo_controller_get_active_emitter
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_active_phase_space => nlo_controller_get_active_phase_space
<<nlo controller: procedures>>=
  function nlo_controller_get_active_phase_space (nlo_controller) result (i_phs)
    integer :: i_phs
    class(nlo_controller_t), intent(in) :: nlo_controller
    i_phs = nlo_controller%active_phase_space
  end function nlo_controller_get_active_phase_space

@ %def nlo_controller_get_active_phase_space
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: disable_subtraction => nlo_controller_disable_subtraction
  procedure :: enable_subtraction => nlo_controller_enable_subtraction
  procedure :: is_subtraction_active => nlo_controller_is_subtraction_active
<<nlo controller: procedures>>=
  subroutine nlo_controller_disable_subtraction (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%real_terms%radiation_active = .true.
    nlo_controller%real_terms%subtraction_active = .false.
  end subroutine nlo_controller_disable_subtraction

  subroutine nlo_controller_enable_subtraction (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%real_terms%subtraction_active = .true.
  end subroutine nlo_controller_enable_subtraction

  function nlo_controller_is_subtraction_active (nlo_controller) result (active)
    class(nlo_controller_t), intent(in) :: nlo_controller
    logical :: active
    active = nlo_controller%real_terms%subtraction_active
  end function nlo_controller_is_subtraction_active

@ %def nlo_controller_disable_subtraction
@ %def nlo_controller_enable_subtraction
@ %def nlo_controller_is_subtraction_active
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: disable_sqme_np1 => nlo_controller_disable_sqme_np1
<<nlo controller: procedures>>=
  subroutine nlo_controller_disable_sqme_np1 (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    nlo_controller%real_terms%radiation_active = .false.
    nlo_controller%real_terms%subtraction_active = .true.
  end subroutine nlo_controller_disable_sqme_np1

@ %def nlo_controller_disable_sqme_np1
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_alr => nlo_controller_set_alr
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_alr (nlo_controller, alr)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in) :: alr
    call nlo_controller%real_terms%set_alr (alr)
  end subroutine nlo_controller_set_alr

@ %def nlo_controller_set_alr
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_flv_born => nlo_controller_set_flv_born
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_flv_born (nlo_controller, flv_in)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in), dimension(:), allocatable :: flv_in
    associate (states => nlo_controller%particle_states)
       allocate (states%flv_born (size (flv_in)))
       states%flv_born = flv_in
    end associate
  end subroutine nlo_controller_set_flv_born

@ %def nlo_controller_set_flv_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_hel_born => nlo_controller_set_hel_born
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_hel_born (nlo_controller, hel_in)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in), dimension(:), allocatable :: hel_in
    associate (states => nlo_controller%particle_states)
       allocate (states%hel_born (size (hel_in)))
       states%hel_born = hel_in
    end associate
  end subroutine nlo_controller_set_hel_born

@ %def nlo_controller_set_hel_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_col_born => nlo_controller_set_col_born
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_col_born (nlo_controller, col_in)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in), dimension(:), allocatable :: col_in
    associate (states => nlo_controller%particle_states)
       allocate (states%col_born (size (col_in)))
       states%col_born = col_in
   end associate
  end subroutine nlo_controller_set_col_born

@ %def nlo_controller_set_col_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_flv_born => nlo_controller_get_flv_born
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_flv_born (nlo_controller, i) result  (flv)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i
    integer :: flv
    flv = nlo_controller%particle_states%flv_born(i)
  end function nlo_controller_get_flv_born

@ %def nlo_controller_get_flv_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_hel_born => nlo_controller_get_hel_born
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_hel_born (nlo_controller, i) result (hel)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i
    integer :: hel
    hel = nlo_controller%particle_states%hel_born (i)
  end function nlo_controller_get_hel_born

@ %def nlo_controller_get_hel_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_col_born => nlo_controller_get_col_born
<<nlo controller: procedures>>=
  elemental function nlo_controller_get_col_born (nlo_controller, i) result (col)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i
    integer :: col
    col = nlo_controller%particle_states%col_born (i)
  end function nlo_controller_get_col_born

@ %def nlo_controller_get_col_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_alpha_s_born => nlo_controller_set_alpha_s_born
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_alpha_s_born (nlo_controller, as_born)
    class (nlo_controller_t), intent(inout) :: nlo_controller
    real(default), intent(in) :: as_born
    call msg_debug2 (D_SUBTRACTION, &
         "nlo_controller_set_alpha_s_born: as_born", as_born)
    nlo_controller%alpha_s_born = as_born
    nlo_controller%alpha_s_born_set = .true.
  end subroutine nlo_controller_set_alpha_s_born

@ %def nlo_controller_set_alpha_s_born
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_real_and_isr_kinematics &
     => nlo_controller_init_real_and_isr_kinematics
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_real_and_isr_kinematics (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer :: n_tot, n_contr
    n_tot = nlo_controller%particle_data%n_in + &
            nlo_controller%particle_data%n_out_born
    allocate (nlo_controller%real_kinematics)
    allocate (nlo_controller%isr_kinematics)
    associate (reg_data => nlo_controller%reg_data)
       if (allocated (reg_data%alr_contributors)) then
          n_contr = size (reg_data%alr_contributors)
       else
          n_contr = 1
       end if
       call nlo_controller%real_kinematics%init (n_tot, &
          reg_data%n_phs, reg_data%n_regions, n_contr)
    end associate
    nlo_controller%isr_kinematics%n_in = nlo_controller%particle_data%n_in
  end subroutine nlo_controller_init_real_and_isr_kinematics

@ %def nlo_controller_init_real_and_isr_kinematics
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: init_isr_kinematics => nlo_controller_init_isr_kinematics
<<nlo controller: procedures>>=
  subroutine nlo_controller_init_isr_kinematics (nlo_controller)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    if (.not. associated (nlo_controller%isr_kinematics)) &
       allocate (nlo_controller%isr_kinematics)
   end subroutine nlo_controller_init_isr_kinematics

@ %def nlo_controller_init_isr_kinematics
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_real_kinematics => nlo_controller_set_real_kinematics
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_real_kinematics (nlo_controller, xi_tilde, &
     y, phi, xi_max, jac, jac_rand)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    real(default), dimension(:), allocatable :: xi_max, y
    real(default), intent(in) :: xi_tilde
    real(default), intent(in) :: phi
    real(default), intent(in), dimension(4) :: jac
    real(default), intent(in), dimension(:), allocatable :: jac_rand
    nlo_controller%real_kinematics%xi_tilde = xi_tilde
    nlo_controller%real_kinematics%y = y
    nlo_controller%real_kinematics%phi = phi
    nlo_controller%real_kinematics%xi_max = xi_max
    nlo_controller%real_kinematics%jac(1)%jac = jac
    nlo_controller%real_kinematics%jac_rand = jac_rand
  end subroutine nlo_controller_set_real_kinematics

@ %def nlo_controller_set_real_kinematics
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_momenta => nlo_controller_set_momenta
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_momenta (nlo_controller, p_born, p_real, i_phs, cms)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    type(vector4_t), dimension(:), intent(in) :: p_born, p_real
    integer, intent(in) :: i_phs
    logical, intent(in), optional :: cms
    logical :: yorn
    yorn = .false.; if (present (cms)) yorn = cms
    associate (kinematics => nlo_controller%real_kinematics)
       if (yorn) then
          if (.not. kinematics%p_born_cms%initialized) &
             call kinematics%p_born_cms%init (size (p_born), 1)
          if (.not. kinematics%p_real_cms%initialized) &
             call kinematics%p_real_cms%init (size (p_real), 1)
          kinematics%p_born_cms%phs_point(1)%p = p_born
          kinematics%p_real_cms%phs_point(i_phs)%p = p_real
       else
          if (.not. kinematics%p_born_lab%initialized) &
             call kinematics%p_born_lab%init (size (p_born), 1)
          if (.not. kinematics%p_real_lab%initialized) &
             call kinematics%p_real_lab%init (size (p_real), 1)
          kinematics%p_born_lab%phs_point(1)%p = p_born
          kinematics%p_real_lab%phs_point(i_phs)%p = p_real
       end if
    end associate
  end subroutine nlo_controller_set_momenta

@ %def nlo_controller_set_momenta
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: get_momenta => nlo_controller_get_momenta
<<nlo controller: procedures>>=
  function nlo_controller_get_momenta (nlo_controller, born_phsp, cms, i_phs) result (p)
    type(vector4_t), dimension(:), allocatable :: p
    class(nlo_controller_t), intent(inout) :: nlo_controller
    logical, intent(in) :: born_phsp
    integer, intent(in) :: i_phs
    logical, intent(in), optional :: cms
    logical :: yorn
    yorn = .false.; if (present (cms)) yorn = cms
    if (born_phsp) then
       if (yorn) then
          allocate (p (1 : nlo_controller%get_n_particles()), &
             source = nlo_controller%real_kinematics%p_born_cms%phs_point(1)%p)
       else
          allocate (p (1 : nlo_controller%get_n_particles()), &
             source = nlo_controller%real_kinematics%p_born_lab%phs_point(1)%p)
       end if
    else
       if (yorn) then
          allocate (p (1 : nlo_controller%get_n_particles_real()), &
             source = nlo_controller%real_kinematics%p_real_cms%phs_point(i_phs)%p)
       else
          allocate (p ( 1 : nlo_controller%get_n_particles_real()), &
               source = nlo_controller%real_kinematics%p_real_lab%phs_point(i_phs)%p)
       end if
    end if
  end function nlo_controller_get_momenta

@ %def nlo_controller_get_momenta
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: set_fac_scale => nlo_controller_set_fac_scale
<<nlo controller: procedures>>=
  subroutine nlo_controller_set_fac_scale (nlo_controller, fac_scale)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    real(default), intent(in) :: fac_scale
    if (associated (nlo_controller%isr_kinematics)) &
       nlo_controller%isr_kinematics%fac_scale = fac_scale
  end subroutine nlo_controller_set_fac_scale

@ %def nlo_controller_set_fac_scale
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: uses_resonance_mappings => nlo_controller_uses_resonance_mappings
<<nlo controller: procedures>>=
  function nlo_controller_uses_resonance_mappings (nlo_controller) result (val)
    logical :: val
    class(nlo_controller_t), intent(in) :: nlo_controller
    val = nlo_controller%settings%use_resonance_mappings
  end function nlo_controller_uses_resonance_mappings

@ %def nlo_controller_uses_resonance_mappings
@
\subsection{xxx}
<<nlo controller: nlo controller: TBP>>=
  procedure :: compute_virt => nlo_controller_compute_virt
<<nlo controller: procedures>>=
  function nlo_controller_compute_virt &
       (nlo_controller, i_flv, i_hel, p_born) result(sqme_virt)
    class(nlo_controller_t), intent(inout) :: nlo_controller
    integer, intent(in) :: i_flv, i_hel
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default) :: sqme_virt
    associate (collector => nlo_controller%sqme_collector)
       if (nlo_controller%settings%use_internal_color_correlations) then
          call nlo_controller%virtual_terms%evaluate &
               (nlo_controller%reg_data, &
               i_flv, nlo_controller%alpha_s_born, &
               p_born, collector%sqme_virt_born_list (i_flv, i_hel), &
               nlo_controller%color_data%beta_ij)
       else
          call nlo_controller%virtual_terms%evaluate &
               (nlo_controller%reg_data, &
               i_flv, nlo_controller%alpha_s_born, &
               p_born, collector%sqme_virt_born_list (i_flv, i_hel), &
               collector%sqme_born_cc)
       end if
    end associate
    sqme_virt = nlo_controller%virtual_terms%sqme_virt
  end function nlo_controller_compute_virt

@ %def nlo_controller_compute_virt
@
<<nlo controller: nlo controller: TBP>>=
  procedure :: requires_spin_correlation => &
                  nlo_controller_requires_spin_correlation
<<nlo controller: procedures>>=
  function nlo_controller_requires_spin_correlation &
       (nlo_controller, i_flv) result (val)
    class(nlo_controller_t), intent(in) :: nlo_controller
    integer, intent(in) :: i_flv
    logical :: val
    val = nlo_controller%real_terms%sc_required (i_flv)
  end function nlo_controller_requires_spin_correlation

@ %def nlo_controller_requires_spin_correlation
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The FKS phase space}
To handle the FKS phase space and adapt it to multi-channel
integration, some extensions have to be made for pre-existing types.
The \texttt{phs\_tree}-type has an attribute containing the tree-code
of the emitting branch.
<<PHS trees: phs tree: TBP>>=
  procedure :: get_emitter => phs_tree_get_emitter
<<PHS trees: procedures>>=
  function phs_tree_get_emitter (tree) result (emitter)
    class(phs_tree_t), intent(in) :: tree
    integer :: emitter
    emitter = tree%emitter
  end function phs_tree_get_emitter

@ %def phs_tree_get_emitter
@
<<[[phs_fks.f90]]>>=
<<File header>>

module phs_fks

<<Use kinds>>
<<Use strings>>
  use constants
  use diagnostics
  use io_units, only: given_output_unit
  use format_utils, only: write_separator
  use lorentz
  use physics_defs
  use flavors
  use sf_mappings
  use sf_base
  use phs_base
  use phs_wood
  use cascades
  use process_constants
  use process_libraries
  use ttv_formfactors, only: THR_POS_WP, THR_POS_WM
  use ttv_formfactors, only: THR_POS_B, THR_POS_BBAR
  use nlo_data
  use fks_regions, only: region_data_t

<<Standard module head>>

<<phs fks: public>>

<<phs fks: parameters>>

<<phs fks: types>>

<<phs fks: interfaces>>

contains

<<phs fks: procedures>>

end module phs_fks

@ %def phs_fks
@
<<phs fks: parameters>>=
  integer, parameter, public :: I_XI = 1
  integer, parameter, public :: I_Y = 2
  integer, parameter, public :: I_PHI = 3

  integer, parameter, public :: PHS_MODE_UNDEFINED = 0
  integer, parameter, public :: PHS_MODE_ADDITIONAL_PARTICLE = 1
  integer, parameter, public :: PHS_MODE_COLLINEAR_REMNANT = 2

@ %def parameters
@
<<phs fks: public>>=
  public :: phs_fks_config_t
<<phs fks: types>>=
  type, extends (phs_wood_config_t) :: phs_fks_config_t
    integer :: mode = PHS_MODE_UNDEFINED
  contains
  <<phs fks: fks config: TBP>>
  end type phs_fks_config_t

@ %def phs_fks_config_t
@
<<phs fks: fks config: TBP>>=
  procedure :: final => phs_fks_config_final
<<phs fks: procedures>>=
  subroutine phs_fks_config_final (object)
    class(phs_fks_config_t), intent(inout) :: object
  end subroutine phs_fks_config_final

@ %def phs_fks_config_final
@
<<phs fks: fks config: TBP>>=
  procedure :: write => phs_fks_config_write
<<phs fks: procedures>>=
  subroutine phs_fks_config_write (object, unit)
    class(phs_fks_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call object%phs_wood_config_t%write (unit)
  end subroutine phs_fks_config_write

@ %def phs_fks_config_write
@
<<phs fks: fks config: TBP>>=
  procedure :: set_mode => phs_fks_config_set_mode
<<phs fks: procedures>>=
  subroutine phs_fks_config_set_mode (phs_config, mode)
    class(phs_fks_config_t), intent(inout) :: phs_config
    integer, intent(in) :: mode
    select case (mode)
    case (NLO_REAL, NLO_MISMATCH)
       phs_config%mode = PHS_MODE_ADDITIONAL_PARTICLE
    case (NLO_PDF)
       phs_config%mode = PHS_MODE_COLLINEAR_REMNANT
    end select
  end subroutine phs_fks_config_set_mode

@ %def phs_fks_config_set_mod
@
<<phs fks: fks config: TBP>>=
  procedure :: configure => phs_fks_config_configure
<<phs fks: procedures>>=
  subroutine phs_fks_config_configure (phs_config, sqrts, &
        sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, &
        ignore_mismatch, nlo_type)
    class(phs_fks_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    integer, intent(in), optional :: nlo_type
    if (.not. phs_config%extended_phs) then
       select case (phs_config%mode)
       case (PHS_MODE_ADDITIONAL_PARTICLE)
          phs_config%n_par = phs_config%n_par + 3
       case (PHS_MODE_COLLINEAR_REMNANT)
          phs_config%n_par = phs_config%n_par + 1
       end select
    end if
!!! Channel equivalences not accessible yet
    phs_config%provides_equivalences = .false.
  end subroutine phs_fks_config_configure

@ %def phs_fks_config_configure
@
<<phs fks: fks config: TBP>>=
  procedure :: startup_message => phs_fks_config_startup_message
<<phs fks: procedures>>=
  subroutine phs_fks_config_startup_message (phs_config, unit)
    class(phs_fks_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%phs_wood_config_t%startup_message (unit)
  end subroutine phs_fks_config_startup_message

@ %def phs_fks_config_startup_message
@
<<phs fks: fks config: TBP>>=
  procedure, nopass :: allocate_instance => phs_fks_config_allocate_instance
<<phs fks: procedures>>=
  subroutine phs_fks_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_fks_t :: phs)
  end subroutine phs_fks_config_allocate_instance

@ %def phs_fks_config_allocate_instance
@ If the phase space is generated from file, but we want to have resonance
histories, we must force the cascade sets to be generated. However, it must
be assured that Born flavors are used for this.
<<phs fks: fks config: TBP>>=
  procedure :: generate_phase_space_extra => phs_fks_config_generate_phase_space_extra
<<phs fks: procedures>>=
  subroutine phs_fks_config_generate_phase_space_extra (phs_config)
    class(phs_fks_config_t), intent(inout) :: phs_config
    integer :: off_shell, extra_off_shell
    type(flavor_t), dimension(:,:), allocatable :: flv_born
    integer :: i, j
    integer :: n_state, n_flv_born
    allocate (phs_config%cascade_set)
    n_flv_born = size (phs_config%flv, 1) - 1
    n_state = size (phs_config%flv, 2)
    allocate (flv_born (n_flv_born, n_state))
    do i = 1, n_flv_born
       do j = 1, n_state
          flv_born(i, j) = phs_config%flv(i, j)
       end do
    end do
    off_shell = phs_config%par%off_shell
    do extra_off_shell = 0, max (n_flv_born - 2, 0)
       phs_config%par%off_shell = off_shell + extra_off_shell
       call cascade_set_generate (phs_config%cascade_set, &
          phs_config%model, phs_config%n_in, phs_config%n_out - 1, &
          flv_born, phs_config%par, phs_config%fatal_beam_decay)
       if (cascade_set_is_valid (phs_config%cascade_set)) exit
    end do
    if (.not. cascade_set_is_valid (phs_config%cascade_set)) &
       call msg_fatal ("Resonance extraction: Phase space generation failed")
  end subroutine phs_fks_config_generate_phase_space_extra

@ %def phs_fks_config_generate_phase_space_extra
@
<<phs fks: fks config: TBP>>=
  procedure :: set_born_config => phs_fks_config_set_born_config
<<phs fks: procedures>>=
  subroutine phs_fks_config_set_born_config (phs_config, phs_cfg_born)
    class(phs_fks_config_t), intent(inout) :: phs_config
    type(phs_wood_config_t), intent(in), target :: phs_cfg_born
    call msg_debug (D_PHASESPACE, "phs_fks_config_set_born_config")
    phs_config%forest = phs_cfg_born%forest
    phs_config%n_channel = phs_cfg_born%n_channel
    allocate (phs_config%channel (phs_config%n_channel))
    phs_config%channel = phs_cfg_born%channel
    phs_config%n_par = phs_cfg_born%n_par
    phs_config%n_state = phs_cfg_born%n_state
    phs_config%sqrts = phs_cfg_born%sqrts
    phs_config%par = phs_cfg_born%par
    phs_config%sqrts_fixed = phs_cfg_born%sqrts_fixed
    phs_config%azimuthal_dependence = phs_cfg_born%azimuthal_dependence
    phs_config%provides_chains = phs_cfg_born%provides_chains
    phs_config%cm_frame = phs_cfg_born%cm_frame
    phs_config%vis_channels = phs_cfg_born%vis_channels
    allocate (phs_config%chain (size (phs_cfg_born%chain)))
    phs_config%chain = phs_cfg_born%chain
    phs_config%model => phs_cfg_born%model
    if (allocated (phs_cfg_born%cascade_set)) then
       allocate (phs_config%cascade_set)
       phs_config%cascade_set = phs_cfg_born%cascade_set
    end if
  end subroutine phs_fks_config_set_born_config

@ %def phs_fks_config_set_born_config
@
<<phs fks: fks config: TBP>>=
  procedure :: get_resonance_histories => phs_fks_config_get_resonance_histories
<<phs fks: procedures>>=
  function phs_fks_config_get_resonance_histories (phs_config) result (resonance_histories)
    type(resonance_history_t), dimension(:), allocatable :: resonance_histories
    class(phs_fks_config_t), intent(inout) :: phs_config
    if (allocated (phs_config%cascade_set)) then
       call cascade_set_get_resonance_histories &
          (phs_config%cascade_set, n_filter = 2, res_hists = resonance_histories)
    else
       call msg_debug (D_PHASESPACE, "Have to rebuild phase space for resonance histories")
       call phs_config%generate_phase_space_extra ()
       call cascade_set_get_resonance_histories &
          (phs_config%cascade_set, n_filter = 2, res_hists = resonance_histories)
    end if
  end function phs_fks_config_get_resonance_histories

@ %def phs_fks_config_get_resonance_histories
@
<<phs fks: parameters>>=
  integer, parameter, public :: GEN_REAL_PHASE_SPACE = 1
  integer, parameter, public :: GEN_SOFT_MISMATCH = 2
  integer, parameter, public :: GEN_SOFT_LIMIT_TEST = 3
  integer, parameter, public :: GEN_COLL_LIMIT_TEST = 4
  integer, parameter, public :: GEN_SOFT_COLL_LIMIT_TEST = 5

  real(default), parameter :: xi_tilde_test_soft = 0.0001_default
  real(default), parameter :: xi_tilde_test_coll = 0.5_default
  real(default), parameter :: y_test_soft = 0.5_default
  real(default), parameter :: y_test_coll = 0.999_default

@ 
@ [[xi_min]] should be set to a non-zero value in order to avoid
phase-space points with [[p_real(emitter) = 0]].
<<phs fks: public>>=
  public :: phs_fks_generator_t
<<phs fks: types>>=
  type :: phs_fks_generator_t
    integer, dimension(:), allocatable :: emitters
    type(real_kinematics_t), pointer :: real_kinematics => null()
    type(isr_kinematics_t), pointer :: isr_kinematics => null()
    integer :: n_in
    real(default) :: xi_min = tiny_07
    real(default) :: y_max = one
    real(default) :: sqrts
    real(default) :: E_gluon
    real(default) :: mrec2
    real(default), dimension(:), allocatable :: m2
    logical :: massive_phsp = .false.
    logical, dimension(:), allocatable :: is_massive
    logical :: singular_jacobian = .false.
    integer :: i_fsr_first = -1
    type(resonance_contributors_t), dimension(:), allocatable :: resonance_contributors !!! Put somewhere else?
    integer :: mode = GEN_REAL_PHASE_SPACE 
  contains
  <<phs fks: phs fks generator: TBP>>
  end type phs_fks_generator_t

@ %def phs_fks_generator_t
<<phs fks: phs fks generator: TBP>>=
  procedure :: connect_kinematics => phs_fks_generator_connect_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_generator_connect_kinematics &
         (generator, isr_kinematics, real_kinematics, massive_phsp)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(isr_kinematics_t), intent(in), pointer :: isr_kinematics
    type(real_kinematics_t), intent(in), pointer :: real_kinematics
    logical, intent(in) :: massive_phsp
    generator%real_kinematics => real_kinematics
    generator%isr_kinematics => isr_kinematics
    generator%massive_phsp = massive_phsp
  end subroutine phs_fks_generator_connect_kinematics

@ %def phs_fks_generator_connect_kinematics
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_isr_kinematics => phs_fks_generator_compute_isr_kinematics
<<phs fks: procedures>>=
  pure subroutine phs_fks_generator_compute_isr_kinematics (generator, r, p_in)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: r
    type(vector4_t), dimension(2), intent(in), optional :: p_in
    integer :: em
    type(vector4_t), dimension(2) :: p

    if (present (p_in)) then
       p = p_in
    else
       p = generator%real_kinematics%p_born_lab%phs_point(1)%p(1:2)
    end if

    associate (isr => generator%isr_kinematics)
       do em = 1, 2
          isr%x(em) = p(em)%p(0) / isr%beam_energy
          isr%z(em) = one - (one - isr%x(em)) * r
          isr%jacobian(em) =  isr%jacobian(em) * (one - isr%x(em))
       end do
       isr%sqrts_born = (p(1) + p(2))**1
    end associate
  end subroutine phs_fks_generator_compute_isr_kinematics

@ %def phs_fks_generator_compute_isr_kinematics
@ The fks phase space type contains the wood phase space and
separately the in- and outcoming momenta for the real process and the
corresponding Born momenta. Additionally, there are the variables
$\xi$,$\xi_{max}$, $y$ and $\phi$ which are used to create the real
phase space, as well as the jacobian and its corresponding soft and
collinear limit. Lastly, the array \texttt{ch\_to\_em} connects each
channel with an emitter.
<<phs fks: public>>=
  public :: phs_fks_t
<<phs fks: types>>=
  type, extends (phs_wood_t) :: phs_fks_t
    integer :: mode = PHS_MODE_UNDEFINED
    type(vector4_t), dimension(:), allocatable :: p_born
    type(vector4_t), dimension(:), allocatable :: q_born
    type(vector4_t), dimension(:), allocatable :: p_real
    type(vector4_t), dimension(:), allocatable :: q_real
    type(vector4_t), dimension(:), allocatable :: p_born_tot
    type(phs_fks_generator_t) :: generator
    type(kinematics_counter_t) :: counter
    logical :: perform_generation = .true.
    !!! Not entirley suited for combined integration
    !!! TODO: Modifiy global r_real-array
    real(default) :: r_isr
    type(phs_identifier_t), dimension(:), allocatable :: phs_identifiers

  contains
  <<phs fks: phs fks: TBP>>
  end type phs_fks_t

@ %def phs_fks_t
@
<<phs fks: interfaces>>=

  interface compute_beta
    module procedure compute_beta_massless
    module procedure compute_beta_massive
  end interface

  interface get_xi_max_fsr
    module procedure get_xi_max_fsr_massless
    module procedure get_xi_max_fsr_massive
  end interface

@ %def interfaces
@ Initializer for the phase space. Calls the initialization of the
corresponding Born phase space, sets up the
channel-emitter-association and allocates space for the momenta.
<<phs fks: phs fks: TBP>>=
  procedure :: init => phs_fks_init
<<phs fks: procedures>>=
  subroutine phs_fks_init (phs, phs_config)
    class(phs_fks_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config

    call phs%base_init (phs_config)
    select type (phs_config)
    type is (phs_fks_config_t)
       phs%config => phs_config
       phs%forest = phs_config%forest
    end select

    select type(phs)
    type is (phs_fks_t)
      select type (phs_config)
      type is (phs_fks_config_t)
         phs%mode = phs_config%mode
      end select

      select case (phs%mode)
      case (PHS_MODE_ADDITIONAL_PARTICLE)
         phs%n_r_born = phs%config%n_par - 3
      case (PHS_MODE_COLLINEAR_REMNANT)
         phs%n_r_born = phs%config%n_par - 1
      end select
      call phs%init_momenta (phs_config)
    end select
  end subroutine phs_fks_init

@ %def phs_fks_init
@
<<phs fks: phs fks: TBP>>=
  procedure :: final => phs_fks_final
<<phs fks: procedures>>=
  subroutine phs_fks_final (object)
    class(phs_fks_t), intent(inout) :: object
  end subroutine phs_fks_final

@ %def phs_fks_final
@
<<phs fks: phs fks: TBP>>=
  procedure :: init_momenta => phs_fks_init_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_init_momenta (phs, phs_config)
    class(phs_fks_t), intent(inout) :: phs
    class(phs_config_t), intent(in) :: phs_config
    allocate (phs%p_born (phs_config%n_in))
    allocate (phs%p_real (phs_config%n_in))
    select case (phs%mode)
    case (PHS_MODE_ADDITIONAL_PARTICLE)
       allocate (phs%q_born (phs_config%n_out-1))
       allocate (phs%q_real (phs_config%n_out-1))
       allocate (phs%p_born_tot (phs%config%n_in + phs%config%n_out-1))
    end select
  end subroutine phs_fks_init_momenta

@ %def phs_fks_init_momenta
@
<<phs fks: phs fks: TBP>>=
  procedure :: set_incoming_momenta => phs_fks_set_incoming_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_set_incoming_momenta (phs, p)
    class(phs_fks_t), intent(inout) :: phs
    type(vector4_t), dimension(:), intent(in) :: p
    call phs%phs_wood_t%set_incoming_momenta(p)
  end subroutine phs_fks_set_incoming_momenta

@ %def phs_fks_set_incoming_momenta
@ Evaluate selected channel. First, the subroutine calls the
evaluation procedure of the underlying Born phase space, using $n_r -
3$ random numbers. Then, the remaining three random numbers are used
to create $\xi$, $y$ and $\phi$, from which the real momenta are
calculated from the Born momenta.
<<phs fks: phs fks: TBP>>=
  procedure :: evaluate_selected_channel => phs_fks_evaluate_selected_channel
<<phs fks: procedures>>=
  subroutine phs_fks_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    integer :: n_in

    call phs%phs_wood_t%evaluate_selected_channel (c_in, r_in)
    phs%r(:,c_in) = r_in

    phs%q_defined = phs%phs_wood_t%q_defined
    if (.not. phs%q_defined) return

    if (phs%perform_generation) then
       select case (phs%mode)
       case (PHS_MODE_ADDITIONAL_PARTICLE)
          n_in = phs%config%n_in
          phs%p_born = phs%phs_wood_t%p
          phs%q_born = phs%phs_wood_t%q
          phs%p_born_tot (1: n_in) = phs%p_born
          phs%p_born_tot (n_in + 1 :) = phs%q_born
          call phs%set_reference_frames ()
          call phs%set_isr_kinematics ()
       case (PHS_MODE_COLLINEAR_REMNANT)
          call phs%compute_isr_kinematics (r_in(phs%n_r_born + 1))
          phs%r_isr = r_in(phs%n_r_born + 1)
       end select
    end if
  end subroutine phs_fks_evaluate_selected_channel

@ %def phs_fks_evaluate_selected_channel
@
<<phs fks: phs fks: TBP>>=
  procedure :: evaluate_other_channels => phs_fks_evaluate_other_channels
<<phs fks: procedures>>=
  subroutine phs_fks_evaluate_other_channels (phs, c_in)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    call phs%phs_wood_t%evaluate_other_channels (c_in)
    phs%r_defined = .true.
  end subroutine phs_fks_evaluate_other_channels

@ %def phs_fks_evaluate_other_channels
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_mcpar => phs_fks_get_mcpar
<<phs fks: procedures>>=
  subroutine phs_fks_get_mcpar (phs, c, r)
    class(phs_fks_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default), dimension(:), intent(out) :: r
    r(1 : phs%n_r_born) = phs%r(1 : phs%n_r_born,c)
    select case (phs%mode)
    case (PHS_MODE_ADDITIONAL_PARTICLE)
       r(phs%n_r_born + 1 :) = phs%r_real
    case (PHS_MODE_COLLINEAR_REMNANT)
       r(phs%n_r_born + 1 :) = phs%r_isr
    end select
  end subroutine phs_fks_get_mcpar

@ %def phs_fks_get_mcpar
@
<<phs fks: phs fks: TBP>>=
  procedure :: set_beam_energy => phs_fks_set_beam_energy
<<phs fks: procedures>>=
  subroutine phs_fks_set_beam_energy (phs)
    class(phs_fks_t), intent(inout) :: phs
    call phs%generator%set_beam_energy (phs%config%sqrts)
  end subroutine phs_fks_set_beam_energy

@ %def phs_fks_set_beam_energy
@
<<phs fks: phs fks: TBP>>=
  procedure :: set_emitters => phs_fks_set_emitters
<<phs fks: procedures>>=
  subroutine phs_fks_set_emitters (phs, emitters)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in), dimension(:), allocatable :: emitters
    call phs%generator%set_emitters (emitters)
  end subroutine phs_fks_set_emitters

@ %def phs_fks_set_emitters
@
<<phs fks: phs fks: TBP>>=
  procedure :: setup_masses => phs_fks_setup_masses
<<phs fks: procedures>>=
  subroutine phs_fks_setup_masses (phs, n_tot)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: n_tot
    call phs%generator%setup_masses (n_tot)
  end subroutine phs_fks_setup_masses

@ %def phs_fks_setup_masses
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_born_momenta => phs_fks_get_born_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_born_momenta (phs, p)
    class(phs_fks_t), intent(inout) :: phs
    type(vector4_t), intent(out), dimension(:) :: p
    select case (phs%mode)
    case (PHS_MODE_ADDITIONAL_PARTICLE)
       p(1:phs%config%n_in) = phs%p_born
       p(phs%config%n_in+1:) = phs%q_born
    case (PHS_MODE_COLLINEAR_REMNANT)
       p(1:phs%config%n_in) = phs%phs_wood_t%p
       p(phs%config%n_in+1:) = phs%phs_wood_t%q
    end select
    if (.not. phs%config%cm_frame) p = phs%lt_cm_to_lab * p
  end subroutine phs_fks_get_born_momenta

@ %def phs_fks_get_born_momenta
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_outgoing_momenta => phs_fks_get_outgoing_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_outgoing_momenta (phs, q)
    class(phs_fks_t), intent(in) :: phs
    type(vector4_t), intent(out), dimension(:) :: q
    select case (phs%mode)
    case (PHS_MODE_ADDITIONAL_PARTICLE)
       q = phs%q_real
    case (PHS_MODE_COLLINEAR_REMNANT)
       q = phs%phs_wood_t%q
    end select
  end subroutine phs_fks_get_outgoing_momenta

@ %def phs_fks_get_outgoing_momenta
@
<<phs fks: phs fks: TBP>>=
  procedure :: get_incoming_momenta => phs_fks_get_incoming_momenta
<<phs fks: procedures>>=
  subroutine phs_fks_get_incoming_momenta (phs, p)
    class(phs_fks_t), intent(in) :: phs
    type(vector4_t), intent(inout), dimension(:), allocatable :: p
    p = phs%p_real
  end subroutine phs_fks_get_incoming_momenta

@ %def phs_fks_get_incoming_momenta
@
<<phs fks: phs fks: TBP>>=
  procedure :: display_kinematics => phs_fks_display_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_display_kinematics (phs)
     class(phs_fks_t), intent(in) :: phs
!     call phs%counter%display ()
  end subroutine phs_fks_display_kinematics

@ %def phs_fks_display_kinematics
@
<<phs fks: phs fks: TBP>>=
  procedure :: set_isr_kinematics => phs_fks_set_isr_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_set_isr_kinematics (phs, p_born)
    class(phs_fks_t), intent(inout) :: phs
    type(vector4_t), dimension(2), intent(in), optional :: p_born
    call phs%generator%set_isr_kinematics (p_born)
  end subroutine phs_fks_set_isr_kinematics

@ %def phs_fks_set_isr_kinematics
@
<<phs fks: phs fks: TBP>>=
  procedure :: generate_radiation_variables => &
                       phs_fks_generate_radiation_variables
<<phs fks: procedures>>=
  subroutine phs_fks_generate_radiation_variables (phs, r_in)
    class(phs_fks_t), intent(inout) :: phs
    real(default), intent(in), dimension(:) :: r_in
    if (size (r_in) /= 3) call msg_fatal &
         ("Real kinematics need to be generated using three random numbers!")
    call phs%generator%generate_radiation_variables (r_in, phs%p_born_tot, &
       phs%phs_identifiers)
    phs%r_real = r_in
  end subroutine phs_fks_generate_radiation_variables

@ %def phs_fks_generate_radiation_variables
@ When initial-state radiation is involved, either due to beamnstrahlung or
QCD corrections, it is important to have access to both the phase space points
in the center-of-mass and lab frame.
<<phs fks: phs fks: TBP>>=
  procedure :: set_reference_frames => phs_fks_set_reference_frames
<<phs fks: procedures>>=
  subroutine phs_fks_set_reference_frames (phs)
    class(phs_fks_t), intent(inout) :: phs
    type(lorentz_transformation_t) :: lt_cm_to_lab
    associate (real_kinematics => phs%generator%real_kinematics)
       real_kinematics%p_born_cms%phs_point(1)%p = phs%p_born_tot
       if (.not. phs%config%cm_frame) then
          !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
          lt_cm_to_lab = phs%lt_cm_to_lab
          real_kinematics%p_born_lab%phs_point(1)%p = &
             lt_cm_to_lab * phs%p_born_tot
       else
          real_kinematics%p_born_lab%phs_point(1)%p = phs%p_born_tot
       end if
    end associate
  end subroutine phs_fks_set_reference_frames

@ %def phs_fks_set_reference_frames
@
<<phs fks: phs fks: TBP>>=
  procedure :: init_phs_identifiers => phs_fks_init_phs_identifiers
<<phs fks: procedures>>=
  subroutine phs_fks_init_phs_identifiers (phs, reg_data)
    class(phs_fks_t), intent(inout) :: phs
    type(region_data_t), intent(in) :: reg_data
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    allocate (phs%phs_identifiers (reg_data%n_phs))
    do i_em = 1, size (reg_data%emitters)
       emitter = reg_data%emitters(i_em)
       if (allocated (reg_data%resonances)) then
          do i_res = 1, size (reg_data%resonances)
             !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
             call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
             if (.not. share_emitter) cycle
             call check_for_phs_identifier &
                (phs%phs_identifiers, emitter, contributors%c, phs_exist, i_phs)
             if (.not. phs_exist) &
                call phs%phs_identifiers(i_phs)%init (emitter, contributors%c)
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       else
          call check_for_phs_identifier &
             (phs%phs_identifiers, emitter, phs_exist = phs_exist, i_phs = i_phs)
          if (.not. phs_exist) &
             call phs%phs_identifiers(i_phs)%init (emitter)
       end if
    end do
  end subroutine phs_fks_init_phs_identifiers

@ %def phs_fks_init_phs_identifiers
@
\subsection{Creation of the real phase space - FSR}
At this point, the Born phase space has been generated, as well as the
three random variables $\xi$, $y$ and $\phi$. The question is how the
real phase space is generated for a final-state emission
configuration. We work with two different sets of momenta, the Born
configuration $\Bigl\{ \bar{k}_{\oplus}, \bar{k}_{\ominus}, \bar{k}_{1}, ...,
\bar{k}_{n} \Bigr\}$ and the real configuration $\Bigl\{ k_{\oplus},
k_{\ominus}, k_1,..., k_n, k_{n+1} \Bigr\}$. We define the momentum of
the emitter to be on the $n$-th position and the momentum of the
radiated particle to be at position $n+1$. The magnitude of the
spatial component of k is denoted by $\underline{k}$.

For final-state emissions, it is $\bar{k}_\oplus = k_\oplus$ and
$\bar{k}_\ominus = k_\ominus$. Thus, the center-of-mass systems
coincide and it is
\begin{equation}
  q = \sum_{i=1}^n \bar{k}_i = \sum_{i=1}^{n+1} k_i,
\end{equation}
with $\vec{q} = 0$ and $q^2 = \left(q^0\right)^2$.

We want to construct the real phase space from the Born phase space
using three random numbers. They are defined as follows:
\begin{itemize}
\item $\xi = \frac{2k_{n+1}^0}{\sqrt{s}} \in [0, \xi_{max}]$, where
  $k_{n+1}$ denotes the four-momentum of the radiated particle.
\item $y = \cos\theta = \frac{\vec{k}_n \cdot
    \vec{k}_{n+1}}{\underline{k}_n \underline{k}_{n+1}}$ is the
  splitting angle.
\item The angle between tho two splitting particles in the transversal
  plane, $phi \in [0,2\pi]$.
\end{itemize}
Further, $k_{rec} = \sum_{i=1}^{n-1} k_i$ denotes the sum of all
recoiling momenta.
<<phs fks: phs fks generator: TBP>>=
  generic :: generate_fsr => generate_fsr_default, generate_fsr_resonances
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_fsr_default => phs_fks_generator_generate_fsr_default
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_fsr_default (generator, emitter, i_phs, p_born, p_real)
    !!! Important: Momenta must be input in the center-of-mass frame
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: emitter, i_phs
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    real(default) :: q0
    integer :: i, nlegreal

    nlegreal = size (p_born) + 1
    call generator%generate_fsr_in (p_born, p_real)
    q0 = generator%real_kinematics%xi_ref_momenta(1)**1

    generator%i_fsr_first = generator%n_in + 1
    call generator%generate_fsr_out (emitter, i_phs, p_born, p_real, q0)
    if (debug_active (D_PHASESPACE)) then
       call vector4_check_momentum_conservation (p_real%p, generator%n_in, &
           rel_smallness = 1000 * tiny_07, abs_smallness = tiny_07)
    end if
  end subroutine phs_fks_generator_generate_fsr_default

@ %def phs_fks_generator_generate_fsr
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_fsr_resonances => phs_fks_generator_generate_fsr_resonances
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_fsr_resonances (generator, &
       emitter, i_phs, i_con, p_born, p_real)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: emitter, i_phs
    integer, intent(in) :: i_con
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    integer, dimension(:), allocatable :: resonance_list
    integer, dimension(size(p_born)) :: inv_resonance_list
    type(vector4_t), dimension(:), allocatable :: p_tmp_born
    type(phs_point_t) :: p_tmp_real
    type(vector4_t) :: p_resonance
    real(default) :: q0
    integer :: i, j, nlegborn, nlegreal
    integer :: i_emitter
    type(lorentz_transformation_t) :: boost_to_resonance
    integer :: n_resonant_particles
    call msg_debug2 (D_PHASESPACE, "phs_fks_generator_generate_fsr_resonances")
    nlegborn = size (p_born); nlegreal = nlegborn + 1
    allocate (resonance_list (size (generator%resonance_contributors(i_con)%c)))
    resonance_list = generator%resonance_contributors(i_con)%c
    n_resonant_particles = size (resonance_list)

    if (.not. any (resonance_list == emitter)) then
       call msg_fatal ("Emitter must be included in the resonance list!")
    else
       do i = 1, n_resonant_particles
          if (resonance_list (i) == emitter) i_emitter = i
       end do
    end if

    inv_resonance_list = &
       create_inverse_resonance_list (nlegborn, resonance_list)

    p_tmp_real = n_resonant_particles + 1
    allocate (p_tmp_born (n_resonant_particles))
    p_tmp_born = vector4_null
    j = 1
    do i = 1, n_resonant_particles
       p_tmp_born(j) = p_born (resonance_list(i))
       j = j + 1
    end do

    call generator%generate_fsr_in (p_born, p_real)

    p_resonance = generator%real_kinematics%xi_ref_momenta(i_con)
    q0 = p_resonance**1

    boost_to_resonance = inverse (boost (p_resonance, q0))
    p_tmp_born = boost_to_resonance * p_tmp_born

    generator%i_fsr_first = 1
    call generator%generate_fsr_out (emitter, i_phs, p_tmp_born, p_tmp_real, q0, i_emitter)
    p_tmp_real = inverse (boost_to_resonance) * p_tmp_real

    do i = generator%n_in + 1, nlegborn
       if (any (resonance_list == i)) then
          p_real%p(i) = p_tmp_real%p(inv_resonance_list (i))
       else
          p_real%p(i) = p_born (i)
       end if
    end do
    p_real%p(nlegreal) = p_tmp_real%p (n_resonant_particles + 1)

    if (debug_active (D_PHASESPACE)) then
       call vector4_check_momentum_conservation (p_real%p, generator%n_in, &
           rel_smallness = 1000 * tiny_07, abs_smallness = tiny_07)
    end if

  contains

    function create_inverse_resonance_list (nlegborn, resonance_list) &
       result (inv_resonance_list)
       integer, intent(in) :: nlegborn
       integer, intent(in), dimension(:) :: resonance_list
       integer, dimension(nlegborn) :: inv_resonance_list
       integer :: i, j
       inv_resonance_list = 0
       j = 1
       do i = 1, nlegborn
          if (any (i == resonance_list)) then
             inv_resonance_list (i) = j
             j = j + 1
          end if
       end do
    end function create_inverse_resonance_list

    function boosted_energy () result (E)
      real(default) :: E
      type(vector4_t) :: p_boost
      p_boost = boost_to_resonance * p_resonance
      E = p_boost%p(0)
    end function boosted_energy
  end subroutine phs_fks_generator_generate_fsr_resonances

@ %def phs_fks_generator_generate_fsr_resonances
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_fsr_in => phs_fks_generator_generate_fsr_in
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_fsr_in (generator, p_born, p_real)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    integer :: i
    do i = 1, generator%n_in
       p_real%p(i) = p_born(i)
    end do
  end subroutine phs_fks_generator_generate_fsr_in

@ %def phs_fks_generator_generate_fsr_in
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_fsr_out => phs_fks_generator_generate_fsr_out
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_fsr_out (generator, &
      emitter, i_phs, p_born, p_real, q0, p_emitter_index)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: emitter, i_phs
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    real(default), intent(in) :: q0
    integer, intent(in), optional :: p_emitter_index
    real(default) :: xi, y, phi
    integer :: nlegborn, nlegreal
    real(default) :: uk_np1, uk_n
    real(default) :: uk_rec, k_rec0
    type(vector3_t) :: k_n_born, k
    real(default) :: uk_n_born, uk, k2, k0_n
    real(default) :: cpsi, beta
    type(vector3_t) :: vec, vec_orth
    type(lorentz_transformation_t) :: rot, lambda
    integer :: i
    integer :: p_em
    p_em = emitter; if (present (p_emitter_index)) p_em = p_emitter_index
    if (generator%i_fsr_first < 0) &
       call msg_fatal ("FSR generator is called for outgoing particles but "&
          &"i_fsr_first is not set!")

    associate (rad_var => generator%real_kinematics)
       xi = rad_var%xi_tilde
       if (rad_var%supply_xi_max) xi = xi*rad_var%xi_max(i_phs)
       y = rad_var%y(i_phs)
       phi = rad_var%phi
    end associate

    nlegborn = size (p_born)
    nlegreal = nlegborn + 1
    generator%E_gluon = q0 * xi / two
    uk_np1 = generator%E_gluon
    k_n_born = p_born(p_em)%p(1:3)
    uk_n_born = k_n_born**1

    generator%mrec2 = (q0 - p_born(p_em)%p(0))**2 &
       - space_part_norm(p_born(p_em))**2
    if (generator%is_massive(emitter)) then
       call generator%compute_emitter_kinematics &
          (y, emitter, i_phs, q0, k0_n, uk_n, uk)
    else
       call generator%compute_emitter_kinematics (y, q0, uk_n, uk)
       generator%real_kinematics%y_soft(i_phs) = y
       k0_n = uk_n
    end if

    call msg_debug2 (D_PHASESPACE, "phs_fks_generator_generate_fsr_out")
    call debug_input_values ()

    vec = uk_n / uk_n_born * k_n_born
    vec_orth = create_orthogonal (vec)
    p_real%p(p_em)%p(0) = k0_n
    p_real%p(p_em)%p(1:3) = vec%p(1:3)
    cpsi = (uk_n**2 + uk**2 - uk_np1**2) / (two * uk_n * uk)
    !!! This is to catch the case where cpsi = 1, but numerically
    !!! turns out to be slightly larger than 1.
    call check_cpsi_bound (cpsi)
    rot = rotation (cpsi, - sqrt (one - cpsi**2), vec_orth)
    p_real%p(p_em) = rot * p_real%p(p_em)
    vec = uk_np1 / uk_n_born * k_n_born
    vec_orth = create_orthogonal (vec)
    p_real%p(nlegreal)%p(0) = uk_np1
    p_real%p(nlegreal)%p(1:3) = vec%p(1:3)
    cpsi = (uk_np1**2 + uk**2 - uk_n**2) / (two * uk_np1 * uk)
    call check_cpsi_bound (cpsi)
    rot = rotation (cpsi, sqrt (one - cpsi**2), vec_orth)
    p_real%p(nlegreal) = rot * p_real%p(nlegreal)
    call construct_recoiling_momenta ()
    call generate_jacobians ()

  contains

<<phs fks: generator generate fsr out procedures>>

  end subroutine phs_fks_generator_generate_fsr_out

@ %def phs_fks_generator_generate_fsr_out
<<phs fks: generator generate fsr out procedures>>=
  subroutine debug_input_values ()
    if (debug2_active (D_PHASESPACE)) then
       call generator%write ()
       print *, 'emitter =    ', emitter
       print *, 'p_born:'
       call vector4_write_set (p_born)
       print *, 'p_real:'
       call p_real%write()
       print *, 'q0 =    ', q0
       if (present(p_emitter_index)) then
          print *, 'p_emitter_index =    ', p_emitter_index
       else
          print *, 'p_emitter_index not given'
       end if
    end if
  end subroutine debug_input_values

<<phs fks: generator generate fsr out procedures>>=
  subroutine check_cpsi_bound (cpsi)
    real(default), intent(inout) :: cpsi
    if (cpsi > one) then
       cpsi = one
    else if (cpsi < -one) then
       cpsi = - one
    end if
  end subroutine check_cpsi_bound

@ Construction of the recoiling momenta. The reshuffling of momenta
must not change the invariant mass of the recoiling system, which
means $k_{\rm{rec}}^2 = \bar{k_{\rm{rec}}}^2$. Therefore, the momenta
are related by a boost, $\bar{k}_i = \Lambda k_i$. The boost parameter
is
\begin{equation*}
  \beta = \frac{q^2 - (k_{\rm{rec}}^0 +
    \underline{k}_{\rm{rec}})^2}{q^2 + (k_{\rm{rec}}^0 +
    \underline{k}_{\rm{rec}})^2}
\end{equation*}
<<phs fks: generator generate fsr out procedures>>=
  subroutine construct_recoiling_momenta ()
    k_rec0 = q0 - p_real%p(p_em)%p(0) - p_real%p(nlegreal)%p(0)
    uk_rec = sqrt (k_rec0**2 - generator%mrec2)
    if (generator%is_massive(emitter)) then
       beta = compute_beta (q0**2, k_rec0, uk_rec, &
                            p_born(p_em)%p(0), uk_n_born)
    else
       beta = compute_beta (q0**2, k_rec0, uk_rec)
    end if
    k = p_real%p(p_em)%p(1:3) + p_real%p(nlegreal)%p(1:3)
    vec%p(1:3) = one / uk * k%p(1:3)
    lambda = boost (beta / sqrt(one - beta**2), vec)
    do i = generator%i_fsr_first, nlegborn
      if (i /= p_em) then
        p_real%p(i) = lambda * p_born(i)
      end if
    end do
    vec%p(1:3) = p_born(p_em)%p(1:3) / uk_n_born
    rot = rotation (cos(phi), sin(phi), vec)
    p_real%p(nlegreal) = rot * p_real%p(nlegreal)
    p_real%p(p_em) = rot * p_real%p(p_em)
  end subroutine construct_recoiling_momenta

@ The factor $\frac{q^2}{(4\pi)^3}$ is not included here since it is
supplied during phase space generation. Also, we already divide by
$\xi$.
<<phs fks: generator generate fsr out procedures>>=
  subroutine generate_jacobians ()
    associate (jac => generator%real_kinematics%jac(i_phs))
       if (generator%is_massive(emitter)) then
          jac%jac(1) = jac%jac(1) * 4 / q0 / uk_n_born / xi
       else
          k2 = two * uk_n * uk_np1* (one - y)
          jac%jac(1) = uk_n**2 / uk_n_born / (uk_n - k2 / (two * q0))
       end if
       !!! Soft jacobian
       jac%jac(2) = one
       !!! Collinear jacobian
       jac%jac(3) = one - xi / two * q0 / uk_n_born
    end associate
  end subroutine generate_jacobians

@
<<phs fks: phs fks: TBP>>=
  procedure :: generate_fsr => phs_fks_generate_fsr
<<phs fks: procedures>>=
  subroutine phs_fks_generate_fsr (phs, emitter, i_phs, p_real, i_con)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: emitter, i_phs
    type(phs_point_t), intent(inout) :: p_real
    integer, intent(in), optional :: i_con
    type(vector4_t), dimension(:), allocatable :: p
    associate (generator => phs%generator)
       allocate (p (1 : generator%real_kinematics%p_born_cms%get_n_particles()), &
          source = generator%real_kinematics%p_born_cms%phs_point(1)%p)
       generator%real_kinematics%supply_xi_max = .true.
       call generator%compute_xi_max (emitter, i_phs, p, i_con)
       if (present (i_con)) then
          call generator%generate_fsr (emitter, i_phs, i_con, p, p_real)
       else
          call generator%generate_fsr (emitter, i_phs, p, p_real)
       end if
       generator%real_kinematics%p_real_cms%phs_point(i_phs)%p = p_real%p
       if (.not. phs%config%cm_frame) p_real = phs%lt_cm_to_lab * p_real
       generator%real_kinematics%p_real_lab%phs_point(i_phs)%p = p_real%p
    end associate
  end subroutine phs_fks_generate_fsr

@ %def phs_fks_generate_fsr
@
<<phs fks: phs fks generator: TBP>>=
  generic :: compute_emitter_kinematics => &
                    compute_emitter_kinematics_massless, &
                    compute_emitter_kinematics_massive
  procedure :: compute_emitter_kinematics_massless => &
                    phs_fks_generator_compute_emitter_kinematics_massless
  procedure :: compute_emitter_kinematics_massive => &
                    phs_fks_generator_compute_emitter_kinematics_massive
<<phs fks: procedures>>=
  subroutine phs_fks_generator_compute_emitter_kinematics_massless &
     (generator, y, q0, uk_em, uk)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: y, q0
    real(default), intent(out) :: uk_em, uk
    real(default) :: k0_np1, q2

    k0_np1 = generator%E_gluon
    q2 = q0**2

    uk_em = (q2 - generator%mrec2 - two * q0 * k0_np1) / (two * (q0 - k0_np1 * (one - y)))
    uk = sqrt (uk_em**2 + k0_np1**2 + two * uk_em * k0_np1 * y)
  end subroutine phs_fks_generator_compute_emitter_kinematics_massless

  subroutine phs_fks_generator_compute_emitter_kinematics_massive &
                                    (generator, y, em, i_phs, q0, k0_em, uk_em, uk)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: y
    integer, intent(in) :: em, i_phs
    real(default), intent(in) :: q0
    real(default), intent(inout) :: k0_em, uk_em, uk
    real(default) :: k0_np1, q2, mrec2, m2
    real(default) :: k0_rec_max, k0_em_max, k0_rec, uk_rec
    real(default) :: z, z1, z2

    k0_np1 = generator%E_gluon
    q2 = q0**2
    mrec2 = generator%mrec2
    m2 = generator%m2(em)

    k0_rec_max = (q2 - m2 + mrec2) / (two * q0)
    k0_em_max = (q2 + m2 - mrec2)  /(two * q0)
    z1 = (k0_rec_max + sqrt (k0_rec_max**2 - mrec2)) / q0
    z2 = (k0_rec_max - sqrt (k0_rec_max**2 - mrec2)) / q0
    z = z2 - (z2 - z1) * (one + y) / 2
    k0_em = k0_em_max - k0_np1 * z
    k0_rec = q0 - k0_np1 - k0_em
    uk_em = sqrt(k0_em**2 - m2)
    uk_rec = sqrt(k0_rec**2 - mrec2)
    uk = uk_rec
    generator%real_kinematics%jac(i_phs)%jac = q0 * (z1 - z2) / 4 * k0_np1
    generator%real_kinematics%y_soft(i_phs) = &
       (two * q2 * z - q2 - mrec2 + m2) / (sqrt(k0_em_max**2 - m2) * q0) / two
  end subroutine phs_fks_generator_compute_emitter_kinematics_massive

@ %def phs_fks_generator_compute_emitter_kinematics
@
<<phs fks: procedures>>=
  function compute_beta_massless (q2, k0_rec, uk_rec) result (beta)
    real(default), intent(in) :: q2, k0_rec, uk_rec
    real(default) :: beta
    beta = (q2 - (k0_rec + uk_rec)**2) / (q2 + (k0_rec + uk_rec)**2)
  end function compute_beta_massless

  function compute_beta_massive (q2, k0_rec, uk_rec, &
                                 k0_em_born, uk_em_born) result (beta)
    real(default), intent(in) :: q2, k0_rec, uk_rec
    real(default), intent(in) :: k0_em_born, uk_em_born
    real(default) :: beta
    real(default) :: k0_rec_born, uk_rec_born, alpha
    k0_rec_born = sqrt(q2) - k0_em_born
    uk_rec_born = uk_em_born
    alpha = (k0_rec + uk_rec) / (k0_rec_born + uk_rec_born)
    beta = (one - alpha**2) / (one + alpha**2)
  end function compute_beta_massive

@ %def compute_beta
@ The momentum of the radiated particle is computed according to
\begin{equation}
  \label{eq:phs fks:compute k_n}
  \underline{k}_n = \frac{q^2 - M_{\rm{rec}}^2 -
    2q^0\underline{k}_{n+1}}{2(q^0 - \underline{k}_{n+1}(1-y))},
\end{equation}
with $k = k_n + k_{n+1}$ and $M_{\rm{rec}}^2 = k_{\rm{rec}}^2 =
\left(q-k\right)^2$. Because of $\boldsymbol{\bar{k}}_n \parallel
\boldsymbol{k}_n + \boldsymbol{k}_{n+1}$ we find $M_{\rm{rec}}^2 =
\left(q-\bar{k}_n\right)^2$.
Equation \ref{eq:phs fks: compute k_n} follows from the fact that
$\left(\boldsymbol{k} - \boldsymbol{k}_n\right)^2 =
\boldsymbol{k}_{n+1}^2$, which is equivalent to $\boldsymbol{k}_n
\cdot \boldsymbol{k} = \frac{1}{2} \left(\underline{k}_n^2 +
  \underline{k}^2 - \underline{k}_{n+1}^2\right)$.\\
$\boldsymbol{k}_n$ and $\boldsymbol{k}_{n+1}$ are obtained by first
setting up vectors parallel to $\boldsymbol{\bar{k}}_n$,
\begin{equation*}
  \boldsymbol{k}_n' = \underline{k}_n
  \frac{\bar{\pmb{k}}_n}{\underline{\bar{k}}_n}, \quad \pmb{k}_{n+1}'
  = \underline{k}_{n+1}\frac{\bar{\pmb{k}}_n}{\underline{\bar{k}}_n},
\end{equation*}
and then rotating these vectors by an amount of $\cos\psi_n =
\frac{\boldsymbol{k}_n\cdot\pmb{k}}{\underline{k}_n \underline{k}}$.
@ The emitted particle cannot have more momentum than the emitter has
in the Born phase space. Thus, there is an upper bound for $\xi$,
determined by the condition $k_{n+1}^0 = \underline{\bar{k}}_n$, which
is equal to
\begin{equation*}
\xi_{\rm{max}} = \frac{2}{\underline{\bar{k}}_n}{q^0}.
\end{equation*}
<<phs fks: procedures>>=
  pure function get_xi_max_fsr_massless (p_born, q0, emitter) result (xi_max)
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: q0
    integer, intent(in) :: emitter
    real(default) :: xi_max
    real(default) :: uk_n_born
    uk_n_born = space_part_norm (p_born(emitter))
    xi_max = two * uk_n_born / q0
  end function get_xi_max_fsr_massless

@ %def get_xi_max_fsr_massless
@ The computation of $\xi_{\rm{max}}$ for massive emitters is described
in arXiv:1202.0465. Let's recapitulate it here.

We consider the Dalitz-domain created by $k_{n+1}^0$, $k_n^0$ and
$k_{\rm{rec}}^0$ and introduce the parameterization
\begin{equation*}
  k_n^0 = \bar{k}_n^0 - zk_{n+1}^0
\end{equation*}
Then, for each value of $z$, there exists a maximum value of
$\underline{k}_{n+1}$ from which $\xi_{\rm{max}}$ can be extracted via
$\xi_{\rm{max}} = 2k_{n+1}^0/q$. It is determined by the condition
\begin{equation*}
  \underline{k}_{n+1} \pm \underline{k}_n \pm \underline{k}_{\rm{rec}} = 0.
\end{equation*}
This can be manipulated to yield
\begin{equation*}
  \left(\underline{k}_{n+1}^2 + \underline{k}_n^2 -
  \underline{k}_{\rm{rec}}^2\right)^2 =
  4\underline{k}^2_{n+1}\underline{k}_n^2.
\end{equation*}
Here we can use $\underline{k}_n^2 = \left(k_n^0\right)^2 - m^2$ and
$\underline{k}_{\rm{rec}}^2 = \left(q - k_n^0 - k_{n+1}^0\right)^2 -
M_{\rm{rec}}^2$, as well as the above parameterization of $k_n^0$, to
obtain
\begin{equation*}
  4\underline{k}_{n+1}^2\left(2\underline{k}_{n+1}qz(1-z) +
  q^2z^2 - 2q\bar{k}_{\rm{rec}}^0z + M_{\rm{rec}}^2\right) = 0.
\end{equation*}
Solving for $k_{n+1}^0$ gives
\begin{equation}
  k_{n+1}^0 = \frac{2q\bar{k}^0_{\rm{rec}}z - q^2z^2 - M_{\rm{rec}}^2}{2qz(1-z)}.
  \label{XiMaxMassive}
\end{equation}
It is still open how to compute $z$. For this, consider that the
right-hand-side of equation (\ref{XiMaxMassive}) vanishes for
\begin{equation*}
  z_{1,2} = \left(\bar{k}_{\rm{rec}}^0 \pm
  \sqrt{\left(\bar{k}_{\rm{rec}}^0\right)^2 - M_{\rm{rec}}^2}\right)/q,
\end{equation*}
which corresponds to the borders of the Dalitz-region where the gluon
momentum vanishes. Thus we define
\begin{equation*}
  z = z_2 - \frac{1}{2} (z_2 - z_1)(1+y).
\end{equation*}
<<phs fks: procedures>>=
  pure function get_xi_max_fsr_massive (p_born, q0, emitter, m2, y) result (xi_max)
    real(default) :: xi_max
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: q0
    integer, intent(in) :: emitter
    real(default), intent(in) :: m2, y
    real(default) :: mrec2
    real(default) :: k0_rec_max
    real(default) :: z, z1, z2
    real(default) :: k_np1_max
    associate (p => p_born(emitter)%p)
       mrec2 = (q0 - p(0))**2 - p(1)**2 - p(2)**2 - p(3)**2
    end associate
    call compute_dalitz_bounds (q0, m2, mrec2, z1, z2, k0_rec_max)
    z = z2 - (z2 - z1) * (one + y) / two
    k_np1_max = - (q0**2 * z**2 - two * q0 * k0_rec_max * z + mrec2) &
       / (two * q0 * z * (one - z))
    xi_max = two * k_np1_max / q0
  end function get_xi_max_fsr_massive

@ %def get_xi_max_fsr_massive
@
<<phs fks: procedures>>=
  function get_xi_max_isr (xb, y) result (xi_max)
    real(default), dimension(2), intent(in) :: xb
    real(default), intent(in) :: y
    real(default) :: xb_plus, xb_minus
    real(default) :: xi_max
    real(default) :: plus_val, minus_val
    real(default) :: onepy, onemy

    xb_plus = xb(I_PLUS); xb_minus = xb(I_MINUS)
    onepy = one + y; onemy = one - y

    plus_val = two * onepy * xb_plus**2 / &
               (sqrt ((one + xb_plus**2)**2 * onemy**2 + 16 * y * xb_plus**2) &
               + onemy * (one - xb_plus**2))
    minus_val = two * onemy * xb_minus**2 / &
                (sqrt ((one + xb_minus**2)**2 * onepy**2 - 16 * y * xb_minus**2) &
               + onemy * (one - xb_minus**2))
    xi_max = one - max (plus_val, minus_val)
  end function get_xi_max_isr

@ %def get_xi_max_isr
@
<<phs fks: procedures>>=
  function get_xi_max_isr_decay (p) result (xi_max)
     real(default) :: xi_max
     type(vector4_t), dimension(:), intent(in) :: p
     real(default) :: m_in, m_out1, m_out2
     m_in = p(1)**1
     m_out1 = p(2)**1; m_out2 = p(3)**1
     xi_max = one - (m_out1 + m_out2)**2 / m_in**2
  end function get_xi_max_isr_decay

@ %def get_xi_max_isr_decay
@
\subsection{Creation of the real phase space - ISR}
<<phs fks: phs fks: TBP>>=
  procedure :: generate_isr => phs_fks_generate_isr
<<phs fks: procedures>>=
  subroutine phs_fks_generate_isr (phs, i_phs, p_born, p_real)
    class(phs_fks_t), intent(inout) :: phs
    integer, intent(in) :: i_phs
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    type(vector4_t) :: p0, p1
    type(lorentz_transformation_t) :: lt
    real(default) :: sqrts_hat

    associate (generator => phs%generator)
       select case (generator%n_in)
       case (1)
          call generator%compute_xi_max (1, i_phs, p_born)
          call generator%generate_isr_decay (i_phs, p_born, p_real)
          phs%config%cm_frame = .true.
       case (2)
          call generator%compute_xi_max (1, i_phs, p_born)
          call generator%compute_xi_max (2, i_phs, p_born)
          call generator%generate_isr (i_phs, p_born, p_real)
       end select
       phs%generator%real_kinematics%p_real_lab%phs_point(i_phs)%p = p_real%p
       if (.not. phs%config%cm_frame) then
          sqrts_hat = (p_real%p(1) + p_real%p(2))**1
          p0 = p_real%p(1) + p_real%p(2)
          lt = boost (p0, sqrts_hat)
          p1 = inverse(lt) * p_real%p(1)
          lt = lt * rotation_to_2nd (3, space_part (p1))
          phs%generator%real_kinematics%p_real_cms%phs_point(i_phs)%p = &
               inverse (lt) * p_real%p
       else
          phs%generator%real_kinematics%p_real_cms%phs_point(i_phs)%p = p_real%p
       end if
     end associate
  end subroutine phs_fks_generate_isr

@ %def phs_fks_generate_isr
@ The real phase space for an inital-state emission involved in a decay
process is generated by first setting the gluon momentum like in the
scattering case by using its angular coordinates $y$ and $\phi$ and then
adjusting the gluon energy with $\xi$. The emitter momentum is kept
identical to the Born case, i.e.  $p_{\rm{in}} = \bar{p}_{\rm{in}}$, so
that after the emission it has momentum $p_{\rm{virt}} = p_{\rm{in}} -
p_{\rm{g}}$ and invariant mass $m^2 = p_{\rm{virt}}^2$.  Note that the
final state momenta have to remain on-shell, so that $p_1^2 =
\bar{p}_1^2 = m_1^2$ and $p_2^2 = \bar{p}_2^2 = m_2^2$. Let $\Lambda$ be
the boost from into the rest frame of the emitter after emission, i.e.
$\Lambda p_{\rm{virt}} = \left(m, 0, 0, 0\right)$.  In this reference
frame, the spatial components of the final-state momenta sum up to zero,
and their magnitude is
\begin{equation*}
  p = \frac{\sqrt {\lambda (m^2, m_1^2, m_2^2)}}{2m},
\end{equation*}
a fact already used in the evaluation of the phase space trees of
[[phs_forest]].  Obviously, from this, the final-state energies can be
deferred via $E_i^2 = m_i^2 - p^2$.  In the next step, the $p_{1,2}$ are
set up as vectors $(E,0,0,\pm p)$ along the z-axis and then rotated
about the same azimuthal and polar angles as in the Born system.
Finally, the momenta are boosted out of the rest frame by multiplying
with $\Lambda$.
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_isr_decay => phs_fks_generator_generate_isr_decay
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_isr_decay (generator, i_phs, p_born, p_real)
     class(phs_fks_generator_t), intent(inout) :: generator
     integer, intent(in) :: i_phs
     type(vector4_t), intent(in), dimension(:) :: p_born
     type(phs_point_t), intent(inout) :: p_real
     real(default) :: xi_max, xi, y, phi
     integer :: nlegborn, nlegreal
     real(default) :: k0_np1
     real(default) :: msq_in
     real(default) :: msq, msq1, msq2, m, p, E
     real(default) :: rlda, rlda_soft
     type(vector4_t) :: p_virt
     real(default) :: theta_born, phi_born
     type(lorentz_transformation_t) :: L, rotation

    associate (rad_var => generator%real_kinematics)
      xi_max = rad_var%xi_max(i_phs)
      xi = rad_var%xi_tilde * xi_max
      y = rad_var%y(i_phs)
      phi = rad_var%phi
      rad_var%y_soft(i_phs) = y
    end associate

    nlegborn = size (p_born)
    nlegreal = nlegborn + 1

    p_real%p(1) = p_born(1)
    k0_np1 = p_real%p(1)%p(0) * xi / two
    p_real%p(nlegreal)%p(0) = k0_np1
    p_real%p(nlegreal)%p(1) = k0_np1 * sqrt(one - y**2) * sin(phi)
    p_real%p(nlegreal)%p(2) = k0_np1 * sqrt(one - y**2) * cos(phi)
    p_real%p(nlegreal)%p(3) = k0_np1 * y

    p_virt = p_real%p(1) - p_real%p(nlegreal)
    L = boost (p_virt, p_virt**1)

    msq = p_virt**2; m = sqrt(msq)
    msq1 = p_born(2)**2
    msq2 = p_born(3)**2
    rlda = sqrt (lambda (msq, msq1, msq2))
    p = rlda / (two * m)

    theta_born = polar_angle (p_born(2))
    phi_born = azimuthal_angle (p_born(2))
    rotation = LT_compose_r2_r3_b3 (cos(theta_born), sin(theta_born), &
        cos(phi_born), sin(phi_born), zero)

    E = sqrt (msq1 + p**2)
    p_real%p(2) = vector4_moving (E, p, 3)
    p_real%p(2) = rotation * p_real%p(2)

    E = sqrt (msq2 + p**2)
    p_real%p(3) = vector4_moving (E, -p, 3)
    p_real%p(3) = rotation * p_real%p(3)

    p_real%p(2:3) = L * p_real%p(2:3)

    associate (jac => generator%real_kinematics%jac(i_phs))
       jac%jac(1) = rlda / msq
       msq_in = p_born(1)**2
       rlda_soft = sqrt (lambda (msq_in, msq1, msq2))
       !!! We have to undo the Jacobian which has already been
       !!! supplied by the Born phase space.
       jac%jac(1) = jac%jac(1) * msq_in / rlda_soft
       jac%jac(2) = one
    end associate

  end subroutine phs_fks_generator_generate_isr_decay

@ %def phs_fks_generator_generate_isr_decay
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_isr_factorized => phs_fks_generator_generate_isr_factorized
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_isr_factorized (generator, i_phs, emitter, p_born, p_real)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: i_phs, emitter
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    type(vector4_t), dimension(:), allocatable :: p_tmp_born
    type(phs_point_t) :: p_tmp_real
    type(vector4_t) :: p_top
    type(lorentz_transformation_t) :: boost_to_rest_frame
    integer, parameter :: nlegreal = 7 !!! Factorized phase space so far only required for ee -> bwbw
     
    allocate (p_tmp_born (3)); p_tmp_born = vector4_null
    p_tmp_real = 4
    p_real%p(1:2) = p_born(1:2)
    if (emitter == THR_POS_B) then
       p_top = p_born (THR_POS_WP) + p_born (THR_POS_B)
       p_tmp_born(2) = p_born (THR_POS_WP)
       p_tmp_born(3) = p_born (THR_POS_B)
    else if (emitter == THR_POS_BBAR) then
       p_top = p_born (THR_POS_WM) + p_born (THR_POS_BBAR) 
       p_tmp_born(2) = p_born (THR_POS_WM)
       p_tmp_born(3) = p_born (THR_POS_BBAR)
    else
       call msg_fatal ("Threshold computation requires emitters to be at position 5 and 6 " // &
          "Please check if your process specification fulfills this requirement.")
    end if
    p_tmp_born (1) = p_top
    boost_to_rest_frame = inverse (boost (p_top, p_top**1))
    p_tmp_born = boost_to_rest_frame * p_tmp_born
    call generator%compute_xi_max_isr_factorized (i_phs, p_tmp_born)
    call generator%generate_isr_decay (i_phs, p_tmp_born, p_tmp_real)
    p_tmp_real = inverse (boost_to_rest_frame) * p_tmp_real
    if (emitter == THR_POS_B) then
       p_real%p(THR_POS_WP) = p_tmp_real%p (2)
       p_real%p(THR_POS_B) = p_tmp_real%p (3)
       p_real%p(THR_POS_WM) = p_born (THR_POS_WM)
       p_real%p(THR_POS_BBAR) = p_born (THR_POS_BBAR)
    !!! Exception has been handled above
    else
       p_real%p(THR_POS_WM) = p_tmp_real%p (2)
       p_real%p(THR_POS_BBAR) = p_tmp_real%p (3)
       p_real%p(THR_POS_WP) = p_born (THR_POS_WP)
       p_real%p(THR_POS_B) = p_born (THR_POS_B)
    end if
    p_real%p(nlegreal) = p_tmp_real%p (4)
  end subroutine phs_fks_generator_generate_isr_factorized
       
@ %def phs_fks_generator_generate_isr_factorized
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_isr => phs_fks_generator_generate_isr
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_isr &
       (generator, i_phs, p_born, p_real)
    !!! Important: Import momenta in the lab frame
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: i_phs
    type(vector4_t), intent(in) , dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    real(default) :: xi_max, xi, y, phi
    integer :: nlegborn, nlegreal
    real(default) :: sqrts_real
    real(default) :: k0_np1
    type(lorentz_transformation_t) :: lambda_transv, lambda_longit, lambda_longit_inv
    real(default) :: x_plus, x_minus, xb_plus, xb_minus
    integer :: i
    real(default) :: xi_plus, xi_minus
    real(default) :: beta_gamma
    type(vector3_t) :: beta_vec

    associate (rad_var => generator%real_kinematics)
      xi_max = rad_var%xi_max(i_phs)
      xi = rad_var%xi_tilde * xi_max
      y = rad_var%y(i_phs)
      phi = rad_var%phi
      rad_var%y_soft(i_phs) = y
    end associate

    nlegborn = size (p_born)
    nlegreal = nlegborn + 1
    generator%isr_kinematics%sqrts_born = sqrt ((p_born(1) + p_born(2))**2)

    !!! Initial state real momenta
    xb_plus = generator%isr_kinematics%x(I_PLUS)
    xb_minus = generator%isr_kinematics%x(I_MINUS)
    x_plus = xb_plus / sqrt(one - xi) * sqrt ((two - xi * (one - y)) / (two - xi * (one + y)))
    x_minus = xb_minus / sqrt(one - xi) * sqrt ((two - xi * (one + y)) / (two - xi * (one - y)))
    p_real%p(I_PLUS) = x_plus/xb_plus * p_born(I_PLUS)
    p_real%p(I_MINUS) = x_minus/xb_minus * p_born(I_MINUS)
    generator%isr_kinematics%z(I_PLUS) = x_plus/generator%isr_kinematics%x(I_PLUS)
    generator%isr_kinematics%z(I_MINUS) = x_minus/generator%isr_kinematics%x(I_MINUS)

    !!! Create radiation momentum
    sqrts_real = generator%isr_kinematics%sqrts_born / sqrt(one - xi)
    k0_np1 = sqrts_real * xi / two
    p_real%p(nlegreal)%p(0) = k0_np1
    p_real%p(nlegreal)%p(1) = k0_np1 * sqrt (one - y**2)*sin(phi)
    p_real%p(nlegreal)%p(2) = k0_np1 * sqrt(one - y**2)*cos(phi)
    p_real%p(nlegreal)%p(3) = k0_np1 * y

    call get_boost_parameters (p_real%p, beta_gamma, beta_vec)
    lambda_longit = create_longitudinal_boost (beta_gamma, beta_vec, inverse = .true.)
    p_real%p(nlegreal) = lambda_longit * p_real%p(nlegreal)

    call get_boost_parameters (p_born, beta_gamma, beta_vec)
    lambda_longit = create_longitudinal_boost (beta_gamma, beta_vec, inverse = .false.)
    forall (i=3:nlegborn) &
        p_real%p(i) = lambda_longit * p_born(i)

    lambda_transv = create_transversal_boost (p_real%p(nlegreal), xi, sqrts_real)
    forall (i=3:nlegborn) &
         p_real%p(i) = lambda_transv * p_real%p(i)

    lambda_longit_inv = create_longitudinal_boost (beta_gamma, beta_vec, inverse = .true.)
    forall (i=3:nlegborn) &
         p_real%p(i) = lambda_longit_inv * p_real%p(i)

    !!! Compute jacobians
    associate (jac => generator%real_kinematics%jac(i_phs))
       xi_plus = xi_max * (one - xb_plus)
       xi_minus = xi_max * (one - xb_minus)
       jac%jac(1) = one / (one - xi)
       jac%jac(2) = one
       jac%jac(3) = xi_plus / (one - xi_plus)
       jac%jac(4) = xi_minus / (one - xi_minus)
    end associate
  contains
    subroutine get_boost_parameters (p, beta_gamma, beta_vec)
       type(vector4_t), intent(in), dimension(:) :: p
       real(default), intent(out) :: beta_gamma
       type(vector3_t), intent(out) :: beta_vec
       beta_vec = (p(1)%p(1:3) + p(2)%p(1:3)) / (p(1)%p(0) + p(2)%p(0))
       beta_gamma = beta_vec**1 / sqrt (one - beta_vec**2)
       beta_vec = beta_vec / beta_vec**1
    end subroutine get_boost_parameters

    function create_longitudinal_boost (beta_gamma, beta_vec, inverse) result (lambda)
       real(default), intent(in) :: beta_gamma
       type(vector3_t), intent(in) :: beta_vec
       logical, intent(in) :: inverse
       type(lorentz_transformation_t) :: lambda
       if (inverse) then
          lambda = boost (beta_gamma, beta_vec)
       else
          lambda = boost (-beta_gamma, beta_vec)
       end if
    end function create_longitudinal_boost

    function create_transversal_boost (p_rad, xi, sqrts_real) result (lambda)
       type(vector4_t), intent(in) :: p_rad
       real(default), intent(in) :: xi, sqrts_real
       type(lorentz_transformation_t) :: lambda
       type(vector3_t) :: vec_transverse
       real(default) :: pt2, beta, beta_gamma
       pt2 = transverse_part(p_rad)**2
       beta = one / sqrt (one + sqrts_real**2 * (one - xi) / pt2)
       beta_gamma = beta / sqrt (one - beta**2)
       vec_transverse%p(1:2) = p_rad%p(1:2)
       vec_transverse%p(3) = zero
       call normalize (vec_transverse)
       lambda = boost (-beta_gamma, vec_transverse)
    end function create_transversal_boost
  end subroutine phs_fks_generator_generate_isr

@ %def phs_fks_generator_generate_isr
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: set_beam_energy => phs_fks_generator_set_beam_energy
<<phs fks: procedures>>=
  pure subroutine phs_fks_generator_set_beam_energy (generator, sqrts)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: sqrts
    generator%sqrts = sqrts
    generator%isr_kinematics%beam_energy = sqrts / two
  end subroutine phs_fks_generator_set_beam_energy

@ %def phs_fks_generator_set_beam_energy
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: set_emitters => phs_fks_generator_set_emitters
<<phs fks: procedures>>=
  subroutine phs_fks_generator_set_emitters (generator, emitters)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in), dimension(:), allocatable ::  emitters
    allocate (generator%emitters (size (emitters)))
    generator%emitters = emitters
  end subroutine phs_fks_generator_set_emitters

@ %def phs_fks_generator_set_emitters
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: setup_masses => phs_fks_generator_setup_masses
<<phs fks: procedures>>=
  subroutine phs_fks_generator_setup_masses (generator, n_tot)
    class (phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: n_tot
    if (.not. allocated (generator%m2)) then
       allocate (generator%is_massive (n_tot))
       allocate (generator%m2 (n_tot))
       generator%is_massive = .false.
       generator%m2 = zero
    end if
  end subroutine phs_fks_generator_setup_masses

@ %def phs_fks_generator_setup_masses
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: set_isr_kinematics => phs_fks_generator_set_isr_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_generator_set_isr_kinematics (generator, p_born)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(vector4_t), dimension(2), intent(in), optional :: p_born
    type(vector4_t), dimension(2) :: p

    if (present (p_born)) then
       p = p_born
    else
       p = generator%real_kinematics%p_born_lab%phs_point(1)%p(1:2)
    end if

    generator%isr_kinematics%x = p%p(0) / (generator%sqrts/two)
  end subroutine phs_fks_generator_set_isr_kinematics

@ %def phs_fks_generator_set_isr_kinematics
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_radiation_variables => &
     phs_fks_generator_generate_radiation_variables
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_radiation_variables &
                    (generator, r_in, p_born, phs_identifiers)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in), dimension(:) :: r_in
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers

    if (any (generator%emitters <= 2) .and. generator%n_in > 1) &
        call generator%set_isr_kinematics &
           (generator%real_kinematics%p_born_lab%phs_point(1)%p(1:2))

    associate (rad_var => generator%real_kinematics)
       rad_var%phi = r_in (I_PHI) * twopi
       select case (generator%mode)
       case (GEN_REAL_PHASE_SPACE)
          rad_var%jac_rand = twopi
       case (GEN_SOFT_MISMATCH)
          rad_var%jac_mismatch = twopi
       end select
       call generator%compute_xi_tilde (r_in(I_XI))
       call generator%set_masses (p_born, phs_identifiers)
       call generator%compute_y (r_in(I_Y), p_born, phs_identifiers)
    end associate
  end subroutine phs_fks_generator_generate_radiation_variables

@ %def phs_fks_generator_generate_radiation_variables
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_xi_ref_momenta => phs_fks_generator_compute_xi_ref_momenta
<<phs fks: procedures>>=
  pure subroutine phs_fks_generator_compute_xi_ref_momenta &
         (generator, p_born, resonance_contributors)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(resonance_contributors_t), intent(in), dimension(:), optional &
       :: resonance_contributors
    integer :: i_con, n_contributors
    if (present (resonance_contributors)) then
       n_contributors = size (resonance_contributors)
       if (.not. allocated (generator%resonance_contributors)) &
          allocate (generator%resonance_contributors (n_contributors))
       do i_con = 1, n_contributors
          generator%real_kinematics%xi_ref_momenta(i_con) = &
               get_resonance_momentum (p_born, resonance_contributors(i_con)%c)
          generator%resonance_contributors(i_con) = resonance_contributors(i_con)
       end do
    else
       generator%real_kinematics%xi_ref_momenta(1) = sum (p_born(1:generator%n_in))
    end if
  end subroutine phs_fks_generator_compute_xi_ref_momenta

@ %def phs_fks_generator_compute_xi_ref_momenta
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_cms_energy => phs_fks_generator_compute_cms_energy
<<phs fks: procedures>>=
  subroutine phs_fks_generator_compute_cms_energy (generator, p_born)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t) :: p_sum
    p_sum = sum (p_born (1 : generator%n_in))
    generator%real_kinematics%cms_energy2 = p_sum**2
  end subroutine phs_fks_generator_compute_cms_energy

@ %def phs_fks_generator_compute_cms_energy
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_xi_max => phs_fks_generator_compute_xi_max
<<phs fks: procedures>>=
  subroutine phs_fks_generator_compute_xi_max (generator, emitter, i_phs, p, i_con)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: i_phs, emitter
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_con
    real(default) :: q0
    type(vector4_t), dimension(:), allocatable :: pp
    type(vector4_t) :: p_res
    type(lorentz_transformation_t) :: L_to_resonance
    integer :: ii_con
    if (.not. any (generator%emitters == emitter)) return
    ii_con = 1; if (present (i_con)) ii_con = i_con
    allocate (pp (size (p)))
    associate (rad_var => generator%real_kinematics)
       q0 = rad_var%xi_ref_momenta(ii_con)**1 
       select case (generator%n_in)
       case (1)
          if (emitter > 1) then
             if (generator%is_massive(emitter)) then
                rad_var%xi_max(i_phs) = get_xi_max_fsr &
                   (p, q0, emitter, generator%m2(emitter), rad_var%y(i_phs))
             else
                rad_var%xi_max(i_phs) = get_xi_max_fsr (p, q0, emitter)
             end if
          else
             rad_var%xi_max(i_phs) = get_xi_max_isr_decay (p)
          end if
       case (2)
          if (present (i_con)) then
             p_res = rad_var%xi_ref_momenta(ii_con)
             L_to_resonance = inverse (boost (p_res, q0))
             pp = L_to_resonance * p
          else
             pp = p
          end if
          if (generator%is_massive(emitter)) then
             if (emitter <= 2) then
                call msg_fatal ("Massive emitters" // &
                   "incompatible with IS scattering phase space")
             else
                rad_var%xi_max(i_phs) = get_xi_max_fsr &
                   (pp, q0, emitter, generator%m2(emitter), rad_var%y(i_phs)) 
             end if
          else
             if (emitter <= 2) then
                rad_var%xi_max(i_phs) = get_xi_max_isr &
                   (generator%isr_kinematics%x, rad_var%y(i_phs))
             else
                rad_var%xi_max(i_phs) = get_xi_max_fsr (pp, q0, emitter)
             end if
          end if
       case default
          call msg_fatal ("Real phase space: " // &
             "Only 1 or 2 initial particles supported")
       end select
    end associate
  end subroutine phs_fks_generator_compute_xi_max

@ %def phs_fks_generator_compute_xi_max
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_xi_max_isr_factorized &
     => phs_fks_generator_compute_xi_max_isr_factorized
<<phs fks: procedures>>=
  subroutine phs_fks_generator_compute_xi_max_isr_factorized &
     (generator, i_phs, p)
    class(phs_fks_generator_t), intent(inout) :: generator
    integer, intent(in) :: i_phs
    type(vector4_t), intent(in), dimension(:) :: p
    generator%real_kinematics%xi_max(i_phs) = get_xi_max_isr_decay (p)
  end subroutine phs_fks_generator_compute_xi_max_isr_factorized

@ %def phs_fks_generator_compute_xi_max_isr_factorized
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: set_masses => phs_fks_generator_set_masses
<<phs fks: procedures>>=
  subroutine phs_fks_generator_set_masses (generator, p, phs_identifiers)
    class(phs_fks_generator_t), intent(inout) :: generator
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    type(vector4_t), intent(in), dimension(:) :: p
    integer :: emitter, i_phs
    do i_phs = 1, size (phs_identifiers)
       emitter = phs_identifiers(i_phs)%emitter
       if (any (generator%emitters == emitter)) then
          if (generator%is_massive (emitter) .and. emitter > generator%n_in) &
             generator%m2(emitter) = p(emitter)**2
       end if
    end do
  end subroutine phs_fks_generator_set_masses

@ %def phs_fhs_generator_set_masses
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_y => phs_fks_generator_compute_y
<<phs fks: procedures>>=
  subroutine phs_fks_generator_compute_y (generator, r_y, p, phs_identifiers)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: r_y
    type(vector4_t), intent(in), dimension(:) :: p
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    integer :: emitter, i_phs
    real(default) :: beta, one_p_beta, one_m_beta
    type(lorentz_transformation_t) :: boost_to_resonance
    real(default) :: q0
    type(vector4_t) :: p_res, p_em
    integer :: i
    real(default), parameter :: tiny_scale = 0.01_default
    real(default) :: theta2_min
    associate (rad_var => generator%real_kinematics)
       select case (generator%mode)
       case (GEN_REAL_PHASE_SPACE)
          do i_phs = 1, size (phs_identifiers)
             emitter = phs_identifiers(i_phs)%emitter 
             p_res = vector4_null
             if (any (generator%emitters == emitter)) then
                if (generator%is_massive (emitter) .and. emitter > generator%n_in) then
                   if (allocated (phs_identifiers(i_phs)%contributors)) then
                      associate (contributors => phs_identifiers(i_phs)%contributors)
                         do i = 1, size (contributors)
                            p_res = p_res + p(contributors(i))
                         end do
                         q0 = p_res**1
                         boost_to_resonance = inverse (boost (p_res, q0))
                         p_em = boost_to_resonance * p(emitter)
                      end associate
                   else
                       q0 = generator%sqrts
                       p_em = p(emitter)
                   end if
                   beta = beta_emitter (q0, p_em)
                   one_m_beta = one - beta
                   one_p_beta = one + beta
                   rad_var%y(i_phs) = one / beta * (one - one_p_beta * &
                       exp ( - r_y * log(one_p_beta / one_m_beta)))
                   rad_var%jac_rand(i_phs) = rad_var%jac_rand(i_phs) * &
                       (one - beta * rad_var%y(i_phs)) * log(one_p_beta / one_m_beta) / beta
                else
                   rad_var%y(i_phs) = (one - two * r_y) * generator%y_max
                   rad_var%jac_rand(i_phs) = rad_var%jac_rand(i_phs) * 3 * (one - rad_var%y(i_phs)**2)
                   rad_var%y(i_phs) = 1.5_default * (rad_var%y(i_phs) - rad_var%y(i_phs)**3/3)
                end if
             end if
          end do
       case (GEN_SOFT_MISMATCH)
          rad_var%y_mismatch = (one - two * r_y) * generator%y_max
          rad_var%jac_mismatch = rad_var%jac_mismatch * 3 * (one - rad_var%y_mismatch**2)
          rad_var%y_mismatch = 1.5_default * (rad_var%y_mismatch - rad_var%y_mismatch**3 / 3)
          rad_var%y_soft = rad_var%y_mismatch
       case (GEN_SOFT_LIMIT_TEST)
          rad_var%y = y_test_soft
       case (GEN_COLL_LIMIT_TEST)
          rad_var%y = y_test_coll
       case (GEN_SOFT_COLL_LIMIT_TEST)
          rad_var%y = y_test_coll
       end select
    end associate
  end subroutine phs_fks_generator_compute_y

@ %def phs_fks_generator_compute_y
@
<<phs fks: public>>=
  public :: beta_emitter
<<phs fks: procedures>>=
  pure function beta_emitter (q0, p) result (beta)
    real(default), intent(in) :: q0
    type(vector4_t), intent(in) :: p
    real(default) :: beta
    real(default) :: m2, mrec2, k0_max
    m2 = p**2
    mrec2 = (q0 - p%p(0))**2 - p%p(1)**2 - p%p(2)**2 - p%p(3)**2
    k0_max = (q0**2 - mrec2 + m2) / (two * q0)
    beta = sqrt(one - m2 / k0_max**2)
  end function beta_emitter

@ %def beta_emitter
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: compute_xi_tilde => phs_fks_generator_compute_xi_tilde
<<phs fks: procedures>>=
  pure subroutine phs_fks_generator_compute_xi_tilde (generator, r)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: r
    real(default) :: deno
    associate (rad_var => generator%real_kinematics)
       select case (generator%mode)
       case (GEN_REAL_PHASE_SPACE) 
          if (generator%singular_jacobian) then
             rad_var%xi_tilde = (one - generator%xi_min) - (one - r)**2 *&
                (one - two * generator%xi_min)
             rad_var%jac_rand = rad_var%jac_rand * two * (one - r) * &
                (one - two * generator%xi_min)
          else
             rad_var%xi_tilde = generator%xi_min + r * (one - generator%xi_min)
             rad_var%jac_rand = rad_var%jac_rand * (one - generator%xi_min)
          end if
       case (GEN_SOFT_MISMATCH)
          deno = one - r
          if (deno < tiny_13) deno = tiny_13
          rad_var%xi_mismatch = generator%xi_min + r / deno
          rad_var%jac_mismatch = rad_var%jac_mismatch / deno**2
       case (GEN_SOFT_LIMIT_TEST)
          rad_var%xi_tilde = r * two * xi_tilde_test_soft
          rad_var%jac_rand = two * xi_tilde_test_soft
       case (GEN_COLL_LIMIT_TEST)
          rad_var%xi_tilde = xi_tilde_test_coll
          rad_var%jac_rand = xi_tilde_test_coll
       case (GEN_SOFT_COLL_LIMIT_TEST)
          rad_var%xi_tilde = r * two * xi_tilde_test_soft
          rad_var%jac_rand = two * xi_tilde_test_soft
       end select
    end associate
  end subroutine phs_fks_generator_compute_xi_tilde

@ %def phs_fks_generator_compute_xi_tilde
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: prepare_generation => phs_fks_generator_prepare_generation
<<phs fks: procedures>>=
  subroutine phs_fks_generator_prepare_generation (generator, r_in, i_phs, &
     emitter, p_born, phs_identifiers, contributors, i_con)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), dimension(3), intent(in) :: r_in
    integer, intent(in) :: i_phs, emitter
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    type(resonance_contributors_t), intent(in), dimension(:), optional :: contributors
    integer, intent(in), optional :: i_con
    call generator%generate_radiation_variables (r_in, p_born, phs_identifiers)
    call generator%compute_xi_ref_momenta (p_born, contributors)
    call generator%compute_xi_max (emitter, i_phs, p_born, i_con) 
  end subroutine phs_fks_generator_prepare_generation

@ %def phs_fks_generator_prepare_generation
@ Get [[xi]] and [[y]] from an external routine (e.g. [[powheg]]) and
generate an FSR phase space. Note that the flag [[supply\_xi\_max]] is
set to [[.false.]] because it is assumed that the upper bound on [[xi]]
has already been taken into account during its generation.
<<phs fks: phs fks generator: TBP>>=
  procedure :: generate_fsr_from_xi_and_y => &
     phs_fks_generator_generate_fsr_from_xi_and_y
<<phs fks: procedures>>=
  subroutine phs_fks_generator_generate_fsr_from_xi_and_y (generator, xi, y, &
     phi, emitter, i_phs, p_born, p_real)
    class(phs_fks_generator_t), intent(inout) :: generator
    real(default), intent(in) :: xi, y, phi
    integer, intent(in) :: emitter, i_phs
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(phs_point_t), intent(inout) :: p_real
    associate (rad_var => generator%real_kinematics)
       rad_var%supply_xi_max = .false.
       rad_var%xi_tilde = xi
       rad_var%y(i_phs) = y
       rad_var%phi = phi
    end associate
    call generator%set_beam_energy (p_born(1)%p(0) + p_born(2)%p(0))
    call generator%generate_fsr (emitter, i_phs, p_born, p_real)
  end subroutine phs_fks_generator_generate_fsr_from_xi_and_y

@ %def phs_fks_generator_generate_fsr_from_xi_and_y
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: get_radiation_variables => &
     phs_fks_generator_get_radiation_variables
<<phs fks: procedures>>=
  pure subroutine phs_fks_generator_get_radiation_variables (generator, &
     i_phs, xi, y, phi)
    class(phs_fks_generator_t), intent(in) :: generator
    integer, intent(in) :: i_phs
    real(default), intent(out) :: xi, y
    real(default), intent(out), optional :: phi
    associate (rad_var => generator%real_kinematics)
       xi = rad_var%xi_max(i_phs) * rad_var%xi_tilde
       y = rad_var%y(i_phs)
       if (present (phi)) phi = rad_var%phi
    end associate
  end subroutine phs_fks_generator_get_radiation_variables

@ %def phs_fks_generator_get_radiation_variables
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: get_jacobian => phs_fks_generator_get_jacobian
<<phs fks: procedures>>=
  subroutine phs_fks_generator_get_jacobian (generator, emitter, jac)
    class(phs_fks_generator_t), intent(in) :: generator
    integer, intent(in) :: emitter
    real(default) :: jac
    associate (rad_var => generator%real_kinematics)
       jac = rad_var%jac_rand (emitter) * rad_var%jac(emitter)%jac(1)
    end associate
  end subroutine phs_fks_generator_get_jacobian

@ %def phs_fks_generator_get_jacobian
@
<<phs fks: phs fks generator: TBP>>=
  procedure :: write => phs_fks_generator_write
<<phs fks: procedures>>=
  subroutine phs_fks_generator_write (generator, unit)
    class(phs_fks_generator_t), intent(in) :: generator
    integer, intent(in), optional :: unit
    integer :: u
    type(string_t) :: massive_phsp
    u = given_output_unit (unit); if (u < 0) return
    if (generator%massive_phsp) then
       massive_phsp = " massive "
    else
       massive_phsp = " massless "
    end if
    write (u, "(A)") char ("This is a generator for a" &
         // massive_phsp // "phase space")
    if (associated (generator%real_kinematics)) then
       call generator%real_kinematics%write ()
    else
       write (u, "(A)") "Warning: There are no real " // &
            "kinematics associated with this generator"
    end if
    call write_separator (u)
    write (u, "(A,F5.3)") "sqrts: ", generator%sqrts
    write (u, "(A,F5.3)") "E_gluon: ", generator%E_gluon
    write (u, "(A,F5.3)") "mrec2: ", generator%mrec2
  end subroutine phs_fks_generator_write

@ %def phs_fks_generator_write
@
<<phs fks: phs fks: TBP>>=
  procedure :: compute_isr_kinematics => phs_fks_compute_isr_kinematics
<<phs fks: procedures>>=
  subroutine phs_fks_compute_isr_kinematics (phs, r)
    class(phs_fks_t), intent(inout) :: phs
    real(default), intent(in) :: r
    call phs%generator%compute_isr_kinematics (r)
  end subroutine phs_fks_compute_isr_kinematics

@ %def phs_fks_compute_isr_kinematics
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[phs_fks_ut.f90]]>>=
<<File header>>

module phs_fks_ut
  use unit_tests
  use phs_fks_uti

<<Standard module head>>

<<phs fks: public test>>

contains

<<phs fks: test driver>>

end module phs_fks_ut
@ %def phs_fks_ut
@
<<[[phs_fks_uti.f90]]>>=
<<File header>>

module phs_fks_uti

<<Use kinds>>
  use format_utils, only: write_separator, pac_fmt
  use format_defs, only: FMT_15, FMT_19
  use constants, only: tiny_07, zero
  use lorentz

  use ttv_formfactors, only: THR_POS_B, THR_POS_BBAR

  use cascades, only: resonance_contributors_t
  use phs_fks
  use nlo_data, only: phs_identifier_t

<<Standard module head>>

<<phs fks: test declarations>>

contains

<<phs fks: tests>>

end module phs_fks_uti
@ %def phs_fks_ut
@ API: driver for the unit tests below.
<<phs fks: public test>>=
  public :: phs_fks_generator_test
<<phs fks: test driver>>=
  subroutine phs_fks_generator_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test(phs_fks_generator_1, "phs_fks_generator_1", &
       "Test the generation of FKS phase spaces", u, results)
    call test(phs_fks_generator_2, "phs_fks_generator_2", &
       "Test the generation of an ISR FKS phase space", u, results)
    call test(phs_fks_generator_3, "phs_fks_generator_3", &
       "Test the generation of a real phase space for decays", &
       u, results)
    call test(phs_fks_generator_4, "phs_fks_generator_4", &
       "Test the generation of an FSR phase space with "&
       &"conserved invariant resonance masses", u, results)
    call test(phs_fks_generator_5, "phs_fks_generator_5", &
       "Test the phase space generation for the factorized threshold computation", &
       u, results)       
  end subroutine phs_fks_generator_test

@ %def phs_fks_generator_test
@
<<phs fks: test declarations>>=
  public :: phs_fks_generator_1
<<phs fks: tests>>=
  subroutine phs_fks_generator_1 (u)
    integer, intent(in) :: u
    type(phs_fks_generator_t) :: generator
    type(vector4_t), dimension(:), allocatable :: p_born
    type(phs_point_t) :: p_real
    integer :: emitter, i_phs
    real(default) :: x1, x2, x3
    real(default), parameter :: sqrts = 250.0_default
    type(phs_identifier_t), dimension(2) :: phs_identifiers
    write (u, "(A)") "* Test output: phs_fks_generator_1"
    write (u, "(A)") "* Purpose: Create massless fsr phase space"
    write (u, "(A)")


    allocate (p_born (4))
    p_born(1)%p(0) = 125.0_default
    p_born(1)%p(1:2) = 0.0_default
    p_born(1)%p(3) = 125.0_default
    p_born(2)%p(0) = 125.0_default
    p_born(2)%p(1:2) = 0.0_default
    p_born(2)%p(3) = -125.0_default
    p_born(3)%p(0) = 125.0_default
    p_born(3)%p(1) = -39.5618_default
    p_born(3)%p(2) = -20.0791_default
    p_born(3)%p(3) = -114.6957_default
    p_born(4)%p(0) = 125.0_default
    p_born(4)%p(1:3) = -p_born(3)%p(1:3)

    allocate (generator%isr_kinematics)
    generator%n_in = 2

    call generator%set_beam_energy (sqrts)

    write (u, "(A)") "* Use four-particle phase space containing: "
    call vector4_write_set (p_born, u, testflag = .true., ultra = .true.)
    write (u, "(A)") "***********************"
    write (u, "(A)")

    x1 = 0.5_default; x2 = 0.25_default; x3 = 0.75_default
    write (u, "(A)" ) "* Use random numbers: "
    write (u, "(A,F3.2,1X,A,F3.2,1X,A,F3.2)") &
       "x1: ", x1, "x2: ", x2, "x3: ", x3

    allocate (generator%real_kinematics)
    call generator%real_kinematics%init (4, 2, 2, 1)

    allocate (generator%emitters (2))
    generator%emitters(1) = 3; generator%emitters(2) = 4
    allocate (generator%m2 (4))
    generator%m2 = zero
    allocate (generator%is_massive (4))
    generator%is_massive(1:2) = .false.
    generator%is_massive(3:4) = .true.
    phs_identifiers(1)%emitter = 3
    phs_identifiers(2)%emitter = 4
    call generator%compute_xi_ref_momenta (p_born)
    call generator%generate_radiation_variables ([x1,x2,x3], p_born, phs_identifiers)
    do i_phs = 1, 2
       emitter = phs_identifiers(i_phs)%emitter
       call generator%compute_xi_max (emitter, i_phs, p_born)
    end do
    write (u, "(A)")  &
         "* With these, the following radiation variables have been produced:"
    associate (rad_var => generator%real_kinematics)
      write (u, "(A,F3.2)") "xi_tilde: ", rad_var%xi_tilde
      write (u, "(A,F3.2)") "y: " , rad_var%y(1)
      write (u, "(A,F3.2)") "phi: ", rad_var%phi
    end associate
    call write_separator (u)
    write (u, "(A)") "Produce real momenta: "
    i_phs = 1; emitter = phs_identifiers(i_phs)%emitter
    write (u, "(A,I1)") "emitter: ", emitter
    p_real = 5
    call generator%generate_fsr (emitter, i_phs, p_born, p_real)
    call vector4_write_set (p_real%p, u, testflag = .true., ultra = .true.)
    call write_separator (u)
    write (u, "(A)")
    write (u, "(A)") "* Test output end: phs_fks_generator_1"

  end subroutine phs_fks_generator_1

@ %def phs_fks_generator_1
@
<<phs fks: test declarations>>=
  public :: phs_fks_generator_2
<<phs fks: tests>>=
  subroutine phs_fks_generator_2 (u)
    integer, intent(in) :: u
    type(phs_fks_generator_t) :: generator
    type(vector4_t), dimension(:), allocatable :: p_born
    type(phs_point_t) :: p_real
    integer :: emitter, i_phs
    real(default) :: x1, x2, x3
    real(default), parameter :: sqrts_hadronic = 250.0_default
    type(phs_identifier_t), dimension(2) :: phs_identifiers
    write (u, "(A)") "* Test output: phs_fks_generator_2"
    write (u, "(A)") "* Purpose: Create massless ISR phase space"
    write (u, "(A)")


    allocate (p_born (4))
    p_born(1)%p(0) = 114.661_default
    p_born(1)%p(1:2) = 0.0_default
    p_born(1)%p(3) = 114.661_default
    p_born(2)%p(0) = 121.784_default
    p_born(2)%p(1:2) = 0.0_default
    p_born(2)%p(3) = -121.784_default
    p_born(3)%p(0) = 115.148_default
    p_born(3)%p(1) = -46.250_default
    p_born(3)%p(2) = -37.711_default
    p_born(3)%p(3) = 98.478_default
    p_born(4)%p(0) = 121.296_default
    p_born(4)%p(1:2) = -p_born(3)%p(1:2)
    p_born(4)%p(3) = -105.601_default

    phs_identifiers(1)%emitter = 1
    phs_identifiers(2)%emitter = 2

    allocate (generator%emitters (2))
    allocate (generator%isr_kinematics)
    generator%n_in = 2
    generator%emitters(1) = 1; generator%emitters(2) = 2
    call generator%set_beam_energy (sqrts_hadronic)
    call generator%set_isr_kinematics (p_born)

    write (u, "(A)") "* Use four-particle phase space containing: "
    call vector4_write_set (p_born, u, testflag = .true., ultra = .true.)
    write (u, "(A)") "***********************"
    write (u, "(A)")

    x1=0.5_default; x2=0.25_default; x3=0.65_default
    write (u, "(A)" ) "* Use random numbers: "
    write (u, "(A,F3.2,1X,A,F3.2,1X,A,F3.2)") &
       "x1: ", x1, "x2: ", x2, "x3: ", x3

    allocate (generator%real_kinematics)
    call generator%real_kinematics%init (4, 2, 2, 1)
    call generator%real_kinematics%p_born_lab%set_momenta (1, p_born)

    allocate (generator%m2 (2))
    generator%m2(1) = 0._default; generator%m2(2) = 0._default
    allocate (generator%is_massive (4))
    generator%is_massive = .false.
    call generator%generate_radiation_variables ([x1,x2,x3], p_born, phs_identifiers)
    call generator%compute_xi_ref_momenta (p_born)
    do i_phs = 1, 2
       emitter = phs_identifiers(i_phs)%emitter
       call generator%compute_xi_max (emitter, i_phs, p_born)
    end do
    write (u, "(A)")  &
         "* With these, the following radiation variables have been produced:"
    associate (rad_var => generator%real_kinematics)
      write (u, "(A,F3.2)") "xi_tilde: ", rad_var%xi_tilde
      write (u, "(A,F3.2)") "y: " , rad_var%y(1)
      write (u, "(A,F3.2)") "phi: ", rad_var%phi
    end associate
    write (u, "(A)") "Initial-state momentum fractions: "
    associate (xb => generator%isr_kinematics%x)
       write (u, "(A,F3.2)") "x_born_plus: ", xb(1)
       write (u, "(A,F3.2)") "x_born_minus: ", xb(2)
    end associate
    call write_separator (u)
    write (u, "(A)") "Produce real momenta: "
    i_phs = 1; emitter = phs_identifiers(i_phs)%emitter
    write (u, "(A,I1)") "emitter: ", emitter
    p_real = 5
    call generator%generate_isr (i_phs, p_born, p_real)
    call vector4_write_set (p_real%p, u, testflag = .true., ultra = .true.)
    call write_separator (u)
    write (u, "(A)")
    write (u, "(A)") "* Test output end: phs_fks_generator_2"

  end subroutine phs_fks_generator_2

@ %def phs_fks_generator_2
@
<<phs fks: test declarations>>=
  public :: phs_fks_generator_3
<<phs fks: tests>>=
  subroutine phs_fks_generator_3 (u)
    integer, intent(in) :: u
    type(phs_fks_generator_t) :: generator
    type(vector4_t), dimension(:), allocatable :: p_born
    type(phs_point_t) :: p_real
    real(default) :: x1, x2, x3
    real(default) :: mB, mW, mT
    integer :: i, emitter, i_phs
    type(phs_identifier_t), dimension(2) :: phs_identifiers

    write (u, "(A)") "* Test output: phs_fks_generator_3"
    write (u, "(A)") "* Puropse: Create real phase space for particle decays"
    write (u, "(A)")

    allocate (p_born(3))
    p_born(1)%p(0) = 172._default
    p_born(1)%p(1) = 0._default
    p_born(1)%p(2) = 0._default
    p_born(1)%p(3) = 0._default
    p_born(2)%p(0) = 104.72866679_default
    p_born(2)%p(1) = 45.028053213_default
    p_born(2)%p(2) = 29.450337581_default
    p_born(2)%p(3) = -5.910229156_default
    p_born(3)%p(0) = 67.271333209_default
    p_born(3)%p(1:3) = -p_born(2)%p(1:3)

    generator%n_in = 1

    mB = 4.2_default
    mW = 80.376_default
    mT = 172._default

    generator%sqrts = mT

    write (u, "(A)") "* Use three-particle phase space containing: "
    call vector4_write_set (p_born, u, testflag = .true., &
       show_mass = .true., ultra = .true.)
    write (u, "(A)") "**********************"
    write (u, "(A)")

    x1=0.5_default; x2=0.25_default; x3=0.6_default
    write (u, "(A)") "* Use random numbers: "
    write (u, "(A,F3.2,1X,A,F3.2,A,1X,F3.2)") &
       "x1: ", x1, "x2: ", x2, "x3: ", x3

    allocate (generator%real_kinematics)
    call generator%real_kinematics%init (3, 2, 2, 1)
    call generator%real_kinematics%p_born_lab%set_momenta (1, p_born)

    allocate (generator%emitters(2))
    generator%emitters(1) = 1
    generator%emitters(2) = 3
    allocate (generator%m2 (3), generator%is_massive(3))
    generator%m2(1) = mT**2
    generator%m2(2) = mW**2
    generator%m2(3) = mB**2
    generator%is_massive = .true.
    phs_identifiers(1)%emitter = 1
    phs_identifiers(2)%emitter = 3

    call generator%generate_radiation_variables ([x1,x2,x3], p_born, phs_identifiers)
    call generator%compute_xi_ref_momenta (p_born)
    do i_phs = 1, 2
       emitter = phs_identifiers(i_phs)%emitter 
       call generator%compute_xi_max (emitter, i_phs, p_born)
    end do

    write (u, "(A)") &
       "* With these, the following radiation variables have been produced: "
    associate (rad_var => generator%real_kinematics)
      write (u, "(A,F4.2)") "xi_tilde: ", rad_var%xi_tilde
      do i = 1, 2
         write (u, "(A,I1,A,F5.2)") "i: ", i, "y: " , rad_var%y(i)
      end do
      write (u, "(A,F4.2)") "phi: ", rad_var%phi
    end associate

    call write_separator (u)
    write (u, "(A)") "Produce real momenta via initial-state emission: "
    i_phs = 1; emitter = phs_identifiers(i_phs)%emitter
    write (u, "(A,I1)") "emitter: ", emitter
    p_real = 4
    call generator%generate_isr_decay (i_phs, p_born, p_real)
    call pacify (p_real%p, 1E-6_default)
    call vector4_write_set (p_real%p, u, testflag = .true., &
         show_mass = .true., ultra = .true.)
    call write_separator(u)
    write (u, "(A)") "Produce real momenta via final-state emisson: "
    i_phs = 2; emitter = phs_identifiers(i_phs)%emitter
    write (u, "(A,I1)") "emitter: ", emitter
    call generator%generate_fsr (emitter, i_phs, p_born, p_real)
    call pacify (p_real%p, 1E-6_default)
    call vector4_write_set (p_real%p, u, testflag = .true., &
         show_mass = .true., ultra = .true.)
    write (u, "(A)")
    write (u, "(A)") "* Test output end: phs_fks_generator_3"

  end subroutine phs_fks_generator_3

@ %def phs_fks_generator_3
@
<<phs fks: test declarations>>=
  public :: phs_fks_generator_4
<<phs fks: tests>>=
  subroutine phs_fks_generator_4 (u)
    integer, intent(in) :: u
    type(phs_fks_generator_t) :: generator
    type(vector4_t), dimension(:), allocatable :: p_born
    type(phs_point_t) :: p_real
    integer, dimension(:), allocatable :: emitters
    integer, dimension(:,:), allocatable :: resonance_lists
    type(resonance_contributors_t), dimension(2) :: alr_contributors
    real(default) :: x1, x2, x3
    real(default), parameter :: sqrts = 250.0_default
    integer, parameter :: nlegborn = 6
    integer :: i_phs, i_con, emitter
    real(default) :: m_inv_born, m_inv_real
    character(len=7) :: fmt
    type(phs_identifier_t), dimension(2) :: phs_identifiers

    call pac_fmt (fmt, FMT_19, FMT_15, .true.)

    write (u, "(A)") "* Test output: phs_fks_generator_4"
    write (u, "(A)") "* Purpose: Create FSR phase space with fixed resonances"
    write (u, "(A)")

    allocate (p_born (nlegborn))
    p_born(1)%p(0) = 250._default
    p_born(1)%p(1) = 0._default
    p_born(1)%p(2) = 0._default
    p_born(1)%p(3) = 250._default
    p_born(2)%p(0) = 250._default
    p_born(2)%p(1) = 0._default
    p_born(2)%p(2) = 0._default
    p_born(2)%p(3) = -250._default
    p_born(3)%p(0) = 145.91184486_default
    p_born(3)%p(1) = 50.39727589_default
    p_born(3)%p(2) = 86.74156041_default
    p_born(3)%p(3) = -69.03608748_default
    p_born(4)%p(0) = 208.1064784_default
    p_born(4)%p(1) = -44.07610020_default
    p_born(4)%p(2) = -186.34264578_default
    p_born(4)%p(3) = 13.48038407_default
    p_born(5)%p(0) = 26.25614471_default
    p_born(5)%p(1) = -25.12258068_default
    p_born(5)%p(2) = -1.09540228_default
    p_born(5)%p(3) = -6.27703505_default
    p_born(6)%p(0) = 119.72553196_default
    p_born(6)%p(1) = 18.80140499_default
    p_born(6)%p(2) = 100.69648766_default
    p_born(6)%p(3) = 61.83273846_default

    allocate (generator%isr_kinematics)
    generator%n_in = 2

    call generator%set_beam_energy (sqrts)

    write (u, "(A)") "* Test process: e+ e- -> W+ W- b b~"
    write (u, "(A)") "* Resonance pairs: (3,5) and (4,6)"
    write (u, "(A)") "* Use four-particle phase space containing: "
    call vector4_write_set (p_born, u, testflag = .true., ultra = .true.)
    write (u, "(A)") "******************************"
    write (u, "(A)")

    x1 = 0.5_default; x2 = 0.25_default; x3 = 0.75_default
    write (u, "(A)") "* Use random numbers: "
    write (u, "(A,F3.2,1X,A,F3.2,1X,A,F3.2)") &
       "x1: ", x1, "x2: ", x2, "x3: ", x3

    allocate (generator%real_kinematics)
    call generator%real_kinematics%init (nlegborn, 2, 2, 2)

    allocate (generator%emitters (2))
    generator%emitters(1) = 5; generator%emitters(2) = 6
    allocate (generator%m2 (nlegborn))
    generator%m2 = p_born**2
    allocate (generator%is_massive (nlegborn))
    generator%is_massive (1:2) = .false.
    generator%is_massive (3:6) = .true.

    phs_identifiers(1)%emitter = 5
    phs_identifiers(2)%emitter = 6
    do i_phs = 1, 2
       allocate (phs_identifiers(i_phs)%contributors (2))
    end do
    allocate (resonance_lists (2, 2))
    resonance_lists (1,:) = [3,5]
    resonance_lists (2,:) = [4,6]
    !!! Here is obviously some redundance. Surely we can improve on this.
    do i_phs = 1, 2
       phs_identifiers(i_phs)%contributors = resonance_lists(i_phs,:)
    end do
    do i_con = 1, 2
       allocate (alr_contributors(i_con)%c (size (resonance_lists(i_con,:))))
       alr_contributors(i_con)%c = resonance_lists(i_con,:)
    end do
    call generator%generate_radiation_variables &
       ([x1, x2, x3], p_born, phs_identifiers)

    p_real = nlegborn + 1
    call generator%compute_xi_ref_momenta (p_born, alr_contributors)
    !!! Keep the distinction between i_phs and i_con because in general,
    !!! they are not the same.
    do i_phs = 1, 2
       i_con = i_phs
       emitter = phs_identifiers(i_phs)%emitter
       write (u, "(A,I1,1X,A,I1,A,I1,A)") &
          "* Generate FSR phase space for emitter ", emitter, &
          "and resonance pair (",  resonance_lists (i_con, 1), ",", &
          resonance_lists (i_con, 2), ")"
       call generator%compute_xi_max (emitter, i_phs, p_born, i_con)
       call generator%generate_fsr (emitter, i_phs, i_con, p_born, p_real)
       call vector4_write_set (p_real%p, u, testflag = .true., ultra = .true.)
       call write_separator(u)
       write (u, "(A)") "* Check if resonance masses are conserved: "
       m_inv_born = compute_resonance_mass (p_born, resonance_lists (i_con,:))
       m_inv_real = compute_resonance_mass (p_real%p, resonance_lists (i_con,:), 7)
       write (u, "(A,1X, " // fmt // ")") "m_inv_born = ", m_inv_born
       write (u, "(A,1X, " // fmt // ")") "m_inv_real = ", m_inv_real
       if (abs (m_inv_born - m_inv_real) < tiny_07) then
          write (u, "(A)") " Success! "
       else
          write (u, "(A)") " Failure! "
       end if
       call write_separator(u)
       call write_separator(u)
    end do
    call p_real%final ()
    write (u, "(A)")
    write (u, "(A)") "* Test output end: phs_fks_generator_4"
  end subroutine phs_fks_generator_4

@ %def phs_fks_generator_4
@
<<phs fks: test declarations>>=
  public :: phs_fks_generator_5
<<phs fks: tests>>=
  subroutine phs_fks_generator_5 (u)
    integer, intent(in) :: u
    type(phs_fks_generator_t) :: generator
    type(vector4_t), dimension(:), allocatable :: p_born
    type(phs_point_t) :: p_real
    integer, dimension(:), allocatable :: emitters
    real(default) :: x1, x2, x3
    integer, parameter :: nlegborn = 6
    integer, parameter :: n_phs = 4, n_alr = 4, n_contr = 1
    integer :: i_phs, emitter
    type(phs_identifier_t), dimension(n_phs) :: phs_identifiers
    write (u, "(A)") "* Test output: phs_fks_generator_5"
    write (u, "(A)") "* Purpose: Create FSR phase space with fixed resonances"
    write (u, "(A)")

    allocate (p_born (nlegborn))
    p_born(1)%p(0) = 250._default
    p_born(1)%p(1) = 0._default
    p_born(1)%p(2) = 0._default
    p_born(1)%p(3) = 250._default
    p_born(2)%p(0) = 250._default
    p_born(2)%p(1) = 0._default
    p_born(2)%p(2) = 0._default
    p_born(2)%p(3) = -250._default
    p_born(3)%p(0) = 145.91184486_default
    p_born(3)%p(1) = 50.39727589_default
    p_born(3)%p(2) = 86.74156041_default
    p_born(3)%p(3) = -69.03608748_default
    p_born(4)%p(0) = 208.1064784_default
    p_born(4)%p(1) = -44.07610020_default
    p_born(4)%p(2) = -186.34264578_default
    p_born(4)%p(3) = 13.48038407_default
    p_born(5)%p(0) = 26.25614471_default
    p_born(5)%p(1) = -25.12258068_default
    p_born(5)%p(2) = -1.09540228_default
    p_born(5)%p(3) = -6.27703505_default
    p_born(6)%p(0) = 119.72553196_default
    p_born(6)%p(1) = 18.80140499_default
    p_born(6)%p(2) = 100.69648766_default
    p_born(6)%p(3) = 61.83273846_default

    allocate (generator%isr_kinematics)
    generator%n_in = 2
    p_real = nlegborn + 1

    call generator%set_beam_energy (250._default)

    write (u, "(A)") "* Test process: e+ e- -> W+ W- b b~"
    write (u, "(A)") "* Use four-particle phase space containing: "
    call vector4_write_set (p_born, u, testflag = .true., ultra = .true.)
    write (u, "(A)") "******************************"
    write (u, "(A)")

    x1 = 0.5_default; x2 = 0.25_default; x3 = 0.75_default
    write (u, "(A)") "* Use random numbers: "
    write (u, "(A,F3.2,1X,A,F3.2,1X,A,F3.2)") &
       "x1: ", x1, "x2: ", x2, "x3: ", x3

    allocate (generator%real_kinematics)
    call generator%real_kinematics%init (nlegborn, n_phs, n_alr, n_contr)
    allocate (generator%emitters (n_phs))
    generator%emitters([1,3]) = THR_POS_B; generator%emitters([2,4]) = THR_POS_BBAR
    allocate (generator%m2 (nlegborn))
    generator%m2 = p_born**2
    allocate (generator%is_massive (nlegborn))
    generator%is_massive (1:2) = .false.
    generator%is_massive (3:6) = .true.
    phs_identifiers([1,3])%emitter = THR_POS_B
    phs_identifiers([2,4])%emitter = THR_POS_BBAR
    call generator%generate_radiation_variables &
       ([x1, x2, x3], p_born, phs_identifiers)
    call generator%generate_isr_factorized &
       (3, phs_identifiers(3)%emitter, p_born, p_real)
    call vector4_write_set (p_real%p, u, testflag = .true., ultra = .true.)
    call write_separator (u)
    call generator%generate_isr_factorized &
       (4, phs_identifiers(4)%emitter, p_born, p_real)
    call vector4_write_set (p_real%p, u, testflag = .true., ultra = .true.)
    call write_separator (u)
    
  end subroutine phs_fks_generator_5

@ %def phs_fks_generator_5
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Subtraction of initial-state divergences}
We must calculate two terms, $G_\oplus$ and $G_\ominus$ for each
possible initial-state emitter.  Following the notation of 0709.2092,
this is separated into $G = \tilde{\mathcal{L}}\mathcal{G}$, such that
$\tilde{\mathcal{L}}$ contains the PDF-values at the scales, explicitly
\begin{align*}
  \tilde{\mathcal{L}} &=
  \begin{cases}
    \mathcal{L}(\bar{x}_\oplus/z, \bar{x}_\ominus) &\mbox{for} \alpha \in \mbox{ISR}_\oplus \\
    \mathcal{L}(\bar{x}_\oplus, \bar{x}_\ominus/z) &\mbox{for} \alpha \in \mbox{ISR}_\ominus
  \end{cases}
\end{align*}
For each flavor combination $f_\oplus$ and $f_\ominus$ of initial-state
particles, the relevant terms are given by
\begin{align*}
  \mathcal{G}_\oplus^{f_\oplus f_\ominus} (z) =
           \frac{\alpha_s}{2\pi}\sum_{f'_\oplus} &\left\lbrace (1-z)P^{f_\oplus f'_\ominus}(z,0)
           \left[\left(\frac{1}{1-z}\right)_+\log\frac{s}{2\mu_F^2} + 2\left(\frac{\log(1-z)}{1-z}\right)_+\right]\right.\\
           - \left.\left[\frac{\partial P^{f_\oplus f'_\oplus}(z,\epsilon)}{\partial \epsilon}\right]_{\epsilon=0}
           - K^{f_\oplus f'_\oplus}\right\rbrace \mathcal{B}^{f'_\oplus f_\ominus}(z)
\end{align*}
where $P(z,\epsilon)$ are the Altarelli-Parisi splitting functions
\begin{align*}
  P_{qq}(z,\epsilon) &= C_F \left[\frac{1+z^2}{1-z} - \epsilon(1-z)\right], \\
  P_{qg}(z,\epsilon) &= C_F \left[\frac{1+(1-z)^2}{z} - \epsilon z\right], \\
  P_{gq}(z,\epsilon) &= T_F \left[1 - \frac{2z(1-z)}{1-\epsilon}\right], \\
  P_{gg}(z,\epsilon) &= 2C_A \left[\frac{z}{1-z} + \frac{1-z}{z} + z(1-z)\right].
\end{align*}
In the code we deal with $\hat{P}^{f_\oplus f_\ominus}(z) =
(1-z)P^{f_\oplus f_\ominus}(z,0)$ because this quantity behaves nicely
in the limit $z \to 1$.  The factor $K^{f_\oplus f_\ominus}$ depends on
the renormalization scheme and vanishes for $\overline{MS}$.\\ The
second thing to consider is the fact that the integration over $z$ is
carried out over the interval $[\bar{x}_\oplus,1]$ or
$[\bar{x}_\ominus,1]$, respectively, but the plus-distribution can only
be evaluated over $[0,1]$. We thus use the identities
\begin{align*}
  \int_{\bar{x}_\oplus}^1 dz \left(\frac{1}{1-z}\right)_+ f(z) &= \log(1-\bar{x}_\oplus)f(1) + \int_{\bar{x}_\oplus}^1 dz \frac{f(z)-f(1)}{1-z}, \\
  \int_{\bar{x}_\oplus}^1 dz \left(\frac{\log(1-z)}{1-z}\right)_+ f(z) &= \frac{1}{2} \log^2(1-\bar{x}_\oplus) f(1) + \int_{\bar{x}_\oplus}^1 dz \frac{\log(1-z)[f(z)-f(1)]}{1-z}.
\end{align*}

<<[[pdf_subtraction.f90]]>>=
<<File header>>

module pdf_subtraction

<<Use kinds with double>>
<<Use strings>>
  use numeric_utils
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use diagnostics
  use constants
  use physics_defs
  use pdg_arrays
  use sf_lhapdf
  use pdf
  use nlo_data

<<Standard module head>>

<<pdf subtraction: public>>

<<pdf subtraction: types>>

contains

<<pdf subtraction: procedures>>

end module pdf_subtraction

@ %def module pdf_subtraction
@
<<pdf subtraction: public>>=
  public :: pdf_subtraction_t
<<pdf subtraction: types>>=
  type :: pdf_subtraction_t
    type(pdf_data_t) :: pdf_data
    logical :: required = .false.
    type(isr_kinematics_t), pointer :: isr_kinematics => null ()
    integer, dimension(:), allocatable :: i_light_quarks
    integer, dimension(2) :: flv_in
    type(pdf_container_t), dimension(2) :: pdf_scaled
    type(pdf_container_t), dimension(2) :: pdf_born
    real(default), dimension(:), pointer :: sqme_born => null ()
    real(default), dimension(:), allocatable :: value
  contains
  <<pdf subtraction: pdf subtraction: TBP>>
  end type pdf_subtraction_t

@ %def pdf_subtraction_t
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: init => pdf_subtraction_init
<<pdf subtraction: procedures>>=
  subroutine pdf_subtraction_init (pdf_sub, isr_kinematics, flv, n_alr, sqme_collector)
    class(pdf_subtraction_t), intent(inout) :: pdf_sub
    type(isr_kinematics_t), intent(in), target :: isr_kinematics
    integer, dimension(:,:), intent(in) :: flv
    integer, intent(in) :: n_alr
    type(sqme_collector_t), intent(in), target :: sqme_collector
    integer :: i, j, n_quarks
    logical, dimension(-6:6) :: quark_checked = .false.
    pdf_sub%required = any ([is_quark(flv(1,1)), &
        is_quark(flv(2,1)), is_gluon(flv(1,1)), is_gluon(flv(2,1))])
    if (.not. pdf_sub%required) return

    pdf_sub%sqme_born => sqme_collector%sqme_subtraction_born_list
    pdf_sub%isr_kinematics => isr_kinematics
    allocate (pdf_sub%value (n_alr))
    call pdf_sub%set_incoming_flavor (flv(1,1), flv(2,1))
    n_quarks = 0
    do i = 1, size (flv, dim=1 )
       if (is_quark(flv(i,1))) then
          n_quarks = n_quarks+1
          quark_checked(flv(i,1)) = .true.
       end if
    end do
    allocate (pdf_sub%i_light_quarks (n_quarks))
    j = 1
    do i = -6, 6
       if (quark_checked(i)) then
          pdf_sub%i_light_quarks(j) = i
          j = j+1
       end if
    end do

    call pdf_sub%init_pdfs ()
  end subroutine pdf_subtraction_init

@ %def pdf_subtraction_init
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: set_incoming_flavor => pdf_subtraction_set_incoming_flavor
<<pdf subtraction: procedures>>=
  subroutine pdf_subtraction_set_incoming_flavor (pdf_sub, flv1, flv2)
    class(pdf_subtraction_t), intent(inout) :: pdf_sub
    integer, intent(in) :: flv1, flv2
    pdf_sub%flv_in(1) = flv1; pdf_sub%flv_in(2) = flv2
  end subroutine pdf_subtraction_set_incoming_flavor

@ %def pdf_subtraction_set_incoming_flavor
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: init_pdfs => pdf_subtraction_init_pdfs
<<pdf subtraction: procedures>>=
  subroutine pdf_subtraction_init_pdfs (pdf_sub)
    class(pdf_subtraction_t), intent(inout) :: pdf_sub
    type(string_t) :: lhapdf_dir, lhapdf_file
    integer :: lhapdf_member
    lhapdf_dir = ""
    lhapdf_file = ""
    lhapdf_member = 0
    if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
            (1, lhapdf_dir, lhapdf_file, lhapdf_member, pdf_sub%pdf_data%pdf)
       associate (pdf_data => pdf_sub%pdf_data)
          pdf_data%type = STRF_LHAPDF6
          pdf_data%xmin = pdf_data%pdf%getxmin ()
          pdf_data%xmax = pdf_data%pdf%getxmax ()
          pdf_data%qmin = sqrt(pdf_data%pdf%getq2min ())
          pdf_data%qmax = sqrt(pdf_data%pdf%getq2max ())
       end associate
    else
       call msg_fatal ("PDF subtraction: PDFs could not be initialized")
    end if
  end subroutine pdf_subtraction_init_pdfs

@ %def pdf_subtraction_init_pdfs
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: compute_pdfs => pdf_subtraction_compute_pdfs
<<pdf subtraction: procedures>>=
  subroutine pdf_subtraction_compute_pdfs (pdf_sub)
    class(pdf_subtraction_t), intent(inout) :: pdf_sub
    integer :: i
    real(default) :: z, x, Q
    real(double), dimension(-6:6) :: f_dble = 0._double
    do i = 1, 2
       x = pdf_sub%isr_kinematics%x(i)
       z = pdf_sub%isr_kinematics%z(i)
       Q = pdf_sub%isr_kinematics%fac_scale
       call pdf_sub%pdf_data%evolve (dble(x), dble(Q), f_dble)
       pdf_sub%pdf_born(i)%f = f_dble
       call pdf_sub%pdf_data%evolve (dble(x/z), dble(Q), f_dble)
       pdf_sub%pdf_scaled(i)%f = f_dble
    end do
  end subroutine pdf_subtraction_compute_pdfs

@ %def pdf_subtraction_compute_pdfs
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: get_gluon_pdf => pdf_subtraction_get_gluon_pdf
<<pdf subtraction: procedures>>=
  function pdf_subtraction_get_gluon_pdf (pdf_sub, em, scaled) result (pdf)
    class(pdf_subtraction_t), intent(in) :: pdf_sub
    integer, intent(in) :: em
    logical, intent(in) :: scaled
    real(default) :: pdf
    if (scaled) then
       pdf = pdf_sub%pdf_scaled(em)%f(0)
    else
       pdf = pdf_sub%pdf_born(em)%f(0)
    end if
  end function pdf_subtraction_get_gluon_pdf

@ %def pdf_subtraction_get_gluon_pdf
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: get_quark_pdf => pdf_subtraction_get_quark_pdf
<<pdf subtraction: procedures>>=
  function pdf_subtraction_get_quark_pdf (pdf_sub, em, i, scaled) result (pdf)
    class(pdf_subtraction_t), intent(in) :: pdf_sub
    integer, intent(in) :: em, i
    logical, intent(in) :: scaled
    real(default) :: pdf
    if (scaled) then
       pdf = pdf_sub%pdf_scaled(em)%f(i)
    else
       pdf = pdf_sub%pdf_born(em)%f(i)
    end if
  end function pdf_subtraction_get_quark_pdf

@ %def pdf_subtraction_get_quark_pdf
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: get_summed_quark_pdf => pdf_subtraction_get_summed_quark_pdf
<<pdf subtraction: procedures>>=
  function pdf_subtraction_get_summed_quark_pdf (pdf_sub, em) result (pdf)
    class(pdf_subtraction_t), intent(in) :: pdf_sub
    integer, intent(in) :: em
    real(default) :: pdf
    integer :: i_quark
    pdf = 0._default
    do i_quark = -6, 6
       if (any(i_quark == pdf_sub%i_light_quarks)) &
          pdf = pdf + pdf_sub%get_quark_pdf(em, i_quark, scaled = .true.)
    end do
  end function pdf_subtraction_get_summed_quark_pdf

@ %def pdf_subtraction_get_summed_quark_pdf
@
<<pdf subtraction: pdf subtraction: TBP>>=
  procedure :: evaluate => pdf_subtraction_evaluate
<<pdf subtraction: procedures>>=
  subroutine pdf_subtraction_evaluate (pdf_sub, alpha_s, sqme_born, alr)
    class(pdf_subtraction_t), intent(inout) :: pdf_sub
    real(default), intent(in) :: alpha_s
    real(default), intent(inout) :: sqme_born
    integer, intent(in) :: alr
    real(default) :: factor, factor_soft, remnant
    real(default) :: pdfs, pdfb
    integer :: emitter
    real(default), dimension(2) :: tmp
    real(default) :: sb, xb, onemz
    real(default) :: fac_scale2, jac

    pdf_sub%value = 0._default
    sb = pdf_sub%isr_kinematics%sqrts_born**2
    tmp = 0._default
    fac_scale2 = pdf_sub%isr_kinematics%fac_scale**2

    call pdf_sub%compute_pdfs ()

    do emitter = 1, 2
       associate (z => pdf_sub%isr_kinematics%z(emitter))
          jac = pdf_sub%isr_kinematics%jacobian(emitter)
          onemz = one - z
          factor = log(sb / z / fac_scale2) / onemz + two * log(onemz) / onemz
          factor_soft = log(sb / fac_scale2) / onemz + two * log(onemz) / onemz

          xb = pdf_sub%isr_kinematics%x(emitter)
          remnant = log(one - xb) * log(sb / fac_scale2) + log(one - xb)**2

          if (is_gluon(pdf_sub%flv_in(emitter))) then
             pdfs = pdf_sub%get_gluon_pdf (emitter, scaled = .true.)
             pdfb = pdf_sub%get_gluon_pdf (emitter, scaled = .false.)
             tmp(emitter) = p_hat_gg(z) * factor/z * pdfs/pdfb * jac &
                  - p_hat_gg(one) * factor_soft * jac &
                  + p_hat_gg(one) * remnant
             pdfs = pdf_sub%get_summed_quark_pdf (emitter)
             tmp(emitter) = tmp(emitter) + &
                  (p_hat_qg(z)*factor - p_derived_qg(z))/z * pdfs/pdfb * jac
          else if (is_quark(abs(pdf_sub%flv_in(emitter)))) then
             pdfs = pdf_sub%get_quark_pdf (emitter, pdf_sub%flv_in(emitter), scaled = .true.)
             pdfb = pdf_sub%get_quark_pdf (emitter, pdf_sub%flv_in(emitter), scaled = .false.)
             if (vanishes (pdfb)) then
                sqme_born = 0._default
                return
             end if
             tmp(emitter) = p_hat_qq(z) * factor/z * pdfs/pdfb * jac &
                  - p_derived_qq(z)/z * pdfs/pdfb * jac &
                  - p_hat_qq(one) * factor_soft * jac &
                  + p_hat_qq(one) * remnant
             pdfs = pdf_sub%get_gluon_pdf (emitter, scaled = .true.)
             tmp(emitter) = tmp(emitter) + &
                  (p_hat_gq(z)*factor - p_derived_gq(z))/z * pdfs/pdfb * jac
          end if
       end associate
    end do
    sqme_born = alpha_s/twopi * (tmp(1)+tmp(2)) * sqme_born
  end subroutine pdf_subtraction_evaluate

@ %def pdf_subtraction_evaluate
@
<<pdf subtraction: procedures>>=
  function p_hat_gg (z)
    real(default) :: p_hat_gg
  <<p variables>>
    p_hat_gg = 2*CA*(z + onemz**2/z + z*onemz**2)
  end function p_hat_gg

  function p_hat_qg (z)
    real(default) :: p_hat_qg
  <<p variables>>
    p_hat_qg = CF * onemz/z * (one+onemz**2)
  end function p_hat_qg

  function p_hat_gq (z)
    real(default) :: p_hat_gq
  <<p variables>>
    p_hat_gq = TR*(onemz - 2*z*onemz**2)
  end function p_hat_gq

  function p_hat_qq (z)
    real(default) :: p_hat_qq
  <<p variables>>
    p_hat_qq = CF*(one+z**2)
  end function p_hat_qq

  function p_derived_gg (z)
    real(default) :: p_derived_gg
  <<p variables>>
    p_derived_gg = 0._default
  end function p_derived_gg

  function p_derived_qg (z)
    real(default) :: p_derived_qg
  <<p variables>>
    p_derived_qg = -CF*z
  end function p_derived_qg

  function p_derived_gq (z)
    real(default) :: p_derived_gq
  <<p variables>>
    p_derived_gq = -2*TR*z*onemz
  end function p_derived_gq

  function p_derived_qq (z)
    real(default) :: p_derived_qq
  <<p variables>>
    p_derived_qq = -CF*onemz
  end function p_derived_qq

<<p variables>>=
  real(default), intent(in) :: z
  real(default) :: onemz
  onemz = one - z
@ %def p_derived
