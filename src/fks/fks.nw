% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{FKS Subtraction Scheme}

The code in this chapter implements the FKS subtraction scheme for use
with \whizard.

These are the modules:
\begin{description}
\item[fks\_regions]
  Given a process definition, identify singular regions in the
  associated phase space.
\item[virtual]
  Handle the virtual correction matrix element.
\item[real\_subtraction]
  Handle the real-subtraction matrix element.
\item[nlo\_data]
  Manage the subtraction objects.
\end{description}

This chapter deals with next-to-leading order contributions to cross sections.
Basically, there are three major issues to be adressed: The creation
of the $N+1$-particle flavor structure, the construction of the
$N+1$-particle phase space and the actual calculation of the real- and
virtual-subtracted matrix elements. The first is dealt with using the
[[auto_components]] class, and it will be shown that the second
and third issue are connected in FKS subtraction.

\section{Brief outline of FKS subtraction}
{\em In the current state, this discussion is only concerned with
  lepton collisions. For hadron collisions, renormalization of parton
  distributions has to be taken into account. Further, for QCD
  corrections, initial-state radiation is necessarily
  present. However, most quantities have so far been only constructed
  for final-state emissions}

The aim is to calculate the next-to-leading order cross section
according to
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \mathcal{V} +
  \mathcal{R}d\Phi_{\rm{rad}}.
\end{equation*}
Analytically, the divergences, in terms of poles in the complex
quantity $\varepsilon = 2-d/2$, cancel. However, this is in general
only valid in an arbitrary, comlex number of dimensions. This is,
roughly, the content of the KLN-theorem. \whizard, as any
other numerical program, is confined to four dimensions. We will
assume that the KLN-theorem is valid and that there exist subtraction
terms $\mathcal{C}$ such that
\begin{equation*}
  d\sigma_{\rm{NLO}} = \mathcal{B} + \underbrace{\mathcal{V} +
    \mathcal{C}}_{\text{finite}} + \underbrace{\mathcal{R} -
    \mathcal{C}}_{\text{finite}},
\end{equation*}
i.e. the subtraction terms correspond to the divergent limits of the
real and virtual matrix element.

Because $\mathcal{C}$ subtracts the divergences of $\mathcal{R}$ as
well as those of $\mathcal{V}$, it suffices to consider one of them,
so we focus on $\mathcal{R}$. For this purpose, $\mathcal{R}$ is
rewritten,
\begin{equation*}
  \mathcal{R} = \frac{1}{\xi^2}\frac{1}{1-y} \left(\xi^2
    (1-y)\mathcal{R}\right) =
  \frac{1}{\xi^2}\frac{1}{1-y}\tilde{\mathcal{R}},
\end{equation*}
with $\xi = \left(2k_{\rm{rad}}^0\right)/\sqrt{s}$ and $y =
\cos\theta$, where $k_{\rm{rad}}^0$ denotes the energy of the radiated
parton and $\theta$ is the angle between emitter and radiated
parton. $\tilde{\mathcal{R}}$ is finite, therefore the whole
singularity structure is contained in the prefactor
$\xi^{-2}(1-y)^{-1}$. Combined with the d-dimensional phase space
element,
\begin{equation*}
  \frac{d^{d-1}k}{2k^0(2\pi)^{d-1}} =
  \frac{s^{1-\varepsilon}}{(4\pi)^{d-1}}\xi^{1-2\varepsilon}\left(1-y^2\right)^{-\varepsilon}
  d\xi dy d\Omega^{d-2},
\end{equation*}
this yields
\begin{equation*}
  d\Phi_{\rm{rad}} \mathcal{R} = dy (1-y)^{-1-\varepsilon} d\xi
  \xi^{-1-2\varepsilon} \tilde{R}.
\end{equation*}
This can further be rewritten in terms of plus-distributions,
\begin{align*}
\xi^{-1-2\varepsilon} &= -\frac{1}{2\varepsilon}\delta(\xi) +
\left(\frac{1}{\xi}\right)_+ -
2\varepsilon\left(\frac{\log\xi}{\xi}\right)_+ +
\mathcal{O}(\varepsilon^2),\\
(1-y)^{-1-\varepsilon} &= -\frac{2^{-\varepsilon}}{\varepsilon}
\delta(1-y) + \left(\frac{1}{1-y}\right)_+ - \varepsilon
\left(\frac{1}{1-y}\right)_+\log(1-y) + \mathcal{O}(\varepsilon^2),
\end{align*}
(imagine that all this is written inside of integrals, which are
spared for ease of notation) such that
\begin{align*}
d\Phi_{\rm{rad}} \mathcal{R} &= -\frac{1}{2\varepsilon} dy
(1-y)^{-1-\varepsilon}\tilde{R} (0,y) -
d\xi\left[\frac{2^{-\varepsilon}}{\varepsilon}\left(\frac{1}{\xi}\right)_+
  - 2\left(\frac{\log\xi}{\xi}\right)_+\right] \tilde{R}(\xi,1) \\
                              &+ dy d\xi \left(\frac{1}{\xi}\right)_+
                              \left(\frac{1}{1-y}\right)_+
                              \tilde{R}(\xi, y) +
                              \mathcal{O}(\varepsilon).\\
\end{align*}
The summand in the second line is of order $\mathcal{O}(1)$ and is the
only one to reproduce $\mathcal{R}{\xi,y}$. It thus constitutes the
sum of the real matrix element and the corresponding counterterms.
The first summand consequently consists of the subtraction terms to
the virtual matrix elements. Above formula thus allows to calculate
all quantities to render the matrix elements finite.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Identifying singular regions}
In the FKS subtraction scheme, the phase space is decomposed into
disjoint singular regions, such that
\begin{equation}
\label{eq:S_complete}
  \sum_i \mathcal{S}_i + \sum_{ij}\mathcal{S}_{ij} = 1.
\end{equation}
The quantities $\mathcal{S}_i$ and $\mathcal{S}_{ij}$ are functions of
phase space corresponding to a pair of particles indices which can
make up a divergent phase space region. We call such an index pair a
fundamental tuple. For example, the process $e^+ \, e^- \rightarrow u
\, \bar{u} \, g$ has two singular regions, $(3,5)$ and $(4,5)$,
indicating that the gluon can be soft or collinear with respect to
either the quark or the anti-quark. Therefore, the functions $S_{ij}$
have to be chosen in such a way that their contribution makes up most
of \eqref{eq:S_complete} in phase-space configurations where
(final-state) particle $j$ is collinear to particle $i$ or/and
particle $j$ is soft. The functions $S_i$ is the corresponding
quantity for initial-state divergences.

As a singular region we understand the collection of real flavor
structures associated with an emitter and a list of all possible
fundamental tuples. As an example, consider the process $e^+ \, e^-
\rightarrow u \, \bar{u} \, g$. At next-to-leading order, processes
with an additionally radiated particle have to be considered. In this
case, these are $e^+ \, e^- \rightarrow u \, \bar{u}, \, g \, g$,
and $e^+ \, e^- \rightarrow u \, \bar{u} \, u \, \bar{u}$ (or the same
process with any other quark). Table \ref{table:singular regions} sums
up all possible singular regions for this problem.
\begin{table}
\label{table:singular regions}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{flst\_alr} & \texttt{emi} &
  \texttt{ftuple\_list}\\ \hline
  1 & [-11,11,2,-2,21,21] & 3 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  2 & [-11,11,2,-2,21,21] & 4 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  3 & [-11,11,2,-2,21,21] & 5 & {(3,5), (3,6), (4,5), (4,6), (5,6)} \\ \hline
  4 & [-11,11,2,-2,2,-2]  & 5 & {(5,6)} \\
  \hline
\end{tabular}
\caption{List of singular regions. The particles are represented by
  their PDG codes. The third column contains the emitter for the
  specific singular region. For the process involving an additional
  gluon, the gluon can either be emitted from one of the quarks or
  from the first gluon. Each emitter yields the same list of
  fundamental tuples, five in total. The last singular region
  corresponds to the process where the gluon splits up into two
  quarks. Here, there is only one fundamental tuple, corresponding to
  a singular configuration of the momenta of the additional quarks.}
\end{table}
\\
\begin{table}
\label{table:ftuples and flavors}
\begin{tabular}{|c|c|c|c|}
  \hline
  \texttt{alr} & \texttt{ftuple} & \texttt{emitter} &
  \texttt{flst\_alr} \\ \hline
  1 & $(3,5)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  2 & $(4,5)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  3 & $(3,6)$ & 5 & [-11,11,-2,21,2,21] \\ \hline
  4 & $(4,6)$ & 5 & [-11,11,2,21,-2,21] \\ \hline
  5 & $(5,6)$ & 5 & [-11,11,2,-2,21,21] \\ \hline
  6 & $(5,6)$ & 5 & [-11,11,2,-2,2,-2] \\ \hline
\end{tabular}
\caption{Initial list of singular regions}
\end{table}
Thus, during the preparation of a NLO-calculation, the possible
singular regions have to be identified. [[fks_regions.f90]] deals
with this issue.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{FKS Regions}
<<[[fks_regions.f90]]>>=
<<File header>>

module fks_regions

<<Use kinds>>
  use format_utils, only: write_separator
  use numeric_utils, only: remove_duplicates_from_list
  use io_units
<<Use strings>>
  use constants
  use diagnostics
  use flavors
  use process_constants
  use lorentz
  use pdg_arrays
  use models
  use physics_defs
  use cascades
  use phs_fks, only: phs_identifier_t, check_for_phs_identifier

  use nlo_data

<<Standard module head>>

<<fks regions: public>>

<<fks regions: parameters>>

<<fks regions: types>>

<<fks regions: interfaces>>

contains

<<fks regions: procedures>>

end module fks_regions
@ %def fks_regions
@ We need these parameters for various temporary buffers
<<fks regions: parameters>>=
  integer, parameter, public :: N_MAX_ALR = 200
  integer, parameter, public :: N_MAX_FLV = 50

@ There are three fundamental splitting types: $q \rightarrow qg$, $g \rightarrow gg$ and
$g \rightarrow qq$.
<<fks regions: parameters>>=
  integer, parameter :: UNDEFINED_SPLITTING = 0
  integer, parameter :: Q_TO_QG = 1
  integer, parameter :: G_TO_GG = 2
  integer, parameter :: G_TO_QQ = 3

@
@ We group the indices of the emitting and the radiated particle in
the [[ftuple]]-object.
<<fks regions: public>>=
  public :: ftuple_t
<<fks regions: types>>=
  type :: ftuple_t
    integer, dimension(2) :: ireg
    integer :: i_res = 0
    integer :: splitting_type
    logical :: pseudo_isr = .false.
  contains
  <<fks regions: ftuple: TBP>>
  end type ftuple_t

@ %def ftuple_t
@
<<fks regions: ftuple: TBP>>=
  procedure :: write => ftuple_write
<<fks regions: procedures>>=
  subroutine ftuple_write (ftuple, unit)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    if (ftuple%i_res > 0) then
       print *, 'Check : ', ftuple%i_res
       write (u, "(A1,I1,A1,I1,A1,I1,A1)") &
         '(', ftuple%ireg(1), ',', ftuple%ireg(2), ';', ftuple%i_res, ')'
    else
       write (u, "(A1,I1,A1,I1,A1)") &
         '(', ftuple%ireg(1), ',', ftuple%ireg(2), ')'
    end if
  end subroutine ftuple_write

@ %def ftuple_write
@
<<fks regions: ftuple: TBP>>=
  procedure :: get => ftuple_get
<<fks regions: procedures>>=
  subroutine ftuple_get (ftuple, pos1, pos2)
    class(ftuple_t), intent(in) :: ftuple
    integer, intent(out) :: pos1, pos2
    pos1 = ftuple%ireg(1)
    pos2 = ftuple%ireg(2)
  end subroutine ftuple_get

@ %def ftuple_get
@
<<fks regions: ftuple: TBP>>=
  procedure :: set => ftuple_set
<<fks regions: procedures>>=
  subroutine ftuple_set (ftuple, pos1, pos2)
    class(ftuple_t), intent(inout) :: ftuple
    integer, intent(in) ::  pos1, pos2
    ftuple%ireg(1) = pos1
    ftuple%ireg(2) = pos2
  end subroutine ftuple_set

@ %def ftuple_set
@
<<fks regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_fsr => ftuple_determine_splitting_type_fsr
<<fks regions: procedures>>=
  subroutine ftuple_determine_splitting_type_fsr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    associate (flst => flv%flst)
       if (flst(i) == GLUON .and. flst(j) == GLUON) then
          ftuple%splitting_type = G_TO_GG
       else if (flst(i)+flst(j) == 0 &
             .and. is_quark (abs(flst(i)))) then
          ftuple%splitting_type = G_TO_QQ
       else if (is_quark(abs(flst(i))) .and. flst(j) == GLUON &
             .or. is_quark(abs(flst(j))) .and. flst(i) == GLUON) then
          ftuple%splitting_type = Q_TO_QG
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_fsr

@ %def ftuple_determine_splitting_type_fsr
@
<<fks regions: ftuple: TBP>>=
  procedure :: determine_splitting_type_isr => ftuple_determine_splitting_type_isr
<<fks regions: procedures>>=
  subroutine ftuple_determine_splitting_type_isr (ftuple, flv, i, j)
    class(ftuple_t), intent(inout) :: ftuple
    type(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i, j
    integer :: em
    em = i; if (i == 0) em = 1
    associate (flst => flv%flst)
       if (flst(em) == GLUON .and. flst(j) == GLUON) then
          ftuple%splitting_type = G_TO_GG
       else if (flst(em) == GLUON .and. is_quark(abs(flst(j)))) then
          ftuple%splitting_type = G_TO_QQ
       else if (is_quark(abs(flst(em))) .and. flst(j) == GLUON) then
          ftuple%splitting_type = Q_TO_QG
       else
          ftuple%splitting_type = UNDEFINED_SPLITTING
       end if
    end associate
  end subroutine ftuple_determine_splitting_type_isr

@ %def ftuple_determine_splitting_type_isr
@ Each singular region can have a different number of
emitter-radiation pairs. This is coped with using the linked list
[[ftuple_list]].
<<fks regions: types>>=
  type :: ftuple_list_t
    integer :: index = 0
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: next => null ()
    type(ftuple_list_t), pointer :: prev => null ()
    type(ftuple_list_t), pointer :: equiv => null ()
  contains
   <<fks regions: ftuple list: TBP>>
  end type ftuple_list_t

@ %def ftuple_list_t
@
<<fks regions: ftuple list: TBP>>=
  procedure :: write => ftuple_list_write
<<fks regions: procedures>>=
  subroutine ftuple_list_write (list)
    class(ftuple_list_t), intent(in), target :: list
    type(ftuple_list_t), pointer :: current
    select type (list)
    type is (ftuple_list_t)
       current => list
       do
          call current%ftuple%write
          if (associated (current%next)) then
             current => current%next
          else
             exit
          end if
       end do
    end select
  end subroutine ftuple_list_write

@ %def ftuple_list_write
@
<<fks regions: ftuple list: TBP>>=
  procedure :: append => ftuple_list_append
<<fks regions: procedures>>=
  subroutine ftuple_list_append (list, ftuple)
   class(ftuple_list_t), intent(inout), target :: list
   type(ftuple_t), intent(in) :: ftuple
   type(ftuple_list_t), pointer :: current

   select type (list)
   type is (ftuple_list_t)
   if (list%index == 0) then
      nullify(list%next)
      list%index = 1
      list%ftuple = ftuple
   else
      current => list
      do
       if (associated (current%next)) then
         current => current%next
       else
         allocate (current%next)
         nullify (current%next%next)
         nullify (current%next%equiv)
         current%next%prev => current
         current%next%index = current%index + 1
         current%next%ftuple = ftuple
         exit
       end if
     end do
   end if
   end select
  end subroutine ftuple_list_append

@ %def ftuple_list_append
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_n_tuples => ftuple_list_get_n_tuples
<<fks regions: procedures>>=
  function ftuple_list_get_n_tuples (list) result(n_tuples)
    class(ftuple_list_t), intent(in), target :: list
    integer :: n_tuples
    type(ftuple_list_t), pointer :: current
    n_tuples = 0
    select type (list)
    type is (ftuple_list_t)
       current => list
       if (current%index > 0) then
          n_tuples = 1
          do
             if (associated (current%next)) then
                current => current%next
                n_tuples = n_tuples + 1
             else
                exit
             end if
          end do
       end if
     end select
  end function ftuple_list_get_n_tuples

@ %def ftuple_list_get_n_tuples
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_entry => ftuple_list_get_entry
<<fks regions: procedures>>=
  function ftuple_list_get_entry (list, index) result (entry)
   class(ftuple_list_t), intent(in), target :: list
   integer, intent(in) :: index
   type(ftuple_list_t), pointer :: entry
   type(ftuple_list_t), pointer :: current
   integer :: i
   entry => null()
   select type (list)
   type is (ftuple_list_t)
      current => list
      if (index <= list%get_n_tuples ()) then
         if (index == 1) then
            entry => current
         else
            do i = 1, index - 1
               current => current%next
            end do
            entry => current
         end if
      else
         call msg_fatal &
              ("Index must be smaller or equal than the total number of regions!")
      end if
   end select
 end function ftuple_list_get_entry

@ %def ftuple_list_get_entry
@
<<fks regions: ftuple list: TBP>>=
  procedure :: get_ftuple => ftuple_list_get_ftuple
<<fks regions: procedures>>=
  function ftuple_list_get_ftuple (list, index)  result (ftuple)
    class(ftuple_list_t), intent(in), target :: list
    integer, intent(in) :: index
    type(ftuple_t) :: ftuple
    type(ftuple_list_t), pointer :: entry
    entry => list%get_entry (index)
    ftuple = entry%ftuple
  end function ftuple_list_get_ftuple

@ %def ftuple_list_get_ftuple
@
<<fks regions: ftuple list: TBP>>=
  procedure :: set_equiv => ftuple_list_set_equiv
<<fks regions: procedures>>=
  subroutine ftuple_list_set_equiv (list, i1, i2)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    type(ftuple_list_t), pointer :: list1, list2
    select type (list)
    type is (ftuple_list_t)
       list1 => list%get_entry (i1)
       list2 => list%get_entry (i2)
       do
          if (associated (list1%equiv)) then
             list1 => list1%equiv
          else
             exit
          end if
       end do
       list1%equiv => list2
    end select
  end subroutine ftuple_list_set_equiv

@ %def ftuple_list_set_equiv
@
<<fks regions: ftuple list: TBP>>=
  procedure :: check_equiv => ftuple_list_check_equiv
<<fks regions: procedures>>=
  function ftuple_list_check_equiv(list, i1, i2) result(eq)
    class(ftuple_list_t), intent(in) :: list
    integer, intent(in) :: i1, i2
    logical :: eq
    type(ftuple_list_t), pointer :: current
    eq = .false.
    select type (list)
    type is (ftuple_list_t)
       current => list%get_entry (i1)
       do
          if (associated (current%equiv)) then
             current => current%equiv
             if (current%index == i2) then
                eq = .true.
                exit
             end if
          else
             exit
          end if
       end do
    end select
  end function ftuple_list_check_equiv

@ %def ftuple_list_check_equiv
@ Class for working with the flavor specification arrays.
<<fks regions: public>>=
  public :: flv_structure_t
<<fks regions: types>>=
  type :: flv_structure_t
    integer, dimension(:), allocatable :: flst
    integer :: nlegs = 0
    integer :: n_in = 0
    logical, dimension(:), allocatable :: massive
    logical, dimension(:), allocatable :: colored
  contains
  <<fks regions: flv structure: TBP>>
  end type flv_structure_t

@ %def flv_structure_t
@
Returns \texttt{true} if the two particles at position \texttt{i}
and \texttt{j} in the flavor array can originate from the same
splitting. For this purpose, the function first checks whether the splitting is
allowed at all. If this is the case, the emitter is removed from the
flavor array. If the resulting array is equivalent to the Born flavor
structure \texttt{flv\_born}, the pair is accepted as a valid
splitting. We first check whether the splitting is possible. The array
[[flv_orig]] contains all particles which share a vertex with the
particles at position [[i]] and [[j]]. If its size is equal to zero,
no splitting is possible and the subroutine is exited. Otherwise,
we loop over all possible underlying Born flavor structures and check
if any of them equals the actual underlying Born flavor structure.
For a quark emitting a gluon, [[flv_orig]] contains the PDG code of
the anti-quark. To be on the safe side, a second array is created,
which contains both the positively and negatively signed PDG
codes. Then, the origial tuple $(i,j)$ is removed from the real flavor
structure and the particles in [[flv_orig2]] are inserted.
If the resulting Born configuration is equal to the underlying Born
configuration, up to a permutation of final-state particles, the tuple
$(i,j)$ is accepted as valid.
<<fks regions: flv structure: TBP>>=
  procedure :: valid_pair => flv_structure_valid_pair
<<fks regions: procedures>>=
  function flv_structure_valid_pair &
     (flv, i, j, flv_ref, model) result (valid)
    logical :: valid
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i,j
    type(flv_structure_t), intent(in) :: flv_ref
    type(model_t), intent(in) :: model
    integer :: k, n_orig
    type(flv_structure_t) :: flv_test
    integer, dimension(:), allocatable :: flv_orig
    valid = .false.
    if (all ([i, j] <= flv%n_in)) return
    call model%match_vertex &
         (flv%flst(i), flv%flst(j), flv_orig)
    n_orig = size (flv_orig)
    if (n_orig == 0) then
      return
    else
      do k = 1, n_orig
         if (any ([i, j] <= flv%n_in)) then
            flv_test = flv%insert_particle_isr (i, j, flv_orig(k))
         else
            flv_test = flv%insert_particle_fsr (i, j, flv_orig(k))
         end if
         valid = flv_ref == flv_test
         call flv_test%final ()
         if (valid) return
      end do
    end if
    deallocate (flv_orig)
  end function flv_structure_valid_pair

@ %def flv_structure_valid_pair
@ This function checks whether two flavor arrays are the same up to a
permutation of the final-state particles
<<fks regions: procedures>>=
  function flv_structure_equivalent (flv1, flv2) result(equiv)
    logical :: equiv
    type(flv_structure_t), intent(in) :: flv1, flv2
    integer :: i, j, n
    logical, dimension(:), allocatable :: present, checked
    n = size (flv1%flst)
    equiv = .true.
    if (n /= size (flv2%flst)) then
       call msg_fatal &
          ('flv_structure_equivalent: flavor arrays do not have equal lengths')
    else if (flv1%n_in /= flv2%n_in) then
       call msg_fatal &
          ('flv_structure_equivalent: flavor arrays do not have equal n_in')
    else
       allocate (present(n))
       allocate (checked(n))
       present = .false.; checked = .false.
       do i = 1, flv1%n_in
          if (flv1%flst(i) /= flv2%flst(i)) then
             equiv = .false.
             return
          end if
       end do
       do i = flv1%n_in + 1 , n
          do j = flv1%n_in + 1 ,n
             if (flv1%flst(i) == flv2%flst(j) .and. .not. checked(j)) then
                present(i) = .true.
                checked(j) = .true.
                exit
             end if
          end do
       end do
       do i = flv1%n_in + 1 , n
          if (.not.present(i)) equiv = .false.
       end do
    end if
  end function flv_structure_equivalent

@ %def flv_structure_equivalent
@
<<fks regions: procedures>>=
  subroutine flv_structure_assign_flv (flv_out, flv_in)
    type(flv_structure_t), intent(out) :: flv_out
    type(flv_structure_t), intent(in) :: flv_in
    flv_out%nlegs = flv_in%nlegs
    flv_out%n_in = flv_in%n_in
    if (allocated (flv_in%flst)) then
       allocate (flv_out%flst (size (flv_in%flst)))
       flv_out%flst = flv_in%flst
    end if
    if (allocated (flv_in%massive)) then
       allocate (flv_out%massive (size (flv_in%massive)))
       flv_out%massive = flv_in%massive
    end if
    if (allocated (flv_in%colored)) then
       allocate (flv_out%colored (size (flv_in%colored)))
       flv_out%colored = flv_in%colored
    end if
  end subroutine flv_structure_assign_flv

@ %def flv_structure_assign_flv
@
<<fks regions: procedures>>=
  subroutine flv_structure_assign_integer (flv_out, iarray)
    type(flv_structure_t), intent(out) :: flv_out
    integer, intent(in), dimension(:) :: iarray
    flv_out%nlegs = size (iarray)
    allocate (flv_out%flst (flv_out%nlegs))
    flv_out%flst = iarray
  end subroutine flv_structure_assign_integer

@ %def flv_structure_assign_integer
@ Returs a new flavor array with the particle at position
\texttt{index} removed.
<<fks regions: flv structure: TBP>>=
  procedure :: remove_particle => flv_structure_remove_particle
<<fks regions: procedures>>=
  function flv_structure_remove_particle (flv, index) result(flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: index
    integer :: n1, n2
    n1 = size (flv%flst)
    n2 = n1 - 1
    allocate (flv_new%flst (n2))
    flv_new%nlegs = n2
    flv_new%n_in = flv%n_in
    if (index == 1) then
      flv_new%flst(1 : n2) = flv%flst(2 : n1)
    else if (index == n1) then
      flv_new%flst(1 : n2) = flv%flst(1 : n2)
    else
      flv_new%flst(1 : index - 1) = flv%flst(1 : index - 1)
      flv_new%flst(index : n2) = flv%flst(index + 1 : n1)
    end if
  end function flv_structure_remove_particle

@ %def flv_structure_remove_particle
@
<<fks regions: flv structure: TBP>>=
  procedure :: insert_particle_fsr => flv_structure_insert_particle_fsr
<<fks regions: procedures>>=
  function flv_structure_insert_particle_fsr (flv, i1, i2, flv_add) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i1, i2, flv_add
    if (flv%flst(i1) + flv_add == 0 .or. flv%flst(i2) + flv_add == 0) then
       flv_new = flv%insert_particle (i1, i2, -flv_add)
    else
       flv_new = flv%insert_particle (i1, i2, flv_add)
    end if
  end function flv_structure_insert_particle_fsr

@ %def flv_structure_insert_particle_fsr
@ For ISR, the two particles are not exchangable.
<<fks regions: flv structure: TBP>>=
  procedure :: insert_particle_isr => flv_structure_insert_particle_isr
<<fks regions: procedures>>=
  function flv_structure_insert_particle_isr (flv, i_in, i_out, flv_add) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i_in, i_out, flv_add
    if (flv%flst(i_in) + flv_add == 0) then
       flv_new = flv%insert_particle (i_in, i_out, -flv_add)
    else
       flv_new = flv%insert_particle (i_in, i_out, flv_add)
    end if
  end function flv_structure_insert_particle_isr

@ %def flv_structure_insert_particle_isr
@ Removes the paritcles at position i1 and i2 and inserts a new
particle at position i1.
<<fks regions: flv structure: TBP>>=
  procedure :: insert_particle => flv_structure_insert_particle
<<fks regions: procedures>>=
  function flv_structure_insert_particle (flv, i1, i2, particle) result (flv_new)
    type(flv_structure_t) :: flv_new
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: i1, i2, particle
    type(flv_structure_t) :: flv_tmp
    integer :: n1, n2
    n1 = size (flv%flst)
    n2 = n1 - 1
    allocate (flv_new%flst(n2))
    flv_new%nlegs = n2
    flv_new%n_in = flv%n_in
    if (i1 < i2) then
      flv_tmp = flv%remove_particle (i1)
      flv_tmp = flv_tmp%remove_particle (i2 - 1)
    else if(i2 < i1) then
      flv_tmp = flv%remove_particle(i2)
      flv_tmp = flv_tmp%remove_particle(i1 - 1)
    else
      call msg_fatal ("flv_structure_insert_particle: Indices are identical!")
    end if
    if (i1 == 1) then
      flv_new%flst(1) = particle
      flv_new%flst(2 : n2) = flv_tmp%flst(1 : n2 - 1)
    else if (i1 == n1 .or. i1 == n2) then
      flv_new%flst(1 : n2 - 1) = flv_tmp%flst(1 : n2 - 1)
      flv_new%flst(n2) = particle
    else
      flv_new%flst(1 : i1 - 1) = flv_tmp%flst(1 : i1 - 1)
      flv_new%flst(i1) = particle
      flv_new%flst(i1 + 1 : n2) = flv_tmp%flst(i1 : n2 - 1)
    end if
  end function flv_structure_insert_particle

@ %def flv_structure_insert_particle
@ Returns the number of particles in a flavor array
<<fks regions: flv structure: TBP>>=
  procedure :: get_nlegs => flv_structure_get_nlegs
<<fks regions: procedures>>=
  function flv_structure_get_nlegs (flv) result(n)
    class(flv_structure_t), intent(in) :: flv
    integer :: n
    n = size (flv%flst)
  end function flv_structure_get_nlegs

@ %def flv_structure_get_nlegs
@ Counts the number of occurances of a particle in a
flavor array
<<fks regions: flv structure: TBP>>=
  procedure :: count_particle => flv_structure_count_particle
<<fks regions: procedures>>=
  function flv_structure_count_particle (flv, part) result (n)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: part
    integer :: n
    n = count (flv%flst == part)
  end function flv_structure_count_particle

@ %def flv_structure_count_particle
@ Initializer for flavor structures
<<fks regions: flv structure: TBP>>=
  procedure :: init => flv_structure_init
<<fks regions: procedures>>=
  subroutine flv_structure_init (flv, aval, n_in)
    class(flv_structure_t), intent(inout) :: flv
    integer, intent(in), dimension(:) :: aval
    integer, intent(in) :: n_in
    integer :: n
    n = size (aval)
    allocate (flv%flst (n))
    flv%flst(1 : n) = aval(1 : n)
    flv%nlegs = n
    flv%n_in = n_in
  end subroutine flv_structure_init

@ %def flv_structure_init
@
<<fks regions: flv structure: TBP>>=
  procedure :: write => flv_structure_write
<<fks regions: procedures>>=
  subroutine flv_structure_write (flv, unit)
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (unit); if (u < 0) return
    write (u, '(A1)',advance = 'no') '['
    do i = 1, size(flv%flst) - 1
      write (u, '(I3,A1)', advance = 'no') flv%flst(i), ','
    end do
    write (u, '(I3,A1)') flv%flst(i), ']'
  end subroutine flv_structure_write

@ %def flv_structure_write
@ Creates the underlying Born flavor structure for a given real flavor
structure if the particle at position \texttt{emitter} is removed
<<fks regions: flv structure: TBP>>=
  procedure :: create_uborn => flv_structure_create_uborn
<<fks regions: procedures>>=
  function flv_structure_create_uborn (flv, emitter) result(flv_uborn)
    type(flv_structure_t) :: flv_uborn
    class(flv_structure_t), intent(in) :: flv
    integer, intent(in) :: emitter
    integer n_legs
    integer :: f1, f2
    n_legs = size(flv%flst)
    allocate (flv_uborn%flst (n_legs - 1))
    if (emitter > flv%n_in) then
       f1 = flv%flst(n_legs); f2 = flv%flst(n_legs - 1)
       if (f1 == 21) then
          !!! Emitted particle is a gluon => just remove it
          flv_uborn = flv%remove_particle(n_legs)
       else if (is_quark (f1) .and. is_quark (f2) .and. f1 + f2 == 0) then
          !!! Emission type is a gluon splitting into two quars
          flv_uborn = flv%insert_particle(n_legs - 1, n_legs, 21)
       else
          call msg_fatal ("Create underlying Born: Unsupported splitting type.")
       end if
    else if (emitter > 0) then
       f1 = flv%flst(n_legs); f2 = flv%flst(emitter)
       if (f1 == 21) then
          flv_uborn = flv%remove_particle(n_legs)
       else if (is_quark (f1) .and. is_gluon (f2)) then
          flv_uborn = flv%insert_particle (emitter, n_legs, -f1)
       else if (is_quark (f1) .and. is_quark (f2) .and. f1 == f2) then
          flv_uborn = flv%insert_particle(emitter, n_legs, 21)
       end if
    else
       flv_uborn = flv%remove_particle (n_legs)
    end if
  end function flv_structure_create_uborn

@ %def flv_structure_create_uborn
@
<<fks regions: flv structure: TBP>>=
  procedure :: init_mass_and_color => flv_structure_init_mass_and_color
<<fks regions: procedures>>=
  subroutine flv_structure_init_mass_and_color (flv, model)
    class(flv_structure_t), intent(inout) :: flv
    type(model_t), intent(in) :: model
    integer :: i
    type(flavor_t) :: flavor
    allocate (flv%massive (flv%nlegs), flv%colored(flv%nlegs))
    do i = 1, flv%nlegs
       call flavor%init (flv%flst(i), model)
       flv%massive(i) = flavor%get_mass () > 0
       flv%colored(i) = &
          is_quark (flv%flst(i)) .or. is_gluon (flv%flst(i))
    end do
  end subroutine flv_structure_init_mass_and_color

@ %def flv_structure_init_mass_and_color
@
<<fks regions: flv structure: TBP>>=
  procedure :: final => flv_structure_final
<<fks regions: procedures>>=
  subroutine flv_structure_final (flv)
    class(flv_structure_t), intent(inout) :: flv
    if (allocated (flv%flst)) deallocate (flv%flst)
    if (allocated (flv%flst)) deallocate (flv%massive)
    if (allocated (flv%flst)) deallocate (flv%colored)
  end subroutine flv_structure_final

@ %def flv_structure_final
@ A singular region is a partition of phase space which is associated with
an individual emitter and, if relevant, resonance. It is associated with
an $\alpha_r$- and resonance-index, with a real flavor structure and
its underlying Born flavor structure. To compute the FKS weights, it is
relevant to know all the other particle indices which can result in a
divergenent phase space configuration, which are collected in the
[[ftuples]]-array.\\
Some singular regions might behave physically identical. E.g. a real
flavor structure associated with three-jet production is $[11,-11,0,2-2,0]$.
Here, there are two possible [[ftuples]] which contribute to the same
$u \rightarrow u g$ splitting, namely $(3,4)$ and $(4,6)$. The resulting
singular regions will be identical. To avoid this, one singular region
is associated with the multiplicity factor [[mult]]. When computing the
subtraction terms for each singular region, the result is then simply
multiplied by this factor.\\
The [[double_fsr]]-flag indicates whether the singular region should
also be supplied by a symmetry factor, explained below.
<<fks regions: public>>=
  public :: singular_region_t
<<fks regions: types>>=
  type :: singular_region_t
    integer :: alr
    integer :: i_res
    type(flv_structure_t) :: flst_real
    type(flv_structure_t) :: flst_uborn
    integer :: mult
    integer :: emitter
    integer :: nregions
    integer :: real_index
    type(ftuple_t), dimension(:), allocatable :: ftuples
    integer :: uborn_index
    logical :: double_fsr
    logical :: soft_divergence
    logical :: coll_divergence
    integer, dimension(:), allocatable :: i_reg_to_i_con
    logical :: pseudo_isr = .false.
  contains
  <<fks regions: singular region: TBP>>
  end type singular_region_t

@ %def singular_region_t
@
<<fks regions: singular region: TBP>>=
  procedure :: init => singular_region_init
<<fks regions: procedures>>=
  subroutine singular_region_init (sregion, alr, mult, i_res, &
         flst_real, flst_uborn, flv_born, emitter, ftuples, index)
    class(singular_region_t), intent(out) :: sregion
    integer, intent(in) :: alr, mult, i_res
    type(flv_structure_t), intent(in) :: flst_real
    type(flv_structure_t), intent(in) :: flst_uborn
    type(flv_structure_t), dimension(:), intent(in) :: flv_born
    integer, intent(in) :: emitter
    type(ftuple_list_t), intent(in), dimension(:), target :: ftuples
    integer, dimension(:), intent(in) :: index
    type(ftuple_list_t), pointer :: current_region
    integer :: i, i1, i2, nlegs
    call msg_debug (D_SUBTRACTION, "singular_region_init")
    call debug_input_values ()
    sregion%alr = alr
    sregion%mult = mult
    sregion%i_res = i_res
    sregion%flst_real = flst_real
    sregion%flst_uborn = flst_uborn
    sregion%emitter = emitter
    sregion%nregions = ftuples (index(alr))%get_n_tuples ()
    nlegs = size (flst_real%flst)
    allocate (sregion%ftuples (sregion%nregions))
    do i = 1, sregion%nregions
       current_region => ftuples (index(alr))%get_entry (i)
       if (.not. associated (current_region%equiv)) then
          call current_region%ftuple%get (i1, i2)
          if (i2 /= nlegs) call current_region%ftuple%set (i1, nlegs)
       end if
       sregion%ftuples (i) = current_region%ftuple
    end do
    do i = 1, size(flv_born)
       if (flv_born (i) == sregion%flst_uborn) then
          sregion%uborn_index = i
          exit
       end if
    end do
  contains
    subroutine debug_input_values()
      if (debug2_active (D_SUBTRACTION)) then
         print *, 'alr =    ', alr
         print *, 'mult =    ', mult
         print *, 'i_res =    ', i_res
         call flst_real%write ()
         call flst_uborn%write ()
         do i = 1, size (flv_born)
            call flv_born(i)%write ()
         end do
         print *, 'emitter =    ', emitter
         do i = 1, size (ftuples)
            call ftuples(i)%write ()
         end do
         print *, 'index =    ', index
      end if
    end subroutine debug_input_values
  end subroutine singular_region_init

@ %def singular_region_init
<<fks regions: singular region: TBP>>=
  procedure :: write => singular_region_write
<<fks regions: procedures>>=
  subroutine singular_region_write (sregion, unit, maxnregions)
    class(singular_region_t), intent(in) :: sregion
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: maxnregions
    character(len=7), parameter :: flst_format = "(I3,A1)"
    character(len=16), parameter :: ireg_format = "(A1,I1,A1,I1,A3)"
    character(len=22), parameter :: &
       ireg_format_resonant = "(A1,I1,A1,I1,A1,I1,A3)"
    character(len=7), parameter :: ireg_space_format = "(7X,A1)"
    integer :: nreal, nborn, i, u, mr, i1, i2
    integer :: nleft, nright, nreg, nreg_diff
    integer :: i_res
    character(len=3) :: closing_bracket
    u = given_output_unit (unit); if (u < 0) return
    mr = sregion%nregions; if (present (maxnregions))  mr = maxnregions
    nreal = size (sregion%flst_real%flst)
    nborn = size (sregion%flst_uborn%flst)
    call write_vline (u)
    write (u, '(A1)', advance = 'no') '['
    do i = 1, nreal - 1
       write (u, flst_format, advance = 'no') sregion%flst_real%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_real%flst(nreal), ']'
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%emitter
    call write_vline (u)
    write (u, '(I3)', advance = 'no') sregion%mult
    call write_vline (u)
    write (u, '(I4)', advance = 'no') sregion%nregions
    call write_vline (u)
    if (sregion%i_res > 0) then
       write (u, '(I3)', advance = 'no') sregion%i_res
       call write_vline (u)
    end if
    nreg = sregion%nregions
    if (nreg == mr) then
       nleft = 0
       nright = 0
    else
       nreg_diff = mr - nreg
       nleft = nreg_diff / 2
       if (mod(nreg_diff , 2) == 0) then
          nright = nleft
       else
          nright = nleft + 1
       end if
    end if
    if (nleft > 0) then
       do i = 1, nleft
          write(u, ireg_space_format, advance='no') ' '
       end do
    end if
    write (u,'(A1)', advance = 'no') '{'
    if (nreg > 1) then
       do i = 1, nreg - 1
          call sregion%ftuples(i)%get (i1, i2)
          if (sregion%ftuples(i)%pseudo_isr) then
             closing_bracket = ')*'
          else
             closing_bracket = ')'
          end if
          i_res = sregion%ftuples(i)%i_res
          if (i_res > 0) then
             write (u, ireg_format_resonant, advance = 'no') &
                '(', i1, ',', i2, ';', i_res, closing_bracket
          else
             write(u, ireg_format, advance = 'no') '(', i1, ',', i2, closing_bracket
          end if
       end do
    end if
    call sregion%ftuples(nreg)%get (i1, i2)
    i_res = sregion%ftuples(nreg)%i_res
    if (sregion%ftuples(nreg)%pseudo_isr) then
       closing_bracket = ')*}'
    else
       closing_bracket = ')}'
    end if
    if (i_res > 0) then
       write (u, ireg_format_resonant, advance = 'no') &
          '(', i1, ',', i2, '; ', i_res, closing_bracket
    else
       write (u, ireg_format, advance = 'no') '(', i1, ',', i2, closing_bracket
    end if
    if (nright > 0) then
       do i = 1, nright
          write(u, ireg_space_format, advance='no') ' '
       end do
    end if
    call write_vline (u)
    write (u,'(A1)',advance = 'no') '['
    do i = 1, nborn - 1
       write(u, flst_format, advance = 'no') sregion%flst_uborn%flst(i), ','
    end do
    write (u, flst_format, advance = 'no') sregion%flst_uborn%flst(nborn), ']'
    call write_vline (u)
    write (u, '(I7)', advance = 'no') sregion%uborn_index
    write (u, '(A)')
  end subroutine singular_region_write

@ %def singular_region_write
@ In case of a $g \rightarrow gg$ or $g \rightarrow qq$ splitting, the factor
\begin{equation*}
 \frac{2E_{\rm{em}}}{E_{\rm{em}} + E_{\rm{rad}}}
\end{equation*}
is multiplied to the real matrix element. This way, the symmetry of the splitting is used
and only one singular region has to be taken into account. However, the factor ensures that
there is only a soft singularity if the radiated parton becomes soft.
<<fks regions: singular region: TBP>>=
  procedure :: set_splitting_info => singular_region_set_splitting_info
<<fks regions: procedures>>=
  subroutine singular_region_set_splitting_info (region)
    class(singular_region_t), intent(inout) :: region
    integer :: i1, i2
    integer :: reg
    region%double_fsr = .false.
    associate (ftuple => region%ftuples)
       do reg = 1, region%nregions
          call ftuple(reg)%get (i1, i2)
          if (i1 /= region%emitter) then
             cycle
          else
             region%soft_divergence = &
                ftuple(reg)%splitting_type /= G_TO_QQ

             if (i1 == 0) then
               region%coll_divergence = .true.
             else
               region%coll_divergence = &
                    .not. region%flst_real%massive(i1)
             end if

             if (ftuple(reg)%splitting_type > 1) then
                region%double_fsr = .true.
                exit
             else if (ftuple(reg)%splitting_type == UNDEFINED_SPLITTING) then
                call msg_fatal ("All splittings should be defined!")
             end if
          end if
       end do
     end associate
  end subroutine singular_region_set_splitting_info

@ %def singular_region_set_splitting_info
@
<<fks regions: singular region: TBP>>=
  procedure :: double_fsr_factor => singular_region_double_fsr_factor
<<fks regions: procedures>>=
  function singular_region_double_fsr_factor (region, p) result (val)
    class(singular_region_t), intent(in) :: region
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: val
    real(default) :: E_rad, E_em
    if (region%double_fsr) then
      E_em = energy (p(region%emitter))
      E_rad = energy (p(region%flst_real%get_nlegs()))
      val = two * E_em / (E_em + E_rad)
    else
      val = one
    end if
  end function singular_region_double_fsr_factor

@ %def singular_region_double_fsr_factor
@
<<fks regions: singular region: TBP>>=
  procedure :: has_soft_divergence => singular_region_has_soft_divergence
<<fks regions: procedures>>=
  function singular_region_has_soft_divergence (region) result (div)
     class(singular_region_t), intent(in) :: region
     logical :: div
     div = region%soft_divergence
  end function singular_region_has_soft_divergence

@ %def singular_region_has_soft_divergence
@
<<fks regions: singular region: TBP>>=
  procedure :: has_collinear_divergence => &
            singular_region_has_collinear_divergence
<<fks regions: procedures>>=
  function singular_region_has_collinear_divergence (region) result (div)
    class(singular_region_t), intent(in) :: region
    logical :: div
    div = region%coll_divergence
  end function singular_region_has_collinear_divergence

@ %def singular_region_has_collinear_divergence
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure singular_region_assign
  end interface

<<fks regions: procedures>>=
  subroutine singular_region_assign (reg_out, reg_in)
    type(singular_region_t), intent(out) :: reg_out
    type(singular_region_t), intent(in) :: reg_in
    reg_out%alr = reg_in%alr
    reg_out%i_res = reg_in%i_res
    reg_out%flst_real = reg_in%flst_real
    reg_out%flst_uborn = reg_in%flst_uborn
    reg_out%mult = reg_in%mult
    reg_out%emitter = reg_in%emitter
    reg_out%nregions = reg_in%nregions
    reg_out%real_index = reg_in%real_index
    reg_out%uborn_index = reg_in%uborn_index
    reg_out%double_fsr = reg_in%double_fsr
    reg_out%soft_divergence = reg_in%soft_divergence
    reg_out%coll_divergence = reg_in%coll_divergence
    if (allocated (reg_in%ftuples)) then
       allocate (reg_out%ftuples (size (reg_in%ftuples)))
       reg_out%ftuples = reg_in%ftuples
    else
       call msg_bug ("singular_region_assign: Trying to copy a singular region without allocated ftuples!")
    end if
  end subroutine singular_region_assign

@ %def singular_region_assign
@
<<fks regions: types>>=
  type :: resonance_mapping_t
    type(resonance_history_t), dimension(:), allocatable :: res_histories
    integer, dimension(:), allocatable :: alr_to_i_res
    integer, dimension(:,:), allocatable :: i_res_to_alr
    type(vector4_t), dimension(:), allocatable :: p_res
  contains
  <<fks regions: resonance mapping: TBP>>
  end type resonance_mapping_t

@ %def resonance_mapping_t
@ Testing: Init resonance mapping for $\mu \mu b b$ final state.
<<fks regions: resonance mapping: TBP>>=
  procedure :: init => resonance_mapping_init
<<fks regions: procedures>>=
  subroutine resonance_mapping_init (res_map, res_hist)
    class(resonance_mapping_t), intent(inout) :: res_map
    type(resonance_history_t), intent(in), dimension(:) :: res_hist
    integer :: n_hist, i_hist1, i_hist2, n_contributors
    n_contributors = 0
    n_hist = size (res_hist)
    allocate (res_map%res_histories (n_hist))
    do i_hist1 = 1, n_hist
       if (i_hist1 + 1 <= n_hist) then
          do i_hist2 = i_hist1 + 1, n_hist
             if (.not. res_hist(i_hist1) > res_hist(i_hist2)) &
                n_contributors = n_contributors + res_hist(i_hist2)%n_resonances
          end do
       else
          n_contributors = n_contributors + res_hist(i_hist1)%n_resonances
       end if
    end do
    allocate (res_map%p_res (n_contributors))
    res_map%res_histories = res_hist
    res_map%p_res = vector4_null
  end subroutine resonance_mapping_init

@ %def resonance_mapping_init
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: set_alr_to_i_res => resonance_mapping_set_alr_to_i_res
<<fks regions: procedures>>=
  subroutine resonance_mapping_set_alr_to_i_res (res_map, regions, alr_new_to_old)
     class(resonance_mapping_t), intent(inout) :: res_map
     type(singular_region_t), intent(in), dimension(:) :: regions
     integer, intent(out), dimension(:), allocatable :: alr_new_to_old
     integer :: alr, i_res
     integer :: alr_new, n_alr_res
     integer :: k
     call msg_debug (D_SUBTRACTION, "resonance_mapping_set_alr_to_i_res")
     n_alr_res = 0
     do alr = 1, size (regions)
        do i_res = 1, size (res_map%res_histories)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) &
              n_alr_res = n_alr_res + 1
        end do
     end do

     allocate (res_map%alr_to_i_res (n_alr_res))
     allocate (res_map%i_res_to_alr (size (res_map%res_histories), 10))
     res_map%i_res_to_alr = 0
     allocate (alr_new_to_old (n_alr_res))
     alr_new = 1
     do alr = 1, size (regions)
        do i_res = 1, size (res_map%res_histories)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) then
              res_map%alr_to_i_res (alr_new) = i_res
              alr_new_to_old (alr_new) = alr
              alr_new = alr_new  + 1
           end if
        end do
     end do

     do i_res = 1, size (res_map%res_histories)
        k = 1
        do alr = 1, size (regions)
           if (res_map%res_histories(i_res)%contains_leg (regions(alr)%emitter)) then
              res_map%i_res_to_alr (i_res, k) = alr
              k = k + 1
           end if
        end do
     end do
     if (debug_active (D_SUBTRACTION)) then
        print *, 'i_res_to_alr:'
        do i_res = 1, size(res_map%i_res_to_alr, dim=1)
           print *, res_map%i_res_to_alr (i_res, :)
        end do
        print *, 'alr_new_to_old:', alr_new_to_old
     end if
  end subroutine resonance_mapping_set_alr_to_i_res

@ %def resonance_mapping_set_alr_to_i_res
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_history => resonance_mapping_get_resonance_history
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_history (res_map, alr) result (res_hist)
     type(resonance_history_t) :: res_hist
     class(resonance_mapping_t), intent(in) :: res_map
     integer, intent(in) :: alr
     res_hist = res_map%res_histories(res_map%alr_to_i_res (alr))
  end function resonance_mapping_get_resonance_history

@ %def resonance_mapping_get_resonance_history
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: write => resonance_mapping_write
<<fks regions: procedures>>=
  subroutine resonance_mapping_write (res_map)
    class(resonance_mapping_t), intent(in) :: res_map
    integer :: i_res
    do i_res = 1, size (res_map%res_histories)
       call res_map%res_histories(i_res)%write ()
    end do
  end subroutine resonance_mapping_write

@ %def resonance_mapping_write
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_value => resonance_mapping_get_resonance_value
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_value (res_map, i_res, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: i_res
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    p_map = res_map%res_histories(i_res)%mapping (p, i_gluon)
  end function resonance_mapping_get_resonance_value

@ %def resonance_mapping_get_resonance_value
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_all => resonance_mapping_get_resonance_all
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_all (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    p_map = zero
    do i_res = 1, size (res_map%res_histories)
       associate (res => res_map%res_histories(i_res))
          if (any (res_map%i_res_to_alr (i_res, :) == alr)) &
             p_map = p_map + res%mapping (p, i_gluon)
       end associate
    end do
  end function resonance_mapping_get_resonance_all

@ %def resonance_mapping_get_resonance_all
@
<<fks regions: resonance mapping: TBP>>=
  procedure :: get_resonance_alr => resonance_mapping_get_resonance_alr
<<fks regions: procedures>>=
  function resonance_mapping_get_resonance_alr (res_map, alr, p, i_gluon) result (p_map)
    real(default) :: p_map
    class(resonance_mapping_t), intent(in) :: res_map
    integer, intent(in) :: alr
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in), optional :: i_gluon
    integer :: i_res
    i_res = res_map%alr_to_i_res (alr)
    p_map = res_map%res_histories(i_res)%mapping (p, i_gluon)
  end function resonance_mapping_get_resonance_alr

@ %def resonance_mapping_get_resonance_alr
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure resonance_mapping_assign
  end interface

<<fks regions: procedures>>=
  subroutine resonance_mapping_assign (res_map_out, res_map_in)
    type(resonance_mapping_t), intent(out) :: res_map_out
    type(resonance_mapping_t), intent(in) :: res_map_in
    if (allocated (res_map_in%res_histories)) then
       allocate (res_map_out%res_histories (size (res_map_in%res_histories)))
       res_map_out%res_histories = res_map_in%res_histories
    end if
    if (allocated (res_map_in%alr_to_i_res)) then
       allocate (res_map_out%alr_to_i_res (size (res_map_in%alr_to_i_res)))
       res_map_out%alr_to_i_res = res_map_in%alr_to_i_res
    end if
    if (allocated (res_map_in%i_res_to_alr)) then
       allocate (res_map_out%i_res_to_alr &
          (size (res_map_in%i_res_to_alr, 1), size (res_map_in%i_res_to_alr, 2)))
       res_map_out%i_res_to_alr = res_map_in%i_res_to_alr
    end if
    if (allocated (res_map_in%p_res)) then
       allocate (res_map_out%p_res (size (res_map_in%p_res)))
       res_map_out%p_res = res_map_in%p_res
    end if
  end subroutine resonance_mapping_assign

@ %def resonance_mapping_assign
@
<<fks regions: types>>=
  type, abstract :: fks_mapping_t
     real(default) :: sumdij
     real(default) :: sumdij_soft
     logical :: pseudo_isr = .false.
  contains
  <<fks regions: fks mapping: TBP>>
  end type fks_mapping_t

@ %def fks_mapping_t
@
<<fks regions: public>>=
  public :: fks_mapping_default_t
<<fks regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_default_t
    real(default) :: exp_1, exp_2
    integer :: n_in
  contains
  <<fks regions: fks mapping default: TBP>>
  end type fks_mapping_default_t

@ %def fks_mapping_default_t
@
<<fks regions: public>>=
  public :: fks_mapping_resonances_t
<<fks regions: types>>=
  type, extends (fks_mapping_t) :: fks_mapping_resonances_t
    real(default) :: exp_1, exp_2
    type(resonance_mapping_t) :: res_map
    integer :: i_con = 0
  contains
  <<fks regions: fks mapping resonances: TBP>>
  end type fks_mapping_resonances_t

@ %def fks_mapping_resonances_t
@
<<fks regions: interfaces>>=
  interface operator(==)
    module procedure flv_structure_equivalent
  end interface

  interface assignment(=)
    module procedure flv_structure_assign_flv
    module procedure flv_structure_assign_integer
  end interface

@ %def operator_equiv
@
<<fks regions: public>>=
  public :: region_data_t
<<fks regions: types>>=
  type :: region_data_t
    type(singular_region_t), dimension(:), allocatable :: regions
    type(flv_structure_t), dimension(:), allocatable :: flv_born
    type(flv_structure_t), dimension(:), allocatable :: flv_real
    integer, dimension(:), allocatable :: emitters
    integer :: n_regions = 0
    integer :: n_emitters = 0
    integer :: n_flv_born = 0
    integer :: n_flv_real = 0
    integer :: n_in = 0
    integer :: n_legs_born = 0
    integer :: n_legs_real = 0
    integer :: n_phs = 0
    integer, dimension(:), allocatable :: underlying_borns
    type(flavor_t) :: flv_extra
    class(fks_mapping_t), allocatable :: fks_mapping
    integer, dimension(:), allocatable :: resonances
    type(resonance_contributors_t), dimension(:), allocatable :: alr_contributors
    integer, dimension(:), allocatable :: alr_to_i_contributor
    integer, dimension(:), allocatable :: i_phs_to_i_con
  contains
  <<fks regions: reg data: TBP>>
  end type region_data_t

@ %def region_data_t
@
<<fks regions: reg data: TBP>>=
  procedure :: allocate_fks_mappings => region_data_allocate_fks_mappings
<<fks regions: procedures>>=
  subroutine region_data_allocate_fks_mappings (reg_data, mapping_type)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: mapping_type

    select case (mapping_type)
    case (FKS_DEFAULT)
       allocate (fks_mapping_default_t :: reg_data%fks_mapping)
    case (FKS_RESONANCES)
       allocate (fks_mapping_resonances_t :: reg_data%fks_mapping)
    case default
       call msg_fatal ("Init region_data: FKS mapping not implemented!")
    end select
  end subroutine region_data_allocate_fks_mappings

@ %def region_data_allocate_fks_mappings
@
<<fks regions: reg data: TBP>>=
  procedure :: init => region_data_init
<<fks regions: procedures>>=
  subroutine region_data_init (reg_data, n_in, model, flavor_born, &
    flavor_real)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: n_in
    type(model_t), intent(in) :: model
    integer, intent(in), dimension(:,:) :: flavor_born, flavor_real
    type(ftuple_list_t), dimension(:), allocatable :: ftuples
    integer, dimension(:), allocatable :: emitter
    type(flv_structure_t), dimension(:), allocatable :: flst_alr
    integer :: i
    reg_data%n_in = n_in
    reg_data%n_flv_born = size (flavor_born, dim = 2)
    reg_data%n_flv_real = size (flavor_real, dim = 2)
    reg_data%n_legs_born = size (flavor_born, dim = 1)
    reg_data%n_legs_real = reg_data%n_legs_born + 1
    allocate (reg_data%flv_born (reg_data%n_flv_born))
    allocate (reg_data%flv_real (reg_data%n_flv_real))
    do i = 1, reg_data%n_flv_born
       call reg_data%flv_born(i)%init (flavor_born (:, i), n_in)
    end do
    do i = 1, reg_data%n_flv_real
       call reg_data%flv_real(i)%init (flavor_real (:, i), n_in)
    end do

    call reg_data%flv_extra%init &
       (reg_data%flv_real(1)%flst(reg_data%n_legs_real), model)
    call reg_data%find_regions (model, ftuples, emitter, flst_alr)
    call reg_data%init_singular_regions (ftuples, emitter, flst_alr)
    call reg_data%find_emitters ()
    call reg_data%set_underlying_borns ()
    call reg_data%evaluate_flavors (model)
    call reg_data%set_splitting_info ()
  end subroutine region_data_init

@ %def region_data_init
@
<<fks regions: reg data: TBP>>=
  procedure :: init_resonance_information => region_data_init_resonance_information
<<fks regions: procedures>>=
  subroutine region_data_init_resonance_information (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    call reg_data%enlarge_singular_regions_with_resonances ()
    call reg_data%find_resonances ()
  end subroutine region_data_init_resonance_information

@ %def region_data_init_resonance_information
@
<<fks regions: reg data: TBP>>=
  procedure :: set_resonance_mappings => region_data_set_resonance_mappings
<<fks regions: procedures>>=
  subroutine region_data_set_resonance_mappings (reg_data, resonance_histories)
    class(region_data_t), intent(inout) :: reg_data
    type(resonance_history_t), intent(in), dimension(:) :: resonance_histories
    select type (map => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       call map%res_map%init (resonance_histories)
    end select
  end subroutine region_data_set_resonance_mappings

@ %def region_data_set_resonance_mappings
@
<<fks regions: reg data: TBP>>=
  procedure :: setup_fks_mappings => region_data_setup_fks_mappings
<<fks regions: procedures>>=
  subroutine region_data_setup_fks_mappings (reg_data, template, n_in)
    class(region_data_t), intent(inout) :: reg_data
    type(fks_template_t), intent(in) :: template
    integer, intent(in) :: n_in
    call reg_data%allocate_fks_mappings (template%mapping_type)
    select type (map => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       call map%set_parameter (n_in, template%fks_dij_exp1, template%fks_dij_exp2)
    end select
  end subroutine region_data_setup_fks_mappings

@ %def region_data_setup_fks_mappings
@ So far, we have only created singular regions for a non-resonant case. When
resonance mappings are required, we have more singular regions, since they
must now be identified by their emitter-resonance pair index, where the emitter
must be compatible with the resonance.
<<fks regions: reg data: TBP>>=
  procedure :: enlarge_singular_regions_with_resonances &
     => region_data_enlarge_singular_regions_with_resonances
<<fks regions: procedures>>=
  subroutine region_data_enlarge_singular_regions_with_resonances (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer, dimension(:), allocatable :: alr_new_to_old
    integer :: n_alr_new
    type(singular_region_t), dimension(:), allocatable :: save_regions
    call msg_debug (D_SUBTRACTION, "region_data_enlarge_singular_regions_with_resonances")
    call debug_input_values ()
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       return
    type is (fks_mapping_resonances_t)
       allocate (save_regions (reg_data%n_regions))
       do alr = 1, reg_data%n_regions
          save_regions(alr) = reg_data%regions(alr)
       end do

       associate (res_map => fks_mapping%res_map)
          call res_map%set_alr_to_i_res (reg_data%regions, alr_new_to_old)
          deallocate (reg_data%regions)
          n_alr_new = size (alr_new_to_old)
          reg_data%n_regions = n_alr_new
          allocate (reg_data%regions (n_alr_new))
          do alr = 1, n_alr_new
             reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
             reg_data%regions(alr)%i_res = res_map%alr_to_i_res (alr)
          end do
       end associate
    end select

  contains

    subroutine debug_input_values ()
      if (debug2_active (D_SUBTRACTION)) then
         call reg_data%write ()
      end if
    end subroutine debug_input_values

  end subroutine region_data_enlarge_singular_regions_with_resonances

@ %def region_data_enlarge_singular_regions_with_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: set_isr_pseudo_regions => region_data_set_isr_pseudo_regions
<<fks regions: procedures>>=
  subroutine region_data_set_isr_pseudo_regions (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer :: n_alr_new
    !!! Subroutine called for threshold factorization ->
    !!! Size of singular regions at this point is fixed
    type(singular_region_t), dimension(2) :: save_regions
    integer, dimension(4) :: alr_new_to_old
    do alr = 1, reg_data%n_regions
       save_regions(alr) = reg_data%regions(alr)
    end do
    n_alr_new = reg_data%n_regions * 2
    alr_new_to_old = [1, 1, 2, 2]
    deallocate (reg_data%regions)
    allocate (reg_data%regions (n_alr_new))
    reg_data%n_regions = n_alr_new
    do alr = 1, n_alr_new
       reg_data%regions(alr) = save_regions(alr_new_to_old (alr))
       call add_pseudo_emitters (reg_data%regions(alr))
       if (mod (alr, 2) == 0) reg_data%regions(alr)%pseudo_isr = .true.
    end do
  contains
    subroutine add_pseudo_emitters (sregion)
      type(singular_region_t), intent(inout) :: sregion
      type(ftuple_t), dimension(2) :: ftuples_save
      integer :: alr
      do alr = 1, 2
         ftuples_save(alr) = sregion%ftuples(alr)
      end do
      deallocate (sregion%ftuples)
      sregion%nregions = sregion%nregions * 2
      allocate (sregion%ftuples (sregion%nregions))
      do alr = 1, sregion%nregions
         sregion%ftuples(alr) = ftuples_save (alr_new_to_old(alr))
         if (mod (alr, 2) == 0) sregion%ftuples(alr)%pseudo_isr = .true.
      end do
    end subroutine add_pseudo_emitters
  end subroutine region_data_set_isr_pseudo_regions

@ %def region_data_set_isr_pseudo_regions
@
<<fks regions: reg data: TBP>>=
  procedure :: evaluate_flavors => region_data_evaluate_flavors
<<fks regions: procedures>>=
  subroutine region_data_evaluate_flavors (reg_data, model)
    class(region_data_t), intent(inout) :: reg_data
    type(model_t), intent(in) :: model
    integer :: i
    do i = 1, reg_data%n_regions
       associate (region => reg_data%regions(i))
          call region%flst_uborn%init_mass_and_color (model)
          call region%flst_real%init_mass_and_color (model)
       end associate
    end do
    do i = 1, reg_data%n_flv_born
       call reg_data%flv_born(i)%init_mass_and_color (model)
    end do
    do i = 1, reg_data%n_flv_real
       call reg_data%flv_real(i)%init_mass_and_color (model)
    end do
  end subroutine region_data_evaluate_flavors

@ %def region_data_evaluate_flavors
@
<<fks regions: reg data: TBP>>=
  procedure :: uses_resonances => region_data_uses_resonances
<<fks regions: procedures>>=
  function region_data_uses_resonances (reg_data) result (val)
    logical :: val
    class(region_data_t), intent(in) :: reg_data
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       val = .true.
    class default
       val = .false.
    end select
  end function region_data_uses_resonances

@ %def region_data_uses_resonances
@ Creates a list containing the emitter of each singular region.
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter_list => region_data_get_emitter_list
<<fks regions: procedures>>=
  pure function region_data_get_emitter_list (reg_data) result(emitters)
    class(region_data_t), intent(in) :: reg_data
    integer, dimension(:), allocatable :: emitters
    integer :: i
    allocate (emitters (reg_data%n_regions))
    do i = 1, reg_data%n_regions
       emitters(i) = reg_data%regions(i)%emitter
    end do
  end function region_data_get_emitter_list

@ %def region_data_get_emitter_list
@
<<fks regions: reg data: TBP>>=
  procedure :: get_associated_resonances => region_data_get_associated_resonances
<<fks regions: procedures>>=
  function region_data_get_associated_resonances (reg_data, emitter) result (res)
    integer, dimension(:), allocatable :: res
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: emitter
    integer :: alr, i
    integer :: n_res
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       n_res = 0

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) &
             n_res = n_res + 1
       end do

       if (n_res > 0) then
          allocate (res (n_res))
       else
          return
       end if
       i = 1

       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%emitter == emitter) then
             res (i) = fks_mapping%res_map%alr_to_i_res (alr)
             i = i + 1
          end if
       end do
    end select
  end function region_data_get_associated_resonances

@ %def region_data_get_associated_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: emitter_is_compatible_with_resonance => &
     region_data_emitter_is_compatible_with_resonance
<<fks regions: procedures>>=
  function region_data_emitter_is_compatible_with_resonance &
     (reg_data, i_res, emitter) result (compatible)
     logical :: compatible
     class(region_data_t), intent(in) :: reg_data
     integer, intent(in) :: i_res, emitter
     integer :: i_res_alr, alr
     compatible = .false.
     select type (fks_mapping => reg_data%fks_mapping)
     type is (fks_mapping_resonances_t)
        do alr = 1, reg_data%n_regions
           i_res_alr = fks_mapping%res_map%alr_to_i_res (alr)
           if (i_res_alr == i_res .and. reg_data%get_emitter(alr) == emitter) then
              compatible = .true.
              exit
           end if
        end do
     end select
  end function region_data_emitter_is_compatible_with_resonance

@ %def region_data_emitter_is_compatible_with_resonance
@
<<fks regions: reg data: TBP>>=
  procedure :: emitter_is_in_resonance => region_data_emitter_is_in_resonance
<<fks regions: procedures>>=
  function region_data_emitter_is_in_resonance (reg_data, i_res, emitter) result (exist)
    logical :: exist
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer :: i
    exist = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories(i_res))
          do i = 1, res_history%n_resonances
             exist = exist .or. any (res_history%resonances(i)%contributors%c == emitter)
          end do
      end associate
    end select
  end function region_data_emitter_is_in_resonance

@ %def region_data_emitter_is_in_resonance
@
<<fks regions: reg data: TBP>>=
  procedure :: get_contributors => region_data_get_contributors
<<fks regions: procedures>>=
  subroutine region_data_get_contributors (reg_data, i_res, emitter, c, success)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_res, emitter
    integer, intent(inout), dimension(:), allocatable :: c
    logical, intent(out) :: success
    integer :: i
    success = .false.
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       associate (res_history => fks_mapping%res_map%res_histories (i_res))
          do i = 1, res_history%n_resonances
             if (any (res_history%resonances(i)%contributors%c == emitter)) then
                allocate (c (size (res_history%resonances(i)%contributors%c)))
                c = res_history%resonances(i)%contributors%c
                success = .true.
                exit
             end if
          end do
       end associate
    end select
  end subroutine region_data_get_contributors

@ %def region_data_get_contributors
@
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter => region_data_get_emitter
<<fks regions: procedures>>=
  pure function region_data_get_emitter (reg_data, alr) result (emitter)
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: alr
    integer :: emitter
    emitter = reg_data%regions(alr)%emitter
  end function region_data_get_emitter

@ %def region_data_get_emitter
@
<<fks regions: reg data: TBP>>=
  procedure :: get_underlying_born_index => region_data_get_underlying_born_index
<<fks regions: procedures>>=
  function region_data_get_underlying_born_index (reg_data, real_index) result (uborn_index)
    integer :: uborn_index
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: real_index
    integer :: alr
    uborn_index = 0
    do alr = 1, size (reg_data%regions)
       if (reg_data%regions(alr)%real_index == real_index) then
          uborn_index = reg_data%regions(alr)%uborn_index
          exit
       end if
    end do
  end function region_data_get_underlying_born_index

@ %def region_data_get_underlying_born_index
@ Creates a list of $\alpha_r$ which share the same underlying Born index.
We factor out the computation of the size of the underlying Born group so that we
do not need to call the whole routine twice when we work around the ifort
auto-allocation bug.
<<fks regions: reg data: TBP>>=
  procedure :: get_uborn_group_size => region_data_get_uborn_group_size
<<fks regions: procedures>>=
  function region_data_get_uborn_group_size (reg_data, uborn_index) result (n_uborn)
    integer :: n_uborn
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: uborn_index
    integer :: alr
    n_uborn = 0
    do alr = 1, reg_data%n_regions
       if (reg_data%regions(alr)%i_res > 1) cycle
       if (reg_data%regions(alr)%uborn_index == uborn_index) n_uborn = n_uborn + 1
    end do
  end function region_data_get_uborn_group_size

@ %def region_data_get_uborn_group_size
@
<<fks regions: reg data: TBP>>=
  procedure :: get_uborn_group => region_data_get_uborn_group
<<fks regions: procedures>>=
  function region_data_get_uborn_group (reg_data, uborn_index) result (uborn_group)
    integer, dimension(:), allocatable :: uborn_group
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: uborn_index
    integer :: alr, n_uborn, i_uborn
    n_uborn = reg_data%get_uborn_group_size (uborn_index)
    if (n_uborn > 0) then
       allocate (uborn_group (n_uborn))
       i_uborn = 1
       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%i_res > 1) cycle
          if (reg_data%regions(alr)%uborn_index == uborn_index) then
             uborn_group (i_uborn) = alr
             i_uborn = i_uborn + 1
          end if
       end do
    end if
  end function region_data_get_uborn_group

@ %def region_data_get_uborn_group
@
<<fks regions: reg data: TBP>>=
  procedure :: get_real_index => region_data_get_real_index
<<fks regions: procedures>>=
  function region_data_get_real_index (reg_data, i_phs) result (i_flv)
    integer :: i_flv
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i_phs
    type(phs_identifier_t), dimension(:), allocatable :: phs_id
    integer :: i
    i_flv = 0
    call reg_data%init_phs_identifiers (phs_id)
    do i = 1, reg_data%n_regions
       if (reg_data%regions(i)%emitter == phs_id(i_phs)%emitter) then
          i_flv = reg_data%regions(i)%real_index
          exit
       end if
    end do
    deallocate (phs_id)
  end function region_data_get_real_index

@ %def region_data_get_real_index
@ Same as above, for emitters with the same underlying Born index.
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter_group_size => region_data_get_emitter_group_size
<<fks regions: procedures>>=
  function region_data_get_emitter_group_size (reg_data, emitter) result (n_emitter)
    integer :: n_emitter
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: emitter
    integer :: alr
    n_emitter = 0
    do alr = 1, reg_data%n_regions
       if (reg_data%regions(alr)%i_res > 1) cycle
       if (reg_data%regions(alr)%emitter == emitter) n_emitter = n_emitter + 1
    end do
  end function region_data_get_emitter_group_size

@ %def region_data_get_emitter_group_size
@
<<fks regions: reg data: TBP>>=
  procedure :: get_emitter_group => region_data_get_emitter_group
<<fks regions: procedures>>=
  function region_data_get_emitter_group (reg_data, emitter) result (emitter_group)
    integer, dimension(:), allocatable :: emitter_group
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: emitter
    integer :: alr, n_emitter, i_emitter
    n_emitter = reg_data%get_emitter_group_size (emitter)
    if (n_emitter > 0) then
       allocate (emitter_group (n_emitter))
       i_emitter = 1
       do alr = 1, reg_data%n_regions
          if (reg_data%regions(alr)%i_res > 1) cycle
          if (reg_data%regions(alr)%emitter == emitter) then
             emitter_group (i_emitter) = alr
             i_emitter = i_emitter + 1
          end if
       end do
    end if
  end function region_data_get_emitter_group

@ %def region_data_get_emitter_group
@
<<fks regions: reg data: TBP>>=
  generic :: get_flv_states_born => get_flv_states_born_single, get_flv_states_born_array
  procedure :: get_flv_states_born_single => region_data_get_flv_states_born_single
  procedure :: get_flv_states_born_array => region_data_get_flv_states_born_array
<<fks regions: procedures>>=
  function region_data_get_flv_states_born_array (reg_data) result (flv_states)
    integer, dimension(:,:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer :: i_flv
    allocate (flv_states (reg_data%n_legs_born, reg_data%n_flv_born))
    do i_flv = 1, reg_data%n_flv_born
       flv_states (:, i_flv) = reg_data%flv_born(i_flv)%flst
    end do
  end function region_data_get_flv_states_born_array

  function region_data_get_flv_states_born_single (reg_data, i) result (flv_states)
    integer, dimension(:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i
    allocate (flv_states (reg_data%n_legs_born))
    flv_states = reg_data%flv_born(i)%flst
  end function region_data_get_flv_states_born_single

@ %def region_data_get_flv_states_born
<<fks regions: reg data: TBP>>=
  generic :: get_flv_states_real => get_flv_states_real_single, get_flv_states_real_array
  procedure :: get_flv_states_real_single => region_data_get_flv_states_real_single
  procedure :: get_flv_states_real_array => region_data_get_flv_states_real_array
<<fks regions: procedures>>=
  function region_data_get_flv_states_real_array (reg_data) result (flv_states)
    integer, dimension(:,:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer :: i_flv
    allocate (flv_states (reg_data%n_legs_real, reg_data%n_flv_real))
    do i_flv = 1, reg_data%n_flv_real
       flv_states (:, i_flv) = reg_data%flv_real(i_flv)%flst
    end do
  end function region_data_get_flv_states_real_array

  function region_data_get_flv_states_real_single (reg_data, i) result (flv_states)
    integer, dimension(:), allocatable :: flv_states
    class(region_data_t), intent(in) :: reg_data
    integer, intent(in) :: i
    allocate (flv_states (reg_data%n_legs_real))
    flv_states = reg_data%flv_real(i)%flst
  end function region_data_get_flv_states_real_single

@ %def region_data_get_flv_states_real
@ Returns $S_i = \frac{1}{\mathcal{D}d_i}$ or $S_{ij} =
\frac{1}{\mathcal{D}d_{ij}}$ for one particular singular region.  At
this point, the flavor array should be rearranged in such a way that
the emitted particle is at the last position of
the flavor structure list.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue => region_data_get_svalue
<<fks regions: procedures>>=
  function region_data_get_svalue (reg_data, p, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: alr, emitter
    integer, intent(in) :: i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       call map%compute_sumdij (reg_data%regions(alr), p)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%i_con = reg_data%alr_to_i_contributor (alr)
          map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       end select
       sval = map%svalue (p, emitter, reg_data%n_legs_real, i_res)
    end associate
  end function region_data_get_svalue

@ %def region_data_get_svalue
@ The same as above, but for the soft limit.
<<fks regions: reg data: TBP>>=
  procedure :: get_svalue_soft => region_data_get_svalue_soft
<<fks regions: procedures>>=
  function region_data_get_svalue_soft &
       (reg_data, p, p_soft, alr, emitter, i_res) result (sval)
    class(region_data_t), intent(inout) :: reg_data
    type(vector4_t), intent(in), dimension(:) :: p
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: sval
    associate (map => reg_data%fks_mapping)
       call map%compute_sumdij_soft (reg_data%regions(alr), p, p_soft)
       select type (map)
       type is (fks_mapping_resonances_t)
          map%i_con = reg_data%alr_to_i_contributor (alr)
          map%pseudo_isr = reg_data%regions(alr)%pseudo_isr
       end select
       sval = map%svalue_soft (p, p_soft, emitter, i_res)
    end associate
  end function region_data_get_svalue_soft

@ %def region_data_get_svalue_soft
@ This subroutine starts with a specification of $N$- and
$N+1$-particle configurations, [[flst_born]] and [[flst_real]], saved
in [[reg_data]]. From these, it creates a list of fundamental tuples,
a list of emitters and a list containing the $N+1$-particle
configuration, rearranged  in such a way that the emitter-radiation
pair is last ([[flst_alr]]). For the $e^+ \, e^- \, \rightarrow u \,
\bar{u} \, g$- example, the generated objects are shown in table
\ref{table:ftuples and flavors}. Note that at this point, [[flst_alr]]
is arranged in such a way that the emitter can only be equal to
$n_{legs}-1$ for final-state radiation or 0, 1, or 2 for initial-state
radiation. Further, it occurs that regions can be equivalent. For
example in table \ref{table:ftuples and flavors} the regions
correpsonding to \texttt{alr} = 1 and \texttt{alr} = 3 as well as
\texttt{alr} = 2 and \texttt{alr} = 4 describe the same physics and
are therefore equivalent.
@
<<fks regions: reg data: TBP>>=
  procedure :: find_regions => region_data_find_regions
<<fks regions: procedures>>=
  subroutine region_data_find_regions &
       (reg_data, model, ftuples, emitter, flst_alr)
    class(region_data_t), intent(in) :: reg_data
    type(model_t), intent(in) :: model
    type(ftuple_list_t), intent(out), dimension(:), allocatable :: ftuples
    integer, intent(out), dimension(:), allocatable :: emitter
    type(flv_structure_t), intent(out), dimension(:), allocatable :: flst_alr
    type(ftuple_t) :: current_ftuple
    integer, dimension(:), allocatable :: emitter_tmp
    type(flv_structure_t), dimension(:), allocatable :: flst_alr_tmp
    integer :: nreg, nborn, nreal
    integer :: nlegreal
    integer, parameter :: maxnregions = 200
    integer :: i_real

    nborn = size (reg_data%flv_born)
    nreal = size (reg_data%flv_real)
    nlegreal = size (reg_data%flv_real(1)%flst)
    allocate (ftuples (nreal))
    allocate (emitter_tmp (maxnregions))
    allocate (flst_alr_tmp (maxnregions))
    nreg = 0

    do i_real = 1, nreal
       call check_final_state_emissions (i_real, nreg)
       call check_initial_state_emissions (i_real, nreg)
    end do

    allocate (flst_alr (nreg))
    allocate (emitter (nreg))
    flst_alr(1 : nreg) = flst_alr_tmp(1 : nreg)
    emitter(1 : nreg) = emitter_tmp(1 : nreg)

  contains
    subroutine check_final_state_emissions (i_real, i_reg)
      integer, intent(in) :: i_real
      integer, intent(inout) :: i_reg
      integer :: leg1, leg2, i_born
      type(flv_structure_t) :: born_flavor
      logical :: valid1, valid2
      do leg1 = reg_data%n_in + 1, nlegreal
         do leg2 = leg1 + 1, nlegreal
            do i_born = 1, nborn
               born_flavor = reg_data%flv_born(i_born)
               associate (flv_real => reg_data%flv_real(i_real))
                  valid1 = flv_real%valid_pair(leg1, leg2, born_flavor, model)
                  valid2 = flv_real%valid_pair(leg2, leg1, born_flavor, model)
                  if ( valid1 .or. valid2) then
                     i_reg = i_reg + 1
                     if(valid1) then
                        flst_alr_tmp(i_reg) = &
                           create_alr (flv_real, reg_data%n_in, leg1, leg2)
                     else
                        flst_alr_tmp(i_reg) = &
                           create_alr (flv_real, reg_data%n_in, leg2, leg1)
                     end if
                     call current_ftuple%set (leg1, leg2)
                     call current_ftuple%determine_splitting_type_fsr &
                        (flv_real, leg1, leg2)
                     call ftuples(i_real)%append (current_ftuple)
                     emitter_tmp(i_reg) = nlegreal - 1
                     exit
                  end if
               end associate
            end do
         end do
      end do
    end subroutine check_final_state_emissions

    subroutine check_initial_state_emissions (i_real, i_reg)
      integer, intent(in) :: i_real
      integer, intent(inout) :: i_reg
      integer :: leg, i_born, emitter
      type(flv_structure_t) :: born_flavor
      logical :: valid1, valid2
      do leg = reg_data%n_in + 1, nlegreal
         do i_born = 1, nborn
            born_flavor = reg_data%flv_born (i_born)
            associate (flv_real => reg_data%flv_real(i_real))
               valid1 = flv_real%valid_pair(1, leg, born_flavor, model)
               if (reg_data%n_in > 1) then
                  valid2 = flv_real%valid_pair(2, leg, born_flavor, model)
               else
                  valid2 = .false.
               end if
               if (valid1 .and. valid2) then
                  emitter = 0
               else if (valid1 .and. .not. valid2) then
                  emitter = 1
               else if (.not. valid1 .and. valid2) then
                  emitter = 2
               else
                  emitter = -1
               end if
               if (valid1 .or. valid2) then
                  i_reg = i_reg + 1
                  call current_ftuple%set(emitter, leg)
                  call current_ftuple%determine_splitting_type_isr &
                     (flv_real, emitter, leg)
                  call ftuples(i_real)%append (current_ftuple)
                  emitter_tmp(i_reg) = emitter
                  flst_alr_tmp(i_reg) = &
                     create_alr (flv_real, reg_data%n_in, emitter, leg)
               end if
            end associate
         end do
      end do
    end subroutine check_initial_state_emissions
  end subroutine region_data_find_regions

@ %def region_data_find_regions
@ Creates singular regions according to table \ref{table:singular
regions}. It scans all regions in table \ref{table:ftuples and
flavors} and records the real flavor structures. If they are
equivalent, the flavor structure is not recorded, but the multiplicity
of the present one is increased.
<<fks regions: reg data: TBP>>=
  procedure :: init_singular_regions => region_data_init_singular_regions
<<fks regions: procedures>>=
  subroutine region_data_init_singular_regions &
         (reg_data, ftuples, emitter, flv_alr)
    class(region_data_t), intent(inout) :: reg_data
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: ftuples
    integer :: n_valid_ftuples
    integer, intent(in), dimension(:) :: emitter
    type(flv_structure_t), intent(in), dimension(:) :: flv_alr
    type(flv_structure_t), dimension(:), allocatable :: flv_uborn, flv_alr2
    integer, dimension(:), allocatable :: mult
    integer, dimension(:), allocatable :: flst_emitter
    integer :: nregions, maxregions
    integer, dimension(:,:), allocatable :: perm_list
    integer, dimension(:), allocatable :: index
    integer :: i, j, k, l
    integer :: nlegs
    logical :: equiv
    integer :: i_first, j_first
    integer, dimension(:), allocatable :: &
         region_to_ftuple, ftuple_limits, k_index
    type(flv_structure_t) :: flv_save

    maxregions = size (emitter)
    nlegs = flv_alr(1)%nlegs

    allocate (flv_uborn (maxregions))
    allocate (flv_alr2 (maxregions))
    allocate (mult (maxregions))
    allocate (flst_emitter (maxregions))
    allocate (index (maxregions))
    allocate (region_to_ftuple (maxregions))
    allocate (k_index (maxregions))

    mult = 0
    n_valid_ftuples = 0
    do i = 1, size (ftuples)
       if (ftuples(i)%get_n_tuples() > 0) &
          n_valid_ftuples = n_valid_ftuples + 1
    end do
    allocate (ftuple_limits (n_valid_ftuples))

    j = 1
    do i = 1, size (ftuples)
       if (ftuples(i)%get_n_tuples() > 0) then
          ftuple_limits(j) = ftuples(i)%get_n_tuples ()
          j = j + 1
       end if
    end do
    if (.not. (sum (ftuple_limits) == maxregions)) &
       call msg_fatal ("Too many regions!")
    k = 1
    do j = 1, n_valid_ftuples
       do i = 1, ftuple_limits(j)
          region_to_ftuple(k) = i
          k = k + 1
       end do
    end do
    i_first = 1
    j_first = 1
    j = 1
    SCAN_REGIONS: do l = 1, n_valid_ftuples
       SCAN_FTUPLES: do i = i_first, i_first + ftuple_limits (l) - 1
          equiv = .false.
          if (i == i_first) then
             flv_alr2(j) = flv_alr(i)
             mult(j) = mult(j) + 1
             flv_uborn(j) = flv_alr(i)%create_uborn (emitter(i))
             flst_emitter(j) = emitter(i)
             index (j) = region_to_index(ftuples, i)
             k_index (j) = region_to_ftuple(i)
             j = j + 1
          else
             !!! Check for equivalent flavor structures
             do k = j_first, j - 1
                if (emitter(i) == emitter(k) .and. emitter(i) > reg_data%n_in) then
                   if (flv_alr(i) == flv_alr2(k) .and. &
                      flv_alr(i)%flst(nlegs - 1) == flv_alr2(k)%flst(nlegs - 1) &
                      .and. flv_alr(i)%flst(nlegs) == flv_alr2(k)%flst(nlegs)) then
                      mult(k) = mult(k) + 1
                      equiv = .true.
                      call ftuples (region_to_index(ftuples, i))%set_equiv &
                         (k_index(k), region_to_ftuple(i))
                      exit
                   end if
                else if (emitter(i) == emitter(k) .and. emitter(i) <= reg_data%n_in) then
                   if (flv_alr(i) == flv_alr2(k)) then
                      mult(k) = mult(k) + 1
                      equiv = .true.
                      call ftuples (region_to_index(ftuples,i))%set_equiv &
                         (k_index(k), region_to_ftuple(i))
                      exit
                   end if
                end if
             end do
             if (.not. equiv) then
                flv_alr2(j) = flv_alr(i)
                mult(j) = mult(j) + 1
                flv_uborn(j) = flv_alr(i)%create_uborn (emitter(i))
                flst_emitter(j) = emitter(i)
                index (j) = region_to_index (ftuples, i)
                k_index (j) = region_to_ftuple(i)
                j = j + 1
             end if
          end if
       end do SCAN_FTUPLES
       i_first = i_first + ftuple_limits(l)
       j_first = j_first + j - 1
    end do SCAN_REGIONS
    nregions = j - 1
    allocate (reg_data%regions (nregions))
    reg_data%n_regions = nregions
    do j = 1, nregions
       do i = 1, reg_data%n_flv_born
          if (reg_data%flv_born (i) == flv_uborn (j)) then
             if (allocated (perm_list)) deallocate (perm_list)
             call fks_permute_born &
                (reg_data%flv_born (i), reg_data%n_in, flv_uborn (j), perm_list)
             call fks_apply_perm (flv_alr2(j), flst_emitter(j), perm_list)
          end if
       end do
    end do
    do i = 1, nregions
       call reg_data%regions(i)%init (i, mult(i), 0, flv_alr2(i), &
          flv_uborn(i), reg_data%flv_born, flst_emitter(i), ftuples, &
          index)
    end do
    ! TODO: (bcn 2015-12-15) can this be put in singular_region_init?
    k = 1
    associate (regions => reg_data%regions)
       do i = 1, nregions
          if (i == 1) then
             regions(i)%real_index = 1
             flv_save = flv_alr2(1)
             cycle
          end if
          if (flv_alr2(i) == flv_save) then
             regions(i)%real_index = k
          else
             k = k + 1
             regions(i)%real_index = k
             flv_save = flv_alr2(i)
          end if
       end do
    end associate

  end subroutine region_data_init_singular_regions

@ %def region_data_init_singular_regions
@ Create an array containing all emitters and resonances of [[region_data]].
<<fks regions: reg data: TBP>>=
  procedure :: find_emitters => region_data_find_emitters
<<fks regions: procedures>>=
  subroutine region_data_find_emitters (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, n_em, em
    integer, dimension(N_MAX_ALR) :: em_count
    em_count = -1
    n_em = 0

    !!!Count the number of different emitters
    do alr = 1, reg_data%n_regions
       em = reg_data%regions(alr)%emitter
       if (.not. any (em_count == em)) then
          n_em = n_em + 1
          em_count(alr) = em
       end if
    end do

    if (n_em < 1) call msg_fatal ("region_data_find_emitters: No emitters found!")
    reg_data%n_emitters = n_em
    allocate (reg_data%emitters (reg_data%n_emitters))
    reg_data%emitters = -1

    j = 1
    do alr = 1, size (reg_data%regions)
       em = reg_data%regions(alr)%emitter
       if (.not. any (reg_data%emitters == em)) then
          reg_data%emitters(j) = em
          j = j + 1
       end if
    end do
  end subroutine region_data_find_emitters

@ %def region_data_find_emitters
@
<<fks regions: reg data: TBP>>=
  procedure :: find_resonances => region_data_find_resonances
<<fks regions: procedures>>=
  subroutine region_data_find_resonances (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr, j, k, n_res, n_contr
    integer :: res
    integer, dimension(10) :: res_count
    type(resonance_contributors_t), dimension(10) :: contributors_count
    type(resonance_contributors_t) :: contributors
    integer :: i_res, emitter
    logical :: share_emitter
    res_count = -1
    n_res = 0; n_contr = 0

    !!! Count the number of different resonances
    do alr = 1, reg_data%n_regions
       select type (fks_mapping => reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (res_count == res)) then
             n_res = n_res + 1
             res_count(alr) = res
          end if
       end select
    end do

    if (n_res > 0) allocate (reg_data%resonances (n_res))

    j = 1
    select type (fks_mapping => reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       do alr = 1, size (reg_data%regions)
          res = fks_mapping%res_map%alr_to_i_res (alr)
          if (.not. any (reg_data%resonances == res)) then
             reg_data%resonances(j) = res
             j = j + 1
          end if
       end do

       allocate (reg_data%alr_to_i_contributor (size (reg_data%regions)))
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (contributors_count == contributors)) then
             n_contr = n_contr + 1
             contributors_count(alr) = contributors
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
       allocate (reg_data%alr_contributors (n_contr))
       j = 1
       do alr = 1, size (reg_data%regions)
          i_res = fks_mapping%res_map%alr_to_i_res (alr)
          emitter = reg_data%regions(alr)%emitter
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
          call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
          if (.not. share_emitter) cycle
          if (.not. any (reg_data%alr_contributors == contributors)) then
             reg_data%alr_contributors(j) = contributors
             reg_data%alr_to_i_contributor (alr) = j
             j = j + 1
          else
             do k = 1, size (reg_data%alr_contributors)
                if (reg_data%alr_contributors(k) == contributors) exit
             end do
             reg_data%alr_to_i_contributor (alr) = k
          end if
          if (allocated (contributors%c)) deallocate (contributors%c)
       end do
    end select
    call reg_data%extend_ftuples (n_res)
    call reg_data%set_contributors ()

  end subroutine region_data_find_resonances

@ %def region_data_find_resonances
@
<<fks regions: reg data: TBP>>=
  procedure :: set_i_phs_to_i_con => region_data_set_i_phs_to_i_con
<<fks regions: procedures>>=
  subroutine region_data_set_i_phs_to_i_con (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: alr
    integer :: i_res, emitter, i_con, i_phs, i_em
    type(phs_identifier_t), dimension(:), allocatable :: phs_id_tmp
    logical :: share_emitter, phs_exist
    type(resonance_contributors_t) :: contributors
    allocate (phs_id_tmp (reg_data%n_phs))
    if (allocated (reg_data%resonances)) then
       allocate (reg_data%i_phs_to_i_con (reg_data%n_phs))
       do i_em = 1, size (reg_data%emitters)
          emitter = reg_data%emitters(i_em)
          do i_res = 1, size (reg_data%resonances)
             if (reg_data%emitter_is_compatible_with_resonance (i_res, emitter)) then
                alr = find_alr (emitter, i_res)
                if (alr == 0) call msg_fatal ("Could not find requested alpha region!")
                i_con = reg_data%alr_to_i_contributor (alr)
                call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
                if (.not. share_emitter) cycle
                call check_for_phs_identifier &
                   (phs_id_tmp, reg_data%n_in, emitter, contributors%c, phs_exist, i_phs)
                if (phs_id_tmp(i_phs)%emitter < 0) then
                   phs_id_tmp(i_phs)%emitter = emitter
                   allocate (phs_id_tmp(i_phs)%contributors (size (contributors%c)))
                   phs_id_tmp(i_phs)%contributors = contributors%c
                end if
                reg_data%i_phs_to_i_con (i_phs) = i_con
             end if
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       end do
    end if
  contains
    function find_alr (emitter, i_res) result (alr)
       integer :: alr
       integer, intent(in) :: emitter, i_res
       integer :: i
       do i = 1, reg_data%n_regions
          if (reg_data%regions(i)%emitter == emitter .and. &
              reg_data%regions(i)%i_res == i_res) then
             alr = i
             return
          end if
       end do
       alr = 0
    end function find_alr
  end subroutine region_data_set_i_phs_to_i_con

@ %def region_data_set_i_phs_to_i_con
@
<<fks regions: reg data: TBP>>=
  procedure :: set_alr_to_i_phs => region_data_set_alr_to_i_phs
<<fks regions: procedures>>=
  subroutine region_data_set_alr_to_i_phs (reg_data, phs_identifiers, alr_to_i_phs)
    class(region_data_t), intent(inout) :: reg_data
    type(phs_identifier_t), intent(in), dimension(:) :: phs_identifiers
    integer, intent(out), dimension(:) :: alr_to_i_phs
    integer :: alr, i_phs
    integer :: emitter, i_res
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    do alr = 1, reg_data%n_regions
       associate (region => reg_data%regions(alr))
          emitter = region%emitter
          i_res = region%i_res
          if (i_res /= 0) then
             !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
             call reg_data%get_contributors (i_res, emitter, &
                contributors%c, share_emitter)
             if (.not. share_emitter) cycle
          end if
          if (allocated (contributors%c)) then
             call check_for_phs_identifier (phs_identifiers, reg_data%n_in, &
                emitter, contributors%c, phs_exist = phs_exist, i_phs = i_phs)
          else
             call check_for_phs_identifier (phs_identifiers, reg_data%n_in, &
                emitter, phs_exist = phs_exist, i_phs = i_phs)
          end if
          if (.not. phs_exist) &
             call msg_fatal ("phs identifiers are not set up correctly!")
          alr_to_i_phs(alr) = i_phs
       end associate
       if (allocated (contributors%c)) deallocate (contributors%c)
    end do
  end subroutine region_data_set_alr_to_i_phs

@ %def region_data_set_alr_to_i_phs
@
<<fks regions: reg data: TBP>>=
  procedure :: set_contributors => region_data_set_contributors
<<fks regions: procedures>>=
  subroutine region_data_set_contributors (reg_data)
     class(region_data_t), intent(inout) :: reg_data
     integer :: alr, i_res, i_reg, i_con
     integer :: i1, i2, i_em
     integer, dimension(:), allocatable :: contributors
     logical :: share_emitter
     do alr = 1, size (reg_data%regions)
        associate (sregion => reg_data%regions(alr))
           allocate (sregion%i_reg_to_i_con (sregion%nregions))
           do i_reg = 1, sregion%nregions
              call sregion%ftuples(i_reg)%get (i1, i2)
              i_em = get_emitter_index (i1, i2, reg_data%n_legs_real)
              i_res = sregion%ftuples(i_reg)%i_res
              call reg_data%get_contributors (i_res, i_em, contributors, share_emitter)
	      !!! Lookup contributor index
              do i_con = 1, size (reg_data%alr_contributors)
                 if (all (reg_data%alr_contributors(i_con)%c == contributors)) then
                    sregion%i_reg_to_i_con (i_reg) = i_con
                    exit
                 end if
              end do
              deallocate (contributors)
           end do
        end associate
     end do
  contains
     function get_emitter_index (i1, i2, n) result (i_em)
       integer :: i_em
       integer, intent(in) :: i1, i2, n
       if (i1 == n) then
          i_em = i2
       else
          i_em = i1
       end if
     end function get_emitter_index
  end subroutine region_data_set_contributors

@ %def region_data_set_contributors
@ This extension of the ftuples is still too naive as it assumes that the same
resonances are possible for all ftuples
<<fks regions: reg data: TBP>>=
  procedure :: extend_ftuples => region_data_extend_ftuples
<<fks regions: procedures>>=
  subroutine region_data_extend_ftuples (reg_data, n_res)
    class(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: n_res
    integer :: alr, n_reg_save
    integer :: i_reg, i_res, i_em, k
    type(ftuple_t), dimension(:), allocatable :: ftuple_save
    integer :: n_new
    do alr = 1, size (reg_data%regions)
       associate (sregion => reg_data%regions(alr))
          n_reg_save = sregion%nregions
          allocate (ftuple_save (n_reg_save))
          ftuple_save = sregion%ftuples
          n_new = count_n_new_ftuples (sregion, n_res)
          deallocate (sregion%ftuples)
          sregion%nregions = n_new
          allocate (sregion%ftuples (n_new))
          k = 1
          do i_res = 1, n_res
             do i_reg = 1, n_reg_save
                associate (ftuple_new => sregion%ftuples(k))
                   i_em = ftuple_save(i_reg)%ireg(1)
                   if (reg_data%emitter_is_in_resonance (i_res, i_em)) then
                      call ftuple_new%set (i_em, ftuple_save(i_reg)%ireg(2))
                      ftuple_new%i_res = i_res
                      ftuple_new%splitting_type = ftuple_save(i_reg)%splitting_type
                      k = k + 1
                   end if
                end associate
             end do
          end do
       end associate
       deallocate (ftuple_save)
    end do
  contains
    function count_n_new_ftuples (sregion, n_res) result (n_new)
      integer :: n_new
      type(singular_region_t), intent(in) :: sregion
      integer, intent(in) :: n_res
      integer :: i_reg, i_res, i_em
      n_new = 0
      do i_reg = 1, sregion%nregions
         do i_res = 1, n_res
            i_em = sregion%ftuples(i_reg)%ireg(1)
            if (reg_data%emitter_is_in_resonance (i_res, i_em)) &
               n_new = n_new + 1
         end do
      end do
    end function count_n_new_ftuples
  end subroutine region_data_extend_ftuples

@ %def region_data_extend_ftuples
@ Create the map real flavor -> underlying Born
<<fks regions: reg data: TBP>>=
  procedure :: set_underlying_borns => region_data_set_underlying_borns
<<fks regions: procedures>>=
  subroutine region_data_set_underlying_borns (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i, alr
    integer, dimension(:), allocatable :: flst_born
    allocate (reg_data%underlying_borns (reg_data%n_flv_born))
    do i = 1, reg_data%n_flv_born
       if (allocated (flst_born))  deallocate (flst_born)
       allocate (flst_born (size (reg_data%flv_born(i)%flst)))
       flst_born = reg_data%flv_born(i)%flst
       do alr = 1, reg_data%n_regions
          if (all (reg_data%regions(alr)%flst_uborn%flst == flst_born)) then
             reg_data%underlying_borns(i) = reg_data%regions(alr)%uborn_index
             exit
          end if
       end do
    end do
  end subroutine region_data_set_underlying_borns

@ %def region_data_set_underlying_borns
@
<<fks regions: reg data: TBP>>=
  procedure :: get_uborn_indices => region_data_get_uborn_indices
<<fks regions: procedures>>=
  function region_data_get_uborn_indices (reg_data) result (uborn_indices)
    integer, dimension(:), allocatable :: uborn_indices
    class(region_data_t), intent(in) :: reg_data
    allocate (uborn_indices (reg_data%n_flv_born))
    uborn_indices = reg_data%underlying_borns
  end function region_data_get_uborn_indices

@ %def region_data_get_uborn_indices
@
<<fks regions: reg data: TBP>>=
  procedure :: compute_number_of_phase_spaces &
     => region_data_compute_number_of_phase_spaces
<<fks regions: procedures>>=
  subroutine region_data_compute_number_of_phase_spaces (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    integer, parameter :: n_max_phs = 10
    type(phs_identifier_t), dimension(n_max_phs) :: phs_id_tmp
    logical :: share_emitter, phs_exist
    if (allocated (reg_data%resonances)) then
       reg_data%n_phs = 0
       do i_em = 1, size (reg_data%emitters)
          emitter = reg_data%emitters(i_em)
          do i_res = 1, size (reg_data%resonances)
             if (reg_data%emitter_is_compatible_with_resonance (i_res, emitter)) then
                !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
                call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
                if (.not. share_emitter) cycle
                call check_for_phs_identifier &
                   (phs_id_tmp, reg_data%n_in, emitter, contributors%c, phs_exist, i_phs)
                if (.not. phs_exist) then
                   reg_data%n_phs = reg_data%n_phs + 1
                   if (reg_data%n_phs > n_max_phs) call msg_fatal &
                      ("Buffer of phase space identifieres: Too much phase spaces!")
                   call phs_id_tmp(i_phs)%init (emitter, contributors%c)
                end if
             end if
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       end do
    else
       reg_data%n_phs = size (remove_duplicates_from_list (reg_data%emitters))
    end if
  end subroutine region_data_compute_number_of_phase_spaces

@ %def region_data_compute_number_of_phase_spaces
@
<<fks regions: reg data: TBP>>=
  procedure :: get_n_phs => region_data_get_n_phs
<<fks regions: procedures>>=
  function region_data_get_n_phs (reg_data) result (n_phs)
    integer :: n_phs
    class(region_data_t), intent(in) :: reg_data
    n_phs = reg_data%n_phs
  end function region_data_get_n_phs

@ %def region_data_get_n_phs
@
<<fks regions: reg data: TBP>>=
  procedure :: set_splitting_info => region_data_set_splitting_info
<<fks regions: procedures>>=
  subroutine region_data_set_splitting_info (reg_data)
     class(region_data_t), intent(inout) :: reg_data
     integer :: alr
     do alr = 1, reg_data%n_regions
        call reg_data%regions(alr)%set_splitting_info ()
     end do
   end subroutine region_data_set_splitting_info

@ %def region_data_set_splitting_info
@
<<fks regions: reg data: TBP>>=
  procedure :: init_phs_identifiers => region_data_init_phs_identifiers
<<fks regions: procedures>>=
  subroutine region_data_init_phs_identifiers (reg_data, phs_id)
    class(region_data_t), intent(in) :: reg_data
    type(phs_identifier_t), intent(out), dimension(:), allocatable :: phs_id
    integer :: i_em, i_res, i_phs
    integer :: emitter
    type(resonance_contributors_t) :: contributors
    logical :: share_emitter, phs_exist
    allocate (phs_id (reg_data%n_phs))
    do i_em = 1, size (reg_data%emitters)
       emitter = reg_data%emitters(i_em)
       if (allocated (reg_data%resonances)) then
          do i_res = 1, size (reg_data%resonances)
             !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
             call reg_data%get_contributors (i_res, emitter, contributors%c, share_emitter)
             if (.not. share_emitter) cycle
             call check_for_phs_identifier &
                (phs_id, reg_data%n_in, emitter, contributors%c, phs_exist, i_phs)
             if (.not. phs_exist) &
                call phs_id(i_phs)%init (emitter, contributors%c)
             if (allocated (contributors%c)) deallocate (contributors%c)
          end do
       else
          call check_for_phs_identifier (phs_id, reg_data%n_in, emitter, &
             phs_exist = phs_exist, i_phs = i_phs)
          if (.not. phs_exist) call phs_id(i_phs)%init (emitter)
       end if
    end do
  end subroutine region_data_init_phs_identifiers

@ %def region_data_init_phs_identifiers
@
<<fks regions: reg data: TBP>>=
  procedure :: write_to_file => region_data_write_to_file
<<fks regions: procedures>>=
  subroutine region_data_write_to_file (reg_data, proc_id)
     class(region_data_t), intent(inout) :: reg_data
     type(string_t), intent(in) :: proc_id
     type(string_t) :: filename
     integer :: u

     filename = proc_id // "_fks_regions.log"
     u = free_unit ()
     open (u, file=char(filename), action = "write", status="replace")
     call reg_data%write (u)
     close (u)
  end subroutine region_data_write_to_file

@ %def region_data_write_to_file
@ Creates a table with information about all singular regions and
writes it to a file.
@ Returns the index of the real flavor structure an ftuple belongs to.
<<fks regions: reg data: TBP>>=
  procedure :: write => region_data_write
<<fks regions: procedures>>=
  subroutine region_data_write (reg_data, unit)
     class(region_data_t), intent(in) :: reg_data
     integer, intent(in), optional :: unit
     integer :: j
     integer :: maxnregions
     type(string_t) :: flst_title, ftuple_title
     integer :: n_res, u
     u = given_output_unit (unit); if (u < 0) return
     maxnregions = 1
     do j = 1, reg_data%n_regions
        if (size (reg_data%regions(j)%ftuples) > maxnregions) &
             maxnregions = reg_data%regions(j)%nregions
     end do
     flst_title = '(A' // flst_title_format(reg_data%n_legs_real) // ')'
     ftuple_title = '(A' // ftuple_title_format() // ')'
     write (u,'(A,1X,I2)') 'Total number of regions: ', size(reg_data%regions)
     write (u, '(A3)', advance = 'no') 'alr'
     call write_vline (u)
     write (u, char (flst_title), advance = 'no') 'flst_real'
     call write_vline (u)
     write (u, '(A3)', advance = 'no') 'em'
     call write_vline (u)
     write (u, '(A3)', advance = 'no') 'mult'
     call write_vline (u)
     write (u, '(A4)', advance = 'no') 'nreg'
     call write_vline (u)
     if (allocated (reg_data%fks_mapping)) then
        select type (fks_mapping => reg_data%fks_mapping)
        type is (fks_mapping_resonances_t)
           write (u, '(A3)', advance = 'no') 'res'
           call write_vline (u)
        end select
     end if
     write (u, char (ftuple_title), advance = 'no') 'ftuples'
     call write_vline (u)
     flst_title = '(A' // flst_title_format(reg_data%n_legs_born) // ')'
     write (u, char (flst_title), advance = 'no') 'flst_born'
     call write_vline (u)
     write (u, '(A7)') 'i_uborn'
     do j = 1, reg_data%n_regions
        write (u, '(I3)', advance = 'no') j
        call reg_data%regions(j)%write (u, maxnregions)
     end do
     call write_separator (u)
     if (allocated (reg_data%fks_mapping)) then
        select type (fks_mapping => reg_data%fks_mapping)
        type is (fks_mapping_resonances_t)
           write (u, '(A)')
           write (u, '(A)') "The FKS regions are combined with resonance information: "
           n_res = size (fks_mapping%res_map%res_histories)
           write (u, '(A,1X,I1)') "Number of QCD resonance histories: ", n_res
           do j = 1, n_res
              write (u, '(A,1X,I1)') "i_res = ", j
              call fks_mapping%res_map%res_histories(j)%write (u)
              call write_separator (u)
           end do
        end select
     end if

   contains

     function flst_title_format (n) result (frmt)
       integer, intent(in) :: n
       type(string_t) :: frmt
       character(len=2) :: frmt_char
       write (frmt_char, '(I2)') 4 * n + 1
       frmt = var_str (frmt_char)
     end function flst_title_format

    function ftuple_title_format () result (frmt)
       type(string_t) :: frmt
       character(len=2) :: frmt_char
       write (frmt_char, '(I2)') 10 * maxnregions + 1
       frmt = var_str (frmt_char)
    end function ftuple_title_format

  end subroutine region_data_write

@ %def region_data_write
@
<<fks regions: procedures>>=
  subroutine write_vline (u)
    integer, intent(in) :: u
    character(len=10), parameter :: sep_format = "(1X,A2,1X)"
    write (u, sep_format, advance = 'no') '||'
  end subroutine write_vline

@ %def write_vline
@
<<fks regions: public>>=
  public :: assignment(=)
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure region_data_assign
  end interface

<<fks regions: procedures>>=
  subroutine region_data_assign (reg_data_out, reg_data_in)
    type(region_data_t), intent(out) :: reg_data_out
    type(region_data_t), intent(in) :: reg_data_in
    integer :: i
    if (allocated (reg_data_in%regions)) then
       allocate (reg_data_out%regions (size (reg_data_in%regions)))
       do i = 1, size (reg_data_in%regions)
          reg_data_out%regions(i) = reg_data_in%regions(i)
       end do
    else
       call msg_warning ("Copying region data without allocated singular regions!")
    end if
    if (allocated (reg_data_in%flv_born)) then
       allocate (reg_data_out%flv_born (size (reg_data_in%flv_born)))
       do i = 1, size (reg_data_in%flv_born)
          reg_data_out%flv_born(i) = reg_data_in%flv_born(i)
       end do
    else
       call msg_warning ("Copying region data without allocated born flavor structure!")
    end if
    if (allocated (reg_data_in%flv_real)) then
       allocate (reg_data_out%flv_real (size (reg_data_in%flv_real)))
       do i = 1, size (reg_data_in%flv_real)
          reg_data_out%flv_real(i) = reg_data_in%flv_real(i)
       end do
    else
       call msg_warning ("Copying region data without allocated real flavor structure!")
    end if
    if (allocated (reg_data_in%emitters)) then
       allocate (reg_data_out%emitters (size (reg_data_in%emitters)))
       do i = 1, size (reg_data_in%emitters)
          reg_data_out%emitters(i) = reg_data_in%emitters(i)
       end do
    else
       call msg_warning ("Copying region data without allocated emitters!")
    end if
    reg_data_out%n_regions = reg_data_in%n_regions
    reg_data_out%n_emitters = reg_data_in%n_emitters
    reg_data_out%n_flv_born = reg_data_in%n_flv_born
    reg_data_out%n_flv_real = reg_data_in%n_flv_real
    reg_data_out%n_in = reg_data_in%n_in
    reg_data_out%n_legs_born = reg_data_in%n_legs_born
    reg_data_out%n_legs_real = reg_data_in%n_legs_real
    if (allocated (reg_data_in%underlying_borns)) then
       allocate (reg_data_out%underlying_borns (size (reg_data_in%underlying_borns)))
       reg_data_out%underlying_borns = reg_data_in%underlying_borns
    else
       call msg_warning ("Copying region data without allocated underlying born flavor indices!")
    end if
    reg_data_out%flv_extra = reg_data_in%flv_extra
    if (allocated (reg_data_in%fks_mapping)) then
       select type (fks_mapping_in => reg_data_in%fks_mapping)
       type is (fks_mapping_default_t)
          allocate (fks_mapping_default_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_default_t)
             fks_mapping_out = fks_mapping_in
          end select
       type is (fks_mapping_resonances_t)
          allocate (fks_mapping_resonances_t :: reg_data_out%fks_mapping)
          select type (fks_mapping_out => reg_data_out%fks_mapping)
          type is (fks_mapping_resonances_t)
             fks_mapping_out = fks_mapping_in
          end select
       end select
    else
       call msg_warning ("Copying region data without allocated FKS regions!")
    end if
    if (allocated (reg_data_in%resonances)) then
       allocate (reg_data_out%resonances (size (reg_data_in%resonances)))
       reg_data_out%resonances = reg_data_in%resonances
    end if
    reg_data_out%n_phs = reg_data_in%n_phs
    if (allocated (reg_data_in%alr_contributors)) then
       allocate (reg_data_out%alr_contributors (size (reg_data_in%alr_contributors)))
       reg_data_out%alr_contributors = reg_data_in%alr_contributors
    end if
    if (allocated (reg_data_in%alr_to_i_contributor)) then
       allocate (reg_data_out%alr_to_i_contributor &
          (size (reg_data_in%alr_to_i_contributor)))
       reg_data_out%alr_to_i_contributor = reg_data_in%alr_to_i_contributor
    end if
  end subroutine region_data_assign

@ %def region_data_assign
@ Returns the index of the real flavor structure an ftuple belogs to.
<<fks regions: procedures>>=
  function region_to_index (list, i) result(index)
    type(ftuple_list_t), intent(inout), dimension(:), allocatable :: list
    integer, intent(in) :: i
    integer :: index, nlist, j
    integer, dimension(:), allocatable :: nreg
    nlist = size(list)
    allocate (nreg (nlist))
    index = 0
    do j = 1, nlist
       if (j == 1) then
          nreg(j) = list(j)%get_n_tuples ()
       else
          nreg(j) = nreg(j - 1) + list(j)%get_n_tuples ()
       end if
    end do
    do j = 1, nlist
       if (j == 1) then
          if (i <= nreg(j)) then
             index = j
             exit
          end if
       else
          if (i > nreg(j - 1) .and. i <= nreg(j)) then
             index = j
             exit
          end if
       end if
    end do
  end function region_to_index

@ %def region_to_index
@ Final state emission: Rearrange the flavor array in such a way that
the emitted particle is last and the emitter is second last. [[i1]] is
the index of the emitter, [[i2]] is the index of the emitted particle.

Initial state emission: Just put the emitted particle to the last
position.
<<fks regions: procedures>>=
  function create_alr (flv1, n_in, i_em, i_rad) result(flv2)
    type(flv_structure_t), intent(in) :: flv1
    integer, intent(in) :: n_in
    integer, intent(in) :: i_em, i_rad
    type(flv_structure_t) :: flv2
    integer :: n
    n = size (flv1%flst)
    allocate (flv2%flst (n))
    flv2%nlegs = n
    flv2%n_in = n_in
    if (i_em > n_in) then
       flv2%flst(1 : 2) = flv1%flst(1 : 2)
       flv2%flst(n - 1) = flv1%flst(i_em)
       flv2%flst(n) = flv1%flst(i_rad)
       call fill_remaining_flavors (n_in, .true.)
    else
       flv2%flst(1 : 2) = flv1%flst(1 : 2)
       flv2%flst(n) = flv1%flst(i_rad)
       call fill_remaining_flavors (n_in, .false.)
    end if
  contains
@ Order remaining particles according to their original position
<<fks regions: procedures>>=
    subroutine fill_remaining_flavors (n_in, final_final)
      integer, intent(in) :: n_in
      logical, intent(in) :: final_final
      integer :: i, j
      logical :: check
      j = n_in + 1
      do i = n_in + 1, n
         if (final_final) then
            check = (i /= i_em .and. i /= i_rad)
         else
            check = (i /= i_rad)
         end if
         if (check) then
            flv2%flst(j) = flv1%flst(i)
            j = j + 1
         end if
      end do
    end subroutine fill_remaining_flavors
  end function create_alr

@ %def create_alr
@ Explain
<<fks regions: procedures>>=
  subroutine fks_permute_born (flv_in, n_in, flv_out, perm_list)
    type(flv_structure_t), intent(in) :: flv_in
    integer, intent(in) :: n_in
    type(flv_structure_t), intent(inout) :: flv_out
    integer, intent(out), dimension(:,:), allocatable :: perm_list
    integer, dimension(:,:), allocatable :: perm_list_tmp
    integer :: n_perms, n_perms_max
    integer :: nlegs
    integer :: flv1, flv2, tmp
    integer :: i, j, j_min
    n_perms_max = 100
    !!! actually (n-1)!, but there seems to be no intrinsic function
    !!! of this type in fortran
    if (allocated (perm_list_tmp)) deallocate (perm_list_tmp)
    allocate (perm_list_tmp (n_perms_max,2))
    n_perms = 0
    j_min = n_in + 1
    nlegs = size (flv_in%flst)
    do i = n_in + 1, nlegs
       flv1 = flv_in%flst(i)
       do j = j_min, nlegs
          flv2 = flv_out%flst(j)
          if (flv1 == flv2 .and. i /= j) then
             n_perms = n_perms + 1
             tmp = flv_out%flst(i)
             flv_out%flst(i) = flv2
             flv_out%flst(j) = tmp
             perm_list_tmp (n_perms, 1) = j
             perm_list_tmp (n_perms, 2) = i
             j_min = j_min + 1
             exit
          end if
       end do
    end do
    allocate (perm_list (n_perms, 2))
    perm_list (1:n_perms, :) = perm_list_tmp (1:n_perms, :)
  end subroutine fks_permute_born

@ %def fks_permute_born
@ Explain
<<fks regions: procedures>>=
  subroutine fks_apply_perm (flv, emitter, perm_list)
    type(flv_structure_t), intent(inout) :: flv
    integer, intent(inout) :: emitter
    integer, intent(in), dimension(:,:), allocatable :: perm_list
    integer :: i
    integer :: i1, i2
    integer :: tmp
    do i = 1, size (perm_list (:,1))
       i1 = perm_list (i,1)
       i2 = perm_list (i,2)
       tmp = flv%flst (i1)
       flv%flst (i1) = flv%flst (i2)
       flv%flst (i2) = tmp
       if (i1 == emitter) emitter = i2
    end do
  end subroutine fks_apply_perm

@ %def fks_apply_perm
@
<<fks regions: reg data: TBP>>=
  procedure :: has_pseudo_isr => region_data_has_pseudo_isr
<<fks regions: procedures>>=
  function region_data_has_pseudo_isr (reg_data) result (val)
    logical :: val
    class(region_data_t), intent(in) :: reg_data
    val = any (reg_data%regions%pseudo_isr)
  end function region_data_has_pseudo_isr

@ %def region_data_has_pseudo_isr
@
<<fks regions: reg data: TBP>>=
  procedure :: final => region_data_final
<<fks regions: procedures>>=
  subroutine region_data_final (reg_data)
    class(region_data_t), intent(inout) :: reg_data
    if (allocated (reg_data%regions)) deallocate (reg_data%regions)
    if (allocated (reg_data%flv_born)) deallocate (reg_data%flv_born)
    if (allocated (reg_data%flv_real)) deallocate (reg_data%flv_real)
    if (allocated (reg_data%emitters)) deallocate (reg_data%emitters)
    if (allocated (reg_data%underlying_borns)) deallocate (reg_data%underlying_borns)
    if (allocated (reg_data%fks_mapping)) deallocate (reg_data%fks_mapping)
    if (allocated (reg_data%resonances)) deallocate (reg_data%resonances)
    if (allocated (reg_data%alr_contributors)) deallocate (reg_data%alr_contributors)
    if (allocated (reg_data%alr_to_i_contributor)) deallocate (reg_data%alr_to_i_contributor)
  end subroutine region_data_final

@ %def region_data_final
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij), deferred :: dij
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij (map, p, i, j, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij
  end interface

@ %def fks_mapping_dij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij), deferred :: compute_sumdij
<<fks regions: interfaces>>=
  abstract interface
    subroutine fks_mapping_compute_sumdij (map, sregion, p)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p
    end subroutine fks_mapping_compute_sumdij
  end interface

@ %def fks_mapping_compute_sumdij
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue), deferred :: svalue
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue (map, p, i, j, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p
      integer, intent(in) :: i, j
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue
  end interface

@ %def fks_mapping_svalue
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_dij_soft), deferred :: dij_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_dij_soft (map, p_born, p_soft, em, i_con) result (d)
      import
      real(default) :: d
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_con
    end function fks_mapping_dij_soft
  end interface

@ %def fks_mapping_dij_soft
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_compute_sumdij_soft), deferred :: compute_sumdij_soft
<<fks regions: interfaces>>=
  abstract interface
    subroutine fks_mapping_compute_sumdij_soft (map, sregion, p_born, p_soft)
      import
      class(fks_mapping_t), intent(inout) :: map
      type(singular_region_t), intent(in) :: sregion
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
    end subroutine fks_mapping_compute_sumdij_soft
  end interface
@ %def fks_mapping_compute_sumdij_soft
@
<<fks regions: fks mapping: TBP>>=
  procedure (fks_mapping_svalue_soft), deferred :: svalue_soft
<<fks regions: interfaces>>=
  abstract interface
    function fks_mapping_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
      import
      real(default) :: value
      class(fks_mapping_t), intent(in) :: map
      type(vector4_t), intent(in), dimension(:) :: p_born
      type(vector4_t), intent(in) :: p_soft
      integer, intent(in) :: em
      integer, intent(in), optional :: i_res
    end function fks_mapping_svalue_soft
  end interface

@ %def fks_mapping_svalue_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: set_parameter => fks_mapping_default_set_parameter
<<fks regions: procedures>>=
  subroutine fks_mapping_default_set_parameter (map, n_in, dij_exp1, dij_exp2)
    class(fks_mapping_default_t), intent(inout) :: map
    integer, intent(in) :: n_in
    real(default), intent(in) :: dij_exp1, dij_exp2
    map%n_in = n_in
    map%exp_1 = dij_exp1
    map%exp_2 = dij_exp2
  end subroutine fks_mapping_default_set_parameter

@ %def fks_mapping_default_set_parameter
@ Computes the $d_{ij}$-quantities defined als follows:
\begin{align*}
  d_{0i} &= \left[E_i^2\left(1-y_i\right)\right]^{p_1}\\,
  d_{1i} &= \left[2E_i^2\left(1-y_i\right)\right]^{p_1}\\,
  d_{2i} &= \left[2E_i^2\left(1+y_i\right)\right]^{p_1}\\,
\end{align*}
for initial state regions and
\begin{align*}
  d_{ij} = \left[2(k_i \cdot k_j) \frac{E_i E_j}{(E_i+E_j)^2}\right]^{p_2}
\end{align*}
for final state regions. The exponents $p_1$ and $p_2$ can be used for
tuning the efficiency of the mapping and are set to $1$ per default.
<<fks regions: fks mapping default: TBP>>=
  procedure :: dij => fks_mapping_default_dij
<<fks regions: procedures>>=
  function fks_mapping_default_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    d = zero
    if (i /= j) then
        if (map%pseudo_isr) then
           d = dij_threshold_gluon_from_top (i, j, p, map%exp_1)
        else if (i > map%n_in .and. j > map%n_in) then
           d = dij_fsr (p(i), p(j), map%exp_1)
        else
           d = dij_isr (map%n_in, i, j, p, map%exp_2)
        end if
    else
      call msg_fatal ("Invalid FKS region: Emitter equals FKS parton!")
    end if
  contains

    function dij_fsr (p1, p2, expo) result (d_ij)
      real(default) :: d_ij
      type(vector4_t), intent(in) :: p1, p2
      real(default), intent(in) :: expo
      real(default) :: E1, E2 
      E1 = p1%p(0); E2 = p2%p(0)
      d_ij = (two * p1 * p2 * E1 * E2 / (E1 + E2)**2)**expo
    end function dij_fsr

    function dij_threshold_gluon_from_top (i, j, p, expo) result (d_ij)
      real(default) :: d_ij
      integer, intent(in) :: i, j
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: expo
      type(vector4_t) :: p_top
      if (i == THR_POS_B) then
         p_top = p(THR_POS_WP) + p(THR_POS_B)
      else
         p_top = p(THR_POS_WM) + p(THR_POS_BBAR)
      end if
      d_ij = dij_fsr (p_top, p(j), expo)
    end function dij_threshold_gluon_from_top

    function dij_isr (n_in, i, j, p, expo) result (d_ij)
      real(default) :: d_ij
      integer, intent(in) :: n_in, i, j
      type(vector4_t), intent(in), dimension(:) :: p
      real(default), intent(in) :: expo
      real(default) :: E, y
      select case (n_in)
      case (1)
         call get_emitter_variables (1, i, j, p, E, y)
         d_ij = (E**2 * (one - y**2))**expo
      case (2)
         if ((i == 0 .and. j > 2) .or. (j == 0 .and. i > 2)) then
            call get_emitter_variables (0, i, j, p, E, y)
            d_ij = (E**2 * (one - y**2))**expo
         else if ((i == 1 .and. j > 2) .or. (j == 1 .and. i > 2)) then
            call get_emitter_variables (1, i, j, p, E, y)
            d_ij = (two * E**2 * (one - y))**expo
         else if ((i == 2 .and. j > 2) .or. (j == 2 .and. i > 2)) then
            call get_emitter_variables (2, i, j, p, E, y)
            d_ij = (two * E**2 * (one + y))**expo
         end if
      end select
    end function dij_isr

    subroutine get_emitter_variables (i_check, i, j, p, E, y)
       integer, intent(in) :: i_check, i, j
       type(vector4_t), intent(in), dimension(:) :: p
       real(default), intent(out) :: E, y
       if (j == i_check) then
           E = energy (p(i))
           y = polar_angle_ct (p(i))
       else
           E = energy (p(j))
           y = polar_angle_ct(p(j))
       end if
    end subroutine get_emitter_variables

  end function fks_mapping_default_dij

@  %def fks_mapping_default_dij
@ Computes the quantity
\begin{equation*}
  \mathcal{D} = \sum_k \frac{1}{d_{0k}} + \sum_{kl} \frac{1}{d_{kl}}.
\end{equation*}
<<fks regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij => fks_mapping_default_compute_sumdij
<<fks regions: procedures>>=
  subroutine fks_mapping_default_compute_sumdij (map, sregion, p)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: d
    integer :: alr, i, j

    associate (ftuples => sregion%ftuples)
      d = zero
      do alr = 1, sregion%nregions
        call ftuples(alr)%get (i, j)
        map%pseudo_isr = ftuples(alr)%pseudo_isr
        d = d + one / map%dij (p, i, j)
      end do
    end associate
    map%sumdij = d
  end subroutine fks_mapping_default_compute_sumdij

@ %def fks_mapping_default_compute_sumdij
@ Computes
\begin{equation*}
  S_i = \frac{1}{\mathcal{D} d_{0i}}
\end{equation*}
or
\begin{equation*}
  S_{ij} = \frac{1}{\mathcal{D} d_{ij}},
\end{equation*}
respectively.
<<fks regions: fks mapping default: TBP>>=
  procedure :: svalue => fks_mapping_default_svalue
<<fks regions: procedures>>=
  function fks_mapping_default_svalue (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    value = one / (map%dij (p, i, j) * map%sumdij)
  end function fks_mapping_default_svalue

@ %def fks_mapping_default_svalue
@ In the soft limit, our treatment of the divergences requires a
modification of the mapping functions. Recall that there, the ratios of
the $d$-functions must approach either $1$ or $0$. This means
\begin{equation*}
  \frac{d_{lm}}{d_{0m}} = \frac{(2k_l \cdot k_m) \left[E_lE_m /(E_l + E_m)^2\right]}{E_m^2 (1-y^2)} =
    \overset {k_m = E_m \hat{k}} {=} \frac{E_l E_m^2}{(E_l + E_m)^2} \frac{2k_l \cdot \hat{k}}{E_m^2 (1-y^2)}
    \overset {E_m \rightarrow 0}{=} \frac{2}{k_l \cdot \hat{k}}{(1-y^2)E_l},
\end{equation*}
where we have written the gluon momentum in terms of the soft momentum
$\hat{k}$. In the same limit
\begin{equation*}
  \frac{d_{lm}}{d_{nm}} = \frac{k_l \cdot \hat{k}}{k_n \cdot \hat{k}} \frac{E_n}{E_l}.
\end{equation*}
From these equations we can deduce the soft limit of $d$:
\begin{align*}
  d_0^{\rm{soft}} &= 1 - y^2,\\
  d_1^{\rm{soft}} &= 2(1-y),\\
  d_2^{\rm{soft}} &= 2(1+y),\\
  d_i^{\rm{soft}} &= \frac{2 k_i \cdot \hat{k}}{E_i}.
\end{align*}
<<fks regions: fks mapping default: TBP>>=
  procedure :: dij_soft => fks_mapping_default_dij_soft
<<fks regions: procedures>>=
  function fks_mapping_default_dij_soft (map, p_born, p_soft, em, i_con) result (d)
    real(default) :: d
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_con
    if (map%pseudo_isr) then
       d = dij_soft_threshold_gluon_from_top (em, p_born, p_soft, map%exp_1)
    else if (em <= map%n_in) then
       d = dij_soft_isr (map%n_in, p_soft, map%exp_2)
    else
       d = dij_soft_fsr (p_born(em), p_soft, map%exp_1)
    end if
  contains

    function dij_soft_threshold_gluon_from_top (em, p, p_soft, expo) result (dij_soft)
      real(default) :: dij_soft
      integer, intent(in) :: em
      type(vector4_t), intent(in), dimension(:) :: p
      type(vector4_t), intent(in) :: p_soft
      real(default), intent(in) :: expo
      type(vector4_t) :: p_top
      if (em == THR_POS_B) then
         p_top = p(THR_POS_WP) + p(THR_POS_B)
      else
         p_top = p(THR_POS_WM) + p(THR_POS_BBAR)
      end if
      dij_soft = dij_soft_fsr (p_top, p_soft, expo)
    end function dij_soft_threshold_gluon_from_top

    function dij_soft_fsr (p_em, p_soft, expo) result (dij_soft)
      real(default) :: dij_soft
      type(vector4_t), intent(in) :: p_em, p_soft
      real(default), intent(in) :: expo
      dij_soft = (two * p_em * p_soft / p_em%p(0))**expo
    end function dij_soft_fsr

    function dij_soft_isr (n_in, p_soft, expo) result (dij_soft)
       real(default) :: dij_soft
       integer, intent(in) :: n_in
       type(vector4_t), intent(in) :: p_soft
       real(default), intent(in) :: expo
       real(default) :: y
       y = polar_angle_ct (p_soft)
       select case (n_in)
       case (1)
          dij_soft = one - y**2
       case (2)
          select case (em)
          case (0)
             dij_soft = one - y**2
          case (1)
             dij_soft = two * (one - y)
          case (2)
             dij_soft = two * (one + y)
          case default
             dij_soft = zero
             call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
          end select
       case default
          dij_soft = zero
          call msg_fatal ("fks_mappings_default_dij_soft: n_in > 2")
       end select
       dij_soft = dij_soft**expo
    end function dij_soft_isr
  end function fks_mapping_default_dij_soft

@ %def fks_mapping_default_dij_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_default_compute_sumdij_soft
<<fks regions: procedures>>=
  subroutine fks_mapping_default_compute_sumdij_soft (map, sregion, p_born, p_soft)
    class(fks_mapping_default_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    integer :: alr, i, j
    integer :: nlegs
    d = zero
    nlegs = size (sregion%flst_real%flst)
    associate (ftuples => sregion%ftuples)
      do alr = 1, sregion%nregions
        call ftuples(alr)%get (i ,j)
        if (j == nlegs) then
          map%pseudo_isr = ftuples(alr)%pseudo_isr
          d = d + one / map%dij_soft (p_born, p_soft, i)
        end if
      end do
    end associate
    map%sumdij_soft = d
  end subroutine fks_mapping_default_compute_sumdij_soft

@ %def fks_mapping_default_compute_sumdij_soft
@
<<fks regions: fks mapping default: TBP>>=
  procedure :: svalue_soft => fks_mapping_default_svalue_soft
<<fks regions: procedures>>=
  function fks_mapping_default_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_default_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    value = one / (map%sumdij_soft * map%dij_soft (p_born, p_soft, em))
  end function fks_mapping_default_svalue_soft

@ %def fks_mapping_default_svalue_soft
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_default_assign
  end interface

<<fks regions: procedures>>=
  subroutine fks_mapping_default_assign (fks_map_out, fks_map_in)
    type(fks_mapping_default_t), intent(out) :: fks_map_out
    type(fks_mapping_default_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%n_in = fks_map_in%n_in
  end subroutine fks_mapping_default_assign

@ %def fks_mapping_default_assign
@ The $d_{ij,k}$-functions for the resonance mapping are basically the same
as in the default case, but the kinematical values here must be evaluated
in the resonance frame of reference. The energy of parton $i$ in a given
resonance frame with momentum $p_{res}$ is
\begin{equation*}
   E_i = \frac{p_i^0 \cdot p_{res}}{m_{res}}.
\end{equation*}
However, since the expressions only depend on ratios of four-momenta, we
leave out the denominator because it will cancel out anyway.
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: dij => fks_mapping_resonances_dij
<<fks regions: procedures>>=
  function fks_mapping_resonances_dij (map, p, i, j, i_con) result (d)
    real(default) :: d
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_con
    real(default) :: E1, E2
    integer :: ii_con
    if (present (i_con)) then
       ii_con = i_con
    else
       call msg_fatal ("Resonance mappings require resonance index as input!")
    end if
    d = 0
    if (i /= j) then
       if (i > 2 .and. j > 2) then
          associate (p_res => map%res_map%p_res (ii_con))
             E1 = p(i) * p_res
             E2 = p(j) * p_res
             d = two * p(i) * p(j) * E1 * E2 / (E1 + E2)**2
          end associate
       else
          call msg_fatal ("Resonance mappings are not implemented for ISR")
       end if
    end if
  end function fks_mapping_resonances_dij

@ %def fks_mapping_resonances_dij
@ Computes
\begin{equation*}
  S_\alpha = \frac{P^{f_r(\alpha)}d^{-1}(\alpha)}
     {\sum_{f_r' \in T(F_r(\alpha))}P^{f_r'}\sum_{\alpha' \in Sr(f_r')}d^{-1}(\alpha)}.
\end{equation*}
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij => fks_mapping_resonances_compute_sumdij
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_compute_sumdij (map, sregion, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p
    real(default) :: d, pfr
    integer :: i_res, i_reg, i, j, i_con
    integer :: nlegreal

    nlegreal = size (p)
    d = zero
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get (i, j)
          i_res = ftuple%i_res
       end associate
       pfr = map%res_map%get_resonance_value (i_res, p, nlegreal)
       i_con = sregion%i_reg_to_i_con (i_reg)
       d = d + pfr / map%dij (p, i, j, i_con)
    end do
    map%sumdij = d
  end subroutine fks_mapping_resonances_compute_sumdij

@ %def fks_mapping_resonances_compute_sumdij
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: svalue => fks_mapping_resonances_svalue
<<fks regions: procedures>>=
  function fks_mapping_resonances_svalue (map, p, i, j, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: i, j
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    integer :: i_gluon
    i_gluon = size (p)
    pfr = map%res_map%get_resonance_value (i_res, p, i_gluon)
    value = pfr / (map%dij (p, i, j, map%i_con) * map%sumdij)
  end function fks_mapping_resonances_svalue

@ %def fks_mapping_resonances_svalue
@ As above, the soft limit of $d_{ij,k}$ must be computed in the resonance frame of
reference.
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: dij_soft => fks_mapping_resonances_dij_soft
<<fks regions: procedures>>=
  function fks_mapping_resonances_dij_soft (map, p_born, p_soft, em, i_con) result (d)
     real(default) :: d
     class(fks_mapping_resonances_t), intent(in) :: map
     type(vector4_t), intent(in), dimension(:) :: p_born
     type(vector4_t), intent(in) :: p_soft
     integer, intent(in) :: em
     integer, intent(in), optional :: i_con
     real(default) :: E1, E2
     integer :: ii_con
     type(vector4_t) :: pb
     if (present (i_con)) then
        ii_con = i_con
     else
        call msg_fatal ("fks_mapping_resonances requires resonance index")
     end if
     associate (p_res => map%res_map%p_res(ii_con))
        pb = p_born(em)
        E1 = pb * p_res
        E2 = p_soft * p_res
        d = two * pb * p_soft * E1 * E2 / E1**2
     end associate
  end function fks_mapping_resonances_dij_soft

@ %def fks_mapping_resonances_dij_soft
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: compute_sumdij_soft => fks_mapping_resonances_compute_sumdij_soft
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_compute_sumdij_soft (map, sregion, p_born, p_soft)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    real(default) :: d
    real(default) :: pfr
    integer :: i_res, i, j, i_reg, i_con
    integer :: nlegs

    d = zero
    nlegs = size (sregion%flst_real%flst)
    do i_reg = 1, sregion%nregions
       associate (ftuple => sregion%ftuples(i_reg))
          call ftuple%get(i, j)
          i_res = ftuple%i_res
       end associate
       pfr = map%res_map%get_resonance_value (i_res, p_born)
       i_con = sregion%i_reg_to_i_con (i_reg)
       if (j == nlegs) d = d + pfr / map%dij_soft (p_born, p_soft, i, i_con)
    end do
    map%sumdij_soft = d
  end subroutine fks_mapping_resonances_compute_sumdij_soft

@ %def fks_mapping_resonances_compute_sumdij_soft
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: svalue_soft => fks_mapping_resonances_svalue_soft
<<fks regions: procedures>>=
  function fks_mapping_resonances_svalue_soft (map, p_born, p_soft, em, i_res) result (value)
    real(default) :: value
    class(fks_mapping_resonances_t), intent(in) :: map
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in) :: p_soft
    integer, intent(in) :: em
    integer, intent(in), optional :: i_res
    real(default) :: pfr
    pfr = map%res_map%get_resonance_value (i_res, p_born)
    value = pfr / (map%sumdij_soft * map%dij_soft (p_born, p_soft, em, map%i_con))
  end function fks_mapping_resonances_svalue_soft

@ %def fks_mapping_resonances_svalue_soft
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momentum => fks_mapping_resonances_set_resonance_momentum
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_set_resonance_momentum (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momentum

@ %def fks_mapping_resonances_set_resonance_momentum
@
<<fks regions: fks mapping resonances: TBP>>=
  procedure :: set_resonance_momenta => fks_mapping_resonances_set_resonance_momenta
<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_set_resonance_momenta (map, p)
    class(fks_mapping_resonances_t), intent(inout) :: map
    type(vector4_t), intent(in), dimension(:) :: p
    map%res_map%p_res = p
  end subroutine fks_mapping_resonances_set_resonance_momenta

@ %def fks_mapping_resonances_set_resonance_momenta
@
<<fks regions: interfaces>>=
  interface assignment(=)
     module procedure fks_mapping_resonances_assign
  end interface

<<fks regions: procedures>>=
  subroutine fks_mapping_resonances_assign (fks_map_out, fks_map_in)
    type(fks_mapping_resonances_t), intent(out) :: fks_map_out
    type(fks_mapping_resonances_t), intent(in) :: fks_map_in
    fks_map_out%exp_1 = fks_map_in%exp_1
    fks_map_out%exp_2 = fks_map_in%exp_2
    fks_map_out%res_map = fks_map_in%res_map
  end subroutine fks_mapping_resonances_assign

@ %def fks_mapping_resonances_assign
@
<<fks regions: public>>=
  public :: create_resonance_histories_for_threshold
<<fks regions: procedures>>=
  function create_resonance_histories_for_threshold () result (res_history)
    type(resonance_history_t) :: res_history
    res_history%n_resonances = 2
    allocate (res_history%resonances (2))
    allocate (res_history%resonances(1)%contributors%c(2))
    allocate (res_history%resonances(2)%contributors%c(2))
    res_history%resonances(1)%contributors%c = [THR_POS_WP, THR_POS_B]
    res_history%resonances(2)%contributors%c = [THR_POS_WM, THR_POS_BBAR]
  end function create_resonance_histories_for_threshold

@ %def create_resonance_histories_for_threshold
@
<<fks regions: public>>=
  public :: setup_region_data_for_test
<<fks regions: procedures>>=
  subroutine setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
    integer, intent(in) :: n_in
    integer, intent(in), dimension(:,:) :: flv_born, flv_real
    type(region_data_t), intent(out) :: reg_data
    type(model_t), pointer :: test_model => null ()
    call create_test_model (var_str ("SM_rad"), test_model)
    call reg_data%init (n_in, test_model, flv_born, flv_real)
  end subroutine setup_region_data_for_test

@ %def setup_region_data_for_test
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unit tests}
\clearpage
<<[[fks_regions_ut.f90]]>>=
<<File header>>

module fks_regions_ut
  use unit_tests
  use fks_regions_uti

<<Standard module head>>

<<fks regions: public test>>

contains

<<fks regions: test driver>>

end module fks_regions_ut
@ %def fks_regions_ut
@
<<[[fks_regions_uti.f90]]>>=
<<File header>>

module fks_regions_uti

<<Use strings>>
  use format_utils, only: write_separator
  use os_interface
  use models

  use fks_regions

<<Standard module head>>

<<fks regions: test declarations>>

contains

<<fks regions: tests>>

end module fks_regions_uti
@ %def fks_regions_uti
@
<<fks regions: public test>>=
  public :: fks_regions_test
<<fks regions: test driver>>=
  subroutine fks_regions_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test(fks_regions_1, "fks_regions_1", &
       "Test flavor structure utilities", u, results)
    call test(fks_regions_2, "fks_regions_2", &
       "Test the creation of singular regions for final-state radiation", &
       u, results)
    call test(fks_regions_3, "fks_regions_3", &
       "Test the creation of singular regions for initial-state radiation", &
       u, results)
  end subroutine fks_regions_test

@ %def fks_regions_test
@
<<fks regions: test declarations>>=
  public :: fks_regions_1
<<fks regions: tests>>=
  subroutine fks_regions_1 (u)
    integer, intent(in) :: u
    type(flv_structure_t) :: flv_born, flv_real
    type(model_t), pointer :: test_model => null ()
    write (u, "(A)") "* Test output: fks_regions_1"
    write (u, "(A)") "* Purpose: Test utilities of flavor structure manipulation"
    write (u, "(A)")

    call create_test_model (var_str ("SM_rad"), test_model)

    flv_born = [11, -11, 2, -2]
    flv_real = [11, -11, 2, -2, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of ee -> uu"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : ", flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : ", flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : ", flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : ", flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 21): ", flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -2): ", flv_real%valid_pair (5, 4, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [2, -2, 11, -11]
    flv_real = [2, -2, 11, -11, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of uu -> ee"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (2, -2) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-2, 2) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (21, -2): " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-2, 21): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (21, 2) : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (2, 21) : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [21, -2, 11, -11, -2]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (21, -2): " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-2, 21): " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (-2, -2): " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-2, -2): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (-2, 21): " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (21, -2): " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [2, 21, 11, -11, 2]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (2, 21) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (21, 2) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (2, 21) : " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (21, 2) : " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (2, 2)  : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (2, 2)  : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [11, -11, 2, -2, 21]
    flv_real = [11, -11, 2, -2, 21, 21]
    flv_born%n_in = 2; flv_real%n_in = 2
    write (u, "(A)") "* Valid splittings of ee -> uug"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 21): " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -2): " , flv_real%valid_pair (5, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 6 (2, 21) : " , flv_real%valid_pair (3, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 3 (21, 2) : " , flv_real%valid_pair (6, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 6 (-2, 21): " , flv_real%valid_pair (4, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 4 (21, -2): " , flv_real%valid_pair (6, 4, flv_born, test_model)
    write (u, "(A,L1)") "5, 6 (21, 21): " , flv_real%valid_pair (5, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 5 (21, 21): " , flv_real%valid_pair (6, 5, flv_born, test_model)
    call flv_real%final ()
    flv_real = [11, -11, 2, -2, 1, -1]
    flv_real%n_in = 2
    write (u, "(A)") "Real Flavors (exemplary g -> dd splitting): "
    call flv_real%write (u)
    write (u, "(A,L1)") "3, 4 (2, -2) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-2, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 1)  : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (1, 2)  : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-2, 1) : " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (1, -2) : " , flv_real%valid_pair (5, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 6 (2, -1) : " , flv_real%valid_pair (3, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 3 (-1, 2) : " , flv_real%valid_pair (6, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 6 (-2, -1): " , flv_real%valid_pair (4, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 4 (-1, -2): " , flv_real%valid_pair (6, 4, flv_born, test_model)
    write (u, "(A,L1)") "5, 6 (1, -1) : " , flv_real%valid_pair (5, 6, flv_born, test_model)
    write (u, "(A,L1)") "6, 5 (-1, 1) : " , flv_real%valid_pair (6, 5, flv_born, test_model)
    call write_separator (u)

    call flv_born%final ()
    call flv_real%final ()

    flv_born = [6, -5, 2, -1 ]
    flv_real = [6, -5, 2, -1, 21]
    flv_born%n_in = 1; flv_real%n_in = 1
    write (u, "(A)") "* Valid splittings of t -> b u d~"
    write (u, "(A)") "Born Flavors: "
    call flv_born%write (u)
    write (u, "(A)") "Real Flavors: "
    call flv_real%write (u)
    write (u, "(A,L1)") "1, 2 (6, -5) : " , flv_real%valid_pair (1, 2, flv_born, test_model)
    write (u, "(A,L1)") "1, 3 (6, 2)  : " , flv_real%valid_pair (1, 3, flv_born, test_model)
    write (u, "(A,L1)") "1, 4 (6, -1) : " , flv_real%valid_pair (1, 4, flv_born, test_model)
    write (u, "(A,L1)") "2, 1 (-5, 6) : " , flv_real%valid_pair (2, 1, flv_born, test_model)
    write (u, "(A,L1)") "3, 1 (2, 6)  : " , flv_real%valid_pair (3, 1, flv_born, test_model)
    write (u, "(A,L1)") "4, 1 (-1, 6) : " , flv_real%valid_pair (4, 1, flv_born, test_model)
    write (u, "(A,L1)") "2, 3 (-5, 2) : " , flv_real%valid_pair (2, 3, flv_born, test_model)
    write (u, "(A,L1)") "2, 4 (-5, -1): " , flv_real%valid_pair (2, 4, flv_born, test_model)
    write (u, "(A,L1)") "3, 2 (2, -5) : " , flv_real%valid_pair (3, 2, flv_born, test_model)
    write (u, "(A,L1)") "4, 2 (-1, -5): " , flv_real%valid_pair (4, 2, flv_born, test_model)
    write (u, "(A,L1)") "3, 4 (2, -1) : " , flv_real%valid_pair (3, 4, flv_born, test_model)
    write (u, "(A,L1)") "4, 3 (-1, 2) : " , flv_real%valid_pair (4, 3, flv_born, test_model)
    write (u, "(A,L1)") "1, 5 (6, 21) : " , flv_real%valid_pair (1, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 1 (21, 6) : " , flv_real%valid_pair (5, 1, flv_born, test_model)
    write (u, "(A,L1)") "2, 5 (-5, 21): " , flv_real%valid_pair (2, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 2 (21, 5) : " , flv_real%valid_pair (5, 2, flv_born, test_model)
    write (u, "(A,L1)") "3, 5 (2, 21) : " , flv_real%valid_pair (3, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 3 (21, 2) : " , flv_real%valid_pair (5, 3, flv_born, test_model)
    write (u, "(A,L1)") "4, 5 (-1, 21): " , flv_real%valid_pair (4, 5, flv_born, test_model)
    write (u, "(A,L1)") "5, 4 (21, -1): " , flv_real%valid_pair (5, 4, flv_born, test_model)

    call flv_born%final ()
    call flv_real%final ()

  end subroutine fks_regions_1

@ %def fks_regions_1
@
<<fks regions: test declarations>>=
  public :: fks_regions_2
<<fks regions: tests>>=
  subroutine fks_regions_2 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: fks_regions_2"
    write (u, "(A)") "* Create table of singular regions for ee -> qq"
    write (u, "(A)")

    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 4; n_legs_real = 5
    n_in = 2

    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flv_born (:, 1) = [11, -11, 2, -2]
    flv_real (:, 1) = [11, -11, 2, -2, 21]
    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
    call reg_data%write (u)

    call write_separator (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

    write (u, "(A)") "* Create table of singular regions for ee -> qqg"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 2
    n_legs_born = 5; n_legs_real = 6
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [11, -11, 2, -2, 21]
    flv_real (:, 1) = [11, -11, 2, -2, 21, 21]
    flv_real (:, 2) = [11, -11, 2, -2, 1, -1]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
    call reg_data%write (u)


  end subroutine fks_regions_2

@ %def fks_regions_2
@
<<fks regions: test declarations>>=
  public :: fks_regions_3
<<fks regions: tests>>=
  subroutine fks_regions_3 (u)
    integer, intent(in) :: u
    integer :: n_flv_born, n_flv_real
    integer :: n_legs_born, n_legs_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    integer :: i, j
    integer, dimension(10) :: flavors
    write (u, "(A)") "* Test output: fks_regions_3"
    write (u, "(A)") "* Create table of singular regions for Drell Yan"
    write (u, "(A)")

    n_flv_born = 10; n_flv_real = 30
    n_legs_born = 4; n_legs_real = 5
    n_in = 2
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))
    flavors = [-5, -4, -3, -2, -1, 1, 2, 3, 4, 5]
    do i = 1, n_flv_born
       flv_born (3:4, i) = [11, -11]
    end do
    do j = 1, n_flv_born
       flv_born (1, j) = flavors (j)
       flv_born (2, j) = -flavors (j)
    end do

    do i = 1, n_flv_real
       flv_real (3:4, i) = [11, -11]
    end do
    i = 1
    do j = 1, n_flv_real
       if (mod (j, 3) == 1) then
          flv_real (1, j) = flavors (i)
          flv_real (2, j) = -flavors (i)
          flv_real (5, j) = 21
       else if (mod (j, 3) == 2) then
          flv_real (1, j) = flavors (i)
          flv_real (2, j) = 21
          flv_real (5, j) = flavors (i)
       else
          flv_real (1, j) = 21
          flv_real (2, j) = -flavors (i)
          flv_real (5, j) = -flavors (i)
          i = i + 1
       end if
    end do

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
    call reg_data%write (u)

    call write_separator (u)

    deallocate (flv_born, flv_real)
    call reg_data%final ()

    write (u, "(A)") "* Create table of singular regions for hadronic top decay"
    write (u, "(A)")
    n_flv_born = 1; n_flv_real = 1
    n_legs_born = 4; n_legs_real = 5
    n_in = 1
    allocate (flv_born (n_legs_born, n_flv_born))
    allocate (flv_real (n_legs_real, n_flv_real))

    flv_born (:, 1) = [6, -5, 2, -1]
    flv_real (:, 1) = [6, -5, 2, -1, 21]

    call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
    call reg_data%write (u)

  end subroutine fks_regions_3

@ %def fks_regions_3
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Virtual contribution to the cross section}
<<[[virtual.f90]]>>=
<<File header>>

module virtual

<<Use kinds>>
  use numeric_utils
  use constants
  use diagnostics
  use pdg_arrays
  use models
  use physics_defs
  use sm_physics
  use lorentz
  use flavors
  use nlo_data, only: get_threshold_momenta
  use fks_regions

<<Standard module head>>

<<virtual: public>>

<<virtual: types>>

contains

<<virtual: procedures>>

end module virtual
@ %def virtual
@
<<virtual: public>>=
  public :: virtual_t
<<virtual: types>>=
  type :: virtual_t
    real(default), dimension(:,:), allocatable :: gamma_0, gamma_p, c_flv
    real(default) :: ren_scale2, fac_scale, es_scale2
    integer, dimension(:), allocatable :: n_is_neutrinos
    integer :: n_in, n_legs, n_flv
    logical :: bad_point = .false.
    logical :: with_subtraction = .true.
    integer :: factorization_mode = NO_FACTORIZATION
    real(default), dimension(:,:,:), allocatable :: sqme_cc
    logical :: use_internal_cc = .false.
    integer, dimension(:), allocatable :: me_index
  contains
  <<virtual: virtual: TBP>>
  end type virtual_t

@ %def virtual_t
@
<<virtual: virtual: TBP>>=
  procedure :: init => virtual_init
<<virtual: procedures>>=
 subroutine virtual_init (virt, flv_born, n_in, use_internal_cc)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer, intent(in) :: n_in
    logical, intent(in) :: use_internal_cc
    integer :: n_sub
    integer :: i_flv
    virt%n_legs = size (flv_born, 1); virt%n_flv = size (flv_born, 2)
    virt%n_in = n_in
    allocate (virt%sqme_cc (virt%n_legs, virt%n_legs, virt%n_flv))
    allocate (virt%gamma_0 (virt%n_legs, virt%n_flv), &
       virt%gamma_p (virt%n_legs, virt%n_flv), &
       virt%c_flv (virt%n_legs, virt%n_flv))
    call virt%init_constants (flv_born)
    allocate (virt%n_is_neutrinos (virt%n_flv))
    virt%n_is_neutrinos = 0
    do i_flv = 1, virt%n_flv
       if (is_neutrino (flv_born(1, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
       if (is_neutrino (flv_born(2, i_flv))) &
          virt%n_is_neutrinos(i_flv) = virt%n_is_neutrinos(i_flv) + 1
    end do
    virt%use_internal_cc = use_internal_cc
    allocate (virt%me_index (virt%n_flv))
    n_sub = virt%compute_n_sub ()
    do i_flv = 1, virt%n_flv
       virt%me_index (i_flv) = (n_sub + 1) * i_flv - 1
    end do
  contains
    function is_neutrino (flv) result (neutrino)
      integer, intent(in) :: flv
      logical :: neutrino
      neutrino = (abs(flv) == 12 .or. abs(flv) == 14 .or. abs(flv) == 16)
    end function is_neutrino
  end subroutine virtual_init

@ %def virtual_init
@
 The virtual subtraction terms contain Casimir operators and derived constants, listed
below:
\begin{align}
  \label{eqn:C(q)}
  C(q) = C(\bar{q}) &= C_F, \\
  \label{eqn:C(g)}
  C(g) &= C_A,\\
  \label{eqn:gamma(q)}
  \gamma(q) = \gamma(\bar{q}) &= \frac{3}{2} C_F,\\
  \label{eqn:gamma(g)}
  \gamma(g) &= \frac{11}{6} C_A - \frac{2}{3} T_F N_f,\\
  \label{eqn:gammap(q)}
  \gamma'(q) = \gamma'(\bar{q}) &= \left(\frac{13}{2} - \frac{2\pi^2}{3}\right) C_F, \\
  \label{eqn:gammap(g)}
  \gamma'(g) &= \left(\frac{67}{9} - \frac{2\pi^2}{3}\right) C_A - \frac{23}{9} T_F N_f.
\end{align}
For uncolored particles, [[virtual_init_constants]] sets $C$, $\gamma$ and $\gamma'$ to zero.
<<virtual: virtual: TBP>>=
  procedure :: init_constants => virtual_init_constants
<<virtual: procedures>>=
  subroutine virtual_init_constants (virt, flv_born)
    class(virtual_t), intent(inout) :: virt
    integer, intent(in), dimension(:,:) :: flv_born
    integer :: i_part, i_flv
    integer, parameter :: nf = 1
    do i_flv = 1, size (flv_born, 2)
       do i_part = 1, size (flv_born, 1)
          if (is_gluon (flv_born(i_part, i_flv))) then
             virt%gamma_0(i_part, i_flv) = (11 * ca - 2 * nf) / 6
             virt%gamma_p(i_part, i_flv) = (67.0 / 9 - 2 * pi**2 / 3) * ca &
                - 23.0 / 18 * nf
             virt%c_flv(i_part, i_flv) = ca
          else if (is_quark (flv_born(i_part, i_flv))) then
             virt%gamma_0(i_part, i_flv) = 1.5 * cf
             virt%gamma_p(i_part, i_flv) = (6.5 - 2 * pi**2 / 3) * cf
             virt%c_flv(i_part, i_flv) = cf
          else
             virt%gamma_0(i_part, i_flv) = zero
             virt%gamma_p(i_part, i_flv) = zero
             virt%c_flv(i_part, i_flv) = zero
          end if
       end do
    end do
  end subroutine virtual_init_constants

@ %def virtual_init_constants
@ Set the renormalization scale. If the input is zero, use the
center-of-mass energy.
<<virtual: virtual: TBP>>=
  procedure :: set_ren_scale => virtual_set_ren_scale
<<virtual: procedures>>=
  subroutine virtual_set_ren_scale (virt, p, ren_scale)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in) :: ren_scale
    if (ren_scale > 0) then
      virt%ren_scale2 = ren_scale**2
    else
      virt%ren_scale2 = (p(1) + p(2))**2
    end if
  end subroutine virtual_set_ren_scale

@ %def virtual_set_ren_scale
@
<<virtual: virtual: TBP>>=
  procedure :: set_fac_scale => virtual_set_fac_scale
<<virtual: procedures>>=
  subroutine virtual_set_fac_scale (virt, p, fac_scale)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), optional :: fac_scale
    if (present (fac_scale)) then
       virt%fac_scale = fac_scale
    else
       virt%fac_scale = (p(1) + p(2))**1
    end if
  end subroutine virtual_set_fac_scale

@ %def virtual_set_fac_scale
<<virtual: virtual: TBP>>=
  procedure :: set_ellis_sexton_scale => virtual_set_ellis_sexton_scale
<<virtual: procedures>>=
  subroutine virtual_set_ellis_sexton_scale (virt, Q2)
    class(virtual_t), intent(inout) :: virt
    real(default), intent(in), optional :: Q2
    if (present (Q2)) then
       virt%es_scale2 = Q2
    else
       virt%es_scale2 = virt%ren_scale2
    end if
  end subroutine virtual_set_ellis_sexton_scale

@ %def virtual_set_ellis_sexton_scale
@
<<virtual: virtual: TBP>>=
  procedure :: compute_n_sub => virtual_compute_n_sub
<<virtual: procedures>>=
  function virtual_compute_n_sub (virt) result (n_sub)
    integer :: n_sub
    class(virtual_t), intent(in) :: virt
    n_sub = 1
    if (.not. virt%use_internal_cc) &
         n_sub = n_sub + virt%n_legs * (virt%n_legs - 1 ) / 2
  end function virtual_compute_n_sub

@ %def virtual_compute_n_sub
@ The virtual-subtracted matrix element is given by the equation
\begin{equation}
  \label{eqn:virt_sub}
  \mathcal{V} = \frac{\alpha_s}{2\pi}\left(\mathcal{Q}\mathcal{B} +
  \sum \mathcal{I}_{ij}\mathcal{B}_{ij} + \mathcal{V}_{fin}\right),
\end{equation}
The expressions for $\mathcal{Q}$ can be found in equations \ref{eqn:virt_Q_isr}
and \ref{eqn:virt_Q_fsr}.
The expressions for $\mathcal{I}_{ij}$ can be found in equations
(\ref{I_00}), (\ref{I_mm}), (\ref{I_0m}), depending on whether the
particles involved in the radiation process are massive or massless.
<<virtual: virtual: TBP>>=
  procedure :: evaluate => virtual_evaluate
<<virtual: procedures>>=
  function virtual_evaluate (virt, reg_data, alpha_s, p_born, sqme) result (sqme_virt)
    real(default) :: sqme_virt
    class(virtual_t), intent(inout) :: virt
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in) :: alpha_s
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in), dimension(:) :: sqme
    real(default) :: s, s_o_Q2
    real(default) :: QB, BI
    integer :: i_flv
    QB = zero; sqme_virt = zero
    if (virt%bad_point) return
    if (debug2_active (D_VIRTUAL)) then
       print *, 'Compute virtual component using phase space point: '
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       print *, 'Compute virtual component using alpha_s = ', alpha_s
    end if

    s = sum (p_born(1 : virt%n_in))**2
    s_o_Q2 = s / virt%es_scale2
    call virt%evaluate_initial_state (sqrt(s), reg_data, sqme, QB)
    call virt%compute_collinear_contribution (p_born, sqrt(s), reg_data, sqme, QB)

    select case (virt%factorization_mode)
    case (FACTORIZATION_THRESHOLD)
       call virt%compute_eikonals_threshold (p_born, s, s_o_Q2, reg_data, sqme, QB, BI)
    case default
       call virt%compute_massive_self_eikonals (p_born, s, reg_data, sqme, QB)
       BI = virt%compute_eikonals (p_born, s, s_o_Q2, reg_data, sqme)
    end select

    do i_flv = 1, reg_data%n_flv_born
       sqme_virt = sqme_virt + sqme (virt%me_index(i_flv))
    end do
    !!! A factor of alpha_s/twopi is assumed to be included in vfin
    if (virt%with_subtraction) &
         sqme_virt = sqme_virt + alpha_s / twopi * (QB + BI)

    if (debug2_active (D_VIRTUAL)) then
       call msg_debug2 (D_VIRTUAL, "virtual-subtracted matrix element: ")
       print *, 'Q * sqme_born: ', QB
       print *, 'BI: ', BI
       print *, 'vfin: ', sqme (virt%me_index)
       print *, 'Result: ', sqme_virt
    end if

    do i_flv = 1, reg_data%n_flv_born
       if (virt%n_is_neutrinos(i_flv) > 0) &
            sqme_virt = sqme_virt * virt%n_is_neutrinos(i_flv) * two
    end do
  end function virtual_evaluate

@ %def virtual_evaluate
@
@
<<virtual: virtual: TBP>>=
  procedure :: compute_eikonals => virtual_compute_eikonals
<<virtual: procedures>>=
  function virtual_compute_eikonals (virtual, p_born, s, s_o_Q2, reg_data, sqme) result (BI)
    real(default) :: BI
    class(virtual_t), intent(inout) :: virtual
    type(vector4_t), intent(in), dimension(:)  :: p_born
    real(default), intent(in) :: s, s_o_Q2
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in), dimension(:) :: sqme
    integer :: i_flv, i_born
    integer :: i, j, k
    real(default) :: I_ij, BI_tmp
    BI = zero
    do k = 1, reg_data%n_flv_born
       BI_tmp = zero
       i_flv = reg_data%underlying_borns (k)
       i_born = virtual%me_index(i_flv) + 1
       associate (flst_born => reg_data%flv_born(i_flv))
          do i = 1, virtual%n_legs
             do j = 1, virtual%n_legs
                if (i /= j) then
                   if (flst_born%colored(i) .and. flst_born%colored(j)) then
                      I_ij = compute_eikonal_factor &
                           (p_born, flst_born%massive, i, j, s_o_Q2)
                      BI_tmp = BI_tmp + virtual%sqme_cc (i, j, i_flv) * I_ij
                      if (debug2_active (D_VIRTUAL)) &
                         print *, 'b_ij: ', virtual%sqme_cc (i, j, i_flv), 'I_ij: ', I_ij
                   end if
                end if
             end do
          end do
       end associate
       if (virtual%use_internal_cc) BI_tmp = BI_tmp * sqme (i_born)
       BI = BI + BI_tmp
    end do
  end function virtual_compute_eikonals

@ %def virtual_compute_eikonals
@
<<virtual: virtual: TBP>>=
  procedure :: compute_eikonals_threshold => virtual_compute_eikonals_threshold
<<virtual: procedures>>=
  subroutine virtual_compute_eikonals_threshold (virtual, p_born, s, s_o_Q2, reg_data, &
       sqme, QB, BI)
    class(virtual_t), intent(in) :: virtual
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: s, s_o_Q2
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in), dimension(:) :: sqme
    real(default), intent(inout) :: QB
    real(default), intent(out) :: BI
    type(vector4_t), dimension(4) :: p_thr
    integer :: i, i_flv, i_born

    BI = zero; p_thr = get_threshold_momenta (p_born)
    do i = 1, reg_data%n_flv_born
       i_flv = reg_data%underlying_borns (i)
       i_born = virtual%me_index(i_flv) + 1
       call compute_massive_self_eikonals (sqme (i_born), QB)
       BI = BI + evaluate_leg_pair (1, i_flv, i_born) + evaluate_leg_pair (3, i_flv, i_born)
    end do
  contains

    subroutine compute_massive_self_eikonals (sqme_born, QB)
      real(default), intent(in) :: sqme_born
      real(default), intent(inout) :: QB
      real(default) :: term_1, term_2
      integer :: i
      do i = 1, 4
         term_1 = log (s_o_Q2)
         term_2 = 0.5_default * I_m_eps (p_thr(i))
         QB = QB - (cf * (term_1 - term_2)) * sqme_born
      end do
    end subroutine compute_massive_self_eikonals

    function evaluate_leg_pair (i_start, i_flv, i_born) result (b_ij_times_I)
      real(default) :: b_ij_times_I
      integer, intent(in) :: i_start, i_flv, i_born
      real(default) :: I_ij
      integer :: i, j
      b_ij_times_I = zero
      do i = i_start, i_start + 1
         do j = i_start, i_start + 1
            if (i /= j) then
               I_ij = compute_eikonal_factor &
                    (p_thr, [.true., .true., .true., .true.], i, j, s_o_Q2)
               b_ij_times_I = b_ij_times_I + &
                    virtual%sqme_cc (i, j, i_flv) * I_ij 
               if (debug2_active (D_VIRTUAL)) &
                  print *, 'b_ij: ', virtual%sqme_cc (i, j, i_flv), 'I_ij: ', I_ij
            end if
         end do
      end do
      if (virtual%use_internal_cc) b_ij_times_I = b_ij_times_I * sqme (i_born)
      if (debug2_active (D_VIRTUAL)) then
         print *, 'b_ij_times_I =    ', b_ij_times_I
         print *, 'QB           =    ', QB
      end if
    end function evaluate_leg_pair
  end subroutine virtual_compute_eikonals_threshold

@ %def virtual_compute_eikonals_threshold
@
<<virtual: virtual: TBP>>=
  procedure :: set_bad_point => virtual_set_bad_point
<<virtual: procedures>>=
  subroutine virtual_set_bad_point (virt, value)
     class(virtual_t), intent(inout) :: virt
     logical, intent(in) :: value
     virt%bad_point = value
  end subroutine virtual_set_bad_point

@  %def virtual_set_bad_point
@ The collinear limit of $\tilde{\mathcal{R}}$ can be integrated over the radiation
degrees of freedom, giving the collinear contribution to the virtual component. Its
general structure is $\mathcal{Q} \cdot \mathcal{B}$. The initial-state contribution
to $\mathcal{Q}$ is simply given by
\begin{equation}
  \label{eqn:virt_Q_isr}
  \mathcal{Q} = -\log\frac{\mu_F^2}{Q^2} \left(\gamma(\mathcal{I}_1)
       + \gamma(\mathcal{I}_2)\right),
\end{equation}
where $Q^2$ is the Ellis-Sexton scale and $\gamma$ is as in eqns. \ref{eqn:gamma(q)}
and \ref{eqn:gamma(g)}.\\
[[virtual_evaluate_initial_state]] computes this quantity. The loop over the
initial-state particles is only executed if we are
dealing with a scattering process, because for decays there are no virtual
initial-initial interactions.
<<virtual: virtual: TBP>>=
  procedure :: evaluate_initial_state => virtual_evaluate_initial_state
<<virtual: procedures>>=
  subroutine virtual_evaluate_initial_state (virt, sqrts, reg_data, sqme, QB)
    class(virtual_t), intent(inout) :: virt
    real(default), intent(in) :: sqrts
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in), dimension(:) :: sqme
    real(default), intent(inout) :: QB
    integer :: i, i_flv, i_sqme
    if (virt%n_in == 2) then
       do i_flv = 1, reg_data%n_flv_born
          i_sqme = virt%me_index(i_flv) + 1
          do i = 1, virt%n_in
             QB = QB - virt%gamma_0 (i, i_flv) * &
                  log(virt%fac_scale**2 / virt%es_scale2) * sqme (i_sqme)
          end do
       end do
    end if
  end subroutine virtual_evaluate_initial_state

@ %def virtual_evaluate_initial_state
@ Same as above, but for final-state particles. The collinear limit for final-state
particles follows from the integral
\begin{equation*}
  I_{+,\alpha_r} = \int d\Phi_{n+1} \frac{\xi_+^{-1-2\epsilon}}{\xi^{-1-2\epsilon}} \mathcal{R}_{\alpha_r}.
\end{equation*}
We can distinguish three situations:
\begin{enumerate}
  \item $\alpha_r$ contains a massive emitter. In this case, no collinear subtraction terms is required and
        the integral above irrelevant.
  \item $\alpha_r$ contains a massless emitter, but resonances are not taken into account in the subtraction.
        Here, $\xi_{max} = \frac{2E_{em}}{\sqrt{s}}$ is the upper bound on $\xi$.
  \item $\alpha_r$ contains a massless emitter and resonance-aware subtraction is used. Here,
        $\xi_{max} = \frac{2E_{em}}{\sqrt{k_{res}^2}}$.
\end{enumerate}
Before version 2.4, only situations 1 and 2 were covered. The difference between situation 2 and 3 comes
from the expansion of the plus-distribution in the integral above,
\begin{equation*}
  \xi_+^{-1-2\epsilon} = \xi^{-1-2\epsilon} + \frac{1}{2\epsilon}\delta(\xi)
       = \xi_{max}^{-1-2\epsilon}\left[(1-z)^{-1-2\epsilon} + \frac{\xi_{max}^{2\epsilon}}{2\epsilon}\delta(1-z)\right].
\end{equation*}
The expression from the standard FKS literature is given by
$\mathcal{Q}$ is given by
\begin{equation}
  \label{eqn:virt_Q_fsr_old}
  \begin{split}
   \mathcal{Q} = \sum_{k=n_{in}}^{n_L^{(B)}} \left[\gamma'(\mathcal{I}_k)
        - \log\frac{s}{2Q^2}\left(\gamma(\mathcal{I}_k)
        - 2C(\mathcal{I}_k) \log\frac{2E_k}{\sqrt{s}}\right) \right.\\
        + \left. 2C(\mathcal{I}_k) \log^2\frac{2E_k}{\sqrt{s}}
        - 2\gamma(\mathcal{I}_k)\log\frac{2E_k}{\sqrt{s}}\right].
  \end{split}
\end{equation}
$n_L^{(B)}$ is the number of legs at Born level.
Here, $\xi_{max}$ is implicitly present in the ratios in the logarithms. Using the resonance-aware $\xi_{max}$ yields
\begin{equation}
  \label{eqn:virt_Q_fsr}
  \begin{split}
    \mathcal{Q} = \sum_{k=n_{in}}^{n_L^{(B)}} \left[\gamma'(\mathcal{I}_k)
         + \left(\log\frac{\sqrt{s}}{2E_{em}} + \log\xi_{max}\right)\left(1 + \log\frac{Q^2}{s}\right) C(\mathcal{I}_k) \right.\\
         + \left. 2 \log\xi_{max} \left(\log\xi_{max} - \log\frac{Q^2}{k_{res}^2}\right) C(\mathcal{I}_k)
         + \left(\frac{Q^2}{k_{res}^2} - 2 \log\xi_{max}\right) \gamma(\mathcal{I}_k)\right].
  \end{split}
\end{equation}
Equation \ref{eqn:virt_Q_fsr} leads to \ref{eqn:virt_Q_fsr_old} with the substitutions $\xi_{max} \rightarrow \frac{2E_em}{\sqrt{s}}$ and $k_{res}^2 \rightarrow s$.
[[virtual_compute_collinear_contribution]] only implements the second one.
<<virtual: virtual: TBP>>=
  procedure :: compute_collinear_contribution &
     => virtual_compute_collinear_contribution
<<virtual: procedures>>=
  subroutine virtual_compute_collinear_contribution (virt, p_born, sqrts, reg_data, sqme, QB)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), dimension(:), intent(in) :: p_born
    real(default), intent(in) :: sqrts
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in), dimension(:) :: sqme
    real(default), intent(inout) :: QB
    real(default) :: s1, s2, s3, s4
    integer :: alr, em, i_flv, i_sqme
    real(default) :: E_em, xi_max, k_res2
    logical :: massive
    logical, dimension(virt%n_flv, virt%n_legs) :: evaluated

    evaluated = .false.
    do alr = 1, reg_data%n_regions
       em = reg_data%regions(alr)%emitter
       i_flv = reg_data%regions(alr)%uborn_index
       if (evaluated(i_flv, em)) cycle
       massive = reg_data%regions(alr)%flst_uborn%massive(em)
       !!! Collinear terms only for massless particles
       if (massive) cycle
       E_em = p_born(em)%p(0)
       i_sqme = virt%me_index(i_flv) + 1
       if (allocated (reg_data%alr_contributors)) then
          k_res2 = compute_resonance_mass (p_born, reg_data%alr_contributors(alr)%c)**2
       else
          k_res2 = sqrts**2
       end if
       xi_max = two * E_em / sqrt (k_res2)
       s1 = virt%gamma_p(em, i_flv)
       s2 = two * (log (sqrts / (two * E_em)) + log (xi_max)) * &
            (one + log (virt%es_scale2 / sqrts**2)) * virt%c_flv(em, i_flv)
       s3 = two * log (xi_max) * &
            (log (xi_max) - log (virt%es_scale2 / k_res2)) * virt%c_flv(em, i_flv)
       s4 = (log (virt%es_scale2 / k_res2) - two * log (xi_max)) * virt%gamma_0(em, i_flv)
       QB = QB + (s1 + s2 + s3 + s4) * sqme (i_sqme)
       evaluated(i_flv, em) = .true.
    end do
  end subroutine virtual_compute_collinear_contribution

@ %def virtual_compute_collinear_contribution
@
<<virtual: virtual: TBP>>=
  procedure :: compute_massive_self_eikonals => virtual_compute_massive_self_eikonals
<<virtual: procedures>>=
  subroutine virtual_compute_massive_self_eikonals (virt, p_born, s, reg_data, sqme, QB)
    class(virtual_t), intent(inout) :: virt
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: s
    type(region_data_t), intent(in) :: reg_data
    real(default), intent(in), dimension(:) :: sqme
    real(default), intent(inout) :: QB
    real(default) :: term1, term2
    integer :: alr, i, i_flv, i_born
    logical :: massive
    logical, dimension(virt%n_flv) :: evaluated

    evaluated = .false.
    do alr = 1, reg_data%n_regions
       i_flv = reg_data%regions(alr)%uborn_index
       if (evaluated(i_flv)) cycle
       i_born = virt%me_index(i_flv) + 1
       do i = 1, virt%n_legs
          massive = reg_data%regions(alr)%flst_uborn%massive(i)
          if (massive) then
             term1 = log(s / virt%es_scale2)
             term2 = 0.5_default * I_m_eps (p_born(i))
             QB = QB - (virt%c_flv (i, i_flv) * (term1 - term2)) * sqme (i_born)
          end if
       end do
       evaluated(i_flv) = .true.
    end do
  end subroutine virtual_compute_massive_self_eikonals

@ %def virtual_compute_massive_self_eikonals
@ The following code implements the $\mathcal{I}_{ij}$-function appearing in eq. blub.
They are defined as follows:
\begin{itemize}
\item[Massles-Massles Case]
  \begin{equation}
    \begin{split}
    \mathcal{I}_{ij} &= \frac{1}{2}\log^2\frac{s}{Q^2} + \log\frac{s}{Q^2}\log\frac{k_ik_j}{2E_iE_j}
                                                       - \rm{Li}_2\left(\frac{k_ik_j}{2E_iE_j}\right) \\
                     &+ \frac{1}{2}\log^2\frac{k_ik_j}{2E_iE_j} - \log\left(1-\frac{k_ik_j}{2E_iE_j}\right)
                        \log\frac{k_ik_j}{2E_iE_j}.
    \end{split}
    \label{I_00}
  \end{equation}
\item[Massive-Massive Case]
  \begin{equation}
     \mathcal{I}_{ij} = -\frac{1}{2}I_0(k_i, k_j)\log\frac{Q^2}{s} - \frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_mm}
  \end{equation}
  with
  \begin{equation*}
    I_0(k_i, k_j) = \frac{1}{\beta}\log\frac{1+\beta}{1-\beta}, \qquad
                    \beta = \sqrt{1-\frac{k_i^2k_j^2}{(k_i \cdot k_j)^2}}
  \end{equation*}
  and a rather involved expression for $I_\epsilon$:
  \begin{align*}
    I_\epsilon(k_i, k_j) &= \left(K(z_j)-K(z_i)\right) \frac{1-\vec{\beta_i}\cdot\vec{\beta_j}}{\sqrt{a(1-b)}}, \\
    \vec{\beta_i} &= \frac{\vec{k}_i}{k_i^0}, \\
    a &= \beta_i^2 + \beta_j^2 - 2\vec{\beta}_i \cdot \vec{\beta}_j, \\
    x_i &= \frac{\beta_i^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a}, \\
    x_j &= \frac{\beta_j^2 -\vec{\beta}_i \cdot \vec{\beta}_j}{a} = 1-x_j, \\
    b &= \frac{\beta_i^2\beta_j^2 - (\vec{\beta}_i\cdot\vec{\beta}_j)^2}{a}, \\
    c &= \sqrt{\frac{b}{4a}}, \\
    z_+ &= \frac{1+\sqrt{1-b}}{\sqrt{b}}, \\
    z_- &= \frac{1-\sqrt{1-b}}{\sqrt{b}}, \\
    z_i &= \frac{\sqrt{x_i^2 + 4c^2} - x_i}{2c}, \\
    z_j &= \frac{\sqrt{x_j^2 + 4c^2} + x_j}{2c}, \\
    K(z) = &-\frac{1}{2}\log^2\frac{(z-z_-)(z_+-z)}{(z_++z)(z_-+z)} - 2Li_2\left(\frac{2z_-(z_+-z)}{(z_+-z_-)(z_-+z)}\right) \\
           &-2Li_2\left(-\frac{2z_+(z_-+z)}{(z_+-z_-)(z_+-z)}\right)
  \end{align*}

\item[Massive-Massless Case]
  \begin{equation}
     \mathcal{I}_{ij} = \frac{1}{2}\left[\log^2\frac{Q}{s} - \frac{\pi^2}{6}\right] -\frac{1}{2}I_0(k_i,k_j)\log\frac{Q^2}{s}
                       -\frac{1}{2}I_\epsilon(k_i,k_j)
     \label{I_0m}
  \end{equation}
  with
  \begin{align*}
     I_0(p,k) &= \log\frac{(\hat{p}\cdot\hat{k})^2}{\hat{k}^2}, \\
     I_\varepsilon(p,k) &= -2\left[\frac{1}{4}\log^2\frac{1-\beta}{1+\beta} + \log\frac{\hat{p}\cdot\hat{k}}{1+\beta}\log\frac{\hat{p}\cdot\hat{k}}{1-\beta}
                           +Li_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1+\beta}\right) + Li_2\left(1-\frac{\hat{p}\cdot\hat{k}}{1-\beta}\right)\right]
  \end{align*}
  using
  \begin{equation*}
     \hat{p} = \frac{p}{p^0}, \quad \hat{k} = \frac{k}{k^0}, \quad \beta = \frac{|\vec{k}|}{k_0}.
  \end{equation*}

\end{itemize}

<<virtual: procedures>>=
  function compute_eikonal_factor (p_born, massive, i, j, s_o_Q2) result (I_ij)
    real(default) :: I_ij
    type(vector4_t), intent(in), dimension(:) :: p_born
    logical, dimension(:), intent(in) :: massive
    integer, intent(in) :: i, j
    real(default), intent(in) :: s_o_Q2
    if (massive(i) .and. massive(j)) then
       I_ij = compute_Imm (p_born(i), p_born(j), s_o_Q2)
    else if (.not. massive(i) .and. massive(j)) then
       I_ij = compute_I0m (p_born(i), p_born(j), s_o_Q2)
    else if (massive(i) .and. .not. massive(j)) then
       I_ij = compute_I0m (p_born(j), p_born(i), s_o_Q2)
    else
       I_ij = compute_I00 (p_born(i), p_born(j), s_o_Q2)
    end if
  end function compute_eikonal_factor

  function compute_I00 (pi, pj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: Ei, Ej
    real(default) :: pij, Eij
    real(default) :: s1, s2, s3, s4, s5
    real(default) :: arglog
    real(default), parameter :: tiny_value = epsilon(1.0)
    s1 = 0; s2 = 0; s3 = 0; s4 = 0; s5 = 0
    Ei = pi%p(0); Ej = pj%p(0)
    pij = pi * pj; Eij = Ei * Ej
    s1 = 0.5 * log(s_o_Q2)**2
    s2 = log(s_o_Q2) * log(pij / (two * Eij))
    s3 = Li2 (pij / (two * Eij))
    s4 = 0.5 * log (pij / (two * Eij))**2
    arglog = one - pij / (2*Eij)
    if (arglog > tiny_value) then
      s5 = log(arglog) * log(pij / (two * Eij))
    else
      s5 = 0
    end if
    I = s1 + s2 - s3 + s4 - s5
  end function compute_I00

  function compute_I0m (ki, kj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: ki, kj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: logsomu
    real(default) :: s1, s2, s3
    s1 = 0; s2 = 0; s3 = 0
    logsomu = log(s_o_Q2)
    s1 = 0.5 * (0.5 * logsomu**2 - pi**2 / 6)
    s2 = 0.5 * I_0m_0 (ki, kj) * logsomu
    s3 = 0.5 * I_0m_eps (ki, kj)
    I = s1 + s2 - s3
  end function compute_I0m

  function compute_Imm (pi, pj, s_o_Q2) result (I)
    type(vector4_t), intent(in) :: pi, pj
    real(default), intent(in) :: s_o_Q2
    real(default) :: I
    real(default) :: s1, s2
    s1 = 0.5 * log(s_o_Q2) * I_mm_0(pi, pj)
    s2 = 0.5 * I_mm_eps(pi, pj)
    I = s1 - s2
  end function compute_Imm

@ %def virtual_compute_I
@
<<virtual: procedures>>=
  function I_m_eps (p) result (I)
    type(vector4_t), intent(in) :: p
    real(default) :: I
    real(default) :: beta
    beta = space_part_norm (p)/p%p(0)
    if (beta < tiny_07) then
       I = four * (one + beta**2/3 + beta**4/5 + beta**6/7)
    else
       I = two * log((one + beta) / (one - beta)) / beta
    end if
  end function I_m_eps

@ %def I_m_eps
@ For $p^2=0$ and $k^2 \neq 0$, this computes the expression
\begin{equation*}
  I_\epsilon(p,k) = -2\left[\frac{1}{4}\log^2\frac{1-\beta}{1+\beta}
                    +\log \frac{\hat{p} \cdot k}{1+\beta}\log{\hat{p} \cdot k}{1-\beta}
                    +Li_2\left(1-\frac{\hat{p} \cdot k}{1+\beta}\right)
                    +Li_2\left(1-\frac{\hat{p} \cdot k}{1-\beta}\right)\right],
\end{equation*}
with $\hat{p} = \frac{p}{p^0}$ and $\beta = \frac{|\vec{k}|}{k^0}$.
<<virtual: procedures>>=
  function I_0m_eps (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp
    real(default) :: beta

    pp = p / p%p(0); kp = k / k%p(0)

    beta = sqrt (one - kp*kp)
    I = -2*(log((one - beta) / (one + beta))**2/4 + log((pp*kp) / (one + beta))*log((pp*kp) / (one - beta)) &
        + Li2(one - (pp*kp) / (one + beta)) + Li2(one - (pp*kp) / (one - beta)))
  end function I_0m_eps

@ %def I_0m_eps
@ For $p^2=0$ and $k^2 \neq 0$, computes the expression
\begin{equation*}
  I_0(p,k) = \log\frac{(\hat{p}\cdot\hat{k})^2}{\hat{k}^2}
\end{equation*}
<<virtual: procedures>>=
  function I_0m_0 (p, k) result (I)
    type(vector4_t), intent(in) :: p, k
    real(default) :: I
    type(vector4_t) :: pp, kp

    pp = p / p%p(0); kp = k / k%p(0)
    I = log((pp*kp)**2 / kp**2)
  end function I_0m_0

@ %def I_0m_0
@ For $k_1^2 \neq 0$ and $k_2^2 \neq 0$, computes the expression
\begin{equation*}
  I_\epsilon(k_1, k_2) = \left[K(z_2) - K(z_1)\right]
                         \frac{1-\vec{\beta}_1\cdot\vec{\beta}_2}{\sqrt{a(1-b)}},
\end{equation*}
where $\vec{\beta}_i = \frac{\vec{k}_i}{k_i^0}$. Further
\begin{align*}
  a &= \beta_1^2 + \beta_2^2 - 2\vec{\beta}_1\cdot\vec{\beta}_2, \\
  b &= \frac{\beta_1^2\beta_2^2 - \left(\vec{\beta}_1\cdot\vec{\beta}_2\right)^2}{a}, \\
  c &= \sqrt{\frac{b}{4a}}, \\
  K(z) = &-\frac{1}{2}\log^2\frac{(z-z_-)(z_+-z)}{(z_++z)(z_-+z)}
          - 2Li_2\left(\frac{2z_-(z_+-z)}{(z_+-z_-)(z_-+z)}\right) \\
         &-2Li_2\left(-\frac{2z_+(z_-+z)}{(z_+-z_-)(z_+-z)}\right),\\
  z_+ &= \frac{1+\sqrt{1-b}}{\sqrt{b}}, \\
  z_- &= \frac{1-\sqrt{1-b}}{\sqrt{b}}, \\
  x_1 &= \frac{\beta_1^2-\vec{\beta}_1\cdot \vec{\beta}_2}{a}, \\
  x_2 &= 1-x_1
  z_1 &= \frac{\sqrt{x_1^2+4c^2}-x_1}{2c}, \\
  z_2 &= \frac{\sqrt{x_2^2+4c^2}+x_2}{2c}.
\end{align*}
<<virtual: procedures>>=
  function I_mm_eps (p1, p2) result (I)
    type(vector4_t), intent(in) :: p1, p2
    real(default) :: I
    type(vector3_t) :: beta1, beta2
    real(default) :: a, b, b2
    real(default) :: zp, zm, z1, z2, x1, x2
    real(default) :: zmb, z1b
    real(default) :: K1, K2

    beta1 = space_part (p1) / energy(p1)
    beta2 = space_part (p2) / energy(p2)
    a = beta1**2 + beta2**2 - 2 * beta1 * beta2
    b = beta1**2 * beta2**2 - (beta1 * beta2)**2
    if (beta1**1 > beta2**1) call switch_beta (beta1, beta2)
    if (beta1 == vector3_null) then
       b2 = beta2**1
       I = (-0.5 * log ((one - b2) / (one + b2))**2 - two * Li2 (-two * b2 / (one - b2))) &
           * one / sqrt (a - b)
       return
    end if
    x1 = beta1**2 - beta1 * beta2
    x2 = beta2**2 - beta1 * beta2
    zp = sqrt (a) + sqrt (a - b)
    zm = sqrt (a) - sqrt (a - b)
    zmb = one  / zp
    z1 = sqrt (x1**2 + b) - x1
    z2 = sqrt (x2**2 + b) + x2
    z1b = one / (sqrt (x1**2 + b) + x1)
    K1 = - 0.5 * log (((z1b - zmb) * (zp - z1)) / ((zp + z1) * (z1b + zmb)))**2 &
          - two * Li2 ((two * zmb * (zp - z1)) / ((zp - zm) * (zmb + z1b))) &
          - two * Li2 ((-two * zp * (zm + z1)) / ((zp - zm) * (zp - z1)))
    K2 = - 0.5 * log ((( z2 - zm) * (zp - z2)) / ((zp + z2) * (z2 + zm)))**2 &
          - two * Li2 ((two * zm * (zp - z2)) / ((zp - zm) * (zm + z2))) &
          - two * Li2 ((-two * zp * (zm + z2)) / ((zp - zm) * (zp - z2)))
    I = (K2 - K1) * (one - beta1 * beta2) / sqrt (a - b)
  contains
    subroutine switch_beta (beta1, beta2)
      type(vector3_t), intent(inout) :: beta1, beta2
      type(vector3_t) :: beta_tmp
      beta_tmp = beta1
      beta1 = beta2
      beta2 = beta_tmp
    end subroutine switch_beta
  end function I_mm_eps

@ %def I_mm_eps
@ For $k_1^2 \neq 0$ and $k_2^2 \neq 0$ ,computes the expression
\begin{equation*}
  I_0(k_1, k_2) = \frac{1}{\beta} \log\frac{1+\beta}{1-\beta},
  \quad
  \beta = \sqrt{1-\frac{k_1^2k_2^2}{(k_1 \cdot k_2)^2}}
\end{equation*}
<<virtual: procedures>>=
  function I_mm_0 (k1, k2) result (I)
    type(vector4_t), intent(in) :: k1, k2
    real(default) :: I
    real(default) :: beta
    beta = sqrt (one - k1**2 * k2**2 / (k1 * k2)**2)
    I = log ((one + beta) / (one - beta)) / beta
  end function I_mm_0

@ %def I_mm_0
@
<<virtual: virtual: TBP>>=
  procedure :: final => virtual_final
<<virtual: procedures>>=
  subroutine virtual_final (virtual)
    class(virtual_t), intent(inout) :: virtual
    if (allocated (virtual%gamma_0)) deallocate (virtual%gamma_0)
    if (allocated (virtual%gamma_p)) deallocate (virtual%gamma_p)
    if (allocated (virtual%c_flv)) deallocate (virtual%c_flv)
    if (allocated (virtual%n_is_neutrinos)) deallocate (virtual%n_is_neutrinos)
  end subroutine virtual_final

@ %def virtual_final
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Real Subtraction}
<<[[real_subtraction.f90]]>>=
<<File header>>

module real_subtraction

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use string_utils
  use constants
  use numeric_utils
  use diagnostics
  use pdg_arrays
  use models
  use physics_defs
  use sm_physics
  use sf_lhapdf
  use pdf
  use lorentz
  use flavors
  use phs_fks, only: real_kinematics_t, isr_kinematics_t
  use phs_fks, only: I_PLUS, I_MINUS
  use phs_fks, only: phs_point_set_t

  use fks_regions
  use nlo_data

<<Standard module head>>

<<real subtraction: public>>

<<real subtraction: parameters>>

<<real subtraction: types>>

contains

<<real subtraction: procedures>>

end module real_subtraction
@ %def real_subtraction
@
\subsubsection{Soft subtraction terms}
<<real subtraction: parameters>>=
  integer, parameter, public :: INTEGRATION = 0
  integer, parameter, public :: FIXED_ORDER_EVENTS = 1
  integer, parameter, public :: POWHEG = 2


@ %def real subtraction parameters
@
In the soft limit, the real matrix element behaves as
\begin{equation*}
  \mathcal{R}_{\rm{soft}} = 4\pi\alpha_s \left[\sum_{i \neq j} \mathcal{B}_{ij} \frac{k_i \cdot k_j}{(k_i \cdot k)(k_j \cdot k)} - \mathcal{B} \sum_{i} \frac{k_i^2}{(k_i \cdot k)^2}C_i\right],
\end{equation*}
where $k$ denotes the momentum of the emitted parton. The quantity $\mathcal{B}_{ij}$ is called the color-correlated Born matrix element defined as
\begin{equation*}
  \mathcal{B}_{ij} = \frac{1}{2s} \sum_{\stackrel{colors}{spins}} \mathcal{M}_{\{c_k\}}\left(\mathcal{M}^\dagger_{\{c_k\}}\right)_{\stackrel{c_i \rightarrow c_i'}{c_j \rightarrow c_j'}} T^a_{c_i,c_i'} T^a_{c_j,c_j'}.
\end{equation*}
<<real subtraction: types>>=
  type :: soft_subtraction_t
    type(region_data_t), pointer :: reg_data => null ()
    real(default), dimension(:,:), allocatable :: momentum_matrix
    logical :: use_resonance_mappings = .false.
    type(vector4_t) :: p_soft = vector4_null
    logical :: use_internal_color_correlations = .true.
    logical :: use_internal_spin_correlations = .false.
    logical :: xi2_expanded = .true.
    integer :: factorization_mode = NO_FACTORIZATION
  contains
  <<real subtraction: soft sub: TBP>>
  end type soft_subtraction_t

@ %def soft_subtraction_t
@
<<real subtraction: soft sub: TBP>>=
  procedure :: init => soft_subtraction_init
<<real subtraction: procedures>>=
  subroutine soft_subtraction_init (sub_soft, reg_data)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(region_data_t), intent(in), target :: reg_data
    sub_soft%reg_data => reg_data
    allocate (sub_soft%momentum_matrix &
       (reg_data%n_legs_born, reg_data%n_legs_born))
  end subroutine soft_subtraction_init

@ %def soft_subtraction_init
@ The treatment of the momentum $k$ follows the discussion about the
soft limit of the partition functions (ref????).  The parton momentum is
pulled out, $k = E \hat{k}$. In fact, we will substitute $\hat{k}$ for
$k$ throughout the code, because the energy will factor out of the
equation when the soft $\mathcal{S}$-function is multiplied.  The soft
momentum is a unit vector, because $k^2 = \left(k^0\right)^2 -
\left(k^0\right)^2\hat{\vec{k}}^2 = 0$.

The soft momentum is constructed by first creating a unit vector
parallel to the emitter's Born momentum. This unit vector is then
rotated about the corresponding angles $y$ and $\phi$.
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_fsr => soft_subtraction_create_softvec_fsr
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_fsr &
     (sub_soft, p_born, y, phi, emitter, xi_ref_momentum)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: y, phi
    integer, intent(in) :: emitter
    type(vector4_t), intent(in) :: xi_ref_momentum
    type(vector3_t) :: dir
    type(vector4_t) :: p_em
    type(lorentz_transformation_t) :: rot
    type(lorentz_transformation_t) :: boost_to_rest_frame
    sub_soft%p_soft%p(0) = one
    if (sub_soft%use_resonance_mappings) then
       boost_to_rest_frame = inverse (boost (xi_ref_momentum, xi_ref_momentum**1))
       p_em = boost_to_rest_frame * p_born(emitter)
    else
       p_em = p_born(emitter)
    end if
    sub_soft%p_soft%p(1:3) = p_em%p(1:3) / space_part_norm (p_em)
    dir = create_orthogonal (space_part (p_em))
    rot = rotation (y, sqrt(one - y**2), dir)
    sub_soft%p_soft = rot * sub_soft%p_soft
    if (.not. vanishes (phi)) then
      dir = space_part (p_em) / space_part_norm (p_em)
      rot = rotation (cos(phi), sin(phi), dir)
      sub_soft%p_soft = rot * sub_soft%p_soft
    end if
    if (sub_soft%use_resonance_mappings) &
       sub_soft%p_soft = inverse (boost_to_rest_frame) * sub_soft%p_soft
  end subroutine soft_subtraction_create_softvec_fsr

@ %def soft_subtraction_create_softvec_fsr
@ For initial-state emissions, the soft vector is just a unit vector
with the same direction as the radiated particle.
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_isr => soft_subtraction_create_softvec_isr
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_isr (sub_soft, y, phi)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: y, phi
    real(default) :: sin_theta
    sin_theta = sqrt(one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = one
       p(1) = sin_theta * sin(phi)
       p(2) = sin_theta * cos(phi)
       p(3) = y
    end associate
  end subroutine soft_subtraction_create_softvec_isr

@ %def soft_subtraction_create_softvec_isr
@ The soft vector for the real mismatch is basically the same as for usual FSR,
except for the scaling with the total gluon energy. Moreover, the resulting
vector is rotated into the frame where the 3-axis points along the direction
of the emitter. This is necessary because in the collinear limit, the approximation
\begin{equation*}
  k_i = \frac{k_i^0}{\bar{k}_j^0} \bar{k}_j = \frac{\xi\sqrt{s}}{2\bar{k}_j^0}\bar{k}_j
\end{equation*}
is used. The collinear limit is not included in the soft mismatch yet, but we keep
the rotation for future usage here already (the performance loss is negligible).
<<real subtraction: soft sub: TBP>>=
  procedure :: create_softvec_mismatch => &
     soft_subtraction_create_softvec_mismatch
<<real subtraction: procedures>>=
  subroutine soft_subtraction_create_softvec_mismatch (sub_soft, E, y, phi, p_em)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    real(default), intent(in) :: E, phi, y
    type(vector4_t), intent(in) :: p_em
    real(default) :: sin_theta
    type(lorentz_transformation_t) :: rot_em_off_3_axis
    sin_theta = sqrt (one - y**2)
    associate (p => sub_soft%p_soft%p)
       p(0) = E
       p(1) = E * sin_theta * sin(phi)
       p(2) = E * sin_theta * cos(phi)
       p(3) = E * y
    end associate
    rot_em_off_3_axis = rotation_to_2nd (3, space_part (p_em))
    sub_soft%p_soft = rot_em_off_3_axis * sub_soft%p_soft
  end subroutine soft_subtraction_create_softvec_mismatch

@ %def soft_subtraction_create_softvec_mismatch
@ Computation of the soft limit of $R_\alpha$. Note that what we are
actually integrating (in the case of final-state radiation) is the
quantity $f(0,y) / \xi$, where
\begin{equation*}
  f(\xi,y) = \frac{J(\xi,y,\phi)}{\xi} \xi^2 R_\alpha.
\end{equation*}
$J/\xi$ is computed by the phase space generator. The additional factor
of $\xi^{-1}$ is supplied in the [[evaluate_region_fsr]]-routine. Thus,
we are left with a factor of $\xi^2$. A look on the expression for the
soft limit of $R_\alpha$ below reveals that we are factoring out the gluon
energy $E_i$ in the denominator. Therefore, we have a factor
$\xi^2 / E_i^2 = q^2 / 4$.\\
Note that the same routine is used also for the computation of the soft
mismatch. There, the gluon energy is not factored out from the soft vector,
so that we are left with the $\xi^2$-factor, which will eventually be
cancelled out again. So, we just multiply with 1. Both cases are
distinguished by the flag [[xi2_expanded]].
<<real subtraction: soft sub: TBP>>=
  procedure :: compute => soft_subtraction_compute
<<real subtraction: procedures>>=
  function soft_subtraction_compute (sub_soft, p_born, &
     born_ij, y, q2, alpha_s, alr, emitter, i_res) result (sqme)
    real(default) :: sqme
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    real(default), intent(in) :: y
    real(default), intent(in) :: q2, alpha_s
    integer, intent(in) :: alr, emitter, i_res
    real(default) :: s_alpha_soft
    real(default) :: kb
    real(default) :: xi2_factor

    if (.not. vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       call msg_fatal ("Soft subtraction: phase space point must be in CMS")
    end if
    if (debug2_active (D_SUBTRACTION)) then
       print *, 'Compute soft subtraction using alpha_s = ', alpha_s
    end if

    s_alpha_soft = sub_soft%reg_data%get_svalue_soft &
       (p_born, sub_soft%p_soft, alr, emitter, i_res)
    if (debug2_active (D_SUBTRACTION)) &
       call msg_print_color ('s_alpha_soft', s_alpha_soft, COL_YELLOW)
    select case (sub_soft%factorization_mode)
    case (NO_FACTORIZATION)
       kb = sub_soft%evaluate_factorization_default (p_born, born_ij)
    case (FACTORIZATION_THRESHOLD)
       kb = sub_soft%evaluate_factorization_threshold (p_born, born_ij)
    end select
    call msg_debug2 (D_SUBTRACTION, 'KB', kb)
    sqme = 4 * pi * alpha_s * s_alpha_soft * kb
    if (sub_soft%xi2_expanded) then
       xi2_factor = 4 / q2
    else
       xi2_factor = one
    end if
    if (emitter <= sub_soft%reg_data%n_in) then
       sqme = xi2_factor * (one - y**2) * sqme
    else
       sqme = xi2_factor * (one - y) * sqme
    end if
  end function soft_subtraction_compute

@ %def soft_subtraction_compute
@ We loop over all external legs and do not take care to leave out non-colored
ones because [[born_ij]] is constructed in such a way that it is only
non-zero for colored entries.
<<real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_default => &
     soft_subtraction_evaluate_factorization_default
<<real subtraction: procedures>>=
  function soft_subtraction_evaluate_factorization_default &
     (sub_soft, p, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p
    real(default), intent(in), dimension(:,:) :: born_ij
    integer :: i, j
    kb = zero
    call sub_soft%compute_momentum_matrix (p)
    do i = 1, size (p)
       do j = 1, size (p)
          kb = kb + sub_soft%momentum_matrix (i, j) * born_ij (i, j)
       end do
    end do
  end function soft_subtraction_evaluate_factorization_default

@ %def soft_subtraction_evaluate_factorization_default
@ We have to multiply this with $\xi^2(1-y)$. Further, when applying
the soft $\mathcal{S}$-function, the energy of the radiated particle
is factored out. Thus we have $\xi^2/E_{em}^2(1-y) = 4/q_0^2(1-y)$.
Computes the quantity $\mathcal{K}_{ij} = \frac{k_i \cdot
k_j}{(k_i\cdot k)(k_j\cdot k)}$.
<<real subtraction: soft sub: TBP>>=
  procedure :: compute_momentum_matrix => &
       soft_subtraction_compute_momentum_matrix
<<real subtraction: procedures>>=
  subroutine soft_subtraction_compute_momentum_matrix &
       (sub_soft, p_born)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default) :: num, deno1, deno2
    integer :: i, j
    do i = 1, sub_soft%reg_data%n_legs_born
       do j = 1, sub_soft%reg_data%n_legs_born
          if (i <= j) then
             num = p_born(i) * p_born(j)
             deno1 = p_born(i) * sub_soft%p_soft
             deno2 = p_born(j) * sub_soft%p_soft
             sub_soft%momentum_matrix(i,j) = num / (deno1 * deno2)
          else
             !!! momentum matrix is symmetric.
            sub_soft%momentum_matrix(i, j) = sub_soft%momentum_matrix(j, i)
          end if
       end do
    end do
  end subroutine soft_subtraction_compute_momentum_matrix

@ %def soft_subtraction_compute_momentum_matrx
@
<<real subtraction: soft sub: TBP>>=
  procedure :: evaluate_factorization_threshold => &
     soft_subtraction_evaluate_factorization_threshold
<<real subtraction: procedures>>=
  function soft_subtraction_evaluate_factorization_threshold &
     (sub_soft, p_born, born_ij) result (kb)
    real(default) :: kb
    class(soft_subtraction_t), intent(inout) :: sub_soft
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in), dimension(:,:) :: born_ij
    type(vector4_t), dimension(4) :: p
    p = get_threshold_momenta (p_born)
    kb = evaluate_leg_pair (1) + evaluate_leg_pair (3)
    if (debug2_active (D_SUBTRACTION))  call show_debug ()

  contains

    function evaluate_leg_pair (i_start) result (kbb)
      real(default) :: kbb
      integer, intent(in) :: i_start
      integer :: i1, i2
      real(default) :: numerator, deno1, deno2
      kbb = zero
      do i1 = i_start, i_start + 1
         do i2 = i_start, i_start + 1
            numerator = p(i1) * p(i2)
            deno1 = p(i1) * sub_soft%p_soft
            deno2 = p(i2) * sub_soft%p_soft
            kbb = kbb +  numerator * born_ij (i1, i2) / deno1 / deno2
         end do
      end do
      if (debug2_active (D_SUBTRACTION)) then
      do i1 = i_start, i_start + 1
         do i2 = i_start, i_start + 1
            call msg_print_color('i1', i1, COL_PEACH)
            call msg_print_color('i2', i2, COL_PEACH)
            call msg_print_color('born_ij(i1,i2)', born_ij(i1,i2), COL_PINK)
            numerator = p(i1) * p(i2)
            deno1 = p(i1) * sub_soft%p_soft
            deno2 = p(i2) * sub_soft%p_soft
            kbb = kbb +  numerator * born_ij (i1, i2) / deno1 / deno2
         end do
      end do
      end if
    end function evaluate_leg_pair

    subroutine show_debug ()
      integer :: i
      call msg_print_color ('soft_subtraction_evaluate_factorization_threshold', COL_GREEN)
      do i = 1, 4
         print *, 'sqrt(p(i)**2) =    ', sqrt(p(i)**2)
      end do
      print *, 'p_soft =    ', sub_soft%p_soft
    end subroutine show_debug

  end function soft_subtraction_evaluate_factorization_threshold

@ %def soft_subtraction_evaluate_factorization_threshold
@
<<real subtraction: soft sub: TBP>>=
  procedure :: final => soft_subtraction_final
<<real subtraction: procedures>>=
  subroutine soft_subtraction_final (sub_soft)
    class(soft_subtraction_t), intent(inout) :: sub_soft
    if (associated (sub_soft%reg_data)) nullify (sub_soft%reg_data)
    if (allocated (sub_soft%momentum_matrix)) deallocate (sub_soft%momentum_matrix)
  end subroutine soft_subtraction_final

@ %def soft_subtraction_final
@
\subsection{Soft mismatch}
<<real subtraction: public>>=
  public :: soft_mismatch_t
<<real subtraction: types>>=
  type :: soft_mismatch_t
    logical :: active = .true.
    type(region_data_t), pointer :: reg_data => null ()
    real(default), dimension(:), allocatable :: sqme_born
    real(default), dimension(:,:,:), allocatable :: sqme_born_cc
    type(real_kinematics_t), pointer :: real_kinematics => null ()
    type(soft_subtraction_t) :: sub_soft
  contains
  <<real subtraction: soft mismatch: TBP>>
  end type soft_mismatch_t

@ %def soft_mismatch_t
@
<<real subtraction: soft mismatch: TBP>>=
  procedure :: init => soft_mismatch_init
<<real subtraction: procedures>>=
  subroutine soft_mismatch_init (soft_mismatch, reg_data, &
     real_kinematics)
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    type(region_data_t), intent(in), target :: reg_data
    type(real_kinematics_t), intent(in), target :: real_kinematics
    select type (mapping => reg_data%fks_mapping)
    type is (fks_mapping_default_t)
       soft_mismatch%active = .false.
    type is (fks_mapping_resonances_t)
       soft_mismatch%reg_data => reg_data
       allocate (soft_mismatch%sqme_born (reg_data%n_flv_born))
       allocate (soft_mismatch%sqme_born_cc (reg_data%n_legs_born, &
          reg_data%n_legs_born, reg_data%n_flv_born))
       call soft_mismatch%sub_soft%init (reg_data)
       soft_mismatch%sub_soft%xi2_expanded = .false.
       soft_mismatch%real_kinematics => real_kinematics
    end select
  end subroutine soft_mismatch_init

@ %def soft_mismatch_init
@ Main routine to compute the soft mismatch. Loops over all singular regions.
There, it first creates the soft vector, then the necessary soft real matrix element.
These inputs are then used to get the numerical value of the soft mismatch.
<<real subtraction: soft mismatch: TBP>>=
  procedure :: evaluate => soft_mismatch_evaluate
<<real subtraction: procedures>>=
  function soft_mismatch_evaluate (soft_mismatch, alpha_s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    real(default), intent(in) :: alpha_s
    integer :: alr, i_uborn, emitter, i_res, i_phs, i_con
    real(default) :: xi, y, q2, s
    real(default) :: E_gluon
    type(vector4_t) :: p_em
    real(default) :: sqme_alr, sqme_soft
    sqme_mismatch = zero
    if (.not. soft_mismatch%active) return
    associate (real_kinematics => soft_mismatch%real_kinematics)
       xi = real_kinematics%xi_mismatch
       y = real_kinematics%y_mismatch
       s = real_kinematics%cms_energy2
       E_gluon = sqrt (s) * xi / two

       if (debug_active (D_MISMATCH)) then
          print *, 'Evaluating soft mismatch: '
          print *, 'Phase space: '
          call vector4_write_set (real_kinematics%p_born_cms%get_momenta(1), &
             show_mass = .true.)
          print *, 'xi: ', xi, 'y: ', y, 's: ', s, 'E_gluon: ', E_gluon
       end if

       do alr = 1, soft_mismatch%reg_data%n_regions

          i_phs = real_kinematics%alr_to_i_phs (alr)
          i_con = soft_mismatch%reg_data%alr_to_i_contributor (alr)
          q2 = real_kinematics%xi_ref_momenta(i_con)**2
          emitter = soft_mismatch%reg_data%regions(alr)%emitter
          p_em = real_kinematics%p_born_cms%get_momentum (1, emitter)
          i_res = soft_mismatch%reg_data%regions(alr)%i_res
          i_uborn = soft_mismatch%reg_data%regions(alr)%uborn_index

          call print_debug_alr ()

          call soft_mismatch%sub_soft%create_softvec_mismatch &
             (E_gluon, y, real_kinematics%phi, p_em)
          if (debug_active (D_MISMATCH)) &
             print *, 'Created soft vector: ', soft_mismatch%sub_soft%p_soft%p

          select type (fks_mapping => soft_mismatch%reg_data%fks_mapping)
          type is (fks_mapping_resonances_t)
             call fks_mapping%set_resonance_momentum &
                (real_kinematics%xi_ref_momenta(i_con))
          end select

          sqme_soft = soft_mismatch%sub_soft%compute &
             (real_kinematics%p_born_cms%get_momenta(1), &
             soft_mismatch%sqme_born_cc(:,:,i_uborn), y, &
             q2, alpha_s, alr, emitter, i_res)

          sqme_alr = soft_mismatch%compute (alr, xi, y, p_em, &
             real_kinematics%xi_ref_momenta(i_con), soft_mismatch%sub_soft%p_soft, &
             soft_mismatch%sqme_born(i_uborn), sqme_soft, &
             alpha_s, s)

          call msg_debug (D_MISMATCH, 'sqme_alr: ', sqme_alr)
          sqme_mismatch = sqme_mismatch + sqme_alr

       end do
    end associate
  contains
    subroutine print_debug_alr ()
      if (debug_active (D_MISMATCH)) then
         print *, 'alr: ', alr
         print *, 'i_phs: ', i_phs, 'i_con: ', i_con, 'i_res: ', i_res
         print *, 'emitter: ', emitter, 'i_uborn: ', i_uborn
         print *, 'emitter momentum: ', p_em%p
         print *, 'resonance momentum: ', &
            soft_mismatch%real_kinematics%xi_ref_momenta(i_con)%p
         print *, 'q2: ', q2
      end if
    end subroutine print_debug_alr
  end function soft_mismatch_evaluate

@ %def soft_mismatch_evaluate
@ Computes the soft mismatch in a given $\alpha_r$,
\begin{align*}
  I_{s+,\alpha_r} &= \int d\Phi_B \int_0^\infty d\xi \int_{-1}^1 dy \int_0^{2\pi} d\phi
     \frac{s\xi}{(4\pi)^3} \\
   &\times \left\lbrace\tilde{R}_{\alpha_r}
    \left(e^{-\frac{2k_\gamma \cdot k_{res}}{k_{res}}^2} - e^{-\xi}\right)
  - \frac{32 \pi \alpha_s C_{em}}{s\xi^2} B_{f_b(\alpha_r)} (1-y)^{-1}
    \left[e^{-\frac{2\bar{k}_{em} \cdot k_{res}}{k_{res}^2} \frac{k_\gamma^0}{k_{em}^0}} - e^{-\xi}\right]\right\rbrace.
\end{align*}
<<real subtraction: soft mismatch: TBP>>=
  procedure :: compute => soft_mismatch_compute
<<real subtraction: procedures>>=
  function soft_mismatch_compute (soft_mismatch, alr, xi, y, p_em, p_res, p_soft, &
     sqme_born, sqme_soft, alpha_s, s) result (sqme_mismatch)
    real(default) :: sqme_mismatch
    class(soft_mismatch_t), intent(in) :: soft_mismatch
    integer, intent(in) :: alr
    real(default), intent(in) :: xi, y
    type(vector4_t), intent(in) :: p_em, p_res, p_soft
    real(default), intent(in) :: sqme_born, sqme_soft
    real(default), intent(in) :: alpha_s, s
    real(default) :: q2, expo, sm1, sm2, jacobian

    q2 = p_res**2
    expo = - two * p_soft * p_res / q2
    !!! Divide by 1 - y to factor out the corresponding
    !!! factor in the soft matrix element
    sm1 = sqme_soft / (one - y) * ( exp(expo) - exp(- xi) )
    call msg_debug2 (D_MISMATCH, 'sqme_soft in mismatch ', sqme_soft)

    sm2 = zero
    if (soft_mismatch%reg_data%regions(alr)%has_collinear_divergence ()) then
       expo = - two * p_em * p_res / q2 * &
          p_soft%p(0) / p_em%p(0)
       sm2 = 32 * pi * alpha_s * cf / (s * xi**2) * sqme_born * &
          ( exp(expo) - exp(- xi) ) / (one - y)
    end if

    jacobian = soft_mismatch%real_kinematics%jac_mismatch * s * xi / (8 * twopi3)
    sqme_mismatch = (sm1 - sm2) * jacobian

  end function soft_mismatch_compute

@ %def soft_mismatch_compute
@
<<real subtraction: soft mismatch: TBP>>=
  procedure :: final => soft_mismatch_final
<<real subtraction: procedures>>=
  subroutine soft_mismatch_final (soft_mismatch)
    class(soft_mismatch_t), intent(inout) :: soft_mismatch
    call soft_mismatch%sub_soft%final ()
    if (associated (soft_mismatch%reg_data)) nullify (soft_mismatch%reg_data)
    if (allocated (soft_mismatch%sqme_born)) deallocate (soft_mismatch%sqme_born)
    if (allocated (soft_mismatch%sqme_born_cc)) deallocate (soft_mismatch%sqme_born_cc)
    if (associated (soft_mismatch%real_kinematics)) nullify (soft_mismatch%real_kinematics)
  end subroutine soft_mismatch_final

@ %def soft_mismatch_final
@
\subsection{Collinear and soft-collinear subtraction terms}
This data type deals with the calculation of the collinear and
soft-collinear contribution to the cross section.
<<real subtraction: types>>=
  type :: coll_subtraction_t
    integer :: n_in, n_alr
    logical :: use_resonance_mappings = .false.
  contains
  <<real subtraction: coll sub: TBP>>
  end type coll_subtraction_t

@ %def coll_subtraction_t
@
<<real subtraction: coll sub: TBP>>=
  procedure :: init => coll_subtraction_init
<<real subtraction: procedures>>=
  subroutine coll_subtraction_init (coll_sub, n_alr, n_in)
    class(coll_subtraction_t), intent(inout) :: coll_sub
    integer, intent(in) :: n_alr, n_in
    coll_sub%n_in = n_in
    coll_sub%n_alr = n_alr
  end subroutine coll_subtraction_init

@ %def coll_subtraction_init
@ To compute the collinear limit of $\mathcal{R}$, we follow the
original FKS-paper. Here, the real amplitude is supposed to factorize
in the collinear limit. considering a splitting $g \rightarrow g(i)g(j)$,
\begin{equation*}
  \mathcal{A}^{(n)}(h_i,h_j,\{h_l\} \stackrel{i \parallel j}{\rightarrow}
  g_s \sum_{d_e} \sum_{h_e} C(d_e, b, c)
  S_{gg}^{h_eh_ih_j}(z)\mathcal{A}_{d_e}^{(n-1)} (h_e, \{h_l\})
\end{equation*}
\textbf{Explain quantities.} Evaluating this expression leads to
\begin{equation*}
  |\mathcal{A}^{(n)}(h_i,h_j,\{h_l\})|^2 \stackrel{i \parallel
  j}{\rightarrow}  |\mathcal{N}^{(n)}(h_i,h_j,\{h_l\}|^2 +
  \mathcal{R}(h_i,h_j,\{h_l\})|^2,
\end{equation*}
where $\mathcal{R}$ contains all contributions with spin-correlated
amplitudes, i.e. terms like
$\mathcal{A}_{d_e}^{(n-1)}(+,\{h_l\})\left(\mathcal{A}_{d_e}^{(n-1)}(-,\{h_l\})\right)^*$.
   Explicitly,
\begin{equation*}
  \sum_{h_i,h_j,\{h_l\}}\sum_{\{d_l\}} |\mathcal{N}^{(n)}(h_i,h_j,\{h_l\})|^2 =
  \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{gg}(z)|\mathcal{A}^{(n-1)}|^2,
\end{equation*}
and
\begin{align*}
  \sum_{h_i,h_j,\{h_l\}}\sum_{\{d_l\}} &\mathcal{R}(h_i,h_j,\{h_l\}) =
    32\pi\alpha_s C_A z(1-z) \\
  &\times \underbrace{Re\left\{\frac{\langle ij \rangle}{[ij]}
    \sum_{\{h_l\}}\sum_{d_e, \{d_l\}}\mathcal{A}^{(n-1)}_{d_e}(+,\{h_l\})
    \left(\mathcal{A}^{(n-1)}_{d_e}(-,\{h_l\})\right)^*\right\}}
   _{-\tilde{\mathcal{M}}^{(n-1)}/(2k_i\cdot k_j)}.
\end{align*}
This yields
\begin{equation}
  \mathcal{M}^{(n)} \stackrel{i \parallel j}{\rightarrow}
  \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{gg}(z)\mathcal{M}^{(n-1)} -
  \frac{16\pi\alpha_s}{k_i \cdot k_j} C_A z(1-z)\tilde{\mathcal{M}}^{(n-1)}.
  \label{coll1}
\end{equation}
The equivalent expression for a $g \rightarrow qq$-splitting is given by
\begin{equation}
  \mathcal{M}^{(n)} \stackrel{i \parallel j}{\rightarrow} \frac{4\pi\alpha_s}{k_i \cdot k_j} P_{qg}(z)\mathcal{M}^{(n-1)} + \frac{16\pi\alpha_s}{k_i \cdot k_j} T_F z(1-z)\tilde{\mathcal{M}}^{(n-1)}.
  \label{coll2}
\end{equation}
The function obtains a flag to indicate whether the limit to be computed
is also soft. Moreover, this consideration explains the structure of the
code. In the soft limit, we find $z \rightarrow 0$ as well as $\xi
\rightarrow 0$. However, the quantity $z/\xi$ is finite, because
\begin{equation*}
  \frac{z}{\xi} = \frac{p_{rad}^0}{\bar{p}_{em}^0} \frac{q^0}{2p_{em}^0} = \frac{q^0}{2\bar{p}^0_{em}}.
\end{equation*}
Thus, all expressions are written in terms of this well-behaved
quantity. Recalling that there is a prefactor of $(\xi^2z)^{-1}$, it is
necessary to expand with $z$ once.
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_fsr => coll_subtraction_compute_fsr
<<real subtraction: procedures>>=
  function coll_subtraction_compute_fsr &
     (coll_sub, sregion, p_res, p_born, sqme_born, sqme_born_sc, &
     xi, alpha_s, alr) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(in) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in) :: p_res
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born, sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr
    real(default) :: q0, z, p0
    real(default) :: z_o_xi, onemz
    real(default) :: pggz, pqgz
    integer :: nlegs, emitter
    integer :: flv_em, flv_rad

    if (.not. vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true., n_in = coll_sub%n_in)
       call msg_fatal ("Collinear subtraction, FSR: Phase space point &
          &must be in CMS")
    end if

    nlegs = size (sregion%flst_real%flst)
    emitter = sregion%emitter
    flv_rad = sregion%flst_real%flst(nlegs)
    flv_em = sregion%flst_real%flst(emitter)
    q0 = p_res**1
    p0 = p_res * p_born(emitter) / q0
    !!! Here, z corresponds to 1-z in the formulas of arXiv:1002.2581;
    !!! the integrand is symmetric under this variable change
    z_o_xi = q0 / (two * p0)
    z = xi * z_o_xi; onemz = one - z
    if (is_gluon(flv_em) .and. is_gluon(flv_rad)) then
       !!! Implementation of equation (\ref{coll1}). Note that an
       !!! additional factor $z$, so that in the last step, the whole
       !!! expression is divided by $z/\xi$.
       pggz = two * CA * (z**2 * onemz + z**2 / onemz + onemz)
       sqme = pggz * sqme_born - 4 * CA * z**2 * onemz * sqme_born_sc
       sqme = sqme / z_o_xi
    else if (is_quark(abs(flv_em)) .and. is_quark (abs(flv_rad))) then
       !!! Equation \ref{coll2}
       pqgz = TR * z * (one - two * z * onemz)
       sqme = pqgz * sqme_born + 4 * TR * z**2 * onemz * sqme_born_sc
       sqme = sqme / z_o_xi
    else if (is_quark (abs(flv_em)) .and. is_gluon (flv_rad)) then
       sqme = sqme_born * CF * (one + onemz**2) / z_o_xi
    else
       sqme = zero
    end if
    sqme = sqme / (p0**2 * onemz * z_o_xi)
    sqme = sqme * 4 * pi * alpha_s

  end function coll_subtraction_compute_fsr

@ %def coll_subtraction_compute_fsr
@ Here, $\xi = 0$ is already required.
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_soft_limit_fsr => coll_subtraction_compute_soft_limit_fsr
<<real subtraction: procedures>>=
  function coll_subtraction_compute_soft_limit_fsr &
       (coll_sub, sregion, p_res, p_born, sqme_born, &
        sqme_born_sc, xi, alpha_s, alr) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in) :: p_res
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in) :: sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr
    sqme = coll_sub%compute_fsr (sregion, p_res, p_born, sqme_born, &
       sqme_born_sc, xi, alpha_s, alr)
  end function coll_subtraction_compute_soft_limit_fsr

@ %def coll_subtraction_compute_soft_limit_fsr
@
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_isr => coll_subtraction_compute_isr
<<real subtraction: procedures>>=
  function coll_subtraction_compute_isr &
     (coll_sub, sregion, p_born, sqme_born, sqme_born_sc, &
     xi, alpha_s, alr, isr_mode) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(in) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born
    real(default), intent(in) :: sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr, isr_mode
    real(default) :: z, onemz
    real(default) :: p02
    integer :: flv_em, flv_rad
    integer :: nlegs

    if (vector_set_is_cms (p_born)) then
       call vector4_write_set (p_born, show_mass = .true., &
          check_conservation = .true.)
       call msg_fatal ("Collinear subtraction, ISR: Phase space point &
          &must be in lab frame")
    end if

    nlegs = size (sregion%flst_real%flst)
    flv_rad = sregion%flst_real%flst(nlegs)
    flv_em = sregion%flst_real%flst(isr_mode)
    !!! No need to pay attention to n_in = 1, because this case always has a
    !!! massive initial-state particle and thus no collinear divergence.
    p02 = p_born(1)%p(0) * p_born(2)%p(0) / two
    z = one - xi; onemz = xi

    if (is_quark(flv_em) .and. is_gluon(flv_rad)) then
       sqme = CF * (one + z**2) * sqme_born
    else if (is_gluon(flv_em) .and. is_quark (flv_rad)) then
       sqme = TR * (z**2 + onemz**2) * onemz * sqme_born
    else
       sqme = zero
    end if
    sqme = sqme * z / p02
    sqme = sqme * 4 * pi * alpha_s
  end function coll_subtraction_compute_isr

@ %def coll_subtraction_compute_isr
@
<<real subtraction: coll sub: TBP>>=
  procedure :: compute_soft_limit_isr => coll_subtraction_compute_soft_limit_isr
<<real subtraction: procedures>>=
  function coll_subtraction_compute_soft_limit_isr &
     (coll_sub, sregion, p_born, sqme_born, sqme_born_sc, &
      xi, alpha_s, alr, isr_mode) result (sqme)
    real(default) :: sqme
    class(coll_subtraction_t), intent(inout) :: coll_sub
    type(singular_region_t), intent(in) :: sregion
    type(vector4_t), intent(in), dimension(:) :: p_born
    real(default), intent(in) :: sqme_born, sqme_born_sc
    real(default), intent(in) :: xi, alpha_s
    integer, intent(in) :: alr, isr_mode
    sqme = coll_sub%compute_isr (sregion, p_born, sqme_born, sqme_born_sc, &
       zero, alpha_s, alr, isr_mode)
  end function coll_subtraction_compute_soft_limit_isr

@ %def coll_subtraction_compute_soft_limit_isr
@
<<real subtraction: coll sub: TBP>>=
  procedure :: final => coll_subtraction_final
<<real subtraction: procedures>>=
  subroutine coll_subtraction_final (sub_coll)
    class(coll_subtraction_t), intent(inout) :: sub_coll
  end subroutine coll_subtraction_final

@ %def coll_subtraction_final
@
\subsection{Real Subtraction}
<<real subtraction: public>>=
  public :: real_subtraction_t
<<real subtraction: types>>=
  type :: real_subtraction_t
    type(region_data_t), pointer :: reg_data => null ()
    type(pdf_data_t) :: pdf_data
    type(real_kinematics_t), pointer :: real_kinematics => null ()
    type(isr_kinematics_t), pointer :: isr_kinematics => null ()
    type(real_scales_t) :: scales
    integer :: current_alr = 0
    integer :: current_i_res = 0
    real(default), dimension(:,:), allocatable :: sqme_real_non_sub
    real(default), dimension(:), allocatable :: sqme_born
    real(default), dimension(:,:,:), allocatable :: sqme_born_cc
    complex(default), dimension(:), pointer :: sqme_born_sc => null ()
    type(soft_subtraction_t) :: sub_soft
    type(coll_subtraction_t) :: sub_coll
    logical, dimension(:), allocatable :: sc_required
    integer :: purpose = INTEGRATION
    logical :: radiation_active = .true.
    logical :: subtraction_active = .true.
    type(pdf_container_t), dimension(2) :: pdf_born, pdf_scaled, pdf_scaled_coll
    integer :: fixed_alr = 0
  contains
  <<real subtraction: real subtraction: TBP>>
  end type real_subtraction_t

@ %def real_subtraction_t
@ Initializer
<<real subtraction: real subtraction: TBP>>=
  procedure :: init => real_subtraction_init
<<real subtraction: procedures>>=
  subroutine real_subtraction_init (rsub, reg_data)
    class(real_subtraction_t), intent(inout), target :: rsub
    type(region_data_t), intent(in), target :: reg_data
    integer :: alr, i_uborn
    call msg_debug (D_SUBTRACTION, "real_subtraction_init")
    call msg_debug (D_SUBTRACTION, "n_in", reg_data%n_in)
    call msg_debug (D_SUBTRACTION, "nlegs_born", reg_data%n_legs_born)
    call msg_debug (D_SUBTRACTION, "nlegs_real", reg_data%n_legs_real)
    call msg_debug (D_SUBTRACTION, "reg_data%n_regions", reg_data%n_regions)

    if (debug2_active (D_SUBTRACTION))  call reg_data%write ()
    rsub%reg_data => reg_data
    allocate (rsub%sqme_born (reg_data%n_flv_born))
    rsub%sqme_born = zero
    allocate (rsub%sqme_born_cc (reg_data%n_legs_born, reg_data%n_legs_born, &
       reg_data%n_flv_born))
    allocate (rsub%sqme_real_non_sub (reg_data%n_flv_real, reg_data%n_phs))
    allocate (rsub%sc_required (reg_data%n_regions))
    do alr = 1, reg_data%n_regions
       i_uborn = reg_data%regions(alr)%uborn_index
       rsub%sc_required(alr) = &
          reg_data%flv_born(i_uborn)%count_particle (GLUON) > 0
    end do

    call rsub%sub_soft%init (reg_data)
    call rsub%sub_coll%init (reg_data%n_regions, reg_data%n_in)

    if (rsub%reg_data%n_in > 1 .and. any (rsub%reg_data%get_emitter_list () <= 2)) then
       call rsub%init_pdfs ()
    end if
  end subroutine real_subtraction_init

@ %def real_subtraction_init
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: init_pdfs => real_subtraction_init_pdfs
<<real subtraction: procedures>>=
  subroutine real_subtraction_init_pdfs (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    type(string_t) :: lhapdf_dir, lhapdf_file
    integer :: lhapdf_member
    call msg_debug (D_SUBTRACTION, "real_subtraction_init_pdfs")
    lhapdf_dir = ""
    lhapdf_file = ""
    lhapdf_member = 0
    if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
          (1, lhapdf_dir, lhapdf_file, lhapdf_member, rsub%pdf_data%pdf)
       associate (pdf_data => rsub%pdf_data)
          pdf_data%type = STRF_LHAPDF6
          pdf_data%xmin = pdf_data%pdf%getxmin ()
          pdf_data%xmax = pdf_data%pdf%getxmax ()
          pdf_data%qmin = sqrt (pdf_data%pdf%getq2min ())
          pdf_data%qmax = sqrt (pdf_data%pdf%getq2max ())
       end associate
    else
       call msg_fatal ("Real subtraction: PDF method must be LHAPDF6")
    end if
  end subroutine real_subtraction_init_pdfs

@ %def real_subtraction_init_pdfs
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_resonance_mappings => real_subtraction_set_resonance_mappings
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_resonance_mappings (rsub, use_mappings)
    class(real_subtraction_t), intent(inout) :: rsub
    logical, intent(in) :: use_mappings
    rsub%sub_soft%use_resonance_mappings = use_mappings
    rsub%sub_coll%use_resonance_mappings = use_mappings
  end subroutine real_subtraction_set_resonance_mappings

@ %def real_subtraction_set_resonance_mappings
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_real_kinematics => real_subtraction_set_real_kinematics
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_real_kinematics (rsub, real_kinematics)
    class(real_subtraction_t), intent(inout) :: rsub
    type(real_kinematics_t), intent(in), target :: real_kinematics
    rsub%real_kinematics => real_kinematics
  end subroutine real_subtraction_set_real_kinematics

@ %def real_subtraction_set_real_kinematics
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_isr_kinematics => real_subtraction_set_isr_kinematics
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_isr_kinematics (rsub, fractions)
    class(real_subtraction_t), intent(inout) :: rsub
    type(isr_kinematics_t), intent(in), target :: fractions
    rsub%isr_kinematics => fractions
  end subroutine real_subtraction_set_isr_kinematics

@ %def real_subtraction_set_isr_kinematics
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_alr => real_subtraction_set_alr
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_alr (rsub, alr)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr
    rsub%current_alr = alr
  end subroutine real_subtraction_set_alr

@ %def real_subtraction_set_alr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: set_i_res => real_subtraction_set_i_res
<<real subtraction: procedures>>=
  subroutine real_subtraction_set_i_res (rsub, alr)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: alr
    select type (fks_mapping => rsub%reg_data%fks_mapping)
    type is (fks_mapping_resonances_t)
       rsub%current_i_res = fks_mapping%res_map%alr_to_i_res (alr)
    class default
       rsub%current_i_res = 0
    end select
  end subroutine real_subtraction_set_i_res

@ %def real_subtraction_set_i_res
@\subsection{The real contribution to the cross section}
In each singular region $\alpha$, the real contribution to $\sigma$ is
given by the second summand of eqn. \ref{fks: sub: complete},
\begin{equation}
  \sigma^\alpha_{\text{real}} = \int d\Phi_n \int_0^{2\pi} d\phi
  \int_{-1}^1 dy \int_0^{\xi_{\text{max}}} d\xi
  \left(\frac{1}{\xi}\right)_+ \left(\frac{1}{1-y}\right)_+
  \underbrace{\frac{J(\Phi_n, \xi, y, \phi)}{\xi}
    \left[(1-y)\xi^2\mathcal{R}^\alpha(\Phi_{n+1})\right]}_{g^\alpha(\xi,y)}.
\end{equation}
Writing out the plus-distribution and introducing $\tilde{\xi} =
\xi/\xi_{\text{max}}$ to set the upper integration limit to 1,  this
turns out to be equal to
\begin{equation}
  \begin{split}
    \sigma^\alpha_{\rm{real}} &= \int d\Phi_n \int_0^{2/pi}d\phi
    \int_{-1}^1 \frac{dy}{1-y} \Bigg\{\int_0^1
    d\tilde{\xi}\Bigg[\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},y)}{\tilde{\xi}}
    - \underbrace{\frac{g^\alpha(0,y)}{\tilde{\xi}}}_{\text{soft}} -
    \underbrace{\frac{g^\alpha(\tilde{\xi}\xi_{\rm{max}},1)}{\tilde{\xi}}}_{\text{coll.}}
    +
    \underbrace{\frac{g^\alpha(0,1)}{\tilde{\xi}}}_{\text{coll.+soft}}\Bigg]
    \\
&+ \left[\log\xi_{\rm{max}}(y)g^\alpha(0,y) - \log\xi_{\rm{max}}(1)g^\alpha(0,1)\right]\Bigg\}.
  \end{split}
\end{equation}
This formula is implemented in \texttt{compute\_sqme\_real\_fin}
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute => real_subtraction_compute
<<real subtraction: procedures>>=
  function real_subtraction_compute (rsub, emitter, i_phs, alpha_s) result (sqme)
    real(default) :: sqme
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default) :: sqme_alr, alpha_s
    integer :: alr, i_con
    logical :: same_emitter
    sqme = zero
    do alr = 1, rsub%reg_data%n_regions
       if (rsub%fixed_alr > 0 .and. rsub%fixed_alr /= alr) cycle
       sqme_alr = zero
       if (emitter > rsub%isr_kinematics%n_in) then
          same_emitter = emitter == rsub%reg_data%regions(alr)%emitter
       else
          same_emitter = rsub%reg_data%regions(alr)%emitter <= rsub%isr_kinematics%n_in
       end if
       if (same_emitter .and. i_phs == rsub%real_kinematics%alr_to_i_phs (alr)) then
          call rsub%set_alr (alr)
          call rsub%set_i_res (alr)
          sqme_alr = rsub%evaluate_emitter_region (rsub%reg_data%regions(alr)%emitter, &
               i_phs, alpha_s)
          i_con = rsub%get_i_contributor (alr)
          if (rsub%purpose == INTEGRATION .or. rsub%purpose == FIXED_ORDER_EVENTS) &
             sqme_alr = sqme_alr * rsub%get_phs_factor (i_con)
       end if
       sqme = sqme + sqme_alr
    end do
  end function real_subtraction_compute

@ %def real_subtraction_compute
@ The emitter is fixed. We now have to decide whether we evaluate in ISR or FSR
region, and also if resonances are used.
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_emitter_region => real_subtraction_evaluate_emitter_region
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_emitter_region (rsub, emitter, i_phs, alpha_s) &
     result (sqme)
    real(default) :: sqme
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    if (emitter <= rsub%isr_kinematics%n_in) then
       sqme = rsub%evaluate_region_isr (emitter, i_phs, alpha_s)
    else
       select type (fks_mapping => rsub%reg_data%fks_mapping)
       type is (fks_mapping_resonances_t)
          call fks_mapping%set_resonance_momenta &
             (rsub%real_kinematics%xi_ref_momenta )
          sqme = rsub%evaluate_region_fsr (emitter, i_phs, alpha_s)
       class default
          sqme = rsub%evaluate_region_fsr (emitter, i_phs, alpha_s)
       end select
    end if
  end function real_subtraction_evaluate_emitter_region

@ %def real_subtraction_evaluate_emitter_region
@ This subroutine computes the finite part of the real matrix element in
an individual singular region.
First, the radiation variables are fetched and $\mathcal{R}$ is
multiplied by the appropriate $S_\alpha$-factors,
region multiplicities and double-FSR factors.
Then, it computes the soft, collinear, soft-collinear and remnant matrix
elements and supplies the corresponding factor $1/\xi/(1-y)$ as well as
the corresponding jacobians.
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_fsr => real_subtraction_evaluate_region_fsr
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_region_fsr (rsub, emitter, i_phs, &
     alpha_s) result (sqme_tot)
    real(default) :: sqme_tot
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default) :: sqme_rad, sqme_soft, sqme_coll, sqme_cs, sqme_remn
    sqme_rad = zero; sqme_soft = zero; sqme_coll = zero
    sqme_cs = zero; sqme_remn = zero
    associate (region => rsub%reg_data%regions(rsub%current_alr))
      if (rsub%radiation_active) then
         sqme_rad = rsub%sqme_real_non_sub (1, i_phs)
         call evaluate_fks_factors (sqme_rad, rsub%reg_data, rsub%real_kinematics, &
              rsub%current_alr, i_phs, emitter, rsub%current_i_res)
         call apply_kinematic_factors_radiation (sqme_rad, rsub%purpose, &
              rsub%real_kinematics, i_phs, .false.)
      end if
      if (rsub%subtraction_active) then
         call rsub%evaluate_subtraction_terms_fsr (emitter, i_phs, alpha_s, &
            sqme_soft, sqme_coll, sqme_cs)
         call apply_kinematic_factors_subtraction_fsr (sqme_soft, sqme_coll, sqme_cs, &
            rsub%real_kinematics, i_phs)
         sqme_remn = compute_sqme_remnant_fsr (sqme_soft, sqme_cs, rsub%real_kinematics, i_phs)
         select case (rsub%purpose)
         case (INTEGRATION)
            sqme_tot = sqme_rad - sqme_soft - sqme_coll + sqme_cs + sqme_remn
         case (FIXED_ORDER_EVENTS)
            sqme_tot = - sqme_soft - sqme_coll + sqme_cs + sqme_remn
         case default
            sqme_tot = zero
            call msg_bug ("real_subtraction_evaluate_region_fsr: " // &
                 "Undefined rsub%purpose")
         end select
      else
         sqme_tot = sqme_rad
      end if
      sqme_tot = sqme_tot * rsub%real_kinematics%jac_rand(i_phs)
    end associate

    call debug_output ()

  contains

    subroutine debug_output ()
       logical :: print_all, soft, collinear
       type(vector4_t) :: p_gluon
       integer, save :: n_soft = 0, passed_soft = 0, n_coll = 0, passed_coll = 0
       logical :: write_histo = .true.
       if (debug_active (D_SUBTRACTION)) then
          print_all = debug2_active (D_SUBTRACTION)
          if (print_all) then
             call msg_debug2 (D_SUBTRACTION, "real_subtraction_evaluate_region_fsr")
             call write_computation_status ()
          else
             associate (p_real => rsub%real_kinematics%p_real_cms)
                p_gluon = p_real%get_momentum (i_phs, p_real%get_n_momenta (i_phs))
                soft = p_gluon%p(0) < 0.1_default
             end associate
             collinear = abs (rsub%real_kinematics%y (i_phs)- one) < 0.01_default
             if (soft) then
                if (write_histo)  call write_point_to_file (p_gluon%p(0), sqme_rad, sqme_soft)
                n_soft = n_soft + 1
                if (sqme_soft < zero)  call msg_warning ("Soft < 0")
                if (abs (sqme_rad - sqme_soft) > sqme_rad .and. sqme_soft > tiny_10 &
                   .and. sqme_rad > tiny_10) then
                   call msg_warning ("Soft MEs do not match in this soft region")
                   call write_computation_status (passed_soft, n_soft, "soft")
                else
                   passed_soft = passed_soft + 1
                end if
             end if
             if (collinear) then
                n_coll = n_coll + 1
                if (abs (sqme_rad - sqme_coll) > sqme_rad .and. &
                   sqme_coll > tiny_10 .and. sqme_rad > tiny_10) then
                   call msg_warning ("Collinear MEs do not match in this collinear region")
                   call write_computation_status (passed_coll, n_coll, "collinear")
                else
                   passed_coll = passed_coll + 1
                end if
             end if
          end if
       end if
    end subroutine debug_output

    subroutine write_computation_status (passed, total, region_type)
       integer, intent(in), optional :: passed, total
       character(*), intent(in), optional :: region_type
       integer :: i_uborn
       integer :: u
       real(default) :: xi
       u = given_output_unit (); if (u < 0) return
       i_uborn = rsub%reg_data%regions(rsub%current_alr)%uborn_index
       xi = rsub%real_kinematics%xi_max (i_phs) * rsub%real_kinematics%xi_tilde
       write (u,'(A,I2)') 'rsub%purpose: ', rsub%purpose
       write (u,'(A,I3)') 'alr: ', rsub%current_alr
       write (u,'(A,I3)') 'emitter: ', emitter
       write (u,'(A,I3)') 'i_phs: ', i_phs
       write (u,'(A,F6.4)') 'xi_max: ', rsub%real_kinematics%xi_max (i_phs)
       write (u,'(A,F6.4,2X,A,F6.4)') 'xi: ', xi, 'y: ', rsub%real_kinematics%y (i_phs)
       write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_uborn)
       write (u,'(A,ES16.9)')  'sqme_real: ', sqme_rad
       write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
       write (u,'(A,ES16.9)')  'sqme_coll: ', sqme_coll
       write (u,'(A,ES16.9)')  'sqme_coll-soft: ', sqme_cs
       write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
       write (u,'(A,ES16.9)')  'sqme_tot: ', sqme_tot
       if (present (passed) .and. present (total) .and. &
            present (region_type)) &
          write (u,'(A)') char (str (passed) // " of " // str (total) // &
               " " // region_type // " points passed in total")
    end subroutine write_computation_status

    subroutine write_point_to_file (E_gluon, sqme_rad, sqme_soft)
      real(default), intent(in) :: E_gluon, sqme_rad, sqme_soft
      integer, save :: funit = 0
      type(string_t) :: filename
      filename = var_str ("soft.log")
      if (funit == 0) then
         funit = free_unit ()
         open (funit, file=char(filename), action = "write", status="replace")
         write (funit, "(A,5X,A,5X,A)") "# E_gluon", "Real", "Soft Approx"
      end if
      write (funit,'(3(ES16.9,1X))') E_gluon, sqme_rad, sqme_soft
    end subroutine write_point_to_file

  end function real_subtraction_evaluate_region_fsr

@ %def real_subtraction_evalute_region_fsr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_region_isr => real_subtraction_evaluate_region_isr
<<real subtraction: procedures>>=
  function real_subtraction_evaluate_region_isr (rsub, emitter, i_phs, alpha_s) &
     result (sqme_tot)
    real(default) :: sqme_tot
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    integer :: i_real
    real(default) :: sqme_rad, sqme_soft, sqme_coll_plus, sqme_coll_minus
    real(default) :: sqme_cs_plus, sqme_cs_minus
    real(default) :: sqme_remn
    real(default) :: onemy, onepy
    logical :: proc_scatter

    proc_scatter = rsub%isr_kinematics%n_in == 2

    sqme_rad = zero; sqme_soft = zero;
    sqme_coll_plus = zero; sqme_coll_minus = zero
    sqme_cs_plus = zero; sqme_cs_minus = zero
    sqme_remn = zero

    if (proc_scatter) call rsub%compute_pdfs ()
    associate (region => rsub%reg_data%regions(rsub%current_alr))
      i_real = region%real_index
      if (rsub%radiation_active) then
         sqme_rad = rsub%sqme_real_non_sub (1, i_phs)
         call evaluate_fks_factors (sqme_rad, rsub%reg_data, rsub%real_kinematics, &
            rsub%current_alr, i_phs, emitter, rsub%current_i_res)
         if (proc_scatter) then
            call rsub%scale_pdfs_real (sqme_rad, i_real, I_PLUS)
            call rsub%scale_pdfs_real (sqme_rad, i_real, I_MINUS)
         end if

         call apply_kinematic_factors_radiation (sqme_rad, rsub%purpose, rsub%real_kinematics, &
            i_phs, .true.)
      end if
      if (rsub%subtraction_active) then
         call rsub%evaluate_subtraction_terms_isr (emitter, i_phs, alpha_s, &
            sqme_soft, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, sqme_cs_minus)
         if (proc_scatter) then
            call rsub%scale_pdfs_collinear (sqme_coll_plus, i_real, &
               region%uborn_index, I_PLUS)
            call rsub%scale_pdfs_collinear (sqme_coll_minus, i_real, &
               region%uborn_index, I_MINUS)
         end if
         call apply_kinematic_factors_subtraction_isr (sqme_soft, sqme_coll_plus, &
            sqme_coll_minus, sqme_cs_plus, sqme_cs_minus, rsub%real_kinematics, i_phs)
         sqme_remn = compute_sqme_remnant_isr (proc_scatter, sqme_soft, sqme_cs_plus, &
            sqme_cs_minus, rsub%isr_kinematics, rsub%real_kinematics, i_phs)

         sqme_tot = sqme_rad - sqme_soft - sqme_coll_plus - sqme_coll_minus &
              + sqme_cs_plus + sqme_cs_minus + sqme_remn
      else
         sqme_tot = sqme_rad
      end if
    end associate

    sqme_tot = sqme_tot * rsub%real_kinematics%jac_rand (i_phs)

    call debug_output ()

  contains

    subroutine debug_output ()
       logical :: soft, collinear
       type(vector4_t) :: p_gluon
       if (debug_active (D_SUBTRACTION)) then
          call msg_debug2 (D_SUBTRACTION, "real_subtraction_evaluate_region_isr")
          if (debug2_active (D_SUBTRACTION)) then
             call write_computation_status ()
          else
             associate (p_real => rsub%real_kinematics%p_real_cms)
                p_gluon = p_real%get_momentum (i_phs, p_real%get_n_momenta (i_phs))
                soft = p_gluon%p(0) < 2.0_default
             end associate
             collinear = abs (rsub%real_kinematics%y (i_phs) - one) < 0.01_default
             if (soft) then
                if (abs (sqme_rad - sqme_soft) > sqme_rad .and. sqme_soft > tiny_10) then
                   call msg_warning ("Soft MEs do not match in soft region")
                   call write_computation_status ()
                end if
             end if
             ! TODO: (bcn 2016-01-13) check coll_plus and coll_minus
             !if (collinear) then
                !if (abs (sqme_rad - sqme_coll) > sqme_rad .and. sqme_coll > tiny_10) then
                   !call msg_warning ("Collinear MEs do not match in collinear region")
                   !call write_computation_status ()
                !end if
             !end if
          end if
       end if
    end subroutine debug_output

    subroutine write_computation_status (unit)
       integer, intent(in), optional :: unit
       integer :: i_uborn
       integer :: u
       real(default) :: xi
       u = given_output_unit (unit); if (u < 0) return
       i_uborn = rsub%reg_data%regions(rsub%current_alr)%uborn_index
       xi = rsub%real_kinematics%xi_max (i_phs) * rsub%real_kinematics%xi_tilde
       write (u,'(A,I2)') 'alr: ', rsub%current_alr
       write (u,'(A,I2)') 'emitter: ', emitter
       write (u,'(A,F4.2)') 'xi_max: ', rsub%real_kinematics%xi_max (i_phs)
       print *, 'xi: ', xi, 'y: ', rsub%real_kinematics%y (i_phs)
       print *, 'xb1: ', rsub%isr_kinematics%x(1), 'xb2: ', rsub%isr_kinematics%x(2)
       print *, 'random jacobian: ', rsub%real_kinematics%jac_rand (i_phs)
       write (u,'(A,ES16.9)')  'sqme_born: ', rsub%sqme_born(i_uborn)
       write (u,'(A,ES16.9)')  'sqme_real: ', sqme_rad
       write (u,'(A,ES16.9)')  'sqme_soft: ', sqme_soft
       write (u,'(A,ES16.9)')  'sqme_coll_plus: ', sqme_coll_plus
       write (u,'(A,ES16.9)')  'sqme_coll_minus: ', sqme_coll_minus
       write (u,'(A,ES16.9)')  'sqme_cs_plus: ', sqme_cs_plus
       write (u,'(A,ES16.9)')  'sqme_cs_minus: ', sqme_cs_minus
       write (u,'(A,ES16.9)')  'sqme_remn: ', sqme_remn
       write (u,'(A,ES16.9)')  'sqme_tot: ', sqme_tot
    end subroutine write_computation_status

  end function real_subtraction_evaluate_region_isr

@ %def real_subtraction_evaluate_region_isr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_fsr => &
       real_subtraction_evaluate_subtraction_terms_fsr
<<real subtraction: procedures>>=
  subroutine real_subtraction_evaluate_subtraction_terms_fsr (rsub, &
     emitter, i_phs, alpha_s, sqme_soft, sqme_coll, sqme_cs)
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default), intent(out) :: sqme_soft, sqme_coll, sqme_cs
    sqme_soft = rsub%compute_sub_soft (emitter, i_phs, alpha_s)
    sqme_coll = rsub%compute_sub_coll (emitter, i_phs, alpha_s)
    sqme_cs = rsub%compute_sub_coll_soft (emitter, alpha_s)
  end subroutine real_subtraction_evaluate_subtraction_terms_fsr

@ %def real_subtraction_evaluate_subtraction_terms_fsr
@
<<real subtraction: procedures>>=
  subroutine evaluate_fks_factors &
     (sqme, reg_data, real_kinematics, alr, i_phs, emitter, i_res)
    real(default), intent(inout) :: sqme
    type(region_data_t), intent(inout) :: reg_data
    type(real_kinematics_t), intent(in), target :: real_kinematics
    integer, intent(in) :: alr, i_phs, emitter, i_res
    real(default) :: s_alpha
    type(phs_point_set_t), pointer :: p_real => null ()
    if (reg_data%has_pseudo_isr ()) then
       p_real => real_kinematics%p_real_onshell
    else
       p_real => real_kinematics%p_real_cms
    end if
    s_alpha = reg_data%get_svalue (p_real%get_momenta(i_phs),  alr, emitter, i_res)
    if (debug2_active (D_SUBTRACTION)) call msg_print_color('s_alpha', s_alpha, COL_YELLOW)
    sqme = sqme * s_alpha
    associate (region => reg_data%regions(alr))
       sqme = sqme * region%mult
       if (emitter > reg_data%n_in) &
          sqme = sqme * region%double_fsr_factor (p_real%get_momenta(i_phs))
    end associate
  end subroutine evaluate_fks_factors

@ %def evaluate_fks_factors
@
<<real subtraction: procedures>>=
  subroutine apply_kinematic_factors_radiation (sqme, purpose, real_kinematics, i_phs, isr)
    real(default), intent(inout) :: sqme
    integer, intent(in) :: purpose
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    logical, intent(in) :: isr
    real(default) :: xi, xi_tilde, s
    xi_tilde = real_kinematics%xi_tilde
    xi = xi_tilde * real_kinematics%xi_max (i_phs)
    select case (purpose)
    case (INTEGRATION, FIXED_ORDER_EVENTS)
       sqme = sqme * xi**2 / xi_tilde * real_kinematics%jac(i_phs)%jac(1)
    case (POWHEG)
       if (.not. isr) then
          s = real_kinematics%cms_energy2
          sqme = sqme * real_kinematics%jac(i_phs)%jac(1) * s / (8 * twopi3) * xi
       else
          call msg_fatal ("POWHEG with initial-state radiation not implemented yet")
       end if
    end select
  end subroutine apply_kinematic_factors_radiation

@ %def apply_kinematics_factors_radiation
@
<<real subtraction: procedures>>=
  subroutine apply_kinematic_factors_subtraction_fsr &
     (sqme_soft, sqme_coll, sqme_cs, real_kinematics, i_phs)
    real(default), intent(inout) :: sqme_soft, sqme_coll, sqme_cs
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi_tilde, onemy
    xi_tilde = real_kinematics%xi_tilde
    onemy = one - real_kinematics%y(i_phs)
    sqme_soft = sqme_soft / onemy / xi_tilde
    sqme_coll = sqme_coll / onemy / xi_tilde
    sqme_cs = sqme_cs / onemy / xi_tilde
    associate (jac => real_kinematics%jac(i_phs)%jac)
       sqme_soft = sqme_soft * jac(2)
       sqme_coll = sqme_coll * jac(3)
       sqme_cs = sqme_cs * jac(2)
    end associate
  end subroutine apply_kinematic_factors_subtraction_fsr

@ %def apply_kinematic_factors_subtraction_fsr
@ For final state radiation, the subtraction remnant cross section is
\begin{equation}
  \sigma_{\text{remn}} = \left(\sigma_{\text{soft}} - \sigma_{\text{coll}}\right)
      \log\xi_{\text{max}} \cdot \tilde{\xi}.
\end{equation}
<<real subtraction: procedures>>=
  function compute_sqme_remnant_fsr (sqme_soft, sqme_cs, &
     real_kinematics, i_phs) result (sqme_remn)
    real(default) :: sqme_remn
    real(default), intent(in) :: sqme_soft, sqme_cs
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    sqme_remn = (sqme_soft - sqme_cs) * &
       log (real_kinematics%xi_max (i_phs)) * real_kinematics%xi_tilde
  end function compute_sqme_remnant_fsr

@ %def compute_sqme_remnant_fsr
@
<<real subtraction: procedures>>=
  subroutine apply_kinematic_factors_subtraction_isr &
     (sqme_soft, sqme_coll_plus, sqme_coll_minus, sqme_cs_plus, &
      sqme_cs_minus, real_kinematics, i_phs)
    real(default), intent(inout) :: sqme_soft, sqme_coll_plus, sqme_coll_minus
    real(default), intent(inout) :: sqme_cs_plus, sqme_cs_minus
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi_tilde, y, onemy, onepy
    xi_tilde = real_kinematics%xi_tilde
    y = real_kinematics%y (i_phs)
    onemy = one - y; onepy = one + y
    associate (jac => real_kinematics%jac(i_phs)%jac)
       sqme_soft = sqme_soft / (one - y**2) / xi_tilde * jac(2)
       sqme_coll_plus = sqme_coll_plus / onemy / xi_tilde / two * jac(3)
       sqme_coll_minus = sqme_coll_minus / onepy / xi_tilde / two * jac(4)
       sqme_cs_plus = sqme_cs_plus / onemy / xi_tilde / two * jac(2)
       sqme_cs_minus = sqme_cs_minus / onepy / xi_tilde / two * jac(2)
    end associate
  end subroutine apply_kinematic_factors_subtraction_isr

@ %def apply_kinematic_factors_subtraction_isr
@
<<real subtraction: procedures>>=
  function compute_sqme_remnant_isr (proc_scatter, sqme_soft, sqme_cs_plus, sqme_cs_minus, &
     isr_kinematics, real_kinematics, i_phs) result (sqme_remn)
    real(default) :: sqme_remn
    logical, intent(in) :: proc_scatter
    real(default), intent(in) :: sqme_soft, sqme_cs_plus, sqme_cs_minus
    type(isr_kinematics_t), intent(in) :: isr_kinematics
    type(real_kinematics_t), intent(in) :: real_kinematics
    integer, intent(in) :: i_phs
    real(default) :: xi_tilde, xi_max, xi_max_plus, xi_max_minus
    xi_max = real_kinematics%xi_max (i_phs)
    if (proc_scatter) then
       xi_max_plus = one - isr_kinematics%x(I_PLUS)
       xi_max_minus = one - isr_kinematics%x(I_MINUS)
    else
       xi_max_plus = real_kinematics%xi_max (i_phs)
       xi_max_minus = real_kinematics%xi_max (i_phs)
    end if
    xi_tilde = real_kinematics%xi_tilde
    sqme_remn = log(xi_max) * xi_tilde * sqme_soft
    sqme_remn = sqme_remn - log (xi_max_plus) * xi_tilde * sqme_cs_plus &
                          - log (xi_max_minus) * xi_tilde * sqme_cs_minus
  end function compute_sqme_remnant_isr

@ %def compute_sqme_remnant_isr
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: evaluate_subtraction_terms_isr => &
      real_subtraction_evaluate_subtraction_terms_isr
<<real subtraction: procedures>>=
  subroutine real_subtraction_evaluate_subtraction_terms_isr (rsub, &
    emitter, i_phs, alpha_s, sqme_soft, sqme_coll_plus, sqme_coll_minus, &
    sqme_cs_plus, sqme_cs_minus)

    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    real(default), intent(out) :: sqme_soft
    real(default), intent(out) :: sqme_coll_plus, sqme_coll_minus
    real(default), intent(out) :: sqme_cs_plus, sqme_cs_minus
    sqme_soft = rsub%compute_sub_soft (emitter, i_phs, alpha_s)
    if (emitter /= 2) then
       sqme_coll_plus = rsub%compute_sub_coll (1, i_phs, alpha_s)
       sqme_cs_plus = rsub%compute_sub_coll_soft (1, alpha_s)
    else
       sqme_coll_plus = zero
       sqme_cs_plus = zero
    end if
    if (emitter /= 1) then
       sqme_coll_minus = rsub%compute_sub_coll (2, i_phs, alpha_s)
       sqme_cs_minus = rsub%compute_sub_coll_soft (2, alpha_s)
    else
       sqme_coll_minus = zero
       sqme_cs_minus = zero
    end if
  end subroutine real_subtraction_evaluate_subtraction_terms_isr

@ %def real_subtraction_evaluate_subtraction_terms_isr
@ This is basically the part of the real jacobian corresponding to
\begin{equation*}
  \frac{q^2}{8 (2\pi)^3}.
\end{equation*}
We interpret it as the additional phase space factor of the real component,
to be more consistent with the evaluation of the Born phase space.
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_phs_factor => real_subtraction_get_phs_factor
<<real subtraction: procedures>>=
  function real_subtraction_get_phs_factor (rsub, i_con) result (factor)
    real(default) :: factor
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: i_con
    real(default) :: s
    s = rsub%real_kinematics%xi_ref_momenta (i_con)**2
    factor = s / (8 * twopi3)
  end function real_subtraction_get_phs_factor

@ %def real_subtraction_get_phs_factor
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_i_contributor => real_subtraction_get_i_contributor
<<real subtraction: procedures>>=
  function real_subtraction_get_i_contributor (rsub, alr) result (i_con)
    integer :: i_con
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr
    if (allocated (rsub%reg_data%alr_to_i_contributor)) then
       i_con = rsub%reg_data%alr_to_i_contributor (alr)
    else
       i_con = 1
    end if
  end function real_subtraction_get_i_contributor

@ %def real_subtraction_get_i_contributor
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_soft => real_subtraction_compute_sub_soft
<<real subtraction: procedures>>=
  function real_subtraction_compute_sub_soft (rsub, emitter, &
     i_phs, alpha_s) result (sqme_soft)
    real(default) :: sqme_soft
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: emitter, i_phs
    real(default), intent(in) :: alpha_s
    integer :: alr, i_con, i_uborn
    real(default) :: q2

    alr = rsub%current_alr
       associate (real_kinematics => rsub%real_kinematics)
       if (rsub%reg_data%regions(alr)%has_soft_divergence ()) then
          if (rsub%sub_soft%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          q2 = real_kinematics%xi_ref_momenta (i_con)**2
          if (emitter > rsub%sub_soft%reg_data%n_in) then
             call rsub%sub_soft%create_softvec_fsr &
                (real_kinematics%p_born_cms%get_momenta(1), &
                real_kinematics%y_soft (i_phs), &
                real_kinematics%phi, emitter, &
                real_kinematics%xi_ref_momenta(i_con))
          else
             call rsub%sub_soft%create_softvec_isr &
                (real_kinematics%y_soft(i_phs), real_kinematics%phi)
          end if
          i_uborn = rsub%reg_data%regions(alr)%uborn_index
          sqme_soft = rsub%sub_soft%compute &
             (real_kinematics%p_born_cms%get_momenta(1), &
             rsub%sqme_born_cc(:,:,i_uborn), real_kinematics%y(i_phs), &
             q2, alpha_s, alr, emitter, rsub%current_i_res)
       else
          sqme_soft = zero
       end if
    end associate
  end function real_subtraction_compute_sub_soft

@ %def real_subtraction_compute_sub_soft
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: get_sc_matrix_element => real_subtraction_get_sc_matrix_element
<<real subtraction: procedures>>=
  function real_subtraction_get_sc_matrix_element (rsub, alr, em, uborn_index) result (sqme_sc)
    class(real_subtraction_t), intent(in) :: rsub
    integer, intent(in) :: alr, em, uborn_index
    real(default) :: sqme_sc
    complex(default) :: prod1, prod2

    if (rsub%sc_required(alr)) then
       associate (p => rsub%real_kinematics%p_real_cms%phs_point(1)%p)
          call spinor_product (p(em), p(rsub%reg_data%n_legs_real), prod1, prod2)
       end associate
       sqme_sc = real (prod1 / prod2 * rsub%sqme_born_sc(uborn_index))
    else
       sqme_sc = zero
    end if
  end function real_subtraction_get_sc_matrix_element

@ %def real_subtraction_get_sc_matrix_element
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll => real_subtraction_compute_sub_coll
<<real subtraction: procedures>>=
  function real_subtraction_compute_sub_coll (rsub, em, i_phs, alpha_s) result (sqme_coll)
    real(default) :: sqme_coll
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: em, i_phs
    real(default), intent(in) :: alpha_s
    real(default) :: xi, xi_max, xi_max_pm
    real(default) :: sqme_sc
    integer :: alr, i_con
    alr = rsub%current_alr
    associate (sregion => rsub%reg_data%regions(alr))
       if (sregion%has_collinear_divergence ()) then
          xi = rsub%real_kinematics%xi_tilde * rsub%real_kinematics%xi_max (i_phs)
          if (rsub%sub_coll%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          sqme_sc = rsub%get_sc_matrix_element (alr, em, sregion%uborn_index)
          if (em <= rsub%sub_coll%n_in) then
             xi_max_pm = one - rsub%isr_kinematics%x(em)
             xi = rsub%real_kinematics%xi_tilde * xi_max_pm
             sqme_coll = rsub%sub_coll%compute_isr (sregion, &
                rsub%real_kinematics%p_born_lab%phs_point(1)%p, &
                rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr, em)
          else
             sqme_coll = rsub%sub_coll%compute_fsr (sregion, &
                  rsub%real_kinematics%xi_ref_momenta (i_con), &
                  rsub%real_kinematics%p_born_cms%get_momenta(1), &
                  rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr)
          end if
       else
          sqme_coll = zero
       end if
    end associate
  end function real_subtraction_compute_sub_coll

@ %def real_subtraction_compute_sub_coll
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_sub_coll_soft => real_subtraction_compute_sub_coll_soft
<<real subtraction: procedures>>=
  function real_subtraction_compute_sub_coll_soft (rsub, em, alpha_s) result (sqme_cs)
    real(default) :: sqme_cs
    class(real_subtraction_t), intent(inout) :: rsub
    integer, intent(in) :: em
    real(default), intent(in) :: alpha_s
    real(default) :: sqme_sc
    real(default) :: xi
    integer :: alr, i_con
    alr = rsub%current_alr
    xi = zero
    associate (sregion => rsub%reg_data%regions(alr))
       if (sregion%has_collinear_divergence ()) then
          if (rsub%sub_coll%use_resonance_mappings) then
             i_con = rsub%reg_data%alr_to_i_contributor (alr)
          else
             i_con = 1
          end if
          sqme_sc = rsub%get_sc_matrix_element (alr, em, sregion%uborn_index)
          if (em <= rsub%sub_coll%n_in) then
             sqme_cs = rsub%sub_coll%compute_soft_limit_isr (sregion, &
                rsub%real_kinematics%p_born_lab%phs_point(1)%p, &
                rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr, em)
          else
             sqme_cs = rsub%sub_coll%compute_soft_limit_fsr &
                (sregion, rsub%real_kinematics%xi_ref_momenta(i_con), &
                rsub%real_kinematics%p_born_cms%phs_point(1)%p, &
                rsub%sqme_born(sregion%uborn_index), sqme_sc, xi, alpha_s, alr)
          end if
       else
          sqme_cs = zero
       end if
    end associate
  end function real_subtraction_compute_sub_coll_soft

@ %def real_subtraction_compute_sub_coll_soft
@ Gets the pdf value from the [[pdf_data]] object. Note that LHAPDF
delivers $x \cdot f(x)$ as output, so that $x$ has to be factored out.
<<real subtraction: real subtraction: TBP>>=
  procedure :: compute_pdfs => real_subtraction_compute_pdfs
<<real subtraction: procedures>>=
  subroutine real_subtraction_compute_pdfs (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    integer :: i
    real(default) :: z, z_coll, x, Q
    real(default) :: x_scaled, x_scaled_coll
    real(double), dimension(-6:6) :: f_dble = 0._double
    Q = rsub%isr_kinematics%fac_scale
    do i = 1, 2
       x = rsub%isr_kinematics%x(i)
       z = rsub%isr_kinematics%z(i)
       z_coll = rsub%isr_kinematics%z_coll(i)
       x_scaled = x * z
       x_scaled_coll = x * z_coll
       call rsub%pdf_data%evolve (dble(x), dble(Q), f_dble)
       rsub%pdf_born(i)%f = f_dble / dble(x)
       call rsub%pdf_data%evolve (dble(x_scaled), dble(Q), f_dble)
       rsub%pdf_scaled(i)%f = f_dble / dble(x_scaled)
       call rsub%pdf_data%evolve (dble(x_scaled_coll), dble(Q), f_dble)
       rsub%pdf_scaled_coll(i)%f = f_dble / dble(x_scaled_coll)
    end do
  end subroutine real_subtraction_compute_pdfs

@ %def real_subtraction_compute_pdfs
@ The real matrix element is evaluated already multiplied with the parton densities
at Born level, but with the real flavor structure. We multiply out the Born
contribution and use the real one instead.
<<real subtraction: real subtraction: TBP>>=
  procedure :: scale_pdfs_real => real_subtraction_scale_pdfs_real
<<real subtraction: procedures>>=
  subroutine real_subtraction_scale_pdfs_real (rsub, sqme, i_real, i_part)
    class(real_subtraction_t), intent(inout) :: rsub
    real(default), intent(inout) :: sqme
    integer, intent(in) :: i_real, i_part
    integer :: flv
    real(default) :: pdfs, pdfb
    flv = rsub%reg_data%flv_real(i_real)%flst(i_part)
    !!! Gluon has index 0 in the pdf array
    if (flv == GLUON) flv = 0
    pdfb = rsub%pdf_born(i_part)%f(flv)
    pdfs = rsub%pdf_scaled(i_part)%f(flv)
    sqme = sqme * pdfs / pdfb
  end subroutine real_subtraction_scale_pdfs_real

@ %def real_subtraction_scale_pdfs_real
@ The same as above, but for the collinear subtraction terms. They are
proportional to the Born matrix element so they enter the subroutine
with pdfs evaluated for the Born flavor structure. Therefore, we
additionally have to take the flavor of the underlying Born particle
when dividing out the Born contribution.
<<real subtraction: real subtraction: TBP>>=
  procedure :: scale_pdfs_collinear => real_subtraction_scale_pdfs_collinear
<<real subtraction: procedures>>=
  subroutine real_subtraction_scale_pdfs_collinear &
     (rsub, sqme, i_real, i_born, i_part)
    class(real_subtraction_t), intent(inout) :: rsub
    real(default), intent(inout) :: sqme
    integer, intent(in) :: i_real, i_born, i_part
    integer :: flv_born, flv_real
    real(default) :: pdfs, pdfb
    flv_born = rsub%reg_data%flv_born(i_born)%flst(i_part)
    flv_real = rsub%reg_data%flv_real(i_real)%flst(i_part)
    if (flv_born == GLUON) flv_born = 0
    if (flv_real == GLUON) flv_real = 0
    pdfb = rsub%pdf_born(i_part)%f(flv_born)
    pdfs = rsub%pdf_scaled_coll(i_part)%f(flv_real)
    sqme = sqme * pdfs / pdfb
  end subroutine real_subtraction_scale_pdfs_collinear

@ %def real_subtraction_scale_pdfs_collinear
@
<<real subtraction: real subtraction: TBP>>=
  procedure :: final => real_subtraction_final
<<real subtraction: procedures>>=
  subroutine real_subtraction_final (rsub)
    class(real_subtraction_t), intent(inout) :: rsub
    call rsub%sub_soft%final ()
    call rsub%sub_coll%final ()
    !!! Finalization of region data is done in pcm_nlo_final
    if (associated (rsub%reg_data)) nullify (rsub%reg_data)
    !!! Finalization of real kinematics is done in pcm_instance_nlo_final
    if (associated (rsub%real_kinematics)) nullify (rsub%real_kinematics)
    if (associated (rsub%isr_kinematics)) nullify (rsub%isr_kinematics)
    if (allocated (rsub%sqme_real_non_sub)) deallocate (rsub%sqme_real_non_sub)
    if (allocated (rsub%sqme_born)) deallocate (rsub%sqme_born)
    if (allocated (rsub%sqme_born_cc)) deallocate (rsub%sqme_born_cc)
    if (allocated (rsub%sc_required)) deallocate (rsub%sc_required)
  end subroutine real_subtraction_final

@ %def real_subtraction_final
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Combining the FKS Pieces}
<<[[nlo_data.f90]]>>=
<<File header>>

module nlo_data

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use constants, only: zero
  use io_units
  use lorentz
  use variables, only: var_list_t
  use format_defs, only: FMT_15
  use physics_defs, only: THR_POS_WP, THR_POS_WM
  use physics_defs, only: THR_POS_B, THR_POS_BBAR
  use physics_defs, only: NO_FACTORIZATION, FACTORIZATION_THRESHOLD

<<Standard module head>>

<<nlo data: public>>

<<nlo data: parameters>>

<<nlo data: types>>

<<nlo data: interfaces>>

contains

<<nlo data: procedures>>

end module nlo_data

@ %def nlo_data
@
<<nlo data: parameters>>=
  integer, parameter, public :: FKS_DEFAULT = 1
  integer, parameter, public :: FKS_RESONANCES = 2

@ %def parameters
@
<<nlo data: public>>=
  public :: fks_template_t
<<nlo data: types>>=
  type :: fks_template_t
    logical :: subtraction_disabled = .false.
    integer :: mapping_type = FKS_DEFAULT
    logical :: count_kinematics = .false.
    real(default) :: fks_dij_exp1
    real(default) :: fks_dij_exp2
    type(string_t), dimension(:), allocatable :: excluded_resonances
  contains
  <<nlo data: fks template: TBP>>
  end type fks_template_t

@ %def fks_template_t
@
<<nlo data: fks template: TBP>>=
  procedure :: write => fks_template_write
<<nlo data: procedures>>=
  subroutine fks_template_write (template, unit)
    class(fks_template_t), intent(in) :: template
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,'(1x,A)') 'FKS Template: '
    write (u,'(1x,A)', advance = 'no') 'Mapping Type: '
    select case (template%mapping_type)
    case (FKS_DEFAULT)
       write (u,'(A)') 'Default'
    case (FKS_RESONANCES)
       write (u,'(A)') 'Resonances'
    case default
       write (u,'(A)') 'Unkown'
    end select
    write (u,'(1x,A,ES4.3,ES4.3)') 'd_ij exponentials: ', &
       template%fks_dij_exp1, template%fks_dij_exp2
  end subroutine fks_template_write

@ %def fks_template_write
@
<<nlo data: fks template: TBP>>=
  procedure :: set_dij_exp => fks_template_set_dij_exp
<<nlo data: procedures>>=
  subroutine fks_template_set_dij_exp (template, exp1, exp2)
    class(fks_template_t), intent(inout) :: template
    real(default), intent(in) :: exp1, exp2
    template%fks_dij_exp1 = exp1
    template%fks_dij_exp2 = exp2
  end subroutine fks_template_set_dij_exp

@ %def fks_template_set_dij_exp
@
<<nlo data: fks template: TBP>>=
  procedure :: set_mapping_type => fks_template_set_mapping_type
<<nlo data: procedures>>=
  subroutine fks_template_set_mapping_type (template, val)
    class(fks_template_t), intent(inout) :: template
    integer, intent(in) :: val
    template%mapping_type = val
  end subroutine fks_template_set_mapping_type

@ %def fks_template_set_mapping_type
@
<<nlo data: fks template: TBP>>=
  procedure :: set_counter => fks_template_set_counter
<<nlo data: procedures>>=
  subroutine fks_template_set_counter (template)
    class(fks_template_t), intent(inout) :: template
    template%count_kinematics = .true.
  end subroutine fks_template_set_counter

@ %def fks_template_set_counter
@
<<nlo data: fks template: TBP>>=
  procedure :: disable_subtraction => fks_template_disable_subtraction
<<nlo data: procedures>>=
  subroutine fks_template_disable_subtraction (template)
    class(fks_template_t), intent(inout) :: template
    template%subtraction_disabled = .true.
  end subroutine fks_template_disable_subtraction

@ %def fks_template_disable_subtraction
<<nlo data: public>>=
  public :: real_scales_t
<<nlo data: types>>=
  type :: real_scales_t
     real(default) :: scale
     real(default) :: ren_scale
     real(default) :: fac_scale
     real(default) :: scale_born
     real(default) :: fac_scale_born
     real(default) :: ren_scale_born
  end type real_scales_t

@ %def real_scales_t
@
<<nlo data: public>>=
  public :: pdf_container_t
<<nlo data: types>>=
  type :: pdf_container_t
     real(default), dimension(-6:6) :: f
  end type pdf_container_t

@ %def pdf_container_t
@
<<nlo data: public>>=
  public :: powheg_damping_t
<<nlo data: types>>=
  type, abstract :: powheg_damping_t
  contains
  <<nlo data: powheg damping: TBP>>
  end type powheg_damping_t

@ %def powheg_damping_t
@
<<nlo data: powheg damping: TBP>>=
  procedure (powheg_damping_init), deferred :: init
<<nlo data: interfaces>>=
  abstract interface
     subroutine powheg_damping_init (damping, scale)
       import
       class(powheg_damping_t), intent(out) :: damping
       real(default), intent(in) :: scale
     end subroutine powheg_damping_init
  end interface

@ %def powheg_damping_init
@
<<nlo data: powheg damping: TBP>>=
  procedure (powheg_damping_write), deferred :: write
<<nlo data: interfaces>>=
  abstract interface
     subroutine powheg_damping_write (damping, unit)
       import
       class(powheg_damping_t), intent(in) :: damping
       integer, intent(in), optional :: unit
     end subroutine powheg_damping_write
  end interface

@ %def powheg_damping_write
@ To allow really arbitrary damping functions, [[get_f]] should get the
full real phase space as argument and not just some [[pt2]] that is
extracted higher up.
<<nlo data: powheg damping: TBP>>=
  procedure (powheg_damping_get_f), deferred :: get_f
<<nlo data: interfaces>>=
  abstract interface
    function powheg_damping_get_f (damping, pt2) result (f)
       import
       real(default) :: f
       class(powheg_damping_t), intent(in) :: damping
       real(default), intent(in) :: pt2
    end function powheg_damping_get_f
  end interface

@ %def powheg_damping_get_f
@
<<nlo data: public>>=
  public :: powheg_damping_simple_t
<<nlo data: types>>=
  type, extends (powheg_damping_t) :: powheg_damping_simple_t
     real(default) :: h2 = 5._default
  contains
  <<nlo data: powheg damping simple: TBP>>
  end type powheg_damping_simple_t

@ %def powheg_damping_simple_t
@
<<nlo data: powheg damping simple: TBP>>=
  procedure :: get_f => powheg_damping_simple_get_f
<<nlo data: procedures>>=
  function powheg_damping_simple_get_f (damping, pt2) result (f)
    real(default) :: f
    class(powheg_damping_simple_t), intent(in) :: damping
    real(default), intent(in) :: pt2
    f = damping%h2 / (pt2 + damping%h2)
  end function powheg_damping_simple_get_f

@ %def powheg_damping_simple_get_f
@
<<nlo data: powheg damping simple: TBP>>=
  procedure :: init => powheg_damping_simple_init
<<nlo data: procedures>>=
  subroutine powheg_damping_simple_init (damping, scale)
    class(powheg_damping_simple_t), intent(out) :: damping
    real(default), intent(in) :: scale
    damping%h2 = scale**2
  end subroutine powheg_damping_simple_init

@ %def powheg_damping_simple_init
@
<<nlo data: powheg damping simple: TBP>>=
  procedure :: write => powheg_damping_simple_write
<<nlo data: procedures>>=
  subroutine powheg_damping_simple_write (damping, unit)
    class(powheg_damping_simple_t), intent(in) :: damping
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(1x,A)") "Powheg damping simple: "
    write (u, "(1x,A, "// FMT_15 // ")") "scale h2: ", damping%h2
  end subroutine powheg_damping_simple_write

@ %def powheg_damping_simple_write
@
<<nlo data: public>>=
  public :: get_threshold_momenta
<<nlo data: procedures>>=
  function get_threshold_momenta (p) result (p_thr)
    type(vector4_t), dimension(4) :: p_thr
    type(vector4_t), intent(in), dimension(:) :: p
    p_thr(1) = p(THR_POS_WP) + p(THR_POS_B)
    p_thr(2) = p(THR_POS_B)
    p_thr(3) = p(THR_POS_WM) + p(THR_POS_BBAR)
    p_thr(4) = p(THR_POS_BBAR)
  end function get_threshold_momenta

@ %def get_threshold_momenta
@
<<[[nlo_color_data.f90]]>>=
<<File header>>

module nlo_color_data

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use numeric_utils
  use diagnostics
  use physics_defs
  use process_constants !NODEP!
  use sm_physics
  use os_interface
  use models
  use pdg_arrays
  use particle_specifiers
  use phs_base
  use phs_single
  use cascades
  use state_matrices
  use interactions
  use lorentz
  use prc_core
  use prc_user_defined
  use sf_base
  use colors
  use phs_fks
  use flavors
  use fks_regions
  use nlo_data
  use virtual
  use real_subtraction
  use dglap_remnant

<<Standard module head>>

<<nlo color data: public>>

<<nlo color data: types>>

contains

<<nlo color data: procedures>>

end module nlo_color_data
@ %def nlo_color_data
@
<<nlo color data: types>>=
  type :: color_index_list_t
     integer, dimension(:), allocatable :: col
  end type color_index_list_t

@ %def color_index_list
@ We need to associate singular regions with compatible color flows.
<<nlo color data: types>>=
  type :: ftuple_color_map_t
    integer :: index
    integer :: color_index
    type(ftuple_color_map_t), pointer :: next
    type(ftuple_color_map_t), pointer :: prev
  contains
  <<nlo color data: color map: TBP>>
  end type ftuple_color_map_t

@ %def ftuple_color_map_t
@
<<nlo color data: color map: TBP>>=
  procedure :: init => ftuple_color_map_init
<<nlo color data: procedures>>=
  subroutine ftuple_color_map_init (icm)
    class(ftuple_color_map_t), intent(inout), target :: icm
    icm%index = 0
    icm%color_index = 0
    nullify (icm%next)
    nullify (icm%prev)
  end subroutine ftuple_color_map_init

@ %def ftuple_color_map_init
@ Explain
<<nlo color data: color map: TBP>>=
  procedure :: present => ftuple_color_map_present
<<nlo color data: procedures>>=
  function ftuple_color_map_present (icm, color_index) result(pres)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: color_index
    logical :: pres
    type(ftuple_color_map_t), pointer :: current
    pres = .false.
    select type (icm)
    type is (ftuple_color_map_t)
       current => icm
       do
          if (current%color_index == color_index) then
             pres = .true.
             exit
          else
             if (associated (current%next)) then
                current => current%next
             else
                exit
             end if
          end if
       end do
    end select
  end function ftuple_color_map_present

@ %def ftuple_color_map_present
@ Appends a color flow to the list
<<nlo color data: color map: TBP>>=
  procedure :: append => ftuple_color_map_append
<<nlo color data: procedures>>=
  subroutine ftuple_color_map_append (icm, val)
    class(ftuple_color_map_t), intent(inout), target :: icm
    integer, intent(in) :: val
    type(ftuple_color_map_t), pointer :: current
    select type (icm)
    type is (ftuple_color_map_t)
    if (.not. icm%present (val)) then
      if (icm%index == 0) then
        nullify(icm%next)
        icm%index = 1
        icm%color_index = val
      else
        current => icm
        do
          if (associated (current%next)) then
            current => current%next
          else
            allocate (current%next)
            nullify (current%next%next)
            current%next%prev => current
            current%next%index = current%index + 1
            current%next%color_index = val
            exit
          end if
        end do
      end if
    end if
    end select
  end subroutine ftuple_color_map_append

@ %def ftuple_color_map_append
@
<<nlo color data: color map: TBP>>=
  procedure :: get_n_entries => ftuple_color_map_get_n_entries
<<nlo color data: procedures>>=
  function ftuple_color_map_get_n_entries (icm) result(n_entries)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer :: n_entries
    type(ftuple_color_map_t), pointer :: current
    n_entries = 0
    select type (icm)
    type is (ftuple_color_map_t)
       current => icm
       do
          if (associated (current%next)) then
             current => current%next
          else
             n_entries = current%index
             exit
          end if
       end do
    end select
  end function ftuple_color_map_get_n_entries

@ %def ftuple_color_map_get_n_entries
@ Explain
<<nlo color data: color map: TBP>>=
  procedure :: get_index_array => ftuple_color_map_get_index_array
<<nlo color data: procedures>>=
  function ftuple_color_map_get_index_array (icm) result(iarr)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, dimension(:), allocatable :: iarr
    type(ftuple_color_map_t), pointer :: current
    integer :: n_entries
    integer :: i
    select type (icm)
    type is (ftuple_color_map_t)
    n_entries = icm%get_n_entries ()
    allocate (iarr(n_entries))
    do i = 1, n_entries
      if (i == 1) then
        current => icm
      else
        current => current%next
      end if
      iarr(i) = current%color_index
    end do
    end select
  end function ftuple_color_map_get_index_array

@ %def ftuple_color_map_get_index_array
@
<<nlo color data: color map: TBP>>=
  procedure :: get_entry => ftuple_color_map_get_entry
<<nlo color data: procedures>>=
  function ftuple_color_map_get_entry (icm, index) result(entry)
    class(ftuple_color_map_t), intent(in), target :: icm
    integer, intent(in) :: index
    integer :: entry
    type(ftuple_color_map_t), pointer :: current
    integer :: i
    entry = 0
    select type (icm)
    type is (ftuple_color_map_t)
       if (index <= icm%get_n_entries ()) then
          do i = 1, icm%get_n_entries ()
             if (i == 1) then
                current => icm
             else
                current => current%next
             end if
             if (i == index) entry = current%color_index
          end do
       end if
    end select
  end function ftuple_color_map_get_entry

@ %def ftuple_color_map_get_entry
@ Explain
<<nlo color data: color map: TBP>>=
  procedure :: create_map => ftuple_color_map_create_map
<<nlo color data: procedures>>=
  recursive subroutine ftuple_color_map_create_map (icm, flst, &
       emitter, allreg, color_states_born, color_states_real, &
       included_color_structures, p_rad_in)
    class(ftuple_color_map_t), intent(inout) :: icm
    type(flv_structure_t), intent(in) :: flst
    integer, intent(in) :: emitter
    type(ftuple_t), intent(in), dimension(:) :: allreg
    integer, intent(in), dimension(:,:,:) :: color_states_born
    integer, intent(in), dimension(:,:,:) :: color_states_real
    integer, intent(in), dimension(:) :: included_color_structures
    integer, intent(in), optional :: p_rad_in
    integer :: nreg, region
    integer :: p1, p2, p_rad
    integer :: flv_em, flv_rad
    integer :: n_col_real
    integer, dimension(2) :: col_em, col_rad
    integer :: i
    !!! splitting type: 1 - q -> qg
    !!!                 2 - g -> qq
    !!!                 3 - g -> gg
    integer :: splitting_type_flv, splitting_type_col
    nreg = size (allreg)
    n_col_real = size (color_states_real (1,1,:))
    do region = 1, nreg
      call allreg(region)%get (p1, p2)
      if (p1 == emitter .or. p2 == emitter .or. present (p_rad_in)) then
        if (.not. present (p_rad_in)) then
          if (p1 == emitter) then
            p_rad = p2
          else
            p_rad = p1
          end if
        else
          p_rad = p_rad_in
        end if
        if (emitter /= 0) then
          flv_em = flst%flst (emitter)
        else
          call icm%create_map &
               (flst, 1, allreg, color_states_born, color_states_real, &
               included_color_structures, p_rad)
          call icm%create_map &
               (flst, 2, allreg, color_states_born, color_states_real, &
               included_color_structures, p_rad)
          return
        end if
        flv_rad = flst%flst (p_rad)
        if (is_quark (flv_em) .and. is_gluon (flv_rad) .or. &
            is_gluon (flv_em) .and. is_quark (flv_rad)) then
           splitting_type_flv = 1
        else if (is_quark (flv_em) .and. flv_em + flv_rad == 0) then
           splitting_type_flv = 2
        else if (is_gluon (flv_em) .and. is_gluon (flv_rad)) then
           splitting_type_flv = 3
        else
          splitting_type_flv = 0
        end if
        do i = 1, n_col_real
           if (.not. (any (i == included_color_structures))) cycle
           col_em = color_states_real(:,emitter,i)
           col_rad = color_states_real(:,p_rad,i)
          if (is_color_singlet (col_em(1), col_em(2)) &
              .and. (is_color_doublet (col_rad(1), col_rad(2)) &
              .or. is_color_ghost (col_rad(1), col_rad(2)))) then
            splitting_type_col = 1
          else if (is_color_singlet (col_em(1), col_em(2)) .and. &
                   is_color_singlet (col_rad(1), col_rad(2))) then
            splitting_type_col = 2
          else if (is_color_doublet (col_em(1), col_em(2)) .and. &
                   is_color_doublet (col_rad(1), col_rad(2))) then
            splitting_type_col = 3
          else
            splitting_type_col = 0
          end if
          if (splitting_type_flv == splitting_type_col .and. &
              splitting_type_flv /= 0) then
            call icm%append (i)
          end if
        end do
      end if
    end do
  contains
    function is_color_singlet (c1, c2) result (singlet)
      integer, intent(in) :: c1, c2
      logical :: singlet
      singlet = (c1 == 0 .and. c2 /= 0) .or. (c1 /= 0 .and. c2 == 0)
    end function is_color_singlet
    function is_color_doublet (c1, c2) result (doublet)
      integer, intent(in) :: c1, c2
      logical :: doublet
      doublet = c1 /= 0 .and. c2 /= 0
    end function is_color_doublet
    function is_color_ghost (c1, c2) result (ghost)
      integer, intent(in) :: c1, c2
      logical :: ghost
      ghost = c1 == 0 .and. c2 == 0
    end function is_color_ghost
  end subroutine ftuple_color_map_create_map

@ %def ftuple_color_map_create_map
@ This data type contains color information, necessary for both soft
and virtual counterterms.
<<nlo color data: public>>=
  public :: nlo_color_data_t
<<nlo color data: types>>=
  type nlo_color_data_t
    type(ftuple_color_map_t), dimension(:), allocatable :: icm
    integer, dimension(:,:,:), allocatable :: col_state_born, col_state_real
    logical, dimension(:,:), allocatable :: ghost_flag_born, ghost_flag_real
    integer :: n_col_born, n_col_real
    type(color_t), dimension(:,:), allocatable :: color_real
    integer, dimension(:), allocatable :: col_born
    complex(default), dimension(:), allocatable :: color_factors_born
    integer, dimension(:,:), allocatable :: cf_index_real
    real(default), dimension(:,:,:), allocatable :: beta_ij
    logical :: beta_ij_evaluated = .false.
    logical :: color_is_conserved = .false.
    integer, dimension(:), allocatable :: equivalent_color_up_to_sign
    integer, dimension(:), allocatable :: included_color_structures

  contains
  <<nlo color data: nlo color data: TBP>>
  end type nlo_color_data_t

@ %def nlo_color_data_t
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: prepare => nlo_color_data_prepare
<<nlo color data: procedures>>=
  subroutine nlo_color_data_prepare (color_data, reg_data, flavor_indices, color_indices)
    class(nlo_color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(in) :: reg_data
    integer, intent(in), dimension(:) :: flavor_indices, color_indices
    integer :: i, i_uborn, n_flv
    integer, dimension(N_MAX_FLV) :: checked_uborns
    integer, dimension(:), allocatable :: i_flv, i_limit
    type(color_index_list_t), dimension(:), allocatable :: i_col
    call evaluate_flavors (n_flv, i_flv, i_limit)
    call evaluate_colors (n_flv, i_flv, i_limit, i_col)
    checked_uborns = 0
    do i = 1, size (i_flv)
       i_uborn = reg_data%get_underlying_born_index (i_flv(i))
       if (.not. any (checked_uborns == i_uborn)) then
          if (.not. allocated (color_data%included_color_structures)) then
             allocate (color_data%included_color_structures (size (i_col(i)%col)))
             color_data%included_color_structures = i_col(i)%col
          end if
          checked_uborns(i) = i_uborn
       end if
    end do
  contains
    subroutine evaluate_flavors (n_flv, i_flavor, i_limit)
      integer, intent(out) :: n_flv
      integer, intent(out), dimension(:), allocatable :: i_flavor
      integer, intent(out), dimension(:), allocatable :: i_limit
      integer :: i, current_flavor
      n_flv = 0; current_flavor = 0
      do i = 1, size (flavor_indices)
         if (flavor_indices (i) /= current_flavor) then
            n_flv = n_flv + 1
            current_flavor = flavor_indices(i)
         end if
      end do
      allocate (i_flavor (n_flv), i_limit (n_flv))
      current_flavor = 0; i_limit(1) = 1
      do i = 1, size (flavor_indices)
         if (flavor_indices(i) /= current_flavor) then
           i_limit(current_flavor + 1) = i
           current_flavor = flavor_indices(i)
           i_flavor(current_flavor) = current_flavor
         end if
      end do
    end subroutine evaluate_flavors

    subroutine evaluate_colors (n_flv, i_flavor, col_limit, i_color)
      integer, intent(in) :: n_flv
      integer, intent(in), dimension(:) :: i_flavor, col_limit
      type(color_index_list_t), intent(out), dimension(:), allocatable :: i_color
      integer :: i, j, k, col_first
      integer :: count_n_col
      allocate (i_color (n_flv))
      j = 1
      do i = 1, n_flv
         col_first = color_indices(col_limit (i))
         count_n_col = 1
         k = col_limit(i) + 1
         do while (color_indices(k) /= col_first)
            count_n_col = count_n_col + 1
            k = k + 1
         end do
         allocate (i_color(i)%col(count_n_col))
      end do
      do i = 1, n_flv
         j = 1
         col_first = color_indices(col_limit (i))
         i_color(i)%col(1) = color_indices (col_limit(i))
         k = col_limit(i) + 1
         do while (color_indices(k) /= col_first)
            j = j + 1
            i_color(i)%col(j) = color_indices (k)
            k = k + 1
         end do
      end do
    end subroutine evaluate_colors

  end subroutine nlo_color_data_prepare

@ %def nlo_color_data_prepare
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: init_color_matrix => nlo_color_data_init_color_matrix
<<nlo color data: procedures>>=
  subroutine nlo_color_data_init_color_matrix (color_data, reg_data, prc_constants, &
     factorization_mode)
    class(nlo_color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    integer, intent(in) :: factorization_mode
    if (debug_active (D_SUBTRACTION))  call show_input_values ()
    call prc_constants(1)%get_col_state (color_data%col_state_born)
    call prc_constants(2)%get_col_state (color_data%col_state_real)
    call prc_constants(2)%get_cf_index (color_data%cf_index_real)
    call prc_constants(1)%get_color_factors (color_data%color_factors_born)
    color_data%n_col_born = size (color_data%col_state_born (1, 1, :))
    color_data%n_col_real = size (color_data%col_state_real (1 ,1, :))
    call color_data%init_ghost_flags (prc_constants)
    call color_data%init_color (reg_data)
    call color_data%check_equivalences ()
    call color_data%compute_betaij (reg_data, factorization_mode)
  contains
    subroutine show_input_values()
      integer :: i
      call msg_debug (D_SUBTRACTION, "color_data_init")
      call msg_debug (D_SUBTRACTION, "factorization_mode", factorization_mode)
      do i = 1, size(color_data%included_color_structures)
         call msg_debug (D_SUBTRACTION, "included_color_structures(i)", &
            color_data%included_color_structures(i))
      end do
    end subroutine show_input_values
  end subroutine nlo_color_data_init_color_matrix

@ %def nlo_color_data_init_color_matrix
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: init_ghost_flags => nlo_color_data_init_ghost_flags
<<nlo color data: procedures>>=
  subroutine nlo_color_data_init_ghost_flags (color_data, prc_constants)
    class(nlo_color_data_t), intent(inout) :: color_data
    type(process_constants_t), intent(in), dimension(2) :: prc_constants
    call prc_constants(1)%get_ghost_flag (color_data%ghost_flag_born)
    call prc_constants(2)%get_ghost_flag (color_data%ghost_flag_real)
  end subroutine nlo_color_data_init_ghost_flags

@ %def nlo_color_data_init_ghost_flags
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: check_equivalences => nlo_color_data_check_equivalences
<<nlo color data: procedures>>=
  subroutine nlo_color_data_check_equivalences (color_data)
    class(nlo_color_data_t), intent(inout) :: color_data
    integer :: i_col1, i_col2
    if (allocated (color_data%equivalent_color_up_to_sign))  &
         deallocate (color_data%equivalent_color_up_to_sign)
    allocate (color_data%equivalent_color_up_to_sign (color_data%n_col_born))
    color_data%equivalent_color_up_to_sign (1) = 1
    do i_col1 = 1, color_data%n_col_born
       do i_col2 = 1, i_col1 - 1
          if (is_equivalent (color_data%col_state_born (:, :, i_col1), &
             color_data%col_state_born (:, :, i_col2))) then
             color_data%equivalent_color_up_to_sign (i_col1) = i_col2
          else
             color_data%equivalent_color_up_to_sign (i_col1) = i_col1
          end if
       end do
    end do
  contains
    function is_equivalent (col1, col2) result (equiv)
      logical :: equiv
      integer, intent(in), dimension(:,:) :: col1, col2
      integer :: leg
      integer, dimension(2) :: c1, c2, c3
      equiv = .true.
      do leg = 1, size (col1, dim = 2)
         c1 = col1(:, leg); c2 = col2(:, leg)
         c3(1) = -c2(2); c3(2) = -c2(1)
         equiv = equiv .and. (all (c1 == c2) .or. all (c1 == c3))
         if (.not. equiv) exit
      end do
    end function is_equivalent
  end subroutine nlo_color_data_check_equivalences

@ %def nlo_color_data_check_equivalences
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: init_color => nlo_color_data_init_color
<<nlo color data: procedures>>=
  subroutine nlo_color_data_init_color (color_data, reg_data)
    class(nlo_color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(in) :: reg_data
    integer :: i
    if (allocated (color_data%color_real))  &
         deallocate (color_data%color_real)
    if (allocated (color_data%icm))  deallocate (color_data%icm)
    allocate (color_data%color_real (reg_data%n_legs_real, &
         color_data%n_col_real))
    allocate (color_data%icm (reg_data%n_regions))
    do i = 1, color_data%n_col_real
      call color_init_from_array (color_data%color_real (:, i), &
           color_data%col_state_real (:, :, i), &
           color_data%ghost_flag_real (:, i))
      call color_data%color_real (1 : reg_data%n_in, i)%invert ()
    end do
    do i = 1, reg_data%n_regions
      call color_data%icm(i)%init
      associate (region => reg_data%regions(i))
        call color_data%icm(i)%create_map (region%flst_real, region%emitter, &
             region%ftuples, color_data%col_state_born, &
             color_data%col_state_real, color_data%included_color_structures)
      end associate
    end do
  end subroutine nlo_color_data_init_color

@ %def nlo_color_data_init_color
@ Allocate and compute $\beta_{ij}$:
<<nlo color data: nlo color data: TBP>>=
  procedure :: compute_betaij => nlo_color_data_compute_betaij
<<nlo color data: procedures>>=
  subroutine nlo_color_data_compute_betaij (color_data, reg_data, factorization_mode)
    class(nlo_color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: factorization_mode
    integer :: alr, i_born
    logical, dimension(reg_data%n_flv_born) :: checked_uborn
    if (debug_active (D_SUBTRACTION)) then
       call msg_print_color ("nlo_color_data_compute_betaij", COL_AQUA)
       call msg_print_color ("factorization_mode", factorization_mode, COL_AQUA)
    end if
    if (allocated (color_data%beta_ij)) &
         deallocate (color_data%beta_ij)
    allocate (color_data%beta_ij (reg_data%n_legs_born, &
         reg_data%n_legs_born, reg_data%n_flv_born))
    select case (factorization_mode)
    case (NO_FACTORIZATION)
       checked_uborn = .false.
       do alr = 1, reg_data%n_regions
          i_born = reg_data%regions(alr)%uborn_index
          if (checked_uborn (i_born)) cycle
          call color_data%fill_betaij_matrix (reg_data%n_legs_born, i_born, &
             reg_data%regions(alr)%flst_real, reg_data)
          checked_uborn (i_born) = .true.
       end do
    case (FACTORIZATION_THRESHOLD)
       call color_data%fill_betaij_matrix_threshold ()
    end select
  end subroutine nlo_color_data_compute_betaij

@ %def nlo_color_data_compute_betaij
@ Actual computation of $\beta_{ij}$.
<<nlo color data: nlo color data: TBP>>=
  procedure :: fill_betaij_matrix => nlo_color_data_fill_betaij_matrix
<<nlo color data: procedures>>=
  subroutine nlo_color_data_fill_betaij_matrix &
       (color_data, n_legs, uborn_index, flst_real, reg_data)
    class(nlo_color_data_t), intent(inout) :: color_data
    integer, intent(in) :: n_legs, uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    type(region_data_t), intent(inout) :: reg_data
    integer :: em1, em2
    associate (flv_born => reg_data%flv_born (uborn_index))
       do em1 = 1, n_legs
          do em2 = 1, n_legs
             if (flv_born%colored(em1) .and. flv_born%colored(em2)) then
                if (em1 < em2) then
                   color_data%beta_ij (em1, em2, uborn_index) &
                      = color_data%compute_bij &
                      (reg_data, uborn_index, flst_real, em1, em2)
                else if (em1 > em2) then
                   !!! B_ij is symmetric
                   color_data%beta_ij (em1, em2, uborn_index) = &
                      color_data%beta_ij (em2, em1, uborn_index)
                else
                   if (is_quark (abs (flv_born%flst (em1)))) then
                       color_data%beta_ij (em1, em2, uborn_index) = - cf
                   else
                      color_data%beta_ij (em1, em2, uborn_index) = - ca
                   end if
                end if
             else
                color_data%beta_ij (em1, em2, uborn_index) = zero
             end if
          end do
       end do
    end associate
    color_data%beta_ij_evaluated = .true.
    call check_color_conservation (color_data%beta_ij (:, :, uborn_index), &
         n_legs, color_data%color_is_conserved)
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "nlo_color_data_fill_betaij_matrix")
       do em1 = 1, n_legs
          do em2 = 1, n_legs
             print *, 'em1, em2, color_data%beta_ij(em1,em2,uborn_index) = ', &
                  em1, em2, color_data%beta_ij(em1, em2, uborn_index)
          end do
       end do
    end if
  contains
    subroutine check_color_conservation (bij_matrix, n_legs, success)
      real(default), intent(in), dimension(:,:) :: bij_matrix
      integer, intent(in) :: n_legs
      logical, intent(out) :: success
      logical, dimension(:), allocatable :: check
      integer :: i, j
      real(default) :: bcheck
      real(default), parameter :: tol = 0.0001_default
      allocate (check (n_legs))
      do i = 1, n_legs
         bcheck = 0.0
         do j = 1, n_legs
            if (i /= j) bcheck = bcheck + bij_matrix (i, j)
         end do
         if (is_quark (abs(flst_real%flst (i))) .or. &
             is_gluon (flst_real%flst (i))) then
            if (is_quark (abs(flst_real%flst (i))) .and. &
                 (bcheck - cf) < tol) then
               check (i) = .true.
            else if (is_gluon (flst_real%flst (i)) .and. &
                 (bcheck - ca) < tol) then
               check (i) = .true.
            else
               check (i) = .false.
            end if
         else
            if (bcheck < tol) then
               check (i) = .true.
            else
               check (i) = .false.
            end if
         end if
      end do
      success = all (check)
    end subroutine check_color_conservation
  end subroutine nlo_color_data_fill_betaij_matrix

@ %def nlo_color_data_fill_betaij_matrix
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: fill_betaij_matrix_threshold &
     => nlo_color_data_fill_betaij_matrix_threshold
<<nlo color data: procedures>>=
  subroutine nlo_color_data_fill_betaij_matrix_threshold (color_data)
    class(nlo_color_data_t), intent(inout) :: color_data
    integer :: i, j
    color_data%beta_ij = zero
    associate (beta_ij => color_data%beta_ij (:,:,1))
       do i = 1, 4
          beta_ij (i,i) = -CF
       end do
       beta_ij (1,2) = CF; beta_ij (2,1) = CF
       beta_ij (3,4) = CF; beta_ij (4,3) = CF
    end associate
    if (debug_active (D_SUBTRACTION)) then
       call msg_debug (D_SUBTRACTION, "nlo_color_data_fill_betaij_matrix_threshold")
       do i = 1, size(color_data%beta_ij, dim=1)
          do j = 1, size(color_data%beta_ij, dim=1)
             print *, 'i, j, color_data%beta_ij(i,j,1) = ', &
                  i, j, color_data%beta_ij(i,j,1)
          end do
       end do
    end if
  end subroutine nlo_color_data_fill_betaij_matrix_threshold

@ %def nlo_color_data_fill_betaij_matrix_threshold
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: compute_bij => nlo_color_data_compute_bij
<<nlo color data: procedures>>=
  function nlo_color_data_compute_bij (color_data, reg_data, uborn_index, &
      flst_real, em1, em2) result (bij)
    real(default) :: bij
    class(nlo_color_data_t), intent(inout) :: color_data
    type(region_data_t), intent(inout) :: reg_data
    integer, intent(in) :: uborn_index
    type(flv_structure_t), intent(in) :: flst_real
    integer, intent(in) :: em1, em2
    logical, dimension(:,:), allocatable :: cf_present
    type(singular_region_t), dimension(2,100) :: reg
    integer ::  i, j, k, l
    integer :: alr, n_alr
    type(ftuple_color_map_t) :: icm1, icm2
    integer :: i1, i2
    real(default) :: color_factor, color_factor_born
    integer, dimension(2) :: i_reg
    logical , dimension(2) :: found
    integer, dimension(2,100) :: map_em_col_tmp
    integer, dimension(:), allocatable :: map_em_col1, map_em_col2
    integer, dimension(2) :: col1, col2
    integer, dimension(:), allocatable :: iarray1, iarray2
    integer, dimension(:), allocatable :: iisec1, iisec2
    integer :: sign
    integer, dimension(:), allocatable :: uborn_group, em1_group, em2_group
    integer, dimension(:), allocatable :: compute_alrs
    bij = zero
    color_factor = zero; color_factor_born = zero
    found = .false.
    allocate (uborn_group (reg_data%get_uborn_group_size (uborn_index)))
    uborn_group = reg_data%get_uborn_group (uborn_index)
    allocate (em1_group (reg_data%get_emitter_group_size (em1)))
    em1_group = reg_data%get_emitter_group (em1)
    allocate (em2_group (reg_data%get_emitter_group_size (em2)))
    em2_group = reg_data%get_emitter_group (em2)
    n_alr = 0
    do i = 1, size (uborn_group)
       n_alr = n_alr + count (uborn_group(i) == em1_group) + count (uborn_group(i) == em2_group)
    end do
    if (n_alr == 0) return
    allocate (compute_alrs (n_alr))
    compute_alrs = &
       pack (uborn_group, [(any (uborn_group(i) == em1_group) .or. any (uborn_group(i) == em2_group), &
       i = 1, size (uborn_group))])
    !!! Include distinction between Born flavors
    do i = 1, size (color_data%color_factors_born)
       if (color_data%equivalent_color_up_to_sign (i) == i) &
          color_factor_born = color_factor_born + real (color_data%color_factors_born (i))
    end do
    i1 = 1; i2 = 1
    do i = 1, color_data%n_col_real
       if (any (color_data%included_color_structures == i)) then
          col1 = color_data%col_state_real (:, em1, i)
          col2 = color_data%col_state_real (:, reg_data%n_legs_real, i)
          if (share_line (col1, col2)) then
             map_em_col_tmp(1, i1) = i
             i1 = i1 + 1
          end if
          col1 = color_data%col_state_real (:, em2, i)
          if (share_line (col1, col2)) then
             map_em_col_tmp(2, i2) = i
             i2 = i2 + 1
          end if
       end if
    end do
    allocate (map_em_col1 (i1), map_em_col2 (i2))
    map_em_col1 = map_em_col_tmp (1, 1 : i1 - 1)
    map_em_col2 = map_em_col_tmp (2, 1 : i2 - 1)

    i_reg = 1

    do alr = 1, reg_data%n_regions
        if (.not. any (compute_alrs == alr)) cycle
        if (em1 == reg_data%regions(alr)%emitter .or. &
           (em1 <= 2 .and. reg_data%regions(alr)%emitter == 0)) then
           reg(1, i_reg(1)) = reg_data%regions(alr)
           i_reg(1) = i_reg(1) + 1
           found(1) = .true.
        end if
        if (em2 == reg_data%regions(alr)%emitter .or. &
           (em2 <= 2 .and. reg_data%regions(alr)%emitter == 0)) then
           reg(2, i_reg(2)) = reg_data%regions(alr)
           i_reg(2) = i_reg(2) + 1
           found(2) = .true.
        end if
    end do
    if (.not. (found(1) .and. found(2))) then
       return
    end if

    do i = 1, i_reg(1) - 1
       do j = 1, i_reg(2) - 1
          icm1 = color_data%icm (reg(1, i)%alr)
          icm2 = color_data%icm (reg(2, j)%alr)

          allocate (iarray1 (size (icm1%get_index_array ())))
          allocate (iarray2 (size (icm2%get_index_array ())))

          iarray1 = icm1%get_index_array ()
          iarray2 = icm2%get_index_array ()

          allocate (iisec1 (count (iarray1 == map_em_col1)))
          allocate (iisec2 (count (iarray2 == map_em_col2)))

          iisec1 = pack (iarray1, [ (any(iarray1(i) == map_em_col1), &
               i = 1, size(iarray1)) ])
          iisec2 = pack (iarray2, [ (any(iarray2(i) == map_em_col2), &
               i = 1, size(iarray2)) ])

          allocate (cf_present (size (color_index_present &
             (color_data%cf_index_real), 1), size (color_index_present &
             (color_data%cf_index_real), 2)))

          cf_present = color_index_present (color_data%cf_index_real)

          do k = 1, size (iisec1)
             do l = 1, size (iisec2)
                i1 = iisec1(k)
                i2 = iisec2(l)
                if (cf_present (i1, i2)) then
                   if (is_gluon (flst_real%flst (em1)) .or. &
                      is_gluon (flst_real%flst (em2))) then
                      sign = get_sign (color_data%col_state_real (:, :, i1)) * &
                         get_sign (color_data%col_state_real (:, :, i2))
                   else
                      sign = 1
                   end if
                   color_factor = color_factor + sign * compute_color_factor &
                      (color_data%color_real(:, i1), &
                      color_data%color_real(:, i2))
                end if
             end do
          end do
       deallocate (iarray1, iarray2, iisec1, iisec2, cf_present)
       end do
    end do
    !!! The real color factor always differs from the Born one
    !!! by one vertex factor. Thus, apply the factor 1/2
    bij = color_factor / (two * color_factor_born)

  contains
    function share_line (col1, col2) result (share)
      integer, intent(in), dimension(2) :: col1, col2
      logical :: share
      logical :: id1, id2, id3
      id1 = (abs(col1(1)) == abs(col2(1)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(2)) .and. col1(2) /= 0)
      id2 = (abs(col1(1)) == abs(col2(2)) .and. col1(1) /= 0) .or. &
            (abs(col1(2)) == abs(col2(1)) .and. col1(2) /= 0)
      id3 = col2(1) == 0 .and. col2(2) == 0
      if (id1 .or. id2 .or. id3) then
        share = .true.
      else
        share = .false.
      end if
    end function share_line

    function get_sign (col) result (sign)
      integer, intent(in), dimension(:,:) :: col
      integer :: sign
      integer, dimension(:), allocatable :: iref, iperm
      integer :: iref1, iperm1
      integer :: n, i, i_first, j
      integer :: i1, i2
      integer :: p1, p2
      p1 = 2; p2 = 2
      iref1 = 0; iperm1 = 0; i_first = 0; i1 = 0
      do i = 1, size(col(1,:))
        if (.not. all (col(:,i) == 0)) then
          if (col(1,i) == 0) then
            i1 = col(2,i)
            iref1 = i; iperm1 = i
            i_first = i
          else
            i1 = col(1,i)
            iref1 = i; iperm1 = i
            i_first = i
          end if
          exit
        end if
      end do
      if (iref1 == 0 .or. iperm1 == 0 .or. i_first == 0) &
         call msg_fatal ("Invalid color structure")
      n = size(col(1,:)) - i_first + 1
      allocate (iref(n), iperm(n))
      iref(1) = iref1; iperm(1) = iperm1
      do i = i_first+1, size(col(1,:))
        if (all (col(:,i) == 0)) cycle
        if (i == size(col(1,:))) then
          iref(p1) = i_first + 1
        else
          iref(p1) = i + 1
          p1 = p1 + 1
        end if
        do j = i_first+1, size(col(1,:))
          if (col(1,j) == -i1) then
            i1 = col(2,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          else if (col(2,j) == -i1) then
            i1 = col(1,j)
            iperm(p2) = j
            p2 = p2 + 1
            exit
          end if
        end do
      end do
      sign = 1
      do i = 1, n
        if (iperm(i) == iref(i)) then
          cycle
        else
          do j = i+1, n
            if (iperm(j) == iref(i)) then
              i1 = j
              exit
            end if
          end do
          i2 = iperm(i)
          iperm(i) = iperm(i1)
          iperm(i1) = i2
          sign = -sign
        end if
      end do
    end function get_sign

    function color_index_present (cf_index) result (cf_present)
      integer, intent(in), dimension(:,:), allocatable :: cf_index
      logical, dimension(:,:), allocatable :: cf_present
      integer :: n_col
      integer :: c, i1, i2
      n_col = size (cf_index(1,:))
      allocate (cf_present (n_col, n_col))
      cf_present = .false.
      do c = 1, n_col
        i1 = cf_index (1, c)
        i2 = cf_index (2, c)
        cf_present (i1, i2) = .true.
        if (i1 /= i2) cf_present(i2, i1) = .true.
      end do
    end function color_index_present
  end function nlo_color_data_compute_bij

@ %def nlo_color_data_compute_bij
@
<<nlo color data: nlo color data: TBP>>=
  procedure :: write => nlo_color_data_write
<<nlo color data: procedures>>=
  subroutine nlo_color_data_write (color_data, unit, verbose)
    class(nlo_color_data_t), intent(in) :: color_data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u, i, i1, i2
    integer :: n_legs, n_up
    logical :: print_second_off_diagonal
    u = given_output_unit (unit); if (u < 0) return
    print_second_off_diagonal = .false.
    if (present (verbose)) print_second_off_diagonal = verbose
    n_legs = size (color_data%beta_ij, dim = 2)
    n_up = n_legs
    write (u, "(1x,A)") "Color information: "
    write (u, "(1x,A,1x,I1)") "Number of Born color states: ", &
         color_data%n_col_born
    write (u, "(1x,A,1x,I1)") "Number of real color states: ", &
         color_data%n_col_real
    if (.not. color_data%beta_ij_evaluated) return
    write (u, "(1x,A)") "Color correlation: "
    do i = 1, size (color_data%beta_ij, dim = 3)
      write (u, "(1x,A,1x,I1)") "State nr. ", i
      write (u, "(1x,A)") "-------------"
      write (u, "(1x,A,1x,A,1x,A)") "i1", "i2", "color factor"
      do i1 = 1, n_legs
        if (.not. print_second_off_diagonal) n_up = i1
        do i2 = 1, n_up
          write (u, "(1x,I1,1x,I1,1x,F5.2)") &
               i1, i2, color_data%beta_ij (i1, i2, i)
        end do
      end do
      write (u, "(1x,A)") "========================================"
    end do
    if (color_data%color_is_conserved) then
      write (u, "(1x,A)") "Color is conserved."
    else
      write (u, "(1x,A)") "Fatal error: Color conversation is violated."
    end if
  end subroutine nlo_color_data_write

@ %def nlo_color_data_write
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Unit tests}
<<[[nlo_color_data_ut.f90]]>>=
<<File header>>

module nlo_color_data_ut
  use unit_tests
  use nlo_color_data_uti

<<Standard module head>>

<<nlo color data: public test>>

contains

<<nlo color data: test driver>>

end module nlo_color_data_ut
@ %def nlo_color_data_ut
@
<<[[nlo_color_data_uti.f90]]>>=
<<File header>>

module nlo_color_data_uti
  use physics_defs, only: NO_FACTORIZATION
  use nlo_color_data, only: nlo_color_data_t
  use fks_regions, only: region_data_t, setup_region_data_for_test

<<Standard module head>>

<<nlo color data: test declarations>>

contains

<<nlo color data: tests>>

end module nlo_color_data_uti

@ %def nlo_color_data_uti
@
<<nlo color data: public test>>=
  public :: nlo_color_data_test
<<nlo color data: test driver>>=
  subroutine nlo_color_data_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
    call test(nlo_color_data_1, "nlo_color_data_1", &
       "Test creation of the beta_ij-matrix for FSR", &
       u, results)
    call test(nlo_color_data_2, "nlo_color_data_2", &
       "Test creation of the beta_ij-matrix for ISR", &
       u, results)
    call test(nlo_color_data_3, "nlo_color_data_3", &
       "Test creation of the beta_ij-matrix for ISR and multiple Born structures (Drell Yan)", &
       u, results)
  end subroutine nlo_color_data_test

@ %def nlo_color_data_test
@
<<nlo color data: test declarations>>=
  public :: nlo_color_data_1
<<nlo color data: tests>>=
  subroutine nlo_color_data_1 (u)
    integer, intent(in) :: u
    type(nlo_color_data_t) :: color_data
    integer :: n_legs_born, n_legs_real
    integer :: n_flv_born, n_flv_real
    integer :: n_col_born, n_col_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    write (u, "(A)") "* Test output: nlo_color_data_1"
    write (u, "(A)") "* Purpose: Test internal computation of color-correlated matrix elements"
    write (u, "(A)") "* in the color-flow scheme"
    write (u, "(A)")
    write (u, "(A)") "* Process: e- e+ -> u u~"

    n_legs_born = 4; n_legs_real = 5
    n_flv_born = 1; n_flv_real = 1
    n_col_born = 1; n_col_real = 2
    allocate (color_data%col_state_born (2, n_legs_born, n_col_born))
    associate (col_state_born => color_data%col_state_born)
       col_state_born (:, 1, 1) = [0, 0]
       col_state_born (:, 2, 1) = [0, 0]
       col_state_born (:, 3, 1) = [1, 0]
       col_state_born (:, 4, 1) = [0, -1]
    end associate
    allocate (color_data%col_state_real (2, n_legs_real, n_col_real))
    associate (col_state_real => color_data%col_state_real)
       col_state_real (:, 1, 1) = [0, 0]
       col_state_real (:, 2, 1) = [0, 0]
       col_state_real (:, 1, 2) = [0, 0]
       col_state_real (:, 2, 2) = [0, 0]
       col_state_real (:, 3, 1) = [1, 0]
       col_state_real (:, 4, 1) = [0, -2]
       col_state_real (:, 5, 1) = [2, -1]
       col_state_real (:, 3, 2) = [1, 0]
       col_state_real (:, 4, 2) = [0, -1]
       col_state_real (:, 5, 2) = [0, 0]
   end associate
   allocate (color_data%cf_index_real (2, n_col_real))
   color_data%cf_index_real(:, 1) = [1, 1]
   color_data%cf_index_real(:, 2) = [2, 2]
   allocate (color_data%color_factors_born (n_col_born))
   color_data%color_factors_born (1) = cmplx (3, 0)
   color_data%n_col_born = n_col_born
   color_data%n_col_real = n_col_real

   n_in = 2
   allocate (flv_born (n_legs_born, n_flv_born))
   allocate (flv_real (n_legs_real, n_flv_real))
   flv_born (:, 1) = [11, -11, 2, -2]
   flv_real (:, 1) = [11, -11, 2, -2, 21]
   call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
   allocate (color_data%ghost_flag_born (n_legs_born, n_col_born))
   allocate (color_data%ghost_flag_real (n_legs_real, n_col_real))
   color_data%ghost_flag_born (:, 1) = .false.
   color_data%ghost_flag_real (:, 1) = .false.
   color_data%ghost_flag_real (1 : n_legs_born, 2) = .false.
   color_data%ghost_flag_real (n_legs_real, 2) = .true.
   allocate (color_data%included_color_structures (2))
   color_data%included_color_structures = [1, 2]
   call color_data%init_color (reg_data)
   call color_data%check_equivalences ()
   call color_data%compute_betaij (reg_data, NO_FACTORIZATION)
   call color_data%write (u, verbose = .true.)
  end subroutine nlo_color_data_1

@ %def nlo_color_data_1
@
<<nlo color data: test declarations>>=
  public :: nlo_color_data_2
<<nlo color data: tests>>=
  subroutine nlo_color_data_2 (u)
    integer, intent(in) :: u
    type(nlo_color_data_t) :: color_data
    integer :: n_legs_born, n_legs_real
    integer :: n_flv_born, n_flv_real
    integer :: n_col_born, n_col_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    integer :: i
    write (u, "(A)") "* Test output: nlo_color_data_2"
    write (u, "(A)") "* Purpose: Test internal computation of color-correlated matrix elements"
    write (u, "(A)") "* in the color-flow scheme"
    write (u, "(A)")
    write (u, "(A)") "* Process: u u~ -> Z Z"

    n_legs_born = 4; n_legs_real = 5
    n_flv_born = 1; n_flv_real = 3
    n_col_born = 1; n_col_real = 6
    allocate (color_data%col_state_born (2, n_legs_born, n_col_born))
    associate (col_state_born => color_data%col_state_born)
       col_state_born (:, 1, 1) = [1, 0]
       col_state_born (:, 2, 1) = [0, -1]
       col_state_born (:, 3, 1) = [0, 0]
       col_state_born (:, 4, 1) = [0, 0]
    end associate
    allocate (color_data%col_state_real (2, n_legs_real, n_col_real))
    associate (col_state_real => color_data%col_state_real)
       col_state_real (:, 1, 1) = [0, 0]
       col_state_real (:, 2, 1) = [0, -2]
       col_state_real (:, 3, 1) = [0, 0]
       col_state_real (:, 4, 1) = [0, 0]
       col_state_real (:, 5, 1) = [0, -2]
       col_state_real (:, 1, 2) = [1, 0]
       col_state_real (:, 2, 2) = [0, -1]
       col_state_real (:, 3, 2) = [0, 0]
       col_state_real (:, 4, 2) = [0, 0]
       col_state_real (:, 5, 2) = [0, 0]
       col_state_real (:, 1, 3) = [1, 0]
       col_state_real (:, 2, 3) = [2, -1]
       col_state_real (:, 3, 3) = [0, 0]
       col_state_real (:, 4, 3) = [0, 0]
       col_state_real (:, 5, 3) = [2, 0]
       col_state_real (:, 1, 4) = [2, -1]
       col_state_real (:, 2, 4) = [0, -2]
       col_state_real (:, 3, 4) = [0, 0]
       col_state_real (:, 4, 4) = [0, 0]
       col_state_real (:, 5, 4) = [0, -1]
       col_state_real (:, 1, 5) = [2, 0]
       col_state_real (:, 2, 5) = [0, 0]
       col_state_real (:, 3, 5) = [0, 0]
       col_state_real (:, 4, 5) = [0, 0]
       col_state_real (:, 5, 5) = [2, 0]
       col_state_real (:, 1, 6) = [2, 0]
       col_state_real (:, 2, 6) = [0, -1]
       col_state_real (:, 3, 6) = [0, 0]
       col_state_real (:, 4, 6) = [0, 0]
       col_state_real (:, 5, 6) = [2, -1]
   end associate
   allocate (color_data%cf_index_real (2, n_col_real))
   do i = 1, n_col_real
      color_data%cf_index_real(:, i) = [i, i]
   end do
   allocate (color_data%color_factors_born (n_col_born))
   color_data%color_factors_born (1) = cmplx (3, 0)
   color_data%n_col_born = n_col_born
   color_data%n_col_real = n_col_real

   n_in = 2
   allocate (flv_born (n_legs_born, n_flv_born))
   allocate (flv_real (n_legs_real, n_flv_real))
   flv_born (:, 1) = [2, -2, 23, 23]
   flv_real (:, 1) = [2, -2, 23, 23, 21]
   flv_real (:, 2) = [2, 21, 23, 23, 2]
   flv_real (:, 3) = [21, -2, 23, 23, -2]
   call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
   allocate (color_data%ghost_flag_born (n_legs_born, n_col_born))
   allocate (color_data%ghost_flag_real (n_legs_real, n_col_real))
   color_data%ghost_flag_born (:, 1) = .false.
   color_data%ghost_flag_real (1, 1) = .true.
   color_data%ghost_flag_real (2 : n_legs_real, 1) = .false.
   color_data%ghost_flag_real (1 : n_legs_born, 2) = .false.
   color_data%ghost_flag_real (n_legs_real, 2) = .true.
   color_data%ghost_flag_real (:, 3) = .false.
   color_data%ghost_flag_real (:, 4) = .false.
   color_data%ghost_flag_real (1, 5) = .false.
   color_data%ghost_flag_real (2, 5) = .false.
   color_data%ghost_flag_real (3 : n_legs_real, 5) = .true.
   color_data%ghost_flag_real (:, 6) = .false.
   allocate (color_data%included_color_structures (2))
   color_data%included_color_structures = [2, 6]
   call color_data%init_color (reg_data)
   call color_data%check_equivalences ()
   call color_data%compute_betaij (reg_data, NO_FACTORIZATION)
   call color_data%write (u, verbose = .true.)
  end subroutine nlo_color_data_2

@ %def nlo_color_data_2
@
<<nlo color data: test declarations>>=
  public :: nlo_color_data_3
<<nlo color data: tests>>=
  subroutine nlo_color_data_3 (u)
    integer, intent(in) :: u
    type(nlo_color_data_t) :: color_data
    integer :: n_legs_born, n_legs_real
    integer :: n_flv_born, n_flv_real
    integer :: n_col_born, n_col_real
    integer :: n_in
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    type(region_data_t) :: reg_data
    integer :: i_col, i_flv, pdg1, pdg2
    write (u, "(A)") "* Test output: nlo_color_data_2"
    write (u, "(A)") "* Purpose: Test internal computation of color-correlated matrix elements"
    write (u, "(A)") "* in the color-flow scheme"
    write (u, "(A)")
    write (u, "(A)") "* Process: u u~ -> Z Z"

    n_legs_born = 4; n_legs_real = 5
    n_flv_born = 10; n_flv_real = 30
    n_col_born = 2; n_col_real = 12
    allocate (color_data%col_state_born (2, n_legs_born, n_col_born))
    associate (col_state_born => color_data%col_state_born)
       do i_col = 1, n_col_born
          col_state_born (:, 1, i_col) = [1, 0]
          col_state_born (:, 2, i_col) = [0, -1]
          col_state_born (:, 3, i_col) = [0, 0]
          col_state_born (:, 4, i_col) = [0, 0]
       end do
    end associate
    allocate (color_data%col_state_real (2, n_legs_real, n_col_real))
    associate (col_state_real => color_data%col_state_real)
       do i_col = 1, n_col_real, 6
          col_state_real (:, 1, i_col) = [0, 0]
          col_state_real (:, 2, i_col) = [0, -2]
          col_state_real (:, 3, i_col) = [0, 0]
          col_state_real (:, 4, i_col) = [0, 0]
          col_state_real (:, 5, i_col) = [0, -2]
          col_state_real (:, 1, i_col + 1) = [1, 0]
          col_state_real (:, 2, i_col + 1) = [0, -1]
          col_state_real (:, 3, i_col + 1) = [0, 0]
          col_state_real (:, 4, i_col + 1) = [0, 0]
          col_state_real (:, 5, i_col + 1) = [0, 0]
          col_state_real (:, 1, i_col + 2) = [1, 0]
          col_state_real (:, 2, i_col + 2) = [2, -1]
          col_state_real (:, 3, i_col + 2) = [0, 0]
          col_state_real (:, 4, i_col + 2) = [0, 0]
          col_state_real (:, 5, i_col + 2) = [2, 0]
          col_state_real (:, 1, i_col + 3) = [2, -1]
          col_state_real (:, 2, i_col + 3) = [0, -2]
          col_state_real (:, 3, i_col + 3) = [0, 0]
          col_state_real (:, 4, i_col + 3) = [0, 0]
          col_state_real (:, 5, i_col + 3) = [0, -1]
          col_state_real (:, 1, i_col + 4) = [2, 0]
          col_state_real (:, 2, i_col + 4) = [0, 0]
          col_state_real (:, 3, i_col + 4) = [0, 0]
          col_state_real (:, 4, i_col + 4) = [0, 0]
          col_state_real (:, 5, i_col + 4) = [2, 0]
          col_state_real (:, 1, i_col + 5) = [2, 0]
          col_state_real (:, 2, i_col + 5) = [0, -1]
          col_state_real (:, 3, i_col + 5) = [0, 0]
          col_state_real (:, 4, i_col + 5) = [0, 0]
          col_state_real (:, 5, i_col + 5) = [2, -1]
      end do
   end associate
   allocate (color_data%cf_index_real (2, n_col_real))
   do i_col = 1, n_col_real
      color_data%cf_index_real(:, i_col) = [i_col, i_col]
   end do
   allocate (color_data%color_factors_born (n_col_born))
   color_data%color_factors_born (:) = cmplx (3, 0)
   color_data%n_col_born = n_col_born
   color_data%n_col_real = n_col_real

   n_in = 2
   allocate (flv_born (n_legs_born, n_flv_born))
   allocate (flv_real (n_legs_real, n_flv_real))
   pdg1 = -5; pdg2 = 5
   do i_flv = 1, n_flv_born
      if (pdg1 == 0 .and. pdg2 == 0) then
         pdg1 = pdg1 + 1; pdg2 = pdg2 - 1
      end if
      flv_born (:, i_flv) = [pdg1, pdg2, 23, 23]
      pdg1 = pdg1 + 1; pdg2 = pdg2 - 1
   end do
   pdg1 = -5; pdg2 = 5
   do i_flv = 1, n_flv_real, 3
      if (pdg1 == 0 .and. pdg2 == 0) then
         pdg1 = pdg1 + 1; pdg2 = pdg2 - 1
      end if
      flv_real (:, i_flv) = [pdg1, pdg2, 23, 23, 21]
      flv_real (:, i_flv + 1) = [pdg1, 21, 23, 23, pdg1]
      flv_real (:, i_flv + 2) = [21, pdg2, 23, 23, pdg2]
      pdg1 = pdg1 + 1; pdg2 = pdg2 - 1
   end do
   call setup_region_data_for_test (n_in, flv_born, flv_real, reg_data)
   allocate (color_data%ghost_flag_born (n_legs_born, n_col_born))
   allocate (color_data%ghost_flag_real (n_legs_real, n_col_real))
   do i_col = 1, n_col_born
      color_data%ghost_flag_born (:, i_col) = .false.
   end do
   do i_col = 1, n_col_real, 6
      color_data%ghost_flag_real (1, i_col) = .true.
      color_data%ghost_flag_real (2 : n_legs_real, i_col) = .false.
      color_data%ghost_flag_real (1 : n_legs_born, i_col + 1) = .false.
      color_data%ghost_flag_real (n_legs_real, i_col + 1) = .true.
      color_data%ghost_flag_real (:, i_col + 2) = .false.
      color_data%ghost_flag_real (:, i_col + 3) = .false.
      color_data%ghost_flag_real (1, i_col + 4) = .false.
      color_data%ghost_flag_real (2, i_col + 4) = .false.
      color_data%ghost_flag_real (3 : n_legs_real, i_col + 4) = .true.
      color_data%ghost_flag_real (:, i_col + 5) = .false.
   end do
   allocate (color_data%included_color_structures (2))
   color_data%included_color_structures = [2, 6]
   call color_data%init_color (reg_data)
   call color_data%check_equivalences ()
   call color_data%compute_betaij (reg_data, NO_FACTORIZATION)
   call color_data%write (u, verbose = .true.)
  end subroutine nlo_color_data_3

@ %def nlo_color_data_3
@
\subsection{Putting it together}
<<nlo data: public>>=
  public :: nlo_settings_t
<<nlo data: types>>=
  type :: nlo_settings_t
     logical :: use_internal_color_correlations = .true.
     logical :: use_internal_spin_correlations = .false.
     logical :: use_resonance_mappings = .false.
     logical :: combined_integration = .false.
     logical :: fixed_order_nlo = .false.
     logical :: with_virtual_subtraction = .true.
     logical :: test_soft_limit = .false.
     logical :: test_coll_limit = .false.
     logical :: test_anti_coll_limit = .false.
     integer :: fixed_alr = 0
     integer :: factorization_mode = NO_FACTORIZATION
     !!! Probably not the right place for this. Revisit after refactoring
     real(default) :: powheg_damping_scale = zero
     type(fks_template_t) :: fks_template
  contains
  <<nlo data: nlo settings: TBP>>
  end type nlo_settings_t

@ %def nlo_settings_t
@
<<nlo data: nlo settings: TBP>>=
procedure :: init => nlo_settings_init
<<nlo data: procedures>>=
  subroutine nlo_settings_init (nlo_settings, var_list, combined_integration)
    class(nlo_settings_t), intent(out) :: nlo_settings
    type(var_list_t), intent(in) :: var_list
    logical, intent(in), optional :: combined_integration
    type(string_t) :: color_method
    color_method = var_list%get_sval (var_str ('$correlation_me_method'))
    nlo_settings%use_internal_color_correlations = color_method == 'omega' &
       .or. color_method == 'threshold'
    if (present (combined_integration)) then
       nlo_settings%combined_integration = combined_integration
    else
       nlo_settings%combined_integration = &
             var_list%get_lval (var_str("?combined_nlo_integration"))
    end if
    nlo_settings%test_soft_limit = var_list%get_lval (var_str ('?test_soft_limit'))
    nlo_settings%test_coll_limit = var_list%get_lval (var_str ('?test_coll_limit'))
    nlo_settings%test_anti_coll_limit = var_list%get_lval (var_str ('?test_anti_coll_limit'))
    nlo_settings%fixed_alr = var_list%get_ival (var_str ('fixed_alpha_region'))
    nlo_settings%with_virtual_subtraction = &
       .not. var_list%get_lval (var_str ('?switch_off_virtual_subtraction'))
    nlo_settings%powheg_damping_scale = &
         var_list%get_rval (var_str ('powheg_damping_scale'))
  end subroutine nlo_settings_init

@ %def nlo_settings_init
@
<<nlo data: nlo settings: TBP>>=
  procedure :: write => nlo_settings_write
<<nlo data: procedures>>=
  subroutine nlo_settings_write (nlo_settings, unit)
    class(nlo_settings_t), intent(in) :: nlo_settings
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(A)') 'nlo_settings:'
    write (u, '(3X,A,L1)') 'internal_color_correlations = ', &
         nlo_settings%use_internal_color_correlations
    write (u, '(3X,A,L1)') 'internal_spin_correlations = ', &
         nlo_settings%use_internal_spin_correlations
    write (u, '(3X,A,L1)') 'use_resonance_mappings = ', &
         nlo_settings%use_resonance_mappings
    write (u, '(3X,A,L1)') 'combined_integration = ', &
         nlo_settings%combined_integration
    write (u, '(3X,A,L1)') 'with_virtual_subtraction = ', &
         nlo_settings%with_virtual_subtraction
    write (u, '(3X,A,L1)') 'test_soft_limit = ', &
         nlo_settings%test_soft_limit
    write (u, '(3X,A,L1)') 'test_coll_limit = ', &
         nlo_settings%test_coll_limit
    write (u, '(3X,A,L1)') 'test_anti_coll_limit = ', &
         nlo_settings%test_anti_coll_limit
    write (u, '(3X,A,I5)') 'fixed_alr = ', &
         nlo_settings%fixed_alr
    write (u, '(3X,A,I2)') 'factorization_mode = ', &
         nlo_settings%factorization_mode
    write (u, '(3X,A,' // FMT_15 // ')') 'powheg_damping_scale = ', &
         nlo_settings%powheg_damping_scale
  end subroutine nlo_settings_write

@ %def nlo_settings_write
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Contribution of divergencies due to PDF Evolution}
The origin of these contributions is a bit tricky to understand, because we cannot understand the
initial-state real collinear contributions without also taking into account the evolution
of parton density functions at $\mathcal{O}(\alpha_s)$. The NLO PDF evolution is given by
\begin{equation}
  \label{eqn:pdf_nlo}
  f (\bar{x}) = \int_0^1 \int_0^1 dx dz f(x) \Gamma(z) \delta (\bar{x} - x z),
\end{equation}
where $\Gamma$ are the DGLAP evolution kernels for an $a \to d$ splitting,
\begin{equation}
  \label{eqn:dglap}
  \Gamma_a^{(d)} = \delta_{ad}\delta(1-x) - \frac{\alpha_s}{2\pi} \left(\frac{1}{\epsilon} P_{ad}(x,0) - K_{ad}(x)\right) + \mathcal{O}(\alpha_s).
\end{equation}
$K_{ad}$ is a renormalization scheme matching factor, which is exactly zero in $\bar{MS}$. Let the leading-order hadronic cross section be given by
\begin{equation}
  \label{eqn:xsec_hadro_lo}
  d\sigma^{(0)}(s) = \int dx_\oplus dx_\ominus f_\oplus (x_\oplus) f_\ominus (x_\ominus) d\tilde{\sigma}^{(0)} (x_\oplus x_\ominus s),
\end{equation}
then the NLO hadronic cross section is
\begin{equation}
  \label{eqn:xsec_hadro_nlo}
  d\sigma^{(1)}(s) = \int dx_\oplus dx_\ominus dz_\oplus dz_\ominus f_\oplus (x_\oplus) f_\ominus (x_\ominus)
                     \underbrace{\Gamma_\oplus (z_\oplus) \Gamma_\ominus (z_\ominus) d\tilde{\sigma}^{(1)} (z_\oplus z_\ominus s)}_{d\hat{\sigma}^{(1)}}.
\end{equation}
$d\hat{\sigma}$ is called the subtracted partonic cross section. Expanding in $\alpha_s$ we find
\begin{align}
  d\hat{\sigma}^{(0)}_{ab}(k_1, k_2) &= d\tilde{\sigma}_{ab}^{(0)} (k_1, k_2), \\
  d\hat{\sigma}^{(1)}_{ab}(k_1, k_2) &= d\tilde{\sigma}_{ab}^{(1)} (k_1, k_2) \\
                                     &+ \frac{\alpha_s}{2\pi} \sum_d \int dx \left (\frac{1}{\epsilon} P_{da}(x,0) - K_{da}(x)\right) d\tilde{\sigma}_{db}^{(0)}(xk_1, k_2)\\
                                     &+ \frac{\alpha_s}{2\pi} \sum_d \int \left (\frac{1}{\epsilon} P_{db} (x, 0) - K_{db}(x)\right) d\tilde{\sigma}_{ad}^{(0)}(k_1, xk_2).\\
                                     &= d\tilde{\sigma}_{ab}^{(1)} + d\tilde{\sigma}_{ab}^{(cnt,+)} + d\tilde{\sigma}_{ab}^{(cnt,-)}
\end{align}

Let us now turn the soft-subtracted real part of the cross section. For ease of notation, it is constrained to one singular region,
\begin{align*}
  \label{eqn:R-in}
  d\sigma^{(in)}_\alpha &= \left[\left(\frac{1}{\xi}\right)_+ - 2\epsilon\left(\frac{\log \xi}{\xi}\right)_+\right] (1-y^2)\xi^2 \mathcal{R}_\alpha \mathcal{S}_\alpha \\
                 &\times  \frac{1}{2(2\pi)^{3-2\epsilon}} \left(\frac{\sqrt{s}}{2}\right)^{2-2\epsilon} \left( 1 - y^2\right)^{-1-\epsilon} d\phi d\xi dy d\Omega^{2-2\epsilon},
\end{align*}
where we regularize collinear divergencies using the identity
\begin{equation*}
  \left (1 - y^2 \right)^{-1-\epsilon} = -\frac{2^{-\epsilon}}{\epsilon} \left (\delta(1-y) + \delta(1+y)\right)
     + \underbrace{\frac{1}{2} \left[ \left (\frac {1}{1-y}\right)_+ + \left (\frac{1}{1+y}\right)_+ \right]}_{\mathcal{P}(y)}.
\end{equation*}
This enables us to split the cross section into a finite and a singular part. The latter can further be separated into a contribution of the incoming and of the outgoing particles,
\begin{equation*}
  d\sigma^{(in)}_\alpha = d\sigma^{(in,+)}_\alpha + d\sigma^{(in,-)}_\alpha + d\sigma^{(in,f)}_\alpha.
\end{equation*}
They are given by
\begin{align}
  \label{eqn:sigma-f}
  d\sigma^{(in,f)}_\alpha = & \mathcal{P}(y) \left[\left(\frac{1}{\xi}\right)_+ - 2\epsilon \left(\frac{\log\xi}{\xi}\right)_+\right] \frac{1}{2(2\pi)^{3-2\epsilon}}
     \left(\frac{\sqrt{s}}{2}\right)^{2-2\epsilon} \\
     & \times (1-y^2)\xi^2 \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi d\xi dy d\Omega^{2-2\epsilon}
\end{align}
and
\begin{align}
  \label{eqn:sigma-pm}
  d\sigma^{(in,\pm)}_\alpha &= -\frac{2^{-\epsilon}}{\epsilon} \delta (1 \mp y) \left[ \left( \frac{1}{\xi}\right)_+ - 2\epsilon \left(\frac{\log\xi}{\xi}\right)_+\right] \\
                    & \times \frac{1}{2(2\pi)^{3-2\epsilon}} \left( \frac{\sqrt{s}}{2}\right)^{2-2\epsilon} (1-y^2)\xi^2 \mathcal{R}_\alpha \mathcal{S}_\alpha d\phi d\xi dy d\Omega^{2-2\epsilon}.
\end{align}
Equation \ref{eqn:sigma-f} is the contribution to the real cross section which is computed in [[evaluate_region_isr]]. It is regularized both in the soft and collinear limit via the plus distributions.
Equation \ref{eqn:sigma-pm} is a different contribution. It is only present exactly in the collinear limit, due to the delta function. The divergences present in this term do not completely cancel out
divergences in the virtual matrix element, because the beam axis is distinguished. Thus, the conditions in which the KLM theorem applies are not met. To see this, we carry out the collinear limit, obtaining
\begin{equation*}
  \lim_{y \to 1} (1-y^2)\xi^2\mathcal{R}_\alpha = 8\pi\alpha_s \mu^{2\epsilon} \left(\frac{2}{\sqrt{s}}\right)^2 \xi P^<(1-\xi, \epsilon) \mathcal{R}_\alpha,
\end{equation*}
with the Altarelli-Parisi splitting kernel for $z < 1$, $P^<(z,\epsilon)$. Moreover, $\lim_{\vec{k} \parallel \vec{k}_1} d\phi = d\phi_3$ violates spatial averaging. The integration over the spherical angle $d\Omega$ can be carried out easily, yielding a factor of $2\pi^{1-\epsilon} / \Gamma(1-\epsilon)$.
This allows us to redefine $\epsilon$,
\begin{equation}
  \frac{1}{\epsilon} - \gamma_E + \log(4\pi) \to \frac{1}{\epsilon}.
\end{equation}
In order to make a connection to $d\tilde{\sigma}^{(cnt,\pm)}$, we relate $P_{ab}(z,0)$ to $P^<_{ab}(z,0)$ via the equation
\begin{equation*}
  P_{ab}(z,0) = (1-z)P_{ab}^<(z,0)\left(\frac{1}{1-z}\right)_+ + \gamma(a)\delta_{ab}\delta(1-z),
\end{equation*}
which yields
\begin{equation}
  d\tilde{\sigma}^{(cnt,+)} = \frac{\alpha_s}{2\pi} \sum_d \left\lbrace -K_{da}(1-\xi) + \frac{1}{\epsilon} \left[\left(\frac{1}{\xi}\right)_+ \xi P_{da}^<(1-\xi,0)
                           + \delta_{da}\delta(\xi)\gamma(d)\right]\right\rbrace \mathcal{R}_\alpha \mathcal{S}_\alpha.
\end{equation}
This term has the same pole structure as eqn. \ref{eqn:sigma-pm}. This makes clear that the quantity
\begin{equation}
  d\hat{\sigma}^{(in,+)} = d\tilde{\sigma}^{(in,+)} + \frac{1}{4} d\tilde{\sigma}^{(cnt,+)}
\end{equation}
has no collinear poles. Therefore, our task is to add up eqns. \ref{eqn:sigma-pm} and \ref{???} in order to compute the finite remainder. This is the integrand which is evaluated in the [[dglap_remnant]] component.\\
So, we have to perform an expansion of $d\hat{\sigma}^{(in,+)}$ in $\epsilon$. Hereby, we must not neglect the implicit $\epsilon$-dependence of $P^<$, which leads to additional terms involving the
first derivative,
\begin{equation*}
  P_{ab}^<(z,\epsilon) = P_{ab}^<(z,0) + \epsilon \frac{\partial P_{ab}^<(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} + \mathcal{O}(\alpha_s^2).
\end{equation*}
This finally gives us the equation for the collinear remnant. Note that there is still one soft $1/\epsilon$-pole, which cancels out with the corresponding expression in the soft-virtual terms.
\begin{align}
  d\hat{\sigma}^{(in,+)} &= \frac{\alpha_s}{2\pi} \frac{1}{\epsilon} \gamma(a) \mathcal{R}_\alpha \mathcal{S}_\alpha \\
                         &+ \frac{\alpha_s}{2\pi} \sum_d \left\lbrace (1-z) P_{da}^<(z,0)\left[\left(\frac{1}{1-z}\right)_+ \log\frac{s}{\mu^2} + 2 \left(\frac{\log(1-z)}{1-z}\right)_+\right] \right .\\
                         &\left . -(1-z)\frac{\partial P_{da}^<(z,\epsilon)}{\partial \epsilon} \left(\frac{1}{1-z}\right)_+ - K_{da}(z)\right\rbrace \mathcal{R}_\alpha \mathcal{S}_\alpha
\end{align}

<<[[dglap_remnant.f90]]>>=
<<File header>>

module dglap_remnant

<<Use kinds with double>>
<<Use strings>>
  use numeric_utils
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use diagnostics
  use constants
  use physics_defs
  use pdg_arrays
  use sf_lhapdf
  use pdf
  use phs_fks, only: isr_kinematics_t

  use nlo_data

<<Standard module head>>

<<dglap remnant: public>>

<<dglap remnant: types>>

contains

<<dglap remnant: procedures>>

end module dglap_remnant

@ %def module dglap_remnant
@
<<dglap remnant: public>>=
  public :: dglap_remnant_t
<<dglap remnant: types>>=
  type :: dglap_remnant_t
    type(pdf_data_t) :: pdf_data
    type(isr_kinematics_t), pointer :: isr_kinematics => null ()
    integer, dimension(:), allocatable :: i_light_quarks
    integer, dimension(2) :: flv_in
    type(pdf_container_t), dimension(2) :: pdf_scaled
    type(pdf_container_t), dimension(2) :: pdf_born
    real(default), dimension(:), pointer :: sqme_born => null ()
  contains
  <<dglap remnant: dglap remnant: TBP>>
  end type dglap_remnant_t

@ %def dglap_remnant_t
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: init => dglap_remnant_init
<<dglap remnant: procedures>>=
  subroutine dglap_remnant_init (dglap, isr_kinematics, flv, n_alr)
    class(dglap_remnant_t), intent(inout) :: dglap
    type(isr_kinematics_t), intent(in), target :: isr_kinematics
    integer, dimension(:,:), intent(in) :: flv
    integer, intent(in) :: n_alr
    integer :: i, j, n_quarks
    logical, dimension(-6:6) :: quark_checked = .false.

    dglap%isr_kinematics => isr_kinematics
    call dglap%set_incoming_flavor (flv(1,1), flv(2,1))
    n_quarks = 0
    do i = 1, size (flv, dim = 1)
       if (is_quark(flv(i,1))) then
          n_quarks = n_quarks + 1
          quark_checked(flv(i, 1)) = .true.
       end if
    end do
    allocate (dglap%i_light_quarks (n_quarks))
    j = 1
    do i = -6, 6
       if (quark_checked(i)) then
          dglap%i_light_quarks(j) = i
          j = j + 1
       end if
    end do

    call dglap%init_pdfs ()
  end subroutine dglap_remnant_init

@ %def dglap_remnant_init
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: set_incoming_flavor => dglap_remnant_set_incoming_flavor
<<dglap remnant: procedures>>=
  subroutine dglap_remnant_set_incoming_flavor (dglap, flv1, flv2)
    class(dglap_remnant_t), intent(inout) :: dglap
    integer, intent(in) :: flv1, flv2
    dglap%flv_in(1) = flv1; dglap%flv_in(2) = flv2
  end subroutine dglap_remnant_set_incoming_flavor

@ %def dglap_remnant_set_incoming_flavor
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: init_pdfs => dglap_remnant_init_pdfs
<<dglap remnant: procedures>>=
  subroutine dglap_remnant_init_pdfs (dglap)
    class(dglap_remnant_t), intent(inout) :: dglap
    type(string_t) :: lhapdf_dir, lhapdf_file
    integer :: lhapdf_member
    lhapdf_dir = ""
    lhapdf_file = ""
    lhapdf_member = 0
    if (LHAPDF6_AVAILABLE) then
       call lhapdf_initialize &
            (1, lhapdf_dir, lhapdf_file, lhapdf_member, dglap%pdf_data%pdf)
       associate (pdf_data => dglap%pdf_data)
          pdf_data%type = STRF_LHAPDF6
          pdf_data%xmin = pdf_data%pdf%getxmin ()
          pdf_data%xmax = pdf_data%pdf%getxmax ()
          pdf_data%qmin = sqrt(pdf_data%pdf%getq2min ())
          pdf_data%qmax = sqrt(pdf_data%pdf%getq2max ())
       end associate
    else
       call msg_fatal ("PDF subtraction: PDFs could not be initialized")
    end if
  end subroutine dglap_remnant_init_pdfs

@ %def dglap_remnant_init_pdfs
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: compute_pdfs => dglap_remnant_compute_pdfs
<<dglap remnant: procedures>>=
  subroutine dglap_remnant_compute_pdfs (dglap)
    class(dglap_remnant_t), intent(inout) :: dglap
    integer :: i
    real(default) :: z, x, Q
    real(double), dimension(-6:6) :: f_dble = 0._double
    Q = dglap%isr_kinematics%fac_scale
    do i = 1, 2
       x = dglap%isr_kinematics%x(i)
       z = dglap%isr_kinematics%z(i)
       call dglap%pdf_data%evolve (dble(x), dble(Q), f_dble)
       dglap%pdf_born(i)%f = f_dble / dble(x)
       call dglap%pdf_data%evolve (dble(x / z), dble(Q), f_dble)
       dglap%pdf_scaled(i)%f = f_dble / dble(x / z)
    end do
  end subroutine dglap_remnant_compute_pdfs

@ %def dglap_remnant_compute_pdfs
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: get_gluon_pdf => dglap_remnant_get_gluon_pdf
<<dglap remnant: procedures>>=
  function dglap_remnant_get_gluon_pdf (dglap, em, scaled) result (pdf)
    class(dglap_remnant_t), intent(in) :: dglap
    integer, intent(in) :: em
    logical, intent(in) :: scaled
    real(default) :: pdf
    if (scaled) then
       pdf = dglap%pdf_scaled(em)%f(0)
    else
       pdf = dglap%pdf_born(em)%f(0)
    end if
  end function dglap_remnant_get_gluon_pdf

@ %def dglap_remnant_get_gluon_pdf
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: get_quark_pdf => dglap_remnant_get_quark_pdf
<<dglap remnant: procedures>>=
  function dglap_remnant_get_quark_pdf (dglap, em, i, scaled) result (pdf)
    class(dglap_remnant_t), intent(in) :: dglap
    integer, intent(in) :: em, i
    logical, intent(in) :: scaled
    real(default) :: pdf
    if (scaled) then
       pdf = dglap%pdf_scaled(em)%f(i)
    else
       pdf = dglap%pdf_born(em)%f(i)
    end if
  end function dglap_remnant_get_quark_pdf

@ %def dglap_remnant_get_quark_pdf
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: get_summed_quark_pdf => dglap_remnant_get_summed_quark_pdf
<<dglap remnant: procedures>>=
  function dglap_remnant_get_summed_quark_pdf (dglap, em) result (pdf)
    class(dglap_remnant_t), intent(in) :: dglap
    integer, intent(in) :: em
    real(default) :: pdf
    integer :: i_quark
    pdf = 0._default
    do i_quark = -6, 6
       if (any(i_quark == dglap%i_light_quarks)) &
          pdf = pdf + dglap%get_quark_pdf(em, i_quark, scaled = .true.)
    end do
  end function dglap_remnant_get_summed_quark_pdf

@ %def dglap_remnant_get_summed_quark_pdf
@ Evaluates formula (...). Note that, as also is the case for the real subtraction,
we have to take into account an additional term, occuring because the integral the
plus distribution is evaluated over is not constrained on the interval $[0,1]$.
Explicitly, this means
\begin{equation}
  \int_{\bar{x}_\oplus}^1 dz \left( \frac{1}{1-z} \right)_+ = \log(1-\bar{x}_\oplus)f(1) + \int_{\bar{x}_\oplus}^1 \frac{f(z) - f(1)}{1-z},
\end{equation}
and
\begin{equation}
  \int_{\bar{x}_\oplus}^1 dz \left(\frac{\log(1-z)}{1-z}\right)_+ f(z) = \frac{1}{2}\log^2(1-\bar{x}_\oplus) f(1)
   + \int_{\bar{x}_\oplus}^1 \frac{\log(1-z)[f(z) - f(1)]}{1-z},
\end{equation}
and the same of course for $\bar{x}_\ominus$. These two terms are stored in the [[plus_dist_remnant]] variable below.
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: evaluate => dglap_remnant_evaluate
<<dglap remnant: procedures>>=
  function dglap_remnant_evaluate (dglap, alpha_s, sqme_born) result (sqme_dglap)
    real(default) :: sqme_dglap
    class(dglap_remnant_t), intent(inout) :: dglap
    real(default), intent(in) :: alpha_s
    real(default), intent(in) :: sqme_born
    real(default) :: factor, factor_soft, plus_dist_remnant
    real(default) :: pdfs, pdfb
    integer :: emitter
    real(default), dimension(2) :: tmp
    real(default) :: sb, xb, onemz
    real(default) :: fac_scale2, jac

    sb = dglap%isr_kinematics%sqrts_born**2
    tmp = zero
    fac_scale2 = dglap%isr_kinematics%fac_scale**2

    call dglap%compute_pdfs ()

    do emitter = 1, 2
       associate (z => dglap%isr_kinematics%z(emitter))
          jac = dglap%isr_kinematics%jacobian(emitter)
          onemz = one - z
          factor = log(sb / z / fac_scale2) / onemz + two * log(onemz) / onemz
          factor_soft = log(sb / fac_scale2) / onemz + two * log(onemz) / onemz

          xb = dglap%isr_kinematics%x(emitter)
          plus_dist_remnant = log(one - xb) * log(sb / fac_scale2) + log(one - xb)**2

          if (is_gluon(dglap%flv_in(emitter))) then
             pdfs = dglap%get_gluon_pdf (emitter, scaled = .true.)
             pdfb = dglap%get_gluon_pdf (emitter, scaled = .false.)
             tmp(emitter) = p_hat_gg(z) * factor / z * pdfs / pdfb * jac &
                  - p_hat_gg(one) * factor_soft * jac &
                  + p_hat_gg(one) * plus_dist_remnant
             pdfs = dglap%get_summed_quark_pdf (emitter)
             tmp(emitter) = tmp(emitter) + &
                  (p_hat_qg(z) * factor - p_derived_qg(z)) / z * pdfs / pdfb * jac
          else if (is_quark(dglap%flv_in(emitter))) then
             pdfs = dglap%get_quark_pdf (emitter, dglap%flv_in(emitter), scaled = .true.)
             pdfb = dglap%get_quark_pdf (emitter, dglap%flv_in(emitter), scaled = .false.)
             if (vanishes (pdfb)) then
                sqme_dglap = zero
                return
             end if
             tmp(emitter) = p_hat_qq(z) * factor / z * pdfs / pdfb * jac &
                  - p_derived_qq(z) / z * pdfs / pdfb * jac &
                  - p_hat_qq(one) * factor_soft * jac &
                  + p_hat_qq(one) * plus_dist_remnant
             pdfs = dglap%get_gluon_pdf (emitter, scaled = .true.)
             tmp(emitter) = tmp(emitter) + &
                  (p_hat_gq(z) * factor - p_derived_gq(z)) / z * pdfs / pdfb * jac
          end if
       end associate
    end do
    sqme_dglap = alpha_s / twopi * (tmp(1) + tmp(2)) * sqme_born
  end function dglap_remnant_evaluate

@ %def dglap_remnant_evaluate
@
\begin{equation}
    \hat{P}^{gg}(z) = 2C_A \left[z + \frac{(1-z)^2}{z} + z(1-z)^2\right]
\end{equation}
<<dglap remnant: procedures>>=
  function p_hat_gg (z)
    real(default) :: p_hat_gg
  <<p variables>>
    p_hat_gg = two * CA * (z + onemz**2 / z + z * onemz**2)
  end function p_hat_gg

@ %def p_hat_gg
@
\begin{equation}
  \hat{P}^{qg}(z) = C_F (1-z) \frac{1 + (1-z)^2}{z}
\end{equation}
<<dglap remnant: procedures>>=
  function p_hat_qg (z)
    real(default) :: p_hat_qg
  <<p variables>>
    p_hat_qg = CF * onemz / z * (one + onemz**2)
  end function p_hat_qg

@ %def p_hat_qg
@
\begin{equation}
  \hat{P}^{gq}(z) = T_F (1 - z - 2z(1-z)^2)
\end{equation}
<<dglap remnant: procedures>>=
  function p_hat_gq (z)
    real(default) :: p_hat_gq
  <<p variables>>
    p_hat_gq = TR * (onemz - two * z * onemz**2)
  end function p_hat_gq

@ %def p_hat_gq
@
\begin{equation}
  \hat{P}^{qq}(z) = C_F (1 + z^2)
\end{equation}
<<dglap remnant: procedures>>=
  function p_hat_qq (z)
    real(default) :: p_hat_qq
    real(default), intent(in) :: z
    p_hat_qq = CF * (one + z**2)
  end function p_hat_qq

@ %def p_hat_qq
@
\begin{equation}
  \frac{\partial P^{gg}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} = 0
\end{equation}
<<dglap remnant: procedures>>=
  function p_derived_gg (z)
    real(default) :: p_derived_gg
    real(default), intent(in) :: z
    p_derived_gg = zero
  end function p_derived_gg

@ %def p_derived_gg
@
\begin{equation}
  \frac{\partial P^{qg}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} = -C_F z
\end{equation}
<<dglap remnant: procedures>>=
  function p_derived_qg (z)
    real(default) :: p_derived_qg
    real(default), intent(in) :: z
    p_derived_qg = -CF * z
  end function p_derived_qg

@ %def p_derived_qg
@
\begin{equation}
  \frac{\partial P^{gq}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} = - 2 T_F z (1-z)
\end{equation}
<<dglap remnant: procedures>>=
  function p_derived_gq (z)
    real(default) :: p_derived_gq
  <<p variables>>
    p_derived_gq = -two * TR * z * onemz
  end function p_derived_gq

@ %def p_derived_gq
@
\begin{equation}
   \frac{\partial P^{gq}(z,\epsilon)}{\partial \epsilon}|_{\epsilon = 0} = -C_F (1-z)
\end{equation}
<<dglap remnant: procedures>>=
  function p_derived_qq (z)
    real(default) :: p_derived_qq
  <<p variables>>
    p_derived_qq = -CF * onemz
  end function p_derived_qq

@ %def p_derived_qq
@
<<p variables>>=
  real(default), intent(in) :: z
  real(default) :: onemz
  onemz = one - z

@ %def variables
@
<<dglap remnant: dglap remnant: TBP>>=
  procedure :: final => dglap_remnant_final
<<dglap remnant: procedures>>=
  subroutine dglap_remnant_final (dglap)
    class(dglap_remnant_t), intent(inout) :: dglap
    if (associated (dglap%isr_kinematics)) nullify (dglap%isr_kinematics)
    if (allocated (dglap%i_light_quarks)) deallocate (dglap%i_light_quarks)
    if (associated (dglap%sqme_born)) deallocate (dglap%sqme_born)
  end subroutine dglap_remnant_final

@ %def dglap_remnant_final
@
\section{Dispatch}
@
<<[[dispatch_fks.f90]]>>=
<<File header>>

module dispatch_fks

<<Use kinds>>
<<Use strings>>
  use string_utils, only: split_string
  use variables, only: var_list_t
  use nlo_data, only: fks_template_t, FKS_DEFAULT, FKS_RESONANCES

<<Standard module head>>

<<Dispatch fks: public>>

contains

<<Dispatch fks: procedures>>

end module dispatch_fks
@ %def dispatch_fks
@ Initialize parameters used to optimize FKS calculations.
<<Dispatch fks: public>>=
  public :: dispatch_fks_s
<<Dispatch fks: procedures>>=
  subroutine dispatch_fks_s (fks_template, var_list)
    type(fks_template_t), intent(inout) :: fks_template
    type(var_list_t), intent(in) :: var_list
    real(default) :: fks_dij_exp1, fks_dij_exp2
    type(string_t) :: fks_mapping_type
    logical :: subtraction_disabled
    type(string_t) :: exclude_from_resonance
    fks_dij_exp1 = &
       var_list%get_rval (var_str ("fks_dij_exp1"))
    fks_dij_exp2 = &
       var_list%get_rval (var_str ("fks_dij_exp2"))
    fks_mapping_type = &
       var_list%get_sval (var_str ("$fks_mapping_type"))
    subtraction_disabled = &
       var_list%get_lval (var_str ("?disable_subtraction"))
    exclude_from_resonance = &
       var_list%get_sval (var_str ("$resonances_exclude_particles"))
    if (exclude_from_resonance /= var_str ("default")) &
       call split_string (exclude_from_resonance, var_str (":"), &
       fks_template%excluded_resonances)
    call fks_template%set_dij_exp (fks_dij_exp1, fks_dij_exp2)
    select case (char (fks_mapping_type))
    case ("default")
       call fks_template%set_mapping_type (FKS_DEFAULT)
    case ("resonances")
       call fks_template%set_mapping_type (FKS_RESONANCES)
    end select
    if (subtraction_disabled) call fks_template%disable_subtraction ()
  end subroutine dispatch_fks_s

@ %def dispatch_fks_s
@
