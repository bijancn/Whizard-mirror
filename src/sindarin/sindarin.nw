% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: Sindarin


\chapter{Sindarin}

\begin{description}
\item[codes]
  Elementary codes and parameters used by the Sindarin modules.
\item[builders]
  Abstract builder that makes use of bytecode.
\item[object\_base]
  Basic objects and methods.
\item[object\_builder]
  Enables building and decoding of objects via bytecode.
\item[object\_expr]
  Statements, assignment, expressions and operators.
\item[object\_logical]
  Logical values and expressions.
\item[sindarin\_parser]
  Parse Sindarin code and transform into bytecode and object tree.
\end{description}

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Codes}
This module contains predefined numerical codes.  It also introduces
[[code_t]] as a universal non-recursive representations for objects.
<<[[codes.f90]]>>=
<<File header>>

module codes
  
<<Use strings>>
<<Use kinds>>
  use unit_tests
  use io_units

<<Standard module head>>

<<Codes: public>>

<<Codes: parameters>>

<<Codes: types>>
  
<<Codes: interfaces>>

contains
  
<<Codes: procedures>>

<<Codes: tests>>

end module codes
@ %def codes
@
\subsection{Navigation}
These codes are useful for navigation within an object tree, they represent
locations within a (composite) object.
<<Codes: parameters>>=
  integer, parameter, public :: POS_NONE = -1
  integer, parameter, public :: POS_HERE = 0
  integer, parameter, public :: POS_ID = 1
  integer, parameter, public :: POS_CORE = 2
  integer, parameter, public :: POS_MEMBER = 3
  integer, parameter, public :: POS_PRIMER = 4

@ %def POS_NONE POS_HERE POS_ID POS_CORE POS_MEMBER POS_PRIMER
@ The [[position_t]] object combines a location code with an arbitrary integer
counter.   The type is kept public and transparent.
<<Codes: public>>=
  public :: position_t
<<Codes: types>>=
  type :: position_t
     integer :: part = POS_HERE
     integer :: i = 0
   contains
   <<Codes: position: TBP>>
  end type position_t

@ %def position_t
<<Codes: position: TBP>>=
  procedure :: write => position_write
<<Codes: procedures>>=
  subroutine position_write (position, unit)
    class(position_t), intent(in) :: position
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    select case (position%part)
    case (POS_NONE)
       write (u, "(1x,'-')", advance="no")
    case (POS_HERE)
       write (u, "(1x,'H')", advance="no")
    case (POS_ID)
       write (u, "(1x,'I')", advance="no")
    case (POS_CORE)
       write (u, "(1x,'C')", advance="no")
    case (POS_MEMBER)
       write (u, "(1x,'M',I0)", advance="no")  position%i
    case (POS_PRIMER)
       write (u, "(1x,'P',I0)", advance="no")  position%i
    case default
       write (u, "(1x,'?')", advance="no")
    end select
  end subroutine position_write

@ %def position_write
@
\subsection{Object categories}
Category codes for atomic objects.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_TAG = 1
  integer, parameter, public :: CAT_VALUE = 2
  integer, parameter, public :: CAT_ID = 3

@ %def CAT_TAG CAT_VALUE CAT_ID
@ Reference object.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_REFERENCE = 99

@ %def CAT_REFERENCE
@ Category code for a composite object.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_COMPOSITE = 100

@ %def CAT_COMPOSITE
@ 
\subsection{Priority values}
A list of predefined priorities.  The default
priority for atomic objects is zero, so operators get negative values.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_NOT = -100
  integer, parameter, public :: PRIO_AND = -101
  integer, parameter, public :: PRIO_OR  = -102
  
@ %def PRIO_NOT PRIO_AND PRIO_OR
@
\subsection{Minimal value container}
The universal code for an object allows us to construct and transfer objects
via a list of code numbers and elementary values.  We provide value containers
in form of one-dimensional arrays which may be of any of the elementary
Fortran types.

Compiler compatibility prohibits a polymorphic value array.  Instead, we store
an array inside the polymorphic value object.
<<Codes: types>>=
  type, abstract :: val_t
   contains
   <<Codes: val: TBP>>
  end type val_t
  
@ %def val_t
@ Each concrete value type has a unique type code.
<<Codes: val: TBP>>=
  procedure(val_get_type), deferred :: get_type
<<Codes: interfaces>>=
  abstract interface
     function val_get_type (val) result (t)
       import
       class(val_t), intent(in) :: val
       integer :: t
     end function val_get_type
  end interface
  
@ %def val_get_type
@ The initializer has to allocate the array.
<<Codes: val: TBP>>=
  procedure(val_init), deferred :: init
<<Codes: interfaces>>=
  abstract interface
     subroutine val_init (val, nval)
       import
       class(val_t), intent(out) :: val
       integer, intent(in) :: nval
     end subroutine val_init
  end interface
  
@ %def val_init
@ Return array size.
<<Codes: val: TBP>>=
  procedure(val_get_nval), deferred :: get_nval
<<Codes: interfaces>>=
  abstract interface
     function val_get_nval (val) result (nval)
       import
       class(val_t), intent(in) :: val
       integer :: nval
     end function val_get_nval
  end interface
  
@ %def val_get_nval
@ Each concrete value must have an input and an output method.  We read/write
one value entry at a time.
<<Codes: val: TBP>>=
  procedure(val_read), deferred :: read
  procedure(val_write), deferred :: write
<<Codes: interfaces>>=
  abstract interface
     subroutine val_read (val, unit, i, iostat)
       import
       class(val_t), intent(inout) :: val
       integer, intent(in) :: unit, i
       integer, intent(out), optional :: iostat
     end subroutine val_read
  end interface
       
  abstract interface
     subroutine val_write (val, unit, i)
       import
       class(val_t), intent(in) :: val
       integer, intent(in) :: unit, i
     end subroutine val_write
  end interface
       
@ %def val_read 
@ %def val_write
@
\subsection{Universal code}
The code object consists of a category code which determines the
interpretation, a number of integer attribute codes, and an optional value.
For the attributes, we use a fixed-size array for simplicity.

We deliberately make all components public.
<<Codes: parameters>>=
  integer, parameter :: NATT_MAX = 16
  integer, parameter :: NAME_LEN_MAX = 256
  
<<Codes: public>>=
  public :: code_t
<<Codes: types>>=
  type :: code_t
     integer :: cat = 0
     integer :: natt = 0
     integer, dimension(NATT_MAX) :: att = 0
     class(val_t), allocatable :: val
   contains
   <<Codes: code: TBP>>
  end type code_t
     
@ %def code_t
@ Methods for input and output.  We mostly read integers.
<<Codes: code: TBP>>=
  procedure :: read => code_read
  procedure :: write => code_write
<<Codes: procedures>>=
  subroutine code_read (code, unit, iostat)
    class(code_t), intent(out) :: code
    integer, intent(in) :: unit
    integer, intent(out), optional :: iostat
    logical :: err
    integer :: cat, vt, nval, natt, i
    err = .false.
    if (present (iostat)) then
       read (unit, *, iostat=iostat) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
       call check;  if (err)  return
    else
       read (unit, *) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
    end if
    code%cat = cat
    code%natt = natt
    if (vt > 0) then
       call code%create_val (code%val, vt, nval)
       do i = 1, nval
          call code%val%read (unit, i, iostat=iostat)
          if (present (iostat))  call check;  if (err)  return
       end do
    end if
  contains
    subroutine check
      err = iostat /= 0
    end subroutine check
  end subroutine code_read
    
  subroutine code_write (code, unit, iostat, verbose)
    class(code_t), intent(in) :: code
    integer, intent(in), optional :: unit
    integer, intent(out), optional :: iostat
    logical, intent(in), optional :: verbose
    logical :: verb
    integer :: natt, nval, i, u
    u = given_output_unit (unit)
    verb = .false.; if (present (verbose))  verb = verbose
    if (verb)  write (u, "(1x,A,1x)", advance="no")  "c="
    write (u, "(I0)", advance="no")  code%cat
    if (verb)  write (u, "(2x,A)", advance="no")  "vt="
    if (allocated (code%val)) then
       write (u, "(1x,I0)", advance="no")  code%val%get_type ()
       nval = code%val%get_nval ()
    else
       write (u, "(1x,I0)", advance="no")  0
       nval = 0
    end if
    if (verb)  write (u, "(2x,A)", advance="no")  "nv="
    write (u, "(1x,I0)", advance="no")  nval
    natt = code%natt
    if (.not. verb)  write (u, "(1x,I0)", advance="no")  natt
    if (natt > 0) then
       if (verb)  write (u, "(2x,A)", advance="no")  "att="
       write (u, "(*(1x,I0,:))")  code%att(1:natt)
    else
       write (u, *)
    end if
    do i = 1, nval
       if (verb)  write (u, "(5x)", advance="no")
       call code%val%write (u, i)
    end do
  end subroutine code_write
    
@ %def code_read
@ %def code_write
@
\subsection{Concrete value types}
These are the Fortran elementary types that we allow.

\subsubsection{Logical}
<<Codes: public>>=
  public :: val_logical_t
<<Codes: types>>=
  type, extends (val_t) :: val_logical_t
     logical, dimension(:), allocatable :: x
   contains
   <<Codes: val logical: TBP>>
  end type val_logical_t
     
@ %def val_logical_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_LOGICAL = 1
<<Codes: val cases>>=
  case (VT_LOGICAL);  allocate (val_logical_t :: val)
<<Codes: val logical: TBP>>=
  procedure :: get_type => val_logical_get_type
<<Codes: procedures>>=
  function val_logical_get_type (val) result (type)
    class(val_logical_t), intent(in) :: val
    integer :: type
    type = VT_LOGICAL
  end function val_logical_get_type
  
@ %def val_logical_get_type
@ Init.  Allocate the array.
<<Codes: val logical: TBP>>=
  procedure :: init => val_logical_init
<<Codes: procedures>>=
  subroutine val_logical_init (val, nval)
    class(val_logical_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_logical_init
  
@ %def val_logical_init
@ Return array size.
<<Codes: val logical: TBP>>=
  procedure :: get_nval => val_logical_get_nval
<<Codes: procedures>>=
  function val_logical_get_nval (val) result (nval)
    class(val_logical_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_logical_get_nval
  
@ %def val_logical_get_nval
@ I/O.  List-directed is ok.
<<Codes: val logical: TBP>>=
  procedure :: read => val_logical_read
  procedure :: write => val_logical_write
<<Codes: procedures>>=
  subroutine val_logical_read (val, unit, i, iostat)
    class(val_logical_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  val%x(i)
    else
       read (unit, *)  val%x(i)
    end if
  end subroutine val_logical_read
       
  subroutine val_logical_write (val, unit, i)
    class(val_logical_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(L1)")  val%x(i)
  end subroutine val_logical_write
       
@ %def val_logical_read 
@ %def val_logical_write
<<Codes: code: TBP>>=
  procedure :: create_logical_val
<<Codes: procedures>>=
  subroutine create_logical_val (code, item)
    class(code_t), intent(inout) :: code
    logical, intent(in) :: item
    call create_val (code%val, VT_LOGICAL, 1)
    select type (val => code%val)
    type is (val_logical_t);  val%x(1) = item
    end select
  end subroutine create_logical_val
  
@ %def create_logical_val
@
\subsubsection{String}
<<Codes: public>>=
  public :: val_string_t
<<Codes: types>>=
  type, extends (val_t) :: val_string_t
     type(string_t), dimension(:), allocatable :: x
   contains
   <<Codes: val string: TBP>>
  end type val_string_t
     
@ %def val_string_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_STRING = 2
<<Codes: val cases>>=
  case (VT_STRING);  allocate (val_string_t :: val)
<<Codes: val string: TBP>>=
  procedure :: get_type => val_string_get_type
<<Codes: procedures>>=
  function val_string_get_type (val) result (type)
    class(val_string_t), intent(in) :: val
    integer :: type
    type = VT_STRING
  end function val_string_get_type
  
@ %def val_string_get_type
@ Init.  Allocate the array.
<<Codes: val string: TBP>>=
  procedure :: init => val_string_init
<<Codes: procedures>>=
  subroutine val_string_init (val, nval)
    class(val_string_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_string_init
  
@ %def val_string_init
@ Return array size.
<<Codes: val string: TBP>>=
  procedure :: get_nval => val_string_get_nval
<<Codes: procedures>>=
  function val_string_get_nval (val) result (nval)
    class(val_string_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_string_get_nval
  
@ %def val_string_get_nval
@ I/O.  We rely on the size being allocated before, using an attribute index
for input.  We write one array entry per line.  The string length is limited
to [[NAME_LEN_MAX]]
<<Codes: val string: TBP>>=
  procedure :: read => val_string_read
  procedure :: write => val_string_write
<<Codes: procedures>>=
  subroutine val_string_read (val, unit, i, iostat)
    class(val_string_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    character(NAME_LEN_MAX) :: buffer
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  buffer
    else
       read (unit, *)  buffer
    end if
    val%x(i) = trim (adjustl (buffer))
  end subroutine val_string_read
       
  subroutine val_string_write (val, unit, i)
    class(val_string_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(A)")  char (val%x(i))
  end subroutine val_string_write
       
@ %def val_string_read 
@ %def val_string_write
<<Codes: code: TBP>>=
  procedure :: create_string_val
<<Codes: procedures>>=
  subroutine create_string_val (code, item)
    class(code_t), intent(inout) :: code
    type(string_t), intent(in) :: item
    call create_val (code%val, VT_STRING, 1)
    select type (val => code%val)
    type is (val_string_t);  val%x(1) = item
    end select
  end subroutine create_string_val
  
@ %def create_string_val
@
\subsection{Generic value constructor}
Depending on the value code, we allocate a specific value object.
<<Codes: code: TBP>>=
  procedure, nopass :: create_val
<<Codes: procedures>>=
  subroutine create_val (val, vt, nval)
    class(val_t), allocatable, intent(out) :: val
    integer, intent(in) :: vt, nval
    select case (vt)
  <<Codes: val cases>>
    end select
    call val%init (nval)
  end subroutine create_val
  
@ %def create_val
@ 
\subsection{Unit tests}
<<Codes: public>>=
  public :: codes_test
<<Codes: procedures>>=
  subroutine codes_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Codes: execute tests>>  
  end subroutine codes_test
  
@ %def codes_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Codes: execute tests>>=
  call test (codes_1, "codes_1", &
       "object codes: I/O", &
       u, results)
<<Codes: tests>>=  
  subroutine codes_1 (u)
    integer, intent(in) :: u
    integer :: utmp, i
    type(code_t) :: code
    character(256) :: buffer

    write (u, "(A)")  "* Test output: codes_1"
    write (u, "(A)")  "*   Purpose: check code I/O"
    write (u, "(A)")      

    utmp = free_unit ()
    open (utmp, status="scratch", action="readwrite")

    write (utmp, "(1x,A)")  "4 0 0 0"
    write (utmp, "(1x,A)")  "5 2 1 3 5 6 7"
    write (utmp, "(1x,A)")  "foo"
    write (utmp, "(1x,A)")  "7 1 2 0"
    write (utmp, "(1x,A)")  "T"
    write (utmp, "(1x,A)")  "F"
    
    rewind (utmp)
    do
       read (utmp, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (utmp)
    write (u, *)

    do i = 1, 3
       call code%read (utmp)
       call code%write (u, verbose=.true.)
    end do

    rewind (utmp)
    write (u, *)

    do i = 1, 3
       call code%read (utmp)
       call code%write (u)
    end do

    close (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: codes_1"
    
    end subroutine codes_1

@ %def codes_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Builder}
This module introduces an abstract type, designed for converting between
bytecode and an undefined kind of object tree.

The abstract type merely declares a finalizer, output, and one method for
building (from bytecode) and decoding (to bytecode), respectively.  We
implement a shortcut that converts between two builders.

Initialization, object extraction etc.\ will depend on the specific
implementations.
<<[[builders.f90]]>>=
<<File header>>

module builders

  use codes

<<Standard module head>>

<<Builder: public>>

<<Builder: types>>

<<Builder: interfaces>>

contains
  
<<Builder: procedures>>

end module builders
@ %def builders
@
\subsection{Abstract Type}
<<Builder: public>>=
  public :: builder_t
<<Builder: types>>=
  type, abstract :: builder_t
     private
   contains
   <<Builder: builder: TBP>>
  end type builder_t
   
@ %def builder_t
@ 
Finalizer:
<<Builder: builder: TBP>>=
  procedure(builder_final), deferred :: final
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_final (builder)
       import
       class(builder_t), intent(inout) :: builder
     end subroutine builder_final
  end interface

@ %def builder_final
@
Output:
<<Builder: builder: TBP>>=
  procedure(builder_write), deferred :: write
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_write (builder, unit)
       import
       class(builder_t), intent(in) :: builder
       integer, intent(in), optional :: unit
     end subroutine builder_write
  end interface

@ %def builder_write
@
\subsection{Decoding}
Decode the current object and advance to the next.  If there is no object
left, return [[.false.]]
<<Builder: builder: TBP>>=
  procedure(builder_decode), deferred :: decode
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_decode (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(out) :: code
       logical, intent(out) :: success
     end subroutine builder_decode
  end interface

@ %def builder_decode
@
\subsection{Building}
Take the current code and build a new object in the current location, then
advance.
<<Builder: builder: TBP>>=
  procedure(builder_build), deferred :: build
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_build (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(in) :: code
       logical, intent(out) :: success
     end subroutine builder_build
  end interface
    
@ %def builder_build
@
\subsection{Conversion}
Using bytecode as common language, we can directly copy/convert between two
builders.
<<Builder: builder: TBP>>=
  procedure :: copy => builder_copy
<<Builder: procedures>>=
  subroutine builder_copy (builder, builder_source, success)
    class(builder_t), intent(inout) :: builder
    class(builder_t), intent(inout) :: builder_source
    logical, intent(out) :: success
    type(code_t) :: code
    call builder_source%decode (code, success)
    if (.not. success)  return
    call builder%build (code, success)
  end subroutine builder_copy
    
@ %def builder_copy
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic objects}
This module implements the components of the actual object tree as a Sindarin
implementation.  We define
\begin{itemize}
\item
  Basic objects, abstract and completely generic
\item
  Tags as a trivial implementation
\item
  Abstract value objects
\item
  ID objects that allow object identification by name
\item
  Generic wrapper objects (for heterogeneous object arrays)
\item
  References to remote objects
\item
  Composite objects as the base for all more complex structures
\item
  Object repository that enable prototype handling
\item
  Object iterators for traversing an object tree structure
\end{itemize}
<<[[object_base.f90]]>>=
<<File header>>

module object_base

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use diagnostics
  use codes

<<Standard module head>>

<<Object base: public>>

<<Object base: parameters>>

<<Object base: types>>

<<Object base: interfaces>>

contains

<<Object base: procedures>>

<<Object base: tests>>

end module object_base
@ %def object_base
@
\subsection{Basic objects (abstract)}
Each object may be referred by other objects, either as a prototype or as a
value.  To keep track, we count the number of instances.  Since the object
itself also counts as an instance, we start with 1, which may be incremented
later.  Conversely, an object is finally deallocated if its instance
count becomes zero.

Any object that is part of a composite will have a context.  

A basic object has a [[defined]] status.  If defined, the value is
known and can be queried.  If undefined, the object signature is
determined but the value is unknown.  If there
is no value, we understand that the object is always defined.

For generic objects, that will be extensions of the abstract type, we
distinguish:
\begin{description}
\item[core]:  The value held by a composite object, target of a reference
\item[mantle]:  Any additional members, and any primer statements that
  initialize the object
\tiem[shell]:  Name and properties of the object.
\end{description}
<<Object base: public>>=
  public :: object_t
<<Object base: types>>=
  type, abstract :: object_t
     private
     class(wrapper_t), pointer :: context => null ()
     integer :: refcount = 1
   contains
   <<Object base: object: TBP>>
  end type object_t
  
@ %def object_t
@
\subsubsection{Finalizer and destructor}
The finalizer should not be called explicitly.  Instead, when an
object is ready for deletion, we should call this method, which calls
the specific finalizer, takes care of any prototype, and checks for
any extra instances before deallocating.

This procedure can't be type-bound.
<<Object base: public>>=
  public :: remove_object
<<Object base: procedures>>=
  recursive subroutine remove_object (object)
    class(object_t), intent(inout), pointer :: object
    if (associated (object)) then
       object%refcount = object%refcount - 1
       if (object%refcount == 0) then
          call object%final ()
          deallocate (object)
       else
          object => null ()
       end if
    end if
  end subroutine remove_object
  
@ %def remove_object
@ There must be a specific finalizer.  The finalizer might be empty,
but this method must be implemented.
<<Object base: object: TBP>>=
  procedure (object_final), deferred :: final
<<Object base: interfaces>>=
  abstract interface
     subroutine object_final (object)
       import
       class(object_t), intent(inout) :: object
     end subroutine object_final
  end interface
       
@ %def object_final
@ 
\subsubsection{Output}
Any object must have a [[write]] method, so we can print a
representation on screen.  The output format depends on the context.

The default [[write]] prints a verbose representation of the object, an
extended version of the declaration form.  All properties and members are
displayed.  Arrays of reference objects (wrappers) are shown explicitly.
If the object has a value, the value is also displayed.  The
[[refcount]] option displays the reference count, following the property
string.

[[write_as_declaration]] prints a concise version of the signature, and
suppresses wrapper objects.  The value is displayed.  Primer statements are
displayed in statement form, following the member declarations.

[[write_as_statement]] prints the object in statement form, if it is a
statement.  Other objects are written in declaration form.

[[write_as_expression]] prints the object as if it occurs inside an
expression.  For a data object, this would print the value, while for an
expression object, the expression (recursively).  Member objects are shown
after the expression, but arguments are not shown as members.  Primer
statements are suppressed.  This format also needs information about the
context, expressed by the [[priority]] and [[lr]] arguments.

[[write_as_value]] just prints the current value, regardless whether this is a
data object or an expression.
<<Object base: object: TBP>>=
  procedure :: write => object_write
  procedure :: write_as_declaration => object_write_as_declaration
  procedure :: write_as_statement => object_write_as_statement
  procedure :: write_as_expression => object_write_as_expression
  procedure :: write_as_value => object_write_as_value
<<Object base: procedures>>=
  recursive subroutine object_write &
       (object, unit, indent, refcount, core, mantle)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    logical, intent(in), optional :: core
    logical, intent(in), optional :: mantle
    logical :: ref, cor, man
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    ref = .false.;  if (present (refcount))  ref = refcount
    cor = .true.;  if (present (core))  cor = core
    man = .true.;  if (present (mantle))  man = mantle
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    write (u, "(1x,'||',A,'||')", advance="no") &
         char (object%get_signature (verbose=.true.))
    if (ref) then
       write (u, "(1x,'(',I0,')')", advance="no")  object%get_refcount ()
    end if
    if (man .and. object%has_mantle ()) then
       write (u, "(1x,'{')")
       call object%write_mantle (u, ind+1, ref)
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (cor .and. object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write
  
  recursive subroutine object_write_as_declaration (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    type(string_t) :: signature
    class(object_t), pointer :: member, primer
    integer :: u, ind, n_mem, n_pri, i
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    signature = object%get_signature (verbose = .false.)
    if (signature /= "") then
       write (u, "(1x,'||',A,'||')", advance="no")  char (signature)
    end if
    n_mem = object%get_n_members ()
    n_pri = object%get_n_primers ()
    if (n_mem + n_pri > 0) then
       write (u, "(1x,'{')")
       do i = 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind)
          call member%write_as_declaration (u, ind+1)
       end do
       do i = 1, n_pri
          call object%get_primer_ptr (i, primer)
          call write_indent (u, ind)
          call primer%write_as_statement (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write_as_declaration

  recursive subroutine object_write_as_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%is_statement ()) then
       call object%write_statement (unit, indent)
    else
       call object%write_as_declaration (unit, indent)
    end if
  end subroutine object_write_as_statement
  
  recursive subroutine object_write_as_expression (object, unit, indent, &
       priority, lr)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer, intent(in), optional :: priority
    logical, intent(in), optional :: lr
    class(object_t), pointer :: member
    logical :: paren
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    paren = .false.
    if (object%is_expression ()) then
       if (present (priority)) then
          if (lr) then
             paren = priority > object%get_priority ()
          else
             paren = priority >= object%get_priority ()
          end if
       end if
       if (paren)  write (u, "('(')", advance="no")
       call object%write_expression (u, indent)
       if (paren)  write (u, "(')')", advance="no")
    else if (object%is_value ()) then
       if (object%is_defined ()) then
          call object%write_expression (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else if (object%has_value ()) then
       call object%write_core (u, ind)
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_expression
  
  recursive subroutine object_write_as_value (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: member
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (object%is_expression () &
         .or. object%is_value () .or. object%has_value ()) then
       if (object%is_defined ()) then
          call object%write_value (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_value
  
@ %def object_write
@ %def object_write_as_declaration
@ %def object_write_as_statement
@ %def object_write_as_expression
@ For these specific output functions we provide a default
implementation.   A bare object has the default prototype [[object]] and no
contents, value, or expression.
<<Object base: object: TBP>>=
  procedure :: write_core => object_write_stub
  procedure :: write_mantle => object_write_mantle
  procedure :: write_statement => object_write_statement
  procedure :: write_expression => object_write_stub
  procedure :: write_value => object_write_stub
<<Object base: procedures>>=
  subroutine object_write_stub (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "('<>')", advance="no")
  end subroutine object_write_stub
       
  subroutine object_write_mantle (object, unit, indent, refcount)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
  end subroutine object_write_mantle
  
  subroutine object_write_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
  end subroutine object_write_statement
       
@ %def object_write_core
@ %def object_write_mantle
@ %def object_write_statement
@ %def object_write_expression
@ %def object_write_value
@
\subsubsection{Reference count and context}
Return the reference count explicitly.  This may be used for debugging
output.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: get_refcount => object_get_refcount
<<Object base: procedures>>=
  function object_get_refcount (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = object%refcount
  end function object_get_refcount
  
@ %def object_get_refcount
@
Set the context pointer.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: set_context => object_set_context
<<Object base: procedures>>=
  subroutine object_set_context (object, context)
    class(object_t), intent(inout) :: object
    class(wrapper_t), intent(in), target :: context
    object%context => context
  end subroutine object_set_context
  
@ %def object_set_context
@
\subsubsection{Queries}
Access the object's name.  The name may be just the type (for atomic
objects) or a variable name (for composites).
<<Object base: object: TBP>>=
  procedure (object_get_name), deferred :: get_name
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_name (object) result (name)
       import
       class(object_t), intent(in) :: object
       type(string_t) :: name
     end function object_get_name
  end interface
  
@ %def object_get_name
@ Return the object's prototype as a string.  The default prototype is `object'.
<<Object base: object: TBP>>=
  procedure :: get_prototype => object_get_prototype
<<Object base: procedures>>=
  function object_get_prototype (object) result (prototype)
    class(object_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "object"
  end function object_get_prototype
  
@ %def object_get_prototype
@ Return the object's signature as a string.  If [[verbose]] is set (default),
we need a complete account of all properties, otherwise a short version.
<<Object base: object: TBP>>=
  procedure (object_get_signature), deferred :: get_signature
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_signature (object, verbose) result (signature)
       import
       class(object_t), intent(in) :: object
       logical, intent(in), optional :: verbose
       type(string_t) :: signature
     end function object_get_signature
  end interface
  
@ %def object_get_signature
@ Return the object priority.  This is relevant only for expressions and
operators.
<<Object base: object: TBP>>=
  procedure :: get_priority => object_get_priority
<<Object base: procedures>>=
  pure function object_get_priority (object) result (priority)
    class(object_t), intent(in) :: object
    integer :: priority
    priority = 0
  end function object_get_priority
  
@ %def object_get_priority
@ Check if this is a reference object.
<<Object base: object: TBP>>=
  procedure :: is_reference => object_is_reference
<<Object base: procedures>>=
  pure function object_is_reference (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_reference
  
@ %def object_is_reference
@ Identify statements and expressions (functions).
<<Object base: object: TBP>>=
  procedure :: is_statement => object_is_statement
  procedure :: is_expression => object_is_expression
<<Object base: procedures>>=
  pure function object_is_statement (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_statement
  
  pure function object_is_expression (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_expression
  
@ %def object_is_statement
@ %def object_is_expression
@ This query tells whether the object contains an ID subobject.
<<Object base: object: TBP>>=
  procedure :: has_id => object_has_id
<<Object base: procedures>>=
  pure function object_has_id (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_id
  
@ %def object_has_id
@ Return the pointer to the ID subobject, if any.
<<Object base: object: TBP>>=
  procedure :: get_id_ptr => object_get_id_ptr
<<Object base: procedures>>=
  subroutine object_get_id_ptr (object, id)
    class(object_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => null ()
  end subroutine object_get_id_ptr
  
@ %def object_get_id_ptr
@ This query tells whether the object is a wrapper which holds a core object.
The [[has_value]] variant is true if the core represents a value.  The
[[is_value]] is true if the object itself is a value.
<<Object base: object: TBP>>=
  procedure :: has_value => object_has_value
  procedure :: is_value => object_is_value
<<Object base: procedures>>=
  pure function object_has_value (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_value
  
  pure function object_is_value (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_value
  
@ %def object_has_value
@ %def object_is_value
@ Analogously, for the `mantle' (members, arguments, primer).
<<Object base: object: TBP>>=
  procedure :: has_mantle => object_has_mantle
<<Object base: procedures>>=
  pure function object_has_mantle (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_mantle
  
@ %def object_has_mantle
@ Return number of mantle components.  A default object has none.
<<Object base: object: TBP>>=
  procedure :: get_n_members => object_get_n_members
  procedure :: get_n_arguments => object_get_n_arguments
  procedure :: get_n_primers => object_get_n_primers
<<Object base: procedures>>=
  pure function object_get_n_members (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_members
  
  pure function object_get_n_arguments (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_arguments
  
  pure function object_get_n_primers (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_primers
  
@ %def object_get_n_members
@ %def object_get_n_arguments
@ %def object_get_n_primers
@ Return pointers to mantle component.  Default: null.
<<Object base: object: TBP>>=
  procedure :: get_member_ptr => object_get_member_ptr
  procedure :: get_primer_ptr => object_get_primer_ptr
<<Object base: procedures>>=
  subroutine object_get_member_ptr (object, i, member)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    member => null ()
  end subroutine object_get_member_ptr
  
  subroutine object_get_primer_ptr (object, i, primer)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    primer => null ()
  end subroutine object_get_primer_ptr
  
@ %def object_get_member_ptr
@ %def object_get_primer_ptr
@ Return the definition status.  An object is defined if it has a value and
the value is defined.  Generic objects are undefined.
<<Object base: object: TBP>>=
  procedure :: is_defined => object_is_defined
<<Object base: procedures>>=
  pure function object_is_defined (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_defined
  
@ %def object_is_defined
@
\subsubsection{Constructors}
Since we are basing the object structure on prototyping, each object
must provide an [[instantiate]] method.  As a rule, the instance
inherits the properties of the prototype with the exception of the
value (core value and member values).  In particular, the copy should
be of the same actual type as the prototype.

We require a pointer implementation for allocating objects, at this
point.  This allows us to freely use pointers without caring too much
about [[target]] attributes.
<<Object base: object: TBP>>=
  procedure (object_instantiate), deferred :: instantiate
<<Object base: interfaces>>=
  abstract interface
     subroutine object_instantiate (object, instance)
       import
       class(object_t), intent(inout), target :: object
       class(object_t), intent(out), pointer :: instance
     end subroutine object_instantiate
  end interface
       
@ %def object_instantiate
@
This is applicable to statements and expressions: resolve any references by
name or position into actual pointers, so evaluation can proceed.  For a bare
object, nothing needs to be resolved.
<<Object base: object: TBP>>=
  procedure :: resolve => object_resolve
<<Object base: procedures>>=
  subroutine object_resolve (object, success)
    class(object_t), intent(inout), target :: object
    logical, intent(out) :: success
    success = .true.
  end subroutine object_resolve
  
@ %def object_resolve
@
With all paths resolved, we can evaluate.  No-op for all objects that aren't
statements or expressions, or contain such objects as members.
<<Object base: object: TBP>>=
  procedure :: evaluate => object_evaluate
<<Object base: procedures>>=
  subroutine object_evaluate (object)
    class(object_t), intent(inout), target :: object
  end subroutine object_evaluate
  
@ %def object_evaluate
@
\subsubsection{Code}
Each object has a representation in terms of elementary values, which can be
used for object construction and data transfer.

The code includes the object's value (if any), which might be a large object.
To allow for passing a pointer, we require a [[target]] attribute.

Determining the code may require a repository lookup, so we need the extra
argument.
<<Object base: object: TBP>>=
  procedure (object_get_code), deferred :: get_code
<<Object base: interfaces>>=
  abstract interface
     function object_get_code (object, repository) result (code)
       import
       class(object_t), intent(in), target :: object
       type(repository_t), intent(in), optional :: repository
       type(code_t) :: code
     end function object_get_code
  end interface
  
@ %def object_get_code
@
Build the object from its code.  This is the inverse method to
[[object_get_code]] above, and to [[remove_object]].

Composite objects are built using a prototype in the repository.  Since the
prototype includes the core, we do not need to build value objects.
<<Object base: public>>=
  public :: build_object
<<Object base: procedures>>=
  subroutine build_object (object, code, repository)
    class(object_t), intent(out), pointer :: object
    type(code_t), intent(in) :: code
    type(repository_t), intent(in) :: repository
    integer :: prototype_index, mode
    select case (code%cat)
    case (CAT_COMPOSITE)
       prototype_index = code%att(1)
       if (prototype_index > 0) then
          call repository%spawn (prototype_index, object)
       else
          allocate (composite_t :: object)
       end if
       select type (object)
       class is (composite_t)
          call object%init_from_code (code)
       end select
    case (CAT_ID)
       allocate (id_t :: object)
       select type (object)
       type is (id_t)
          call object%init_from_code (code)
       end select
    case (CAT_REFERENCE)
       allocate (reference_t :: object)
    case default
       object => null ()
    end select
  end subroutine build_object
  
@ %def build_object
@
\subsubsection{Iterator Support}
Iterate.  This procedure returns the next object in a given order, for
iteration over the object tree.  If there is a [[insert_object]] argument,
this object is inserted before returning it as the next object.

This implementation: the bare object has nothing that follows it, and the
inserted object is ignored.
<<Object base: object: TBP>>=
  procedure :: next_position => object_next_position
<<Object base: procedures>>=
  subroutine object_next_position (object, position, next_object, import_object)
    class(object_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    position%part = POS_NONE
    if (present (next_object))  next_object => null ()
  end subroutine object_next_position
  
@ %def object_next_position
@
\subsubsection{Tools}
Create a reference object.  The core is the previous object (via pointer).
We therefore can implement the method directly.
<<Object base: object: TBP>>=
  procedure :: make_reference => object_make_reference
<<Object base: procedures>>=
  subroutine object_make_reference (object, reference)
    class(object_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: reference
    allocate (reference_t :: reference)
    select type (reference)
    type is (reference_t)
       call reference%link_core (object)
    end select
  end subroutine object_make_reference
  
@ %def object_make_reference
@
Dereference: if this is not a reference, return the pointer to the object
itself.
<<Object base: object: TBP>>=
  procedure :: dereference => object_dereference
<<Object base: procedures>>=
  recursive function object_dereference (object) result (remote)
    class(object_t), intent(in), target :: object
    class(object_t), pointer :: remote
    remote => object
  end function object_dereference

@ %def object_dereference
@ Find an object within the object's contents: no result for a default
object.
<<Object base: object: TBP>>=
  procedure :: find => object_find
<<Object base: procedures>>=
  recursive subroutine object_find (object, path, member)
    class(object_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    member => null ()
  end subroutine object_find
    
@ %def object_find
@ This is invalid for all objects except assignment, where it fills the stack
of matching items that will be assigned.
<<Object base: object: TBP>>=
  procedure :: push => object_push
<<Object base: procedures>>=
  subroutine object_push (object, lhs, rhs)
    class(object_t), intent(inout) :: object
    class(value_t), intent(in), pointer :: lhs, rhs
    call msg_bug ("Object: push method invalid in this context")
  end subroutine object_push
  
@ %def object_push
@ Match an object [[source]] against a pattern object [[ref]], iteratively and
recursively.  Return [[success]].  If also [[master]] is provided, call its
[[push]] method for any matching item pair.

We use a pair of iterators, one for the lhs and one for the rhs.  We iterate
over the lhs and track the moves of the iterator.  Whenever we go to a core,
we go to the core of the rhs and match the values, if any.  For a successful
match, the lhs and rhs value pointer pair is pushed onto the assignment item
stack.  When we go to a member, we check if we actually can assign it.  If
yes, we take its name and find the corresponding member on the rhs.  The
member indices need not coincide, then we navigate to the member core(s).
Finally, when the current lhs object is exhausted, we also skip the current
rhs object.

Also, the match fails if any [[lhs]] object has mode ABSTRACT.

TODO: distinguish VARIABLE/CONSTANT

TODO: assignment for primer statements.

Any mismatch immediately aborts the matching procedure.
<<Object base: object: TBP>>=
  procedure :: match => object_match
<<Object base: procedures>>=
  recursive subroutine object_match (ref, source, success, master)
    class(object_t), intent(in), target :: ref
    class(object_t), intent(in), target :: source
    logical, intent(out) :: success
    class(object_t), intent(inout), optional :: master
    type(object_iterator_t) :: it_lhs, it_rhs
    class(object_t), pointer :: lhs, rhs, rhs_context
    class(value_t), pointer :: lval, rval
    type(position_t) :: position
    integer :: part, i
    logical :: mutable, required
    lhs => ref
    rhs => source
    call it_lhs%init (lhs)
    call it_rhs%init (rhs)
    ITERATE: do while (it_lhs%is_valid ())
       call it_lhs%get_next_position (position)
       select case (position%part)
       case (POS_NONE)
          call it_lhs%to_context (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_context (success);  if (.not. success)  exit ITERATE
       case (POS_ID)
          call it_lhs%to_id (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_id (success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          call it_rhs%get_object (rhs)
          select type (lhs)
             class is (id_t)
             call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
             if (present (master)) then
                select type (rhs)
                class is (id_t)
                   lval => lhs
                   rval => rhs
                   call master%push (lval, rval)
                end select
             end if
          end select
       case (POS_CORE)
          call it_lhs%to_core (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_core (success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          call it_rhs%get_object (rhs)
          select type (lhs)
             class is (value_t)
             call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
             if (present (master)) then
                select type (rhs)
                class is (value_t)
                   lval => lhs
                   rval => rhs
                   call master%push (lval, rval)
                end select
             end if
          end select
       case (POS_MEMBER)
          call it_lhs%to_member &
               (position%i, success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          select type (lhs)
             class is (composite_t)
             call lhs%check_mode (mutable)
             call lhs%check_role (required)
          end select
          if (mutable .or. required) then
             call it_rhs%get_object (rhs_context)
             select type (rhs_context)
                class is (composite_t)
                call rhs_context%find_member (lhs%get_name (), index=i)
             end select
             if (i > 0) then
                call it_rhs%to_member &
                     (i, success);  if (.not. success)  exit ITERATE
             else if (required) then
                success = .false.;  exit ITERATE
             else
                call it_lhs%to_context &
                     (success);  if (.not. success)  exit ITERATE
             end if
          else
             call it_lhs%to_context &
                  (success);  if (.not. success)  exit ITERATE
          end if
       case default
          call it_lhs%to_context &
               (success);  if (.not. success)  exit ITERATE
       end select
    end do ITERATE
  end subroutine object_match
    
@ %def object_match
@
\subsection{Tag Object Type}
A tag is an atomic object with no content, it just exists.  (As a
variable, it has a name but no value.)  The definition status is
always defined.

Tag objects are checked in matching types against a pattern.  The match fails
if a required tag is not found.

We introduce this here, so we have concrete objects that we can use in
unit tests.  Object types with value are defined elsewhere.
<<Object base: public>>=
  public :: tag_t
<<Object base: types>>=
  type, extends (object_t) :: tag_t
     private
   contains
   <<Object base: tag: TBP>>
  end type tag_t
  
@ %def tag_t
@ 
\subsubsection{Finalizer}
We do not need an initializer, there are no contents or value.

The finalizer is also empty.
<<Object base: tag: TBP>>=
  procedure :: final => tag_final
<<Object base: procedures>>=
  subroutine tag_final (object)
    class(tag_t), intent(inout) :: object
  end subroutine tag_final
 
@ %def tag_final
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[tag]].
<<Object base: tag: TBP>>=
  procedure :: get_name => tag_get_name
<<Object base: procedures>>=
  pure function tag_get_name (object) result (name)
    class(tag_t), intent(in) :: object
    type(string_t) :: name
    name = "tag"
  end function tag_get_name
  
@ %def tag_get_name
@ The full signature of a tag object is [[atom]].
<<Object base: tag: TBP>>=
  procedure :: get_signature => tag_get_signature
<<Object base: procedures>>=
  pure function tag_get_signature (object, verbose) result (signature)
    class(tag_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "atom"
    else
       signature = ""
    end if
  end function tag_get_signature
  
@ %def tag_get_signature
@
\subsubsection{Constructor}
For a new tag instance, nothing needs to be copied.
<<Object base: tag: TBP>>=
  procedure :: instantiate => tag_instantiate
<<Object base: procedures>>=
  subroutine tag_instantiate (object, instance)
    class(tag_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (tag_t :: instance)
  end subroutine tag_instantiate
    
@ %def tag_instantiate
@ Object code.  Only the category is nontrivial.
<<Object base: tag: TBP>>=
  procedure :: get_code => tag_get_code
<<Object base: procedures>>=
  function tag_get_code (object, repository) result (code)
    class(tag_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_TAG
  end function tag_get_code
  
@ %def tag_get_code
@
\subsection{Value object type (abstract)}
The [[value_t]] is the base type of all objects that holds a value.  The
abstract base type includes the [[defined]] property for the value.
<<Object base: public>>=
  public :: value_t
<<Object base: types>>=
  type, extends (object_t), abstract :: value_t
     private
     logical :: defined = .false.
   contains
   <<Object base: value: TBP>>
  end type value_t
  
@ %def value_t
@
\subsubsection{Queries}
The signature of value objects is [[value]].
<<Object base: value: TBP>>=
  procedure :: get_signature => value_get_signature
<<Object base: procedures>>=
  pure function value_get_signature (object, verbose) result (signature)
    class(value_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "value"
    else
       signature = ""
    end if
  end function value_get_signature
  
@ %def value_get_signature
@ A value is a value.
<<Object base: value: TBP>>=
  procedure :: is_value => value_is_value
<<Object base: procedures>>=
  pure function value_is_value (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function value_is_value
  
@ %def value_is_value
@
This overrides a base-type method.  The value may be defined or undefined.
<<Object base: value: TBP>>=
  procedure :: is_defined => value_is_defined
<<Object base: procedures>>=
  pure function value_is_defined (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = object%defined
  end function value_is_defined
  
@ %def value_is_defined
@
\subsubsection{Setting Content}
Initialize the value from a code object.
<<Object base: value: TBP>>=
  procedure(value_init_from_code), deferred :: init_from_code
<<Object base: interfaces>>=
  abstract interface
     subroutine value_init_from_code (object, code)
       import
       class(value_t), intent(out) :: object
       type(code_t), intent(in) :: code
     end subroutine value_init_from_code
  end interface

@ %def value_init_from_code
@ Set the definition status.
<<Object base: value: TBP>>=
  procedure :: set_defined => value_set_defined
<<Object base: procedures>>=
  pure subroutine value_set_defined (object, defined)
    class(value_t), intent(inout) :: object
    logical, intent(in) :: defined
    object%defined = defined
  end subroutine value_set_defined
  
@ %def value_set_defined
@
\subsubsection{Tools}
Assign value: there should be an allowed possibility for any value object.
The actual variants depend on the concrete type combination.  Before we call
the actual assignment, we should call the [[match]] method which checks
whether the assignment is allowed.
<<Object base: value: TBP>>=
  procedure :: match => value_match
  procedure :: assign => value_assign
<<Object base: procedures>>=
  subroutine value_match (ref, source, success, master)
    class(value_t), intent(in), target :: ref
    class(object_t), intent(in), target :: source
    logical, intent(out) :: success
    class(object_t), intent(inout), optional :: master
    select type (source)
    class is (value_t)
       call ref%match_value (source, success)
    class default
       success = .false.
    end select
  end subroutine value_match
       
  subroutine value_assign (object, source)
    class(value_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    call object%final ()
    object%defined = source%defined
    if (source%defined)  call object%assign_value (source)
  end subroutine value_assign
       
@ %def value_match
@ %def value_assign
@ This must be implemented specifically.
<<Object base: value: TBP>>=
  procedure (value_match_value), deferred :: match_value
  procedure (value_assign_value), deferred :: assign_value
<<Object base: interfaces>>=
  abstract interface
     subroutine value_match_value (object, source, success)
       import
       class(value_t), intent(in) :: object
       class(value_t), intent(in) :: source
       logical, intent(out) :: success
     end subroutine value_match_value
  end interface
  
  abstract interface
     subroutine value_assign_value (object, source)
       import
       class(value_t), intent(inout) :: object
       class(value_t), intent(in) :: source
     end subroutine value_assign_value
  end interface
  
@ %def value_match_value
@ %def value_assign_value
@
\subsection{ID Object}
We define the [[id_t]] type that holds the ID of an object (the name / path to
an object) and can be used for searching and navigating.  The ID object is the
first implementation of the abstract value type.
<<Object base: public>>=
  public :: id_t
<<Object base: types>>=
  type, extends (value_t) :: id_t
     private
     type(string_t), dimension(:), allocatable :: path
   contains
   <<Object base: id: TBP>>
  end type id_t
  
@ %def id_t
@
\subsubsection{Finalizer}
Delete the path.
<<Object base: id: TBP>>=
  procedure :: final => id_final
<<Object base: procedures>>=
  subroutine id_final (object)
    class(id_t), intent(inout) :: object
    if (allocated (object%path))  deallocate (object%path)
    call object%set_defined (.false.)
  end subroutine id_final
  
@ %def id_final
@
\subsubsection{Output}
Expression form: write a representation of the ID string array as the ID
object value.
<<Object base: id: TBP>>=
  procedure :: write_expression => id_write_expression
<<Object base: procedures>>=
  subroutine id_write_expression (object, unit, indent)
    class(id_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, i
    u = given_output_unit (unit)
    if (allocated (object%path)) then
       write (u, "(A)", advance="no")  char (object%get_path_string ())
    else
       write (u, "(A)", advance="no")  "<id>"
    end if
  end subroutine id_write_expression
       
@ %def id_write_expression
@
\subsubsection{Queries}
The name is [[id]]
<<Object base: id: TBP>>=
  procedure :: get_name => id_get_name
<<Object base: procedures>>=
  pure function id_get_name (object) result (name)
    class(id_t), intent(in) :: object
    type(string_t) :: name
    name = "id"
  end function id_get_name

@ %def id_get_name  
@ Return the path, either as a string array or as a string, concatenated by
dots.
<<Object base: id: TBP>>=
  procedure :: get_path => id_get_path
  procedure :: get_path_string => id_get_path_string
<<Object base: procedures>>=
  pure function id_get_path (object) result (path)
    class(id_t), intent(in) :: object
    type(string_t), dimension(:), allocatable :: path
    if (allocated (object%path)) then
       allocate (path (size (object%path)))
       path = object%path
    end if
  end function id_get_path
  
  pure function id_get_path_string (object) result (path)
    class(id_t), intent(in) :: object
    type(string_t) :: path
    integer :: i
    path = ""
    if (allocated (object%path)) then
       do i = 1, size (object%path)
          if (i == 1) then
             path = object%path(i)
          else
             path = path // "." // object%path(i)
          end if
       end do
    end if
  end function id_get_path_string
  
@ %def id_get_path
@ %def id_get_path_string
@
\subsubsection{Construction and initialization}
Instantiate: likely unused.
<<Object base: id: TBP>>=
  procedure :: instantiate => id_instantiate
<<Object base: procedures>>=
  subroutine id_instantiate (object, instance)
    class(id_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (id_t :: instance)
  end subroutine id_instantiate

@ %def id_instantiate
@ The ID object carries a string-array value.
<<Object base: id: TBP>>=
  procedure :: get_code => id_get_code
<<Object base: procedures>>=
  function id_get_code (object, repository) result (code)
    class(id_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    integer :: nval, i
    code%cat = CAT_ID
    if (allocated (object%path)) then
       nval = size (object%path)
       call code%create_val (code%val, VT_STRING, nval)
       select type (val => code%val)
       type is (val_string_t)
          do i = 1, nval
             val%x(i) = object%path(i)
          end do
       end select
    end if
  end function id_get_code
  
@ %def id_get_code
@ Initialize from a code object, which includes the path.
<<Object base: id: TBP>>=
  procedure :: init_from_code => id_init_from_code
<<Object base: procedures>>=
  subroutine id_init_from_code (object, code)
    class(id_t), intent(out) :: object
    type(code_t), intent(in) :: code
    select type (val => code%val)
    type is (val_string_t)
       call object%init (val%x)
    end select
  end subroutine id_init_from_code
    
@ %def id_init_from_code
@ Initialize with a path, specified as a string array.
<<Object base: id: TBP>>=
  procedure :: init => id_init_path
<<Object base: procedures>>=
  subroutine id_init_path (object, path)
    class(id_t), intent(out) :: object
    type(string_t), dimension(:), intent(in) :: path
    allocate (object%path (size (path)))
    object%path = path
    call object%set_defined (.true.)
  end subroutine id_init_path
    
@ %def id_init_path
@
\subsubsection{Tools}
Must be implemented due to the [[value_t]] base type: match/copy the path
value.
<<Object base: id: TBP>>=
  procedure :: match_value => id_match_value
  procedure :: assign_value => id_assign_value
<<Object base: procedures>>=
  subroutine id_match_value (object, source, success)
    class(id_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (id_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine id_match_value
       
  subroutine id_assign_value (object, source)
    class(id_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (id_t)
       call object%init (source%path)
    end select
  end subroutine id_assign_value
       
@ %def id_match_value
@ %def id_assign_value
@
\subsection{Wrapper}
A wrapper is an object that can hold another object, its [[core]].  This base
type allows us to define composite objects and references.  As a stand-alone
type, it enables arrays of heterogeneous concrete type.

All method calls are delegated to the core.
<<Object base: public>>=
  public :: wrapper_t
<<Object base: types>>=
  type, extends (object_t) :: wrapper_t
     private
     class(object_t), pointer :: core => null ()
   contains
   <<Object base: wrapper: TBP>>
  end type wrapper_t
  
@ %def wrapper_t
@ 
\subsubsection{Finalizer}
The finalizer should remove and deallocate the core object.
<<Object base: wrapper: TBP>>=
  procedure :: final => wrapper_final
<<Object base: procedures>>=
  recursive subroutine wrapper_final (object)
    class(wrapper_t), intent(inout) :: object
    if (associated (object%core)) then
       call object%core%final ()
       call remove_object (object%core)
    end if
  end subroutine wrapper_final
  
@ %def wrapper_final
@
\subsubsection{Output}
 Write the wrapper core.  Assuming this represents a value, we write in
expression form.
<<Object base: wrapper: TBP>>=
  procedure :: write_core => wrapper_write_core
<<Object base: procedures>>=
  recursive subroutine wrapper_write_core (object, unit, indent)
    class(wrapper_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%core%write_as_expression (unit, indent)
  end subroutine wrapper_write_core
       
@ %def wrapper_write_core  
@
\subsubsection{Queries}
Delegate name and signature as appropriate.
<<Object base: wrapper: TBP>>=
  procedure :: get_name => wrapper_get_name
<<Object base: procedures>>=
  pure recursive function wrapper_get_name (object) result (name)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: name
    if (associated (object%core)) then
       name = object%core%get_name ()
    else
       name = "<???>"
    end if
  end function wrapper_get_name
  
@ %def wrapper_get_name
@ Delegate the prototype.
<<Object base: wrapper: TBP>>=
  procedure :: get_prototype => wrapper_get_prototype
<<Object base: procedures>>=
  recursive function wrapper_get_prototype (object) result (prototype)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%core)) then
       prototype = object%core%get_prototype ()
    else
       prototype = object_get_prototype (object)
    end if
  end function wrapper_get_prototype
  
@ %def wrapper_get_prototype
@ The signature is a plain [[wrapper]] string.
<<Object base: wrapper: TBP>>=
  procedure :: get_signature => wrapper_get_signature
<<Object base: procedures>>=
  pure function wrapper_get_signature (object, verbose) result (signature)
    class(wrapper_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = "wrapper"
  end function wrapper_get_signature
  
@ %def wrapper_get_signature
@ The [[is_reference]], [[has_value]], [[is_defined]] and [[is_statement]]
queries are delegated.
<<Object base: wrapper: TBP>>=
  procedure :: is_reference => wrapper_is_reference
  procedure :: is_statement => wrapper_is_statement
  procedure :: is_expression => wrapper_is_expression
  procedure :: is_defined => wrapper_is_defined
<<Object base: procedures>>=
  pure recursive function wrapper_is_reference (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_reference ()
    else
       flag = .false.
    end if
  end function wrapper_is_reference
  
  pure recursive function wrapper_is_statement (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_statement ()
    else
       flag = .false.
    end if
  end function wrapper_is_statement
  
  pure recursive function wrapper_is_expression (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_expression ()
    else
       flag = .false.
    end if
  end function wrapper_is_expression
  
  pure recursive function wrapper_is_defined (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function wrapper_is_defined
  
@ %def wrapper_is_reference
@ %def wrapper_is_statement
@ %def wrapper_is_expression
@ %def wrapper_is_defined
@ Return pointer to the core.
<<Object base: wrapper: TBP>>=
  procedure :: get_core_ptr => wrapper_get_core_ptr
<<Object base: procedures>>=
  subroutine wrapper_get_core_ptr (object, core)
    class(wrapper_t), intent(in) :: object
    class(object_t), intent(out), pointer :: core
    if (associated (object%core)) then
       core => object%core%dereference ()
    else
       core => null ()
    end if
  end subroutine wrapper_get_core_ptr
  
@ %def wrapper_get_core_ptr
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.  It should not be called for
a pure wrapper, however.
<<Object base: wrapper: TBP>>=
  procedure :: instantiate => wrapper_instantiate
<<Object base: procedures>>=
  recursive subroutine wrapper_instantiate (object, instance)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (wrapper_t :: instance)
  end subroutine wrapper_instantiate
    
@ %def wrapper_instantiate
@ Import an object as the new core.
<<Object base: wrapper: TBP>>=
  procedure, non_overridable :: import_core => wrapper_import_core
<<Object base: procedures>>=
  subroutine wrapper_import_core (object, core)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(inout), pointer :: core
    if (associated (object%core))  call remove_object (object%core)
    call core%set_context (object)
    object%core => core
    core => null ()
  end subroutine wrapper_import_core
    
@ %def wrapper_import_core
@ A wrapper should not appear explicitly in code, so return zero here.
<<Object base: wrapper: TBP>>=
  procedure :: get_code => wrapper_get_code
<<Object base: procedures>>=
  function wrapper_get_code (object, repository) result (code)
    class(wrapper_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = 0
  end function wrapper_get_code
  
@ %def wrapper_get_code
@
\subsubsection{Iterator Support}
Iterate: next is core, then context.  The import object, if present, is
inserted as the core before proceeding.
<<Object base: wrapper: TBP>>=
  procedure :: next_position => wrapper_next_position
<<Object base: procedures>>=
  subroutine wrapper_next_position &
       (object, position, next_object, import_object)
    class(wrapper_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    if (object%is_statement ()) then
       call object_next_position (object, position, next_object)
    else       
       select case (position%part)
       case (POS_CORE)
          call object_next_position (object, position, next_object)
       case default
          if (present (import_object)) then
             call object%import_core (import_object)
          end if
          if (associated (object%core)) then
             position%part = POS_CORE
             if (present (next_object))  next_object => object%core
          else
             call object_next_position (object, position, next_object)
          end if
       end select
    end if
  end subroutine wrapper_next_position
  
@ %def wrapper_next_position
@
\subsubsection{Tools}
Find: refer to the context object.
<<Object base: wrapper: TBP>>=
  procedure :: find => wrapper_find
<<Object base: procedures>>=
  recursive subroutine wrapper_find (object, path, member)
    class(wrapper_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: context
    member => null ()
    if (size (path) > 0) then
       if (associated (object%context)) then
          context => object%context
          call context%find (path, member)
       end if
    end if
  end subroutine wrapper_find
    
@ %def wrapper_find
@
\subsection{Object references}
This extension of a wrapper behaves as a pointer to the core object.  We have
to assume that the target object of that core has been allocated remotely, and
should not be deallocated from here.

The target is identified via the [[id]] component.  Initially, the core object
is unassigned.  To resolve a reference, we search for the referenced object
and link it to the core.

TODO: For references as user-level objects, we would need a prototype matching
feature.  The current implementation does not type-check.
<<Object base: public>>=
  public :: reference_t
<<Object base: types>>=
  type, extends (wrapper_t) :: reference_t
     private
     class(object_t), pointer :: id => null ()
   contains
   <<Object base: reference: TBP>>
  end type reference_t
  
@ %def reference_t
@
\subsubsection{Finalizer}
The finalizer should not finalize the core.  However, it should call
[[remove_object]] as this takes care of reference counts.
<<Object base: reference: TBP>>=
  procedure :: final => reference_final
<<Object base: procedures>>=
  recursive subroutine reference_final (object)
    class(reference_t), intent(inout) :: object
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    if (associated (object%core)) then
       call remove_object (object%core)
    end if
  end subroutine reference_final
  
@ %def reference_final
@
\subsubsection{Output}
The output procedures are delegated to the core as appropriate.
<<Object base: reference: TBP>>=
  procedure :: write_statement => reference_write_statement
  procedure :: write_expression => reference_write_expression
<<Object base: procedures>>=
  recursive subroutine reference_write_statement (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_statement (unit, indent)
       else
          write (u, "('<REF>')", advance="no")
       end if
    else if (associated (object%core)) then
       call object%core%write_statement (unit, indent)
    end if
  end subroutine reference_write_statement
       
  recursive subroutine reference_write_expression (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, indent)
       else
          write (u, "('<REF>')", advance="no")
       end if
    else if (associated (object%core)) then
       call object%core%write_expression (unit, indent)
    end if
  end subroutine reference_write_expression
       
@ %def reference_write_statement
@ %def reference_write_expression
@
\subsubsection{Queries}
The name should really be the ID.
<<Object base: reference: TBP>>=
  procedure :: get_name => reference_get_name
<<Object base: procedures>>=
  pure recursive function reference_get_name (object) result (name)
    class(reference_t), intent(in) :: object
    type(string_t) :: name
    if (associated (object%id)) then
       select type (id => object%id)
       class is (id_t)
          name = id%get_path_string ()
       end select
    else if (associated (object%core)) then
       name = object%core%get_name ()
    else
       name = "<???>"
    end if
  end function reference_get_name
  
@ %def reference_get_name
@ The signature includes a [[reference]] string.
<<Object base: reference: TBP>>=
  procedure :: get_signature => reference_get_signature
<<Object base: procedures>>=
  pure recursive function reference_get_signature (object, verbose) &
       result (signature)
    class(reference_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    if (associated (object%core)) then
       signature = object%core%get_signature ()
       if (signature /= "") then
          signature = "reference|" // signature
       else
          signature = "reference"
       end if
    else
       signature = "reference"
    end if
  end function reference_get_signature
  
@ %def reference_get_signature
@ A reference is a reference.
<<Object base: reference: TBP>>=
  procedure :: is_reference => reference_is_reference
<<Object base: procedures>>=
  pure function reference_is_reference (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function reference_is_reference
  
@ %def reference_is_reference
@ This query tells whether the object contains an ID subobject.
<<Object base: reference: TBP>>=
  procedure :: has_id => reference_has_id
<<Object base: procedures>>=
  pure function reference_has_id (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = associated (object%id)
  end function reference_has_id
  
@ %def reference_has_id
@ Return the pointer to the ID subobject, if any.
<<Object base: reference: TBP>>=
  procedure :: get_id_ptr => reference_get_id_ptr
<<Object base: procedures>>=
  subroutine reference_get_id_ptr (object, id)
    class(reference_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => object%id
  end subroutine reference_get_id_ptr
  
@ %def reference_get_id_ptr
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.
<<Object base: reference: TBP>>=
  procedure :: instantiate => reference_instantiate
<<Object base: procedures>>=
  recursive subroutine reference_instantiate (object, instance)
    class(reference_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (reference_t :: instance)
  end subroutine reference_instantiate
    
@ %def reference_instantiate
<<Object base: reference: TBP>>=
  procedure :: set_path => reference_set_path
<<Object base: procedures>>=
  subroutine reference_set_path (object, lhs_path)
    class(reference_t), intent(inout) :: object
    type(string_t), dimension(:), intent(in) :: lhs_path
    allocate (id_t :: object%id)
    select type (id => object%id)
    type is (id_t)
       call id%init (lhs_path)
    end select
  end subroutine reference_set_path
    
@ %def reference_set_path
@ Import an existing ID object.
<<Object base: reference: TBP>>=
  procedure :: import_id => reference_import_id
<<Object base: procedures>>=
  subroutine reference_import_id (object, id)
    class(reference_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: id
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    object%id => id
    id => null ()
  end subroutine reference_import_id
  
@ %def reference_import_id
@ Link the core as a pointer to an existing object, updating the reference
count.
<<Object base: reference: TBP>>=
  procedure :: link_core => reference_link_core
<<Object base: procedures>>=
  subroutine reference_link_core (object, remote)
    class(reference_t), intent(inout) :: object
    class(object_t), intent(inout), target :: remote
    class(object_t), pointer :: remote_target
    call object%final ()
    remote_target => remote%dereference ()
    object%core => remote_target
    remote_target%refcount = remote_target%refcount + 1
  end subroutine reference_link_core
    
@ %def reference_link_core
@ Resolve: Find the object that belongs to the stored ID and link it to the
reference's core.

TODO: match the target type against a prototype.
<<Object base: reference: TBP>>=
  procedure :: resolve => reference_resolve
<<Object base: procedures>>=
  subroutine reference_resolve (object, success)
    class(reference_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: remote
    if (object%has_id ()) then
       select type (id => object%id)
       type is (id_t)
          call object%find (id%get_path (), remote)
       end select
    end if
    success = associated (remote)
    if (success) then
       call object%link_core (remote)
    end if
  end subroutine reference_resolve
    
@ %def reference_resolve
@
\subsubsection{Code}
Code is simple.  The reference will be followed by the target ID.
<<Object base: reference: TBP>>=
  procedure :: get_code => reference_get_code
<<Object base: procedures>>=
  function reference_get_code (object, repository) result (code)
    class(reference_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_REFERENCE
  end function reference_get_code
  
@ %def reference_get_code
@
\subsubsection{Tools}
Dereference.
<<Object base: reference: TBP>>=
  procedure :: dereference => reference_dereference
<<Object base: procedures>>=
  recursive function reference_dereference (object) result (remote)
    class(reference_t), intent(in), target :: object
    class(object_t), pointer :: remote
    if (associated (object%core)) then
       remote => object%core%dereference ()
    else
       remote => object
    end if
  end function reference_dereference

@ %def reference_dereference
@
\subsection{Composite object type}
A composite object is an extension of a wrapper: it consists of a core
(essentially, its value) and members (properties). 

Each object has a name which should be unique within the current scope
(i.e., as a member of the parent object, if any).  It also has a mode
(abstract, constant, variable) which controls the assignment of values.

Each object is derived from a [[prototype]].

Objects may be instrinsic or user-defined, inheriting from some intrinsic
prototype. 
<<Object base: parameters>>=
  integer, parameter, public :: MODE_ABSTRACT = 0
  integer, parameter, public :: MODE_CONSTANT = 1
  integer, parameter, public :: MODE_VARIABLE = 2

@ %def MODE_ABSTRACT MODE_CONSTANT MODE_VARIABLE
@
<<Object base: public>>=
  public :: composite_t
<<Object base: types>>=
  type, extends (wrapper_t) :: composite_t
     private
     type(string_t) :: name
     integer :: mode = MODE_ABSTRACT
     logical :: intrinsic = .true.
     class(composite_t), pointer :: prototype => null ()
     logical, dimension(:), allocatable :: member_is_argument
     type(wrapper_t), dimension(:), pointer :: member => null ()
     type(wrapper_t), dimension(:), pointer :: primer => null ()
   contains
   <<Object base: composite: TBP>>
  end type composite_t

@ %def composite_t
@
\subsubsection{Finalizer}
The finalizer has to take care of core and members.
<<Object base: composite: TBP>>=
  procedure :: final => composite_final
<<Object base: procedures>>=
  recursive subroutine composite_final (object)
    class(composite_t), intent(inout) :: object
    integer :: i
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          if (associated (object%primer(i)%core)) then
             call remove_object (object%primer(i)%core)
          end if
       end do
       deallocate (object%primer)
    end if
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (associated (object%member(i)%core)) then
             call remove_object (object%member(i)%core)
          end if
       end do
       deallocate (object%member)
       deallocate (object%member_is_argument)
    end if
    call object%wrapper_t%final ()
    call object%unregister ()
  end subroutine composite_final
       
@ %def composite_final
@
\subsubsection{Output}
Value: this is the core, if any.
<<Object base: composite: TBP>>=
  procedure :: write_value => composite_write_value
<<Object base: procedures>>=
  recursive subroutine composite_write_value (object, unit, indent)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%has_value ()) then
       call object%core%write_as_value (unit, indent)
    else
       call object_write_stub (object, unit, indent)
    end if
  end subroutine composite_write_value
    
@ %def composite_write_value
@
Mantle: members/arguments and primer statements.  This explicit routine writes
indices for members.
<<Object base: composite: TBP>>=
  procedure :: write_mantle => composite_write_mantle
<<Object base: procedures>>=
  recursive subroutine composite_write_mantle (object, unit, indent, refcount)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: member, primer
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call write_indent (u, ind)
          if (object%member_is_argument (i)) then
             write (u, "('A')", advance="no")
          else
             write (u, "('M')", advance="no")
          end if
          write (u, "(I0,':',1x)", advance="no") i
          if (object%member(i)%is_reference ()) then
             write (u, "('*')", advance="no")
          end if
          call object%get_member_ptr (i, member)
          if (associated (member)) then
             call member%write (u, ind, refcount)
          else
             write (u, "('<>')")
          end if
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call write_indent (u, ind)
          write (u, "('P',I0,':',1x)", advance="no") i
          call object%get_primer_ptr (i, primer)
          if (associated (primer)) then
             call primer%write_as_statement (u, ind)
          end if
          write (u, *)
       end do
    end if
  end subroutine composite_write_mantle
  
@ %def composite_write_mantle
@
\subsubsection{Prototype feature}
When an instance of a composite is created, it should call the
[[register]] method with specified object as prototype.

The [[register]] method must be public, since the assignment type uses it.

The [[unregister]] method is called only by [[remove_object]] and therefore
is private.  It calls [[remove_object]] for the prototype, which will delete
the prototype object if there is no other instance of it.

The new object inherits the [[intrinsic]] tag from its prototype, so
we don't need to unset it manually.
<<Object base: composite: TBP>>=
  procedure, non_overridable :: register => composite_register
  procedure, non_overridable, private :: unregister => composite_unregister
<<Object base: procedures>>=
  subroutine composite_register (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    object%prototype => prototype
    prototype%refcount = prototype%refcount + 1
    object%intrinsic = prototype%intrinsic
  end subroutine composite_register

  recursive subroutine composite_unregister (object)
    class(composite_t), intent(inout) :: object
    class(object_t), pointer :: prototype
    prototype => object%prototype 
    call remove_object (prototype)
    object%prototype => null ()
  end subroutine composite_unregister

@ %def composite_register
@ %def composite_unregister
@ If the object is not an instance, we associate it to the given prototype.
<<Object base: composite: TBP>>=
  procedure :: set_default_prototype => composite_set_default_prototype
<<Object base: procedures>>=
  subroutine composite_set_default_prototype (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    if (.not. associated (object%prototype)) then
       call object%register (prototype)
    end if
  end subroutine composite_set_default_prototype
    
@ %def composite_set_default_prototype
@ If the prototype is a repository member, we can obtain the index of the
prototype.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_index => composite_get_prototype_index
<<Object base: procedures>>=
  function composite_get_prototype_index (object, repository) result (i)
    class(composite_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    if (associated (object%prototype)) then
       call repository%find_member (object%prototype%get_name (), index=i)
    else
       i = 0
    end if
  end function composite_get_prototype_index

@ %def composite_get_prototype_index
@
\subsubsection{Queries}
Access the object's name.
<<Object base: composite: TBP>>=
  procedure :: get_name => composite_get_name
<<Object base: procedures>>=
  pure function composite_get_name (object) result (name)
    class(composite_t), intent(in) :: object
    type(string_t) :: name
    name = object%name
  end function composite_get_name
  
@ %def composite_get_name
@ Prototype string: actually, the prototype of the value object, i.e., the
core.  If there is a core, delegate the function.  Otherwise, delegate to the
prototype or revert to the plain object.

The exception are non-intrinsic objects, for which we write the prototype name
with an enclosing [[type(..)]] clause.
<<Object base: composite: TBP>>=
  procedure :: get_prototype => composite_get_prototype
<<Object base: procedures>>=
  recursive function composite_get_prototype (object) result (prototype)
    class(composite_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%prototype)) then
       if (object%prototype%intrinsic) then
          prototype = object%prototype%get_name ()
       else
          prototype = "type(" // object%prototype%get_name () // ")"
       end if
    else
       prototype = object_get_prototype (object)
    end if   
  end function composite_get_prototype
  
@ %def composite_get_prototype
@ The signature of a composite object.
<<Object base: composite: TBP>>=
  procedure :: get_signature => composite_get_signature
<<Object base: procedures>>=
  pure function composite_get_signature (object, verbose) result (signature)
    class(composite_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    select case (object%mode)
    case (MODE_ABSTRACT)
       signature = "abstract"
    case (MODE_CONSTANT)
       signature = "constant"
    case (MODE_VARIABLE)
       if (verb) then
          signature = "variable"
       else
          signature = ""
       end if
    end select
  end function composite_get_signature
       
@ %def composite_get_signature
@ This query tells whether the object has a core, and this core
describes a value.
<<Object base: composite: TBP>>=
  procedure :: has_value => composite_has_value
<<Object base: procedures>>=
  pure function composite_has_value (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    if (object%is_statement ()) then
       flag = .false.
    else
       select case (object%mode)
       case (MODE_CONSTANT, MODE_VARIABLE)
          flag = associated (object%core)
       case default
          flag = .false.
       end select
    end if
  end function composite_has_value
  
@ %def composite_has_value
@ The definition status is delegated to the core.
<<Object base: composite: TBP>>=
  procedure :: is_defined => composite_is_defined
<<Object base: procedures>>=
  pure function composite_is_defined (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    if (object%has_value ()) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function composite_is_defined
  
@ %def composite_is_defined
@ Yes if there are member or primer components.
<<Object base: composite: TBP>>=
  procedure :: has_mantle => composite_has_mantle
<<Object base: procedures>>=
  pure function composite_has_mantle (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    flag = object%get_n_members () + object%get_n_primers () > 0
  end function composite_has_mantle
  
@ %def composite_has_mantle
@ Return the number of members, of members that are marked as arguments, and
of primer statements, respectively.
<<Object base: composite: TBP>>=
  procedure :: get_n_members => composite_get_n_members
  procedure :: get_n_arguments => composite_get_n_arguments
  procedure :: get_n_primers => composite_get_n_primers
<<Object base: procedures>>=
  pure function composite_get_n_members (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = size (object%member)
    else
       n = 0
    end if
  end function composite_get_n_members
  
  pure function composite_get_n_arguments (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = count (object%member_is_argument)
    else
       n = 0
    end if
  end function composite_get_n_arguments
  
  pure function composite_get_n_primers (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%primer)) then
       n = size (object%primer)
    else
       n = 0
    end if
  end function composite_get_n_primers
  
@ %def composite_get_n_members
@ %def composite_get_n_arguments
@ %def composite_get_n_primers
@ Return pointer to a specific member (dereference and return the core).
<<Object base: composite: TBP>>=
  procedure :: get_member_ptr => composite_get_member_ptr
  procedure :: get_primer_ptr => composite_get_primer_ptr
<<Object base: procedures>>=
  subroutine composite_get_member_ptr (object, i, member)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    if (associated (object%member)) then
       if (associated (object%member(i)%core)) then
          member => object%member(i)%core%dereference ()
       else
          member => null ()
       end if
    else
       member => null ()
    end if
  end subroutine composite_get_member_ptr
  
  subroutine composite_get_primer_ptr (object, i, primer)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    if (associated (object%primer)) then
       if (associated (object%primer(i)%core)) then
          primer => object%primer(i)%core%dereference ()
       else
          primer => null ()
       end if
    else
       primer => null ()
    end if
  end subroutine composite_get_primer_ptr
  
@ %def composite_get_member_ptr
@ %def composite_get_primer_ptr
@ Prototype status and pointer.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_ptr => composite_get_prototype_ptr
<<Object base: procedures>>=
  subroutine composite_get_prototype_ptr (object, prototype)
    class(composite_t), intent(in) :: object
    class(composite_t), intent(out), pointer :: prototype
    prototype => object%prototype
  end subroutine composite_get_prototype_ptr
  
@ %def composite_get_prototype_ptr
@ Query the object mode.  The [[check_mode]] subroutine returns success if an
object is supposed to be mutable.
<<Object base: composite: TBP>>=
  procedure :: check_mode => composite_check_mode
<<Object base: procedures>>=
  pure subroutine composite_check_mode (object, mutable)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: mutable
    select case (object%mode)
    case (MODE_ABSTRACT);  mutable = .false.
    case default
       mutable = .true.
    end select
  end subroutine composite_check_mode
  
@ %def composite_check_mode
@ This query tells if the object is required in an assignment.
<<Object base: composite: TBP>>=
  procedure :: check_role => composite_check_role
<<Object base: procedures>>=
  pure subroutine composite_check_role (object, required)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: required
    select case (object%mode)
    case (MODE_ABSTRACT)
       required = .false.
       if (associated (object%core)) then
          select type (core => object%core)
          type is (tag_t);  required = .true.
          end select
       end if
    case (MODE_CONSTANT, MODE_VARIABLE)
       required = .true.
    case default
       required = .false.
    end select
  end subroutine composite_check_role
  
@ %def composite_check_role
@
\subsubsection{Constructors and Initialization}
Instantiate: setup a composite with the same core as the prototype.
<<Object base: composite: TBP>>=
  procedure :: instantiate => composite_instantiate
<<Object base: procedures>>=
  recursive subroutine composite_instantiate (object, instance)
    class(composite_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (composite_t :: instance)
    select type (instance)
    class is (composite_t)
       call instance%register (object)
       if (associated (object%core)) &
            call object%core%instantiate (instance%core)
    end select
  end subroutine composite_instantiate
  
@ %def composite_instantiate
@
The attribute list consists of [[intrinsic]] and [[mode]], expressed as
integers.

Attribute codes are assigned as follows:
\begin{enumerate}
\item Prototype index, from the repository
\item [[mode]]
\item [[intrinsic]] status
\item Number of members
\item Number of arguments (included in members)
\item Number of primer statements
\end{enumerate}
<<Object base: composite: TBP>>=
  procedure :: get_code => composite_get_code
<<Object base: procedures>>=
  function composite_get_code (object, repository) result (code)
    class(composite_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
    call object%get_name_code (code)
  end function composite_get_code
  
@ %def composite_get_code
@ Separate procedures for base code and name string.
<<Object base: composite: TBP>>=
  procedure :: get_base_code => composite_get_base_code
  procedure :: get_name_code => composite_get_name_code
<<Object base: procedures>>=
  subroutine composite_get_base_code (object, code, repository)
    class(composite_t), intent(in), target :: object
    type(code_t), intent(inout) :: code
    type(repository_t), intent(in), optional :: repository
    code%cat = CAT_COMPOSITE
    code%natt = 6
    if (present (repository)) then
       code%att(1) = object%get_prototype_index (repository)
    end if
    code%att(2) = object%mode
    if (.not. object%intrinsic) then
       code%att(3) = 1
    end if
    code%att(4) = object%get_n_members ()
    code%att(5) = object%get_n_arguments ()
    code%att(6) = object%get_n_primers ()
  end subroutine composite_get_base_code
  
  subroutine composite_get_name_code (object, code)
    class(composite_t), intent(in), target :: object
    type(code_t), intent(inout) :: code
    call code%create_string_val (object%get_name ())
  end subroutine composite_get_name_code
  
@ %def composite_get_base_code  
@ %def composite_get_name_code  
@ Initialize from code.
<<Object base: composite: TBP>>=
  procedure :: init_from_code => composite_init_from_code
<<Object base: procedures>>=
  subroutine composite_init_from_code (object, code)
    class(composite_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    type(string_t) :: name
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_string_t);  name = val%x(1)
       class default;  name = ""
       end select
    else
       name = ""
    end if
    call object%init ( &
         name = name, &
         mode = code%att(2), &
         n_members = code%att(4), &
         n_arguments = code%att(5), &
         n_primers = code%att(6))
    call object%set_intrinsic (code%att(3) == 0)
  end subroutine composite_init_from_code

@ %def composite_init_from_code
@ Initialize/reset.

The initializer will prepare for a member array sized [[n_members]], a primer
statement array sized [[n_primers]], and a number of named positional
arguments [[n_args]].  The latter are included in [[n_members]].  If a number
is not provided, the corresponding array is not allocated. 
<<Object base: composite: TBP>>=
  generic :: init => composite_init
  procedure, private :: composite_init
  procedure :: set_mode => composite_set_mode
  procedure :: set_intrinsic => composite_set_intrinsic
  procedure :: init_members => composite_init_members
  procedure :: init_primers => composite_init_primers
<<Object base: procedures>>=
  subroutine composite_init &
       (object, name, mode, n_members, n_arguments, n_primers)
    class(composite_t), intent(inout), target :: object
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    integer, intent(in), optional :: n_members
    integer, intent(in), optional :: n_arguments
    integer, intent(in), optional :: n_primers
    object%name = name
    if (present (mode))  call object%set_mode (mode)
    if (present (n_members)) then
       call object%init_members (n_members, n_arguments)
    end if
    if (present (n_primers)) then
       call object%init_primers (n_primers)
    end if
  end subroutine composite_init
 
  subroutine composite_set_mode (object, mode)
    class(composite_t), intent(inout) :: object
    integer, intent(in) :: mode
    object%mode = mode
  end subroutine composite_set_mode

  subroutine composite_set_intrinsic (object, intrinsic)
    class(composite_t), intent(inout) :: object
    logical, intent(in) :: intrinsic
    object%intrinsic = intrinsic
  end subroutine composite_set_intrinsic

  subroutine composite_init_members (object, n_members, n_arguments)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: n_members
    integer, intent(in), optional :: n_arguments
    integer :: i
    allocate (object%member (n_members))
    do i = 1, n_members
       call object%member(i)%set_context (object)
    end do
    allocate (object%member_is_argument (n_members), source = .false.)
    if (present (n_arguments)) then
       object%member_is_argument(1:n_arguments) = .true.
    end if
  end subroutine composite_init_members
 
  subroutine composite_init_primers (object, n_primers)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: n_primers
    integer :: i
    allocate (object%primer (n_primers))
    do i = 1, n_primers
       call object%primer(i)%set_context (object)
    end do
  end subroutine composite_init_primers
 
@ %def composite_init
@ %def composite_set_mode
@ %def composite_init_members
@ %def composite_init_primers
@
Mark the object as non-intrinsic.  Default is intrinsic.
<<Object base: composite: TBP>>=
  procedure :: tag_non_intrinsic => composite_tag_non_intrinsic
<<Object base: procedures>>=
  pure subroutine composite_tag_non_intrinsic (object)
    class(composite_t), intent(inout) :: object
    object%intrinsic = .false.
  end subroutine composite_tag_non_intrinsic
  
@ %def composite_tag_non_intrinsic
@ Import a member object which has been created previously.  The object will
become the member's core.  No copy is made, the original pointer is
discarded.
<<Object base: composite: TBP>>=
  procedure :: import_member => composite_import_member
  procedure :: link_member => composite_link_member
<<Object base: procedures>>=
  subroutine composite_import_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    call member%set_context (object%member(i))
    call object%member(i)%final ()
    call object%member(i)%import_core (member)
  end subroutine composite_import_member
    
  subroutine composite_link_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    class(object_t), pointer :: ref
    call member%make_reference (ref)
    call object%import_member (i, ref)
  end subroutine composite_link_member
    
@ %def composite_import_member
@ %def composite_link_member
@ Import a primer object which has been created previously.  The object will
become the core of the primer reference.  No copy is made, the original
pointer is discarded.
<<Object base: composite: TBP>>=
  procedure :: import_primer => composite_import_primer
<<Object base: procedures>>=
  subroutine composite_import_primer (object, i, primer)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: primer
    call primer%set_context (object%primer(i))
    call object%primer(i)%final ()
    call object%primer(i)%import_core (primer)
  end subroutine composite_import_primer
    
@ %def composite_import_primer
@
\subsubsection{Evaluation}
Resolve: First resolve arguments/members, then primer statements.
<<Object base: composite: TBP>>=
  procedure :: resolve => composite_resolve
<<Object base: procedures>>=
  recursive subroutine composite_resolve (object, success)
    class(composite_t), intent(inout), target :: object
    logical, intent(out) :: success
    integer :: i
    success = .true.
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call object%member(i)%core%resolve (success)
          if (.not. success)  return
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call object%primer(i)%core%resolve (success)
          if (.not. success)  return
       end do
    end if
  end subroutine composite_resolve
  
@ %def composite_resolve
@ Evaluation: first arguments, then primer statements.
<<Object base: composite: TBP>>=
  procedure :: evaluate => composite_evaluate
<<Object base: procedures>>=
  recursive subroutine composite_evaluate (object)
    class(composite_t), intent(inout), target :: object
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (object%member_is_argument(i)) then
             call object%member(i)%core%evaluate ()
          end if
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call object%primer(i)%core%evaluate ()
       end do
    end if
  end subroutine composite_evaluate
  
@ %def composite_evaluate
@
\subsubsection{Iterator Support}
Iterate: first scan the members, then core.  Then, return to
context.
<<Object base: public>>=
  public :: composite_next_position
<<Object base: composite: TBP>>=
  procedure :: next_position => composite_next_position
<<Object base: procedures>>=
  subroutine composite_next_position &
       (object, position, next_object, import_object)
    class(composite_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE, POS_ID)
       if (object%get_n_members () > 0) then
          position%part = POS_MEMBER
          position%i = 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case (POS_MEMBER)
       if (position%i < size (object%member)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case (POS_PRIMER)
       if (position%i < size (object%primer)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case default
       call wrapper_next_position &
            (object, position, next_object, import_object)
    end select
  end subroutine composite_next_position
  
@ %def composite_next_position
@
\subsubsection{Tools}
Return a pointer to a path, given in form of an array of strings.  If no
object is found, return a null pointer.  Otherwise, return a pointer to the
object as [[member]].

First search the immediate members of the current object.  Then search the
prototype object.
<<Object base: composite: TBP>>=
  procedure :: find => composite_find
<<Object base: procedures>>=
  recursive subroutine composite_find (object, path, member)
    class(composite_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: parent
    member => null ()
    if (size (path) > 0) then
       call object%find_member (path(1), member)
       if (associated (member)) then
          if (size (path) > 1) then
             parent => member
             call parent%find (path(2:), member)
          end if
       else
          if (associated (object%prototype)) then
             call object%prototype%find (path, member)
          end if
          if (.not. associated (member)) then
             call wrapper_find (object, path, member)
          end if
       end if
    end if
  end subroutine composite_find
    
@ %def composite_find_member
@ Return a pointer to a specific member.  If the object has no members, or the
member is not found, return a null pointer.
<<Object base: composite: TBP>>=
  procedure :: find_member => composite_find_member
<<Object base: procedures>>=
  subroutine composite_find_member (object, name, member, index)
    class(composite_t), intent(in) :: object
    type(string_t), intent(in) :: name
    class(object_t), intent(out), optional, pointer :: member
    integer, intent(out), optional :: index
    class(object_t), pointer :: core
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call object%member(i)%get_core_ptr (core)
          if (core%get_name () == name) then
             if (present (member))  member => core%dereference ()
             if (present (index))  index = i
             return
          end if
       end do
    end if
    if (present (member))  member => null ()
    if (present (index))  index = 0
  end subroutine composite_find_member
    
@ %def composite_find_member
@ Expand the member array by inserting empty entries at the end.
<<Object base: composite: TBP>>=
  procedure :: expand => composite_expand
<<Object base: procedures>>=
  subroutine composite_expand (object, n_extra, is_argument)
    class(composite_t), intent(inout) :: object
    integer, intent(in) :: n_extra
    logical, intent(in) :: is_argument
    type(wrapper_t), dimension(:), pointer :: member
    class(object_t), pointer :: core
    integer :: i
    member => object%member
    allocate (object%member (object%get_n_members () + n_extra))
    if (associated (member)) then
       do i = 1, size (member)
          call member(i)%get_core_ptr (core)
          if (associated (core))  call object%import_member (i, core)
       end do
    end if
    object%member_is_argument = &
         [object%member_is_argument, spread (is_argument, 1, n_extra)]
  end subroutine composite_expand
    
@ %def composite_expand
@
\subsection{Repository}
A repository is a simple extension of a generic [[composite_t]] object.  It
collects the objects that are supposed to act as prototypes.  We hold those
objects as members and access them by name or by index.

It has a [[spawn]] method which allows it to create new objects from those
prototypes.
<<Object base: public>>=
  public :: repository_t
<<Object base: types>>=
  type, extends (composite_t) :: repository_t
     private
   contains
   <<Object base: repository: TBP>>
  end type repository_t
  
@ %def repository_t
@ Include: add a new object as a prototype to the repository member array.  We
have to extend the array by one.  The new object is stored as a non-local
reference.
<<Object base: repository: TBP>>=
  procedure :: include => repository_include
<<Object base: procedures>>=
  subroutine repository_include (repository, object)
    class(repository_t), intent(inout), target :: repository
    class(object_t), intent(inout), target :: object
    type(wrapper_t), dimension(:), pointer :: new_member
    logical, dimension(:), allocatable :: member_is_argument
    class(object_t), pointer :: ref
    integer :: n
    n = size (repository%member) 
    allocate (new_member (n + 1))
    new_member(1:n) = repository%member
    deallocate (repository%member)
    call object%make_reference (ref)
    call new_member(n+1)%import_core (ref)
    call new_member(n+1)%set_context (repository)
    repository%member => new_member
    deallocate (repository%member_is_argument)
    allocate (repository%member_is_argument (n+1), source=.false.)
  end subroutine repository_include
    
@ %def repository_include
@ There are two variants of the [[spawn]] method: either search for the
prototype name or use a known member index.
<<Object base: repository: TBP>>=
  generic :: spawn => spawn_by_name, spawn_by_index
  procedure, private :: spawn_by_name
  procedure, private :: spawn_by_index
<<Object base: procedures>>=
  subroutine spawn_by_name (repository, name, object)
    class(repository_t), intent(in) :: repository
    type(string_t), intent(in) :: name
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%find_member (name, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_name
    
  subroutine spawn_by_index (repository, i, object)
    class(repository_t), intent(in) :: repository
    integer, intent(in) :: i
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%get_member_ptr (i, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_index
    
@ %def spawn_by_name
@ %def spawn_by_index
@ Extract an array that contains all member names, so we have an independent
lookup for prototypes.
<<Object base: repository: TBP>>=
  procedure :: get_prototype_names => repository_get_prototype_names
<<Object base: procedures>>=
  subroutine repository_get_prototype_names (repository, name)
    class(repository_t), intent(in) :: repository
    type(string_t), dimension(:), allocatable, intent(out) :: name
    class(object_t), pointer :: prototype
    integer :: i
    allocate (name (repository%get_n_members ()))
    do i = 1, size (name)
       call repository%get_member_ptr (i, prototype)
       name(i) = prototype%get_name ()
    end do
  end subroutine repository_get_prototype_names
    
@ %def repository_get_prototype_names 
@
\subsection{Object iterator}
The object iterator allows us to traverse the object tree in a well-defined
oorder.   

\subsubsection{Iterator stack}
Positions objects are pushed on a stack (LIFO).  This constitutes the
iterator, the last stack entry provides the current object pointer.
<<Object base: types>>=
  type, extends (position_t) :: position_entry_t
     private
     class(object_t), pointer :: object => null ()
     type(position_entry_t), pointer :: previous => null ()
  end type position_entry_t
  
@ %def position_entry_t
<<Object base: public>>=
  public :: object_iterator_t
<<Object base: types>>=
  type :: object_iterator_t
     private
     type(position_entry_t), pointer :: current => null ()
   contains
   <<Object base: object iterator: TBP>>
  end type object_iterator_t
  
@ %def object_iterator
@ Recursively clear.
<<Object base: object iterator: TBP>>=
  procedure :: final => object_iterator_final
<<Object base: procedures>>=
  subroutine object_iterator_final (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    do while (associated (it%current))
       call it%pop ()
    end do
  end subroutine object_iterator_final
    
@ %def object_iterator_final
@ Output for debugging purposes.
<<Object base: object iterator: TBP>>=
  procedure :: write => object_iterator_write
<<Object base: procedures>>=
  subroutine object_iterator_write (it, unit)
    class(object_iterator_t), intent(in) :: it
    integer, intent(in), optional :: unit
    type(position_entry_t), pointer :: entry
    integer :: u
    u = given_output_unit (unit)
    entry => it%current
    do while (associated (entry))
       call entry%write (u)
       entry => entry%previous
    end do
  end subroutine object_iterator_write
  
@ %def object_iterator_write
@ Push/pop a fresh position object at the it entry point.
<<Object base: object iterator: TBP>>=
  procedure, private :: push => object_iterator_push
  procedure, private :: pop => object_iterator_pop
<<Object base: procedures>>=
  subroutine object_iterator_push (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    allocate (entry)
    entry%previous => it%current
    it%current => entry
  end subroutine object_iterator_push
    
  subroutine object_iterator_pop (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    entry => it%current
    if (associated (entry)) then
       it%current => entry%previous
       deallocate (entry)
    else
       it%current => null ()
    end if
  end subroutine object_iterator_pop
  
@ %def object_iterator_push
@ %def object_iterator_pop
@
\subsubsection{Iterator: initialization and query}
Create a single-entry it and position at the root object.
<<Object base: object iterator: TBP>>=
  procedure :: init => object_iterator_init
<<Object base: procedures>>=
  subroutine object_iterator_init (it, object)
    class(object_iterator_t), intent(out) :: it
    class(object_t), intent(in), target :: object
    call it%push ()
    it%current%object => object
  end subroutine object_iterator_init
    
@ %def object_iterator_init
@ The iterator is valid as long as the stack has a
current entry, associated with the current object.
<<Object base: object iterator: TBP>>=
  procedure :: is_valid => object_iterator_is_valid
<<Object base: procedures>>=
  function object_iterator_is_valid (it) result (flag)
    class(object_iterator_t), intent(in) :: it
    logical :: flag
    flag = associated (it%current)
    if (flag)  flag = associated (it%current%object)
  end function object_iterator_is_valid
  
@ %def object_iterator_is_valid
@ Return the object pointer.
<<Object base: object iterator: TBP>>=
  procedure :: get_object => object_iterator_get_object
<<Object base: procedures>>=
  subroutine object_iterator_get_object (it, object)
    class(object_iterator_t), intent(in) :: it
    class(object_t), pointer, intent(out) :: object
    if (associated (it%current)) then
       object => it%current%object
    else
       object => null ()
    end if
  end subroutine object_iterator_get_object
  
@ %def object_iterator_get_object
@ Return the code for the next object in automatic navigation order.
<<Object base: object iterator: TBP>>=
  procedure :: get_next_position => object_iterator_get_next_position
<<Object base: procedures>>=
  subroutine object_iterator_get_next_position (it, position)
    class(object_iterator_t), intent(inout) :: it
    type(position_t), intent(out) :: position
    if (associated (it%current)) then
       position = it%current%position_t
       call it%current%object%next_position (position)
    end if
  end subroutine object_iterator_get_next_position
    
@ %def object_iterator_get_next_position
@
\subsubsection{Automatic navigation}
Advance, traversing the objects in well-defined order.  The order is under
control of the current object.  It should increment the position counter and
return a pointer to the next object in line, if possible.

If the [[import_object]] argument is given, insert this as the next object in
the object tree, before moving to it.  If the insertion was successful, the
[[import_object]] pointer will be null on exit.
<<Object base: object iterator: TBP>>=
  procedure :: advance => object_iterator_advance
<<Object base: procedures>>=
  recursive subroutine object_iterator_advance (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    class(position_t), pointer :: position
    class(object_t), pointer :: next_object
    position => it%current
    call it%current%object%next_position (position, next_object, import_object)
    select case (position%part)
    case (POS_NONE)
       call it%skip (import_object)
    case default
       call it%push ()
       it%current%object => next_object
    end select
  end subroutine object_iterator_advance
       
@ %def object_iterator_advance
@ This is a variant that tells the iterator to skip the current object and all
of its subobjects, returning to the previous stack entry and advancing from
there.  The routine is also called by [[advance]] when the current object is
already exhausted.
<<Object base: object iterator: TBP>>=
  procedure :: skip => object_iterator_skip
<<Object base: procedures>>=
  recursive subroutine object_iterator_skip (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    call it%pop ()
    if (it%is_valid ()) then
       call it%advance (import_object)
    else
       call it%final ()
    end if
  end subroutine object_iterator_skip
       
@ %def object_iterator_skip
@
\subsubsection{Manual navigation}
Navigate in specific ways.
<<Object base: object iterator: TBP>>=
  procedure :: to_context => object_iterator_to_context
  procedure :: to_id => object_iterator_to_id
  procedure :: to_core => object_iterator_to_core
  procedure :: to_member => object_iterator_to_member
  procedure :: to_primer => object_iterator_to_primer
<<Object base: procedures>>=
  subroutine object_iterator_to_context (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    if (it%is_valid ()) then
       call it%pop ()
       success = .true.
    else
       success = .false.
    end if
  end subroutine object_iterator_to_context

  subroutine object_iterator_to_id (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = .false.
    object => it%current%object
    if (object%has_id ()) then
       it%current%part = POS_ID
       call it%push ()
       call object%get_id_ptr (it%current%object)
       success = .true.
    end if
  end subroutine object_iterator_to_id

  subroutine object_iterator_to_core (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (wrapper_t)
       if (associated (object%core)) then
          it%current%part = POS_CORE
          call it%push ()
          it%current%object => object%core
          success = .true.
       end if
    end select
  end subroutine object_iterator_to_core

  subroutine object_iterator_to_member (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%member)) then
          if (0 < i .and. i <= size (object%member)) then
             if (associated (object%member(i)%core)) then
                it%current%part = POS_MEMBER
                it%current%i = i
                call it%push ()
                it%current%object => object%member(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_member

  subroutine object_iterator_to_primer (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%primer)) then
          if (0 < i .and. i <= size (object%primer)) then
             if (associated (object%primer(i)%core)) then
                it%current%part = POS_PRIMER
                it%current%i = i
                call it%push ()
                it%current%object => object%primer(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_primer

@ %def object_iterator_to_context
@ %def object_iterator_to_id
@ %def object_iterator_to_core
@ %def object_iterator_to_member
@ %def object_iterator_to_primer
@ 
\subsection{Unit tests}
<<Object base: public>>=
  public :: object_base_test
<<Object base: procedures>>=
  subroutine object_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object base: execute tests>>  
  end subroutine object_base_test
  
@ %def object_base_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Object base: execute tests>>=
  call test (object_base_1, "object_base_1", &
       "object and prototype", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: obj1, obj2
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_1"
    write (u, "(A)")  "*   Purpose: elementary operations with objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Trivial object (tag): create, instantiate, display"

    allocate (tag_t :: obj1)
    call obj1%instantiate (obj2)
    
    write (u, "(A)")
    call obj1%write (u, refcount=.true.)
    call obj2%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Object code:"
    write (u, "(A)")

    code = obj1%get_code ()
    call code%write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    call remove_object (obj1)
    call remove_object (obj2)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (obj1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (obj2)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_1"
    
    end subroutine object_base_1

@ %def object_base_1
@ Create a composite object.
<<Object base: execute tests>>=
  call test (object_base_2, "object_base_2", &
       "composite object", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, object1, object2, object3
    class(object_t), pointer :: member
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_2"
    write (u, "(A)")  "*   Purpose: build composite objects"

    write (u, "(A)")      
    write (u, "(A)")  "* Create tag prototype"
    
    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite without members"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%init (name = var_str ("obj1"))
    end select
   
    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite with two members"
    
    call prototype%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%tag_non_intrinsic ()
       call object2%init (name = var_str ("obj2"), n_members = 2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object2%import_member (1, member)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (2, member)
    end select
    
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Code of obj2"
    
    code = object2%get_code ()

    write (u, "(A)")
    call code%write (u, verbose=.true.)

    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate further with additional member"
    
    call object2%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("new"))
       end select
       call object3%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj3"
    
    call remove_object (object3)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj2"
    
    call remove_object (object2)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj1"
    
    call remove_object (object1)

    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    call remove_object (prototype)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (object1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (object2)
    write (u, "(A,1x,L1)")  "obj3 allocated =", associated (object3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_2"
    
    end subroutine object_base_2

@ %def object_base_2
@ Find objects by path.
<<Object base: execute tests>>=
  call test (object_base_3, "object_base_3", &
       "object path search", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, foo, bar

    write (u, "(A)")  "* Test output: object_base_3"
    write (u, "(A)")  "*   Purpose: find objects by path"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1"

    object1 => null ()
    select type (object3)
    class is (composite_t)
       call object3%find_member (var_str ("obj1"), object1)
    end select

    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1.foo"

    foo => null ()
    call object3%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj2.foo"

    foo => null ()
    call object3%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2"

    object2 => null ()
    call object1%find ([var_str ("obj2")], object2)

    if (associated (object2)) then
       write (u, "(A)")
       call object2%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2.foo"

    foo => null ()
    call object1%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to bar"

    bar => null ()
    call object1%find ([var_str ("bar")], bar)

    if (associated (bar)) then
       write (u, "(A)")
       call bar%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at bar, return pointer to obj1.foo"

    foo => null ()
    call bar%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)

    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_3"
    
    end subroutine object_base_3

@ %def object_base_3
@ Handle references and copies.
<<Object base: execute tests>>=
  call test (object_base_4, "object_base_4", &
       "object references and copies", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: obj, ref

    write (u, "(A)")  "* Test output: object_base_4"
    write (u, "(A)")  "*   Purpose: create references and copies"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create object"
    
    call prototype%instantiate (obj)
    select type (obj)
    class is (composite_t)
       call obj%init (name = var_str ("obj"))
    end select
    
    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create reference"

    call obj%make_reference (ref)

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    call ref%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (ref)
    call remove_object (obj)
    call remove_object (prototype)
    call remove_object (tag)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj allocated =", associated (obj)
    write (u, "(A,1x,L1)")  "ref allocated =", associated (ref)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_4"
    
  end subroutine object_base_4

@ %def object_base_4
@ Iterate.
<<Object base: execute tests>>=
  call test (object_base_5, "object_base_5", &
       "object iterator", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, ptr
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_5"
    write (u, "(A)")  "*   Purpose: use iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3, skipping obj2"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       if (ptr%get_name () == "obj2") then
          call it%skip ()
          cycle
       end if
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_5"
    
    end subroutine object_base_5

@ %def object_base_5
@ Repository for prototypes.
<<Object base: execute tests>>=
  call test (object_base_6, "object_base_6", &
       "prototype repository", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object1, object2, object3, member
    type(repository_t), target :: repository
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_6"
    write (u, "(A)")  "*   Purpose: use prototype repository"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create composite with member of type tag"
     
    call repository%spawn (var_str ("tag"), object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call repository%spawn (1, member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select
 
    write (u, "(A)")
    call object1%write (u, refcount=.true.)

    write (u, "(A)")      
    code = object1%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create extension of object1"
    
    call repository%include (object1)
    call repository%spawn (var_str ("obj1"), object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"), n_members = 1)
       call repository%spawn (var_str ("tag"), member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (1, member)
    end select
       
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    code = object2%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (object2)
    call remove_object (object1)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_6"
    
    end subroutine object_base_6

@ %def object_base_6
@ Object building.
<<Object base: execute tests>>=
  call test (object_base_7, "object_base_7", &
       "build composite using code", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: main, object
    type(repository_t), target :: repository
    integer, parameter :: ncode = 4
    integer :: utmp, i
    type(code_t), dimension(ncode) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_7"
    write (u, "(A)")  "*   Purpose: object building using code and iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create anonymous wrapper"
    
    allocate (wrapper_t :: main)

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Code array for composite with member"
     
    utmp = free_unit ()
    open (utmp, status="scratch")
    ! Composite with 1 member, named 'obj1'
    write (utmp, "(A)")  "100 2 1 6 1 0 0 1 0 0"
    write (utmp, "(A)")  " obj1"
    ! Member: composite named 'foo'
    write (utmp, "(A)")  "100 2 1 6 1 0 0 0 0 0"
    write (utmp, "(A)")  " foo"
    ! Member core: tag
    write (utmp, "(A)")  "  1 0 0 0"
    ! Parent core: tag
    write (utmp, "(A)")  "  1 0 0 0"

    rewind (utmp)
    write (u, "(A)")
    do i = 1, ncode
       call code(i)%read (utmp)
       call code(i)%write (u, verbose=.true.)
    end do
    close (utmp)

    write (u, "(A)")      
    write (u, "(A)")  "* Build composite using code array"
     
    call it%init (main)
    do i = 1, ncode
       call build_object (object, code(i), repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
    end do

    write (u, "(A)")
    select type (main)
    class is (wrapper_t)
       if (associated (main%core)) then
          call main%core%write (u)
       end if
    end select
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_7"
    
    end subroutine object_base_7

@ %def object_base_7
@ Resolve named reference
<<Object base: execute tests>>=
  call test (object_base_8, "object_base_8", &
       "named reference", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_8 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: main, foo, ref
    logical :: success

    write (u, "(A)")  "* Test output: object_base_8"
    write (u, "(A)")  "*   Purpose: resolve reference by ID"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    call prototype%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create main"

    call prototype%instantiate (foo)
    select type (foo)
    class is (composite_t)
       call foo%init (name = var_str ("foo"))
    end select
    
    allocate (reference_t :: ref)
    select type (ref)
    class is (reference_t)
       call ref%set_path ([var_str ("foo")])
    end select

    allocate (composite_t :: main)
    select type (main)
    class is (composite_t)
       call main%init (name = var_str ("main"), n_members = 2)
       call main%import_member (1, foo)
       call main%import_member (2, ref)
    end select
    
    write (u, "(A)")      
    call main%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Resolve reference"

    call main%resolve (success)

    write (u, "(A)")      
    write (u, "(A,1x,L1)")  "success =", success

    write (u, "(A)")      
    call main%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (main)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_8"
    
  end subroutine object_base_8

@ %def object_base_8
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Builder}
This module introduces an [[object_builder_t]] which allows us to convert
bytecode into an object tree and back.  This is an implementation of
abstract [[builder_t]].

The code definitions are in the [[codes]] module, while the [[object_base]]
module provides a [[build_object]] procedure.  Furthermore, we need an object
repository.
<<[[object_builder.f90]]>>=
<<File header>>

module object_builder

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use diagnostics
  use codes
  use builders
  use object_base

<<Standard module head>>

<<Object builder: public>>

<<Object builder: types>>

contains

<<Object builder: procedures>>

<<Object builder: tests>>

end module object_builder
@ %def object_builder
@
\subsection{Type}
<<Object builder: public>>=
  public :: object_builder_t
<<Object builder: types>>=
  type, extends (builder_t) :: object_builder_t
     private
     type(repository_t), allocatable :: repository
     class(object_t), pointer :: main => null ()
     type(object_iterator_t) :: it
   contains
   <<Object builder: object builder: TBP>>
  end type object_builder_t
  
@ %def object_builder_t
@ 
Finalizer:
<<Object builder: object builder: TBP>>=
  procedure :: final => object_builder_final
<<Object builder: procedures>>=
  subroutine object_builder_final (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    if (allocated (builder%repository)) then
       call builder%repository%final ()
       deallocate (builder%repository)
    end if
  end subroutine object_builder_final

@ %def object_builder_final
@
Output:
<<Object builder: object builder: TBP>>=
  procedure :: write => object_builder_write
<<Object builder: procedures>>=
  subroutine object_builder_write (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(A)")  "Object builder:"
    call builder%write_repository (u)
    call builder%write_object (u)
    call builder%write_iterator (u)
  end subroutine object_builder_write

@ %def object_builder_write
@ Write parts
<<Object builder: object builder: TBP>>=
  procedure :: write_repository => object_builder_write_repository
  procedure :: write_object => object_builder_write_object
  procedure :: write_iterator => object_builder_write_iterator
<<Object builder: procedures>>=
  subroutine object_builder_write_repository (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x)", advance="no")
    if (allocated (builder%repository)) then
       call builder%repository%write (u)
    else
       write (u, "(A)")  "[no repository]"
    end if
  end subroutine object_builder_write_repository
  
  subroutine object_builder_write_object (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(object_t), pointer :: core
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x)", advance="no")
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (core)
          if (associated (core)) then
             call core%write (u)
          else
             write (u, "(A)")  "[Empty object]"
          end if
       end select
    else
       write (u, "(A)")  "[No object]"
    end if
  end subroutine object_builder_write_object
  
  subroutine object_builder_write_iterator (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (builder%it%is_valid ()) then
       write (u, "(1x,A)", advance="no")  "Iterator:"
       call builder%it%write (u)
       write (u, *)
    else
       write (u, "(1x,A)")  "[Null iterator]"
    end if
  end subroutine object_builder_write_iterator
  
@ %def object_builder_write_repository
@ %def object_builder_write_object
@ %def object_builder_write_iterator
@
\subsection{Initialization}
This is probably done only once.
<<Object builder: object builder: TBP>>=
  procedure :: import_repository => object_builder_import_repository
<<Object builder: procedures>>=
  subroutine object_builder_import_repository (builder, repository)
    class(object_builder_t), intent(inout) :: builder
    type(repository_t), intent(inout), allocatable :: repository
    call move_alloc (from=repository, to=builder%repository)
  end subroutine object_builder_import_repository
  
@ %def object_builder_import_repository
@ This can be done repeatedly.
<<Object builder: object builder: TBP>>=
  procedure :: reset => object_builder_reset
<<Object builder: procedures>>=
  subroutine object_builder_reset (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%it%final ()
    if (associated (builder%main)) then
       call remove_object (builder%main)
    end if
  end subroutine object_builder_reset
    
@ %def object_builder_reset
@ Initialize for decoding an existing object tree.  The object is allocated as
a reference to the object.  The repository is not touched.
<<Object builder: object builder: TBP>>=
  procedure :: init_object => object_builder_init_object
<<Object builder: procedures>>=
  subroutine object_builder_init_object (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(inout), target :: object
    call builder%reset ()
    call object%make_reference (builder%main)
    call builder%it%init (builder%main%dereference ())
  end subroutine object_builder_init_object
  
@ %def object_builder_init_object
@ Initialize for building a new object tree.  The object is allocated as a
wrapper.
<<Object builder: object builder: TBP>>=
  procedure :: init_empty => object_builder_init_empty
<<Object builder: procedures>>=
  subroutine object_builder_init_empty (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    allocate (wrapper_t :: builder%main)
    call builder%it%init (builder%main)
  end subroutine object_builder_init_empty
    
@ %def object_builder_init_empty
@
\subsection{Decoding}
Decode the current object and advance the iterator.  If there is no object
left, return [[.false.]]
<<Object builder: object builder: TBP>>=
  procedure :: decode => object_builder_decode
<<Object builder: procedures>>=
  subroutine object_builder_decode (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = builder%it%is_valid ()
    if (success) then
       call builder%it%get_object (object)
       code = object%get_code (builder%repository)
       call builder%it%advance ()
    end if
  end subroutine object_builder_decode
  
@ %def object_builder_decode
@
\subsection{Building}
Take the current code, build a new object if appropriate, and insert this (or
the value given by the code) at the next location in the object tree.  Then
advance the iterator to the new location.
<<Object builder: object builder: TBP>>=
  procedure :: build => object_builder_build
<<Object builder: procedures>>=
  subroutine object_builder_build (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    logical, parameter :: DEBUG = .false.
!     logical, parameter :: DEBUG = .true.
    if (DEBUG)  print *
    if (DEBUG)  print *, "build object"
    if (DEBUG)  call code%write ()
    call build_object (object, code, builder%repository)
    if (associated (object)) then
       call builder%it%advance (import_object = object)
    else
       call builder%it%advance ()
    end if
    success = builder%it%is_valid ()
    if (success) then
       call builder%it%get_object (object)
       if (DEBUG)  call builder%it%write ()
       if (DEBUG)  print *
       if (DEBUG)  call object%write ()
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    else
       call builder%write ()
       call code%write ()
       call msg_fatal ("Sindarin: error in byte code")
    end if
  end subroutine object_builder_build
    
@ %def object_builder_build
@ Extract the complete object tree.  The builder is reset to empty state.
<<Object builder: object builder: TBP>>=
  procedure :: export => object_builder_export
<<Object builder: procedures>>=
  subroutine object_builder_export (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(out), pointer :: object
    object => null ()
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (object)
       end select
       deallocate (builder%main)
    end if
    call builder%reset ()
  end subroutine object_builder_export
          
@ %def object_builder_export
@ 
\subsection{Unit tests}
<<Object builder: public>>=
  public :: object_builder_test
<<Object builder: procedures>>=
  subroutine object_builder_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object builder: execute tests>>  
  end subroutine object_builder_test
  
@ %def object_builder_test 
@ Object building.
<<Object builder: execute tests>>=
  call test (object_builder_1, "object_builder_1", &
       "build composite using builder", &
       u, results)
<<Object builder: tests>>=  
  subroutine object_builder_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object, member
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    type(code_t) :: code
    logical :: success
    integer :: utmp, iostat

    write (u, "(A)")  "* Test output: object_builder_1"
    write (u, "(A)")  "*   Purpose: object building using builder"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create composite"
    
    call repository%spawn (var_str ("tag"), member)
    select type (member)
    class is (composite_t)
       call member%init (name = var_str ("foo"))
    end select
    
    call repository%spawn (var_str ("tag"), object)
    select type (object)
    class is (composite_t)
       call object%init (name = var_str ("obj1"), n_members = 1)
       call object%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create builder"
    
    call builder%import_repository (repository)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Initialize builder with object"
    
    call builder%init_object (object)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Decode"
    write (u, "(A)")      
      
    utmp = free_unit ()
    open (utmp, status="scratch")

    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do

    call remove_object (object)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Reset builder"
    write (u, "(A)")     
 
    call builder%init_empty ()
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Reconstruct object"
    write (u, "(A)")      

    rewind (utmp)
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (utmp)

    call builder%export (object)
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call builder%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_builder_1"
    
    end subroutine object_builder_1

@ %def object_builder_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}
This module supplements the system of basic objects by statements and
expressions.  Those are composite objects that can be evaluated.  We
furthermore implement assignments as special statements, and define unary and
binary operators as special expressions.
<<[[object_expr.f90]]>>=
<<File header>>

module object_expr

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use diagnostics
  use codes
  use object_base

<<Standard module head>>

<<Expr: public>>

<<Expr: parameters>>

<<Expr: types>>

<<Expr: interfaces>>

contains

<<Expr: procedures>>

end module object_expr
@ %def object_expr
@
\subsection{Statements}
A statement is an extended composite.  The first few of the members are
interpreted as arguments.  There is no core.
<<Expr: public>>=
  public :: statement_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: statement_t
     private
   contains
   <<Expr: statement: TBP>>
  end type statement_t
  
@ %def statement_t
@
\subsubsection{Queries}
The default prototype for all statements.
<<Expr: statement: TBP>>=
  procedure :: get_prototype => statement_get_prototype
<<Expr: procedures>>=
  function statement_get_prototype (object) result (prototype)
    class(statement_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "statement"
  end function statement_get_prototype
  
@ %def statement_get_prototype
@ The statement is a statement.
<<Expr: statement: TBP>>=
  procedure :: is_statement => statement_is_statement
<<Expr: procedures>>=
  pure function statement_is_statement (object) result (flag)
    class(statement_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function statement_is_statement
  
@ %def statement_is_statement
@
\subsection{Assignment item}
An assignment item combines pointers for the left-hand and right-hand sides of
an elementary value assignment.  A list of such items constitutes a composite
assignment.
<<Expr: types>>=
  type :: item_t
     private
     class(value_t), pointer :: lhs => null ()
     class(value_t), pointer :: rhs => null ()
     class(item_t), pointer :: next => null ()
  end type item_t
  
@ %def item_t
@
\subsection{Assignment object}
The ID object should be allocated and owned by the assignment object.  It
denotes the ID (object path) of the LHS.  The [[lhs]] object is just a pointer
to the actual LHS object that is stored elsewhere.  It is the root of the
object list for assignment, and set by the [[resolve]] method.  Finally, the
[[item]] list indicates the actual assignments to perform.
<<Expr: public>>=
  public :: assignment_t
<<Expr: types>>=
  type, extends (statement_t) :: assignment_t
     private
     class(object_t), pointer :: id => null ()
     class(object_t), pointer :: lhs => null ()
     class(item_t), pointer :: item => null ()
   contains
   <<Expr: assignment: TBP>>
  end type assignment_t
     
@ %def assignment_t
@
\subsubsection{Finalizer}
The core (rhs) will be finalized depending on whether it is
stored as a reference or a local component.  The lhs pointer is never
finalized.
<<Expr: assignment: TBP>>=
  procedure :: final => assignment_final
<<Expr: procedures>>=
  recursive subroutine assignment_final (object)
    class(assignment_t), intent(inout) :: object
    class(item_t), pointer :: item
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    do while (associated (object%item))
       item => object%item
       object%item => item%next
       deallocate (item)
    end do
    call object%composite_t%final ()
  end subroutine assignment_final
    
@ %def assignment_final
@
\subsubsection{Output}
Output in statement form.  For the LHS, we try to write the path
expression.  The RHS is written as an expression.
<<Expr: assignment: TBP>>=
  procedure :: write_statement => assignment_write_statement
<<Expr: procedures>>=
  recursive subroutine assignment_write_statement (object, unit, indent)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: rhs
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, indent)
       else
          write (u, "('<LHS>')", advance="no")
       end if
    else
       write (u, "('<LHS>')", advance="no")
    end if
    write (u, "(1x,'=',1x)", advance="no")
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write_as_expression (unit, indent)
    else
       write (u, "(A)", advance="no") "<???>"
    end if
  end subroutine assignment_write_statement
    
@ %def assignment_write_statement
@ The mantle (statement contents) are presented in a special way.
<<Expr: assignment: TBP>>=
  procedure :: write_mantle => assignment_write_mantle
<<Expr: procedures>>=
  recursive subroutine assignment_write_mantle (object, unit, indent, refcount)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: rhs
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "LHS:"
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, ind+1)
          write (u, *)
       else
          write (u, "('<LHS>')")
       end if
    else
       write (u, *)
    end if
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "RHS:"
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write (unit, ind+1)
    else
       write (u, "(A)") "<???>"
    end if
  end subroutine assignment_write_mantle
  
@ %def assignment_write_mantle
@ Extra output for debugging.
<<Expr: assignment: TBP>>=
  procedure :: write_stack => assignment_write_stack
<<Expr: procedures>>=
  subroutine assignment_write_stack (object, unit)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    class(item_t), pointer :: item
    u = given_output_unit (unit)
    call object%write (u)
    item => object%item
    do while (associated (item))
       write (u, "('+')", advance="no")
       write (u, "(1x,'LHS: ')", advance="no")
       if (associated (item%lhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%lhs%get_name ())
          if (item%lhs%is_defined ()) then
             call item%lhs%write_as_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, "(2x,'RHS: ')", advance="no")
       if (associated (item%rhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%rhs%get_name ())
          if (item%rhs%is_defined ()) then
             call item%rhs%write_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, *)
       item => item%next
    end do
  end subroutine assignment_write_stack
  
@ %def assignment_write_stack
@
\subsubsection{Queries}
This query tells whether the object contains an ID subobject.
<<Expr: assignment: TBP>>=
  procedure :: has_id => assignment_has_id
<<Expr: procedures>>=
  pure function assignment_has_id (object) result (flag)
    class(assignment_t), intent(in) :: object
    logical :: flag
    flag = associated (object%id)
  end function assignment_has_id
  
@ %def assignment_has_id
@ Return the pointer to the ID subobject, if any.
<<Expr: assignment: TBP>>=
  procedure :: get_id_ptr => assignment_get_id_ptr
<<Expr: procedures>>=
  subroutine assignment_get_id_ptr (object, id)
    class(assignment_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => object%id
  end subroutine assignment_get_id_ptr
  
@ %def assignment_get_id_ptr
@
\subsubsection{Construction}
The [[instantiate]] method must be implemented.
<<Expr: assignment: TBP>>=
  procedure :: instantiate => assignment_instantiate
<<Expr: procedures>>=
  recursive subroutine assignment_instantiate (object, instance)
    class(assignment_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (assignment_t :: instance)
    select type (instance)
    type is (assignment_t)
       call instance%register (object)
       call instance%init (mode = MODE_CONSTANT)
    end select
  end subroutine assignment_instantiate
    
@ %def assignment_instantiate
@
The assignment object doesn't require the attribute list of generic composites.
<<Expr: assignment: TBP>>=
  procedure :: get_code => assignment_get_code
<<Expr: procedures>>=
  function assignment_get_code (object, repository) result (code)
    class(assignment_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_COMPOSITE
    code%natt = 1
    if (present (repository)) then
       code%att(1) = object%get_prototype_index (repository)
    end if
  end function assignment_get_code
  
@ %def assignment_get_code
@ Initialize from code: since the [[instantiate]] method already does
everything, we must not initialize anything here, just override the method.
<<Expr: assignment: TBP>>=
  procedure :: init_from_code => assignment_init_from_code
<<Expr: procedures>>=
  subroutine assignment_init_from_code (object, code)
    class(assignment_t), intent(inout) :: object
    type(code_t), intent(in) :: code
  end subroutine assignment_init_from_code

@ %def assignment_init_from_code
@ Initialize: Set the path for the LHS and import the object pointer for the
RHS.  Alternatively, ignore the part and set the LHS pointer directly.

If [[link]] is true, the [[rhs]] component is interpreted as a reference.  If
false, it is imported, nullifying the original pointer.
<<Expr: assignment: TBP>>=
  generic :: init => assignment_init
  procedure, private :: assignment_init
  procedure :: set_path => assignment_set_path
<<Expr: procedures>>=
  subroutine assignment_init (object, mode)
    class(assignment_t), intent(inout) :: object
    integer, intent(in), optional :: mode
    call object%init (name=var_str ("assignment"), mode = mode, &
         n_members=1, n_arguments=1)
  end subroutine assignment_init
    
  subroutine assignment_set_path (object, lhs_path)
    class(assignment_t), intent(inout) :: object
    type(string_t), dimension(:), intent(in) :: lhs_path
    allocate (id_t :: object%id)
    select type (id => object%id)
    type is (id_t)
       call id%init (lhs_path)
    end select
  end subroutine assignment_set_path
    
@ %def assignment_init
@ %def assignment_set_path
@ Assign ID, LHS pointer, RHS object.
<<Expr: assignment: TBP>>=
  procedure :: import_id => assignment_import_id
  procedure :: set_lhs => assignment_set_lhs
  procedure :: set_rhs => assignment_set_rhs
<<Expr: procedures>>=
  subroutine assignment_import_id (object, id)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: id
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    object%id => id
    id => null ()
  end subroutine assignment_import_id
    
  subroutine assignment_set_lhs (object, lhs)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(in), pointer :: lhs
    object%lhs => lhs
  end subroutine assignment_set_lhs

  subroutine assignment_set_rhs (object, rhs, link)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: rhs
    logical, intent(in) :: link
    if (link) then
       call object%link_member (1, rhs)
    else
       call object%import_member (1, rhs)
    end if
  end subroutine assignment_set_rhs
    
@ %def assignment_set_lhs
@ %def assignment_set_rhs
@
\subsubsection{Evaluation}
Push a lhs-rhs combination onto the assigment stack.
<<Expr: assignment: TBP>>=
  procedure :: push => assignment_push
<<Expr: procedures>>=
  subroutine assignment_push (object, lhs, rhs)
    class(assignment_t), intent(inout) :: object
    class(value_t), intent(in), pointer :: lhs, rhs
    class(item_t), pointer :: item
    allocate (item)
    item%lhs => lhs
    item%rhs => rhs
    item%next => object%item
    object%item => item
  end subroutine assignment_push
  
@ %def assignment_push
@ Resolve: Find the object that belongs to the LHS, match the RHS signature
against it, and build an assignment-item list for the matching values.  The
algorithm implements duck typing, i.e., the match is successful if all
required items are present at the correct position and with correct value type
in the RHS object tree.

TODO: find should not extend beyond the immediate composite-object context.
<<Expr: assignment: TBP>>=
  procedure :: resolve => assignment_resolve
<<Expr: procedures>>=
  subroutine assignment_resolve (object, success)
    class(assignment_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: lhs, rhs
    logical :: mutable
    if (object%has_id ()) then
       select type (id => object%id)
       type is (id_t)
          call object%find (id%get_path (), object%lhs)
       end select
    end if
    success = associated (object%lhs)
    if (success) then
       select type (lhs => object%lhs)
       type is (composite_t);  call lhs%check_mode (mutable)
          success = mutable
       end select
    end if
    if (success) then
       lhs => object%lhs
       call object%get_member_ptr (1, rhs)
       if (associated (lhs) .and. associated (rhs)) then
          call lhs%match (rhs, success, object)
       else
          success = .false.
       end if
    end if
  end subroutine assignment_resolve
    
@ %def assignment_resolve
@ Evaluate: Assign values, using the resolved pointers.

We iterate over the assignment list which should contain pointers to the
matching lhs-rhs combinations.
<<Expr: assignment: TBP>>=
  procedure :: evaluate => assignment_evaluate
<<Expr: procedures>>=
  subroutine assignment_evaluate (object)
    class(assignment_t), intent(inout), target :: object
    class(item_t), pointer :: item
    item => object%item
    do while (associated (item))
       call item%lhs%assign (item%rhs)
       item => item%next
    end do
  end subroutine assignment_evaluate
    
@ %def assignment_evaluate
@
\subsubsection{Iterator Support}
Iterate: scan the ID object (the LHS) before the rest.
<<Expr: assignment: TBP>>=
  procedure :: next_position => assignment_next_position
<<Expr: procedures>>=
  subroutine assignment_next_position &
       (object, position, next_object, import_object)
    class(assignment_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE)
       if (object%has_id ()) then
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else if (present (import_object)) then
          call object%import_id (import_object)
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else
          call composite_next_position &
               (object, position, next_object, import_object)
       end if
    case default
       call composite_next_position &
            (object, position, next_object, import_object)
    end select
  end subroutine assignment_next_position
  
@ %def assignment_next_position
@
\subsection{Expressions}
An expression is an extended composite.  The first few of the members are
interpreted as arguments.
<<Expr: public>>=
  public :: expression_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: expression_t
     private
   contains
   <<Expr: expression: TBP>>
  end type expression_t
  
@ %def expression_t
@
\subsubsection{Queries}
The expression has an expression, unless it is marked [[abstract]].
<<Expr: expression: TBP>>=
  procedure :: is_expression => expression_is_expression
<<Expr: procedures>>=
  pure function expression_is_expression (object) result (flag)
    class(expression_t), intent(in) :: object
    logical :: flag
    call object%check_mode (flag)
  end function expression_is_expression
  
@ %def expression_is_expression
@ For expressions, we should look for the name of the object itself, not the
name of the prototype object (which is the prototype of the value).
<<Expr: expression: TBP>>=
  procedure :: get_prototype_index => expression_get_prototype_index
<<Expr: procedures>>=
  function expression_get_prototype_index (object, repository) result (i)
    class(expression_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    call repository%find_member (object%get_name (), index=i)
  end function expression_get_prototype_index

@ %def expression_get_prototype_index
@
\subsection{Construction / Decoding}
For expressions, we store the standard composite code set, but leave out the
object name.
<<Expr: expression: TBP>>=
  procedure :: get_code => expression_get_code
<<Expr: procedures>>=
  function expression_get_code (object, repository) result (code)
    class(expression_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
  end function expression_get_code
  
@ %def expression_get_code
@ Build object from code: we don't need much of initialization here since this
is achieved by instantiating the prototype.  We just set the number of
arguments.
<<Expr: expression: TBP>>=
  procedure :: init_from_code => expression_init_from_code
<<Expr: procedures>>=
  subroutine expression_init_from_code (object, code)
    class(expression_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    call object%set_mode (mode = code%att(2))
    call object%init_args (n_arg = code%att(5))
    call object%set_intrinsic (intrinsic = code%att(3) == 0)
  end subroutine expression_init_from_code

@ %def expression_init_from_code
@
We define a separate procedure that initializes the number of arguments.
Extensions may do a sanity check.
<<Expr: expression: TBP>>=
  procedure (expression_init_args), deferred :: init_args
<<Expr: interfaces>>=
  abstract interface
     subroutine expression_init_args (object, n_arg)
       import
       class(expression_t), intent(inout) :: object
       integer, intent(in) :: n_arg
     end subroutine expression_init_args
  end interface

@ %def expression_init_args
@
\subsection{Operators}
An operator is an expression with a specific notation.  We have unary and
binary operators.  In addition to the result prototype, which is stored in the
parent type, we store a pointer to the (uniform) prototype of the arguments.
<<Expr: public>>=
  public :: operator_t
  public :: operator_unary_t
  public :: operator_binary_t
<<Expr: types>>=
  type, extends (expression_t), abstract :: operator_t
     private
   contains
   <<Expr: operator: TBP>>
  end type operator_t
  
  type, extends (operator_t), abstract :: operator_unary_t
     private
   contains
   <<Expr: operator unary: TBP>>
  end type operator_unary_t
  
  type, extends (operator_t), abstract :: operator_binary_t
     private
   contains
   <<Expr: operator binary: TBP>>
  end type operator_binary_t
  
@ %def operator_t
@ %def operator_unary_t
@ %def operator_binary_t
@
\subsubsection{Output}
Unary or binary operators in prefix or infix notation,
respectively.  We pass the current object's priority to the subexpression
output, so there we decide about extra brackets to write.
<<Expr: operator unary: TBP>>=
  procedure :: write_expression => operator_unary_write_expression
<<Expr: operator binary: TBP>>=
  procedure :: write_expression => operator_binary_write_expression
<<Expr: procedures>>=
  recursive subroutine operator_unary_write_expression (object, unit, indent)
    class(operator_unary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority
    u = given_output_unit (unit)
    priority = object%get_priority ()
    write (u, "(A,1x)", advance="no")  char (object%get_name ())
    call object%get_member_ptr (1, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       call arg%write_as_expression &
            (unit, indent, priority=priority, lr=.true.)
    else
       write (u, "(A)", advance="no") "???"
    end if
  end subroutine operator_unary_write_expression
    
  recursive subroutine operator_binary_write_expression (object, unit, indent)
    class(operator_binary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority, i
    u = given_output_unit (unit)
    priority = object%get_priority ()
    do i = 1, object%get_n_members ()
       if (i > 1) then
          write (u, "(1x,A,1x)", advance="no")  char (object%get_name ())
       end if
       call object%get_member_ptr (i, arg)
       if (associated (arg)) then
          arg => arg%dereference ()
          call arg%write_as_expression &
               (unit, indent, priority=priority, lr=.true.)
       else
          write (u, "(A)", advance="no") "???"
       end if
    end do
  end subroutine operator_binary_write_expression
    
@ %def operator_unary_write_expression
@ %def operator_binary_write_expression
@
\subsubsection{Queries}
The written prototype is the prototype of the result.
<<Expr: operator: TBP>>=
  procedure :: get_prototype => operator_get_prototype
<<Expr: procedures>>=
  recursive function operator_get_prototype (object) result (prototype)
    class(operator_t), intent(in) :: object
    type(string_t) :: prototype
    class(object_t), pointer :: core
    call object%get_core_ptr (core)
    if (associated (core)) then
       select type (core)
       class is (composite_t)
          prototype = core%get_prototype ()
       class default
          prototype = core%get_name ()
       end select
    else
       prototype = "operator"
    end if
  end function operator_get_prototype
  
@ %def operator_get_prototype
@ The signature of a operator object contains the [[operator]] attribute,
qualified as either [[unary]] or [[binary]].
<<Expr: operator unary: TBP>>=
  procedure :: get_signature => operator_unary_get_signature
<<Expr: operator binary: TBP>>=
  procedure :: get_signature => operator_binary_get_signature
<<Expr: procedures>>=
  pure function operator_unary_get_signature (object, verbose) &
       result (signature)
    class(operator_unary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|unary|" // signature
    else
       signature = "operator|unary"
    end if
  end function operator_unary_get_signature
       
  pure function operator_binary_get_signature (object, verbose) &
       result (signature)
    class(operator_binary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|binary|" // signature
    else
       signature = "operator|binary"
    end if
  end function operator_binary_get_signature
       
@ %def operator_get_unary_signature
@ %def operator_binary_get_signature
@
\subsubsection{Construction}
We define a separate procedure that initializes the number of arguments and
does a sanity check.  Argument type is not checked.
<<Expr: operator: TBP>>=
  procedure :: init_args => operator_init_args
<<Expr: procedures>>=
  subroutine operator_init_args (object, n_arg)
    class(operator_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    select type (object)
    class is (operator_unary_t)
       if (n_arg /= 1) then
          call object%write ()
          call msg_bug ("Unary operator: number of arguments must be one")
       end if
    class is (operator_binary_t)
       if (n_arg < 2) then
          call object%write ()
          call msg_bug ("Binary operator: number of arguments less than two")
       end if
    end select
    call object%init_members (n_members = n_arg, n_arguments = n_arg)
  end subroutine operator_init_args

@ %def operator_init_args
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logical values}
Logical values are a concrete implementation of [[value_t]].  We also define
logical expressions.

Logical values and expressions allow us to write unit tests for assignment,
expression evaluation, building and decoding.
<<[[object_logical.f90]]>>=
<<File header>>

module object_logical

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units

  use codes
  use object_base
  use object_builder
  use object_expr

<<Standard module head>>

<<Logical: public>>

<<Logical: parameters>>

<<Logical: types>>

<<Logical: interfaces>>

contains

<<Logical: procedures>>

<<Logical: tests>>

end module object_logical
@ %def object_logical
@ 
\subsection{Type definition}
A logical object carries a logical value.  The [[defined]] status also
applies, inherited from [[value_t]].
<<Logical: public>>=
  public :: logical_t
<<Logical: types>>=
  type, extends (value_t) :: logical_t
     private
     logical :: value = .false.
   contains
   <<Logical: logical: TBP>>
  end type logical_t
  
@ %def logical_t
@ A wrapper type for assembling pointers in expression objects:
<<Logical: types>>=
  type :: logical_p
     private
     type(logical_t), pointer :: p => null ()
  end type logical_p
     
@ %def logical_p
@
\subsubsection{Finalizer}
Finalizer is empty.
<<Logical: logical: TBP>>=
  procedure :: final => logical_final
<<Logical: procedures>>=
  pure subroutine logical_final (object)
    class(logical_t), intent(inout) :: object
  end subroutine logical_final
 
@ %def logical_final
@
\subsubsection{Output}
Display the value.
<<Logical: logical: TBP>>=
  procedure :: write_expression => logical_write_value
  procedure :: write_value => logical_write_value
<<Logical: procedures>>=
  subroutine logical_write_value (object, unit, indent)
    class(logical_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (object%value) then
       write (u, "(A)", advance="no")  "true"
    else
       write (u, "(A)", advance="no")  "false"
    end if
  end subroutine logical_write_value
       
@ %def logical_write_expression
@ %def logical_write_value
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[logical]].
<<Logical: logical: TBP>>=
  procedure :: get_name => logical_get_name
<<Logical: procedures>>=
  pure function logical_get_name (object) result (name)
    class(logical_t), intent(in) :: object
    type(string_t) :: name
    name = "logical"
  end function logical_get_name
  
@ %def logical_get_name
@
\subsubsection{Construction}
For a new tag instance, nothing needs to be copied.
<<Logical: logical: TBP>>=
  procedure :: instantiate => logical_instantiate
<<Logical: procedures>>=
  subroutine logical_instantiate (object, instance)
    class(logical_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (logical_t :: instance)
  end subroutine logical_instantiate
    
@ %def logical_instantiate
@ Logical value: the code includes the value.
<<Logical: logical: TBP>>=
  procedure :: get_code => logical_get_code
<<Logical: procedures>>=
  function logical_get_code (object, repository) result (code)
    class(logical_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_VALUE
    if (object%is_defined ()) then
       allocate (val_logical_t :: code%val)
       select type (val => code%val)
       type is (val_logical_t)
          call val%init (1)
          val%x(1) = object%value
       end select
    end if
  end function logical_get_code
  
@ %def logical_get_code
@ Initialize the value, given a code object.
<<Logical: logical: TBP>>=
  procedure :: init_from_code => logical_init_from_code
<<Logical: procedures>>=
  subroutine logical_init_from_code (object, code)
    class(logical_t), intent(out) :: object
    type(code_t), intent(in) :: code
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_logical_t)
          if (val%get_nval () > 0)  call object%init (val%x(1))
       end select
    end if
  end subroutine logical_init_from_code
    
@ %def logical_init_from_code
@ Initializer: we may define or undefine the value.
<<Logical: logical: TBP>>=
  procedure :: init => logical_init
<<Logical: procedures>>=
  pure subroutine logical_init (object, value)
    class(logical_t), intent(inout) :: object
    logical, intent(in), optional :: value
    if (present (value)) then
       object%value = value
       call object%set_defined (.true.)
    else
       call object%set_defined (.false.)
    end if
  end subroutine logical_init
 
@ %def logical_init
@
\subsubsection{Assignment}
Copy the value.  LHS and RHS must both be logical.
<<Logical: logical: TBP>>=
  procedure :: match_value => logical_match_value
  procedure :: assign_value => logical_assign_value
<<Logical: procedures>>=
  subroutine logical_match_value (object, source, success)
    class(logical_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (logical_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine logical_match_value
       
  subroutine logical_assign_value (object, source)
    class(logical_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (logical_t)
       object%value = source%value
    end select
  end subroutine logical_assign_value
       
@ %def logical_match_value
@ %def logical_assign_value
@ 
\subsection{Operators: not}
The [[not]] operator is a unary operator.  Both argument and result are of
type [[logical_t]].  We define pointer shortcuts for both argument and
result.
<<Logical: types>>=
  type, extends (operator_unary_t), abstract :: logical_unary_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_t), pointer :: arg => null ()
   contains
   <<Logical: logical unary: TBP>>
  end type logical_unary_t

@ %def logical_unary_t
<<Logical: public>>=
  public :: not_t
<<Logical: types>>=
  type, extends (logical_unary_t) :: not_t
     private
   contains
   <<Logical: not: TBP>>
  end type not_t
  
@ %def not_t
@
\subsubsection{Queries}
Priority value.
<<Logical: not: TBP>>=
  procedure :: get_priority => not_get_priority
<<Logical: procedures>>=
  pure function not_get_priority (object) result (priority)
    class(not_t), intent(in) :: object
    integer :: priority
    priority = PRIO_NOT
  end function not_get_priority
  
@ %def not_get_priority
@
\subsubsection{Construction}
Instantiate: we have to initialize, so the core and argument types are fixed.
<<Logical: not: TBP>>=
  procedure :: instantiate => not_instantiate
<<Logical: procedures>>=
  subroutine not_instantiate (object, instance)
    class(not_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (not_t :: instance)
    select type (instance)
    class is (not_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine not_instantiate
  
@ %def not_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Logical: logical unary: TBP>>=
  generic :: init => logical_unary_init
  procedure, private :: logical_unary_init
<<Logical: procedures>>=
  subroutine logical_unary_init (object, prototype, name, mode)
    class(logical_unary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%init (name, mode = mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine logical_unary_init
  
@ %def logical_unary_init 
@ Initialize: one argument, no extra members.  We need the [[logical]]
prototype for initializing core and argument.  If this is not an instance, we
also declare the prototype for the object itself.
<<Logical: not: TBP>>=
  generic :: init => not_init
  procedure, private :: not_init
<<Logical: procedures>>=
  subroutine not_init (object, prototype, mode)
    class(not_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_unary_init (object, prototype, var_str ("not"), mode)
  end subroutine not_init
  
@ %def not_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical.
<<Logical: logical unary: TBP>>=
  procedure :: resolve => logical_unary_resolve
<<Logical: procedures>>=
  recursive subroutine logical_unary_resolve (object, success)
    class(logical_unary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    success = .false.
    object%res => null ()
    object%arg => null ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (object%has_value ()) then
       call object%get_member_ptr (1, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             object%arg => core
             success = .true.
          end select
       end select
    end if
  end subroutine logical_unary_resolve
  
@ %def logical_unary_resolve
@ Evaluate the operation.
<<Logical: not: TBP>>=
  procedure :: evaluate => not_evaluate
<<Logical: procedures>>=
  recursive subroutine not_evaluate (object)
    class(not_t), intent(inout), target :: object
    call object%composite_t%evaluate ()
    if (object%arg%is_defined ()) then
       call object%res%init (.not. object%arg%value)
    else
       call object%res%init ()
    end if
  end subroutine not_evaluate
  
@ %def not_evaluate
@ 
\subsection{Operators: and, or}
The [[and]] and [[or]] operators are binary operators.  Both arguments and
result are of type [[logical_t]].  We define pointer shortcuts for both
arguments and result.
<<Logical: types>>=
  type, extends (operator_binary_t), abstract :: logical_binary_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_p), dimension(:), allocatable :: arg_ptr
   contains
   <<Logical: logical binary: TBP>>
  end type logical_binary_t

@ %def logical_binary_t
<<Logical: public>>=
  public :: and_t
  public :: or_t
<<Logical: types>>=
  type, extends (logical_binary_t) :: and_t
     private
   contains
   <<Logical: and: TBP>>
  end type and_t
  
  type, extends (logical_binary_t) :: or_t
     private
   contains
   <<Logical: or: TBP>>
  end type or_t
  
@ %def and_t
@ %def or_t
@
\subsubsection{Queries}
Priority value.
<<Logical: and: TBP>>=
  procedure :: get_priority => and_get_priority
<<Logical: or: TBP>>=
  procedure :: get_priority => or_get_priority
<<Logical: procedures>>=
  pure function and_get_priority (object) result (priority)
    class(and_t), intent(in) :: object
    integer :: priority
    priority = PRIO_AND
  end function and_get_priority
  
  pure function or_get_priority (object) result (priority)
    class(or_t), intent(in) :: object
    integer :: priority
    priority = PRIO_OR
  end function or_get_priority
  
@ %def and_get_priority
@ %def or_get_priority
@
\subsubsection{Construction}
Instantiate: initialize using the generic logical binary initializer.  The
number of arguments is not yet known, we just initialize the core.
<<Logical: and: TBP>>=
  procedure :: instantiate => and_instantiate
<<Logical: or: TBP>>=
  procedure :: instantiate => or_instantiate
<<Logical: procedures>>=
  subroutine and_instantiate (object, instance)
    class(and_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (and_t :: instance)
    select type (instance)
    type is (and_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine and_instantiate
  
  subroutine or_instantiate (object, instance)
    class(or_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (or_t :: instance)
    select type (instance)
    type is (or_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine or_instantiate
  
@ %def and_instantiate
@ %def or_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Logical: logical binary: TBP>>=
  generic :: init => logical_binary_init
  procedure, private :: logical_binary_init
<<Logical: procedures>>=
  subroutine logical_binary_init (object, prototype, name, mode)
    class(logical_binary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%init (name, mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine logical_binary_init
  
@ %def logical_binary_init 
@ Specific initializers.
<<Logical: and: TBP>>=
  generic :: init => and_init
  procedure, private :: and_init
<<Logical: or: TBP>>=
  generic :: init => or_init
  procedure, private :: or_init
<<Logical: procedures>>=
  subroutine and_init (object, prototype, mode)
    class(and_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_binary_init (object, prototype, var_str ("and"), mode)
  end subroutine and_init
  
  subroutine or_init (object, prototype, mode)
    class(or_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_binary_init (object, prototype, var_str ("or"), mode)
  end subroutine or_init
  
@ %def and_init 
@ %def or_init 
@ Shortcut to member initialization.  This routine is used only in the unit
tests below.
<<Logical: tests>>=
  subroutine init_members (object, n_arg)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    select type (object)
    class is (operator_t)
       call object%init_args (n_arg)
    end select
  end subroutine init_members
    
@ %def init_members
@ Set the member value directly.  This routine is used only in the unit tests
below.
<<Logical: tests>>=
  subroutine set_member_val (object, i, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    logical, intent(in), optional :: value
    class(object_t), pointer :: member, core
    class(composite_t), pointer :: prototype
    type(string_t) :: name
    if (present (value)) then
       if (value) then
          name = "true"
       else
          name = "false"
       end if
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       call object%get_prototype_ptr (prototype)
       call prototype%instantiate (member)
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (logical_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
  end subroutine set_member_val
    
@ %def set_member_val
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical, otherwise the routine is universal for binary operators.
<<Logical: logical binary: TBP>>=
  procedure :: resolve => logical_binary_resolve
<<Logical: procedures>>=
  recursive subroutine logical_binary_resolve (object, success)
    class(logical_binary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    integer :: i, n_args
    success = .false.
    object%res => null ()
    n_args = object%get_n_members ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (.not. allocated (object%arg_ptr)) &
         allocate (object%arg_ptr (n_args))
    if (object%has_value ()) then
       do i = 1, n_args
          call object%get_member_ptr (i, arg)
          call arg%resolve (success);  if (.not. success)  return
          select type (arg)
          class is (wrapper_t)
             call arg%get_core_ptr (core)
             select type (core)
             type is (logical_t)
                object%arg_ptr(i)%p => core
                success = .true.
             end select
          end select
       end do
    end if
  end subroutine logical_binary_resolve
  
@ %def logical_binary_resolve
@ Evaluate the operation.
<<Logical: and: TBP>>=
  procedure :: evaluate => and_evaluate
<<Logical: or: TBP>>=
  procedure :: evaluate => or_evaluate
<<Logical: procedures>>=
  recursive subroutine and_evaluate (object)
    class(and_t), intent(inout), target :: object
    integer :: i
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%p%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%p%value) then
          call object%res%init (.false.)
          return
       end if
    end do
    call object%res%init (.true.)
  end subroutine and_evaluate
  
  recursive subroutine or_evaluate (object)
    class(or_t), intent(inout), target :: object
    integer :: i
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%p%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    do i = 1, size (object%arg_ptr)
       if (object%arg_ptr(i)%p%value) then
          call object%res%init (.true.)
          return
       end if
    end do
    call object%res%init (.false.)
  end subroutine or_evaluate
  
@ %def and_evaluate
@ %def or_evaluate
@ 
\subsection{Unit tests}
<<Logical: public>>=
  public :: object_logical_test
<<Logical: procedures>>=
  subroutine object_logical_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Logical: execute tests>>  
  end subroutine object_logical_test
  
@ %def object_logical_test 
@
\subsubsection{Values}
Create logical objects.
<<Logical: execute tests>>=
  call test (object_logical_1, "object_logical_1", &
       "values", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: bare_logical, core
    class(object_t), pointer :: prototype, true, false, undef

    write (u, "(A)")  "* Test output: object_logical_1"
    write (u, "(A)")  "*   Purpose: construct logical value objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Logical objects: prototype"

    allocate (logical_t :: bare_logical)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("logical"))
       call prototype%import_core (bare_logical)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Logical objects: true, false, undefined"

    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (undef)
    select type (undef)
    type is (composite_t)
       call undef%init (mode = MODE_CONSTANT, name = var_str ("undef"))
       allocate (logical_t :: core)
       call undef%import_core (core)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    call true%write (u, refcount=.true.)
    call false%write (u, refcount=.true.)
    call undef%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (undef)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)
    call remove_object (bare_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_1"
    
    end subroutine object_logical_1

@ %def object_logical_1
@ 
\subsubsection{Atomic assignment}
Perform assignments of elementary logicals.
<<Logical: execute tests>>=
  call test (object_logical_2, "object_logical_2", &
       "assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core, rhs
    class(object_t), pointer :: prototype, true, false, lval1, lval2, lval3
    type(assignment_t) :: asg
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_2"
    write (u, "(A)")  "*   Purpose: assignments"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Create objects"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (lval1)
    select type (lval1)
    type is (composite_t)
       call lval1%init (mode = MODE_VARIABLE, name = var_str ("lval1"))
    end select
    
    call prototype%instantiate (lval2)
    select type (lval2)
    type is (composite_t)
       call lval2%init (mode = MODE_VARIABLE, name = var_str ("lval2"))
    end select
    
    call prototype%instantiate (lval3)
    select type (lval3)
    type is (composite_t)
       call lval3%init (mode = MODE_VARIABLE, name = var_str ("lval3"))
    end select
    
    write (u, "(A)")
    call true%write (u)
    call false%write (u)

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval1 = true"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval1)
    call asg%set_rhs (true, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = false"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (false, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()
    
    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval1"
  
    rhs => lval1
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval3"
  
    rhs => lval3
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (lval1)
    call remove_object (lval2)
    call remove_object (lval3)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "true allocated =", associated (true)
    write (u, "(A,1x,L1)")  "false allocated =", associated (false)
    write (u, "(A,1x,L1)")  "lval1 allocated =", associated (lval1)
    write (u, "(A,1x,L1)")  "lval2 allocated =", associated (lval2)
    write (u, "(A,1x,L1)")  "lval3 allocated =", associated (lval3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_2"
    
    end subroutine object_logical_2

@ %def object_logical_2
@ 
\subsubsection{Composite assignment}
Perform assignments of composites with elementary logical core.
<<Logical: execute tests>>=
  call test (object_logical_3, "object_logical_3", &
       "composite assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: prototype, proto2, main, val, core, rhs, asg
    type(object_iterator_t) :: it
    class(object_t), pointer :: object
    type(code_t) :: code
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_3"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("val"))
    end select
    
    call setup_assignment ()
    write (u, "(A)")
    write (u, "(A)")  "* Assignment object"
    write (u, "(A)")
    call asg%write (u)

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Main object"
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Check name mismatch"

    call remove_object (main)

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("foo"))
    end select
    
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Check mode/type mismatch"

    call remove_object (main)

    allocate (composite_t :: proto2)
    select type (proto2)
    type is (composite_t)
       call proto2%init (var_str ("tag"))
       allocate (tag_t :: core)
       call proto2%import_core (core)
    end select

    call proto2%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (name = var_str ("val"))
    end select
   
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (proto2)
    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_3"
    
    contains
      
      subroutine setup_assignment
        allocate (assignment_t :: asg)
        select type (asg)
        type is (assignment_t)
           call prototype%instantiate (rhs)
           select type (rhs)
           type is (composite_t)
              call rhs%init (mode=MODE_CONSTANT, name=var_str ("rhs"))
              call rhs%get_core_ptr (core)
              select type (core)
              type is (logical_t)
                 call core%init (value = .true.)
              end select
           end select
           call asg%init (MODE=MODE_CONSTANT)
           call asg%set_path ([var_str ("val")])
           call asg%set_rhs (rhs=rhs, link=.false.)
        end select
      end subroutine setup_assignment

    end subroutine object_logical_3

@ %def object_logical_3
@ 
\subsubsection{Nested composite assignment}
Perform assignments of composites with multiple and composite members.
<<Logical: execute tests>>=
  call test (object_logical_4, "object_logical_4", &
       "nontrivial assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: pro_logical, pro_tag
    class(object_t), pointer :: main, foo, bar, a, core, member, rhs, asg, ptr
    type(object_iterator_t) :: it
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_4"
    write (u, "(A)")  "*   Purpose: nested composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: pro_tag)
    select type (pro_tag)
    type is (composite_t)
       call pro_tag%init (var_str ("tag"))
       allocate (tag_t :: core)
       call pro_tag%import_core (core)
    end select

    allocate (composite_t :: pro_logical)
    select type (pro_logical)
    type is (composite_t)
       call pro_logical%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_logical%import_core (core)
    end select

    call pro_logical%instantiate (bar)
    select type (bar)
    type is (composite_t)
       call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
    end select

    call pro_tag%instantiate (a)
    select type (a)
    type is (composite_t)
       call a%init (name = var_str ("a"))
    end select

    call pro_logical%instantiate (foo)
    select type (foo)
    type is (composite_t)
       call foo%init (mode=MODE_CONSTANT, name = var_str ("foo"), &
            n_members=2)
       call foo%import_member (1, a)
       call foo%import_member (2, bar)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t)
          call core%init (value = .true.)
       end select

       call pro_logical%instantiate (bar)
       select type (bar)
       type is (composite_t)
          call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
          call bar%get_core_ptr (core)
          select type (core)
          type is (logical_t);  call core%init (value = .false.)
          end select
       end select

       call pro_tag%instantiate (a)
       select type (a)
       type is (composite_t)
          call a%init (name = var_str ("a"))
       end select

       allocate (composite_t :: rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (mode=MODE_CONSTANT, name = var_str ("rhs"), &
               n_members = 2)
          allocate (logical_t :: core)
          select type (core)
          type is (logical_t);  call core%init (value = .true.)
          end select
          call rhs%import_core (core)
          call rhs%import_member (1, bar)
          call rhs%import_member (2, a)
       end select

       call asg%init (mode=MODE_CONSTANT)
       call asg%set_path ([var_str ("foo")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, foo)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through main"
    write (u, "(A)")      

    call it%init (main)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, core=.false., mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call remove_object (pro_tag)
    call remove_object (pro_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_4"
    
    end subroutine object_logical_4

@ %def object_logical_4
@ 
\subsubsection{Operators: not}
Now the test for [[not]].
<<Logical: execute tests>>=
  call test (object_logical_5, "object_logical_5", &
       "operator: not", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: not, expr1, expr2, expr3
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_5"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: not"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    write (u, "(A)")
    call not%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"

    write (u, "(A)")
    
    call not%instantiate (expr1)
    call init_members (expr1, 1)
    call set_member_val (expr1, 1, .true.)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    call init_members (expr2, 1)
    call set_member_val (expr2, 1, .false.)
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr3)
    call init_members (expr3, 1)
    call set_member_val (expr3, 1)
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u);  write (u, *)
    call expr2%write_as_expression (u);  write (u, *)
    call expr3%write_as_expression (u);  write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "not allocated =", associated (not)
    write (u, "(A,1x,L1)")  "expr1 allocated =", associated (expr1)
    write (u, "(A,1x,L1)")  "expr2 allocated =", associated (expr2)
    write (u, "(A,1x,L1)")  "expr3 allocated =", associated (expr3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_5"
    
    end subroutine object_logical_5

@ %def object_logical_5
@ 
\subsubsection{Operators: and}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_6, "object_logical_6", &
       "operator: and", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: and
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    class(object_t), pointer :: expr8, expr9
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_6"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: and"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    write (u, "(A)")
    call and%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, .true.)
    call set_member_val (expr1, 2, .true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, .true.)
    call set_member_val (expr2, 2, .false.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .false.)
    call set_member_val (expr3, 2, .true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .false.)
    call set_member_val (expr4, 2, .false.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    call init_members (expr5, 2)
    call set_member_val (expr5, 1)
    call set_member_val (expr5, 2, .true.) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr6)
    call init_members (expr6, 2)
    call set_member_val (expr6, 1, .false.)
    call set_member_val (expr6, 2) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr7)
    call init_members (expr7, 2)
    call set_member_val (expr7, 1)
    call set_member_val (expr7, 2) 
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, *)

    call and%instantiate (expr8)
    call init_members (expr8, 3)
    call set_member_val (expr8, 1, .true.)
    call set_member_val (expr8, 2, .true.) 
    call set_member_val (expr8, 3, .false.) 
    call expr8%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr9)
    call init_members (expr9, 4)
    call set_member_val (expr9, 1, .true.)
    call set_member_val (expr9, 2, .true.) 
    call set_member_val (expr9, 3, .true.)
    call set_member_val (expr9, 4, .true.) 
    call expr9%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_expression (u)
    write (u, *)
    call expr9%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    call expr8%evaluate ()
    call expr9%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_value (u)
    write (u, *)
    call expr9%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (expr8)
    call remove_object (expr9)
    call remove_object (and)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_6"
    
    end subroutine object_logical_6

@ %def object_logical_6
@ 
\subsubsection{Operators: or}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_7, "object_logical_7", &
       "operator: or", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    class(object_t), pointer :: expr8, expr9
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_7"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    call or%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call or%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, .true.)
    call set_member_val (expr1, 2, .true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, .true.)
    call set_member_val (expr2, 2, .false.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .false.)
    call set_member_val (expr3, 2, .true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .false.)
    call set_member_val (expr4, 2, .false.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr5)
    call init_members (expr5, 2)
    call set_member_val (expr5, 1)
    call set_member_val (expr5, 2, .true.) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr6)
    call init_members (expr6, 2)
    call set_member_val (expr6, 1, .false.)
    call set_member_val (expr6, 2) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr7)
    call init_members (expr7, 2)
    call set_member_val (expr7, 1)
    call set_member_val (expr7, 2) 
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, *)

    call or%instantiate (expr8)
    call init_members (expr8, 3)
    call set_member_val (expr8, 1, .false.)
    call set_member_val (expr8, 2, .false.) 
    call set_member_val (expr8, 3, .true.) 
    call expr8%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr9)
    call init_members (expr9, 4)
    call set_member_val (expr9, 1, .false.)
    call set_member_val (expr9, 2, .false.) 
    call set_member_val (expr9, 3, .false.)
    call set_member_val (expr9, 4, .false.) 
    call expr9%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_expression (u)
    write (u, *)
    call expr9%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    call expr8%evaluate ()
    call expr9%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_value (u)
    write (u, *)
    call expr9%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (expr8)
    call remove_object (expr9)
    call remove_object (or)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_7"
    
    end subroutine object_logical_7

@ %def object_logical_7
@ 
\subsubsection{Operators: nested expression}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_8, "object_logical_8", &
       "nested expressions", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_8 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: not, and, or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5
    class(object_t), pointer :: arg1, arg2
1    logical :: success

    write (u, "(A)")  "* Test output: object_logical_8"
    write (u, "(A)")  "*   Purpose: check nested logical expressions"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototypes: not, and, or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    call init_members (expr1, 2)
    select type (expr1)
    class is (composite_t)
       call not%instantiate (arg1)
       call init_members (arg1, 1)
       call set_member_val (arg1, 1, .true.)
       call expr1%import_member (1, arg1)
    end select
    call set_member_val (expr1, 2, .false.)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    call init_members (expr2, 1)
    select type (expr2)
    class is (composite_t)
       call and%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, .true.)
       call set_member_val (arg1, 2, .false.)
       call expr2%import_member (1, arg1)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .true.)
    select type (expr3)
    class is (composite_t)
       call or%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, .false.)
       call set_member_val (arg2, 2, .true.)
       call expr3%import_member (2, arg2)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .true.)
    select type (expr4)
    class is (composite_t)
       call and%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, .false.)
       call set_member_val (arg2, 2, .true.)
       call expr4%import_member (2, arg2)
    end select
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    call init_members (expr5, 2)
    select type (expr5)
    class is (composite_t)
       call and%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, .true.)
       call set_member_val (arg1, 2, .false.)
       call expr5%import_member (1, arg1)
    end select
    call set_member_val (expr5, 2, .true.)
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (and)
    call remove_object (or)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_8"
    
    end subroutine object_logical_8

@ %def object_logical_8
@ 
\subsubsection{Build assignment}
Generate code for an assignment object and reconstruct the object from code.
<<Logical: execute tests>>=
  call test (object_logical_9, "object_logical_9", &
       "build assignment from code", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_9 (u)
    integer, intent(in) :: u
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    class(object_t), pointer :: prototype, main, val, core, rhs, asg
    type(code_t) :: code
    logical :: success
    integer :: iostat
    integer :: utmp

    write (u, "(A)")  "* Test output: object_logical_9"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       call asg%init ()
    end select

    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 2)
    call repository%import_member (1, prototype)
    call repository%import_member (2, asg)


    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare composite object with primer"

    call repository%spawn (var_str ("logical"), val)
    select type (val)
    class is (composite_t)
       call val%init (name = var_str ("val"), mode = MODE_CONSTANT)
    end select
    
    call repository%spawn (var_str ("assignment"), asg)
    select type (asg)
    type is (assignment_t)
       call repository%spawn (var_str ("logical"), rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (name = var_str ("rhs"), mode = MODE_CONSTANT)
          call rhs%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             call core%init (value = .true.)
          end select
       end select
       call asg%set_path ([var_str ("val")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Code"

    call builder%import_repository (repository)

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")
    call builder%init_object (main)
    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do
    rewind (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Reconstruct object"

    call remove_object (main)

    call builder%init_empty ()
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    call builder%export (main)

    close (utmp)
    
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_9"
    
  end subroutine object_logical_9

@ %def object_logical_9
@ 
\subsubsection{Code: not}
Construct logical expressions from bytecode.
<<Logical: execute tests>>=
  call test (object_logical_10, "object_logical_10", &
       "build expressions from code", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_10 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    class(object_t), pointer :: p_log, p_not, p_and, p_or, core, main, object
    class(object_t), pointer :: val1, val2, expr
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_logical_10"
    write (u, "(A)")  "*   Purpose: construct expressions from code"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_log)
    select type (p_log)
    type is (composite_t)
       call p_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call p_log%import_core (core)
    end select

    allocate (not_t :: p_not)
    select type (p_not)
    type is (not_t)
       call p_not%init (p_log)
    end select

    allocate (and_t :: p_and)
    select type (p_and)
    type is (and_t)
       call p_and%init (p_log)
    end select

    allocate (or_t :: p_or)
    select type (p_or)
    type is (or_t)
       call p_or%init (p_log)
    end select

    call repository%init (name = var_str ("repository"), n_members = 4)
    call repository%import_member (1, p_log)
    call repository%import_member (2, p_not)
    call repository%import_member (3, p_and)
    call repository%import_member (4, p_or)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: not"
    

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("not"), expr)
    select type (expr)
    class is (not_t)
       call expr%init_args (1)
       call expr%import_member (1, val1)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 4
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: and"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("and"), expr)
    select type (expr)
    class is (and_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: or"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("or"), expr)
    select type (expr)
    class is (or_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_10"

  end subroutine object_logical_10

@ %def object_logical_10
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sindarin Parser}
<<[[sindarin_parser.f90]]>>=
<<File header>>

module sindarin_parser

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use diagnostics

  use ifiles
  use syntax_rules
  use lexers
  use parser
  
  use codes
  use builders

  use object_base
  use object_builder
  use object_expr
  use object_logical

<<Standard module head>>

<<Sindarin parser: public>>

<<Sindarin parser: types>>

<<Sindarin parser: variables>>

contains

<<Sindarin parser: procedures>>

<<Sindarin parser: tests>>

end module sindarin_parser
@ %def sindarin_parser
@ 
\subsection{Prototype Repository}
<<Sindarin parser: procedures>>=
  subroutine make_sindarin_repository (repository)
    type(repository_t), intent(inout) :: repository
    class(object_t), pointer :: core
    class(object_t), pointer :: logical
    class(object_t), pointer :: not, and, or
    class(object_t), pointer :: assignment
    integer :: i
    integer, parameter :: n_members = 5
    call repository%init (name = var_str ("repository"), n_members = n_members)
    ! Elementary data types
    ! logical
    allocate (composite_t :: logical)
    select type (logical)
    type is (composite_t)
       allocate (logical_t :: core)
       call logical%init (var_str ("logical"))
       call logical%import_core (core)
    end select
    ! Logical operators
    ! not
    allocate (not_t :: not)
    select type (not)
    type is (not_t);  call not%init (logical)
    end select
    ! and
    allocate (and_t :: and)
    select type (and)
    type is (and_t);  call and%init (logical)
    end select
    ! or
    allocate (or_t :: or)
    select type (or)
    type is (or_t);  call or%init (logical)
    end select
    ! Statements
    ! Assignment
    allocate (assignment_t :: assignment)
    select type (assignment)
    type is (assignment_t);  call assignment%init ()
    end select
    i = 0
    i = i + 1;  call repository%import_member (i, logical)
    i = i + 1;  call repository%import_member (i, not)
    i = i + 1;  call repository%import_member (i, and)
    i = i + 1;  call repository%import_member (i, or)
    i = i + 1;  call repository%import_member (i, assignment)
    if (i /= n_members) then
       write (msg_buffer, "(A,I0,A,I0,A)")  "Sindarin: prototype repository&
            & has size ", n_members, ", but ", i, " items are given."
       call msg_bug ()
    end if
  end subroutine make_sindarin_repository
    
@ %def make_sindarin_repository
@ 
\subsection{Syntax Object}
<<Sindarin parser: public>>=
  public :: syntax_sindarin
<<Sindarin parser: variables>>=
  type(syntax_t), target, save :: syntax_sindarin
  
@ %def syntax_sindarin
<<Sindarin parser: public>>=
  public :: syntax_sindarin_init
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_init ()
    type(ifile_t) :: ifile
    call sindarin_syntax_setup (ifile)
    call syntax_init (syntax_sindarin, ifile)
    call ifile%final ()
  end subroutine syntax_sindarin_init

@ %def syntax_sindarin_init
<<Sindarin parser: public>>=
  public :: syntax_sindarin_final
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_final ()
    call syntax_final (syntax_sindarin)
  end subroutine syntax_sindarin_final

@ %def syntax_sindarin_final
<<Sindarin parser: public>>=
  public :: syntax_sindarin_write
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_sindarin, unit)
  end subroutine syntax_sindarin_write

@ %def syntax_sindarin_write
<<Sindarin parser: procedures>>=
  subroutine sindarin_syntax_setup (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile%append ("SEQ script = command*")
    call ifile%append ("ALT command = declaration | assignment")
    call ifile%append ("SEQ declaration =&
         & builtin_type var_name assignment_clause?")
    call ifile%append ("SEQ assignment = var_name assignment_clause")
    call ifile%append ("ALT builtin_type = logical")
    call ifile%append ("KEY logical")
    call ifile%append ("IDE var_name")
    call ifile%append ("SEQ assignment_clause = '=' expr")
    call ifile%append ("KEY '='")
    call ifile%append ("ALT expr = logical_expr")
    call ifile%append ("SEQ logical_expr = logical_term or_clause*")
    call ifile%append ("SEQ logical_term = logical_value and_clause*")
    call ifile%append ("ALT logical_value =&
         & not_clause | logical_literal | group | atom")
    call ifile%append ("SEQ or_clause = or logical_term")
    call ifile%append ("SEQ and_clause = and logical_value")
    call ifile%append ("SEQ not_clause = not logical_value")
    call ifile%append ("ALT logical_literal = true | false")
    call ifile%append ("KEY or")
    call ifile%append ("KEY and")
    call ifile%append ("KEY not")
    call ifile%append ("KEY true")
    call ifile%append ("KEY false")
    call ifile%append ("GRO group = ( expr )")
    call ifile%append ("IDE atom")
  end subroutine sindarin_syntax_setup

@ %def sindarin_syntax_setup
@
\subsection{Parse Node Decoder}
This is an object that allows us to iterate over the parse tree step by step.
We implement it as an implementation of [[builder_t]], because it is
technically a builder (with only the decoding mode implemented) that works
just on a single node.

The [[sindarin_decoder_t]] below contains a factory method that allocates the
correct implementation of [[pn_decoder_t]], corresponding to a particular
syntax rule.

The [[pn_decoder_t]] object holds the pointer to a parse node and a numeric
item counter.  We also point to the syntax rule.

We include a pointer to the [[prototypes]] array, which is allocated in the
parent [[sindarin_decoder_t]] object.

The [[previous]] pointer allows us to build a stack of decoder objects.
<<Sindarin parser: types>>=
  type, extends (builder_t), abstract :: pn_decoder_t
     private
     type(parse_node_t), pointer :: pn => null ()
     type(parse_node_t), pointer :: pn_next => null ()
     type(syntax_rule_t), pointer :: rule => null ()
     type(string_t), dimension(:), pointer :: prototypes => null ()
     type(position_t) :: position
     class(pn_decoder_t), pointer :: previous => null ()
   contains
   <<Sindarin parser: pn decoder: TBP>>
  end type pn_decoder_t
  
@ %def pn_decoder_t
@ Finalizer: not needed in the default case.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: final => pn_decoder_final
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_final (builder)
    class(pn_decoder_t), intent(inout) :: builder
  end subroutine pn_decoder_final
  
@ %def pn_decoder_final
@ Output: print rule keyword and item index.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: write => pn_decoder_write
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_write (builder, unit)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(2x)", advance="no")
    call builder%rule%write (u, short=.true., key_only=.true., advance=.false.)
    write (u, "(':',1x)", advance="no")
    call builder%position%write (u)
    write (u, *)
  end subroutine pn_decoder_write

@ %def pn_decoder_write
@ Initialization: assign the parse node, determine the rule.  Also set the
prototype index if applicable.

The may have preset content, therefore intent(inout).
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: init => pn_decoder_init
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_init (builder, parse_node, rule, prototypes)
    class(pn_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    type(syntax_rule_t), intent(in), target :: rule
    type(string_t), dimension(:), target :: prototypes
    builder%pn => parse_node
    builder%rule => rule
    builder%prototypes => prototypes
  end subroutine pn_decoder_init
  
@ %def pn_decoder_init
@ The [[build]] method is not implemented for this type.  We just support
decoding, which is deferred to the rule-dependent implementation.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: build => pn_decoder_build
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_build (builder, code, success)
    class(pn_decoder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    success = .false.
    call msg_bug ("Parse-node decoder: build method not implemented")
  end subroutine pn_decoder_build
    
@ %def pn_decoder_build
@ Return the next parse (sub-)node to be interpreted, originating from the
current node.  If this is null, the current node has been digested fully.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: get_next_node => pn_decoder_get_next_node
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_get_next_node (builder, parse_node)
    class(pn_decoder_t), intent(in) :: builder
    type(parse_node_t), pointer, intent(out) :: parse_node
    parse_node => builder%pn_next
  end subroutine pn_decoder_get_next_node
  
@ %def pn_decoder_get_next_node
@ Return the current value of the position-part marker.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: get_part => pn_decoder_get_part
<<Sindarin parser: procedures>>=
  function pn_decoder_get_part (builder) result (part)
    class(pn_decoder_t), intent(in) :: builder
    integer :: part
    part = builder%position%part
  end function pn_decoder_get_part
  
@ %def pn_decoder_get_part
@
\subsection{Parse Tree Interpreter}
The Sindarin source is parsed by the [[parse_tree]] object, using the
[[sindarin_syntax]] table.  The next step is to convert the parse tree into
bytecode, corresponding to the Sindarin object tree structure.

This task is given to a the [[sindarin_decoder_t]] object, which is an
incarnation of the [[builder_t]] abstract type.  An abstract builder has
methods both for coding and decoding an object tree.  Here we just decode:
iterate over the parse tree and return a sequence of byte codes.

We store the array of prototype names, a pointer to the parse-tree root, and a
pointer to the node-decoder stack.  The prototype-name array is allocated via
pointer, so we can target it without worrying about TARGET attributes.

We also store the prototype index of the [[assignment]] statement, since this
will be frequently used and constant.
<<Sindarin parser: types>>=
  type, extends (builder_t) :: sindarin_decoder_t
     private
     type(string_t), dimension(:), pointer :: prototypes => null ()
     type(parse_node_t), pointer :: pn_root => null ()
     class(pn_decoder_t), pointer :: pn_decoder => null ()
   contains
   <<Sindarin parser: sindarin decoder: TBP>>
  end type sindarin_decoder_t
     
@ %def sindarin_decoder_t
@
\subsubsection{Finalizer}
Clear content accumulated by the decoder.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: final => sindarin_decoder_final
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_final (builder)
    class(sindarin_decoder_t), intent(inout) :: builder
    class(pn_decoder_t), pointer :: pn_decoder
    if (associated (builder%prototypes))  deallocate (builder%prototypes)
    do while (associated (builder%pn_decoder))
       pn_decoder => builder%pn_decoder
       builder%pn_decoder => pn_decoder%previous
       call pn_decoder%final ()
       deallocate (pn_decoder)
    end do
  end subroutine sindarin_decoder_final
  
@ %def sindarin_decoder_final
@
\subsubsection{Output}
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: write => sindarin_decoder_write
  procedure :: write_prototypes => sindarin_decoder_write_prototypes
  procedure :: write_tree => sindarin_decoder_write_tree
  procedure :: write_stack => sindarin_decoder_write_stack
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_write (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    write (u, "(A)")  "Parse-tree decoder state:"
    call builder%write_prototypes (u)
    call builder%write_tree (u)
    call builder%write_stack (u)
  end subroutine sindarin_decoder_write

  subroutine sindarin_decoder_write_prototypes (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (builder%prototypes)) then
       write (u, "(A)")  "Prototype names:"
       do i = 1, size (builder%prototypes)
          write (u, "(1x,I0,1x,A)")  i, char (builder%prototypes(i))
       end do
    else
       write (u, "(A)")  "[No prototype array]"
    end if
  end subroutine sindarin_decoder_write_prototypes

  subroutine sindarin_decoder_write_tree (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    if (associated (builder%pn_root)) then
       write (u, "(A)")  "Parse tree:"
       call builder%pn_root%write (unit, short=.true., depth = 1)
    else
       write (u, "(A)")  "[No parse tree]"
    end if
  end subroutine sindarin_decoder_write_tree

  subroutine sindarin_decoder_write_stack (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    if (associated (builder%pn_decoder)) then
       write (u, "(A)")  "Node handler stack:"
       pn_decoder => builder%pn_decoder
       do while (associated (pn_decoder))
          call pn_decoder%write (u)
          pn_decoder => pn_decoder%previous
       end do
    else
       write (u, "(A)")  "[No pointer stack]"
    end if
  end subroutine sindarin_decoder_write_stack

@ %def sindarin_decoder_write
@ %def sindarin_decoder_write_tree
@ %def sindarin_decoder_write_stack
@
\subsubsection{Initialization}
The decoder is started by associating the root of an existing parse tree.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: init => sindarin_decoder_init
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_init (decoder, parse_tree, prototype_names)
    class(sindarin_decoder_t), intent(out) :: decoder
    type(parse_tree_t), intent(in) :: parse_tree
    type(string_t), dimension(:), intent(in) :: prototype_names
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: i
    allocate (decoder%prototypes (size (prototype_names)))
    decoder%prototypes = prototype_names
    decoder%pn_root => parse_tree%get_root_ptr ()
    if (associated (decoder%pn_root)) then
       call decoder%push (decoder%pn_root, 0)
    end if
  end subroutine sindarin_decoder_init
  
@ %def sindarin_decoder_init
@
\subsubsection{Pointer Stack}
The decoder maintains a stack of decoder objects, which point to locations in
the parse tree.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure, private :: push => sindarin_decoder_push
  procedure, private :: pop => sindarin_decoder_pop
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_push (builder, parse_node, context_part)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    integer, intent(in) :: context_part
    class(pn_decoder_t), pointer :: pn_decoder
    call builder%make_pn_decoder (parse_node, context_part, pn_decoder)
    pn_decoder%previous => builder%pn_decoder
    builder%pn_decoder => pn_decoder
  end subroutine sindarin_decoder_push
    
  subroutine sindarin_decoder_pop (builder)
    class(sindarin_decoder_t), intent(inout) :: builder
    class(pn_decoder_t), pointer :: pn_decoder
    pn_decoder => builder%pn_decoder
    builder%pn_decoder => pn_decoder%previous
    call pn_decoder%final ()
    deallocate (pn_decoder)
  end subroutine sindarin_decoder_pop
    
@ %def sindarin_decoder_push
@ %def sindarin_decoder_pop
@
\subsubsection{Decoding}
Decode the current object and advance to the next.  If there is a valid
sub-node for the current node, push this to the top of the stack for the next
iteration.  If there is no object left, return [[.false.]]
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: decode => sindarin_decoder_decode
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_decode (builder, code, success)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_next
    integer :: context_part
    do while (associated (builder%pn_decoder))
       call builder%pn_decoder%decode (code, success)
       if (success) then
          call builder%pn_decoder%get_next_node (pn_next)
          if (associated (pn_next)) then
             context_part = builder%pn_decoder%get_part ()
             call builder%push (pn_next, context_part)
          end if
          if (code%cat /= 0) then
             return
          end if
       else
          call builder%pop ()
       end if
    end do
    success = .false.
  end subroutine sindarin_decoder_decode

@ %def sindarin_decoder_decode
@
\subsubsection{Building}
This is not applicable for [[sindarin_decoder_t]].
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: build => sindarin_decoder_build
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_build (builder, code, success)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    success = .false.
    call msg_bug ("Sindarin decoder: build method not implemented")
  end subroutine sindarin_decoder_build
    
@ %def sindarin_decoder_build
@
\subsection{Handling Individual Parse Nodes}
This is the factory method for creating a specific parse-node handler.  We
check the syntax rule and allocate a matching extension of [[pn_decoder_t]].
This extension is initialized with pointers to the parse node and rule.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: make_pn_decoder => sindarin_decoder_make_pn_decoder
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_make_pn_decoder &
       (builder, parse_node, context_part, pn_decoder)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    integer, intent(in) :: context_part
    class(pn_decoder_t), intent(out), pointer :: pn_decoder
    type(syntax_rule_t), pointer :: rule
    integer :: prototype_index
    rule => parse_node%get_rule_ptr ()
    prototype_index = 0
    select case (char (rule%get_key ()))
     <<Sindarin parser: decoder selection>>
    case default
       call msg_bug ("Sindarin decoder: rule '" &
            // char (rule%get_key ()) // "' not supported")
    end select
    call pn_decoder%init (parse_node, rule, builder%prototypes)
  end subroutine sindarin_decoder_make_pn_decoder
    
@ %def sindarin_decoder_make_pn_decoder
@ Auxiliary: return the index of a named prototype, using the prototype array.

NB: We do a simple linear search.  In case this becomes a bottleneck, we should
think about a hash table for the prototypes array.
<<Sindarin parser: procedures>>=
  function find_index (array, name) result (i_prototype)
    type(string_t), dimension(:), intent(in) :: array
    type(string_t), intent(in) :: name
    integer :: i_prototype
    integer :: i
    i_prototype = 0
    do i = 1, size (array)
       if (name == array(i)) then
          i_prototype = i
          return
       end if
    end do
  end function find_index

@ %def find_index
@
\subsubsection{Script}
<<Sindarin parser: decoder selection>>=
  case ("script")
     allocate (pnd_script_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_script_t
     private
     integer :: n_declarations = 0
     integer :: n_commands = 0
     integer, dimension(:), allocatable :: dec
     integer, dimension(:), allocatable :: com
   contains
     procedure :: decode => decode_script
  end type pnd_script_t
  
@ %def pnd_script_t
<<Sindarin parser: procedures>>=
  recursive subroutine decode_script (builder, code, success)
    class(pnd_script_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_com, pn_asg
    type(syntax_rule_t), pointer :: rule, rule_asg
    logical, dimension(:), allocatable :: mask_dec, mask_com
    integer :: i, n_sub, n_dec, n_com
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       n_sub = builder%pn%get_n_sub ()
       allocate (mask_dec (n_sub))
       allocate (mask_com (n_sub))
       pn_com => builder%pn%get_sub_ptr ()
       do i = 1, n_sub
          rule => pn_com%get_rule_ptr ()
          select case (char (rule%get_key ()))
          case ("declaration")
             mask_dec(i) = .true.
             pn_asg => pn_com%get_sub_ptr (3)
             mask_com(i) = associated (pn_asg)
          case default
             mask_dec(i) = .false.
             mask_com(i) = .true.
          end select
          pn_com => pn_com%get_next_ptr ()
       end do
       n_dec = count (mask_dec)
       n_com = count (mask_com)
       code%cat = CAT_COMPOSITE
       code%natt = 6
       code%att(4) = n_dec
       code%att(6) = n_com
       call code%create_string_val (builder%rule%get_key ())
       builder%n_declarations = n_dec
       builder%n_commands = n_com
       builder%dec = pack ([(i, i=1, n_sub)], mask_dec)
       builder%com = pack ([(i, i=1, n_sub)], mask_com)
       if (n_dec > 0) then
          builder%position%part = POS_MEMBER
          i = 1
          builder%pn_next => builder%pn%get_sub_ptr (builder%dec(1))
       else if (n_com > 0) then
          builder%position%part = POS_PRIMER
          i = 1
          builder%pn_next => builder%pn%get_sub_ptr (builder%com(1))
       else
          builder%position%part = POS_NONE
          i = 0
          builder%pn_next => null ()
       end if
    case (POS_MEMBER)
       i = builder%position%i
       if (i < builder%n_declarations) then
          i = i + 1
          builder%pn_next => builder%pn%get_sub_ptr (builder%dec(i))
       else if (builder%n_commands > 0) then
          builder%position%part = POS_PRIMER
          i = 1
          builder%pn_next => builder%pn%get_sub_ptr (builder%com(1))
       else
          builder%position%part = POS_NONE
          i = 0
          builder%pn_next => null ()
       end if
       builder%position%i = i
    case (POS_PRIMER)
       i = builder%position%i
       if (i < builder%n_commands) then
          i = i + 1
          builder%pn_next => builder%pn%get_sub_ptr (builder%com(i))
       else
          builder%position%part = POS_NONE
          i = 0
          builder%pn_next => null ()
       end if
    case default
       builder%pn_next => null ()
       success = .false.
    end select
    builder%position%i = i
  end subroutine decode_script
  
@ %def decode_script
@
\subsubsection{Declaration}
A declaration defines a new member of the current context.  When we encounter
the declaration statement, we decode it and prepare a member object with
undefined value.

The declaration may have an assignment clause.  To handle this, we create an
assignment builder instead (see below), when we encounter the parse node again
during primer generation.
<<Sindarin parser: decoder selection>>=
  case ("declaration")
     select case (context_part)
     case (POS_MEMBER)
        allocate (pnd_declaration_t :: pn_decoder)
     case (POS_PRIMER)
        allocate (pnd_assignment_t :: pn_decoder)
     end select
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_declaration_t
     private
   contains
     procedure :: decode => decode_declaration
  end type pnd_declaration_t
  
@ %def pnd_declaration_t
@ Declaration: we handle the declaration of a variable with name and
prototype and generate the code for initializing this as a member object.

The current implementation supports only [[variable]] objects.
<<Sindarin parser: procedures>>=
  recursive subroutine decode_declaration (builder, code, success)
    class(pnd_declaration_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_prototype, pn_var_name
    type(syntax_rule_t), pointer :: rule
    type(string_t) :: var_name
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       pn_prototype => builder%pn%get_sub_ptr ()
       rule => pn_prototype%get_rule_ptr ()
       pn_var_name => pn_prototype%get_next_ptr ()
       var_name = pn_var_name%get_string ()
       code%cat = CAT_COMPOSITE
       code%natt = 2
       code%att(1) = find_index (builder%prototypes, rule%get_key ())
       code%att(2) = MODE_VARIABLE
       call code%create_string_val (var_name)
       builder%position%part = POS_CORE
       builder%pn_next => null ()
    case (POS_CORE)
       code%cat = CAT_VALUE
       builder%position%part = POS_NONE
       builder%pn_next => null ()
    case default
       builder%pn_next => null ()
       success = .false.
    end select
  end subroutine decode_declaration
  
@ %def decode_declaration
@
\subsubsection{Assignment}
Assign a variable: lhs is the variable name, rhs is an expression.  The
prototype index is constant.
<<Sindarin parser: decoder selection>>=
  case ("assignment")
     allocate (pnd_assignment_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_assignment_t
     private
     type(string_t) :: var_name
     type(parse_node_t), pointer :: pn_rhs => null ()
   contains
     procedure :: decode => decode_assignment
  end type pnd_assignment_t
  
@ %def pnd_assignment_t
@ Decode.  There is a composite assignment object, a left-hand side (variable
name) as an ID object, and a right-hand side expression which becomes a member
object.
<<Sindarin parser: procedures>>=
  recursive subroutine decode_assignment (builder, code, success)
    class(pnd_assignment_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_lhs, pn_asg
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       select case (char (builder%rule%get_key ()))
       case ("assignment")
          pn_lhs => builder%pn%get_sub_ptr ()
       case ("declaration")
          pn_lhs => builder%pn%get_sub_ptr (2)
       end select
       pn_asg => pn_lhs%get_next_ptr ()
       builder%pn_rhs => pn_asg%get_sub_ptr (2)
       builder%var_name = pn_lhs%get_string ()
       code%cat = CAT_COMPOSITE
       code%natt = 1
       code%att(1) = find_index (builder%prototypes, var_str ("assignment"))
       builder%position%part = POS_ID
       builder%pn_next => null ()
    case (POS_ID)
       code%cat = CAT_ID
       call code%create_string_val (builder%var_name)
       builder%position%part = POS_MEMBER
       builder%pn_next => null ()
    case (POS_MEMBER)
       builder%position%part = POS_NONE
       builder%pn_next => builder%pn_rhs
    case default
       builder%pn_next => null ()
       success = .false.
    end select
  end subroutine decode_assignment
  
@ %def decode_assignment
@
\subsubsection{Atom}
This is a variable reference.

Note: current support only for simple variable name.
<<Sindarin parser: decoder selection>>=
  case ("atom")
     allocate (pnd_atom_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_atom_t
     private
   contains
     procedure :: decode => decode_atom
  end type pnd_atom_t
  
@ %def pnd_atom_t
@ Decode.
<<Sindarin parser: procedures>>=
  recursive subroutine decode_atom (builder, code, success)
    class(pnd_atom_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       code%cat = CAT_REFERENCE
       builder%position%part = POS_ID
       builder%pn_next => null ()
    case (POS_ID)
       code%cat = CAT_ID
       call code%create_string_val (builder%pn%get_string ())
       builder%position%part = POS_NONE
       builder%pn_next => null ()
    case default
       builder%pn_next => null ()
       success = .false.
    end select
  end subroutine decode_atom
  
@ %def decode_atom
@
\subsubsection{Logical expression}
Assign a variable: lhs is the variable name, rhs is an expression.  The
prototype index is constant.
<<Sindarin parser: decoder selection>>=
  case ("logical_expr", "logical_term")
     allocate (pnd_logical_expr_t :: pn_decoder)
  case ("not_clause")
     allocate (pnd_logical_expr_t :: pn_decoder)
     select type (pn_decoder)
     type is (pnd_logical_expr_t)
        pn_decoder%unary = .true.
     end select
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_logical_expr_t
     private
     logical :: unary = .false.
   contains
     procedure :: decode => decode_logical_expr
  end type pnd_logical_expr_t
  
@ %def pnd_logical_expr_t
@ Decode.
<<Sindarin parser: procedures>>=
  recursive subroutine decode_logical_expr (builder, code, success)
    class(pnd_logical_expr_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_arg, pn_op
    type(syntax_rule_t), pointer :: rule
    integer :: i, n_terms
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       if (builder%unary) then
          pn_arg => null ()
          pn_op => builder%pn
       else
          pn_arg => builder%pn%get_sub_ptr ()
          pn_op => builder%pn%get_sub_ptr (2)
       end if
       n_terms = builder%pn%get_n_sub ()
       if (associated (pn_op)) then
          rule => pn_op%get_rule_ptr ()
          code%cat = CAT_COMPOSITE
          code%natt = 5
          select case (char (rule%get_key ()))
          case ("not_clause")
             code%att(1) = find_index (builder%prototypes, var_str ("not"))
             code%att(2) = MODE_CONSTANT
             code%att(4) = 1
             code%att(5) = 1
          case ("and_clause")
             code%att(1) = find_index (builder%prototypes, var_str ("and"))
             code%att(2) = MODE_CONSTANT
             code%att(4) = n_terms
             code%att(5) = n_terms
          case ("or_clause")
             code%att(1) = find_index (builder%prototypes, var_str ("or"))
             code%att(2) = MODE_CONSTANT
             code%att(4) = n_terms
             code%att(5) = n_terms
          end select
          builder%position%part = POS_MEMBER
          builder%position%i = 1
          builder%pn_next => pn_arg
       else
          builder%position%part = POS_NONE
          builder%pn_next => pn_arg
       end if
    case (POS_MEMBER)
       i = builder%position%i
       i = i + 1
       if (builder%unary) then
          pn_op => builder%pn
       else
          pn_op => builder%pn%get_sub_ptr (i)
       end if
       pn_arg => pn_op%get_sub_ptr (2)
       builder%position%part = POS_CORE
       builder%pn_next => pn_arg
    case (POS_CORE)
       code%cat = CAT_VALUE
       builder%position%part = POS_NONE
       builder%pn_next => null ()
    case default
       builder%pn_next => null ()
       success = .false.
    end select
  end subroutine decode_logical_expr
  
@ %def decode_logical_expr
@
\subsubsection{Logical literal}
The logical values [[true]] and [[false]] are coded as [[logical]] objects
with a definite initial value.
<<Sindarin parser: decoder selection>>=
  case ("true")
     allocate (pnd_logical_literal_t :: pn_decoder)
     select type (pn_decoder)
     type is (pnd_logical_literal_t)
        pn_decoder%value = .true.
     end select
  case ("false")
     allocate (pnd_logical_literal_t :: pn_decoder)
     select type (pn_decoder)
     type is (pnd_logical_literal_t)
        pn_decoder%value = .false.
     end select
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_logical_literal_t
     private
     logical :: value
   contains
     procedure :: decode => decode_logical_literal
  end type pnd_logical_literal_t
  
@ %def pnd_logical_literal_t
@ Decode.
<<Sindarin parser: procedures>>=
  recursive subroutine decode_logical_literal (builder, code, success)
    class(pnd_logical_literal_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn1, pn_op
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       code%cat = CAT_COMPOSITE
       code%natt = 2
       code%att(1) = find_index (builder%prototypes, var_str ("logical"))
       code%att(2) = MODE_CONSTANT
       builder%position%part = POS_CORE
       builder%pn_next => null ()
    case (POS_CORE)
       code%cat = CAT_VALUE
       call code%create_logical_val (builder%value)
       builder%position%part = POS_NONE
       builder%pn_next => null ()
    case default
       builder%pn_next => null ()
       success = .false.
    end select
  end subroutine decode_logical_literal
  
@ %def decode_logical_literal
@ 
\subsection{Unit tests}
<<Sindarin parser: public>>=
  public :: sindarin_parser_test
<<Sindarin parser: procedures>>=
  subroutine sindarin_parser_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Sindarin parser: execute tests>>  
  end subroutine sindarin_parser_test
  
@ %def sindarin_parser_test 
@
Build and display the Sindarin syntax
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_1, "sindarin_parser_1", &
       "syntax table", &
       u, results)
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_1 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: sindarin_parser_1"
    write (u, "(A)")  "*   Purpose: build syntax table"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()
    call syntax_sindarin_write (u)
    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_1"
    
    end subroutine sindarin_parser_1

@ %def sindarin_parser_1
@
Build and display the Sindarin repository
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_2, "sindarin_parser_2", &
       "repository", &
       u, results)
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_2 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    type(string_t), dimension(:), allocatable :: name
    integer :: i

    write (u, "(A)")  "* Test output: sindarin_parser_2"
    write (u, "(A)")  "*   Purpose: build Sindarin repository"
    write (u, "(A)")      
    
    call make_sindarin_repository (repository)
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Name array"
    write (u, "(A)")
    
    call repository%get_prototype_names (name)
    do i = 1, size (name)
       write (u, "(I0,1x,A)")  i, char (name (i))
    end do

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_2"
    
    end subroutine sindarin_parser_2

@ %def sindarin_parser_2
@
Parse a simple Sindarin script
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_3, "sindarin_parser_3", &
       "parse script", &
       u, results)
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_3 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_3"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")
    
    write (u_sin, "(A)")  "logical a"
    write (u_sin, "(A)")  "logical b = true"
    write (u_sin, "(A)")  "a = b and not false"          ! = true 
    write (u_sin, "(A)")  "b = (a or true) and (not b)"  ! = false
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "()", &
         special_class = [ "=" ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)
    call decoder%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Decode (see 'sindarin_parser_3.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_3.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_3"
    
    end subroutine sindarin_parser_3

@ %def sindarin_parser_3

