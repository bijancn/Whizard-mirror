% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: Sindarin


\chapter{Sindarin}

\begin{description}
\item[codes]
  Elementary codes and parameters used by the Sindarin modules.
\item[builders]
  Abstract builder that makes use of bytecode.
\item[object\_base]
  Basic objects and methods.
\item[object\_builder]
  Enables building and decoding of objects via bytecode.
\item[object\_expr]
  Statements, assignment, expressions and operators.
\item[object\_logical]
  Logical values and expressions.
\item[object\_integer]
  Integer values and expressions.
\item[object\_comparison]
  Equality and inequality checks.
\item[object\_conditional]
  If-then-else expressions and statements.
\item[sindarin\_parser]
  Parse Sindarin code and transform into bytecode and object tree.
\end{description}

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Codes}
This module contains predefined numerical codes.  It also introduces
[[code_t]] as a universal non-recursive representations for objects.
<<[[codes.f90]]>>=
<<File header>>

module codes
  
<<Use strings>>
<<Use kinds>>
  use io_units

<<Standard module head>>

<<Codes: public>>

<<Codes: parameters>>

<<Codes: types>>
  
<<Codes: interfaces>>

contains
  
<<Codes: procedures>>

end module codes
@ %def codes
@
\subsection{Navigation}
These codes are useful for navigation within an object tree, they represent
locations within a (composite) object.
<<Codes: parameters>>=
  integer, parameter, public :: POS_NONE = -1
  integer, parameter, public :: POS_HERE = 0
  integer, parameter, public :: POS_ID = 1
  integer, parameter, public :: POS_CORE = 2
  integer, parameter, public :: POS_MEMBER = 3
  integer, parameter, public :: POS_PRIMER = 4

@ %def POS_NONE POS_HERE POS_ID POS_CORE POS_MEMBER POS_PRIMER
@ The [[position_t]] object combines a location code with an arbitrary integer
counter.   The type is kept public and transparent.
<<Codes: public>>=
  public :: position_t
<<Codes: types>>=
  type :: position_t
     integer :: part = POS_HERE
     integer :: i = 0
   contains
   <<Codes: position: TBP>>
  end type position_t

@ %def position_t
<<Codes: position: TBP>>=
  procedure :: write => position_write
<<Codes: procedures>>=
  subroutine position_write (position, unit)
    class(position_t), intent(in) :: position
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    select case (position%part)
    case (POS_NONE)
       write (u, "(1x,'-')", advance="no")
    case (POS_HERE)
       write (u, "(1x,'H')", advance="no")
    case (POS_ID)
       write (u, "(1x,'I')", advance="no")
    case (POS_CORE)
       write (u, "(1x,'C')", advance="no")
    case (POS_MEMBER)
       write (u, "(1x,'M',I0)", advance="no")  position%i
    case (POS_PRIMER)
       write (u, "(1x,'P',I0)", advance="no")  position%i
    case default
       write (u, "(1x,'?')", advance="no")
    end select
  end subroutine position_write

@ %def position_write
@
\subsection{Object categories}
Category codes for atomic objects.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_TAG = 1
  integer, parameter, public :: CAT_VALUE = 2
  integer, parameter, public :: CAT_ID = 3

@ %def CAT_TAG CAT_VALUE CAT_ID
@ Reference objects and arrays.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_REFERENCE = 99
  integer, parameter, public :: CAT_REF_ARRAY = 90

@ %def CAT_REFERENCE CAT_REF_ARRAY
@ Category code for a composite object.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_COMPOSITE = 100

@ %def CAT_COMPOSITE
@
\subsection{Operator codes}
We use integer codes for identifying comparison operators.
<<Codes: parameters>>=
  integer, parameter, public :: CMP_NONE = 0
  integer, parameter, public :: CMP_EQ = 1
  integer, parameter, public :: CMP_NE = 2
  integer, parameter, public :: CMP_LT = 3
  integer, parameter, public :: CMP_GT = 4
  integer, parameter, public :: CMP_LE = 5
  integer, parameter, public :: CMP_GE = 6
  
@ %def CMP_EQ CMP_NE CMP_LT CMP_GT CMP_LE CMP_GE
@ Codes for generic container objects.
<<Codes: parameters>>=
  integer, parameter, public :: CT_TUPLE = 201
  integer, parameter, public :: CT_LIST = 202
  integer, parameter, public :: CT_SEQUENCE = 203

@ %def CT_TUPLE CT_LIST CT_SEQUENCE
@ These codes distinguish step formats for range expressions.
<<Codes: parameters>>=
  integer, parameter, public :: CT_ADD = 210
  integer, parameter, public :: CT_SUB = 211
  integer, parameter, public :: CT_MUL = 212
  integer, parameter, public :: CT_DIV = 213
  integer, parameter, public :: CT_LIN = 214
  integer, parameter, public :: CT_LOG = 215
  
@ %def CT_ADD CT_SUB CT_MUL CT_DIV CT_LIN CT_LOG
@ 
\subsection{Priority values}
A list of predefined priorities.  The default
priority for atomic objects is zero, so operators get negative values.

Arithmetic operators.  The unary minus has higher priority than addition.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_POWER = -71
  integer, parameter, public :: PRIO_MULTIPLY = -72
  integer, parameter, public :: PRIO_MINUS = -73 
  integer, parameter, public :: PRIO_ADD = -74
  
@ %def PRIO_POWER PRIO_MULTIPLY PRIO_ADD
@ %def PRIO_MINUS
@ The comparison operators are between the arithmetic and the Logical
operators.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_COMPARE = -95

@ %def PRIO_COMPARE
@ Logical operators.  Here, the unary not has highest priority.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_NOT = -100
  integer, parameter, public :: PRIO_AND = -101
  integer, parameter, public :: PRIO_OR  = -102
  
@ %def PRIO_NOT PRIO_AND PRIO_OR
@ Container expressions.  Diverse priority values, colon is high but below
arithmetic operators.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_COLON = -80
  integer, parameter, public :: PRIO_COMMA = -121
  integer, parameter, public :: PRIO_ARROW = -122
  
@ %def PRIO_COLON, PRIO_COMMA, PRIO_ARROW
@
Conditional expression.  This priority is rather low, so the arguments
(branches) don't get brackets around them.  In output, this will result in a
bracket around the whole conditional expression.  We don't require this on
input, however.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_CONDITIONAL = -200

@ %def PRIO_CONDITIONAL 
@
\subsection{Minimal value container}
The universal code for an object allows us to construct and transfer objects
via a list of code numbers and elementary values.  We provide value containers
in form of one-dimensional arrays which may be of any of the elementary
Fortran types.

Compiler compatibility prohibits a polymorphic value array.  Instead, we store
an array inside the polymorphic value object.
<<Codes: types>>=
  type, abstract :: val_t
     private
   contains
   <<Codes: val: TBP>>
  end type val_t
  
@ %def val_t
@ Each concrete value type has a unique type code.
<<Codes: val: TBP>>=
  procedure(val_get_type), deferred :: get_type
<<Codes: interfaces>>=
  abstract interface
     function val_get_type (val) result (t)
       import
       class(val_t), intent(in) :: val
       integer :: t
     end function val_get_type
  end interface
  
@ %def val_get_type
@ The initializer has to allocate the array.
<<Codes: val: TBP>>=
  procedure(val_init), deferred :: init
<<Codes: interfaces>>=
  abstract interface
     subroutine val_init (val, nval)
       import
       class(val_t), intent(out) :: val
       integer, intent(in) :: nval
     end subroutine val_init
  end interface
  
@ %def val_init
@ Return array size.
<<Codes: val: TBP>>=
  procedure(val_get_nval), deferred :: get_nval
<<Codes: interfaces>>=
  abstract interface
     function val_get_nval (val) result (nval)
       import
       class(val_t), intent(in) :: val
       integer :: nval
     end function val_get_nval
  end interface
  
@ %def val_get_nval
@ Each concrete value must have an input and an output method.  We read/write
one value entry at a time.
<<Codes: val: TBP>>=
  procedure(val_read), deferred :: read
  procedure(val_write), deferred :: write
<<Codes: interfaces>>=
  abstract interface
     subroutine val_read (val, unit, i, iostat)
       import
       class(val_t), intent(inout) :: val
       integer, intent(in) :: unit, i
       integer, intent(out), optional :: iostat
     end subroutine val_read
  end interface
       
  abstract interface
     subroutine val_write (val, unit, i)
       import
       class(val_t), intent(in) :: val
       integer, intent(in) :: unit, i
     end subroutine val_write
  end interface
       
@ %def val_read 
@ %def val_write
@
\subsection{Universal code}
The code object consists of a category code which determines the
interpretation, a number of integer attribute codes, and an optional value.
For the attributes, we use a fixed-size array for simplicity.

We deliberately make all components public.
<<Codes: parameters>>=
  integer, parameter :: NATT_MAX = 16
  integer, parameter :: NAME_LEN_MAX = 256
  
<<Codes: public>>=
  public :: code_t
<<Codes: types>>=
  type :: code_t
     private
     integer :: cat = 0
     integer :: natt = 0
     integer, dimension(NATT_MAX) :: att = 0
     class(val_t), allocatable :: val
   contains
   <<Codes: code: TBP>>
  end type code_t
     
@ %def code_t
@ Methods for input and output.  We mostly read integers.
<<Codes: code: TBP>>=
  procedure :: read => code_read
  procedure :: write => code_write
<<Codes: procedures>>=
  subroutine code_read (code, unit, iostat)
    class(code_t), intent(out) :: code
    integer, intent(in) :: unit
    integer, intent(out), optional :: iostat
    logical :: err
    integer :: cat, vt, nval, natt, i
    err = .false.
    if (present (iostat)) then
       read (unit, *, iostat=iostat) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
       call check;  if (err)  return
    else
       read (unit, *) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
    end if
    code%cat = cat
    code%natt = natt
    if (vt > 0) then
       call code%create_val (code%val, vt, nval)
       do i = 1, nval
          call code%val%read (unit, i, iostat=iostat)
          if (present (iostat))  call check;  if (err)  return
       end do
    end if
  contains
    subroutine check
      err = iostat /= 0
    end subroutine check
  end subroutine code_read
    
  subroutine code_write (code, unit, iostat, verbose)
    class(code_t), intent(in) :: code
    integer, intent(in), optional :: unit
    integer, intent(out), optional :: iostat
    logical, intent(in), optional :: verbose
    logical :: verb
    integer :: natt, nval, i, u
    u = given_output_unit (unit)
    verb = .false.; if (present (verbose))  verb = verbose
    if (verb)  write (u, "(1x,A,1x)", advance="no")  "c="
    write (u, "(I0)", advance="no")  code%cat
    if (verb)  write (u, "(2x,A)", advance="no")  "vt="
    if (allocated (code%val)) then
       write (u, "(1x,I0)", advance="no")  code%val%get_type ()
       nval = code%val%get_nval ()
    else
       write (u, "(1x,I0)", advance="no")  0
       nval = 0
    end if
    if (verb)  write (u, "(2x,A)", advance="no")  "nv="
    write (u, "(1x,I0)", advance="no")  nval
    natt = code%natt
    if (.not. verb)  write (u, "(1x,I0)", advance="no")  natt
    if (natt > 0) then
       if (verb)  write (u, "(2x,A)", advance="no")  "att="
       write (u, "(*(1x,I0,:))")  code%att(1:natt)
    else
       write (u, *)
    end if
    do i = 1, nval
       if (verb)  write (u, "(5x)", advance="no")
       call code%val%write (u, i)
    end do
  end subroutine code_write
    
@ %def code_read
@ %def code_write
@ Set code by subroutine.
<<Codes: code: TBP>>=
  procedure :: set
<<Codes: procedures>>=
  subroutine set (code, cat, att)
    class(code_t), intent(inout) :: code
    integer, intent(in) :: cat
    integer, dimension(:), optional, intent(in) :: att
    code%cat = cat
    if (present (att)) then
       code%natt = size (att)
       code%att(1:code%natt) = att
    else
       code%natt = 0
    end if
  end subroutine set
   
@ %def set
@ Return the category code / a specific attribute entry.
<<Codes: code: TBP>>=
  procedure :: get_cat
  procedure :: get_n_att
  procedure :: get_att
<<Codes: procedures>>=
  function get_cat (code) result (cat)
    class(code_t), intent(in) :: code
    integer :: cat
    cat = code%cat
  end function get_cat

  function get_n_att (code) result (n)
    class(code_t), intent(in) :: code
    integer :: n
    n = code%natt
  end function get_n_att
  
  function get_att (code, i) result (att)
    class(code_t), intent(in) :: code
    integer, intent(in) :: i
    integer :: att
    if (i <= code%natt) then
       att = code%att(i)
    else
       att = 0
    end if
  end function get_att
  
@ %def get_cat
@ %def get_n_att
@ %def get_att
@
\subsection{Concrete value types}
These are the Fortran elementary types that we allow.

\subsubsection{Logical}
<<Codes: public>>=
  public :: val_logical_t
<<Codes: types>>=
  type, extends (val_t) :: val_logical_t
     private
     logical, dimension(:), allocatable :: x
   contains
   <<Codes: val logical: TBP>>
  end type val_logical_t
     
@ %def val_logical_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_LOGICAL = 1
<<Codes: val cases>>=
  case (VT_LOGICAL);  allocate (val_logical_t :: val)
<<Codes: val logical: TBP>>=
  procedure :: get_type => val_logical_get_type
<<Codes: procedures>>=
  function val_logical_get_type (val) result (type)
    class(val_logical_t), intent(in) :: val
    integer :: type
    type = VT_LOGICAL
  end function val_logical_get_type
  
@ %def val_logical_get_type
@ Init.  Allocate the array.
<<Codes: val logical: TBP>>=
  procedure :: init => val_logical_init
<<Codes: procedures>>=
  subroutine val_logical_init (val, nval)
    class(val_logical_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_logical_init
  
@ %def val_logical_init
@ Return array size.
<<Codes: val logical: TBP>>=
  procedure :: get_nval => val_logical_get_nval
<<Codes: procedures>>=
  function val_logical_get_nval (val) result (nval)
    class(val_logical_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_logical_get_nval
  
@ %def val_logical_get_nval
@ I/O.  List-directed is ok.
<<Codes: val logical: TBP>>=
  procedure :: read => val_logical_read
  procedure :: write => val_logical_write
<<Codes: procedures>>=
  subroutine val_logical_read (val, unit, i, iostat)
    class(val_logical_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  val%x(i)
    else
       read (unit, *)  val%x(i)
    end if
  end subroutine val_logical_read
       
  subroutine val_logical_write (val, unit, i)
    class(val_logical_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(L1)")  val%x(i)
  end subroutine val_logical_write
       
@ %def val_logical_read 
@ %def val_logical_write
<<Codes: code: TBP>>=
  procedure :: create_logical_val
  procedure :: get_logical_array
  procedure :: get_logical
<<Codes: procedures>>=
  subroutine create_logical_val (code, item)
    class(code_t), intent(inout) :: code
    logical, dimension(:), intent(in) :: item
    call create_val (code%val, VT_LOGICAL, size (item))
    select type (val => code%val)
    type is (val_logical_t);  val%x = item
    end select
  end subroutine create_logical_val
  
  subroutine get_logical_array (code, item, success)
    class(code_t), intent(in) :: code
    logical, dimension(:), intent(out), allocatable :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_logical_t)
          item = val%x
          success = .true.;  return
       end select
    end if
    success = .false.
  end subroutine get_logical_array
  
  subroutine get_logical (code, item, success)
    class(code_t), intent(in) :: code
    logical, intent(out) :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_logical_t)
          if (size (val%x) == 1) then
             item = val%x(1)
             success = .true.;  return
          end if
       end select
    end if
    success = .false.
  end subroutine get_logical
  
@ %def create_logical_val
@ %def get_logical_array
@ %def get_logical
@
\subsubsection{String}
<<Codes: public>>=
  public :: val_string_t
<<Codes: types>>=
  type, extends (val_t) :: val_string_t
     private
     type(string_t), dimension(:), allocatable :: x
   contains
   <<Codes: val string: TBP>>
  end type val_string_t
     
@ %def val_string_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_STRING = 2
<<Codes: val cases>>=
  case (VT_STRING);  allocate (val_string_t :: val)
<<Codes: val string: TBP>>=
  procedure :: get_type => val_string_get_type
<<Codes: procedures>>=
  function val_string_get_type (val) result (type)
    class(val_string_t), intent(in) :: val
    integer :: type
    type = VT_STRING
  end function val_string_get_type
  
@ %def val_string_get_type
@ Init.  Allocate the array.
<<Codes: val string: TBP>>=
  procedure :: init => val_string_init
<<Codes: procedures>>=
  subroutine val_string_init (val, nval)
    class(val_string_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_string_init
  
@ %def val_string_init
@ Return array size.
<<Codes: val string: TBP>>=
  procedure :: get_nval => val_string_get_nval
<<Codes: procedures>>=
  function val_string_get_nval (val) result (nval)
    class(val_string_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_string_get_nval
  
@ %def val_string_get_nval
@ I/O.  We rely on the size being allocated before, using an attribute index
for input.  We write one array entry per line.  The string length is limited
to [[NAME_LEN_MAX]]
<<Codes: val string: TBP>>=
  procedure :: read => val_string_read
  procedure :: write => val_string_write
<<Codes: procedures>>=
  subroutine val_string_read (val, unit, i, iostat)
    class(val_string_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    character(NAME_LEN_MAX) :: buffer
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  buffer
    else
       read (unit, *)  buffer
    end if
    val%x(i) = trim (adjustl (buffer))
  end subroutine val_string_read
       
  subroutine val_string_write (val, unit, i)
    class(val_string_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(A)")  char (val%x(i))
  end subroutine val_string_write
       
@ %def val_string_read 
@ %def val_string_write
<<Codes: code: TBP>>=
  procedure :: create_string_val
  procedure :: get_string_array
  procedure :: get_string
<<Codes: procedures>>=
  subroutine create_string_val (code, item)
    class(code_t), intent(inout) :: code
    type(string_t), dimension(:), intent(in) :: item
    call create_val (code%val, VT_STRING, size (item))
    select type (val => code%val)
    type is (val_string_t);  val%x = item
    end select
  end subroutine create_string_val
  
  subroutine get_string_array (code, item, success)
    class(code_t), intent(in) :: code
    type(string_t), dimension(:), intent(out), allocatable :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_string_t)
          allocate (item (size (val%x)))
          item = val%x
          success = .true.;  return
       end select
    end if
    success = .false.
  end subroutine get_string_array
  
  subroutine get_string (code, item, success)
    class(code_t), intent(in) :: code
    type(string_t), intent(out) :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_string_t)
          if (size (val%x) == 1) then
             item = val%x(1)
             success = .true.;  return
          end if
       end select
    end if
    success = .false.
  end subroutine get_string
  
@ %def create_string_val
@ %def get_string_array
@ %def get_string
@
\subsubsection{Integer}
<<Codes: public>>=
  public :: val_integer_t
<<Codes: types>>=
  type, extends (val_t) :: val_integer_t
     private
     integer, dimension(:), allocatable :: x
   contains
   <<Codes: val integer: TBP>>
  end type val_integer_t
     
@ %def val_integer_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_INTEGER = 3
<<Codes: val cases>>=
  case (VT_INTEGER);  allocate (val_integer_t :: val)
<<Codes: val integer: TBP>>=
  procedure :: get_type => val_integer_get_type
<<Codes: procedures>>=
  function val_integer_get_type (val) result (type)
    class(val_integer_t), intent(in) :: val
    integer :: type
    type = VT_INTEGER
  end function val_integer_get_type
  
@ %def val_integer_get_type
@ Init.  Allocate the array.
<<Codes: val integer: TBP>>=
  procedure :: init => val_integer_init
<<Codes: procedures>>=
  subroutine val_integer_init (val, nval)
    class(val_integer_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_integer_init
  
@ %def val_integer_init
@ Return array size.
<<Codes: val integer: TBP>>=
  procedure :: get_nval => val_integer_get_nval
<<Codes: procedures>>=
  function val_integer_get_nval (val) result (nval)
    class(val_integer_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_integer_get_nval
  
@ %def val_integer_get_nval
@ I/O.  List-directed is ok.
<<Codes: val integer: TBP>>=
  procedure :: read => val_integer_read
  procedure :: write => val_integer_write
<<Codes: procedures>>=
  subroutine val_integer_read (val, unit, i, iostat)
    class(val_integer_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  val%x(i)
    else
       read (unit, *)  val%x(i)
    end if
  end subroutine val_integer_read
       
  subroutine val_integer_write (val, unit, i)
    class(val_integer_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(I0)")  val%x(i)
  end subroutine val_integer_write
       
@ %def val_integer_read 
@ %def val_integer_write
<<Codes: code: TBP>>=
  procedure :: create_integer_val
  procedure :: get_integer_array
  procedure :: get_integer
<<Codes: procedures>>=
  subroutine create_integer_val (code, item)
    class(code_t), intent(inout) :: code
    integer, dimension(:), intent(in) :: item
    call create_val (code%val, VT_INTEGER, size (item))
    select type (val => code%val)
    type is (val_integer_t);  val%x = item
    end select
  end subroutine create_integer_val
  
  subroutine get_integer_array (code, item, success)
    class(code_t), intent(in) :: code
    integer, dimension(:), intent(out), allocatable :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_integer_t)
          item = val%x
          success = .true.;  return
       end select
    end if
    success = .false.
  end subroutine get_integer_array
  
  subroutine get_integer (code, item, success)
    class(code_t), intent(in) :: code
    integer, intent(out) :: item
    logical, intent(out) :: success
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_integer_t)
          if (size (val%x) == 1) then
             item = val%x(1)
             success = .true.;  return
          end if
       end select
    end if
    success = .false.
  end subroutine get_integer
  
@ %def create_integer_val
@ %def get_integer_array
@ %def get_integer
@
\subsection{Generic value constructor}
Depending on the value code, we allocate a specific value object.
<<Codes: code: TBP>>=
  procedure, nopass :: create_val
<<Codes: procedures>>=
  subroutine create_val (val, vt, nval)
    class(val_t), allocatable, intent(out) :: val
    integer, intent(in) :: vt, nval
    if (allocated (val))  deallocate (val)    
    select case (vt)
  <<Codes: val cases>>
    end select
    call val%init (nval)
  end subroutine create_val
  
@ %def create_val
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[codes_ut.f90]]>>=
<<File header>>

module codes_ut

  use unit_tests
  use codes_uti
  
<<Standard module head>>

<<Codes: public test>>

contains
  
<<Codes: test driver>>

end module codes_ut
@ %def codes_ut
@ 
<<[[codes_uti.f90]]>>=
<<File header>>

module codes_uti
  
  use io_units

  use codes
    
<<Standard module head>>

<<Codes: test declarations>>

contains
  
<<Codes: tests>>

end module codes_uti
@ %def codes_uti
@ API: driver for the unit tests below.
<<Codes: public test>>=
  public :: codes_test
<<Codes: test driver>>=
  subroutine codes_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Codes: execute tests>>  
  end subroutine codes_test
  
@ %def codes_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Codes: execute tests>>=
  call test (codes_1, "codes_1", &
       "object codes: I/O", &
       u, results)
<<Codes: test declarations>>=
  public :: codes_1
<<Codes: tests>>=
  subroutine codes_1 (u)
    integer, intent(in) :: u
    integer :: utmp, i
    type(code_t) :: code
    character(256) :: buffer

    write (u, "(A)")  "* Test output: codes_1"
    write (u, "(A)")  "*   Purpose: check code I/O"
    write (u, "(A)")      

    utmp = free_unit ()
    open (utmp, status="scratch", action="readwrite")

    write (utmp, "(1x,A)")  "4 0 0 0"
    write (utmp, "(1x,A)")  "5 2 1 3 5 6 7"
    write (utmp, "(1x,A)")  "foo"
    write (utmp, "(1x,A)")  "7 1 2 0"
    write (utmp, "(1x,A)")  "T"
    write (utmp, "(1x,A)")  "F"
    write (utmp, "(1x,A)")  "42 3 3 0"
    write (utmp, "(1x,A)")  "0"
    write (utmp, "(1x,A)")  "12345"
    write (utmp, "(1x,A)")  "-987654321"
    
    rewind (utmp)
    do
       read (utmp, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (utmp)
    write (u, *)

    do i = 1, 4
       call code%read (utmp)
       call code%write (u, verbose=.true.)
    end do

    rewind (utmp)
    write (u, *)

    do i = 1, 4
       call code%read (utmp)
       call code%write (u)
    end do

    close (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: codes_1"
    
  end subroutine codes_1

@ %def codes_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Builder}
This module introduces an abstract type, designed for converting between
bytecode and an undefined kind of object tree.

The abstract type merely declares a finalizer, output, and one method for
building (from bytecode) and decoding (to bytecode), respectively.  We
implement a shortcut that converts between two builders.

Initialization, object extraction etc.\ will depend on the specific
implementations.
<<[[builders.f90]]>>=
<<File header>>

module builders

  use codes

<<Standard module head>>

<<Builder: public>>

<<Builder: types>>

<<Builder: interfaces>>

contains
  
<<Builder: procedures>>

end module builders
@ %def builders
@
\subsection{Abstract Type}
<<Builder: public>>=
  public :: builder_t
<<Builder: types>>=
  type, abstract :: builder_t
     private
   contains
   <<Builder: builder: TBP>>
  end type builder_t
   
@ %def builder_t
@ 
Finalizer:
<<Builder: builder: TBP>>=
  procedure(builder_final), deferred :: final
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_final (builder)
       import
       class(builder_t), intent(inout) :: builder
     end subroutine builder_final
  end interface

@ %def builder_final
@
Output:
<<Builder: builder: TBP>>=
  procedure(builder_write), deferred :: write
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_write (builder, unit)
       import
       class(builder_t), intent(in) :: builder
       integer, intent(in), optional :: unit
     end subroutine builder_write
  end interface

@ %def builder_write
@
\subsection{Decoding}
Decode the current object and advance to the next.  If there is no object
left, return [[.false.]]
<<Builder: builder: TBP>>=
  procedure(builder_decode), deferred :: decode
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_decode (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(out) :: code
       logical, intent(out) :: success
     end subroutine builder_decode
  end interface

@ %def builder_decode
@
\subsection{Building}
Take the current code and build a new object in the current location, then
advance.
<<Builder: builder: TBP>>=
  procedure(builder_build), deferred :: build
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_build (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(in) :: code
       logical, intent(out) :: success
     end subroutine builder_build
  end interface
    
@ %def builder_build
@
\subsection{Conversion}
Using bytecode as common language, we can directly copy/convert between two
builders.
<<Builder: builder: TBP>>=
  procedure :: copy => builder_copy
<<Builder: procedures>>=
  subroutine builder_copy (builder, builder_source, success)
    class(builder_t), intent(inout) :: builder
    class(builder_t), intent(inout) :: builder_source
    logical, intent(out) :: success
    type(code_t) :: code
    call builder_source%decode (code, success)
    if (.not. success)  return
    call builder%build (code, success)
  end subroutine builder_copy
    
@ %def builder_copy
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic objects}
This module implements the components of the actual object tree as a Sindarin
implementation.  We define
\begin{itemize}
\item
  Basic objects, abstract and completely generic
\item
  Tags as a trivial implementation
\item
  Abstract value objects
\item
  ID objects that allow object identification by name
\item
  Generic wrapper objects (for heterogeneous object arrays)
\item
  References to remote objects
\item
  Composite objects as the base for all more complex structures
\item
  Object repository that enable prototype handling
\item
  Object iterators for traversing an object tree structure
\end{itemize}
<<[[object_base.f90]]>>=
<<File header>>

module object_base

<<Use strings>>

  use format_utils
  use io_units
  use diagnostics
  use codes

<<Standard module head>>

<<Object base: public>>

<<Object base: parameters>>

<<Object base: types>>

<<Object base: interfaces>>

contains

<<Object base: procedures>>

end module object_base
@ %def object_base
@
\subsection{Basic objects (abstract)}
Each object may be referred by other objects, either as a prototype or as a
value.  To keep track, we count the number of instances.  Since the object
itself also counts as an instance, we start with 1, which may be incremented
later.  Conversely, an object is finally deallocated if its instance
count becomes zero.

Any object that is part of a composite will have a context.  

A basic object has a [[defined]] status.  If defined, the value is
known and can be queried.  If undefined, the object signature is
determined but the value is unknown.  If there
is no value, we understand that the object is always defined.

For generic objects, that will be extensions of the abstract type, we
distinguish:
\begin{description}
\item[core]:  The value held by a composite object, target of a reference
\item[mantle]:  Any additional members, and any primer statements that
  initialize the object
\tiem[shell]:  Name and properties of the object.
\end{description}
<<Object base: public>>=
  public :: object_t
<<Object base: types>>=
  type, abstract :: object_t
     private
     class(wrapper_t), pointer :: context => null ()
     integer :: refcount = 1
   contains
   <<Object base: object: TBP>>
  end type object_t
  
@ %def object_t
@
\subsubsection{Finalizer and destructor}
The finalizer should not be called explicitly.  Instead, when an
object is ready for deletion, we should call this method, which calls
the specific finalizer, takes care of any prototype, and checks for
any extra instances before deallocating.

This procedure can't be type-bound.
<<Object base: public>>=
  public :: remove_object
<<Object base: procedures>>=
  recursive subroutine remove_object (object)
    class(object_t), intent(inout), pointer :: object
    if (associated (object)) then
       object%refcount = object%refcount - 1
       if (object%refcount == 0) then
          call object%final ()
          deallocate (object)
       else
          object => null ()
       end if
    end if
  end subroutine remove_object
  
@ %def remove_object
@ There must be a specific finalizer.  The finalizer might be empty,
but this method must be implemented.
<<Object base: object: TBP>>=
  procedure (object_final), deferred :: final
<<Object base: interfaces>>=
  abstract interface
     subroutine object_final (object)
       import
       class(object_t), intent(inout) :: object
     end subroutine object_final
  end interface
       
@ %def object_final
@ 
\subsubsection{Output}
Any object must have a [[write]] method, so we can print a
representation on screen.  The output format depends on the context.

The default [[write]] prints a verbose representation of the object, an
extended version of the declaration form.  All properties and members are
displayed.  Arrays of reference objects (wrappers) are shown explicitly.
If the object has a value, the value is also displayed.  The
[[refcount]] option displays the reference count, following the property
string.

[[write_as_declaration]] prints a concise version of the signature, and
suppresses wrapper objects.  The value is displayed.  Primer statements are
displayed in statement form, following the member declarations.

[[write_as_statement]] prints the object in statement form, if it is a
statement.  Other objects are written in declaration form.

[[write_as_expression]] prints the object as if it occurs inside an
expression.  For a data object, this would print the value, while for an
expression object, the expression (recursively).  Member objects are shown
after the expression, but arguments are not shown as members.  Primer
statements are suppressed.  This format also needs information about the
context, expressed by the [[priority]] argument.

[[write_as_value]] just prints the current value, regardless whether this is a
data object or an expression.
<<Object base: object: TBP>>=
  procedure :: write => object_write
  procedure :: write_as_declaration => object_write_as_declaration
  procedure :: write_as_statement => object_write_as_statement
  procedure :: write_as_expression => object_write_as_expression
  procedure :: write_as_value => object_write_as_value
<<Object base: procedures>>=
  recursive subroutine object_write &
       (object, unit, indent, refcount, core, mantle)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    logical, intent(in), optional :: core
    logical, intent(in), optional :: mantle
    logical :: ref, cor, man
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    ref = .false.;  if (present (refcount))  ref = refcount
    cor = .true.;  if (present (core))  cor = core
    man = .true.;  if (present (mantle))  man = mantle
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    write (u, "(1x,'||',A,'||')", advance="no") &
         char (object%get_signature (verbose=.true.))
    if (ref) then
       write (u, "(1x,'(',I0,')')", advance="no")  object%get_refcount ()
    end if
    if (man .and. object%has_mantle ()) then
       write (u, "(1x,'{')")
       call object%write_mantle (u, ind+1, ref)
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (cor .and. object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write
  
  recursive subroutine object_write_as_declaration (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    type(string_t) :: signature
    class(object_t), pointer :: member, primer
    integer :: u, ind, n_mem, n_pri, i
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    signature = object%get_signature (verbose = .false.)
    if (signature /= "") then
       write (u, "(1x,'||',A,'||')", advance="no")  char (signature)
    end if
    n_mem = object%get_n_members ()
    n_pri = object%get_n_primers ()
    if (n_mem + n_pri > 0) then
       write (u, "(1x,'{')")
       do i = 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind)
          call member%write_as_declaration (u, ind+1)
       end do
       do i = 1, n_pri
          call object%get_primer_ptr (i, primer)
          call write_indent (u, ind)
          call primer%write_as_statement (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write_as_declaration

  recursive subroutine object_write_as_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%is_statement ()) then
       call object%write_statement (unit, indent)
    else
       call object%write_as_declaration (unit, indent)
    end if
  end subroutine object_write_as_statement
  
  recursive subroutine object_write_as_expression (object, unit, indent, &
       priority)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer, intent(in), optional :: priority
    class(object_t), pointer :: member
    logical :: paren
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    paren = .false.
    if (object%is_expression ()) then
       if (present (priority)) then
          paren = priority >= object%get_priority ()
       end if
       if (paren)  write (u, "('(')", advance="no")
       call object%write_expression (u, indent)
       if (paren)  write (u, "(')')", advance="no")
    else if (object%is_literal ()) then
       if (object%is_defined ()) then
          call object%write_expression (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else if (object%has_value ()) then
       call object%write_core (u, ind)
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_expression
  
  recursive subroutine object_write_as_value (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: member
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (object%is_expression () &
         .or. object%is_literal () .or. object%has_value ()) then
       if (object%is_defined ()) then
          call object%write_value (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_value
  
@ %def object_write
@ %def object_write_as_declaration
@ %def object_write_as_statement
@ %def object_write_as_expression
@ For these specific output functions we provide a default
implementation.   A bare object has the default prototype [[object]] and no
contents, value, or expression.
<<Object base: object: TBP>>=
  procedure :: write_core => object_write_stub
  procedure :: write_mantle => object_write_mantle
  procedure :: write_statement => object_write_statement
  procedure :: write_expression => object_write_stub
  procedure :: write_value => object_write_stub
<<Object base: procedures>>=
  subroutine object_write_stub (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "('<>')", advance="no")
  end subroutine object_write_stub
       
  subroutine object_write_mantle (object, unit, indent, refcount)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
  end subroutine object_write_mantle
  
  subroutine object_write_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
  end subroutine object_write_statement
       
@ %def object_write_core
@ %def object_write_mantle
@ %def object_write_statement
@ %def object_write_expression
@ %def object_write_value
@
\subsubsection{Reference count and context}
Return the reference count explicitly.  This may be used for debugging
output.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: get_refcount => object_get_refcount
<<Object base: procedures>>=
  function object_get_refcount (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = object%refcount
  end function object_get_refcount
  
@ %def object_get_refcount
@
Set the context pointer.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: set_context => object_set_context
<<Object base: procedures>>=
  subroutine object_set_context (object, context)
    class(object_t), intent(inout) :: object
    class(wrapper_t), intent(in), target :: context
    object%context => context
  end subroutine object_set_context
  
@ %def object_set_context
@
\subsubsection{Queries}
Access the object's name.  The name may be just the type (for atomic
objects) or a variable name (for composites).
<<Object base: object: TBP>>=
  procedure (object_get_name), deferred :: get_name
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_name (object) result (name)
       import
       class(object_t), intent(in) :: object
       type(string_t) :: name
     end function object_get_name
  end interface
  
@ %def object_get_name
@ Return the object's prototype as a string.  The default prototype is `object'.
<<Object base: object: TBP>>=
  procedure :: get_prototype => object_get_prototype
<<Object base: procedures>>=
  function object_get_prototype (object) result (prototype)
    class(object_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "object"
  end function object_get_prototype
  
@ %def object_get_prototype
@ Return the object's signature as a string.  If [[verbose]] is set (default),
we need a complete account of all properties, otherwise a short version.
<<Object base: object: TBP>>=
  procedure (object_get_signature), deferred :: get_signature
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_signature (object, verbose) result (signature)
       import
       class(object_t), intent(in) :: object
       logical, intent(in), optional :: verbose
       type(string_t) :: signature
     end function object_get_signature
  end interface
  
@ %def object_get_signature
@ Return the object priority.  This is relevant only for expressions and
operators.
<<Object base: object: TBP>>=
  procedure :: get_priority => object_get_priority
<<Object base: procedures>>=
  pure function object_get_priority (object) result (priority)
    class(object_t), intent(in) :: object
    integer :: priority
    priority = 0
  end function object_get_priority
  
@ %def object_get_priority
@ Check if this is a reference object.
<<Object base: object: TBP>>=
  procedure :: is_reference => object_is_reference
<<Object base: procedures>>=
  pure function object_is_reference (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_reference
  
@ %def object_is_reference
@ Identify statements and expressions (functions).
<<Object base: object: TBP>>=
  procedure :: is_statement => object_is_statement
  procedure :: is_expression => object_is_expression
<<Object base: procedures>>=
  pure function object_is_statement (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_statement
  
  pure function object_is_expression (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_expression
  
@ %def object_is_statement
@ %def object_is_expression
@ This query tells whether the object contains an ID subobject.
<<Object base: object: TBP>>=
  procedure :: has_id => object_has_id
<<Object base: procedures>>=
  pure function object_has_id (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_id
  
@ %def object_has_id
@ Return the pointer to the ID subobject, if any.
<<Object base: object: TBP>>=
  procedure :: get_id_ptr => object_get_id_ptr
<<Object base: procedures>>=
  subroutine object_get_id_ptr (object, id)
    class(object_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => null ()
  end subroutine object_get_id_ptr
  
@ %def object_get_id_ptr
@ This query tells whether the object is a wrapper which holds a core object.
The [[has_value]] variant is true if the core represents a value, or a
definable variable.  The [[is_literal]] is true if the object itself is a
literal value, represented by one of the possible literal-value types.
Finally, the [[has_literal]] query returns true for a composite where the
value is of literal type.
<<Object base: object: TBP>>=
  procedure :: has_value => object_has_value
  procedure :: is_literal => object_is_literal
  procedure :: has_literal => object_has_literal
<<Object base: procedures>>=
  pure function object_has_value (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_value
  
  pure function object_is_literal (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_literal
  
  pure function object_has_literal (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_literal
  
@ %def object_has_value
@ %def object_is_literal
@ %def object_has_literal
@ Analogously, for the `mantle' (members, arguments, primer).
<<Object base: object: TBP>>=
  procedure :: has_mantle => object_has_mantle
<<Object base: procedures>>=
  pure function object_has_mantle (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_mantle
  
@ %def object_has_mantle
@ Return number of mantle components.  A default object has none.
<<Object base: object: TBP>>=
  procedure :: get_n_members => object_get_n_members
  procedure :: get_n_arguments => object_get_n_arguments
  procedure :: get_n_primers => object_get_n_primers
<<Object base: procedures>>=
  pure function object_get_n_members (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_members
  
  pure function object_get_n_arguments (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_arguments
  
  pure function object_get_n_primers (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_primers
  
@ %def object_get_n_members
@ %def object_get_n_arguments
@ %def object_get_n_primers
@ Return pointers to mantle component.  Default: null.
<<Object base: object: TBP>>=
  procedure :: get_member_ptr => object_get_member_ptr
  procedure :: get_primer_ptr => object_get_primer_ptr
<<Object base: procedures>>=
  subroutine object_get_member_ptr (object, i, member)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    member => null ()
  end subroutine object_get_member_ptr
  
  subroutine object_get_primer_ptr (object, i, primer)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    primer => null ()
  end subroutine object_get_primer_ptr
  
@ %def object_get_member_ptr
@ %def object_get_primer_ptr
@ Return the definition status.  An object is defined if it has a value and
the value is defined.  Generic objects are undefined.
<<Object base: object: TBP>>=
  procedure :: is_defined => object_is_defined
<<Object base: procedures>>=
  pure function object_is_defined (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_defined
  
@ %def object_is_defined
@
\subsubsection{Constructors}
Since we are basing the object structure on prototyping, each object
must provide an [[instantiate]] method.  As a rule, the instance
inherits the properties of the prototype with the exception of the
value (core value and member values).  In particular, the copy should
be of the same actual type as the prototype.

We require a pointer implementation for allocating objects, at this
point.  This allows us to freely use pointers without caring too much
about [[target]] attributes.
<<Object base: object: TBP>>=
  procedure (object_instantiate), deferred :: instantiate
<<Object base: interfaces>>=
  abstract interface
     subroutine object_instantiate (object, instance)
       import
       class(object_t), intent(inout), target :: object
       class(object_t), intent(out), pointer :: instance
     end subroutine object_instantiate
  end interface
       
@ %def object_instantiate
@
This is applicable to statements and expressions: resolve any references by
name or position into actual pointers, so evaluation can proceed.  For a bare
object, nothing needs to be resolved.
<<Object base: object: TBP>>=
  procedure :: resolve => object_resolve
<<Object base: procedures>>=
  subroutine object_resolve (object, success)
    class(object_t), intent(inout), target :: object
    logical, intent(out) :: success
    success = .true.
  end subroutine object_resolve
  
@ %def object_resolve
@
With all paths resolved, we can evaluate.  No-op for all objects that aren't
statements or expressions, or contain such objects as members.
<<Object base: object: TBP>>=
  procedure :: evaluate => object_evaluate
<<Object base: procedures>>=
  subroutine object_evaluate (object)
    class(object_t), intent(inout), target :: object
  end subroutine object_evaluate
  
@ %def object_evaluate
@
\subsubsection{Code}
Each object has a representation in terms of elementary values, which can be
used for object construction and data transfer.

The code includes the object's value (if any), which might be a large object.
To allow for passing a pointer, we require a [[target]] attribute.

Determining the code may require a repository lookup, so we need the extra
argument.
<<Object base: object: TBP>>=
  procedure (object_get_code), deferred :: get_code
<<Object base: interfaces>>=
  abstract interface
     function object_get_code (object, repository) result (code)
       import
       class(object_t), intent(in), target :: object
       type(repository_t), intent(in), optional :: repository
       type(code_t) :: code
     end function object_get_code
  end interface
  
@ %def object_get_code
@
Build the object from its code.  This is the inverse method to
[[object_get_code]] above, and to [[remove_object]].

Composite objects are built using a prototype in the repository.  Since the
prototype includes the core, we do not need to build value objects.
<<Object base: public>>=
  public :: build_object
<<Object base: procedures>>=
  subroutine build_object (object, code, repository)
    class(object_t), intent(out), pointer :: object
    type(code_t), intent(in) :: code
    type(repository_t), intent(in) :: repository
    integer :: prototype_index, mode
    select case (code%get_cat ())
    case (CAT_COMPOSITE)
       prototype_index = code%get_att (1)
       if (prototype_index > 0) then
          call repository%spawn (prototype_index, object)
       else
          allocate (composite_t :: object)
       end if
       select type (object)
       class is (composite_t)
          call object%init_from_code (code)
       end select
    case (CAT_ID)
       allocate (id_t :: object)
       select type (object)
       type is (id_t)
          call object%init_from_code (code)
       end select
    case (CAT_REFERENCE)
       allocate (reference_t :: object)
    case (CAT_REF_ARRAY)
       allocate (ref_array_t :: object)
    case default
       object => null ()
    end select
  end subroutine build_object
  
@ %def build_object
@
\subsubsection{Iterator Support}
Iterate.  This procedure returns the next object in a given order, for
iteration over the object tree.  If there is a [[insert_object]] argument,
this object is inserted before returning it as the next object.

This implementation: the bare object has nothing that follows it, and the
inserted object is ignored.
<<Object base: object: TBP>>=
  procedure :: next_position => object_next_position
<<Object base: procedures>>=
  subroutine object_next_position (object, position, next_object, import_object)
    class(object_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    position%part = POS_NONE
    if (present (next_object))  next_object => null ()
  end subroutine object_next_position
  
@ %def object_next_position
@
\subsubsection{Tools}
Create a reference object.  The core is the previous object (via pointer).
We therefore can implement the method directly.
<<Object base: object: TBP>>=
  procedure :: make_reference => object_make_reference
<<Object base: procedures>>=
  subroutine object_make_reference (object, reference)
    class(object_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: reference
    allocate (reference_t :: reference)
    select type (reference)
    type is (reference_t)
       call reference%link_core (object)
    end select
  end subroutine object_make_reference
  
@ %def object_make_reference
@
Dereference: if this is not a reference, return the pointer to the object
itself.
<<Object base: object: TBP>>=
  procedure :: dereference => object_dereference
<<Object base: procedures>>=
  recursive function object_dereference (object) result (remote)
    class(object_t), intent(in), target :: object
    class(object_t), pointer :: remote
    remote => object
  end function object_dereference

@ %def object_dereference
@ Find an object within the object's contents: no result for a default
object.
<<Object base: object: TBP>>=
  procedure :: find => object_find
<<Object base: procedures>>=
  recursive subroutine object_find (object, path, member)
    class(object_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    member => null ()
  end subroutine object_find
    
@ %def object_find
@ This is invalid for all objects except assignment, where it fills the stack
of matching items that will be assigned.
<<Object base: object: TBP>>=
  procedure :: push => object_push
<<Object base: procedures>>=
  subroutine object_push (object, lhs, rhs)
    class(object_t), intent(inout) :: object
    class(value_t), intent(in), pointer :: lhs, rhs
    call msg_bug ("Object: push method invalid in this context")
  end subroutine object_push
  
@ %def object_push
@ Match an object [[source]] against a pattern object [[ref]], iteratively and
recursively.  Return [[success]].  If also [[master]] is provided, call its
[[push]] method for any matching item pair.

We use a pair of iterators, one for the lhs and one for the rhs.  We iterate
over the lhs and track the moves of the iterator.  Whenever we go to a core,
we go to the core of the rhs and match the values, if any.  For a successful
match, the lhs and rhs value pointer pair is pushed onto the assignment item
stack.  When we go to a member, we check if we actually can assign it.  If
yes, we take its name and find the corresponding member on the rhs.  The
member indices need not coincide, then we navigate to the member core(s).
Finally, when the current lhs object is exhausted, we also skip the current
rhs object.

Also, the match fails if any [[lhs]] object has mode ABSTRACT.

TODO: distinguish VARIABLE/CONSTANT

TODO: assignment for primer statements.

Any mismatch immediately aborts the matching procedure.
<<Object base: object: TBP>>=
  procedure :: match => object_match
<<Object base: procedures>>=
  recursive subroutine object_match (ref, source, success, master)
    class(object_t), intent(in), target :: ref
    class(object_t), intent(in), target :: source
    logical, intent(out) :: success
    class(object_t), intent(inout), optional :: master
    type(object_iterator_t) :: it_lhs, it_rhs
    class(object_t), pointer :: lhs, rhs, rhs_context
    class(value_t), pointer :: lval, rval
    type(position_t) :: position
    integer :: part, i
    logical :: mutable, required
    lhs => ref
    rhs => source
    call it_lhs%init (lhs)
    call it_rhs%init (rhs)
    ITERATE: do while (it_lhs%is_valid ())
       call it_lhs%get_next_position (position)
       select case (position%part)
       case (POS_NONE)
          call it_lhs%to_context (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_context (success);  if (.not. success)  exit ITERATE
       case (POS_ID)
          call it_lhs%to_id (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_id (success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          call it_rhs%get_object (rhs)
          select type (lhs)
             class is (id_t)
             call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
             if (present (master)) then
                select type (rhs)
                class is (id_t)
                   lval => lhs
                   rval => rhs
                   call master%push (lval, rval)
                end select
             end if
          end select
       case (POS_CORE)
          call it_lhs%to_core (success);  if (.not. success)  exit ITERATE
          call it_rhs%to_core (success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          call it_rhs%get_object (rhs)
          select type (lhs)
             class is (value_t)
             call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
             if (present (master)) then
                select type (rhs)
                class is (value_t)
                   lval => lhs
                   rval => rhs
                   call master%push (lval, rval)
                end select
             end if
          end select
       case (POS_MEMBER)
          call it_lhs%to_member &
               (position%i, success);  if (.not. success)  exit ITERATE
          call it_lhs%get_object (lhs)
          select type (lhs)
             class is (composite_t)
             call lhs%check_mode (mutable)
             call lhs%check_role (required)
          end select
          if (mutable .or. required) then
             call it_rhs%get_object (rhs_context)
             select type (rhs_context)
                class is (composite_t)
                call rhs_context%find_member (lhs%get_name (), index=i)
             end select
             if (i > 0) then
                call it_rhs%to_member &
                     (i, success);  if (.not. success)  exit ITERATE
             else if (required) then
                success = .false.;  exit ITERATE
             else
                call it_lhs%to_context &
                     (success);  if (.not. success)  exit ITERATE
             end if
          else
             call it_lhs%to_context &
                  (success);  if (.not. success)  exit ITERATE
          end if
       case default
          call it_lhs%to_context &
               (success);  if (.not. success)  exit ITERATE
       end select
    end do ITERATE
  end subroutine object_match
    
@ %def object_match
@
\subsection{Tag Object Type}
A tag is an atomic object with no content, it just exists.  (As a
variable, it has a name but no value.)  The definition status is
always defined.

Tag objects are checked in matching types against a pattern.  The match fails
if a required tag is not found.

We introduce this here, so we have concrete objects that we can use in
unit tests.  Object types with value are defined elsewhere.
<<Object base: public>>=
  public :: tag_t
<<Object base: types>>=
  type, extends (object_t) :: tag_t
     private
   contains
   <<Object base: tag: TBP>>
  end type tag_t
  
@ %def tag_t
@ 
\subsubsection{Finalizer}
We do not need an initializer, there are no contents or value.

The finalizer is also empty.
<<Object base: tag: TBP>>=
  procedure :: final => tag_final
<<Object base: procedures>>=
  subroutine tag_final (object)
    class(tag_t), intent(inout) :: object
  end subroutine tag_final
 
@ %def tag_final
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[tag]].
<<Object base: tag: TBP>>=
  procedure :: get_name => tag_get_name
<<Object base: procedures>>=
  pure function tag_get_name (object) result (name)
    class(tag_t), intent(in) :: object
    type(string_t) :: name
    name = "tag"
  end function tag_get_name
  
@ %def tag_get_name
@ The full signature of a tag object is [[atom]].
<<Object base: tag: TBP>>=
  procedure :: get_signature => tag_get_signature
<<Object base: procedures>>=
  pure function tag_get_signature (object, verbose) result (signature)
    class(tag_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "atom"
    else
       signature = ""
    end if
  end function tag_get_signature
  
@ %def tag_get_signature
@
\subsubsection{Constructor}
For a new tag instance, nothing needs to be copied.
<<Object base: tag: TBP>>=
  procedure :: instantiate => tag_instantiate
<<Object base: procedures>>=
  subroutine tag_instantiate (object, instance)
    class(tag_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (tag_t :: instance)
  end subroutine tag_instantiate
    
@ %def tag_instantiate
@ Object code.  Only the category is nontrivial.
<<Object base: tag: TBP>>=
  procedure :: get_code => tag_get_code
<<Object base: procedures>>=
  function tag_get_code (object, repository) result (code)
    class(tag_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call code%set (CAT_TAG)
  end function tag_get_code
  
@ %def tag_get_code
@
\subsection{Value object type (abstract)}
The [[value_t]] is the base type of all objects that holds a value.  The
abstract base type includes the [[defined]] property for the value.
<<Object base: public>>=
  public :: value_t
<<Object base: types>>=
  type, extends (object_t), abstract :: value_t
     private
     logical :: defined = .false.
   contains
   <<Object base: value: TBP>>
  end type value_t
  
@ %def value_t
@
\subsubsection{Queries}
The signature of value objects is [[value]].
<<Object base: value: TBP>>=
  procedure :: get_signature => value_get_signature
<<Object base: procedures>>=
  pure function value_get_signature (object, verbose) result (signature)
    class(value_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "value"
    else
       signature = ""
    end if
  end function value_get_signature
  
@ %def value_get_signature
@ All extensions of [[value_t]] represent literal values.
<<Object base: value: TBP>>=
  procedure :: is_literal => value_is_literal
<<Object base: procedures>>=
  pure function value_is_literal (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function value_is_literal
  
@ %def value_is_literal
@
This overrides a base-type method.  The value may be defined or undefined.
<<Object base: value: TBP>>=
  procedure :: is_defined => value_is_defined
<<Object base: procedures>>=
  pure function value_is_defined (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = object%defined
  end function value_is_defined
  
@ %def value_is_defined
@
\subsubsection{Setting Content}
Initialize the value from a code object.
<<Object base: value: TBP>>=
  procedure(value_init_from_code), deferred :: init_from_code
<<Object base: interfaces>>=
  abstract interface
     subroutine value_init_from_code (object, code)
       import
       class(value_t), intent(out) :: object
       type(code_t), intent(in) :: code
     end subroutine value_init_from_code
  end interface

@ %def value_init_from_code
@ Set the definition status.
<<Object base: value: TBP>>=
  procedure :: set_defined => value_set_defined
<<Object base: procedures>>=
  pure subroutine value_set_defined (object, defined)
    class(value_t), intent(inout) :: object
    logical, intent(in) :: defined
    object%defined = defined
  end subroutine value_set_defined
  
@ %def value_set_defined
@
\subsubsection{Tools}
Assign value: there should be an allowed possibility for any value object.
The actual variants depend on the concrete type combination.  Before we call
the actual assignment, we should call the [[match]] method which checks
whether the assignment is allowed.
<<Object base: value: TBP>>=
  procedure :: match => value_match
  procedure :: assign => value_assign
<<Object base: procedures>>=
  subroutine value_match (ref, source, success, master)
    class(value_t), intent(in), target :: ref
    class(object_t), intent(in), target :: source
    logical, intent(out) :: success
    class(object_t), intent(inout), optional :: master
    select type (source)
    class is (value_t)
       call ref%match_value (source, success)
    class default
       success = .false.
    end select
  end subroutine value_match
       
  subroutine value_assign (object, source)
    class(value_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    call object%final ()
    object%defined = source%defined
    if (source%defined)  call object%assign_value (source)
  end subroutine value_assign
       
@ %def value_match
@ %def value_assign
@ This must be implemented specifically.
<<Object base: value: TBP>>=
  procedure (value_match_value), deferred :: match_value
  procedure (value_assign_value), deferred :: assign_value
<<Object base: interfaces>>=
  abstract interface
     subroutine value_match_value (object, source, success)
       import
       class(value_t), intent(in) :: object
       class(value_t), intent(in) :: source
       logical, intent(out) :: success
     end subroutine value_match_value
  end interface
  
  abstract interface
     subroutine value_assign_value (object, source)
       import
       class(value_t), intent(inout) :: object
       class(value_t), intent(in) :: source
     end subroutine value_assign_value
  end interface
  
@ %def value_match_value
@ %def value_assign_value
@
\subsection{ID Object}
We define the [[id_t]] type that holds the ID of an object (the name / path to
an object) and can be used for searching and navigating.  The ID object is the
first implementation of the abstract value type.
<<Object base: public>>=
  public :: id_t
<<Object base: types>>=
  type, extends (value_t) :: id_t
     private
     type(string_t), dimension(:), allocatable :: path
   contains
   <<Object base: id: TBP>>
  end type id_t
  
@ %def id_t
@
\subsubsection{Finalizer}
Delete the path.
<<Object base: id: TBP>>=
  procedure :: final => id_final
<<Object base: procedures>>=
  subroutine id_final (object)
    class(id_t), intent(inout) :: object
    if (allocated (object%path))  deallocate (object%path)
    call object%set_defined (.false.)
  end subroutine id_final
  
@ %def id_final
@
\subsubsection{Output}
Expression form: write a representation of the ID string array as the ID
object value.
<<Object base: id: TBP>>=
  procedure :: write_expression => id_write_expression
<<Object base: procedures>>=
  subroutine id_write_expression (object, unit, indent)
    class(id_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, i
    u = given_output_unit (unit)
    if (allocated (object%path)) then
       write (u, "(A)", advance="no")  char (object%get_path_string ())
    else
       write (u, "(A)", advance="no")  "<id>"
    end if
  end subroutine id_write_expression
       
@ %def id_write_expression
@
\subsubsection{Queries}
The name is [[id]]
<<Object base: id: TBP>>=
  procedure :: get_name => id_get_name
<<Object base: procedures>>=
  pure function id_get_name (object) result (name)
    class(id_t), intent(in) :: object
    type(string_t) :: name
    name = "id"
  end function id_get_name

@ %def id_get_name  
@ Return the path, either as a string array or as a string, concatenated by
dots.
<<Object base: id: TBP>>=
  procedure :: get_path => id_get_path
  procedure :: get_path_string => id_get_path_string
<<Object base: procedures>>=
  pure function id_get_path (object) result (path)
    class(id_t), intent(in) :: object
    type(string_t), dimension(:), allocatable :: path
    if (allocated (object%path)) then
       allocate (path (size (object%path)))
       path = object%path
    end if
  end function id_get_path
  
  pure function id_get_path_string (object) result (path)
    class(id_t), intent(in) :: object
    type(string_t) :: path
    integer :: i
    path = ""
    if (allocated (object%path)) then
       do i = 1, size (object%path)
          if (i == 1) then
             path = object%path(i)
          else
             path = path // "." // object%path(i)
          end if
       end do
    end if
  end function id_get_path_string
  
@ %def id_get_path
@ %def id_get_path_string
@
\subsubsection{Construction and initialization}
Instantiate: likely unused.
<<Object base: id: TBP>>=
  procedure :: instantiate => id_instantiate
<<Object base: procedures>>=
  subroutine id_instantiate (object, instance)
    class(id_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (id_t :: instance)
  end subroutine id_instantiate

@ %def id_instantiate
@ The ID object carries a string-array value.
<<Object base: id: TBP>>=
  procedure :: get_code => id_get_code
<<Object base: procedures>>=
  function id_get_code (object, repository) result (code)
    class(id_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    integer :: i
    call code%set (CAT_ID)
    if (allocated (object%path)) then
       call code%create_string_val (object%path)
    end if
  end function id_get_code
  
@ %def id_get_code
@ Initialize from a code object, which includes the path.
<<Object base: id: TBP>>=
  procedure :: init_from_code => id_init_from_code
<<Object base: procedures>>=
  subroutine id_init_from_code (object, code)
    class(id_t), intent(out) :: object
    type(code_t), intent(in) :: code
    logical :: success
    call code%get_string_array (object%path, success)
    call object%set_defined (success)
  end subroutine id_init_from_code
    
@ %def id_init_from_code
@ Initialize with a path, specified as a string array.
<<Object base: id: TBP>>=
  procedure :: init => id_init_path
<<Object base: procedures>>=
  subroutine id_init_path (object, path)
    class(id_t), intent(out) :: object
    type(string_t), dimension(:), intent(in) :: path
    allocate (object%path (size (path)))
    object%path = path
    call object%set_defined (.true.)
  end subroutine id_init_path
    
@ %def id_init_path
@
\subsubsection{Tools}
Must be implemented due to the [[value_t]] base type: match/copy the path
value.
<<Object base: id: TBP>>=
  procedure :: match_value => id_match_value
  procedure :: assign_value => id_assign_value
<<Object base: procedures>>=
  subroutine id_match_value (object, source, success)
    class(id_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (id_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine id_match_value
       
  subroutine id_assign_value (object, source)
    class(id_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (id_t)
       call object%init (source%path)
    end select
  end subroutine id_assign_value
       
@ %def id_match_value
@ %def id_assign_value
@
\subsection{Wrapper}
A wrapper is an object that can hold another object, its [[core]].  This base
type allows us to define composite objects and references.  As a stand-alone
type, it enables arrays of heterogeneous concrete type.

All method calls are delegated to the core.
<<Object base: public>>=
  public :: wrapper_t
<<Object base: types>>=
  type, extends (object_t) :: wrapper_t
     private
     class(object_t), pointer :: core => null ()
   contains
   <<Object base: wrapper: TBP>>
  end type wrapper_t
  
@ %def wrapper_t
@ 
\subsubsection{Finalizer}
The finalizer should remove and deallocate the core object.
<<Object base: wrapper: TBP>>=
  procedure :: final => wrapper_final
<<Object base: procedures>>=
  recursive subroutine wrapper_final (object)
    class(wrapper_t), intent(inout) :: object
    if (associated (object%core)) then
       call object%core%final ()
       call remove_object (object%core)
    end if
  end subroutine wrapper_final
  
@ %def wrapper_final
@
\subsubsection{Output}
 Write the wrapper core.  Assuming this represents a value, we write in
expression form.
<<Object base: wrapper: TBP>>=
  procedure :: write_core => wrapper_write_core
<<Object base: procedures>>=
  recursive subroutine wrapper_write_core (object, unit, indent)
    class(wrapper_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%core%write_as_expression (unit, indent)
  end subroutine wrapper_write_core
       
@ %def wrapper_write_core  
@
\subsubsection{Queries}
Delegate name and signature as appropriate.
<<Object base: wrapper: TBP>>=
  procedure :: get_name => wrapper_get_name
<<Object base: procedures>>=
  pure recursive function wrapper_get_name (object) result (name)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: name
    if (associated (object%core)) then
       name = object%core%get_name ()
    else
       name = "<???>"
    end if
  end function wrapper_get_name
  
@ %def wrapper_get_name
@ Delegate the prototype.
<<Object base: wrapper: TBP>>=
  procedure :: get_prototype => wrapper_get_prototype
<<Object base: procedures>>=
  recursive function wrapper_get_prototype (object) result (prototype)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%core)) then
       prototype = object%core%get_prototype ()
    else
       prototype = object_get_prototype (object)
    end if
  end function wrapper_get_prototype
  
@ %def wrapper_get_prototype
@ The signature is a plain [[wrapper]] string.
<<Object base: wrapper: TBP>>=
  procedure :: get_signature => wrapper_get_signature
<<Object base: procedures>>=
  pure function wrapper_get_signature (object, verbose) result (signature)
    class(wrapper_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = "wrapper"
  end function wrapper_get_signature
  
@ %def wrapper_get_signature
@ The [[is_reference]], [[has_value]], [[is_defined]] and [[is_statement]]
queries are delegated.
<<Object base: wrapper: TBP>>=
  procedure :: is_reference => wrapper_is_reference
  procedure :: is_statement => wrapper_is_statement
  procedure :: is_expression => wrapper_is_expression
  procedure :: is_defined => wrapper_is_defined
<<Object base: procedures>>=
  pure recursive function wrapper_is_reference (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_reference ()
    else
       flag = .false.
    end if
  end function wrapper_is_reference
  
  pure recursive function wrapper_is_statement (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_statement ()
    else
       flag = .false.
    end if
  end function wrapper_is_statement
  
  pure recursive function wrapper_is_expression (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_expression ()
    else
       flag = .false.
    end if
  end function wrapper_is_expression
  
  pure recursive function wrapper_is_defined (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function wrapper_is_defined
  
@ %def wrapper_is_reference
@ %def wrapper_is_statement
@ %def wrapper_is_expression
@ %def wrapper_is_defined
@ Return pointer to the core.
<<Object base: wrapper: TBP>>=
  procedure :: get_core_ptr => wrapper_get_core_ptr
<<Object base: procedures>>=
  subroutine wrapper_get_core_ptr (object, core)
    class(wrapper_t), intent(in) :: object
    class(object_t), intent(out), pointer :: core
    if (associated (object%core)) then
       core => object%core%dereference ()
    else
       core => null ()
    end if
  end subroutine wrapper_get_core_ptr
  
@ %def wrapper_get_core_ptr
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.  It should not be called for
a pure wrapper, however.
<<Object base: wrapper: TBP>>=
  procedure :: instantiate => wrapper_instantiate
<<Object base: procedures>>=
  recursive subroutine wrapper_instantiate (object, instance)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (wrapper_t :: instance)
  end subroutine wrapper_instantiate
    
@ %def wrapper_instantiate
@ Import an object as the new core.
<<Object base: wrapper: TBP>>=
  procedure, non_overridable :: import_core => wrapper_import_core
<<Object base: procedures>>=
  subroutine wrapper_import_core (object, core)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(inout), pointer :: core
    if (associated (object%core))  call remove_object (object%core)
    call core%set_context (object)
    object%core => core
    core => null ()
  end subroutine wrapper_import_core
    
@ %def wrapper_import_core
@ A wrapper should not appear explicitly in code, so return zero here.
<<Object base: wrapper: TBP>>=
  procedure :: get_code => wrapper_get_code
<<Object base: procedures>>=
  function wrapper_get_code (object, repository) result (code)
    class(wrapper_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call code%set (0)
  end function wrapper_get_code
  
@ %def wrapper_get_code
@
\subsubsection{Iterator Support}
Iterate: next is core, then context.  The import object, if present, is
inserted as the core before proceeding.
<<Object base: wrapper: TBP>>=
  procedure :: next_position => wrapper_next_position
<<Object base: procedures>>=
  subroutine wrapper_next_position &
       (object, position, next_object, import_object)
    class(wrapper_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    if (object%is_statement ()) then
       call object_next_position (object, position, next_object)
    else       
       select case (position%part)
       case (POS_CORE)
          call object_next_position (object, position, next_object)
       case default
          if (present (import_object)) then
             call object%import_core (import_object)
          end if
          if (associated (object%core)) then
             position%part = POS_CORE
             if (present (next_object))  next_object => object%core
          else
             call object_next_position (object, position, next_object)
          end if
       end select
    end if
  end subroutine wrapper_next_position
  
@ %def wrapper_next_position
@
\subsubsection{Tools}
Find: refer to the context object.
<<Object base: wrapper: TBP>>=
  procedure :: find => wrapper_find
<<Object base: procedures>>=
  recursive subroutine wrapper_find (object, path, member)
    class(wrapper_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: context
    member => null ()
    if (size (path) > 0) then
       if (associated (object%context)) then
          context => object%context
          call context%find (path, member)
       end if
    end if
  end subroutine wrapper_find
    
@ %def wrapper_find
@
\subsection{Object references}
This extension of a wrapper behaves as a pointer to the core object.  We have
to assume that the target object of that core has been allocated remotely, and
should not be deallocated from here.

The target is identified via the [[id]] component.  Initially, the core object
is unassigned.  To resolve a reference, we search for the referenced object
and link it to the core.

TODO: For references as user-level objects, we would need a prototype matching
feature.  The current implementation does not type-check.
<<Object base: public>>=
  public :: reference_t
<<Object base: types>>=
  type, extends (wrapper_t) :: reference_t
     private
     class(object_t), pointer :: id => null ()
   contains
   <<Object base: reference: TBP>>
  end type reference_t
  
@ %def reference_t
@
\subsubsection{Finalizer}
The finalizer should not finalize the core.  However, it should call
[[remove_object]] as this takes care of reference counts.
<<Object base: reference: TBP>>=
  procedure :: final => reference_final
<<Object base: procedures>>=
  recursive subroutine reference_final (object)
    class(reference_t), intent(inout) :: object
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    if (associated (object%core)) then
       call remove_object (object%core)
    end if
  end subroutine reference_final
  
@ %def reference_final
@
\subsubsection{Output}
The output procedures are delegated to the core as appropriate.
<<Object base: reference: TBP>>=
  procedure :: write_statement => reference_write_statement
  procedure :: write_expression => reference_write_expression
<<Object base: procedures>>=
  recursive subroutine reference_write_statement (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_statement (unit, indent)
       else
          write (u, "('<REF>')", advance="no")
       end if
    else if (associated (object%core)) then
       call object%core%write_statement (unit, indent)
    end if
  end subroutine reference_write_statement
       
  recursive subroutine reference_write_expression (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, indent)
       else
          write (u, "('<REF>')", advance="no")
       end if
    else if (associated (object%core)) then
       call object%core%write_expression (unit, indent)
    end if
  end subroutine reference_write_expression
       
@ %def reference_write_statement
@ %def reference_write_expression
@
\subsubsection{Queries}
The name should really be the ID.
<<Object base: reference: TBP>>=
  procedure :: get_name => reference_get_name
<<Object base: procedures>>=
  pure recursive function reference_get_name (object) result (name)
    class(reference_t), intent(in) :: object
    type(string_t) :: name
    if (associated (object%id)) then
       select type (id => object%id)
       class is (id_t)
          name = id%get_path_string ()
       end select
    else if (associated (object%core)) then
       name = object%core%get_name ()
    else
       name = "<???>"
    end if
  end function reference_get_name
  
@ %def reference_get_name
@ The signature includes a [[reference]] string.
<<Object base: reference: TBP>>=
  procedure :: get_signature => reference_get_signature
<<Object base: procedures>>=
  pure recursive function reference_get_signature (object, verbose) &
       result (signature)
    class(reference_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    if (associated (object%core)) then
       signature = object%core%get_signature ()
       if (signature /= "") then
          signature = "reference|" // signature
       else
          signature = "reference"
       end if
    else
       signature = "reference"
    end if
  end function reference_get_signature
  
@ %def reference_get_signature
@ A reference is a reference.
<<Object base: reference: TBP>>=
  procedure :: is_reference => reference_is_reference
<<Object base: procedures>>=
  pure function reference_is_reference (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function reference_is_reference
  
@ %def reference_is_reference
@ A reference is associated if there is a core object.
<<Object base: reference: TBP>>=
  procedure :: is_associated => reference_is_associated
<<Object base: procedures>>=
  elemental function reference_is_associated (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = associated (object%core)
  end function reference_is_associated
  
@ %def reference_is_associated
@ This query tells whether the object contains an ID subobject.
<<Object base: reference: TBP>>=
  procedure :: has_id => reference_has_id
<<Object base: procedures>>=
  pure function reference_has_id (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = associated (object%id)
  end function reference_has_id
  
@ %def reference_has_id
@ Return the pointer to the ID subobject, if any.
<<Object base: reference: TBP>>=
  procedure :: get_id_ptr => reference_get_id_ptr
<<Object base: procedures>>=
  subroutine reference_get_id_ptr (object, id)
    class(reference_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => object%id
  end subroutine reference_get_id_ptr
  
@ %def reference_get_id_ptr
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.
<<Object base: reference: TBP>>=
  procedure :: instantiate => reference_instantiate
<<Object base: procedures>>=
  recursive subroutine reference_instantiate (object, instance)
    class(reference_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (reference_t :: instance)
  end subroutine reference_instantiate
    
@ %def reference_instantiate
<<Object base: reference: TBP>>=
  procedure :: set_path => reference_set_path
<<Object base: procedures>>=
  subroutine reference_set_path (object, lhs_path)
    class(reference_t), intent(inout) :: object
    type(string_t), dimension(:), intent(in) :: lhs_path
    allocate (id_t :: object%id)
    select type (id => object%id)
    type is (id_t)
       call id%init (lhs_path)
    end select
  end subroutine reference_set_path
    
@ %def reference_set_path
@ Import an existing ID object.
<<Object base: reference: TBP>>=
  procedure :: import_id => reference_import_id
<<Object base: procedures>>=
  subroutine reference_import_id (object, id)
    class(reference_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: id
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    object%id => id
    id => null ()
  end subroutine reference_import_id
  
@ %def reference_import_id
@ Link the core as a pointer to an existing object, updating the reference
count.
<<Object base: reference: TBP>>=
  procedure :: link_core => reference_link_core
<<Object base: procedures>>=
  subroutine reference_link_core (object, remote)
    class(reference_t), intent(inout) :: object
    class(object_t), intent(inout), target :: remote
    class(object_t), pointer :: remote_target
    call object%final ()
    remote_target => remote%dereference ()
    object%core => remote_target
    remote_target%refcount = remote_target%refcount + 1
  end subroutine reference_link_core
    
@ %def reference_link_core
@ Resolve: Find the object that belongs to the stored ID and link it to the
reference's core.

TODO: match the target type against a prototype.
<<Object base: reference: TBP>>=
  procedure :: resolve => reference_resolve
<<Object base: procedures>>=
  subroutine reference_resolve (object, success)
    class(reference_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: remote
    if (object%has_id ()) then
       select type (id => object%id)
       type is (id_t)
          call object%find (id%get_path (), remote)
       end select
    end if
    success = associated (remote)
    if (success) then
       call object%link_core (remote)
    end if
  end subroutine reference_resolve
    
@ %def reference_resolve
@
\subsubsection{Code}
Code is simple.  The reference will be followed by the target ID.
<<Object base: reference: TBP>>=
  procedure :: get_code => reference_get_code
<<Object base: procedures>>=
  function reference_get_code (object, repository) result (code)
    class(reference_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call code%set (CAT_REFERENCE)
  end function reference_get_code
  
@ %def reference_get_code
@
\subsubsection{Tools}
Dereference.
<<Object base: reference: TBP>>=
  procedure :: dereference => reference_dereference
<<Object base: procedures>>=
  recursive function reference_dereference (object) result (remote)
    class(reference_t), intent(in), target :: object
    class(object_t), pointer :: remote
    if (associated (object%core)) then
       remote => object%core%dereference ()
    else
       remote => object
    end if
  end function reference_dereference

@ %def reference_dereference
@
\subsection{Reference array}
The core of a generic container is a [[ref_array_t]] object, holding nothing
but an array of references.  The references are assigned to the arguments of
the container (as an expression object) when the container object is
resolved.  Since the reference array is a basic category, we define it here.
<<Object base: public>>=
  public :: ref_array_t
<<Object base: types>>=
  type, extends (object_t) :: ref_array_t
     private
     type(reference_t), dimension(:), pointer :: item => null ()
   contains
   <<Object base: ref array: TBP>>
  end type ref_array_t
  
@ %def ref_array_t
@
\subsubsection{Finalizer}
Delete the array.
<<Object base: ref array: TBP>>=
  procedure :: final => ref_array_final
<<Object base: procedures>>=
  recursive subroutine ref_array_final (object)
    class(ref_array_t), intent(inout) :: object
    integer :: i
    if (associated (object%item)) then
       do i = 1, size (object%item)
          call object%item(i)%final ()
       end do
       deallocate (object%item)
    end if
  end subroutine ref_array_final
  
@ %def ref_array_final
@
\subsubsection{Output}
We connect the items by commas and enclose all in brackets.  No distinction
in structure between expression and value forms, but the form is respected for
the items.
<<Object base: ref array: TBP>>=
  procedure :: write_expression => ref_array_write_expression
  procedure :: write_value => ref_array_write_value
<<Object base: procedures>>=
  subroutine ref_array_write_expression (object, unit, indent)
    class(ref_array_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: item
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (object%item)) then
       write (u, "('(')", advance="no")
       do i = 1, size (object%item)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          if (object%item(i)%is_associated ()) then
             call object%item(i)%get_core_ptr (item)
             call item%write_as_expression (u, priority=0)
          else
             write (u, "('<>')", advance="no")
          end if
       end do
       write (u, "(')')", advance="no")
    else
       write (u, "('???')", advance="no")
    end if
  end subroutine ref_array_write_expression
       
  subroutine ref_array_write_value (object, unit, indent)
    class(ref_array_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: item
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (object%item)) then
       write (u, "('(')", advance="no")
       do i = 1, size (object%item)
          if (i > 1)  write (u, "(',',1x)", advance="no")
          if (object%item(i)%is_associated ()) then
             call object%item(i)%get_core_ptr (item)
             call item%write_as_value (u)
          else
             write (u, "('<>')", advance="no")
          end if
       end do
       write (u, "(')')", advance="no")
    else
       write (u, "('???')", advance="no")
    end if
  end subroutine ref_array_write_value
       
@ %def ref_array_write_expression
@ %def ref_array_write_value
@
\subsubsection{Queries}
<<Object base: ref array: TBP>>=
  procedure :: get_name => ref_array_get_name
<<Object base: procedures>>=
  pure function ref_array_get_name (object) result (name)
    class(ref_array_t), intent(in) :: object
    type(string_t) :: name
    name = "<ref array>"
  end function ref_array_get_name
  
@ %def ref_array_get_name
@ Signature is empty.
<<Object base: ref array: TBP>>=
  procedure :: get_signature => ref_array_get_signature
<<Object base: procedures>>=
  pure function ref_array_get_signature (object, verbose) result (signature)
    class(ref_array_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = ""
  end function ref_array_get_signature
  
@ %def ref_array_get_signature
@ This is an expression.  In particular, it should be printed in expression
form.
<<Object base: ref array: TBP>>=
  procedure :: is_expression => ref_array_is_expression
<<Object base: procedures>>=
  pure function ref_array_is_expression (object) result (flag)
    class(ref_array_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function ref_array_is_expression
  
@ %def ref_array_is_expression
@ The reference array is defined if the references are all associated.  We do
not check whether the targets are defined.
<<Object base: ref array: TBP>>=
  procedure :: is_defined => ref_array_is_defined
<<Object base: procedures>>=
  pure function ref_array_is_defined (object) result (flag)
    class(ref_array_t), intent(in) :: object
    logical :: flag
    if (associated (object%item)) then
       flag = all (object%item%is_associated ())
    else
       flag = .false.
    end if
  end function ref_array_is_defined
  
@ %def ref_array_is_defined
@ Dereference, i.e., return the pointer to a specific item.
<<Object base: ref array: TBP>>=
  procedure :: get_item_ptr => ref_array_get_item_ptr
<<Object base: procedures>>=
  subroutine ref_array_get_item_ptr (object, i, item)
    class(ref_array_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), intent(out), pointer :: item
    if (associated (object%item)) then
       call object%item(i)%get_core_ptr (item)
    else
       item => null ()
    end if
  end subroutine ref_array_get_item_ptr
  
@ %def ref_array_get_item_ptr
@
\subsubsection{Constructors}
Instantiate: nothing special.
<<Object base: ref array: TBP>>=
  procedure :: instantiate => ref_array_instantiate
<<Object base: procedures>>=
  subroutine ref_array_instantiate (object, instance)
    class(ref_array_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (ref_array_t :: instance)
  end subroutine ref_array_instantiate
    
@ %def ref_array_instantiate
@ Initialize for a fixed number of items.
<<Object base: ref array: TBP>>=
  procedure :: init => ref_array_init
<<Object base: procedures>>=
  subroutine ref_array_init (object, n_item)
    class(ref_array_t), intent(inout) :: object
    integer, intent(in) :: n_item
    allocate (object%item (n_item))
  end subroutine ref_array_init
  
@ %def ref_array_init
@ Associate a target object to a specific item reference.
<<Object base: ref array: TBP>>=
  procedure :: associate => ref_array_associate
<<Object base: procedures>>=
  subroutine ref_array_associate (object, i, remote)
    class(ref_array_t), intent(inout) :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), target :: remote
    call object%item(i)%link_core (remote)
  end subroutine ref_array_associate
  
@ %def ref_array_associate
@
\subsubsection{Code}
We just store the number of items, so we can initialize the reference array
correctly.
<<Object base: ref array: TBP>>=
  procedure :: get_code => ref_array_get_code
<<Object base: procedures>>=
  function ref_array_get_code (object, repository) result (code)
    class(ref_array_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    if (associated (object%item)) then
       call code%set (CAT_REF_ARRAY, [size (object%item)])
    else
       call code%set (CAT_REF_ARRAY)
    end if
  end function ref_array_get_code
  
@ %def ref_array_get_code
@ Initialize from code: use the specified number of items.
<<Object base: ref array: TBP>>=
  procedure :: init_from_code => ref_array_init_from_code
<<Object base: procedures>>=
  subroutine ref_array_init_from_code (object, code)
    class(ref_array_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    if (code%get_n_att () > 0) then
       call object%init (code%get_att (1))
    end if
  end subroutine ref_array_init_from_code
    
@ %def ref_array_init_from_code
@
\subsection{Composite object type}
A composite object is an extension of a wrapper: it consists of a core
(essentially, its value) and members (properties). 

Each object has a name which should be unique within the current scope
(i.e., as a member of the parent object, if any).  It also has a mode
(abstract, constant, variable) which controls the assignment of values.

Each object is derived from a [[prototype]].

Objects may be instrinsic or user-defined, inheriting from some intrinsic
prototype. 
<<Object base: parameters>>=
  integer, parameter, public :: MODE_ABSTRACT = 0
  integer, parameter, public :: MODE_CONSTANT = 1
  integer, parameter, public :: MODE_VARIABLE = 2

@ %def MODE_ABSTRACT MODE_CONSTANT MODE_VARIABLE
@
<<Object base: public>>=
  public :: composite_t
<<Object base: types>>=
  type, extends (wrapper_t) :: composite_t
     private
     type(string_t) :: name
     integer :: mode = MODE_ABSTRACT
     logical :: intrinsic = .true.
     class(composite_t), pointer :: prototype => null ()
     logical, dimension(:), allocatable :: member_is_argument
     type(wrapper_t), dimension(:), pointer :: member => null ()
     type(wrapper_t), dimension(:), pointer :: primer => null ()
   contains
   <<Object base: composite: TBP>>
  end type composite_t

@ %def composite_t
@
\subsubsection{Finalizer}
The finalizer has to take care of core and members.
<<Object base: composite: TBP>>=
  procedure :: final => composite_final
<<Object base: procedures>>=
  recursive subroutine composite_final (object)
    class(composite_t), intent(inout) :: object
    integer :: i
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          if (associated (object%primer(i)%core)) then
             call remove_object (object%primer(i)%core)
          end if
       end do
       deallocate (object%primer)
    end if
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (associated (object%member(i)%core)) then
             call remove_object (object%member(i)%core)
          end if
       end do
       deallocate (object%member)
       deallocate (object%member_is_argument)
    end if
    call object%wrapper_t%final ()
    call object%unregister ()
  end subroutine composite_final
       
@ %def composite_final
@
\subsubsection{Output}
Value: this is the core, if any.
<<Object base: composite: TBP>>=
  procedure :: write_value => composite_write_value
<<Object base: procedures>>=
  recursive subroutine composite_write_value (object, unit, indent)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%has_value ()) then
       call object%core%write_as_value (unit, indent)
    else
       call object_write_stub (object, unit, indent)
    end if
  end subroutine composite_write_value
    
@ %def composite_write_value
@
Mantle: members/arguments and primer statements.  This explicit routine writes
indices for members.
<<Object base: composite: TBP>>=
  procedure :: write_mantle => composite_write_mantle
<<Object base: procedures>>=
  recursive subroutine composite_write_mantle (object, unit, indent, refcount)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: member, primer
    type(string_t) :: opname
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (object%show_opname(i)) then
             call write_indent (u, ind)
             write (u, "('O')", advance="no")
             write (u, "(I0,':',1x)", advance="no") i
             write (u, "(A)")  char (object%get_opname (i))
          end if
          call write_indent (u, ind)
          if (object%member_is_argument (i)) then
             write (u, "('A')", advance="no")
          else
             write (u, "('M')", advance="no")
          end if
          write (u, "(I0,':',1x)", advance="no") i
          if (object%member(i)%is_reference ()) then
             write (u, "('*')", advance="no")
          end if
          call object%get_member_ptr (i, member)
          if (associated (member)) then
             call member%write (u, ind, refcount)
          else
             write (u, "('<>')")
          end if
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call write_indent (u, ind)
          write (u, "('P',I0,':',1x)", advance="no") i
          call object%get_primer_ptr (i, primer)
          if (associated (primer)) then
             call primer%write_as_statement (u, ind)
          end if
          write (u, *)
       end do
    end if
  end subroutine composite_write_mantle
  
@ %def composite_write_mantle
@
\subsubsection{Prototype feature}
When an instance of a composite is created, it should call the
[[register]] method with specified object as prototype.

The [[register]] method must be public, since the assignment type uses it.

The [[unregister]] method is called only by [[remove_object]] and therefore
is private.  It calls [[remove_object]] for the prototype, which will delete
the prototype object if there is no other instance of it.

The new object inherits the [[intrinsic]] tag from its prototype, so
we don't need to unset it manually.
<<Object base: composite: TBP>>=
  procedure, non_overridable :: register => composite_register
  procedure, non_overridable, private :: unregister => composite_unregister
<<Object base: procedures>>=
  subroutine composite_register (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    object%prototype => prototype
    prototype%refcount = prototype%refcount + 1
    object%intrinsic = prototype%intrinsic
  end subroutine composite_register

  recursive subroutine composite_unregister (object)
    class(composite_t), intent(inout) :: object
    class(object_t), pointer :: prototype
    prototype => object%prototype 
    call remove_object (prototype)
    object%prototype => null ()
  end subroutine composite_unregister

@ %def composite_register
@ %def composite_unregister
@ If the object is not an instance, we associate it to the given prototype.
<<Object base: composite: TBP>>=
  procedure :: set_default_prototype => composite_set_default_prototype
<<Object base: procedures>>=
  subroutine composite_set_default_prototype (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    if (.not. associated (object%prototype)) then
       call object%register (prototype)
    end if
  end subroutine composite_set_default_prototype
    
@ %def composite_set_default_prototype
@ If the prototype is a repository member, we can obtain the index of the
prototype.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_index => composite_get_prototype_index
<<Object base: procedures>>=
  function composite_get_prototype_index (object, repository) result (i)
    class(composite_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    if (associated (object%prototype)) then
       call repository%find_member (object%prototype%get_name (), index=i)
    else
       i = 0
    end if
  end function composite_get_prototype_index

@ %def composite_get_prototype_index
@
\subsubsection{Queries}
Access the object's name.
<<Object base: composite: TBP>>=
  procedure :: get_name => composite_get_name
<<Object base: procedures>>=
  pure function composite_get_name (object) result (name)
    class(composite_t), intent(in) :: object
    type(string_t) :: name
    name = object%name
  end function composite_get_name
  
@ %def composite_get_name
@ Prototype string: actually, the prototype of the value object, i.e., the
core.  If there is a core, delegate the function.  Otherwise, delegate to the
prototype or revert to the plain object.

The exception are non-intrinsic objects, for which we write the prototype name
with an enclosing [[type(..)]] clause.
<<Object base: composite: TBP>>=
  procedure :: get_prototype => composite_get_prototype
<<Object base: procedures>>=
  recursive function composite_get_prototype (object) result (prototype)
    class(composite_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%prototype)) then
       if (object%prototype%intrinsic) then
          prototype = object%prototype%get_name ()
       else
          prototype = "type(" // object%prototype%get_name () // ")"
       end if
    else
       prototype = object_get_prototype (object)
    end if   
  end function composite_get_prototype
  
@ %def composite_get_prototype
@ The signature of a composite object.
<<Object base: composite: TBP>>=
  procedure :: get_signature => composite_get_signature
<<Object base: procedures>>=
  pure function composite_get_signature (object, verbose) result (signature)
    class(composite_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    select case (object%mode)
    case (MODE_ABSTRACT)
       signature = "abstract"
    case (MODE_CONSTANT)
       signature = "constant"
    case (MODE_VARIABLE)
       if (verb) then
          signature = "variable"
       else
          signature = ""
       end if
    end select
  end function composite_get_signature
       
@ %def composite_get_signature
@ This query tells whether the object has a core, and this core
describes a literal value or definable variable.
<<Object base: composite: TBP>>=
  procedure :: has_value => composite_has_value
<<Object base: procedures>>=
  pure function composite_has_value (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    if (object%is_statement ()) then
       flag = .false.
    else
       select case (object%mode)
       case (MODE_CONSTANT, MODE_VARIABLE)
          flag = associated (object%core)
       case default
          flag = .false.
       end select
    end if
  end function composite_has_value
  
@ %def composite_has_value
@ This query tells whether the object has a core, and this core
describes a literal value.
<<Object base: composite: TBP>>=
  procedure :: has_literal => composite_has_literal
<<Object base: procedures>>=
  pure function composite_has_literal (object) result (flag)
    class(composite_t), intent(in) :: object
    class(object_t), pointer :: core
    logical :: flag
    if (object%has_value ()) then
       flag = object%core%is_literal ()
    else
       flag = .false.
    end if
  end function composite_has_literal
  
@ %def composite_has_literal
@ The definition status is delegated to the core.
<<Object base: composite: TBP>>=
  procedure :: is_defined => composite_is_defined
<<Object base: procedures>>=
  pure function composite_is_defined (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    if (object%has_value ()) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function composite_is_defined
  
@ %def composite_is_defined
@ Yes if there are member or primer components.
<<Object base: composite: TBP>>=
  procedure :: has_mantle => composite_has_mantle
<<Object base: procedures>>=
  pure function composite_has_mantle (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    flag = object%get_n_members () + object%get_n_primers () > 0
  end function composite_has_mantle
  
@ %def composite_has_mantle
@ Return the number of members, of members that are marked as arguments, and
of primer statements, respectively.
<<Object base: composite: TBP>>=
  procedure :: get_n_members => composite_get_n_members
  procedure :: get_n_arguments => composite_get_n_arguments
  procedure :: get_n_primers => composite_get_n_primers
<<Object base: procedures>>=
  pure function composite_get_n_members (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = size (object%member)
    else
       n = 0
    end if
  end function composite_get_n_members
  
  pure function composite_get_n_arguments (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = count (object%member_is_argument)
    else
       n = 0
    end if
  end function composite_get_n_arguments
  
  pure function composite_get_n_primers (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%primer)) then
       n = size (object%primer)
    else
       n = 0
    end if
  end function composite_get_n_primers
  
@ %def composite_get_n_members
@ %def composite_get_n_arguments
@ %def composite_get_n_primers
@ Return pointer to a specific member (dereference and return the core).
<<Object base: composite: TBP>>=
  procedure :: get_member_ptr => composite_get_member_ptr
  procedure :: get_primer_ptr => composite_get_primer_ptr
<<Object base: procedures>>=
  subroutine composite_get_member_ptr (object, i, member)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    if (associated (object%member)) then
       if (associated (object%member(i)%core)) then
          member => object%member(i)%core%dereference ()
       else
          member => null ()
       end if
    else
       member => null ()
    end if
  end subroutine composite_get_member_ptr
  
  subroutine composite_get_primer_ptr (object, i, primer)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    if (associated (object%primer)) then
       if (associated (object%primer(i)%core)) then
          primer => object%primer(i)%core%dereference ()
       else
          primer => null ()
       end if
    else
       primer => null ()
    end if
  end subroutine composite_get_primer_ptr
  
@ %def composite_get_member_ptr
@ %def composite_get_primer_ptr
@ These queries are valid for some operators.  The logical query indicates
whether to show the operator name in verbose output.  The string quary returns
the operator string specific for a particular operand (argument).  Other
composites don't have that.  In any case, we set the default operator string
to the operator name.
<<Object base: composite: TBP>>=
  procedure :: show_opname => composite_show_opname
  procedure :: get_opname => composite_get_opname
<<Object base: procedures>>=
  pure function composite_show_opname (object, i) result (flag)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: i
    logical :: flag
    flag = .false.
  end function composite_show_opname
    
  function composite_get_opname (object, i) result (name)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    name = object%get_name ()
  end function composite_get_opname
    
@ %def composite_show_opname
@ %def composite_get_opname
@ Prototype status and pointer.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_ptr => composite_get_prototype_ptr
<<Object base: procedures>>=
  subroutine composite_get_prototype_ptr (object, prototype)
    class(composite_t), intent(in) :: object
    class(composite_t), intent(out), pointer :: prototype
    prototype => object%prototype
  end subroutine composite_get_prototype_ptr
  
@ %def composite_get_prototype_ptr
@ Query the object mode.  The [[check_mode]] subroutine returns success if an
object is supposed to be mutable.
<<Object base: composite: TBP>>=
  procedure :: check_mode => composite_check_mode
<<Object base: procedures>>=
  pure subroutine composite_check_mode (object, mutable)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: mutable
    select case (object%mode)
    case (MODE_ABSTRACT);  mutable = .false.
    case default
       mutable = .true.
    end select
  end subroutine composite_check_mode
  
@ %def composite_check_mode
@ This query tells if the object is required in an assignment.
<<Object base: composite: TBP>>=
  procedure :: check_role => composite_check_role
<<Object base: procedures>>=
  pure subroutine composite_check_role (object, required)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: required
    select case (object%mode)
    case (MODE_ABSTRACT)
       required = .false.
       if (associated (object%core)) then
          select type (core => object%core)
          type is (tag_t);  required = .true.
          end select
       end if
    case (MODE_CONSTANT, MODE_VARIABLE)
       required = .true.
    case default
       required = .false.
    end select
  end subroutine composite_check_role
  
@ %def composite_check_role
@
\subsubsection{Constructors and Initialization}
Instantiate: setup a composite with the same core as the prototype.
<<Object base: composite: TBP>>=
  procedure :: instantiate => composite_instantiate
<<Object base: procedures>>=
  recursive subroutine composite_instantiate (object, instance)
    class(composite_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (composite_t :: instance)
    select type (instance)
    class is (composite_t)
       call instance%register (object)
       if (associated (object%core)) &
            call object%core%instantiate (instance%core)
    end select
  end subroutine composite_instantiate
  
@ %def composite_instantiate
@
The attribute list consists of [[intrinsic]] and [[mode]], expressed as
integers.

Attribute codes are assigned as follows:
\begin{enumerate}
\item Prototype index, from the repository
\item [[mode]]
\item [[intrinsic]] status
\item Number of members
\item Number of arguments (included in members)
\item Number of primer statements
\end{enumerate}
<<Object base: composite: TBP>>=
  procedure :: get_code => composite_get_code
<<Object base: procedures>>=
  function composite_get_code (object, repository) result (code)
    class(composite_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
    call object%get_name_code (code)
  end function composite_get_code
  
@ %def composite_get_code
@ Separate procedures for base code and name string.
<<Object base: composite: TBP>>=
  procedure :: get_base_code => composite_get_base_code
  procedure :: get_name_code => composite_get_name_code
<<Object base: procedures>>=
  subroutine composite_get_base_code (object, code, repository)
    class(composite_t), intent(in), target :: object
    type(code_t), intent(inout) :: code
    type(repository_t), intent(in), optional :: repository
    integer, dimension(6) :: att
    att = 0
    if (present (repository)) then
       att(1) = object%get_prototype_index (repository)
    end if
    att(2) = object%mode
    if (.not. object%intrinsic) then
       att(3) = 1
    end if
    att(4) = object%get_n_members ()
    att(5) = object%get_n_arguments ()
    att(6) = object%get_n_primers ()
    call code%set (CAT_COMPOSITE, att)
  end subroutine composite_get_base_code
  
  subroutine composite_get_name_code (object, code)
    class(composite_t), intent(in), target :: object
    type(code_t), intent(inout) :: code
    call code%create_string_val ([object%get_name ()])
  end subroutine composite_get_name_code
  
@ %def composite_get_base_code  
@ %def composite_get_name_code  
@ Initialize from code.
<<Object base: composite: TBP>>=
  procedure :: init_from_code => composite_init_from_code
<<Object base: procedures>>=
  subroutine composite_init_from_code (object, code)
    class(composite_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    type(string_t), dimension(:), allocatable :: string_array
    type(string_t) :: name
    logical :: success
    call code%get_string (name, success)
    if (.not. success)  name = ""
    call object%init ( &
         name = name, &
         mode = code%get_att (2), &
         n_members = code%get_att (4), &
         n_arguments = code%get_att (5), &
         n_primers = code%get_att (6))
    call object%set_intrinsic (code%get_att (3) == 0)
  end subroutine composite_init_from_code

@ %def composite_init_from_code
@ Initialize/reset.

The initializer will prepare for a member array sized [[n_members]], a primer
statement array sized [[n_primers]], and a number of named positional
arguments [[n_args]].  The latter are included in [[n_members]].  If a number
is not provided, the corresponding array is not allocated. 
<<Object base: composite: TBP>>=
  generic :: init => composite_init
  procedure, private :: composite_init
  procedure :: set_mode => composite_set_mode
  procedure :: set_intrinsic => composite_set_intrinsic
  procedure :: init_members => composite_init_members
  procedure :: init_primers => composite_init_primers
<<Object base: procedures>>=
  subroutine composite_init &
       (object, name, mode, n_members, n_arguments, n_primers)
    class(composite_t), intent(inout), target :: object
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    integer, intent(in), optional :: n_members
    integer, intent(in), optional :: n_arguments
    integer, intent(in), optional :: n_primers
    object%name = name
    if (present (mode))  call object%set_mode (mode)
    if (present (n_members)) then
       call object%init_members (n_members, n_arguments)
    end if
    if (present (n_primers)) then
       call object%init_primers (n_primers)
    end if
  end subroutine composite_init
 
  subroutine composite_set_mode (object, mode)
    class(composite_t), intent(inout) :: object
    integer, intent(in) :: mode
    object%mode = mode
  end subroutine composite_set_mode

  subroutine composite_set_intrinsic (object, intrinsic)
    class(composite_t), intent(inout) :: object
    logical, intent(in) :: intrinsic
    object%intrinsic = intrinsic
  end subroutine composite_set_intrinsic

  subroutine composite_init_members (object, n_members, n_arguments)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: n_members
    integer, intent(in), optional :: n_arguments
    integer :: i
    allocate (object%member (n_members))
    do i = 1, n_members
       call object%member(i)%set_context (object)
    end do
    allocate (object%member_is_argument (n_members), source = .false.)
    if (present (n_arguments)) then
       object%member_is_argument(1:n_arguments) = .true.
    end if
  end subroutine composite_init_members
 
  subroutine composite_init_primers (object, n_primers)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: n_primers
    integer :: i
    allocate (object%primer (n_primers))
    do i = 1, n_primers
       call object%primer(i)%set_context (object)
    end do
  end subroutine composite_init_primers
 
@ %def composite_init
@ %def composite_set_mode
@ %def composite_init_members
@ %def composite_init_primers
@
Mark the object as non-intrinsic.  Default is intrinsic.
<<Object base: composite: TBP>>=
  procedure :: tag_non_intrinsic => composite_tag_non_intrinsic
<<Object base: procedures>>=
  pure subroutine composite_tag_non_intrinsic (object)
    class(composite_t), intent(inout) :: object
    object%intrinsic = .false.
  end subroutine composite_tag_non_intrinsic
  
@ %def composite_tag_non_intrinsic
@ Import a member object which has been created previously.  The object will
become the member's core.  No copy is made, the original pointer is
discarded.
<<Object base: composite: TBP>>=
  procedure :: import_member => composite_import_member
  procedure :: link_member => composite_link_member
<<Object base: procedures>>=
  subroutine composite_import_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    call member%set_context (object%member(i))
    call object%member(i)%final ()
    call object%member(i)%import_core (member)
  end subroutine composite_import_member
    
  subroutine composite_link_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    class(object_t), pointer :: ref
    call member%make_reference (ref)
    call object%import_member (i, ref)
  end subroutine composite_link_member
    
@ %def composite_import_member
@ %def composite_link_member
@ Import a primer object which has been created previously.  The object will
become the core of the primer reference.  No copy is made, the original
pointer is discarded.
<<Object base: composite: TBP>>=
  procedure :: import_primer => composite_import_primer
<<Object base: procedures>>=
  subroutine composite_import_primer (object, i, primer)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: primer
    call primer%set_context (object%primer(i))
    call object%primer(i)%final ()
    call object%primer(i)%import_core (primer)
  end subroutine composite_import_primer
    
@ %def composite_import_primer
@
\subsubsection{Evaluation}
Resolve: First resolve arguments/members, then primer statements.
<<Object base: composite: TBP>>=
  procedure :: resolve => composite_resolve
<<Object base: procedures>>=
  recursive subroutine composite_resolve (object, success)
    class(composite_t), intent(inout), target :: object
    logical, intent(out) :: success
    integer :: i
    success = .true.
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call object%member(i)%core%resolve (success)
          if (.not. success)  return
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call object%primer(i)%core%resolve (success)
          if (.not. success)  return
       end do
    end if
  end subroutine composite_resolve
  
@ %def composite_resolve
@ Evaluation: first arguments, then primer statements.
<<Object base: composite: TBP>>=
  procedure :: evaluate => composite_evaluate
<<Object base: procedures>>=
  recursive subroutine composite_evaluate (object)
    class(composite_t), intent(inout), target :: object
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (object%member_is_argument(i)) then
             call object%member(i)%core%evaluate ()
          end if
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call object%primer(i)%core%evaluate ()
       end do
    end if
  end subroutine composite_evaluate
  
@ %def composite_evaluate
@
\subsubsection{Iterator Support}
Iterate: first scan the members, then core.  Then, return to
context.
<<Object base: public>>=
  public :: composite_next_position
<<Object base: composite: TBP>>=
  procedure :: next_position => composite_next_position
<<Object base: procedures>>=
  subroutine composite_next_position &
       (object, position, next_object, import_object)
    class(composite_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE, POS_ID)
       if (object%get_n_members () > 0) then
          position%part = POS_MEMBER
          position%i = 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case (POS_MEMBER)
       if (position%i < size (object%member)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case (POS_PRIMER)
       if (position%i < size (object%primer)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call wrapper_next_position &
               (object, position, next_object, import_object)
       end if
    case default
       call wrapper_next_position &
            (object, position, next_object, import_object)
    end select
  end subroutine composite_next_position
  
@ %def composite_next_position
@
\subsubsection{Tools}
Return a pointer to a path, given in form of an array of strings.  If no
object is found, return a null pointer.  Otherwise, return a pointer to the
object as [[member]].

First search the immediate members of the current object.  Then search the
prototype object.
<<Object base: composite: TBP>>=
  procedure :: find => composite_find
<<Object base: procedures>>=
  recursive subroutine composite_find (object, path, member)
    class(composite_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: parent
    member => null ()
    if (size (path) > 0) then
       call object%find_member (path(1), member)
       if (associated (member)) then
          if (size (path) > 1) then
             parent => member
             call parent%find (path(2:), member)
          end if
       else
          if (associated (object%prototype)) then
             call object%prototype%find (path, member)
          end if
          if (.not. associated (member)) then
             call wrapper_find (object, path, member)
          end if
       end if
    end if
  end subroutine composite_find
    
@ %def composite_find_member
@ Return a pointer to a specific member.  If the object has no members, or the
member is not found, return a null pointer.
<<Object base: composite: TBP>>=
  procedure :: find_member => composite_find_member
<<Object base: procedures>>=
  subroutine composite_find_member (object, name, member, index)
    class(composite_t), intent(in) :: object
    type(string_t), intent(in) :: name
    class(object_t), intent(out), optional, pointer :: member
    integer, intent(out), optional :: index
    class(object_t), pointer :: core
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call object%member(i)%get_core_ptr (core)
          if (core%get_name () == name) then
             if (present (member))  member => core%dereference ()
             if (present (index))  index = i
             return
          end if
       end do
    end if
    if (present (member))  member => null ()
    if (present (index))  index = 0
  end subroutine composite_find_member
    
@ %def composite_find_member
@ Expand the member array by inserting empty entries at the end.
<<Object base: composite: TBP>>=
  procedure :: expand => composite_expand
<<Object base: procedures>>=
  subroutine composite_expand (object, n_extra, is_argument)
    class(composite_t), intent(inout) :: object
    integer, intent(in) :: n_extra
    logical, intent(in) :: is_argument
    type(wrapper_t), dimension(:), pointer :: member
    class(object_t), pointer :: core
    integer :: i
    member => object%member
    allocate (object%member (object%get_n_members () + n_extra))
    if (associated (member)) then
       do i = 1, size (member)
          call member(i)%get_core_ptr (core)
          if (associated (core))  call object%import_member (i, core)
       end do
    end if
    object%member_is_argument = &
         [object%member_is_argument, spread (is_argument, 1, n_extra)]
  end subroutine composite_expand
    
@ %def composite_expand
@
\subsection{Repository}
A repository is a simple extension of a generic [[composite_t]] object.  It
collects the objects that are supposed to act as prototypes.  We hold those
objects as members and access them by name or by index.

It has a [[spawn]] method which allows it to create new objects from those
prototypes.
<<Object base: public>>=
  public :: repository_t
<<Object base: types>>=
  type, extends (composite_t) :: repository_t
     private
   contains
   <<Object base: repository: TBP>>
  end type repository_t
  
@ %def repository_t
@ Include: add a new object as a prototype to the repository member array.  We
have to extend the array by one.  The new object is stored as a non-local
reference.
<<Object base: repository: TBP>>=
  procedure :: include => repository_include
<<Object base: procedures>>=
  subroutine repository_include (repository, object)
    class(repository_t), intent(inout), target :: repository
    class(object_t), intent(inout), target :: object
    type(wrapper_t), dimension(:), pointer :: new_member
    logical, dimension(:), allocatable :: member_is_argument
    class(object_t), pointer :: ref
    integer :: n
    n = size (repository%member) 
    allocate (new_member (n + 1))
    new_member(1:n) = repository%member
    deallocate (repository%member)
    call object%make_reference (ref)
    call new_member(n+1)%import_core (ref)
    call new_member(n+1)%set_context (repository)
    repository%member => new_member
    deallocate (repository%member_is_argument)
    allocate (repository%member_is_argument (n+1), source=.false.)
  end subroutine repository_include
    
@ %def repository_include
@ There are two variants of the [[spawn]] method: either search for the
prototype name or use a known member index.
<<Object base: repository: TBP>>=
  generic :: spawn => spawn_by_name, spawn_by_index
  procedure, private :: spawn_by_name
  procedure, private :: spawn_by_index
<<Object base: procedures>>=
  subroutine spawn_by_name (repository, name, object)
    class(repository_t), intent(in) :: repository
    type(string_t), intent(in) :: name
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%find_member (name, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_name
    
  subroutine spawn_by_index (repository, i, object)
    class(repository_t), intent(in) :: repository
    integer, intent(in) :: i
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%get_member_ptr (i, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_index
    
@ %def spawn_by_name
@ %def spawn_by_index
@ Extract an array that contains all member names, so we have an independent
lookup for prototypes.
<<Object base: repository: TBP>>=
  procedure :: get_prototype_names => repository_get_prototype_names
<<Object base: procedures>>=
  subroutine repository_get_prototype_names (repository, name)
    class(repository_t), intent(in) :: repository
    type(string_t), dimension(:), allocatable, intent(out) :: name
    class(object_t), pointer :: prototype
    integer :: i
    allocate (name (repository%get_n_members ()))
    do i = 1, size (name)
       call repository%get_member_ptr (i, prototype)
       name(i) = prototype%get_name ()
    end do
  end subroutine repository_get_prototype_names
    
@ %def repository_get_prototype_names 
@
\subsection{Object iterator}
The object iterator allows us to traverse the object tree in a well-defined
oorder.   

\subsubsection{Iterator stack}
Positions objects are pushed on a stack (LIFO).  This constitutes the
iterator, the last stack entry provides the current object pointer.
<<Object base: types>>=
  type, extends (position_t) :: position_entry_t
     private
     class(object_t), pointer :: object => null ()
     type(position_entry_t), pointer :: previous => null ()
  end type position_entry_t
  
@ %def position_entry_t
<<Object base: public>>=
  public :: object_iterator_t
<<Object base: types>>=
  type :: object_iterator_t
     private
     type(position_entry_t), pointer :: current => null ()
   contains
   <<Object base: object iterator: TBP>>
  end type object_iterator_t
  
@ %def object_iterator
@ Recursively clear.
<<Object base: object iterator: TBP>>=
  procedure :: final => object_iterator_final
<<Object base: procedures>>=
  subroutine object_iterator_final (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    do while (associated (it%current))
       call it%pop ()
    end do
  end subroutine object_iterator_final
    
@ %def object_iterator_final
@ Output for debugging purposes.
<<Object base: object iterator: TBP>>=
  procedure :: write => object_iterator_write
<<Object base: procedures>>=
  subroutine object_iterator_write (it, unit)
    class(object_iterator_t), intent(in) :: it
    integer, intent(in), optional :: unit
    type(position_entry_t), pointer :: entry
    integer :: u
    u = given_output_unit (unit)
    entry => it%current
    do while (associated (entry))
       call entry%write (u)
       entry => entry%previous
    end do
  end subroutine object_iterator_write
  
@ %def object_iterator_write
@ Push/pop a fresh position object at the it entry point.
<<Object base: object iterator: TBP>>=
  procedure, private :: push => object_iterator_push
  procedure, private :: pop => object_iterator_pop
<<Object base: procedures>>=
  subroutine object_iterator_push (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    allocate (entry)
    entry%previous => it%current
    it%current => entry
  end subroutine object_iterator_push
    
  subroutine object_iterator_pop (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    entry => it%current
    if (associated (entry)) then
       it%current => entry%previous
       deallocate (entry)
    else
       it%current => null ()
    end if
  end subroutine object_iterator_pop
  
@ %def object_iterator_push
@ %def object_iterator_pop
@
\subsubsection{Iterator: initialization and query}
Create a single-entry it and position at the root object.
<<Object base: object iterator: TBP>>=
  procedure :: init => object_iterator_init
<<Object base: procedures>>=
  subroutine object_iterator_init (it, object)
    class(object_iterator_t), intent(out) :: it
    class(object_t), intent(in), target :: object
    call it%push ()
    it%current%object => object
  end subroutine object_iterator_init
    
@ %def object_iterator_init
@ The iterator is valid as long as the stack has a
current entry, associated with the current object.
<<Object base: object iterator: TBP>>=
  procedure :: is_valid => object_iterator_is_valid
<<Object base: procedures>>=
  function object_iterator_is_valid (it) result (flag)
    class(object_iterator_t), intent(in) :: it
    logical :: flag
    flag = associated (it%current)
    if (flag)  flag = associated (it%current%object)
  end function object_iterator_is_valid
  
@ %def object_iterator_is_valid
@ Return the object pointer.
<<Object base: object iterator: TBP>>=
  procedure :: get_object => object_iterator_get_object
<<Object base: procedures>>=
  subroutine object_iterator_get_object (it, object)
    class(object_iterator_t), intent(in) :: it
    class(object_t), pointer, intent(out) :: object
    if (associated (it%current)) then
       object => it%current%object
    else
       object => null ()
    end if
  end subroutine object_iterator_get_object
  
@ %def object_iterator_get_object
@ Return the code for the next object in automatic navigation order.
<<Object base: object iterator: TBP>>=
  procedure :: get_next_position => object_iterator_get_next_position
<<Object base: procedures>>=
  subroutine object_iterator_get_next_position (it, position)
    class(object_iterator_t), intent(inout) :: it
    type(position_t), intent(out) :: position
    if (associated (it%current)) then
       position = it%current%position_t
       call it%current%object%next_position (position)
    end if
  end subroutine object_iterator_get_next_position
    
@ %def object_iterator_get_next_position
@
\subsubsection{Automatic navigation}
Advance, traversing the objects in well-defined order.  The order is under
control of the current object.  It should increment the position counter and
return a pointer to the next object in line, if possible.

If the [[import_object]] argument is given, insert this as the next object in
the object tree, before moving to it.  If the insertion was successful, the
[[import_object]] pointer will be null on exit.
<<Object base: object iterator: TBP>>=
  procedure :: advance => object_iterator_advance
<<Object base: procedures>>=
  recursive subroutine object_iterator_advance (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    class(position_t), pointer :: position
    class(object_t), pointer :: next_object
    position => it%current
    call it%current%object%next_position (position, next_object, import_object)
    select case (position%part)
    case (POS_NONE)
       call it%skip (import_object)
    case default
       call it%push ()
       it%current%object => next_object
    end select
  end subroutine object_iterator_advance
       
@ %def object_iterator_advance
@ This is a variant that tells the iterator to skip the current object and all
of its subobjects, returning to the previous stack entry and advancing from
there.  The routine is also called by [[advance]] when the current object is
already exhausted.
<<Object base: object iterator: TBP>>=
  procedure :: skip => object_iterator_skip
<<Object base: procedures>>=
  recursive subroutine object_iterator_skip (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    call it%pop ()
    if (it%is_valid ()) then
       call it%advance (import_object)
    else
       call it%final ()
    end if
  end subroutine object_iterator_skip
       
@ %def object_iterator_skip
@
\subsubsection{Manual navigation}
Navigate in specific ways.
<<Object base: object iterator: TBP>>=
  procedure :: to_context => object_iterator_to_context
  procedure :: to_id => object_iterator_to_id
  procedure :: to_core => object_iterator_to_core
  procedure :: to_member => object_iterator_to_member
  procedure :: to_primer => object_iterator_to_primer
<<Object base: procedures>>=
  subroutine object_iterator_to_context (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    if (it%is_valid ()) then
       call it%pop ()
       success = .true.
    else
       success = .false.
    end if
  end subroutine object_iterator_to_context

  subroutine object_iterator_to_id (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = .false.
    object => it%current%object
    if (object%has_id ()) then
       it%current%part = POS_ID
       call it%push ()
       call object%get_id_ptr (it%current%object)
       success = .true.
    end if
  end subroutine object_iterator_to_id

  subroutine object_iterator_to_core (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (wrapper_t)
       if (associated (object%core)) then
          it%current%part = POS_CORE
          call it%push ()
          it%current%object => object%core
          success = .true.
       end if
    end select
  end subroutine object_iterator_to_core

  subroutine object_iterator_to_member (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%member)) then
          if (0 < i .and. i <= size (object%member)) then
             if (associated (object%member(i)%core)) then
                it%current%part = POS_MEMBER
                it%current%i = i
                call it%push ()
                it%current%object => object%member(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_member

  subroutine object_iterator_to_primer (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%primer)) then
          if (0 < i .and. i <= size (object%primer)) then
             if (associated (object%primer(i)%core)) then
                it%current%part = POS_PRIMER
                it%current%i = i
                call it%push ()
                it%current%object => object%primer(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_primer

@ %def object_iterator_to_context
@ %def object_iterator_to_id
@ %def object_iterator_to_core
@ %def object_iterator_to_member
@ %def object_iterator_to_primer
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_base_ut.f90]]>>=
<<File header>>

module object_base_ut

  use unit_tests
  use object_base_uti
  
<<Standard module head>>

<<Object base: public test>>

contains
  
<<Object base: test driver>>

end module object_base_ut
@ %def object_base_ut
@ 
<<[[object_base_uti.f90]]>>=
<<File header>>

module object_base_uti
  
<<Standard module head>>

<<Object base: test declarations>>

contains
  
<<Object base: tests>>

end module object_base_uti
@ %def object_base_uti
@ API: driver for the unit tests below.
<<Object base: public test>>=
  public :: object_base_test
<<Object base: test driver>>=
  subroutine object_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object base: execute tests>>  
  end subroutine object_base_test
  
@ %def object_base_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Object base: execute tests>>=
  call test (object_base_1, "object_base_1", &
       "object and prototype", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_1
<<Object base: tests>>=  
  subroutine object_base_1 (u)
    use codes
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: obj1, obj2
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_1"
    write (u, "(A)")  "*   Purpose: elementary operations with objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Trivial object (tag): create, instantiate, display"

    allocate (tag_t :: obj1)
    call obj1%instantiate (obj2)
    
    write (u, "(A)")
    call obj1%write (u, refcount=.true.)
    call obj2%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Object code:"
    write (u, "(A)")

    code = obj1%get_code ()
    call code%write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    call remove_object (obj1)
    call remove_object (obj2)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (obj1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (obj2)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_1"
    
  end subroutine object_base_1

@ %def object_base_1
@ Create a composite object.
<<Object base: execute tests>>=
  call test (object_base_2, "object_base_2", &
       "composite object", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_2
<<Object base: tests>>=  
  subroutine object_base_2 (u)
  <<Use strings>>
    use codes
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, object1, object2, object3
    class(object_t), pointer :: member
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_2"
    write (u, "(A)")  "*   Purpose: build composite objects"

    write (u, "(A)")      
    write (u, "(A)")  "* Create tag prototype"
    
    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite without members"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%init (name = var_str ("obj1"))
    end select
   
    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite with two members"
    
    call prototype%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%tag_non_intrinsic ()
       call object2%init (name = var_str ("obj2"), n_members = 2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object2%import_member (1, member)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (2, member)
    end select
    
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Code of obj2"
    
    code = object2%get_code ()

    write (u, "(A)")
    call code%write (u, verbose=.true.)

    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate further with additional member"
    
    call object2%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("new"))
       end select
       call object3%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj3"
    
    call remove_object (object3)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj2"
    
    call remove_object (object2)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj1"
    
    call remove_object (object1)

    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    call remove_object (prototype)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (object1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (object2)
    write (u, "(A,1x,L1)")  "obj3 allocated =", associated (object3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_2"
    
  end subroutine object_base_2

@ %def object_base_2
@ Find objects by path.
<<Object base: execute tests>>=
  call test (object_base_3, "object_base_3", &
       "object path search", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_3
<<Object base: tests>>=  
  subroutine object_base_3 (u)
  <<Use strings>>
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, foo, bar

    write (u, "(A)")  "* Test output: object_base_3"
    write (u, "(A)")  "*   Purpose: find objects by path"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1"

    object1 => null ()
    select type (object3)
    class is (composite_t)
       call object3%find_member (var_str ("obj1"), object1)
    end select

    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1.foo"

    foo => null ()
    call object3%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj2.foo"

    foo => null ()
    call object3%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2"

    object2 => null ()
    call object1%find ([var_str ("obj2")], object2)

    if (associated (object2)) then
       write (u, "(A)")
       call object2%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2.foo"

    foo => null ()
    call object1%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to bar"

    bar => null ()
    call object1%find ([var_str ("bar")], bar)

    if (associated (bar)) then
       write (u, "(A)")
       call bar%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at bar, return pointer to obj1.foo"

    foo => null ()
    call bar%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)

    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_3"
    
  end subroutine object_base_3

@ %def object_base_3
@ Handle references and copies.
<<Object base: execute tests>>=
  call test (object_base_4, "object_base_4", &
       "object references and copies", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_4
<<Object base: tests>>=  
  subroutine object_base_4 (u)
  <<Use strings>>
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: obj, ref

    write (u, "(A)")  "* Test output: object_base_4"
    write (u, "(A)")  "*   Purpose: create references and copies"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create object"
    
    call prototype%instantiate (obj)
    select type (obj)
    class is (composite_t)
       call obj%init (name = var_str ("obj"))
    end select
    
    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create reference"

    call obj%make_reference (ref)

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    call ref%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (ref)
    call remove_object (obj)
    call remove_object (prototype)
    call remove_object (tag)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj allocated =", associated (obj)
    write (u, "(A,1x,L1)")  "ref allocated =", associated (ref)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_4"
    
  end subroutine object_base_4

@ %def object_base_4
@ Iterate.
<<Object base: execute tests>>=
  call test (object_base_5, "object_base_5", &
       "object iterator", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_5
<<Object base: tests>>=  
  subroutine object_base_5 (u)
  <<Use strings>>
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, ptr
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_5"
    write (u, "(A)")  "*   Purpose: use iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3, skipping obj2"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       if (ptr%get_name () == "obj2") then
          call it%skip ()
          cycle
       end if
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_5"
    
  end subroutine object_base_5

@ %def object_base_5
@ Repository for prototypes.
<<Object base: execute tests>>=
  call test (object_base_6, "object_base_6", &
       "prototype repository", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_6
<<Object base: tests>>=  
  subroutine object_base_6 (u)
  <<Use strings>>
    use codes
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object1, object2, object3, member
    type(repository_t), target :: repository
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_6"
    write (u, "(A)")  "*   Purpose: use prototype repository"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create composite with member of type tag"
     
    call repository%spawn (var_str ("tag"), object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call repository%spawn (1, member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select
 
    write (u, "(A)")
    call object1%write (u, refcount=.true.)

    write (u, "(A)")      
    code = object1%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create extension of object1"
    
    call repository%include (object1)
    call repository%spawn (var_str ("obj1"), object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"), n_members = 1)
       call repository%spawn (var_str ("tag"), member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (1, member)
    end select
       
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    code = object2%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (object2)
    call remove_object (object1)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_6"
    
  end subroutine object_base_6

@ %def object_base_6
@ Object building.
<<Object base: execute tests>>=
  call test (object_base_7, "object_base_7", &
       "build composite using code", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_7
<<Object base: tests>>=  
  subroutine object_base_7 (u)
  <<Use strings>>
    use io_units
    use codes
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: main, object, core
    type(repository_t), target :: repository
    integer, parameter :: ncode = 4
    integer :: utmp, i
    type(code_t), dimension(ncode) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_7"
    write (u, "(A)")  "*   Purpose: object building using code and iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create anonymous wrapper"
    
    allocate (wrapper_t :: main)

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Code array for composite with member"
     
    utmp = free_unit ()
    open (utmp, status="scratch")
    ! Composite with 1 member, named 'obj1'
    write (utmp, "(A)")  "100 2 1 6 1 0 0 1 0 0"
    write (utmp, "(A)")  " obj1"
    ! Member: composite named 'foo'
    write (utmp, "(A)")  "100 2 1 6 1 0 0 0 0 0"
    write (utmp, "(A)")  " foo"
    ! Member core: tag
    write (utmp, "(A)")  "  1 0 0 0"
    ! Parent core: tag
    write (utmp, "(A)")  "  1 0 0 0"

    rewind (utmp)
    write (u, "(A)")
    do i = 1, ncode
       call code(i)%read (utmp)
       call code(i)%write (u, verbose=.true.)
    end do
    close (utmp)

    write (u, "(A)")      
    write (u, "(A)")  "* Build composite using code array"
     
    call it%init (main)
    do i = 1, ncode
       call build_object (object, code(i), repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
    end do

    write (u, "(A)")
    select type (main)
    class is (wrapper_t)
       call main%get_core_ptr (core)
       if (associated (core)) then
          call core%write (u)
       end if
    end select
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_7"
    
  end subroutine object_base_7

@ %def object_base_7
@ Resolve named reference
<<Object base: execute tests>>=
  call test (object_base_8, "object_base_8", &
       "named reference", &
       u, results)
<<Object base: test declarations>>=
  public :: object_base_8
<<Object base: tests>>=  
  subroutine object_base_8 (u)
  <<Use strings>>
    use object_base
    
    implicit none

    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: main, foo, ref
    logical :: success

    write (u, "(A)")  "* Test output: object_base_8"
    write (u, "(A)")  "*   Purpose: resolve reference by ID"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    call prototype%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create main"

    call prototype%instantiate (foo)
    select type (foo)
    class is (composite_t)
       call foo%init (name = var_str ("foo"))
    end select
    
    allocate (reference_t :: ref)
    select type (ref)
    class is (reference_t)
       call ref%set_path ([var_str ("foo")])
    end select

    allocate (composite_t :: main)
    select type (main)
    class is (composite_t)
       call main%init (name = var_str ("main"), n_members = 2)
       call main%import_member (1, foo)
       call main%import_member (2, ref)
    end select
    
    write (u, "(A)")      
    call main%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Resolve reference"

    call main%resolve (success)

    write (u, "(A)")      
    write (u, "(A,1x,L1)")  "success =", success

    write (u, "(A)")      
    call main%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (main)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_8"
    
  end subroutine object_base_8

@ %def object_base_8
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Builder}
This module introduces an [[object_builder_t]] which allows us to convert
bytecode into an object tree and back.  This is an implementation of
abstract [[builder_t]].

The code definitions are in the [[codes]] module, while the [[object_base]]
module provides a [[build_object]] procedure.  Furthermore, we need an object
repository.
<<[[object_builder.f90]]>>=
<<File header>>

module object_builder

<<Use strings>>
  use format_utils
  use io_units
  use diagnostics
  use codes
  use builders
  use object_base

<<Standard module head>>

<<Object builder: public>>

<<Object builder: types>>

contains

<<Object builder: procedures>>

end module object_builder
@ %def object_builder
@
\subsection{Type}
<<Object builder: public>>=
  public :: object_builder_t
<<Object builder: types>>=
  type, extends (builder_t) :: object_builder_t
     private
     type(repository_t), allocatable :: repository
     class(object_t), pointer :: main => null ()
     type(object_iterator_t) :: it
   contains
   <<Object builder: object builder: TBP>>
  end type object_builder_t
  
@ %def object_builder_t
@ 
Finalizer:
<<Object builder: object builder: TBP>>=
  procedure :: final => object_builder_final
<<Object builder: procedures>>=
  subroutine object_builder_final (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    if (allocated (builder%repository)) then
       call builder%repository%final ()
       deallocate (builder%repository)
    end if
  end subroutine object_builder_final

@ %def object_builder_final
@
Output:
<<Object builder: object builder: TBP>>=
  procedure :: write => object_builder_write
<<Object builder: procedures>>=
  subroutine object_builder_write (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(A)")  "Object builder:"
    call builder%write_repository (u)
    call builder%write_object (u)
    call builder%write_iterator (u)
  end subroutine object_builder_write

@ %def object_builder_write
@ Write parts
<<Object builder: object builder: TBP>>=
  procedure :: write_repository => object_builder_write_repository
  procedure :: write_object => object_builder_write_object
  procedure :: write_iterator => object_builder_write_iterator
<<Object builder: procedures>>=
  subroutine object_builder_write_repository (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x)", advance="no")
    if (allocated (builder%repository)) then
       call builder%repository%write (u)
    else
       write (u, "(A)")  "[no repository]"
    end if
  end subroutine object_builder_write_repository
  
  subroutine object_builder_write_object (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(object_t), pointer :: core
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x)", advance="no")
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (core)
          if (associated (core)) then
             call core%write (u)
          else
             write (u, "(A)")  "[Empty object]"
          end if
       end select
    else
       write (u, "(A)")  "[No object]"
    end if
  end subroutine object_builder_write_object
  
  subroutine object_builder_write_iterator (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (builder%it%is_valid ()) then
       write (u, "(1x,A)", advance="no")  "Iterator:"
       call builder%it%write (u)
       write (u, *)
    else
       write (u, "(1x,A)")  "[Null iterator]"
    end if
  end subroutine object_builder_write_iterator
  
@ %def object_builder_write_repository
@ %def object_builder_write_object
@ %def object_builder_write_iterator
@
\subsection{Initialization}
This is probably done only once.
<<Object builder: object builder: TBP>>=
  procedure :: import_repository => object_builder_import_repository
<<Object builder: procedures>>=
  subroutine object_builder_import_repository (builder, repository)
    class(object_builder_t), intent(inout) :: builder
    type(repository_t), intent(inout), allocatable :: repository
    call move_alloc (from=repository, to=builder%repository)
  end subroutine object_builder_import_repository
  
@ %def object_builder_import_repository
@ This can be done repeatedly.
<<Object builder: object builder: TBP>>=
  procedure :: reset => object_builder_reset
<<Object builder: procedures>>=
  subroutine object_builder_reset (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%it%final ()
    if (associated (builder%main)) then
       call remove_object (builder%main)
    end if
  end subroutine object_builder_reset
    
@ %def object_builder_reset
@ Initialize for decoding an existing object tree.  The object is allocated as
a reference to the object.  The repository is not touched.
<<Object builder: object builder: TBP>>=
  procedure :: init_object => object_builder_init_object
<<Object builder: procedures>>=
  subroutine object_builder_init_object (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(inout), target :: object
    call builder%reset ()
    call object%make_reference (builder%main)
    call builder%it%init (builder%main%dereference ())
  end subroutine object_builder_init_object
  
@ %def object_builder_init_object
@ Initialize for building a new object tree.  The object is allocated as a
wrapper.
<<Object builder: object builder: TBP>>=
  procedure :: init_empty => object_builder_init_empty
<<Object builder: procedures>>=
  subroutine object_builder_init_empty (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    allocate (wrapper_t :: builder%main)
    call builder%it%init (builder%main)
  end subroutine object_builder_init_empty
    
@ %def object_builder_init_empty
@
\subsection{Decoding}
Decode the current object and advance the iterator.  If there is no object
left, return [[.false.]]
<<Object builder: object builder: TBP>>=
  procedure :: decode => object_builder_decode
<<Object builder: procedures>>=
  subroutine object_builder_decode (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = builder%it%is_valid ()
    if (success) then
       call builder%it%get_object (object)
       code = object%get_code (builder%repository)
       call builder%it%advance ()
    end if
  end subroutine object_builder_decode
  
@ %def object_builder_decode
@
\subsection{Building}
Take the current code, build a new object if appropriate, and insert this (or
the value given by the code) at the next location in the object tree.  Then
advance the iterator to the new location.
<<Object builder: object builder: TBP>>=
  procedure :: build => object_builder_build
<<Object builder: procedures>>=
  subroutine object_builder_build (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    logical, parameter :: DEBUG = .false.
!     logical, parameter :: DEBUG = .true.
    if (DEBUG)  print *
    if (DEBUG)  print *, "build object"
    if (DEBUG)  call code%write ()
    call build_object (object, code, builder%repository)
    if (associated (object)) then
       call builder%it%advance (import_object = object)
    else
       call builder%it%advance ()
    end if
    success = builder%it%is_valid ()
    if (success) then
       call builder%it%get_object (object)
       if (DEBUG)  call builder%it%write ()
       if (DEBUG)  print *
       if (DEBUG)  call object%write ()
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       class is (ref_array_t)
          call object%init_from_code (code)
       end select
    else
       call builder%write ()
       call code%write ()
       call msg_fatal ("Sindarin: error in byte code")
    end if
  end subroutine object_builder_build
    
@ %def object_builder_build
@ Extract the complete object tree.  The builder is reset to empty state.
<<Object builder: object builder: TBP>>=
  procedure :: export => object_builder_export
<<Object builder: procedures>>=
  subroutine object_builder_export (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(out), pointer :: object
    object => null ()
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (object)
       end select
       deallocate (builder%main)
    end if
    call builder%reset ()
  end subroutine object_builder_export
          
@ %def object_builder_export
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_builder_ut.f90]]>>=
<<File header>>

module object_builder_ut
  
  use unit_tests
  use object_builder_uti

<<Standard module head>>

<<Object builder: public test>>

contains
  
<<Object builder: test driver>>

end module object_builder_ut
@ %def object_builder_ut
@ 
<<[[object_builder_uti.f90]]>>=
<<File header>>

module object_builder_uti
  
  <<Use strings>>
    use io_units
    use codes
    use object_base

    use object_builder

<<Standard module head>>

<<Object builder: test declarations>>

contains
  
<<Object builder: tests>>

end module object_builder_uti
@ %def object_builder_uti
@ API: driver for the unit tests below.
<<Object builder: public test>>=
  public :: object_builder_test
<<Object builder: test driver>>=
  subroutine object_builder_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object builder: execute tests>>  
  end subroutine object_builder_test
  
@ %def object_builder_test 
@ Object building.
<<Object builder: execute tests>>=
  call test (object_builder_1, "object_builder_1", &
       "build composite using builder", &
       u, results)
<<Object builder: test declarations>>=
  public :: object_builder_1
<<Object builder: tests>>=  
  subroutine object_builder_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object, member
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    type(code_t) :: code
    logical :: success
    integer :: utmp, iostat

    write (u, "(A)")  "* Test output: object_builder_1"
    write (u, "(A)")  "*   Purpose: object building using builder"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create composite"
    
    call repository%spawn (var_str ("tag"), member)
    select type (member)
    class is (composite_t)
       call member%init (name = var_str ("foo"))
    end select
    
    call repository%spawn (var_str ("tag"), object)
    select type (object)
    class is (composite_t)
       call object%init (name = var_str ("obj1"), n_members = 1)
       call object%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create builder"
    
    call builder%import_repository (repository)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Initialize builder with object"
    
    call builder%init_object (object)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Decode"
    write (u, "(A)")      
      
    utmp = free_unit ()
    open (utmp, status="scratch")

    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do

    call remove_object (object)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Reset builder"
    write (u, "(A)")     
 
    call builder%init_empty ()
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Reconstruct object"
    write (u, "(A)")      

    rewind (utmp)
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (utmp)

    call builder%export (object)
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call builder%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_builder_1"
    
    end subroutine object_builder_1

@ %def object_builder_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}
This module supplements the system of basic objects by statements and
expressions.  Those are composite objects that can be evaluated.  We
furthermore implement assignments as special statements, and define unary and
binary operators as special expressions.
<<[[object_expr.f90]]>>=
<<File header>>

module object_expr

<<Use strings>>
  use format_utils
  use io_units
  use diagnostics
  use codes
  use object_base

<<Standard module head>>

<<Expr: public>>

<<Expr: types>>

<<Expr: interfaces>>

contains

<<Expr: procedures>>

end module object_expr
@ %def object_expr
@
\subsection{Statements}
A statement is an extended composite.  The first few of the members are
interpreted as arguments.  There is no core.
<<Expr: public>>=
  public :: statement_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: statement_t
     private
   contains
   <<Expr: statement: TBP>>
  end type statement_t
  
@ %def statement_t
@
\subsubsection{Queries}
The default prototype for all statements.
<<Expr: statement: TBP>>=
  procedure :: get_prototype => statement_get_prototype
<<Expr: procedures>>=
  function statement_get_prototype (object) result (prototype)
    class(statement_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "statement"
  end function statement_get_prototype
  
@ %def statement_get_prototype
@ The statement is a statement.
<<Expr: statement: TBP>>=
  procedure :: is_statement => statement_is_statement
<<Expr: procedures>>=
  pure function statement_is_statement (object) result (flag)
    class(statement_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function statement_is_statement
  
@ %def statement_is_statement
@
\subsection{Assignment item}
An assignment item combines pointers for the left-hand and right-hand sides of
an elementary value assignment.  A list of such items constitutes a composite
assignment.
<<Expr: types>>=
  type :: item_t
     private
     class(value_t), pointer :: lhs => null ()
     class(value_t), pointer :: rhs => null ()
     class(item_t), pointer :: next => null ()
  end type item_t
  
@ %def item_t
@
\subsection{Assignment object}
The ID object should be allocated and owned by the assignment object.  It
denotes the ID (object path) of the LHS.  The [[lhs]] object is just a pointer
to the actual LHS object that is stored elsewhere.  It is the root of the
object list for assignment, and set by the [[resolve]] method.  Finally, the
[[item]] list indicates the actual assignments to perform.
<<Expr: public>>=
  public :: assignment_t
<<Expr: types>>=
  type, extends (statement_t) :: assignment_t
     private
     class(object_t), pointer :: id => null ()
     class(object_t), pointer :: lhs => null ()
     class(item_t), pointer :: item => null ()
   contains
   <<Expr: assignment: TBP>>
  end type assignment_t
     
@ %def assignment_t
@
\subsubsection{Finalizer}
The core (rhs) will be finalized depending on whether it is
stored as a reference or a local component.  The lhs pointer is never
finalized.
<<Expr: assignment: TBP>>=
  procedure :: final => assignment_final
<<Expr: procedures>>=
  recursive subroutine assignment_final (object)
    class(assignment_t), intent(inout) :: object
    class(item_t), pointer :: item
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    do while (associated (object%item))
       item => object%item
       object%item => item%next
       deallocate (item)
    end do
    call object%composite_t%final ()
  end subroutine assignment_final
    
@ %def assignment_final
@
\subsubsection{Output}
Output in statement form.  For the LHS, we try to write the path
expression.  The RHS is written as an expression.
<<Expr: assignment: TBP>>=
  procedure :: write_statement => assignment_write_statement
<<Expr: procedures>>=
  recursive subroutine assignment_write_statement (object, unit, indent)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: rhs
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, indent)
       else
          write (u, "('<LHS>')", advance="no")
       end if
    else
       write (u, "('<LHS>')", advance="no")
    end if
    write (u, "(1x,'=',1x)", advance="no")
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write_as_expression (unit, indent)
    else
       write (u, "(A)", advance="no") "<???>"
    end if
  end subroutine assignment_write_statement
    
@ %def assignment_write_statement
@ The mantle (statement contents) are presented in a special way.
<<Expr: assignment: TBP>>=
  procedure :: write_mantle => assignment_write_mantle
<<Expr: procedures>>=
  recursive subroutine assignment_write_mantle (object, unit, indent, refcount)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: rhs
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "LHS:"
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, ind+1)
          write (u, *)
       else
          write (u, "('<LHS>')")
       end if
    else
       write (u, *)
    end if
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "RHS:"
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write (unit, ind+1)
    else
       write (u, "(A)") "<???>"
    end if
  end subroutine assignment_write_mantle
  
@ %def assignment_write_mantle
@ Extra output for debugging.
<<Expr: assignment: TBP>>=
  procedure :: write_stack => assignment_write_stack
<<Expr: procedures>>=
  subroutine assignment_write_stack (object, unit)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    class(item_t), pointer :: item
    u = given_output_unit (unit)
    call object%write (u)
    item => object%item
    do while (associated (item))
       write (u, "('+')", advance="no")
       write (u, "(1x,'LHS: ')", advance="no")
       if (associated (item%lhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%lhs%get_name ())
          if (item%lhs%is_defined ()) then
             call item%lhs%write_as_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, "(2x,'RHS: ')", advance="no")
       if (associated (item%rhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%rhs%get_name ())
          if (item%rhs%is_defined ()) then
             call item%rhs%write_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, *)
       item => item%next
    end do
  end subroutine assignment_write_stack
  
@ %def assignment_write_stack
@
\subsubsection{Queries}
This query tells whether the object contains an ID subobject.
<<Expr: assignment: TBP>>=
  procedure :: has_id => assignment_has_id
<<Expr: procedures>>=
  pure function assignment_has_id (object) result (flag)
    class(assignment_t), intent(in) :: object
    logical :: flag
    flag = associated (object%id)
  end function assignment_has_id
  
@ %def assignment_has_id
@ Return the pointer to the ID subobject, if any.
<<Expr: assignment: TBP>>=
  procedure :: get_id_ptr => assignment_get_id_ptr
<<Expr: procedures>>=
  subroutine assignment_get_id_ptr (object, id)
    class(assignment_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => object%id
  end subroutine assignment_get_id_ptr
  
@ %def assignment_get_id_ptr
@
\subsubsection{Construction}
The [[instantiate]] method must be implemented.
<<Expr: assignment: TBP>>=
  procedure :: instantiate => assignment_instantiate
<<Expr: procedures>>=
  recursive subroutine assignment_instantiate (object, instance)
    class(assignment_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (assignment_t :: instance)
    select type (instance)
    type is (assignment_t)
       call instance%register (object)
       call instance%init (mode = MODE_CONSTANT)
    end select
  end subroutine assignment_instantiate
    
@ %def assignment_instantiate
@
The assignment object doesn't require the attribute list of generic composites.
<<Expr: assignment: TBP>>=
  procedure :: get_code => assignment_get_code
<<Expr: procedures>>=
  function assignment_get_code (object, repository) result (code)
    class(assignment_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    integer :: prototype_index
    type(code_t) :: code
    if (present (repository)) then
       prototype_index = object%get_prototype_index (repository)
    else
       prototype_index = 0
    end if
    call code%set (CAT_COMPOSITE, [prototype_index])
  end function assignment_get_code
  
@ %def assignment_get_code
@ Initialize from code: since the [[instantiate]] method already does
everything, we must not initialize anything here, just override the method.
<<Expr: assignment: TBP>>=
  procedure :: init_from_code => assignment_init_from_code
<<Expr: procedures>>=
  subroutine assignment_init_from_code (object, code)
    class(assignment_t), intent(inout) :: object
    type(code_t), intent(in) :: code
  end subroutine assignment_init_from_code

@ %def assignment_init_from_code
@ Initialize: Set the path for the LHS and import the object pointer for the
RHS.  Alternatively, ignore the part and set the LHS pointer directly.

If [[link]] is true, the [[rhs]] component is interpreted as a reference.  If
false, it is imported, nullifying the original pointer.
<<Expr: assignment: TBP>>=
  generic :: init => assignment_init
  procedure, private :: assignment_init
  procedure :: set_path => assignment_set_path
<<Expr: procedures>>=
  subroutine assignment_init (object, mode)
    class(assignment_t), intent(inout) :: object
    integer, intent(in), optional :: mode
    call object%init (name=var_str ("assignment"), mode = mode, &
         n_members=1, n_arguments=1)
  end subroutine assignment_init
    
  subroutine assignment_set_path (object, lhs_path)
    class(assignment_t), intent(inout) :: object
    type(string_t), dimension(:), intent(in) :: lhs_path
    allocate (id_t :: object%id)
    select type (id => object%id)
    type is (id_t)
       call id%init (lhs_path)
    end select
  end subroutine assignment_set_path
    
@ %def assignment_init
@ %def assignment_set_path
@ Assign ID, LHS pointer, RHS object.
<<Expr: assignment: TBP>>=
  procedure :: import_id => assignment_import_id
  procedure :: set_lhs => assignment_set_lhs
  procedure :: set_rhs => assignment_set_rhs
<<Expr: procedures>>=
  subroutine assignment_import_id (object, id)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: id
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    object%id => id
    id => null ()
  end subroutine assignment_import_id
    
  subroutine assignment_set_lhs (object, lhs)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(in), pointer :: lhs
    object%lhs => lhs
  end subroutine assignment_set_lhs

  subroutine assignment_set_rhs (object, rhs, link)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: rhs
    logical, intent(in) :: link
    if (link) then
       call object%link_member (1, rhs)
    else
       call object%import_member (1, rhs)
    end if
  end subroutine assignment_set_rhs
    
@ %def assignment_set_lhs
@ %def assignment_set_rhs
@
\subsubsection{Evaluation}
Push a lhs-rhs combination onto the assigment stack.
<<Expr: assignment: TBP>>=
  procedure :: push => assignment_push
<<Expr: procedures>>=
  subroutine assignment_push (object, lhs, rhs)
    class(assignment_t), intent(inout) :: object
    class(value_t), intent(in), pointer :: lhs, rhs
    class(item_t), pointer :: item
    allocate (item)
    item%lhs => lhs
    item%rhs => rhs
    item%next => object%item
    object%item => item
  end subroutine assignment_push
  
@ %def assignment_push
@ Resolve: Find the object that belongs to the LHS, match the RHS signature
against it, and build an assignment-item list for the matching values.  The
algorithm implements duck typing, i.e., the match is successful if all
required items are present at the correct position and with correct value type
in the RHS object tree.

TODO: find should not extend beyond the immediate composite-object context.
<<Expr: assignment: TBP>>=
  procedure :: resolve => assignment_resolve
<<Expr: procedures>>=
  subroutine assignment_resolve (object, success)
    class(assignment_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: lhs, rhs
    logical :: mutable
    if (object%has_id ()) then
       select type (id => object%id)
       type is (id_t)
          call object%find (id%get_path (), object%lhs)
       end select
    end if
    success = associated (object%lhs)
    if (success) then
       select type (lhs => object%lhs)
       type is (composite_t);  call lhs%check_mode (mutable)
          success = mutable
       end select
    end if
    if (success) then
       lhs => object%lhs
       call object%get_member_ptr (1, rhs)
       if (associated (lhs) .and. associated (rhs)) then
          call lhs%match (rhs, success, object)
       else
          success = .false.
       end if
    end if
  end subroutine assignment_resolve
    
@ %def assignment_resolve
@ Evaluate: Assign values, using the resolved pointers.

We iterate over the assignment list which should contain pointers to the
matching lhs-rhs combinations.
<<Expr: assignment: TBP>>=
  procedure :: evaluate => assignment_evaluate
<<Expr: procedures>>=
  subroutine assignment_evaluate (object)
    class(assignment_t), intent(inout), target :: object
    class(item_t), pointer :: item
    item => object%item
    do while (associated (item))
       call item%lhs%assign (item%rhs)
       item => item%next
    end do
  end subroutine assignment_evaluate
    
@ %def assignment_evaluate
@
\subsubsection{Iterator Support}
Iterate: scan the ID object (the LHS) before the rest.
<<Expr: assignment: TBP>>=
  procedure :: next_position => assignment_next_position
<<Expr: procedures>>=
  subroutine assignment_next_position &
       (object, position, next_object, import_object)
    class(assignment_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE)
       if (object%has_id ()) then
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else if (present (import_object)) then
          call object%import_id (import_object)
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else
          call composite_next_position &
               (object, position, next_object, import_object)
       end if
    case default
       call composite_next_position &
            (object, position, next_object, import_object)
    end select
  end subroutine assignment_next_position
  
@ %def assignment_next_position
@
\subsection{Expressions}
An expression is an extended composite.  The first few of the members are
interpreted as arguments.
<<Expr: public>>=
  public :: expression_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: expression_t
     private
   contains
   <<Expr: expression: TBP>>
  end type expression_t
  
@ %def expression_t
@
\subsubsection{Queries}
The expression has an expression, unless it is marked [[abstract]].
<<Expr: expression: TBP>>=
  procedure :: is_expression => expression_is_expression
<<Expr: procedures>>=
  pure function expression_is_expression (object) result (flag)
    class(expression_t), intent(in) :: object
    logical :: flag
    call object%check_mode (flag)
  end function expression_is_expression
  
@ %def expression_is_expression
@ For expressions, we should look for the name of the object itself, not the
name of the prototype object (which is the prototype of the value).
<<Expr: expression: TBP>>=
  procedure :: get_prototype_index => expression_get_prototype_index
<<Expr: procedures>>=
  function expression_get_prototype_index (object, repository) result (i)
    class(expression_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    call repository%find_member (object%get_name (), index=i)
  end function expression_get_prototype_index

@ %def expression_get_prototype_index
@
\subsection{Construction / Decoding}
For expressions, we store the standard composite code set, but leave out the
object name.
<<Expr: expression: TBP>>=
  procedure :: get_code => expression_get_code
<<Expr: procedures>>=
  function expression_get_code (object, repository) result (code)
    class(expression_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
  end function expression_get_code
  
@ %def expression_get_code
@ Build object from code: we don't need much of initialization here since this
is achieved by instantiating the prototype.  We just set the number of
arguments.
<<Expr: expression: TBP>>=
  procedure :: init_from_code => expression_init_from_code
<<Expr: procedures>>=
  subroutine expression_init_from_code (object, code)
    class(expression_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    call object%set_mode (mode = code%get_att (2))
    call object%init_args (n_arg = code%get_att (5))
    call object%set_intrinsic (intrinsic = code%get_att (3) == 0)
  end subroutine expression_init_from_code

@ %def expression_init_from_code
@
We define a separate procedure that initializes the number of arguments.
Extensions may do a sanity check.
<<Expr: expression: TBP>>=
  procedure (expression_init_args), deferred :: init_args
<<Expr: interfaces>>=
  abstract interface
     subroutine expression_init_args (object, n_arg, check)
       import
       class(expression_t), intent(inout) :: object
       integer, intent(in) :: n_arg
       logical, intent(in), optional :: check
     end subroutine expression_init_args
  end interface

@ %def expression_init_args
@
\subsection{Operators}
An operator is an expression with a specific notation.  We have unary and
binary operators.  In addition to the result prototype, which is stored in the
parent type, we store a pointer to the (uniform) prototype of the arguments.
<<Expr: public>>=
  public :: operator_t
  public :: operator_unary_t
  public :: operator_binary_t
<<Expr: types>>=
  type, extends (expression_t), abstract :: operator_t
     private
   contains
   <<Expr: operator: TBP>>
  end type operator_t
  
  type, extends (operator_t), abstract :: operator_unary_t
     private
   contains
   <<Expr: operator unary: TBP>>
  end type operator_unary_t
  
  type, extends (operator_t), abstract :: operator_binary_t
     private
   contains
   <<Expr: operator binary: TBP>>
  end type operator_binary_t
  
@ %def operator_t
@ %def operator_unary_t
@ %def operator_binary_t
@
\subsubsection{Output}
Unary or binary operators in prefix or infix notation,
respectively.  We pass the current object's priority to the subexpression
output, so there we decide about extra brackets to write.
<<Expr: operator unary: TBP>>=
  procedure :: write_expression => operator_unary_write_expression
<<Expr: operator binary: TBP>>=
  procedure :: write_expression => operator_binary_write_expression
<<Expr: procedures>>=
  recursive subroutine operator_unary_write_expression (object, unit, indent)
    class(operator_unary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority
    u = given_output_unit (unit)
    priority = object%get_priority ()
    write (u, "(A,1x)", advance="no")  char (object%get_opname ())
    call object%get_member_ptr (1, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       call arg%write_as_expression (unit, indent, priority=priority)
    else
       write (u, "(A)", advance="no") "???"
    end if
  end subroutine operator_unary_write_expression
    
  recursive subroutine operator_binary_write_expression (object, unit, indent)
    class(operator_binary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, priority, i, n_members
    u = given_output_unit (unit)
    priority = object%get_priority ()
    n_members = object%get_n_members ()
    select case (n_members)
    case (0)
       write (u, "('(',A,')')", advance="no")  char (object%get_opname (0))
    case (1)
       write (u, "('(')", advance="no")
       write (u, "(A)", advance="no")  char (object%get_opname (1))
       if (object%space_right ())  write (u, "(1x)", advance="no")
       call write_member (1)
       write (u, "(')')", advance="no")
    case default
       do i = 1, object%get_n_members ()
          if (i > 1) then
             if (object%space_left ())  write (u, "(1x)", advance="no")
             write (u, "(A)", advance="no")  char (object%get_opname (i))
             if (object%space_right ())  write (u, "(1x)", advance="no")
          end if
          call write_member (i)
       end do
    end select
  contains
    recursive subroutine write_member (i)
      integer, intent(in) :: i
      class(object_t), pointer :: arg
      call object%get_member_ptr (i, arg)
      if (associated (arg)) then
         arg => arg%dereference ()
         call arg%write_as_expression (unit, indent, priority=priority)
      else
         write (u, "(A)", advance="no") "???"
      end if
     end subroutine write_member
  end subroutine operator_binary_write_expression
    
@ %def operator_unary_write_expression
@ %def operator_binary_write_expression
@
\subsubsection{Queries}
The written prototype is the prototype of the result.
<<Expr: operator: TBP>>=
  procedure :: get_prototype => operator_get_prototype
<<Expr: procedures>>=
  recursive function operator_get_prototype (object) result (prototype)
    class(operator_t), intent(in) :: object
    type(string_t) :: prototype
    class(object_t), pointer :: core
    call object%get_core_ptr (core)
    if (associated (core)) then
       select type (core)
       class is (composite_t)
          prototype = core%get_prototype ()
       class default
          prototype = core%get_name ()
       end select
    else
       prototype = "operator"
    end if
  end function operator_get_prototype
  
@ %def operator_get_prototype
@ The signature of a operator object contains the [[operator]] attribute,
qualified as either [[unary]] or [[binary]].
<<Expr: operator unary: TBP>>=
  procedure :: get_signature => operator_unary_get_signature
<<Expr: operator binary: TBP>>=
  procedure :: get_signature => operator_binary_get_signature
<<Expr: procedures>>=
  pure function operator_unary_get_signature (object, verbose) &
       result (signature)
    class(operator_unary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|unary|" // signature
    else
       signature = "operator|unary"
    end if
  end function operator_unary_get_signature
       
  pure function operator_binary_get_signature (object, verbose) &
       result (signature)
    class(operator_binary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|binary|" // signature
    else
       signature = "operator|binary"
    end if
  end function operator_binary_get_signature
       
@ %def operator_get_unary_signature
@ %def operator_binary_get_signature
@ For operators, the operator name need not coincide with the notation within
an expression.  The notation may also depend on the position in the
expression.  However, we provide a default where name and notation coincide.
<<Expr: operator: TBP>>=
  procedure :: get_opname => operator_get_opname
<<Expr: procedures>>=
  function operator_get_opname (object, i) result (name)
    class(operator_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    name = object%get_name ()
  end function operator_get_opname
    
@ %def operator_get_opname
@ Operators have different conventions about spacing to the left and right of
the operator symbol.  Default is a single space for both sides.
<<Expr: operator: TBP>>=
  procedure :: space_left => operator_space_left
  procedure :: space_right => operator_space_right
<<Expr: procedures>>=
  function operator_space_left (object) result (flag)
    class(operator_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function operator_space_left
  
  function operator_space_right (object) result (flag)
    class(operator_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function operator_space_right
  
@ %def operator_space_left
@ %def operator_space_right
@
\subsubsection{Construction}
We define a separate procedure that initializes the number of arguments and
does a sanity check.  Argument type is not checked.
<<Expr: operator: TBP>>=
  procedure :: init_args => operator_init_args
<<Expr: procedures>>=
  subroutine operator_init_args (object, n_arg, check)
    class(operator_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    logical, intent(in), optional :: check
    logical :: check_args
    check_args = .true.;  if (present (check))  check_args = check
    if (check_args) then
       select type (object)
       class is (operator_unary_t)
          if (n_arg /= 1) then
             call object%write ()
             call msg_bug ("Unary operator: number of arguments must be one")
          end if
       class is (operator_binary_t)
          if (n_arg < 2) then
             call object%write ()
             call msg_bug ("Binary operator: number of arguments less than two")
          end if
       end select
    end if
    call object%init_members (n_members = n_arg, n_arguments = n_arg)
  end subroutine operator_init_args

@ %def operator_init_args
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logical values}
Logical values are a concrete implementation of [[value_t]].  We also define
logical expressions.

Logical values and expressions allow us to write unit tests for assignment,
expression evaluation, building and decoding.
<<[[object_logical.f90]]>>=
<<File header>>

module object_logical

<<Use strings>>
  use format_utils
  use io_units

  use codes
  use object_base
  use object_builder
  use object_expr

<<Standard module head>>

<<Logical: public>>

<<Logical: types>>

contains

<<Logical: procedures>>

end module object_logical
@ %def object_logical
@ 
\subsection{Type definition}
A logical object carries a logical value.  The [[defined]] status also
applies, inherited from [[value_t]].
<<Logical: public>>=
  public :: logical_t
<<Logical: types>>=
  type, extends (value_t) :: logical_t
     private
     logical :: value = .false.
   contains
   <<Logical: logical: TBP>>
  end type logical_t
  
@ %def logical_t
@ A wrapper type for assembling pointers in expression objects:
<<Logical: public>>=
  public :: logical_p
<<Logical: types>>=
  type :: logical_p
     private
     type(logical_t), pointer :: p => null ()
   contains
   <<Logical: logical p: TBP>>
  end type logical_p
     
@ %def logical_p
@ Associate with a target.
<<Logical: logical p: TBP>>=
  procedure :: associate => logical_p_associate
<<Logical: procedures>>=
  subroutine logical_p_associate (object, target_object)
    class(logical_p), intent(inout) :: object
    type(logical_t), intent(in), target :: target_object
    object%p => target_object
  end subroutine logical_p_associate
  
@ %def logical_p_associate
@ Return the definition status and the logical value.
<<Logical: logical p: TBP>>=
  procedure :: is_defined => logical_p_is_defined
  procedure :: get_value => logical_p_get_value
<<Logical: procedures>>=
  pure function logical_p_is_defined (object) result (flag)
    class(logical_p), intent(in) :: object
    logical :: flag
    if (associated (object%p)) then
       flag = object%p%is_defined ()
    else
       flag = .false.
    end if
  end function logical_p_is_defined
  
  pure function logical_p_get_value (object) result (value)
    class(logical_p), intent(in) :: object
    logical :: value
    value = object%p%value
  end function logical_p_get_value
  
@ %def logical_p_is_defined
@ %def logical_p_get_value
@
\subsubsection{Finalizer}
Finalizer is empty.
<<Logical: logical: TBP>>=
  procedure :: final => logical_final
<<Logical: procedures>>=
  pure subroutine logical_final (object)
    class(logical_t), intent(inout) :: object
  end subroutine logical_final
 
@ %def logical_final
@
\subsubsection{Output}
Display the value.
<<Logical: logical: TBP>>=
  procedure :: write_expression => logical_write_value
  procedure :: write_value => logical_write_value
<<Logical: procedures>>=
  subroutine logical_write_value (object, unit, indent)
    class(logical_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (object%value) then
       write (u, "(A)", advance="no")  "true"
    else
       write (u, "(A)", advance="no")  "false"
    end if
  end subroutine logical_write_value
       
@ %def logical_write_expression
@ %def logical_write_value
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[logical]].
<<Logical: logical: TBP>>=
  procedure :: get_name => logical_get_name
<<Logical: procedures>>=
  pure function logical_get_name (object) result (name)
    class(logical_t), intent(in) :: object
    type(string_t) :: name
    name = "logical"
  end function logical_get_name
  
@ %def logical_get_name
@
\subsubsection{Construction}
For a new tag instance, nothing needs to be copied.
<<Logical: logical: TBP>>=
  procedure :: instantiate => logical_instantiate
<<Logical: procedures>>=
  subroutine logical_instantiate (object, instance)
    class(logical_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (logical_t :: instance)
  end subroutine logical_instantiate
    
@ %def logical_instantiate
@ Logical value: the code includes the value.
<<Logical: logical: TBP>>=
  procedure :: get_code => logical_get_code
<<Logical: procedures>>=
  function logical_get_code (object, repository) result (code)
    class(logical_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call code%set (CAT_VALUE)
    if (object%is_defined ()) then
       call code%create_logical_val ([object%value])
    end if
  end function logical_get_code
  
@ %def logical_get_code
@ Initialize the value, given a code object.
<<Logical: logical: TBP>>=
  procedure :: init_from_code => logical_init_from_code
<<Logical: procedures>>=
  subroutine logical_init_from_code (object, code)
    class(logical_t), intent(out) :: object
    type(code_t), intent(in) :: code
    logical, dimension(:), allocatable :: logical_array
    logical :: value, is_defined
    call code%get_logical (value, is_defined)
    if (is_defined) then
       call object%init (value)
    else
       call object%init ()
    end if
  end subroutine logical_init_from_code
    
@ %def logical_init_from_code
@ Initializer: we may define or undefine the value.
<<Logical: logical: TBP>>=
  procedure :: init => logical_init
<<Logical: procedures>>=
  pure subroutine logical_init (object, value)
    class(logical_t), intent(inout) :: object
    logical, intent(in), optional :: value
    if (present (value)) then
       object%value = value
       call object%set_defined (.true.)
    else
       call object%set_defined (.false.)
    end if
  end subroutine logical_init
 
@ %def logical_init
@
\subsubsection{Assignment}
Copy the value.  LHS and RHS must both be logical.
<<Logical: logical: TBP>>=
  procedure :: match_value => logical_match_value
  procedure :: assign_value => logical_assign_value
<<Logical: procedures>>=
  subroutine logical_match_value (object, source, success)
    class(logical_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (logical_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine logical_match_value
       
  subroutine logical_assign_value (object, source)
    class(logical_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (logical_t)
       object%value = source%value
    end select
  end subroutine logical_assign_value
       
@ %def logical_match_value
@ %def logical_assign_value
@ 
\subsection{Operators: not}
The [[not]] operator is a unary operator.  Both argument and result are of
type [[logical_t]].  We define pointer shortcuts for both argument and
result.
<<Logical: types>>=
  type, extends (operator_unary_t), abstract :: logical_unary_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_t), pointer :: arg => null ()
   contains
   <<Logical: logical unary: TBP>>
  end type logical_unary_t

@ %def logical_unary_t
<<Logical: public>>=
  public :: not_t
<<Logical: types>>=
  type, extends (logical_unary_t) :: not_t
     private
   contains
   <<Logical: not: TBP>>
  end type not_t
  
@ %def not_t
@
\subsubsection{Queries}
Priority value.
<<Logical: not: TBP>>=
  procedure :: get_priority => not_get_priority
<<Logical: procedures>>=
  pure function not_get_priority (object) result (priority)
    class(not_t), intent(in) :: object
    integer :: priority
    priority = PRIO_NOT
  end function not_get_priority
  
@ %def not_get_priority
@
\subsubsection{Construction}
Instantiate: we have to initialize, so the core and argument types are fixed.
<<Logical: not: TBP>>=
  procedure :: instantiate => not_instantiate
<<Logical: procedures>>=
  subroutine not_instantiate (object, instance)
    class(not_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (not_t :: instance)
    select type (instance)
    class is (not_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine not_instantiate
  
@ %def not_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Logical: logical unary: TBP>>=
  generic :: init => logical_unary_init
  procedure, private :: logical_unary_init
<<Logical: procedures>>=
  subroutine logical_unary_init (object, prototype, name, mode)
    class(logical_unary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (name, mode = mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine logical_unary_init
  
@ %def logical_unary_init 
@ Initialize: one argument, no extra members.  We need the [[logical]]
prototype for initializing core and argument.  If this is not an instance, we
also declare the prototype for the object itself.
<<Logical: not: TBP>>=
  generic :: init => not_init
  procedure, private :: not_init
<<Logical: procedures>>=
  subroutine not_init (object, prototype, mode)
    class(not_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_unary_init (object, prototype, var_str ("not"), mode)
  end subroutine not_init
  
@ %def not_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical.
<<Logical: logical unary: TBP>>=
  procedure :: resolve => logical_unary_resolve
<<Logical: procedures>>=
  recursive subroutine logical_unary_resolve (object, success)
    class(logical_unary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    success = .false.
    object%res => null ()
    object%arg => null ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (object%has_value ()) then
       call object%get_member_ptr (1, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             object%arg => core
             success = .true.
          end select
       end select
    end if
  end subroutine logical_unary_resolve
  
@ %def logical_unary_resolve
@ Evaluate the operation.
<<Logical: not: TBP>>=
  procedure :: evaluate => not_evaluate
<<Logical: procedures>>=
  recursive subroutine not_evaluate (object)
    class(not_t), intent(inout), target :: object
    call object%composite_t%evaluate ()
    if (object%arg%is_defined ()) then
       call object%res%init (.not. object%arg%value)
    else
       call object%res%init ()
    end if
  end subroutine not_evaluate
  
@ %def not_evaluate
@ 
\subsection{Operators: and, or}
The [[and]] and [[or]] operators are binary operators.  Both arguments and
result are of type [[logical_t]].  We define pointer shortcuts for both
arguments and result.
<<Logical: types>>=
  type, extends (operator_binary_t), abstract :: logical_binary_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_p), dimension(:), allocatable :: arg_ptr
   contains
   <<Logical: logical binary: TBP>>
  end type logical_binary_t

@ %def logical_binary_t
<<Logical: public>>=
  public :: and_t
  public :: or_t
<<Logical: types>>=
  type, extends (logical_binary_t) :: and_t
     private
   contains
   <<Logical: and: TBP>>
  end type and_t
  
  type, extends (logical_binary_t) :: or_t
     private
   contains
   <<Logical: or: TBP>>
  end type or_t
  
@ %def and_t
@ %def or_t
@
\subsubsection{Queries}
Priority value.
<<Logical: and: TBP>>=
  procedure :: get_priority => and_get_priority
<<Logical: or: TBP>>=
  procedure :: get_priority => or_get_priority
<<Logical: procedures>>=
  pure function and_get_priority (object) result (priority)
    class(and_t), intent(in) :: object
    integer :: priority
    priority = PRIO_AND
  end function and_get_priority
  
  pure function or_get_priority (object) result (priority)
    class(or_t), intent(in) :: object
    integer :: priority
    priority = PRIO_OR
  end function or_get_priority
  
@ %def and_get_priority
@ %def or_get_priority
@
\subsubsection{Construction}
Instantiate: initialize using the generic logical binary initializer.  The
number of arguments is not yet known, we just initialize the core.
<<Logical: and: TBP>>=
  procedure :: instantiate => and_instantiate
<<Logical: or: TBP>>=
  procedure :: instantiate => or_instantiate
<<Logical: procedures>>=
  subroutine and_instantiate (object, instance)
    class(and_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (and_t :: instance)
    select type (instance)
    type is (and_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine and_instantiate
  
  subroutine or_instantiate (object, instance)
    class(or_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (or_t :: instance)
    select type (instance)
    type is (or_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine or_instantiate
  
@ %def and_instantiate
@ %def or_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Logical: logical binary: TBP>>=
  generic :: init => logical_binary_init
  procedure, private :: logical_binary_init
<<Logical: procedures>>=
  subroutine logical_binary_init (object, prototype, name, mode)
    class(logical_binary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (name, mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine logical_binary_init
  
@ %def logical_binary_init 
@ Specific initializers.
<<Logical: and: TBP>>=
  generic :: init => and_init
  procedure, private :: and_init
<<Logical: or: TBP>>=
  generic :: init => or_init
  procedure, private :: or_init
<<Logical: procedures>>=
  subroutine and_init (object, prototype, mode)
    class(and_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_binary_init (object, prototype, var_str ("and"), mode)
  end subroutine and_init
  
  subroutine or_init (object, prototype, mode)
    class(or_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call logical_binary_init (object, prototype, var_str ("or"), mode)
  end subroutine or_init
  
@ %def and_init 
@ %def or_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical, otherwise the routine is universal for binary operators.
<<Logical: logical binary: TBP>>=
  procedure :: resolve => logical_binary_resolve
<<Logical: procedures>>=
  recursive subroutine logical_binary_resolve (object, success)
    class(logical_binary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    integer :: i, n_args
    success = .false.
    object%res => null ()
    n_args = object%get_n_members ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (.not. allocated (object%arg_ptr)) &
         allocate (object%arg_ptr (n_args))
    if (object%has_value ()) then
       do i = 1, n_args
          call object%get_member_ptr (i, arg)
          call arg%resolve (success);  if (.not. success)  return
          select type (arg)
          class is (wrapper_t)
             call arg%get_core_ptr (core)
             select type (core)
             type is (logical_t)
                call object%arg_ptr(i)%associate (core)
                success = .true.
             end select
          end select
       end do
    end if
  end subroutine logical_binary_resolve
  
@ %def logical_binary_resolve
@ Evaluate the operation.
<<Logical: and: TBP>>=
  procedure :: evaluate => and_evaluate
<<Logical: or: TBP>>=
  procedure :: evaluate => or_evaluate
<<Logical: procedures>>=
  recursive subroutine and_evaluate (object)
    class(and_t), intent(inout), target :: object
    integer :: i
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%get_value ()) then
          call object%res%init (.false.)
          return
       end if
    end do
    call object%res%init (.true.)
  end subroutine and_evaluate
  
  recursive subroutine or_evaluate (object)
    class(or_t), intent(inout), target :: object
    integer :: i
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    do i = 1, size (object%arg_ptr)
       if (object%arg_ptr(i)%get_value ()) then
          call object%res%init (.true.)
          return
       end if
    end do
    call object%res%init (.false.)
  end subroutine or_evaluate
  
@ %def and_evaluate
@ %def or_evaluate
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_logical_ut.f90]]>>=
<<File header>>

module object_logical_ut

  use unit_tests
  use object_logical_uti
  
<<Standard module head>>

<<Logical: public test>>

contains
  
<<Logical: test driver>>

end module object_logical_ut
@ %def object_logical_ut
@ 
<<[[object_logical_uti.f90]]>>=
<<File header>>

module object_logical_uti
  
<<Use strings>>
  use io_units
  use codes
  use object_base
  use object_builder
  use object_expr

  use object_logical

<<Standard module head>>

<<Logical: test declarations>>

contains
  
<<Logical: tests>>

<<Logical: test auxiliary>>

end module object_logical_uti
@ %def object_logical_uti
@ API: driver for the unit tests below.
<<Logical: public test>>=
  public :: object_logical_test
<<Logical: test driver>>=
  subroutine object_logical_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Logical: execute tests>>  
  end subroutine object_logical_test
  
@ %def object_logical_test 
@
\subsubsection{Manual initialization}
Shortcut to member initialization.  This routine is used only in the unit
tests below.
<<Logical: public test auxiliary>>=
  public :: init_members
<<Logical: test auxiliary>>=
  subroutine init_members (object, n_arg)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    select type (object)
    class is (operator_t)
       call object%init_args (n_arg)
    end select
  end subroutine init_members
    
@ %def init_members
@ Set the member value directly.  This routine is used only in the unit tests
below.
<<Logical: public test auxiliary>>=
  public :: set_member_val
<<Logical: test auxiliary>>=
  subroutine set_member_val (object, i, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    logical, intent(in), optional :: value
    class(object_t), pointer :: member, core
    class(composite_t), pointer :: prototype
    type(string_t) :: name
    if (present (value)) then
       if (value) then
          name = "true"
       else
          name = "false"
       end if
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       call object%get_prototype_ptr (prototype)
       call prototype%instantiate (member)
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (logical_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
  end subroutine set_member_val
    
@ %def set_member_val
@
\subsubsection{Values}
Create logical objects.
<<Logical: execute tests>>=
  call test (object_logical_1, "object_logical_1", &
       "values", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_1
<<Logical: tests>>=  
  subroutine object_logical_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: bare_logical, core
    class(object_t), pointer :: prototype, true, false, undef

    write (u, "(A)")  "* Test output: object_logical_1"
    write (u, "(A)")  "*   Purpose: construct logical value objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Logical objects: prototype"

    allocate (logical_t :: bare_logical)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("logical"))
       call prototype%import_core (bare_logical)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Logical objects: true, false, undefined"

    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (undef)
    select type (undef)
    type is (composite_t)
       call undef%init (mode = MODE_CONSTANT, name = var_str ("undef"))
       allocate (logical_t :: core)
       call undef%import_core (core)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    call true%write (u, refcount=.true.)
    call false%write (u, refcount=.true.)
    call undef%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (undef)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)
    call remove_object (bare_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_1"
    
    end subroutine object_logical_1

@ %def object_logical_1
@ 
\subsubsection{Atomic assignment}
Perform assignments of elementary logicals.
<<Logical: execute tests>>=
  call test (object_logical_2, "object_logical_2", &
       "assignment", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_2
<<Logical: tests>>=  
  subroutine object_logical_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core, rhs
    class(object_t), pointer :: prototype, true, false, lval1, lval2, lval3
    type(assignment_t) :: asg
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_2"
    write (u, "(A)")  "*   Purpose: assignments"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Create objects"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (lval1)
    select type (lval1)
    type is (composite_t)
       call lval1%init (mode = MODE_VARIABLE, name = var_str ("lval1"))
    end select
    
    call prototype%instantiate (lval2)
    select type (lval2)
    type is (composite_t)
       call lval2%init (mode = MODE_VARIABLE, name = var_str ("lval2"))
    end select
    
    call prototype%instantiate (lval3)
    select type (lval3)
    type is (composite_t)
       call lval3%init (mode = MODE_VARIABLE, name = var_str ("lval3"))
    end select
    
    write (u, "(A)")
    call true%write (u)
    call false%write (u)

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval1 = true"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval1)
    call asg%set_rhs (true, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = false"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (false, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()
    
    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval1"
  
    rhs => lval1
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval3"
  
    rhs => lval3
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (lval1)
    call remove_object (lval2)
    call remove_object (lval3)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "true allocated =", associated (true)
    write (u, "(A,1x,L1)")  "false allocated =", associated (false)
    write (u, "(A,1x,L1)")  "lval1 allocated =", associated (lval1)
    write (u, "(A,1x,L1)")  "lval2 allocated =", associated (lval2)
    write (u, "(A,1x,L1)")  "lval3 allocated =", associated (lval3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_2"
    
    end subroutine object_logical_2

@ %def object_logical_2
@ 
\subsubsection{Composite assignment}
Perform assignments of composites with elementary logical core.
<<Logical: execute tests>>=
  call test (object_logical_3, "object_logical_3", &
       "composite assignment", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_3
<<Logical: tests>>=  
  subroutine object_logical_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: prototype, proto2, main, val, core, rhs, asg
    type(object_iterator_t) :: it
    class(object_t), pointer :: object
    type(code_t) :: code
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_3"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("val"))
    end select
    
    call setup_assignment ()
    write (u, "(A)")
    write (u, "(A)")  "* Assignment object"
    write (u, "(A)")
    call asg%write (u)

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Main object"
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Check name mismatch"

    call remove_object (main)

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("foo"))
    end select
    
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Check mode/type mismatch"

    call remove_object (main)

    allocate (composite_t :: proto2)
    select type (proto2)
    type is (composite_t)
       call proto2%init (var_str ("tag"))
       allocate (tag_t :: core)
       call proto2%import_core (core)
    end select

    call proto2%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (name = var_str ("val"))
    end select
   
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (proto2)
    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_3"
    
    contains
      
      subroutine setup_assignment
        allocate (assignment_t :: asg)
        select type (asg)
        type is (assignment_t)
           call prototype%instantiate (rhs)
           select type (rhs)
           type is (composite_t)
              call rhs%init (mode=MODE_CONSTANT, name=var_str ("rhs"))
              call rhs%get_core_ptr (core)
              select type (core)
              type is (logical_t)
                 call core%init (value = .true.)
              end select
           end select
           call asg%init (MODE=MODE_CONSTANT)
           call asg%set_path ([var_str ("val")])
           call asg%set_rhs (rhs=rhs, link=.false.)
        end select
      end subroutine setup_assignment

    end subroutine object_logical_3

@ %def object_logical_3
@ 
\subsubsection{Nested composite assignment}
Perform assignments of composites with multiple and composite members.
<<Logical: execute tests>>=
  call test (object_logical_4, "object_logical_4", &
       "nontrivial assignment", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_4
<<Logical: tests>>=  
  subroutine object_logical_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: pro_logical, pro_tag
    class(object_t), pointer :: main, foo, bar, a, core, member, rhs, asg, ptr
    type(object_iterator_t) :: it
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_4"
    write (u, "(A)")  "*   Purpose: nested composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: pro_tag)
    select type (pro_tag)
    type is (composite_t)
       call pro_tag%init (var_str ("tag"))
       allocate (tag_t :: core)
       call pro_tag%import_core (core)
    end select

    allocate (composite_t :: pro_logical)
    select type (pro_logical)
    type is (composite_t)
       call pro_logical%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_logical%import_core (core)
    end select

    call pro_logical%instantiate (bar)
    select type (bar)
    type is (composite_t)
       call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
    end select

    call pro_tag%instantiate (a)
    select type (a)
    type is (composite_t)
       call a%init (name = var_str ("a"))
    end select

    call pro_logical%instantiate (foo)
    select type (foo)
    type is (composite_t)
       call foo%init (mode=MODE_CONSTANT, name = var_str ("foo"), &
            n_members=2)
       call foo%import_member (1, a)
       call foo%import_member (2, bar)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t)
          call core%init (value = .true.)
       end select

       call pro_logical%instantiate (bar)
       select type (bar)
       type is (composite_t)
          call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
          call bar%get_core_ptr (core)
          select type (core)
          type is (logical_t);  call core%init (value = .false.)
          end select
       end select

       call pro_tag%instantiate (a)
       select type (a)
       type is (composite_t)
          call a%init (name = var_str ("a"))
       end select

       allocate (composite_t :: rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (mode=MODE_CONSTANT, name = var_str ("rhs"), &
               n_members = 2)
          allocate (logical_t :: core)
          select type (core)
          type is (logical_t);  call core%init (value = .true.)
          end select
          call rhs%import_core (core)
          call rhs%import_member (1, bar)
          call rhs%import_member (2, a)
       end select

       call asg%init (mode=MODE_CONSTANT)
       call asg%set_path ([var_str ("foo")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, foo)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through main"
    write (u, "(A)")      

    call it%init (main)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, core=.false., mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call remove_object (pro_tag)
    call remove_object (pro_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_4"
    
    end subroutine object_logical_4

@ %def object_logical_4
@ 
\subsubsection{Operators: not}
Now the test for [[not]].
<<Logical: execute tests>>=
  call test (object_logical_5, "object_logical_5", &
       "operator: not", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_5
<<Logical: tests>>=  
  subroutine object_logical_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: not, expr1, expr2, expr3
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_5"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: not"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    write (u, "(A)")
    call not%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"

    write (u, "(A)")
    
    call not%instantiate (expr1)
    call init_members (expr1, 1)
    call set_member_val (expr1, 1, .true.)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    call init_members (expr2, 1)
    call set_member_val (expr2, 1, .false.)
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr3)
    call init_members (expr3, 1)
    call set_member_val (expr3, 1)
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u);  write (u, *)
    call expr2%write_as_expression (u);  write (u, *)
    call expr3%write_as_expression (u);  write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "not allocated =", associated (not)
    write (u, "(A,1x,L1)")  "expr1 allocated =", associated (expr1)
    write (u, "(A,1x,L1)")  "expr2 allocated =", associated (expr2)
    write (u, "(A,1x,L1)")  "expr3 allocated =", associated (expr3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_5"
    
    end subroutine object_logical_5

@ %def object_logical_5
@ 
\subsubsection{Operators: and}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_6, "object_logical_6", &
       "operator: and", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_6
<<Logical: tests>>=  
  subroutine object_logical_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: and
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    class(object_t), pointer :: expr8, expr9
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_6"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: and"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    write (u, "(A)")
    call and%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, .true.)
    call set_member_val (expr1, 2, .true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, .true.)
    call set_member_val (expr2, 2, .false.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .false.)
    call set_member_val (expr3, 2, .true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .false.)
    call set_member_val (expr4, 2, .false.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    call init_members (expr5, 2)
    call set_member_val (expr5, 1)
    call set_member_val (expr5, 2, .true.) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr6)
    call init_members (expr6, 2)
    call set_member_val (expr6, 1, .false.)
    call set_member_val (expr6, 2) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr7)
    call init_members (expr7, 2)
    call set_member_val (expr7, 1)
    call set_member_val (expr7, 2) 
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, *)

    call and%instantiate (expr8)
    call init_members (expr8, 3)
    call set_member_val (expr8, 1, .true.)
    call set_member_val (expr8, 2, .true.) 
    call set_member_val (expr8, 3, .false.) 
    call expr8%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr9)
    call init_members (expr9, 4)
    call set_member_val (expr9, 1, .true.)
    call set_member_val (expr9, 2, .true.) 
    call set_member_val (expr9, 3, .true.)
    call set_member_val (expr9, 4, .true.) 
    call expr9%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_expression (u)
    write (u, *)
    call expr9%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    call expr8%evaluate ()
    call expr9%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_value (u)
    write (u, *)
    call expr9%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (expr8)
    call remove_object (expr9)
    call remove_object (and)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_6"
    
    end subroutine object_logical_6

@ %def object_logical_6
@ 
\subsubsection{Operators: or}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_7, "object_logical_7", &
       "operator: or", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_7
<<Logical: tests>>=  
  subroutine object_logical_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    class(object_t), pointer :: expr8, expr9
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_7"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    call or%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call or%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, .true.)
    call set_member_val (expr1, 2, .true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, .true.)
    call set_member_val (expr2, 2, .false.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .false.)
    call set_member_val (expr3, 2, .true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .false.)
    call set_member_val (expr4, 2, .false.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr5)
    call init_members (expr5, 2)
    call set_member_val (expr5, 1)
    call set_member_val (expr5, 2, .true.) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr6)
    call init_members (expr6, 2)
    call set_member_val (expr6, 1, .false.)
    call set_member_val (expr6, 2) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr7)
    call init_members (expr7, 2)
    call set_member_val (expr7, 1)
    call set_member_val (expr7, 2) 
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, *)

    call or%instantiate (expr8)
    call init_members (expr8, 3)
    call set_member_val (expr8, 1, .false.)
    call set_member_val (expr8, 2, .false.) 
    call set_member_val (expr8, 3, .true.) 
    call expr8%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr9)
    call init_members (expr9, 4)
    call set_member_val (expr9, 1, .false.)
    call set_member_val (expr9, 2, .false.) 
    call set_member_val (expr9, 3, .false.)
    call set_member_val (expr9, 4, .false.) 
    call expr9%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_expression (u)
    write (u, *)
    call expr9%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    call expr8%evaluate ()
    call expr9%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, *)
    call expr8%write_as_value (u)
    write (u, *)
    call expr9%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (expr8)
    call remove_object (expr9)
    call remove_object (or)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_7"
    
    end subroutine object_logical_7

@ %def object_logical_7
@ 
\subsubsection{Operators: nested expression}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_8, "object_logical_8", &
       "nested expressions", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_8
<<Logical: tests>>=  
  subroutine object_logical_8 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: not, and, or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5
    class(object_t), pointer :: arg1, arg2
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_8"
    write (u, "(A)")  "*   Purpose: check nested logical expressions"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototypes: not, and, or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    call init_members (expr1, 2)
    select type (expr1)
    class is (composite_t)
       call not%instantiate (arg1)
       call init_members (arg1, 1)
       call set_member_val (arg1, 1, .true.)
       call expr1%import_member (1, arg1)
    end select
    call set_member_val (expr1, 2, .false.)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    call init_members (expr2, 1)
    select type (expr2)
    class is (composite_t)
       call and%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, .true.)
       call set_member_val (arg1, 2, .false.)
       call expr2%import_member (1, arg1)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, .true.)
    select type (expr3)
    class is (composite_t)
       call or%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, .false.)
       call set_member_val (arg2, 2, .true.)
       call expr3%import_member (2, arg2)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, .true.)
    select type (expr4)
    class is (composite_t)
       call and%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, .false.)
       call set_member_val (arg2, 2, .true.)
       call expr4%import_member (2, arg2)
    end select
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    call init_members (expr5, 2)
    select type (expr5)
    class is (composite_t)
       call and%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, .true.)
       call set_member_val (arg1, 2, .false.)
       call expr5%import_member (1, arg1)
    end select
    call set_member_val (expr5, 2, .true.)
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (and)
    call remove_object (or)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_8"
    
    end subroutine object_logical_8

@ %def object_logical_8
@ 
\subsubsection{Build assignment}
Generate code for an assignment object and reconstruct the object from code.
<<Logical: execute tests>>=
  call test (object_logical_9, "object_logical_9", &
       "build assignment from code", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_9
<<Logical: tests>>=  
  subroutine object_logical_9 (u)
    integer, intent(in) :: u
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    class(object_t), pointer :: prototype, main, val, core, rhs, asg
    type(code_t) :: code
    logical :: success
    integer :: iostat
    integer :: utmp

    write (u, "(A)")  "* Test output: object_logical_9"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       call asg%init ()
    end select

    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 2)
    call repository%import_member (1, prototype)
    call repository%import_member (2, asg)


    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare composite object with primer"

    call repository%spawn (var_str ("logical"), val)
    select type (val)
    class is (composite_t)
       call val%init (name = var_str ("val"), mode = MODE_CONSTANT)
    end select
    
    call repository%spawn (var_str ("assignment"), asg)
    select type (asg)
    type is (assignment_t)
       call repository%spawn (var_str ("logical"), rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (name = var_str ("rhs"), mode = MODE_CONSTANT)
          call rhs%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             call core%init (value = .true.)
          end select
       end select
       call asg%set_path ([var_str ("val")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Code"

    call builder%import_repository (repository)

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")
    call builder%init_object (main)
    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do
    rewind (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Reconstruct object"

    call remove_object (main)

    call builder%init_empty ()
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    call builder%export (main)

    close (utmp)
    
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_9"
    
  end subroutine object_logical_9

@ %def object_logical_9
@ 
\subsubsection{Code: not}
Construct logical expressions from bytecode.
<<Logical: execute tests>>=
  call test (object_logical_10, "object_logical_10", &
       "build expressions from code", &
       u, results)
<<Logical: test declarations>>=
  public :: object_logical_10
<<Logical: tests>>=  
  subroutine object_logical_10 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    class(object_t), pointer :: p_log, p_not, p_and, p_or, core, main, object
    class(object_t), pointer :: val1, val2, expr
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_logical_10"
    write (u, "(A)")  "*   Purpose: construct expressions from code"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_log)
    select type (p_log)
    type is (composite_t)
       call p_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call p_log%import_core (core)
    end select

    allocate (not_t :: p_not)
    select type (p_not)
    type is (not_t)
       call p_not%init (p_log)
    end select

    allocate (and_t :: p_and)
    select type (p_and)
    type is (and_t)
       call p_and%init (p_log)
    end select

    allocate (or_t :: p_or)
    select type (p_or)
    type is (or_t)
       call p_or%init (p_log)
    end select

    call repository%init (name = var_str ("repository"), n_members = 4)
    call repository%import_member (1, p_log)
    call repository%import_member (2, p_not)
    call repository%import_member (3, p_and)
    call repository%import_member (4, p_or)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: not"
    

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("not"), expr)
    select type (expr)
    class is (not_t)
       call expr%init_args (1)
       call expr%import_member (1, val1)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 4
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: and"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("and"), expr)
    select type (expr)
    class is (and_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: or"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("or"), expr)
    select type (expr)
    class is (or_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_10"

  end subroutine object_logical_10

@ %def object_logical_10
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integer values}
Integer values are a concrete implementation of [[value_t]].  We also define
integer expressions.

Integer values and expressions allow us to write unit tests for assignment,
expression evaluation, building and decoding.
<<[[object_integer.f90]]>>=
<<File header>>

module object_integer

<<Use strings>>
  use format_utils
  use io_units
  use diagnostics

  use codes
  use object_base
  use object_builder
  use object_expr
  use object_logical

<<Standard module head>>

<<Integer: public>>

<<Integer: types>>

contains

<<Integer: procedures>>

end module object_integer
@ %def object_integer
@ 
\subsection{Type definition}
A integer object carries a integer value.  The [[defined]] status also
applies, inherited from [[value_t]].
<<Integer: public>>=
  public :: integer_t
<<Integer: types>>=
  type, extends (value_t) :: integer_t
     private
     integer :: value = 0
   contains
   <<Integer: integer: TBP>>
  end type integer_t
  
@ %def integer_t
@ A wrapper type for assembling pointers in expression objects:
<<Integer: public>>=
  public :: integer_p
<<Integer: types>>=
  type :: integer_p
     private
     type(integer_t), pointer :: p => null ()
   contains
   <<Integer: integer p: TBP>>
  end type integer_p
     
@ %def integer_p
@ Associate with a target.
<<Integer: integer p: TBP>>=
  procedure :: associate => integer_p_associate
<<Integer: procedures>>=
  subroutine integer_p_associate (object, target_object)
    class(integer_p), intent(inout) :: object
    type(integer_t), intent(in), target :: target_object
    object%p => target_object
  end subroutine integer_p_associate
  
@ %def integer_p_associate
@ Return the integer value.
<<Integer: integer p: TBP>>=
  procedure :: is_defined => integer_p_is_defined
  procedure :: get_value => integer_p_get_value
<<Integer: procedures>>=
  pure function integer_p_is_defined (object) result (flag)
    class(integer_p), intent(in) :: object
    logical :: flag
    if (associated (object%p)) then
       flag = object%p%is_defined ()
    else
       flag = .false.
    end if
  end function integer_p_is_defined
  
  pure function integer_p_get_value (object) result (value)
    class(integer_p), intent(in) :: object
    integer :: value
    value = object%p%value
  end function integer_p_get_value
  
@ %def integer_p_is_defined
@ %def integer_p_get_value
@
\subsubsection{Finalizer}
Finalizer is empty.
<<Integer: integer: TBP>>=
  procedure :: final => integer_final
<<Integer: procedures>>=
  pure subroutine integer_final (object)
    class(integer_t), intent(inout) :: object
  end subroutine integer_final
 
@ %def integer_final
@
\subsubsection{Output}
Display the value.
<<Integer: integer: TBP>>=
  procedure :: write_expression => integer_write_value
  procedure :: write_value => integer_write_value
<<Integer: procedures>>=
  subroutine integer_write_value (object, unit, indent)
    class(integer_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "(I0)", advance="no")  object%value
  end subroutine integer_write_value
       
@ %def integer_write_expression
@ %def integer_write_value
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[integer]].
<<Integer: integer: TBP>>=
  procedure :: get_name => integer_get_name
<<Integer: procedures>>=
  pure function integer_get_name (object) result (name)
    class(integer_t), intent(in) :: object
    type(string_t) :: name
    name = "integer"
  end function integer_get_name
  
@ %def integer_get_name
@
\subsubsection{Construction}
For a new tag instance, nothing needs to be copied.
<<Integer: integer: TBP>>=
  procedure :: instantiate => integer_instantiate
<<Integer: procedures>>=
  subroutine integer_instantiate (object, instance)
    class(integer_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (integer_t :: instance)
  end subroutine integer_instantiate
    
@ %def integer_instantiate
@ Integer value: the code includes the value.
<<Integer: integer: TBP>>=
  procedure :: get_code => integer_get_code
<<Integer: procedures>>=
  function integer_get_code (object, repository) result (code)
    class(integer_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call code%set (CAT_VALUE)
    if (object%is_defined ()) then
       call code%create_integer_val ([object%value])
    end if
  end function integer_get_code
  
@ %def integer_get_code
@ Initialize the value, given a code object.
<<Integer: integer: TBP>>=
  procedure :: init_from_code => integer_init_from_code
<<Integer: procedures>>=
  subroutine integer_init_from_code (object, code)
    class(integer_t), intent(out) :: object
    type(code_t), intent(in) :: code
    integer :: value
    logical :: is_defined
    call code%get_integer (value, is_defined)
    if (is_defined) then
       call object%init (value)
    else
       call object%init ()
    end if
  end subroutine integer_init_from_code
    
@ %def integer_init_from_code
@ Initializer: we may define or undefine the value.
<<Integer: integer: TBP>>=
  procedure :: init => integer_init
<<Integer: procedures>>=
  pure subroutine integer_init (object, value)
    class(integer_t), intent(inout) :: object
    integer, intent(in), optional :: value
    if (present (value)) then
       object%value = value
       call object%set_defined (.true.)
    else
       call object%set_defined (.false.)
    end if
  end subroutine integer_init
 
@ %def integer_init
@
\subsubsection{Assignment}
Copy the value.  LHS and RHS must both be integer.
<<Integer: integer: TBP>>=
  procedure :: match_value => integer_match_value
  procedure :: assign_value => integer_assign_value
<<Integer: procedures>>=
  subroutine integer_match_value (object, source, success)
    class(integer_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (integer_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine integer_match_value
       
  subroutine integer_assign_value (object, source)
    class(integer_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (integer_t)
       object%value = source%value
    end select
  end subroutine integer_assign_value
       
@ %def integer_match_value
@ %def integer_assign_value
@ 
\subsection{Operators: minus}
The [[minus]] operator is a unary operator.  Both argument and result are of
type [[integer_t]].  We define pointer shortcuts for both argument and
result.
<<Integer: types>>=
  type, extends (operator_unary_t), abstract :: integer_unary_t
     private
     type(integer_t), pointer :: res => null ()
     type(integer_t), pointer :: arg => null ()
   contains
   <<Integer: integer unary: TBP>>
  end type integer_unary_t

@ %def integer_unary_t
<<Integer: public>>=
  public :: minus_t
<<Integer: types>>=
  type, extends (integer_unary_t) :: minus_t
     private
   contains
   <<Integer: minus: TBP>>
  end type minus_t
  
@ %def minus_t
@
\subsubsection{Output}
The minus sign is special, as in expression-output the argument should be
enclosed in brackets if it either represents a literal value or another minus
operator.  Furthermore, we avoid space between operator and operand.
<<Integer: minus: TBP>>=
  procedure :: write_expression => minus_write_expression
<<Integer: procedures>>=
  recursive subroutine minus_write_expression (object, unit, indent)
    class(minus_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority
    u = given_output_unit (unit)
    priority = object%get_priority ()
    write (u, "(A)", advance="no")  char (object%get_opname ())
    call object%get_member_ptr (1, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       if (arg%is_expression ()) then
          call arg%write_as_expression (unit, indent, priority=priority)
       else if (arg%has_literal ()) then
          write (u, "('(')", advance="no")
          call arg%write_as_expression (u, indent)
          write (u, "(')')", advance="no")
       else
          call arg%write_as_expression (u, indent)
       end if
    else
       write (u, "(A)", advance="no") "???"
    end if
  end subroutine minus_write_expression

@ %def minus_write_expression
@
\subsubsection{Queries}
Priority value.
<<Integer: minus: TBP>>=
  procedure :: get_priority => minus_get_priority
<<Integer: procedures>>=
  pure function minus_get_priority (object) result (priority)
    class(minus_t), intent(in) :: object
    integer :: priority
    priority = PRIO_MINUS
  end function minus_get_priority
  
@ %def minus_get_priority
@ The operator name is the $-$ sign.
<<Integer: minus: TBP>>=
  procedure :: get_opname => minus_get_opname
<<Integer: procedures>>=
  pure function minus_get_opname (object, i) result (name)
    class(minus_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    name = "-"
  end function minus_get_opname
    
@ %def minus_get_opname
@
\subsubsection{Construction}
Instantiate: we have to initialize, so the core and argument types are fixed.
<<Integer: minus: TBP>>=
  procedure :: instantiate => minus_instantiate
<<Integer: procedures>>=
  subroutine minus_instantiate (object, instance)
    class(minus_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (minus_t :: instance)
    select type (instance)
    class is (minus_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine minus_instantiate
  
@ %def minus_instantiate
@ Initialize: We need the [[integer]] prototype for initializing the core.
Arguments are minus allocated, this requires a call to the [[init_args]]
method.
<<Integer: integer unary: TBP>>=
  generic :: init => integer_unary_init
  procedure, private :: integer_unary_init
<<Integer: procedures>>=
  subroutine integer_unary_init (object, prototype, name, mode)
    class(integer_unary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (name, mode = mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine integer_unary_init
  
@ %def integer_unary_init 
@ Initialize: one argument, no extra members.  We need the [[integer]]
prototype for initializing core and argument.  If this is minus an instance, we
also declare the prototype for the object itself.
<<Integer: minus: TBP>>=
  generic :: init => minus_init
  procedure, private :: minus_init
<<Integer: procedures>>=
  subroutine minus_init (object, prototype, mode)
    class(minus_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call integer_unary_init (object, prototype, var_str ("minus"), mode)
  end subroutine minus_init
  
@ %def minus_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type integer.
<<Integer: integer unary: TBP>>=
  procedure :: resolve => integer_unary_resolve
<<Integer: procedures>>=
  recursive subroutine integer_unary_resolve (object, success)
    class(integer_unary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    success = .false.
    object%res => null ()
    object%arg => null ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (integer_t)
       object%res => core
    class default
       return
    end select
    if (object%has_value ()) then
       call object%get_member_ptr (1, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (integer_t)
             object%arg => core
             success = .true.
          end select
       end select
    end if
  end subroutine integer_unary_resolve
  
@ %def integer_unary_resolve
@ Evaluate the operation.
<<Integer: minus: TBP>>=
  procedure :: evaluate => minus_evaluate
<<Integer: procedures>>=
  recursive subroutine minus_evaluate (object)
    class(minus_t), intent(inout), target :: object
    call object%composite_t%evaluate ()
    if (object%arg%is_defined ()) then
       call object%res%init (- object%arg%value)
    else
       call object%res%init ()
    end if
  end subroutine minus_evaluate
  
@ %def minus_evaluate
@ 
\subsection{Operators: multiply, add}
The [[multiply]] and [[add]] operators are binary operators.  Both arguments and
result are of type [[integer_t]].  We define pointer shortcuts for both
arguments and result.  Furthermore, the [[inverse]] flag replaces a specific
argument by its inverse, replacing $+$ by $-$, and $*$ by $/$.
<<Integer: public>>=
  public :: integer_binary_t
<<Integer: types>>=
  type, extends (operator_binary_t), abstract :: integer_binary_t
     private
     type(integer_t), pointer :: res => null ()
     type(integer_p), dimension(:), allocatable :: arg_ptr
     logical, dimension(:), allocatable :: inverse
   contains
   <<Integer: integer binary: TBP>>
  end type integer_binary_t

@ %def integer_binary_t
<<Integer: public>>=
  public :: multiply_t
  public :: add_t
<<Integer: types>>=
  type, extends (integer_binary_t) :: multiply_t
     private
   contains
   <<Integer: multiply: TBP>>
  end type multiply_t
  
  type, extends (integer_binary_t) :: add_t
     private
   contains
   <<Integer: add: TBP>>
  end type add_t
  
@ %def multiply_t
@ %def add_t
@
\subsubsection{Output}
The output routine for integer binary operators is a slight modification of
the generic output routine.  We have to put extra brackets around negative
numerical literals and [[minus]] expressions as argument.
<<Integer: integer binary: TBP>>=
  procedure :: write_expression => integer_binary_write_expression
<<Integer: procedures>>=
  recursive subroutine integer_binary_write_expression (object, unit, indent)
    class(integer_binary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg, core
    integer :: u, priority, i
    logical :: paren
    u = given_output_unit (unit)
    priority = object%get_priority ()
    do i = 1, object%get_n_members ()
       if (i > 1) then
          write (u, "(1x,A,1x)", advance="no")  char (object%get_opname (i))
       end if
       call object%get_member_ptr (i, arg)
       if (associated (arg)) then
          paren = .false.
          arg => arg%dereference ()
          select type (arg)
          class is (minus_t)
             paren = i > 1
          class is (composite_t)
             call arg%get_core_ptr (core)
             select type (core)
             type is (integer_t);  paren = core%value < 0
             end select
          end select
          if (paren)  write (u, "('(')", advance="no")
          call arg%write_as_expression (unit, indent, priority=priority)
          if (paren)  write (u, "(')')", advance="no")
       else
          write (u, "(A)", advance="no") "???"
       end if
    end do
  end subroutine integer_binary_write_expression

@ %def integer_binary_write_expression
@
\subsubsection{Queries}
Priority value.
<<Integer: multiply: TBP>>=
  procedure :: get_priority => multiply_get_priority
<<Integer: add: TBP>>=
  procedure :: get_priority => add_get_priority
<<Integer: procedures>>=
  pure function multiply_get_priority (object) result (priority)
    class(multiply_t), intent(in) :: object
    integer :: priority
    priority = PRIO_MULTIPLY
  end function multiply_get_priority
  
  pure function add_get_priority (object) result (priority)
    class(add_t), intent(in) :: object
    integer :: priority
    priority = PRIO_ADD
  end function add_get_priority
  
@ %def multiply_get_priority
@ %def add_get_priority
@ The operator name is replaced by the appropriate sign for arithmetic
operation.
<<Integer: integer binary: TBP>>=
  procedure :: show_opname => integer_binary_show_opname
<<Integer: procedures>>=
  pure function integer_binary_show_opname (object, i) result (flag)
    class(integer_binary_t), intent(in) :: object
    integer, intent(in), optional :: i
    logical :: flag
    if (present (i)) then
       flag = i > 1
    else
       flag = .false.
    end if
  end function integer_binary_show_opname
  
@ %def integer_binary_show_opname
<<Integer: multiply: TBP>>=
  procedure :: get_opname => multiply_get_opname
<<Integer: add: TBP>>=
  procedure :: get_opname => add_get_opname
<<Integer: procedures>>=
  pure function multiply_get_opname (object, i) result (name)
    class(multiply_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    if (object%inverse(i)) then
       name = "/"
    else
       name = "*"
    end if
  end function multiply_get_opname
    
  pure function add_get_opname (object, i) result (name)
    class(add_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    if (object%inverse(i)) then
       name = "-"
    else
       name = "+"
    end if
  end function add_get_opname
    
@ %def multiply_get_opname
@ %def add_get_opname
@
\subsubsection{Construction}
Instantiate: initialize using the generic integer binary initializer.  The
number of arguments is not yet known, we just initialize the core.
<<Integer: multiply: TBP>>=
  procedure :: instantiate => multiply_instantiate
<<Integer: add: TBP>>=
  procedure :: instantiate => add_instantiate
<<Integer: procedures>>=
  subroutine multiply_instantiate (object, instance)
    class(multiply_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (multiply_t :: instance)
    select type (instance)
    type is (multiply_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine multiply_instantiate
  
  subroutine add_instantiate (object, instance)
    class(add_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (add_t :: instance)
    select type (instance)
    type is (add_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine add_instantiate
  
@ %def multiply_instantiate
@ %def add_instantiate
@ Initialize: We need the [[integer]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Integer: integer binary: TBP>>=
  generic :: init => integer_binary_init
  procedure, private :: integer_binary_init
<<Integer: procedures>>=
  subroutine integer_binary_init (object, prototype, name, mode)
    class(integer_binary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (name, mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine integer_binary_init
  
@ %def integer_binary_init 
@ The [[init_members]] method has to allocate the [[inverse]] flag in addition
to the default initialization.
<<Integer: integer binary: TBP>>=
  procedure :: init_members => integer_binary_init_members
<<Integer: procedures>>=
  subroutine integer_binary_init_members (object, n_members, n_arguments)
    class(integer_binary_t), intent(inout), target :: object
    integer, intent(in) :: n_members
    integer, intent(in), optional :: n_arguments
    call object%composite_t%init_members (n_members, n_arguments)
    allocate (object%inverse (n_members), source = .false.)
  end subroutine integer_binary_init_members

@ %def integer_binary_init_members
@ Tag a specific argument by the [[inverse]] flag.  This replaces
multiplication by division, and addition by subtraction, respectively.  The
argument index should be greater than one.
<<Integer: integer binary: TBP>>=
  procedure :: tag_inverse => integer_binary_tag_inverse
<<Integer: procedures>>=
  subroutine integer_binary_tag_inverse (object, i, inverse)
    class(integer_binary_t), intent(inout) :: object
    integer, intent(in) :: i
    logical, intent(in) :: inverse
    object%inverse(i) = inverse
  end subroutine integer_binary_tag_inverse
  
@ %def integer_binary_tag_inverse
@ Specific initializers.
<<Integer: multiply: TBP>>=
  generic :: init => multiply_init
  procedure, private :: multiply_init
<<Integer: add: TBP>>=
  generic :: init => add_init
  procedure, private :: add_init
<<Integer: procedures>>=
  subroutine multiply_init (object, prototype, mode)
    class(multiply_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call integer_binary_init (object, prototype, var_str ("multiply"), mode)
  end subroutine multiply_init
  
  subroutine add_init (object, prototype, mode)
    class(add_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    call integer_binary_init (object, prototype, var_str ("add"), mode)
  end subroutine add_init
  
@ %def multiply_init 
@ %def add_init 
@
\subsection{Decoding}
For integer binary operators, we need to store the values of the [[inverse]]
flags for all arguments.  We do this right after the main code line.  The code
is a sequence of logical flags, true for inverse.  It occupies the place of
the object-name code of ordinary composites.
<<Integer: integer binary: TBP>>=
  procedure :: get_code => integer_binary_get_code
<<Integer: procedures>>=
  function integer_binary_get_code (object, repository) result (code)
    class(integer_binary_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
    call code%create_logical_val (object%inverse)
  end function integer_binary_get_code
  
@ %def integer_binary_get_code
@ Build object from code: we set the number of arguments and fetch the
[[inverse]] flag array.
<<Integer: integer binary: TBP>>=
  procedure :: init_from_code => integer_binary_init_from_code
<<Integer: procedures>>=
  subroutine integer_binary_init_from_code (object, code)
    class(integer_binary_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    logical :: success
    call object%set_mode (mode = code%get_att (2))
    call object%init_args (n_arg = code%get_att (5))
    call object%set_intrinsic (intrinsic = code%get_att (3) == 0)
    call code%get_logical_array (object%inverse, success)
    if (.not. success)  call msg_bug &
         ("Sindarin: error in byte code for integer binary operator")
  end subroutine integer_binary_init_from_code

@ %def integer_binary_init_from_code
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type integer, otherwise the routine is universal for binary operators.
<<Integer: integer binary: TBP>>=
  procedure :: resolve => integer_binary_resolve
<<Integer: procedures>>=
  recursive subroutine integer_binary_resolve (object, success)
    class(integer_binary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    integer :: i, n_args
    success = .false.
    object%res => null ()
    n_args = object%get_n_members ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (integer_t)
       object%res => core
    class default
       return
    end select
    if (.not. allocated (object%arg_ptr)) &
         allocate (object%arg_ptr (n_args))
    if (object%has_value ()) then
       do i = 1, n_args
          call object%get_member_ptr (i, arg)
          call arg%resolve (success);  if (.not. success)  return
          select type (arg)
          class is (wrapper_t)
             call arg%get_core_ptr (core)
             select type (core)
             type is (integer_t)
                call object%arg_ptr(i)%associate (core)
                success = .true.
             end select
          end select
       end do
    end if
  end subroutine integer_binary_resolve
  
@ %def integer_binary_resolve
@ Evaluate the operation.  Respect the [[inverse]] flag for each argument
except the first one.  Division by zero should result in an undefined result.
<<Integer: multiply: TBP>>=
  procedure :: evaluate => multiply_evaluate
<<Integer: add: TBP>>=
  procedure :: evaluate => add_evaluate
<<Integer: procedures>>=
  recursive subroutine multiply_evaluate (object)
    class(multiply_t), intent(inout), target :: object
    integer :: i
    integer :: val, res
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    res = object%arg_ptr(1)%get_value ()
    do i = 2, size (object%arg_ptr)
       val = object%arg_ptr(i)%get_value ()
       if (object%inverse(i)) then
          if (val == 0) then
             call object%res%init ()
             return
          else
             res = res / val
          end if
       else
          res = res * val
       end if
    end do
    call object%res%init (res)
  end subroutine multiply_evaluate
  
  recursive subroutine add_evaluate (object)
    class(add_t), intent(inout), target :: object
    integer :: i
    integer :: val, res
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    res = object%arg_ptr(1)%get_value ()
    do i = 2, size (object%arg_ptr)
       val = object%arg_ptr(i)%get_value ()
       if (object%inverse(i)) then
          res = res - val
       else
          res = res + val
       end if
    end do
    call object%res%init (res)
  end subroutine add_evaluate
  
@ %def multiply_evaluate
@ %def add_evaluate
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_integer_ut.f90]]>>=
<<File header>>

module object_integer_ut

  use unit_tests
  use object_integer_uti
  
<<Standard module head>>

<<Integer: public test>>

contains
  
<<Integer: test driver>>

end module object_integer_ut
@ %def object_integer_ut
@ 
<<[[object_integer_uti.f90]]>>=
<<File header>>

module object_integer_uti
  
  <<Use strings>>
    use io_units
    use codes
    use object_base
    use object_expr
    use object_logical

    use object_integer

<<Standard module head>>

<<Integer: test declarations>>

contains
  
<<Integer: tests>>

<<Integer: test auxiliary>>

end module object_integer_uti
@ %def object_integer_uti
@ API: driver for the unit tests below.
<<Integer: public test>>=
  public :: object_integer_test
<<Integer: test driver>>=
  subroutine object_integer_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Integer: execute tests>>  
  end subroutine object_integer_test
  
@ %def object_integer_test 
@
\subsubsection{Manual initialization}
Shortcut to member initialization.  This routine is used only in the unit
tests below.
<<Integer: public test auxiliary>>=
  public :: init_members
<<Integer: test auxiliary>>=
  subroutine init_members (object, n_arg)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    select type (object)
    class is (operator_t)
       call object%init_args (n_arg)
    end select
  end subroutine init_members
    
@ %def init_members
@ Set the member value directly.  This routine is used only in the unit tests
below.
<<Integer: public test auxiliary>>=
  public :: set_member_val
<<Integer: test auxiliary>>=
  subroutine set_member_val (object, i, value, inverse)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    integer, intent(in), optional :: value
    logical, intent(in), optional :: inverse
    class(object_t), pointer :: member, core
    class(composite_t), pointer :: prototype
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "i"
       case (2);  name = "j"
       case (3);  name = "k"
       case (4);  name = "l"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       call object%get_prototype_ptr (prototype)
       call prototype%instantiate (member)
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (integer_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
    if (present (inverse)) then
       select type (object)
       class is (integer_binary_t)
          call object%tag_inverse (i, inverse)
       end select
    end if
  end subroutine set_member_val
    
@ %def set_member_val
@
\subsubsection{Values}
Create integer objects.
<<Integer: execute tests>>=
  call test (object_integer_1, "object_integer_1", &
       "values", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_1
<<Integer: tests>>=  
  subroutine object_integer_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: bare_integer, core
    class(object_t), pointer :: prototype, pos, neg, zero, undef

    write (u, "(A)")  "* Test output: object_integer_1"
    write (u, "(A)")  "*   Purpose: construct integer value objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Integer objects: prototype"

    allocate (integer_t :: bare_integer)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("integer"))
       call prototype%import_core (bare_integer)
    end select

    write (u, "(A)")
    call prototype%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Integer objects: zero, positive, negative, undefined"

    call prototype%instantiate (pos)
    select type (pos)
    type is (composite_t)
       call pos%init (mode = MODE_CONSTANT, name = var_str ("pos"))
       allocate (integer_t :: core)
       select type (core)
       type is (integer_t);  call core%init (value = 42)
       end select
       call pos%import_core (core)
    end select

    call prototype%instantiate (neg)
    select type (neg)
    type is (composite_t)
       call neg%init (mode = MODE_CONSTANT, name = var_str ("neg"))
       allocate (integer_t :: core)
       select type (core)
       type is (integer_t);  call core%init (value = -1234567890)
       end select
       call neg%import_core (core)
    end select

    call prototype%instantiate (zero)
    select type (zero)
    type is (composite_t)
       call zero%init (mode = MODE_CONSTANT, name = var_str ("zero"))
       allocate (integer_t :: core)
       select type (core)
       type is (integer_t);  call core%init (value = 0)
       end select
       call zero%import_core (core)
    end select

    call prototype%instantiate (undef)
    select type (undef)
    type is (composite_t)
       call undef%init (mode = MODE_CONSTANT, name = var_str ("undef"))
       allocate (integer_t :: core)
       call undef%import_core (core)
    end select

    write (u, "(A)")
    call pos%write (u)
    call neg%write (u)
    call zero%write (u)
    call undef%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (undef)
    call remove_object (pos)
    call remove_object (neg)
    call remove_object (zero)
    call remove_object (prototype)
    call remove_object (bare_integer)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_1"
    
  end subroutine object_integer_1

@ %def object_integer_1
@ 
\subsubsection{Atomic assignment}
Perform assignments of elementary integers.
<<Integer: execute tests>>=
  call test (object_integer_2, "object_integer_2", &
       "assignment", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_2
<<Integer: tests>>=  
  subroutine object_integer_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core, rhs
    class(object_t), pointer :: prototype, v1, v2, ival1, ival2, ival3
    type(assignment_t) :: asg
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_2"
    write (u, "(A)")  "*   Purpose: assignments"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Create objects"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    call prototype%instantiate (v1)
    select type (v1)
    type is (composite_t)
       call v1%init (mode = MODE_CONSTANT, name = var_str ("v1"))
       allocate (integer_t :: core)
       select type (core)
       type is (integer_t);  call core%init (value = 12)
       end select
       call v1%import_core (core)
    end select

    call prototype%instantiate (v2)
    select type (v2)
    type is (composite_t)
       call v2%init (mode = MODE_CONSTANT, name = var_str ("v2"))
       allocate (integer_t :: core)
       select type (core)
       type is (integer_t);  call core%init (value = -177)
       end select
       call v2%import_core (core)
    end select

    call prototype%instantiate (ival1)
    select type (ival1)
    type is (composite_t)
       call ival1%init (mode = MODE_VARIABLE, name = var_str ("ival1"))
    end select
    
    call prototype%instantiate (ival2)
    select type (ival2)
    type is (composite_t)
       call ival2%init (mode = MODE_VARIABLE, name = var_str ("ival2"))
    end select
    
    call prototype%instantiate (ival3)
    select type (ival3)
    type is (composite_t)
       call ival3%init (mode = MODE_VARIABLE, name = var_str ("ival3"))
    end select
    
    write (u, "(A)")
    call v1%write (u)
    call v2%write (u)

    write (u, "(A)")
    call ival1%write_as_declaration (u)
    call ival2%write_as_declaration (u)
    call ival3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* ival1 = v1"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (ival1)
    call asg%set_rhs (v1, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call ival1%write_as_declaration (u)
    call ival2%write_as_declaration (u)
    call ival3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* ival2 = v2"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (ival2)
    call asg%set_rhs (v2, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()
    
    write (u, "(A)")
    call ival1%write_as_declaration (u)
    call ival2%write_as_declaration (u)
    call ival3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* ival2 = ival1"
  
    rhs => ival1
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (ival2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call ival1%write_as_declaration (u)
    call ival2%write_as_declaration (u)
    call ival3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* ival2 = ival3"
  
    rhs => ival3
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (ival2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call ival1%write_as_declaration (u)
    call ival2%write_as_declaration (u)
    call ival3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (ival1)
    call remove_object (ival2)
    call remove_object (ival3)
    call remove_object (v1)
    call remove_object (v2)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_2"
    
  end subroutine object_integer_2

@ %def object_integer_2
@ 
\subsubsection{Composite assignment}
Perform assignments of composites with elementary integer core.
<<Integer: execute tests>>=
  call test (object_integer_3, "object_integer_3", &
       "composite assignment", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_3
<<Integer: tests>>=  
  subroutine object_integer_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: prototype, proto2, main, val, core, rhs, asg
    type(object_iterator_t) :: it
    class(object_t), pointer :: object
    type(code_t) :: code
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_3"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("val"))
    end select
    
    call setup_assignment ()
    write (u, "(A)")
    write (u, "(A)")  "* Assignment object"
    write (u, "(A)")
    call asg%write (u)

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Main object"
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Check mode/type mismatch"

    call remove_object (main)

    allocate (composite_t :: proto2)
    select type (proto2)
    type is (composite_t)
       call proto2%init (var_str ("logical"))
       allocate (logical_t :: core)
       call proto2%import_core (core)
    end select

    call proto2%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (name = var_str ("val"), mode = MODE_CONSTANT)
    end select
   
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%resolve (success)
       call main%evaluate ()
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (proto2)
    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_3"
    
  contains
      
    subroutine setup_assignment
      allocate (assignment_t :: asg)
      select type (asg)
      type is (assignment_t)
         call prototype%instantiate (rhs)
         select type (rhs)
         type is (composite_t)
            call rhs%init (mode=MODE_CONSTANT, name=var_str ("rhs"))
            call rhs%get_core_ptr (core)
            select type (core)
            type is (integer_t)
               call core%init (value = 42)
            end select
         end select
         call asg%init (MODE=MODE_CONSTANT)
         call asg%set_path ([var_str ("val")])
         call asg%set_rhs (rhs=rhs, link=.false.)
      end select
    end subroutine setup_assignment

  end subroutine object_integer_3

@ %def object_integer_3
@ 
\subsubsection{Operators: minus}
Now the test for [[minus]].
<<Integer: execute tests>>=
  call test (object_integer_4, "object_integer_4", &
       "operator: minus", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_4
<<Integer: tests>>=  
  subroutine object_integer_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: minus, expr1, expr2, expr3
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_4"
    write (u, "(A)")  "*   Purpose: check integer operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: minus"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (minus_t :: minus)
    select type (minus)
    type is (minus_t)
       call minus%init (prototype)
    end select
    
    write (u, "(A)")
    call minus%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"

    write (u, "(A)")
    
    call minus%instantiate (expr1)
    call init_members (expr1, 1)
    call set_member_val (expr1, 1, 42)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call minus%instantiate (expr2)
    call init_members (expr2, 1)
    call set_member_val (expr2, 1, -1234567890)
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call minus%instantiate (expr3)
    call init_members (expr3, 1)
    call set_member_val (expr3, 1)
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u);  write (u, *)
    call expr2%write_as_expression (u);  write (u, *)
    call expr3%write_as_expression (u);  write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (minus)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_4"
    
  end subroutine object_integer_4

@ %def object_integer_4
@ 
\subsubsection{Operators: multiply}
Build and evaluate simple integer expressions.
<<Integer: execute tests>>=
  call test (object_integer_5, "object_integer_5", &
       "operator: multiply", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_5
<<Integer: tests>>=  
  subroutine object_integer_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: multiply
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_5"
    write (u, "(A)")  "*   Purpose: check integer operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: multiply"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (multiply_t :: multiply)
    select type (multiply)
    type is (multiply_t)
       call multiply%init (prototype)
    end select
    
    write (u, "(A)")
    call multiply%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call multiply%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, 2)
    call set_member_val (expr1, 2, 3) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, 2)
    call set_member_val (expr2, 2, 0) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, 2)
    call set_member_val (expr3, 2, -2) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr4)
    call init_members (expr4, 3)
    call set_member_val (expr4, 1, 2)
    call set_member_val (expr4, 2, 3) 
    call set_member_val (expr4, 3, 5) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr5)
    call init_members (expr5, 3)
    call set_member_val (expr5, 1, -2)
    call set_member_val (expr5, 2, 3) 
    call set_member_val (expr5, 3, 5) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr6)
    call init_members (expr6, 3)
    call set_member_val (expr6, 1, -2)
    call set_member_val (expr6, 2) 
    call set_member_val (expr6, 3, 5) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (multiply)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_5"
    
  end subroutine object_integer_5

@ %def object_integer_5
@ 
\subsubsection{Operators: multiply and divide}
Build and evaluate simple integer expressions.
<<Integer: execute tests>>=
  call test (object_integer_6, "object_integer_6", &
       "operator: multiply and divide", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_6
<<Integer: tests>>=  
  subroutine object_integer_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: multiply
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    class(object_t), pointer :: expr8, expr9, arg1, arg2
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_6"
    write (u, "(A)")  "*   Purpose: check integer operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: multiply"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (multiply_t :: multiply)
    select type (multiply)
    type is (multiply_t)
       call multiply%init (prototype)
    end select
    
    write (u, "(A)")
    call multiply%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call multiply%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, 4)
    call set_member_val (expr1, 2, 2, inverse=.true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, 2)
    call set_member_val (expr2, 2, 3, inverse=.true.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, 2)
    call set_member_val (expr3, 2, -2, inverse=.true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, 2)
    call set_member_val (expr4, 2, 0, inverse=.true.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr5)
    call init_members (expr5, 3)
    call set_member_val (expr5, 1, 24)
    call set_member_val (expr5, 2, 3, inverse=.true.) 
    call set_member_val (expr5, 3, 4) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr6)
    call init_members (expr6, 2)
    select type (expr6)
    class is (composite_t)
       call multiply%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, 24)
       call set_member_val (arg1, 2, 3, inverse=.true.) 
       call expr6%import_member (1, arg1)
    end select
    call set_member_val (expr6, 2, 4) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr7)
    call init_members (expr7, 2)
    call set_member_val (expr7, 1, 24)
    select type (expr7)
    class is (composite_t)
       call multiply%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, 3) 
       call set_member_val (arg2, 2, 4) 
       call expr7%import_member (2, arg2)
    end select
    select type (expr7)
    class is (integer_binary_t)
       call expr7%tag_inverse (2, .true.)
    end select
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr8)
    call init_members (expr8, 3)
    call set_member_val (expr8, 1, 24)
    call set_member_val (expr8, 2, 3, inverse=.true.) 
    call set_member_val (expr8, 3, 4, inverse=.true.) 
    call expr8%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr9)
    call init_members (expr9, 3)
    call set_member_val (expr9, 1, 24)
    call set_member_val (expr9, 2, inverse=.true.) 
    call set_member_val (expr9, 3, 4) 
    call expr9%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)
    call expr8%write_as_expression (u)
    write (u, *)
    call expr9%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()
    call expr8%evaluate ()
    call expr9%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)
    call expr8%write (u)
    call expr9%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)
    call expr8%write_as_value (u)
    write (u, *)
    call expr9%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (expr8)
    call remove_object (expr9)
    call remove_object (multiply)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_6"
    
  end subroutine object_integer_6

@ %def object_integer_6
@ 
\subsubsection{Operators: add}
Build and evaluate simple integer expressions.
<<Integer: execute tests>>=
  call test (object_integer_7, "object_integer_7", &
       "operator: add", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_7
<<Integer: tests>>=  
  subroutine object_integer_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: add
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_7"
    write (u, "(A)")  "*   Purpose: check integer operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: add"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (add_t :: add)
    select type (add)
    type is (add_t)
       call add%init (prototype)
    end select
    
    write (u, "(A)")
    call add%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call add%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, 2)
    call set_member_val (expr1, 2, 3) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, 2)
    call set_member_val (expr2, 2, 0) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, 2)
    call set_member_val (expr3, 2, -2) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr4)
    call init_members (expr4, 3)
    call set_member_val (expr4, 1, 2)
    call set_member_val (expr4, 2, 3) 
    call set_member_val (expr4, 3, 5) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr5)
    call init_members (expr5, 3)
    call set_member_val (expr5, 1, -2)
    call set_member_val (expr5, 2, 3) 
    call set_member_val (expr5, 3, 5) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr6)
    call init_members (expr6, 3)
    call set_member_val (expr6, 1, -2)
    call set_member_val (expr6, 2) 
    call set_member_val (expr6, 3, 5) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (add)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_7"
    
  end subroutine object_integer_7

@ %def object_integer_7
@ 
\subsubsection{Operators: add and subtract}
Build and evaluate simple integer expressions.
<<Integer: execute tests>>=
  call test (object_integer_8, "object_integer_8", &
       "operator: add and subtract", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_8
<<Integer: tests>>=  
  subroutine object_integer_8 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: add
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_8"
    write (u, "(A)")  "*   Purpose: check integer operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: add"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (add_t :: add)
    select type (add)
    type is (add_t)
       call add%init (prototype)
    end select
    
    write (u, "(A)")
    call add%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call add%instantiate (expr1)
    call init_members (expr1, 2)
    call set_member_val (expr1, 1, 4)
    call set_member_val (expr1, 2, 2, inverse=.true.) 
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr2)
    call init_members (expr2, 2)
    call set_member_val (expr2, 1, 2)
    call set_member_val (expr2, 2, 3, inverse=.true.) 
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, 2)
    call set_member_val (expr3, 2, -2, inverse=.true.) 
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr4)
    call init_members (expr4, 2)
    call set_member_val (expr4, 1, 2)
    call set_member_val (expr4, 2, 0, inverse=.true.) 
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr5)
    call init_members (expr5, 3)
    call set_member_val (expr5, 1, 24)
    call set_member_val (expr5, 2, 3, inverse=.true.) 
    call set_member_val (expr5, 3, 4) 
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr6)
    call init_members (expr6, 3)
    call set_member_val (expr6, 1, 24)
    call set_member_val (expr6, 2, 3, inverse=.true.) 
    call set_member_val (expr6, 3, 4, inverse=.true.) 
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr7)
    call init_members (expr7, 3)
    call set_member_val (expr7, 1, 24)
    call set_member_val (expr7, 2, inverse=.true.) 
    call set_member_val (expr7, 3, 4) 
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (add)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_8"
    
  end subroutine object_integer_8

@ %def object_integer_8
@ 
\subsubsection{Operators: nested expression}
Build and evaluate simple integer expressions.
<<Integer: execute tests>>=
  call test (object_integer_9, "object_integer_9", &
       "nested expressions", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_9
<<Integer: tests>>=  
  subroutine object_integer_9 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype
    class(object_t), pointer :: minus, multiply, add
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5
    class(object_t), pointer :: arg1, arg2, arg3
    logical :: success

    write (u, "(A)")  "* Test output: object_integer_9"
    write (u, "(A)")  "*   Purpose: check nested integer expressions"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototypes: minus, multiply, add"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("integer"))
       allocate (integer_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (minus_t :: minus)
    select type (minus)
    type is (minus_t)
       call minus%init (prototype)
    end select
    
    allocate (multiply_t :: multiply)
    select type (multiply)
    type is (multiply_t)
       call multiply%init (prototype)
    end select
    
    allocate (add_t :: add)
    select type (add)
    type is (add_t)
       call add%init (prototype)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call multiply%instantiate (expr1)
    call init_members (expr1, 2)
    select type (expr1)
    class is (composite_t)
       call minus%instantiate (arg1)
       call init_members (arg1, 1)
       call set_member_val (arg1, 1, -4)
       call expr1%import_member (1, arg1)
    end select
    call set_member_val (expr1, 2, 25)
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call minus%instantiate (expr2)
    call init_members (expr2, 1)
    select type (expr2)
    class is (composite_t)
       call multiply%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, -4)
       call set_member_val (arg1, 2, 25)
       call expr2%import_member (1, arg1)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr3)
    call init_members (expr3, 2)
    call set_member_val (expr3, 1, 12)
    select type (expr3)
    class is (composite_t)
       call add%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, 5)
       call set_member_val (arg2, 2, 3, inverse=.true.)
       call expr3%import_member (2, arg2)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call add%instantiate (expr4)
    call init_members (expr4, 2)
    select type (expr4)
    class is (composite_t)
       call multiply%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, 12)
       call set_member_val (arg1, 2, 5)
       call expr4%import_member (1, arg1)
    end select
    call set_member_val (expr4, 2, 3, inverse=.true.)
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call multiply%instantiate (expr5)
    call init_members (expr5, 2)
    select type (expr5)
    class is (composite_t)
       call add%instantiate (arg1)
       call init_members (arg1, 2)
       call set_member_val (arg1, 1, 5)
       call set_member_val (arg1, 2, 3)
       call expr5%import_member (1, arg1)
       call add%instantiate (arg2)
       call init_members (arg2, 2)
       call set_member_val (arg2, 1, 5)
       select type (arg2)
       class is (composite_t)
          call minus%instantiate (arg3)
          call init_members (arg3, 1)
          call set_member_val (arg3, 1, 3)
          call arg2%import_member (2, arg3)
       end select
       call expr5%import_member (2, arg2)
    end select
    select type (expr5)
    class is (integer_binary_t)
       call expr5%tag_inverse (2, .true.)
    end select
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (multiply)
    call remove_object (add)
    call remove_object (minus)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_9"
    
  end subroutine object_integer_9

@ %def object_integer_9
@ 
\subsubsection{Code: not}
Construct integer expressions from bytecode.
<<Integer: execute tests>>=
  call test (object_integer_10, "object_integer_10", &
       "build expressions from code", &
       u, results)
<<Integer: test declarations>>=
  public :: object_integer_10
<<Integer: tests>>=  
  subroutine object_integer_10 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    class(object_t), pointer :: p_int, p_minus, p_mult, p_add
    class(object_t), pointer :: core, main, object
    class(object_t), pointer :: val1, val2, expr
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_integer_10"
    write (u, "(A)")  "*   Purpose: construct expressions from code"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_int)
    select type (p_int)
    type is (composite_t)
       call p_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call p_int%import_core (core)
    end select

    allocate (minus_t :: p_minus)
    select type (p_minus)
    type is (minus_t)
       call p_minus%init (p_int)
    end select

    allocate (multiply_t :: p_mult)
    select type (p_mult)
    type is (multiply_t)
       call p_mult%init (p_int)
    end select

    allocate (add_t :: p_add)
    select type (p_add)
    type is (add_t)
       call p_add%init (p_int)
    end select

    call repository%init (name = var_str ("repository"), n_members = 4)
    call repository%import_member (1, p_int)
    call repository%import_member (2, p_minus)
    call repository%import_member (3, p_mult)
    call repository%import_member (4, p_add)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: minus"
    

    call repository%spawn (var_str ("integer"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_two"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (integer_t)
          call core%init (2)
       end select
    end select

    call repository%spawn (var_str ("minus"), expr)
    select type (expr)
    class is (minus_t)
       call expr%init_args (1)
       call expr%import_member (1, val1)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 4
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: multiply"

    call remove_object (object)

    call repository%spawn (var_str ("integer"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_two"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (integer_t)
          call core%init (2)
       end select
    end select

    call repository%spawn (var_str ("integer"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_three"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (integer_t)
          call core%init (3)
       end select
    end select

    call repository%spawn (var_str ("multiply"), expr)
    select type (expr)
    class is (multiply_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: add"

    call remove_object (object)

    call repository%spawn (var_str ("integer"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_two"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (integer_t)
          call core%init (2)
       end select
    end select

    call repository%spawn (var_str ("integer"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_three"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (integer_t)
          call core%init (3)
       end select
    end select

    call repository%spawn (var_str ("add"), expr)
    select type (expr)
    class is (add_t)
       call expr%init_args (2)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
       call expr%tag_inverse (2, .true.)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_integer_10"

  end subroutine object_integer_10

@ %def object_integer_10
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Containers}
This section defines container objects for arrays, lists and such.
<<[[object_container.f90]]>>=
<<File header>>

module object_container

<<Use strings>>
  use format_utils
  use io_units
  use diagnostics

  use codes
  use object_base
  use object_builder
  use object_expr
  use object_logical
  use object_integer

<<Standard module head>>

<<Containers: public>>

<<Containers: types>>

contains

<<Containers: procedures>>

end module object_container
@ %def object_container
@ 
\subsection{Container operator}
We introduce a generic container operator.  The operator is actually a
constructor for a generic array.  The container operator fetches its
arguments, i.e., objects that are concatenated syntactically by one of the
signs '[[:]]' (tuple), '[[,]]' (list), or '[[=>]]' (sequence), and transforms
then into a value object.  The value object, internally, is a generic array of
non-uniform type, since we do not require type uniformity for the operator
arguments.

The [[ctype]] component distinguishes the operator signs.

A container can also store the data for configuring a range
expression.  In that case, there must be exactly three members for
start, end, and step.  The step format is stored via the [[stype]]
component.
<<Containers: public>>=
  public :: container_t
<<Containers: types>>=
  type, extends (operator_binary_t) :: container_t
     private
     integer :: ctype = 0
     integer :: stype = 0
   contains
   <<Containers: container: TBP>>
end type container_t

@ %def container_t
@ Write the core in expression form.
<<Containers: container: TBP>>=
  procedure :: write_core => container_write_core
<<Containers: procedures>>=
  recursive subroutine container_write_core (object, unit, indent)
    class(container_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    class(object_t), pointer :: core
    integer :: u
    u = given_output_unit (unit)
    call object%get_core_ptr (core)
    call core%write_as_expression (unit, indent)
  end subroutine container_write_core
       
@ %def container_write_core  
@ Value: for a container, there is no difference in display between value and
expression.  The subroutine writes the array items, separated by the
appropriate sign.  The spacing between items depends on the separator.
<<Containers: container: TBP>>=
  procedure :: write_value => container_write_value
<<Containers: procedures>>=
  recursive subroutine container_write_value (object, unit, indent)
    class(container_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    call object%write_expression (unit, indent)
  end subroutine container_write_value
    
@ %def container_write_value
@
\subsubsection{Queries}
Priority value.
<<Containers: container: TBP>>=
  procedure :: get_priority => container_get_priority
<<Containers: procedures>>=
  pure function container_get_priority (object) result (priority)
    class(container_t), intent(in) :: object
    integer :: priority
    select case (object%ctype)
    case (CT_TUPLE);    priority = PRIO_COLON
    case (CT_LIST);     priority = PRIO_COMMA
    case (CT_SEQUENCE); priority = PRIO_ARROW
    case default
       priority = 0
    end select
  end function container_get_priority
  
@ %def container_get_priority
@ The written prototype is [[container]], except if the core is not
associated.  In that case, it is [[object]].
<<Containers: container: TBP>>=
  procedure :: get_prototype => container_get_prototype
<<Containers: procedures>>=
  recursive function container_get_prototype (object) result (prototype)
    class(container_t), intent(in) :: object
    type(string_t) :: prototype
    class(object_t), pointer :: core
    call object%get_core_ptr (core)
    if (associated (core)) then
       prototype = "container"
    else
       prototype = "object"
    end if
  end function container_get_prototype
  
@ %def container_get_prototype
@ The operator name is replaced by the appropriate item-separator sign.  In
verbose display, we show the sign before all arguments.  The display
distinguishes between plain container (separator shown before first
member) and range container (separators shown between 1/2 and 2/3).
<<Containers: container: TBP>>=
  procedure :: show_opname => container_show_opname
  procedure :: get_opname => container_get_opname
<<Containers: procedures>>=
  pure function container_show_opname (object, i) result (flag)
    class(container_t), intent(in) :: object
    integer, intent(in), optional :: i
    logical :: flag
    if (present (i)) then
       select case (object%stype)
       case (0)
          flag = i == 1
       case default
          flag = i == 2 .or. i == 3
       end select
    else
       flag = .false.
    end if
  end function container_show_opname

  pure function container_get_opname (object, i) result (name)
    class(container_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    select case (object%stype)
    case (0)
       select case (object%ctype)
       case (CT_TUPLE);  name = ":"
       case (CT_LIST);  name = ","
       case (CT_SEQUENCE);  name = "=>"
       case default
          name = "?"
       end select
    case default
       if (i == 2) then
          name = "=>"
       else if (i == 3) then
          select case (object%stype)
          case (CT_ADD);  name = "/+"
          case (CT_SUB);  name = "/-"
          case (CT_MUL);  name = "/*"
          case (CT_DIV);  name = "//"
          case (CT_LIN);  name = "+/+"
          case (CT_LOG);  name = "*/*"
          case default
             name = "?"
          end select
       else
          name = "?"
       end if
    end select
  end function container_get_opname

@ %def container_show_opname
@ %def container_get_opname
@ The spacing conventions for the list separator symbols.
<<Containers: container: TBP>>=
  procedure :: space_left => container_space_left
  procedure :: space_right => container_space_right
<<Containers: procedures>>=
  function container_space_left (object) result (flag)
    class(container_t), intent(in) :: object
    logical :: flag
    select case (object%ctype)
    case (CT_TUPLE);    flag = .false.
    case (CT_LIST);     flag = .false.
    case (CT_SEQUENCE); flag = .true.
    case default
       flag = .false.
    end select
  end function container_space_left
  
  function container_space_right (object) result (flag)
    class(container_t), intent(in) :: object
    logical :: flag
    select case (object%ctype)
    case (CT_TUPLE);    flag = .false.
    case (CT_LIST);     flag = .true.
    case (CT_SEQUENCE); flag = .true.
    case default
       flag = .true.
    end select
  end function container_space_right
  
@ %def container_space_left
@ %def container_space_right
@
\subsubsection{Construction}
Instantiate.  The number of arguments is not yet known, so just allocate.
<<Containers: container: TBP>>=
  procedure :: instantiate => container_instantiate
<<Containers: procedures>>=
  subroutine container_instantiate (object, instance)
    class(container_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (container_t :: instance)
  end subroutine container_instantiate
  
@ %def container_instantiate
@ Initialize.  [[ctype]] is the container (sub)type, indicating tuple, list, or
sequence syntax.
<<Containers: container: TBP>>=
  generic :: init => container_init
  procedure, private :: container_init
<<Containers: procedures>>=
  subroutine container_init (object, ctype, name, mode)
    class(container_t), intent(inout) :: object
    integer, intent(in) :: ctype
    type(string_t), intent(in), optional :: name
    integer, intent(in), optional :: mode
    if (present (name)) then
       call object%composite_t%init (name, mode)
    else
       call object%composite_t%init (var_str ("container"), mode)
    end if
    object%ctype = ctype
  end subroutine container_init
  
@ %def container_init 
@ Set the step type, indicating that this container should hold a range.
<<Containers: container: TBP>>=
  procedure :: setup_range => container_setup_range
<<Containers: procedures>>=
  subroutine container_setup_range (object, stype)
    class(container_t), intent(inout) :: object
    integer, intent(in) :: stype
    object%stype = stype
  end subroutine container_setup_range
  
@ %def container_setup_range
@
\subsection{Decoding}
For the container operator, we need to store the appropriate container codes
for all arguments.  We do this right after the main code line.  The code is a
container of integers.  It occupies the place of the object-name code of
ordinary composites.

For a normal container, we store the separator code.  For a range
container, we store the step code, so we can simply reconstruct this when
decoding.
<<Containers: container: TBP>>=
  procedure :: get_code => container_get_code
<<Containers: procedures>>=
  function container_get_code (object, repository) result (code)
    class(container_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
    if (object%stype /= 0) then
       call code%create_integer_val ([object%stype])
    else
       call code%create_integer_val ([object%ctype])
    end if
  end function container_get_code
  
@ %def container_get_code
@ Build object from code: we set the number of arguments and fetch the
[[cmp_code]] array.
<<Containers: container: TBP>>=
  procedure :: init_from_code => container_init_from_code
<<Containers: procedures>>=
  subroutine container_init_from_code (object, code)
    class(container_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    logical :: success
    integer :: t
    call code%get_integer (t, success)
    if (.not. success)  call msg_bug &
         ("Sindarin: error in byte code for container operator")
    select case (t)
    case (CT_TUPLE, CT_LIST, CT_SEQUENCE)
       call object%init (t, mode = code%get_att (2))
    case (CT_ADD, CT_SUB, CT_MUL, CT_DIV, CT_LIN, CT_LOG)
       call object%init (CT_SEQUENCE, mode = code%get_att (2))
       call object%setup_range (t)
    case default
       call msg_bug ("Sindarin decoder: container: unknown separator code")
    end select
    call object%init_args (n_arg = code%get_att (5))
    call object%set_intrinsic (intrinsic = code%get_att (3) == 0)
  end subroutine container_init_from_code

@ %def container_init_from_code
@
\subsubsection{Evaluation}
Resolve: Link the references in the core to the member objects.  For
evaluation, we take the default binding.
<<Containers: container: TBP>>=
  procedure :: resolve => container_resolve
<<Containers: procedures>>=
  recursive subroutine container_resolve (object, success)
    class(container_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: item, core
    integer :: i, n_args
    success = .false.
    n_args = object%get_n_members ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (ref_array_t)
       do i = 1, n_args
          call object%get_member_ptr (i, item)
          call item%resolve (success);  if (.not. success)  return
          call core%associate (i, item)
       end do
    end select
  end subroutine container_resolve
  
@ %def container_resolve
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_container_ut.f90]]>>=
<<File header>>

module object_container_ut

  use unit_tests
  use object_container_uti
  
<<Standard module head>>

<<Containers: public test>>

contains
  
<<Containers: test driver>>

end module object_container_ut
@ %def object_container_ut
@ 
<<[[object_container_uti.f90]]>>=
<<File header>>

module object_container_uti
  
<<Use strings>>
  use io_units
  use codes
  use object_base
  use object_logical
  use object_integer

  use object_container

<<Standard module head>>

<<Containers: test declarations>>

contains

<<Containers: tests>>

<<Containers: test auxiliary>>
  
end module object_container_uti
@ %def object_container_uti
@ API: driver for the unit tests below.
<<Containers: public test>>=
  public :: object_container_test
<<Containers: test driver>>=
  subroutine object_container_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Containers: execute tests>>  
  end subroutine object_container_test
  
@ %def object_container_test 
@
\subsubsection{Manual initialization}
Init the container with a specific category code and number of items.
<<Containers: public test auxiliary>>=
  public :: init_container
<<Containers: test auxiliary>>=
  subroutine init_container (object, name, ctype, n_item)
    class(object_t), intent(inout) :: object
    type(string_t), intent(in) :: name
    integer, intent(in) :: ctype
    integer, intent(in) :: n_item
    class(object_t), pointer :: core
    allocate (ref_array_t :: core)
    select type (core)
    class is (ref_array_t)
       call core%init (n_item)
    end select
    select type (object)
    class is (container_t)
       call object%init (ctype, name, MODE_CONSTANT)
       call object%import_core (core)
       call object%init_args (n_item, check=.false.)
    end select
  end subroutine init_container
    
@ %def init_container
@ Init a container that holds exactly three members, suited for a
range expression with step type [[stype]].
<<Containers: public test auxiliary>>=
  public :: init_range_container
<<Containers: test auxiliary>>=
  subroutine init_range_container (object, name, stype)
    class(object_t), intent(inout) :: object
    type(string_t), intent(in) :: name
    integer, intent(in) :: stype
    class(object_t), pointer :: core
    allocate (ref_array_t :: core)
    select type (core)
    class is (ref_array_t)
       call core%init (3)
    end select
    select type (object)
    class is (container_t)
       call object%init (CT_SEQUENCE, name, MODE_CONSTANT)
       call object%setup_range (stype)
       call object%import_core (core)
       call object%init_args (3, check=.false.)
    end select
  end subroutine init_range_container
    
@ %def init_range_container
@ Set the member value directly to a [[logical]] composite with constant value.
<<Containers: public test auxiliary>>=
  public :: set_member_log
<<Containers: test auxiliary>>=
  subroutine set_member_log (object, i, prototype, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), target :: prototype
    logical, intent(in), optional :: value
    class(object_t), pointer :: member, core
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "item1"
       case (2);  name = "item2"
       case (3);  name = "item3"
       case (4);  name = "item4"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       select type (prototype)
       class is (composite_t)
          call prototype%instantiate (member)
       end select
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (logical_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
  end subroutine set_member_log
    
@ %def set_member_log
@ Set the member value directly to a [[integer]] composite with constant value.
<<Containers: public test auxiliary>>=
  public :: set_member_int
<<Containers: test auxiliary>>=
  subroutine set_member_int (object, i, prototype, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: value
    class(object_t), pointer :: member, core
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "item1"
       case (2);  name = "item2"
       case (3);  name = "item3"
       case (4);  name = "item4"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       select type (prototype)
       class is (composite_t)
          call prototype%instantiate (member)
       end select
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (integer_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
  end subroutine set_member_int
    
@ %def set_member_int
@ 
\subsubsection{Simple conteiners}
We manually construct some containers and display them.
<<Containers: execute tests>>=
  call test (object_container_1, "object_container_1", &
       "display containers", &
       u, results)
<<Containers: test declarations>>=
  public :: object_container_1
<<Containers: tests>>=  
  subroutine object_container_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: pro_log, pro_int
    class(object_t), pointer :: container
    class(object_t), pointer :: a1, a2, a3, a4, a5, a6
    logical :: success

    write (u, "(A)")  "* Test output: object_container_1"
    write (u, "(A)")  "*   Purpose: construct containers"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: container"

    allocate (composite_t :: pro_log)
    select type (pro_log)
    type is (composite_t)
       call pro_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_log%import_core (core)
    end select
    
    allocate (composite_t :: pro_int)
    select type (pro_int)
    type is (composite_t)
       call pro_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call pro_int%import_core (core)
    end select
    
    allocate (container_t :: container)
    select type (container)
    class is (composite_t)
       call container%init (var_str ("container"))
    end select
    
    write (u, "(A)")
    call container%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call container%instantiate (a1)
    call init_container (a1, var_str ("a1"), CT_TUPLE, 0)

    call container%instantiate (a2)
    call init_container (a2, var_str ("a2"), CT_TUPLE, 1)
    call set_member_int (a2, 1, pro_int, 1)

    call container%instantiate (a3)
    call init_container (a3, var_str ("a3"), CT_TUPLE, 2)
    call set_member_int (a3, 1, pro_int, 1)
    call set_member_log (a3, 2, pro_log, .true.) 

    call container%instantiate (a4)
    call init_container (a4, var_str ("a4"), CT_TUPLE, 3)
    call set_member_int (a4, 1, pro_int, 1)
    call set_member_log (a4, 2, pro_log, .true.) 
    call set_member_int (a4, 3, pro_int) 

    call container%instantiate (a5)
    call init_container (a5, var_str ("a5"), CT_LIST, 2)
    call set_member_int (a5, 1, pro_int, 1)
    call set_member_log (a5, 2, pro_log, .true.) 

    call container%instantiate (a6)
    call init_container (a6, var_str ("a6"), CT_SEQUENCE, 2)
    call set_member_int (a6, 1, pro_int, 1)
    call set_member_log (a6, 2, pro_log, .true.) 

    call a1%write (u)
    write (u, "(A)")
    call a2%write (u)
    write (u, "(A)")
    call a3%write (u)
    write (u, "(A)")
    call a4%write (u)
    write (u, "(A)")
    call a5%write (u)
    write (u, "(A)")
    call a6%write (u)
    write (u, "(A)")

    call a1%write_as_expression (u)
    write (u, "(A)")
    call a2%write_as_expression (u)
    write (u, "(A)")
    call a3%write_as_expression (u)
    write (u, "(A)")
    call a4%write_as_expression (u)
    write (u, "(A)")
    call a5%write_as_expression (u)
    write (u, "(A)")
    call a6%write_as_expression (u)
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Resolve and evaluate"
    write (u, "(A)")
  
    call a1%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a2%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a3%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a4%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a5%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call a1%evaluate ()
    call a2%evaluate ()
    call a3%evaluate ()
    call a4%evaluate ()
    call a5%evaluate ()
    call a6%evaluate ()

    write (u, "(A)")
    call a1%write (u)
    write (u, "(A)")
    call a2%write (u)
    write (u, "(A)")
    call a3%write (u)
    write (u, "(A)")
    call a4%write (u)
    write (u, "(A)")
    call a5%write (u)
    write (u, "(A)")
    call a6%write (u)

    write (u, *)
    call a1%write_as_value (u)
    write (u, "(A)")
    call a2%write_as_value (u)
    write (u, "(A)")
    call a3%write_as_value (u)
    write (u, "(A)")
    call a4%write_as_value (u)
    write (u, "(A)")
    call a5%write_as_value (u)
    write (u, "(A)")
    call a6%write_as_value (u)
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a3)
    call remove_object (a4)
    call remove_object (a5)
    call remove_object (a6)
    call remove_object (container)
    call remove_object (pro_log)
    call remove_object (pro_int)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_container_1"
    
  end subroutine object_container_1

@ %def object_container_1
@ 
\subsubsection{Nested containers}
Build and evaluate chained containers expressions and containers with
undefined parts.
<<Containers: execute tests>>=
  call test (object_container_2, "object_container_2", &
       "nested containers", &
       u, results)
<<Containers: test declarations>>=
  public :: object_container_2
<<Containers: tests>>=  
  subroutine object_container_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: pro_int
    class(object_t), pointer :: container
    class(object_t), pointer :: a1, a2, a3, a4, a5
    class(object_t), pointer :: b1, c1
    logical :: success
    
    write (u, "(A)")  "* Test output: object_container_2"
    write (u, "(A)")  "*   Purpose: construct nested containers"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: container"

    allocate (composite_t :: pro_int)
    select type (pro_int)
    type is (composite_t)
       call pro_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call pro_int%import_core (core)
    end select
    
    allocate (container_t :: container)
    select type (container)
    class is (composite_t)
       call container%init (var_str ("container"))
    end select
    
    write (u, "(A)")
    call container%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call container%instantiate (a1)
    call init_container (a1, var_str ("a1"), CT_TUPLE, 2)
    select type (a1)
    class is (container_t)
       call container%instantiate (b1)
       call init_container (b1, var_str ("item1"), CT_LIST, 2)
       select type (b1)
       class is (container_t)
          call container%instantiate (c1)
          call init_container (c1, var_str ("item1"), CT_SEQUENCE, 2)
          call set_member_int (c1, 1, pro_int, 1)
          call set_member_int (c1, 2, pro_int, 2)
          call b1%import_member (1, c1)
       end select
       call set_member_int (b1, 2, pro_int, 3)
       call a1%import_member (1, b1)
    end select
    call set_member_int (a1, 2, pro_int, 4)
    
    call container%instantiate (a2)
    call init_container (a2, var_str ("a2"), CT_TUPLE, 2)
    select type (a2)
    class is (container_t)
       call container%instantiate (b1)
       call init_container (b1, var_str ("item1"), CT_SEQUENCE, 2)
       select type (b1)
       class is (container_t)
          call container%instantiate (c1)
          call init_container (c1, var_str ("item1"), CT_LIST, 2)
          call set_member_int (c1, 1, pro_int, 1)
          call set_member_int (c1, 2, pro_int, 2)
          call b1%import_member (1, c1)
       end select
       call set_member_int (b1, 2, pro_int, 3)
       call a2%import_member (1, b1)
    end select
    call set_member_int (a2, 2, pro_int, 4)
    
    call container%instantiate (a3)
    call init_container (a3, var_str ("a3"), CT_LIST, 2)
    select type (a3)
    class is (container_t)
       call container%instantiate (b1)
       call init_container (b1, var_str ("item1"), CT_SEQUENCE, 2)
       select type (b1)
       class is (container_t)
          call container%instantiate (c1)
          call init_container (c1, var_str ("item1"), CT_TUPLE, 2)
          call set_member_int (c1, 1, pro_int, 1)
          call set_member_int (c1, 2, pro_int, 2)
          call b1%import_member (1, c1)
       end select
       call set_member_int (b1, 2, pro_int, 3)
       call a3%import_member (1, b1)
    end select
    call set_member_int (a3, 2, pro_int, 4)
    
    call container%instantiate (a4)
    call init_container (a4, var_str ("a4"), CT_SEQUENCE, 2)
    select type (a4)
    class is (container_t)
       call container%instantiate (b1)
       call init_container (b1, var_str ("item1"), CT_LIST, 2)
       select type (b1)
       class is (container_t)
          call container%instantiate (c1)
          call init_container (c1, var_str ("item1"), CT_TUPLE, 2)
          call set_member_int (c1, 1, pro_int, 1)
          call set_member_int (c1, 2, pro_int, 2)
          call b1%import_member (1, c1)
       end select
       call set_member_int (b1, 2, pro_int, 3)
       call a4%import_member (1, b1)
    end select
    call set_member_int (a4, 2, pro_int, 4)
    
    call container%instantiate (a5)
    call init_container (a5, var_str ("a5"), CT_LIST, 2)
    select type (a5)
    class is (container_t)
       call container%instantiate (b1)
       call init_container (b1, var_str ("item1"), CT_LIST, 2)
       select type (b1)
       class is (container_t)
          call container%instantiate (c1)
          call init_container (c1, var_str ("item1"), CT_TUPLE, 2)
          call set_member_int (c1, 1, pro_int, 1)
          call set_member_int (c1, 2, pro_int, 2)
          call b1%import_member (1, c1)
       end select
       call set_member_int (b1, 2, pro_int, 3)
       call a5%import_member (1, b1)
    end select
    call set_member_int (a5, 2, pro_int, 4)

    call a1%write (u)
    write (u, "(A)")
    call a2%write (u)
    write (u, "(A)")
    call a3%write (u)
    write (u, "(A)")
    call a4%write (u)
    write (u, "(A)")
    call a5%write (u)
    write (u, "(A)")

    call a1%write_as_expression (u)
    write (u, "(A)")
    call a2%write_as_expression (u)
    write (u, "(A)")
    call a3%write_as_expression (u)
    write (u, "(A)")
    call a4%write_as_expression (u)
    write (u, "(A)")
    call a5%write_as_expression (u)
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Resolve and evaluate"
    write (u, "(A)")
  
    call a1%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a2%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a3%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a4%resolve (success)
    write (u, "(A,L1)")  "success = ", success
    call a5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call a1%evaluate ()
    call a2%evaluate ()
    call a3%evaluate ()
    call a4%evaluate ()
    call a5%evaluate ()

    write (u, "(A)")
    call a1%write (u)
    write (u, "(A)")
    call a2%write (u)
    write (u, "(A)")
    call a3%write (u)
    write (u, "(A)")
    call a4%write (u)
    write (u, "(A)")
    call a5%write (u)

    write (u, *)
    call a1%write_as_value (u)
    write (u, "(A)")
    call a2%write_as_value (u)
    write (u, "(A)")
    call a3%write_as_value (u)
    write (u, "(A)")
    call a4%write_as_value (u)
    write (u, "(A)")
    call a5%write_as_value (u)
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a3)
    call remove_object (a4)
    call remove_object (a5)
    call remove_object (container)
    call remove_object (pro_int)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_container_2"
    
  end subroutine object_container_2

@ %def object_container_2
@ 
\subsubsection{Container code I/O}
Construct container expression from bytecode.
<<Containers: execute tests>>=
  call test (object_container_3, "object_container_3", &
       "build expression from code", &
       u, results)
<<Containers: test declarations>>=
  public :: object_container_3
<<Containers: tests>>=  
  subroutine object_container_3 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    class(object_t), pointer :: p_int, p_cont, core, main, object
    class(object_t), pointer :: expr, val1, val2
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_container_3"
    write (u, "(A)")  "*   Purpose: construct expressions from code"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_int)
    select type (p_int)
    type is (composite_t)
       call p_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call p_int%import_core (core)
    end select

    allocate (container_t :: p_cont)
    select type (p_cont)
    type is (container_t)
       call p_cont%init (0)
    end select

    call repository%init (name = var_str ("repository"), n_members = 2)
    call repository%import_member (1, p_int)
    call repository%import_member (2, p_cont)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: list"
    
    call repository%get_member_ptr (1, p_int)

    call repository%spawn (var_str ("container"), expr)
    call init_container (expr, var_str ("container"), CT_LIST, 2)
    call set_member_int (expr, 1, p_int, 71)
    call set_member_int (expr, 2, p_int, 72)

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reconstruct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       class is (ref_array_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_container_3"

  end subroutine object_container_3

@ %def object_container_3
@ 
\subsubsection{Range conteiners}
Display containers that hold a range expression.
<<Containers: execute tests>>=
  call test (object_container_4, "object_container_4", &
       "range containers", &
       u, results)
<<Containers: test declarations>>=
  public :: object_container_4
<<Containers: tests>>=  
  subroutine object_container_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: p_int, p_cont, core, main, object, expr
    class(object_t), pointer :: a1, a2, a3, a4, a5, a6
    type(repository_t) :: repository
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_container_4"
    write (u, "(A)")  "*   Purpose: construct and encode range containers"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_int)
    select type (p_int)
    type is (composite_t)
       call p_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call p_int%import_core (core)
    end select

    allocate (container_t :: p_cont)
    select type (p_cont)
    type is (container_t)
       call p_cont%init (0)
    end select

    call repository%init (name = var_str ("repository"), n_members = 2)
    call repository%import_member (1, p_int)
    call repository%import_member (2, p_cont)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call repository%get_member_ptr (1, p_int)

    call repository%spawn (var_str ("container"), a1)
    call init_range_container (a1, var_str ("a1"), CT_ADD)
    call set_member_int (a1, 1, p_int)
    call set_member_int (a1, 2, p_int)
    call set_member_int (a1, 3, p_int)

    call repository%spawn (var_str ("container"), a2)
    call init_range_container (a2, var_str ("a2"), CT_SUB)
    call set_member_int (a2, 1, p_int, 10)
    call set_member_int (a2, 2, p_int, 0)
    call set_member_int (a2, 3, p_int, 1)

    call repository%spawn (var_str ("container"), a3)
    call init_range_container (a3, var_str ("a3"), CT_MUL)
    call set_member_int (a3, 1, p_int, 1)
    call set_member_int (a3, 2, p_int)
    call set_member_int (a3, 3, p_int, 2)

    call repository%spawn (var_str ("container"), a4)
    call init_range_container (a4, var_str ("a4"), CT_DIV)
    call set_member_int (a4, 1, p_int, 20)
    call set_member_int (a4, 2, p_int, 2)
    call set_member_int (a4, 3, p_int, 1)

    call repository%spawn (var_str ("container"), a5)
    call init_range_container (a5, var_str ("a5"), CT_LIN)
    call set_member_int (a5, 1, p_int, 0)
    call set_member_int (a5, 2, p_int, 100)
    call set_member_int (a5, 3, p_int, 10)

    call repository%spawn (var_str ("container"), a6)
    call init_range_container (a6, var_str ("a6"), CT_LOG)
    call set_member_int (a6, 1, p_int, 1)
    call set_member_int (a6, 2, p_int, 200)
    call set_member_int (a6, 3, p_int, 5)

    call a1%write (u)
    write (u, "(A)")
    call a2%write (u)
    write (u, "(A)")
    call a3%write (u)
    write (u, "(A)")
    call a4%write (u)
    write (u, "(A)")
    call a5%write (u)
    write (u, "(A)")
    call a6%write (u)
    write (u, "(A)")

    call a1%write_as_expression (u)
    write (u, "(A)")
    call a2%write_as_expression (u)
    write (u, "(A)")
    call a3%write_as_expression (u)
    write (u, "(A)")
    call a4%write_as_expression (u)
    write (u, "(A)")
    call a5%write_as_expression (u)
    write (u, "(A)")
    call a6%write_as_expression (u)
    write (u, "(A)")

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: range"
    
    call repository%get_member_ptr (1, p_int)

    call repository%spawn (var_str ("container"), expr)
    call init_range_container (expr, var_str ("container"), CT_ADD)
    call set_member_int (expr, 1, p_int, 11)
    call set_member_int (expr, 2, p_int, 33)
    call set_member_int (expr, 3, p_int, 22)

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 8
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       class is (ref_array_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a2)
    call remove_object (a3)
    call remove_object (a4)
    call remove_object (a5)
    call remove_object (a6)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_container_4"
    
  end subroutine object_container_4

@ %def object_container_4
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Comparison values}
This section defines comparison operators for numbers etc., resulting in
logical values.
<<[[object_comparison.f90]]>>=
<<File header>>

module object_comparison

<<Use strings>>
  use format_utils
  use io_units
  use diagnostics

  use codes
  use object_base
  use object_builder
  use object_expr
  use object_logical
  use object_integer

<<Standard module head>>

<<Comparison: public>>

<<Comparison: types>>

contains

<<Comparison: procedures>>

end module object_comparison
@ %def object_comparison
@ 
\subsection{Comparison operator}
We introduce a generic comparison operator that can handle multiple
comparisons, concatenated by logical [[and]].  The arguments are integer
expressions, otherwise everything is analogous to logical binary operators.
We define pointer shortcuts for both arguments and result.
<<Comparison: public>>=
  public :: compare_t
<<Comparison: types>>=
  type, extends (operator_binary_t) :: compare_t
     private
     type(logical_t), pointer :: res => null ()
     type(integer_p), dimension(:), allocatable :: arg_ptr
     integer, dimension(:), allocatable :: cmp_code
   contains
   <<Comparison: compare: TBP>>
end type compare_t

@ %def compare_t
@
\subsubsection{Queries}
Priority value.
<<Comparison: compare: TBP>>=
  procedure :: get_priority => compare_get_priority
<<Comparison: procedures>>=
  pure function compare_get_priority (object) result (priority)
    class(compare_t), intent(in) :: object
    integer :: priority
    priority = PRIO_COMPARE
  end function compare_get_priority
  
@ %def compare_get_priority
@ The operator name is replaced by the appropriate comparison sign.
<<Comparison: compare: TBP>>=
  procedure :: show_opname => compare_show_opname
  procedure :: get_opname => compare_get_opname
<<Comparison: procedures>>=
  pure function compare_show_opname (object, i) result (flag)
    class(compare_t), intent(in) :: object
    integer, intent(in), optional :: i
    logical :: flag
    if (present (i)) then
       flag = i > 1
    else
       flag = .false.
    end if
  end function compare_show_opname

  pure function compare_get_opname (object, i) result (name)
    class(compare_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    select case (object%cmp_code(i))
    case (CMP_EQ);  name = "=="
    case (CMP_NE);  name = "<>"
    case (CMP_LT);  name = "<"
    case (CMP_GT);  name = ">"
    case (CMP_LE);  name = "<="
    case (CMP_GE);  name = ">="
    end select
  end function compare_get_opname

@ %def compare_show_opname
@ %def compare_get_opname
@
\subsubsection{Construction}
Instantiate.  The number of arguments is not yet known, we just initialize the
core.
<<Comparison: compare: TBP>>=
  procedure :: instantiate => compare_instantiate
<<Comparison: procedures>>=
  subroutine compare_instantiate (object, instance)
    class(compare_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (compare_t :: instance)
    select type (instance)
    type is (compare_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype, mode=MODE_CONSTANT)
    end select
  end subroutine compare_instantiate
  
@ %def compare_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the core.
Arguments are not allocated, this requires a call to the [[init_args]]
method.
<<Comparison: compare: TBP>>=
  generic :: init => compare_init
  procedure, private :: compare_init
<<Comparison: procedures>>=
  subroutine compare_init (object, prototype, mode)
    class(compare_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (var_str ("compare"), mode)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine compare_init
  
@ %def compare_init 
@ The [[init_members]] method has to allocate the [[cmp_code]] array in addition
to the default initialization.
<<Comparison: compare: TBP>>=
  procedure :: init_members => compare_init_members
<<Comparison: procedures>>=
  subroutine compare_init_members (object, n_members, n_arguments)
    class(compare_t), intent(inout), target :: object
    integer, intent(in) :: n_members
    integer, intent(in), optional :: n_arguments
    call object%composite_t%init_members (n_members, n_arguments)
    allocate (object%cmp_code (n_members), source = CMP_NONE)
  end subroutine compare_init_members

@ %def compare_init_members
@ Set the comparison code for a specific argument.  The
argument index should be greater than one.
<<Comparison: compare: TBP>>=
  procedure :: set_cmp_code => compare_set_cmp_code
<<Comparison: procedures>>=
  subroutine compare_set_cmp_code (object, i, cmp_code)
    class(compare_t), intent(inout) :: object
    integer, intent(in) :: i
    integer, intent(in) :: cmp_code
    object%cmp_code(i) = cmp_code
  end subroutine compare_set_cmp_code
  
@ %def compare_set_cmp_code
@
\subsection{Decoding}
For the compare operator, we need to store the appropriate comparison codes
for all arguments.  We do this right after the main code line.  The code is a
sequence of integers.  It occupies the place of the object-name code of
ordinary composites.
<<Comparison: compare: TBP>>=
  procedure :: get_code => compare_get_code
<<Comparison: procedures>>=
  function compare_get_code (object, repository) result (code)
    class(compare_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    call object%get_base_code (code, repository)
    call code%create_integer_val (object%cmp_code)
  end function compare_get_code
  
@ %def compare_get_code
@ Build object from code: we set the number of arguments and fetch the
[[cmp_code]] array.
<<Comparison: compare: TBP>>=
  procedure :: init_from_code => compare_init_from_code
<<Comparison: procedures>>=
  subroutine compare_init_from_code (object, code)
    class(compare_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    logical :: success
    call object%set_mode (mode = code%get_att (2))
    call object%init_args (n_arg = code%get_att (5))
    call object%set_intrinsic (intrinsic = code%get_att (3) == 0)
    call code%get_integer_array (object%cmp_code, success)
    if (.not. success)  call msg_bug &
         ("Sindarin: error in byte code for comparison operator")
  end subroutine compare_init_from_code

@ %def compare_init_from_code
@
\subsubsection{Evaluation}
Resolve: check arguments and assign pointer shortcuts.  The arguments must be
of type integer; otherwise the routine is universal for binary operators.
<<Comparison: compare: TBP>>=
  procedure :: resolve => compare_resolve
<<Comparison: procedures>>=
  recursive subroutine compare_resolve (object, success)
    class(compare_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    integer :: i, n_args
    success = .false.
    object%res => null ()
    n_args = object%get_n_members ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (.not. allocated (object%arg_ptr)) &
         allocate (object%arg_ptr (n_args))
    if (object%has_value ()) then
       do i = 1, n_args
          call object%get_member_ptr (i, arg)
          call arg%resolve (success);  if (.not. success)  return
          select type (arg)
          class is (wrapper_t)
             call arg%get_core_ptr (core)
             select type (core)
             type is (integer_t)
                call object%arg_ptr(i)%associate (core)
                success = .true.
             end select
          end select
       end do
    end if
  end subroutine compare_resolve
  
@ %def compare_resolve
@ Evaluate the operation.
<<Comparison: compare: TBP>>=
  procedure :: evaluate => compare_evaluate
<<Comparison: procedures>>=
  recursive subroutine compare_evaluate (object)
    class(compare_t), intent(inout), target :: object
    integer :: i
    integer :: lhs, rhs
    logical :: passed
    call object%composite_t%evaluate ()
    do i = 1, size (object%arg_ptr)
       if (.not. object%arg_ptr(i)%is_defined ()) then
          call object%res%init ()
          return
       end if
    end do
    lhs = object%arg_ptr(1)%get_value ()
    do i = 2, size (object%arg_ptr)
       rhs = object%arg_ptr(i)%get_value ()
       select case (object%cmp_code(i))
       case (CMP_EQ);  passed = lhs == rhs
       case (CMP_NE);  passed = lhs /= rhs
       case (CMP_LT);  passed = lhs <  rhs
       case (CMP_GT);  passed = lhs >  rhs
       case (CMP_LE);  passed = lhs <= rhs
       case (CMP_GE);  passed = lhs >= rhs
       end select
       if (.not. passed) then
          call object%res%init (.false.)
          return
       end if
       lhs = rhs
    end do
    call object%res%init (.true.)
  end subroutine compare_evaluate
  
@ %def compare_evaluate
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_comparison_ut.f90]]>>=
<<File header>>

module object_comparison_ut

  use unit_tests
  use object_comparison_uti
  
<<Standard module head>>

<<Comparison: public test>>

contains
  
<<Comparison: test driver>>

end module object_comparison_ut
@ %def object_comparison_ut
@ 
<<[[object_comparison_uti.f90]]>>=
<<File header>>

module object_comparison_uti
  
  <<Use strings>>
    use codes
    use object_base
    use object_logical
    use object_expr
    use object_integer

    use object_comparison

<<Standard module head>>

<<Comparison: test declarations>>

contains
  
<<Comparison: test auxiliary>>

<<Comparison: tests>>

end module object_comparison_uti
@ %def object_comparison_uti
@ API: driver for the unit tests below.
<<Comparison: public test>>=
  public :: object_comparison_test
<<Comparison: test driver>>=
  subroutine object_comparison_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Comparison: execute tests>>  
  end subroutine object_comparison_test
  
@ %def object_comparison_test 
@
\subsubsection{Manual initialization}
Shortcut to member initialization.  This routine is used only in the unit
tests below.
<<Comparison: public test auxiliary>>=
  public :: init_members
<<Comparison: test auxiliary>>=
  subroutine init_members (object, n_arg)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: n_arg
    select type (object)
    class is (operator_t)
       call object%init_args (n_arg)
    end select
  end subroutine init_members
    
@ %def init_members
@ Set the member value directly.  This routine is used only in the unit tests
below.
<<Comparison: public test auxiliary>>=
  public :: set_member_val
<<Comparison: test auxiliary>>=
  subroutine set_member_val (object, prototype, i, value, cmp_code)
    class(object_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    integer, intent(in) :: i
    integer, intent(in), optional :: value
    integer, intent(in), optional :: cmp_code
    class(object_t), pointer :: member, core
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "i"
       case (2);  name = "j"
       case (3);  name = "k"
       case (4);  name = "l"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       select type (prototype)
       class is (composite_t)
          call prototype%instantiate (member)
       end select
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (integer_t)
             call core%init (value)
          end select
       end select
       call object%import_member (i, member)
    end select
    if (present (cmp_code)) then
       select type (object)
       class is (compare_t)
          call object%set_cmp_code (i, cmp_code)
       end select
    end if
  end subroutine set_member_val
    
@ %def set_member_val
@ 
\subsubsection{Test operators: two arguments}
Build and evaluate simple comparisons expressions.
<<Comparison: execute tests>>=
  call test (object_comparison_1, "object_comparison_1", &
       "simple comparisons", &
       u, results)
<<Comparison: test declarations>>=
  public :: object_comparison_1
<<Comparison: tests>>=  
  subroutine object_comparison_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: pro_log, pro_int
    class(object_t), pointer :: compare
    class(object_t), pointer :: a1, a2, a3, a4, a5, a6
    class(object_t), pointer :: b1, b2, b3, b4, b5, b6
    logical :: success

    write (u, "(A)")  "* Test output: object_comparison_1"
    write (u, "(A)")  "*   Purpose: check integer comparison operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: compare"

    allocate (composite_t :: pro_log)
    select type (pro_log)
    type is (composite_t)
       call pro_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_log%import_core (core)
    end select
    
    allocate (composite_t :: pro_int)
    select type (pro_int)
    type is (composite_t)
       call pro_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call pro_int%import_core (core)
    end select
    
    allocate (compare_t :: compare)
    select type (compare)
    type is (compare_t)
       call compare%init (pro_log)
    end select
    
    write (u, "(A)")
    call compare%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call compare%instantiate (a1)
    call init_members (a1, 2)
    call set_member_val (a1, pro_int, 1, 2)
    call set_member_val (a1, pro_int, 2, 3, CMP_EQ) 
    call a1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a2)
    call init_members (a2, 2)
    call set_member_val (a2, pro_int, 1, 2)
    call set_member_val (a2, pro_int, 2, 3, CMP_NE) 
    call a2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a3)
    call init_members (a3, 2)
    call set_member_val (a3, pro_int, 1, 2)
    call set_member_val (a3, pro_int, 2, 3, CMP_LT) 
    call a3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a4)
    call init_members (a4, 2)
    call set_member_val (a4, pro_int, 1, 2)
    call set_member_val (a4, pro_int, 2, 3, CMP_GT) 
    call a4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a5)
    call init_members (a5, 2)
    call set_member_val (a5, pro_int, 1, 2)
    call set_member_val (a5, pro_int, 2, 3, CMP_LE) 
    call a5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a6)
    call init_members (a6, 2)
    call set_member_val (a6, pro_int, 1, 2)
    call set_member_val (a6, pro_int, 2, 3, CMP_GE) 
    call a6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, *)

    call compare%instantiate (b1)
    call init_members (b1, 2)
    call set_member_val (b1, pro_int, 1, 2)
    call set_member_val (b1, pro_int, 2, 2, CMP_EQ) 
    call b1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (b2)
    call init_members (b2, 2)
    call set_member_val (b2, pro_int, 1, 2)
    call set_member_val (b2, pro_int, 2, 2, CMP_NE) 
    call b2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (b3)
    call init_members (b3, 2)
    call set_member_val (b3, pro_int, 1, 2)
    call set_member_val (b3, pro_int, 2, 2, CMP_LT) 
    call b3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (b4)
    call init_members (b4, 2)
    call set_member_val (b4, pro_int, 1, 2)
    call set_member_val (b4, pro_int, 2, 2, CMP_GT) 
    call b4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (b5)
    call init_members (b5, 2)
    call set_member_val (b5, pro_int, 1, 2)
    call set_member_val (b5, pro_int, 2, 2, CMP_LE) 
    call b5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (b6)
    call init_members (b6, 2)
    call set_member_val (b6, pro_int, 1, 2)
    call set_member_val (b6, pro_int, 2, 2, CMP_GE) 
    call b6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
    call a4%write (u)
    call a5%write (u)
    call a6%write (u)

    write (u, "(A)")
    call a1%write_as_expression (u)
    write (u, *)
    call a2%write_as_expression (u)
    write (u, *)
    call a3%write_as_expression (u)
    write (u, *)
    call a4%write_as_expression (u)
    write (u, *)
    call a5%write_as_expression (u)
    write (u, *)
    call a6%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    call b1%write_as_expression (u)
    write (u, *)
    call b2%write_as_expression (u)
    write (u, *)
    call b3%write_as_expression (u)
    write (u, *)
    call b4%write_as_expression (u)
    write (u, *)
    call b5%write_as_expression (u)
    write (u, *)
    call b6%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call a1%evaluate ()
    call a2%evaluate ()
    call a3%evaluate ()
    call a4%evaluate ()
    call a5%evaluate ()
    call a6%evaluate ()

    call b1%evaluate ()
    call b2%evaluate ()
    call b3%evaluate ()
    call b4%evaluate ()
    call b5%evaluate ()
    call b6%evaluate ()

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
    call a4%write (u)
    call a5%write (u)
    call a6%write (u)

    write (u, "(A)")
    call a1%write_as_value (u)
    write (u, *)
    call a2%write_as_value (u)
    write (u, *)
    call a3%write_as_value (u)
    write (u, *)
    call a4%write_as_value (u)
    write (u, *)
    call a5%write_as_value (u)
    write (u, *)
    call a6%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    call b1%write_as_value (u)
    write (u, *)
    call b2%write_as_value (u)
    write (u, *)
    call b3%write_as_value (u)
    write (u, *)
    call b4%write_as_value (u)
    write (u, *)
    call b5%write_as_value (u)
    write (u, *)
    call b6%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a3)
    call remove_object (a4)
    call remove_object (a5)
    call remove_object (a6)
    call remove_object (b1)
    call remove_object (b2)
    call remove_object (b3)
    call remove_object (b4)
    call remove_object (b5)
    call remove_object (b6)
    call remove_object (compare)
    call remove_object (pro_log)
    call remove_object (pro_int)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_comparison_1"
    
  end subroutine object_comparison_1

@ %def object_comparison_1
@ 
\subsubsection{Test operators: multiple arguments}
Build and evaluate chained comparisons expressions and comparisons with
undefined parts.
<<Comparison: execute tests>>=
  call test (object_comparison_2, "object_comparison_2", &
       "chained comparisons", &
       u, results)
<<Comparison: test declarations>>=
  public :: object_comparison_2
<<Comparison: tests>>=  
  subroutine object_comparison_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: pro_log, pro_int
    class(object_t), pointer :: compare
    class(object_t), pointer :: a1, a2, a3, a4
    logical :: success

    write (u, "(A)")  "* Test output: object_comparison_2"
    write (u, "(A)")  "*   Purpose: check chained integer comparison operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: compare"

    allocate (composite_t :: pro_log)
    select type (pro_log)
    type is (composite_t)
       call pro_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_log%import_core (core)
    end select
    
    allocate (composite_t :: pro_int)
    select type (pro_int)
    type is (composite_t)
       call pro_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call pro_int%import_core (core)
    end select
    
    allocate (compare_t :: compare)
    select type (compare)
    type is (compare_t)
       call compare%init (pro_log)
    end select
    
    write (u, "(A)")
    call compare%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call compare%instantiate (a1)
    call init_members (a1, 2)
    call set_member_val (a1, pro_int, 1)
    call set_member_val (a1, pro_int, 2, 3, CMP_EQ) 
    call a1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a2)
    call init_members (a2, 2)
    call set_member_val (a2, pro_int, 1, 2)
    call set_member_val (a2, pro_int, 2, cmp_code = CMP_EQ) 
    call a2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a3)
    call init_members (a3, 3)
    call set_member_val (a3, pro_int, 1, 2)
    call set_member_val (a3, pro_int, 2, 3, CMP_LT) 
    call set_member_val (a3, pro_int, 3, 4, CMP_LT) 
    call a3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call compare%instantiate (a4)
    call init_members (a4, 4)
    call set_member_val (a4, pro_int, 1, 2)
    call set_member_val (a4, pro_int, 2, 3, CMP_LT) 
    call set_member_val (a4, pro_int, 3, 4, CMP_LE) 
    call set_member_val (a4, pro_int, 4, 5, CMP_GT) 
    call a4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
    call a4%write (u)

    write (u, "(A)")
    call a1%write_as_expression (u)
    write (u, *)
    call a2%write_as_expression (u)
    write (u, *)
    call a3%write_as_expression (u)
    write (u, *)
    call a4%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call a1%evaluate ()
    call a2%evaluate ()
    call a3%evaluate ()
    call a4%evaluate ()

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
    call a4%write (u)

    write (u, "(A)")
    call a1%write_as_value (u)
    write (u, *)
    call a2%write_as_value (u)
    write (u, *)
    call a3%write_as_value (u)
    write (u, *)
    call a4%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a3)
    call remove_object (a4)
    call remove_object (compare)
    call remove_object (pro_log)
    call remove_object (pro_int)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_comparison_2"
    
  end subroutine object_comparison_2

@ %def object_comparison_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conditional expressions}
This section defines conditional expressions and statements.
<<[[object_conditional.f90]]>>=
<<File header>>

module object_conditional

<<Use strings>>
  use format_utils
  use io_units

  use codes
  use object_base
  use object_builder
  use object_expr
  use object_logical
  use object_integer
  use object_comparison

<<Standard module head>>

<<Conditional: public>>

<<Conditional: types>>

contains

<<Conditional: procedures>>

end module object_conditional
@ %def object_conditional
@ 
\subsection{Conditional type}
A conditional is a generic composite where the members are of alternating
type: the odd-numbered entries are of the result type, while the even-numbered
entries are of logical type, the conditions.  We keep pointer shortcuts to the
conditions.
<<Conditional: public>>=
  public :: conditional_t
<<Conditional: types>>=
  type, extends (composite_t) :: conditional_t
     private
     class(object_t), pointer :: cond_prototype => null ()
     type(integer_t), pointer :: res => null ()
     type(logical_p), dimension(:), allocatable :: cond_ptr
     type(integer_p), dimension(:), allocatable :: branch_ptr
   contains
   <<Conditional: conditional: TBP>>
end type conditional_t

@ %def conditional_t
@
\subsubsection{Finalizer}
The finalizer unregisters the [[cond_prototype]], then proceeds as usual.
<<Conditional: conditional: TBP>>=
  procedure :: final => conditional_final
<<Conditional: procedures>>=
  recursive subroutine conditional_final (object)
    class(conditional_t), intent(inout) :: object
    call remove_object (object%cond_prototype)
    call object%composite_t%final ()
  end subroutine conditional_final
       
@ %def conditional_final
@
\subsubsection{Output}
The output routine is the same as for an operator, except that we write an
operator symbol ([[if]]/[[endif]]) before and after the whole expression.

Note that we change the order between condition and branch, for each member
except the last one.
<<Conditional: conditional: TBP>>=
  procedure :: write_expression => conditional_write_expression
<<Conditional: procedures>>=
  recursive subroutine conditional_write_expression (object, unit, indent)
    class(conditional_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority, i, ii
    u = given_output_unit (unit)
    priority = object%get_priority ()
    do i = 1, object%get_n_members ()
       write (u, "(A,1x)", advance="no")  char (object%get_opname (i))
       if (i < object%get_n_members ()) then
          select case (mod(i,2))
          case (0);  ii = i - 1
          case (1);  ii = i + 1
          end select
       else
          ii = i
       end if
       call object%get_member_ptr (ii, arg)
       if (associated (arg)) then
          arg => arg%dereference ()
          call arg%write_as_expression (unit, indent, priority=priority)
       else
          write (u, "(A)", advance="no") "???"
       end if
       write (u, "(1x)", advance="no")
    end do
    write (u, "(A)", advance="no")  "endif"
  end subroutine conditional_write_expression
    
@ %def conditional_write_expression
@
\subsubsection{Queries}
This is an expression.
<<Conditional: conditional: TBP>>=
  procedure :: is_expression => conditional_is_expression
<<Conditional: procedures>>=
  pure function conditional_is_expression (object) result (flag)
    class(conditional_t), intent(in) :: object
    logical :: flag
    call object%check_mode (flag)
  end function conditional_is_expression
  
@ %def conditional_is_expression
@ For conditionals, we should look for the name of the object itself, not the
name of the prototype object (which is the prototype of the value).
<<Conditional: conditional: TBP>>=
  procedure :: get_prototype_index => conditional_get_prototype_index
<<Conditional: procedures>>=
  function conditional_get_prototype_index (object, repository) result (i)
    class(conditional_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    call repository%find_member (object%get_name (), index=i)
  end function conditional_get_prototype_index

@ %def conditional_get_prototype_index
@ Priority value.
<<Conditional: conditional: TBP>>=
  procedure :: get_priority => conditional_get_priority
<<Conditional: procedures>>=
  pure function conditional_get_priority (object) result (priority)
    class(conditional_t), intent(in) :: object
    integer :: priority
    priority = PRIO_CONDITIONAL
  end function conditional_get_priority
  
@ %def conditional_get_priority
@ We always show an operator name in verbose mode, for clarity.  The operator
name is specified as [[if]], [[then]], [[elsif]], or [[else]], depending on
the branch and member.  The if-branches consist of two members each, the else
branch is only one member.  Note that the [[then]] keyword is not written in
verbose format ([[show_opname]]), just in expression format.

The optional [[i]] must be present here.
<<Conditional: conditional: TBP>>=
  procedure :: show_opname => conditional_show_opname
  procedure :: get_opname => conditional_get_opname
<<Conditional: procedures>>=
  pure function conditional_show_opname (object, i) result (flag)
    class(conditional_t), intent(in) :: object
    integer, intent(in), optional :: i
    logical :: flag
    flag = mod (i, 2) == 1
  end function conditional_show_opname

  pure function conditional_get_opname (object, i) result (name)
    class(conditional_t), intent(in) :: object
    integer, intent(in), optional :: i
    type(string_t) :: name
    select case (mod (i, 2))
    case (1)
       if (i == 1) then
          name = "if"
       else if (i < object%get_n_members ()) then
          name = "elsif"
       else
          name = "else"
       end if
    case (0)
       name = "then"
    end select
  end function conditional_get_opname

@ %def conditional_show_opname
@ %def conditional_get_opname
@ Return a pointer to the prototype, for use in a unit test.
<<Conditional: conditional: TBP>>=
  procedure :: get_cond_prototype_ptr => conditional_get_cond_prototype_ptr
<<Conditional: procedures>>=
  subroutine conditional_get_cond_prototype_ptr (object, cond_prototype)
    class(conditional_t), intent(in) :: object
    class(object_t), pointer :: cond_prototype
    cond_prototype => object%cond_prototype
  end subroutine conditional_get_cond_prototype_ptr
  
@ %def conditional_get_cond_prototype_ptr
@
\subsubsection{Construction}
Instantiate.  We associate to the value prototype as usual, and additionally
associate to the condition prototype.
<<Conditional: conditional: TBP>>=
  procedure :: instantiate => conditional_instantiate
<<Conditional: procedures>>=
  subroutine conditional_instantiate (object, instance)
    class(conditional_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: value_prototype
    allocate (conditional_t :: instance)
    select type (instance)
    type is (conditional_t)
       call object%get_prototype_ptr (value_prototype)
       select type (cond_prototype => object%cond_prototype)
       class is (composite_t)
          call instance%init (cond_prototype, value_prototype, &
               mode=MODE_CONSTANT)
       end select
    end select
  end subroutine conditional_instantiate
  
@ %def conditional_instantiate
@ Initialize: We need the [[logical]] prototype for initializing the
conditions, and we need the value prototype for the branch expressions and the
core.  The object itself is associated to the value prototype.  Branches are
not allocated, this requires a call to the [[init_branches]] method.  The core
is preallocated with an unknown value.

The name is [[conditional_expr]].
<<Conditional: conditional: TBP>>=
  generic :: init => conditional_init
  procedure, private :: conditional_init
<<Conditional: procedures>>=
  subroutine conditional_init (object, cond_prototype, value_prototype, mode)
    class(conditional_t), intent(inout) :: object
    class(object_t), intent(inout), target :: cond_prototype
    class(object_t), intent(inout), target :: value_prototype
    integer, intent(in), optional :: mode
    class(object_t), pointer :: value, core
    call object%composite_t%init (var_str ("conditional_expr"), mode)
    select type (cond_prototype)
    class is (composite_t)
       object%cond_prototype => cond_prototype
       call object%register (cond_prototype)
    end select
    select type (value_prototype)
    class is (composite_t)
       call object%register (value_prototype)
       call value_prototype%get_core_ptr (value)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine conditional_init
  
@ %def conditional_init 
@
We define a separate procedure that initializes the number of arguments.
Argument type is not checked.

We count the number of branches that have a condition plus the else-branch
that has no condition.  There is always an else-branch, even if it has not
been specified explicitly, so the number of members is an odd number greater
or equal to three.
<<Conditional: conditional: TBP>>=
  procedure :: init_branches => conditional_init_branches
<<Conditional: procedures>>=
  subroutine conditional_init_branches (object, n_branches)
    class(conditional_t), intent(inout) :: object
    integer, intent(in) :: n_branches
    call object%init_members &
         (n_members = 2 * n_branches - 1, n_arguments = 2 * n_branches - 1)
  end subroutine conditional_init_branches

@ %def conditional_init_branches
@
\subsection{Decoding}
For the conditional operator, the standard bytecode handler (composite) is
sufficient.

\subsubsection{Evaluation}
Resolve: check arguments and assign pointer shortcuts.  The arguments must be
of type integer; otherwise the routine is universal for binary operators.

The core need not be resolved.
<<Conditional: conditional: TBP>>=
  procedure :: resolve => conditional_resolve
<<Conditional: procedures>>=
  recursive subroutine conditional_resolve (object, success)
    class(conditional_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    integer :: i, n_args, n_branches, n_cond
    success = .false.
    object%res => null ()
    n_args = object%get_n_members ()
    n_cond = n_args / 2
    n_branches = n_cond + 1
    call object%get_core_ptr (core)
    select type (core)
    type is (integer_t)
       object%res => core
    class default
       return
    end select
    if (.not. allocated (object%branch_ptr)) &
         allocate (object%branch_ptr (n_branches))
    if (.not. allocated (object%cond_ptr)) &
         allocate (object%cond_ptr (n_cond))
    if (object%has_value ()) then
       do i = 1, n_args
          call object%get_member_ptr (i, arg)
          call arg%resolve (success);  if (.not. success)  return
          select type (arg)
          class is (wrapper_t)
             call arg%get_core_ptr (core)
             select case (mod (i, 2))
             case (0)
                select type (core)
                type is (logical_t)
                   call object%cond_ptr(i/2)%associate (core)
                   success = .true.
                end select
             case (1)
                select type (core)
                type is (integer_t)
                   call object%branch_ptr(i/2+1)%associate (core)
                   success = .true.
                end select
             end select
          end select
       end do
    end if
  end subroutine conditional_resolve
  
@ %def conditional_resolve
@ Evaluate the operation.  Evaluate all conditions in order; if one returns
true, evaluate the corresponding branch and copy its value.

If a condition result or the selected branch value is undefined, return
undefined.
<<Conditional: conditional: TBP>>=
  procedure :: evaluate => conditional_evaluate
<<Conditional: procedures>>=
  recursive subroutine conditional_evaluate (object)
    class(conditional_t), intent(inout), target :: object
    class(object_t), pointer :: condition, branch
    integer :: i, n_branches, n_cond
    integer :: value
    logical :: passed
    n_cond = object%get_n_members () / 2
    n_branches = n_cond + 1
    do i = 1, n_cond
       call object%get_member_ptr (2*i, condition)
       call condition%evaluate ()
       if (object%cond_ptr(i)%is_defined ()) then
          if (object%cond_ptr(i)%get_value ()) then
             call object%get_member_ptr (2*i-1, branch)
             call branch%evaluate ()
             if (object%branch_ptr(i)%is_defined ()) then
                value = object%branch_ptr(i)%get_value ()
                call object%res%init (value)
                return
             else
                call object%res%init ()
                return
             end if
          end if
       else
          call object%res%init ()
          return
       end if
    end do
    call object%get_member_ptr (2*n_branches-1, branch)
    call branch%evaluate ()
    if (object%branch_ptr(n_branches)%is_defined ()) then
       value = object%branch_ptr(n_branches)%get_value ()
       call object%res%init (value)
    else
       call object%res%init ()
    end if
  end subroutine conditional_evaluate
  
@ %def conditional_evaluate
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[object_conditional_ut.f90]]>>=
<<File header>>

module object_conditional_ut

  use unit_tests
  use object_conditional_uti
  
<<Standard module head>>

<<Conditional: public test>>

contains
  
<<Conditional: test driver>>

end module object_conditional_ut
@ %def object_conditional_ut
@ 
<<[[object_conditional_uti.f90]]>>=
<<File header>>

module object_conditional_uti
  
  <<Use strings>>
    use object_base
    use object_logical
    use object_integer

    use object_conditional

<<Standard module head>>

<<Conditional: test declarations>>

contains
  
<<Conditional: tests>>

<<Conditional: test auxiliary>>

end module object_conditional_uti
@ %def object_conditional_uti
@ API: driver for the unit tests below.
<<Conditional: public test>>=
  public :: object_conditional_test
<<Conditional: test driver>>=
  subroutine object_conditional_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Conditional: execute tests>>  
  end subroutine object_conditional_test
  
@ %def object_conditional_test 
@
\subsubsection{Manual initialization}
Shortcut to member initialization.  This routine is used only in the unit
tests below.
<<Conditional: public test auxiliary>>=
  public :: init_members
<<Conditional: test auxiliary>>=
  subroutine init_members (object, n_branches)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: n_branches
    select type (object)
    class is (conditional_t)
       call object%init_branches (n_branches)
    end select
  end subroutine init_members
    
@ %def init_members
@ Set the condition value directly.  Note that the condition members are the
even-numbered members.  This routine is used only in the unit tests
below.
<<Conditional: public test auxiliary>>=
  public :: set_condit_val
<<Conditional: test auxiliary>>=
  subroutine set_condit_val (object, i, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    logical, intent(in), optional :: value
    class(composite_t), pointer :: prototype
    class(object_t), pointer :: member, core, cond_prototype
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "c1"
       case (2);  name = "c2"
       case (3);  name = "c3"
       case (4);  name = "c4"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (conditional_t)
       call object%get_cond_prototype_ptr (cond_prototype)
       call cond_prototype%instantiate (member)
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (logical_t)
             call core%init (value)
          end select
       end select
       call object%import_member (2*i, member)
    end select
  end subroutine set_condit_val
    
@ %def set_condit_val
@ Set the integer value of a branch directly.  Note that the value members are
the odd-numbered members.  This routine is used only in the unit tests
below.
<<Conditional: public test auxiliary>>=
  public :: set_branch_val
<<Conditional: test auxiliary>>=
  subroutine set_branch_val (object, i, value)
    class(object_t), intent(inout) :: object
    integer, intent(in) :: i
    integer, intent(in), optional :: value
    class(composite_t), pointer :: prototype
    class(object_t), pointer :: member, core
    type(string_t) :: name
    if (present (value)) then
       select case (i)
       case (1);  name = "i1"
       case (2);  name = "i2"
       case (3);  name = "i3"
       case (4);  name = "i4"
       end select
    else
       name = "undef"
    end if
    select type (object)
    class is (composite_t)
       call object%get_prototype_ptr (prototype)
       call prototype%instantiate (member)
       select type (member)
       class is (composite_t)
          call member%init (name = name, mode = MODE_CONSTANT)
          call member%get_core_ptr (core)
          select type (core)
          class is (integer_t)
             call core%init (value)
          end select
       end select
       call object%import_member (2*i-1, member)
    end select
  end subroutine set_branch_val
    
@ %def set_branch_val
@ 
\subsubsection{Integer conditional expression}
Build and evaluate various conditional expressions.
<<Conditional: execute tests>>=
  call test (object_conditional_1, "object_conditional_1", &
       "simple conditionals", &
       u, results)
<<Conditional: test declarations>>=  
  public :: object_conditional_1
<<Conditional: tests>>=  
  subroutine object_conditional_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: pro_log, pro_int
    class(object_t), pointer :: conditional
    class(object_t), pointer :: a1, a2, a3, a4, a5, a6
    logical :: success

    write (u, "(A)")  "* Test output: object_conditional_1"
    write (u, "(A)")  "*   Purpose: check integer conditional operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: conditional"

    allocate (composite_t :: pro_log)
    select type (pro_log)
    type is (composite_t)
       call pro_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_log%import_core (core)
    end select
    
    allocate (composite_t :: pro_int)
    select type (pro_int)
    type is (composite_t)
       call pro_int%init (var_str ("integer"))
       allocate (integer_t :: core)
       call pro_int%import_core (core)
    end select
    
    allocate (conditional_t :: conditional)
    select type (conditional)
    type is (conditional_t)
       call conditional%init (pro_log, pro_int)
    end select
    
    write (u, "(A)")
    call conditional%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call conditional%instantiate (a1)
    call init_members (a1, 2)
    call set_branch_val (a1, 1, 2)
    call set_condit_val (a1, 1, .true.)
    call set_branch_val (a1, 2, 3)
    call a1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call conditional%instantiate (a2)
    call init_members (a2, 2)
    call set_branch_val (a2, 1, 2)
    call set_condit_val (a2, 1, .false.)
    call set_branch_val (a2, 2, 3) 
    call a2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call conditional%instantiate (a3)
    call init_members (a3, 2)
    call set_branch_val (a3, 1, 2)
    call set_condit_val (a3, 1, .false.)
    call set_branch_val (a3, 2)
    call a3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

!     call conditional%instantiate (a4)
!     call init_members (a4, 2)
!     call set_branch_val (a4, 1, 2)
!     call set_branch_val (a4, 2, 3, CMP_GT) 
!     call a4%resolve (success)
!     write (u, "(A,L1)")  "success = ", success
! 
!     call conditional%instantiate (a5)
!     call init_members (a5, 2)
!     call set_branch_val (a5, 1, 2)
!     call set_branch_val (a5, 2, 3, CMP_LE) 
!     call a5%resolve (success)
!     write (u, "(A,L1)")  "success = ", success
! 
!     call conditional%instantiate (a6)
!     call init_members (a6, 2)
!     call set_branch_val (a6, 1, 2)
!     call set_branch_val (a6, 2, 3, CMP_GE) 
!     call a6%resolve (success)
!     write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
!     call a4%write (u)
!     call a5%write (u)
!     call a6%write (u)

    write (u, "(A)")
    call a1%write_as_expression (u)
    write (u, *)
    call a2%write_as_expression (u)
    write (u, *)
    call a3%write_as_expression (u)
    write (u, *)
!     call a4%write_as_expression (u)
!     write (u, *)
!     call a5%write_as_expression (u)
!     write (u, *)
!     call a6%write_as_expression (u)
!     write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call a1%evaluate ()
    call a2%evaluate ()
    call a3%evaluate ()
!     call a4%evaluate ()
!     call a5%evaluate ()
!     call a6%evaluate ()

    write (u, "(A)")
    call a1%write (u)
    call a2%write (u)
    call a3%write (u)
!     call a4%write (u)
!     call a5%write (u)
!     call a6%write (u)

    write (u, "(A)")
    call a1%write_as_value (u)
    write (u, *)
    call a2%write_as_value (u)
    write (u, *)
    call a3%write_as_value (u)
    write (u, *)
!     call a4%write_as_value (u)
!     write (u, *)
!     call a5%write_as_value (u)
!     write (u, *)
!     call a6%write_as_value (u)
!     write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (a1)
    call remove_object (a2)
    call remove_object (a3)
!     call remove_object (a4)
!     call remove_object (a5)
!     call remove_object (a6)
    call remove_object (conditional)
    call remove_object (pro_log)
    call remove_object (pro_int)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_conditional_1"
    
  end subroutine object_conditional_1

@ %def object_conditional_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Sindarin Parser}
<<[[sindarin_parser.f90]]>>=
<<File header>>

module sindarin_parser

<<Use strings>>

  use io_units
  use diagnostics
  use ifiles
  use syntax_rules
  use parser
  use codes
  use builders
  use object_base
  use object_expr
  use object_logical
  use object_integer
  use object_container
  use object_comparison
  use object_conditional

<<Standard module head>>

<<Sindarin parser: public>>

<<Sindarin parser: types>>

<<Sindarin parser: interfaces>>

<<Sindarin parser: variables>>

contains

<<Sindarin parser: procedures>>

end module sindarin_parser
@ %def sindarin_parser
@ 
\subsection{Prototype Repository}
<<Sindarin parser: public>>=
  public :: make_sindarin_repository
<<Sindarin parser: procedures>>=
  subroutine make_sindarin_repository (repository)
    type(repository_t), intent(inout) :: repository
    class(object_t), pointer :: core
    class(object_t), pointer :: logical
    class(object_t), pointer :: integer
    class(object_t), pointer :: container
    class(object_t), pointer :: not, and, or
    class(object_t), pointer :: compare
    class(object_t), pointer :: minus, multiply, add
    class(object_t), pointer :: conditional
    class(object_t), pointer :: assignment
    integer :: i
    integer, parameter :: n_members = 12
    call repository%init (name = var_str ("repository"), n_members = n_members)
    ! Elementary data types
    ! logical
    allocate (composite_t :: logical)
    select type (logical)
    type is (composite_t)
       allocate (logical_t :: core)
       call logical%init (var_str ("logical"))
       call logical%import_core (core)
    end select
    ! integer
    allocate (composite_t :: integer)
    select type (integer)
    type is (composite_t)
       allocate (integer_t :: core)
       call integer%init (var_str ("integer"))
       call integer%import_core (core)
    end select
    ! Containers
    allocate (container_t :: container)
    select type (container)
    type is (container_t);  call container%init (CT_LIST)
    end select
    ! Logical operators
    ! not
    allocate (not_t :: not)
    select type (not)
    type is (not_t);  call not%init (logical)
    end select
    ! and
    allocate (and_t :: and)
    select type (and)
    type is (and_t);  call and%init (logical)
    end select
    ! or
    allocate (or_t :: or)
    select type (or)
    type is (or_t);  call or%init (logical)
    end select
    ! Comparison operator
    ! compare
    allocate (compare_t :: compare)
    select type (compare)
    type is (compare_t);  call compare%init (logical)
    end select
    ! Integer operators
    ! minus
    allocate (minus_t :: minus)
    select type (minus)
    type is (minus_t);  call minus%init (integer)
    end select
    ! multiply
    allocate (multiply_t :: multiply)
    select type (multiply)
    type is (multiply_t);  call multiply%init (integer)
    end select
    ! add
    allocate (add_t :: add)
    select type (add)
    type is (add_t);  call add%init (integer)
    end select
    ! Structured expressions
    ! conditional
    allocate (conditional_t :: conditional)
    select type (conditional)
    type is (conditional_t);  call conditional%init (logical, integer)
    end select
    ! Statements
    ! Assignment
    allocate (assignment_t :: assignment)
    select type (assignment)
    type is (assignment_t);  call assignment%init ()
    end select
    i = 0
    i = i + 1;  call repository%import_member (i, logical)
    i = i + 1;  call repository%import_member (i, integer)
    i = i + 1;  call repository%import_member (i, container)
    i = i + 1;  call repository%import_member (i, not)
    i = i + 1;  call repository%import_member (i, and)
    i = i + 1;  call repository%import_member (i, or)
    i = i + 1;  call repository%import_member (i, compare)
    i = i + 1;  call repository%import_member (i, minus)
    i = i + 1;  call repository%import_member (i, multiply)
    i = i + 1;  call repository%import_member (i, add)
    i = i + 1;  call repository%import_member (i, conditional)
    i = i + 1;  call repository%import_member (i, assignment)
    if (i /= n_members) then
       write (msg_buffer, "(A,I0,A,I0,A)")  "Sindarin: prototype repository&
            & has size ", n_members, ", but ", i, " items are given."
       call msg_bug ()
    end if
  end subroutine make_sindarin_repository
    
@ %def make_sindarin_repository
@ 
\subsection{Syntax Object}
<<Sindarin parser: public>>=
  public :: syntax_sindarin
<<Sindarin parser: variables>>=
  type(syntax_t), target, save :: syntax_sindarin
  
@ %def syntax_sindarin
<<Sindarin parser: public>>=
  public :: syntax_sindarin_init
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_init ()
    type(ifile_t) :: ifile
    call sindarin_syntax_setup (ifile)
    call syntax_init (syntax_sindarin, ifile)
    call ifile%final ()
  end subroutine syntax_sindarin_init

@ %def syntax_sindarin_init
<<Sindarin parser: public>>=
  public :: syntax_sindarin_final
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_final ()
    call syntax_final (syntax_sindarin)
  end subroutine syntax_sindarin_final

@ %def syntax_sindarin_final
<<Sindarin parser: public>>=
  public :: syntax_sindarin_write
<<Sindarin parser: procedures>>=
  subroutine syntax_sindarin_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_sindarin, unit)
  end subroutine syntax_sindarin_write

@ %def syntax_sindarin_write
<<Sindarin parser: procedures>>=
  subroutine sindarin_syntax_setup (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile%append ("SEQ script = command*")
    call ifile%append ("ALT command = declaration | assignment")
    call ifile%append ("SEQ declaration =&
         & builtin_type var_name assignment_clause?")
    call ifile%append ("SEQ assignment = var_name assignment_clause")
    call ifile%append ("ALT builtin_type = logical | integer")
    call ifile%append ("KEY logical")
    call ifile%append ("KEY integer")
    call ifile%append ("IDE var_name")
    call ifile%append ("SEQ assignment_clause = '=' generic_expr")
    call ifile%append ("KEY '='")
    call ifile%append ("ALT generic_expr = signed_expr | expr")
    call ifile%append ("SEQ signed_expr = sign expr")
    call ifile%append ("ALT sign = '+' | '-'")
    call ifile%append ("SEQ expr = term operator_clause*")
    call ifile%append ("ALT operator_clause =&
         & separator_clause |&
         & logical_operation |&
         & comparison |&
         & arithmetic_operation")
    call ifile%append ("SEQ separator_clause = separator term")
    call ifile%append ("ALT separator = ':' | ',' | '=>'")
    call ifile%append ("KEY ':'")
    call ifile%append ("KEY ','")
    call ifile%append ("KEY '=>'")
    call ifile%append ("SEQ logical_operation = logical_operator term")
    call ifile%append ("ALT logical_operator = or | and")
    call ifile%append ("KEY or")
    call ifile%append ("KEY and")
    call ifile%append ("SEQ comparison = comparison_operator term")
    call ifile%append ("ALT comparison_operator =&
         & '==' | '<>' | '<' | '>' | '<=' | '>='")
    call ifile%append ("KEY '=='")
    call ifile%append ("KEY '<>'")
    call ifile%append ("KEY '<'")
    call ifile%append ("KEY '>'")
    call ifile%append ("KEY '<='")
    call ifile%append ("KEY '>='")
    call ifile%append ("SEQ arithmetic_operation = arithmetic_operator term")
    call ifile%append ("ALT arithmetic_operator =&
         & '+' | '-' | '*' | '/' | '^'")
    call ifile%append ("KEY '+'")
    call ifile%append ("KEY '-'")
    call ifile%append ("KEY '*'")
    call ifile%append ("KEY '/'")
    call ifile%append ("KEY '^'")
    call ifile%append ("ALT term =&
         & not_clause | logical_literal |&
         & integer_literal |&
         & conditional_expr |&
         & group | atom")
    call ifile%append ("SEQ not_clause = not logical_expr")
    call ifile%append ("ALT logical_expr = term comparison*")
    call ifile%append ("ALT logical_literal = true | false")
    call ifile%append ("KEY not")
    call ifile%append ("KEY true")
    call ifile%append ("KEY false")
    call ifile%append ("INT integer_literal")
    call ifile%append ("SEQ conditional_expr =&
         & if_expr elsif_expr_part else_expr_part endif")
    call ifile%append ("SEQ if_expr = if expr then expr")
    call ifile%append ("SEQ elsif_expr_part = elsif_expr*")
    call ifile%append ("SEQ elsif_expr = elsif expr then expr")
    call ifile%append ("SEQ else_expr_part = else_expr?") 
    call ifile%append ("SEQ else_expr = else expr")
    call ifile%append ("KEY if")
    call ifile%append ("KEY then")
    call ifile%append ("KEY elsif")
    call ifile%append ("KEY else")
    call ifile%append ("KEY endif")
    call ifile%append ("GRO group = ( expr )")
    call ifile%append ("IDE atom")
  end subroutine sindarin_syntax_setup

@ %def sindarin_syntax_setup
@
\subsection{Parse Node Decoder}
This is an object that allows us to iterate over the parse tree step by step.
We implement it as an implementation of [[builder_t]], because it is
technically a builder (with only the decoding mode implemented) that works
just on a single node.

The [[sindarin_decoder_t]] below contains a factory method that allocates the
correct implementation of [[pn_decoder_t]], corresponding to a particular
syntax rule.

The [[pn_decoder_t]] object holds the pointer to a parse node and a numeric
item counter.  We also point to the syntax rule.

We include a pointer to the [[prototypes]] array, which is allocated in the
parent [[sindarin_decoder_t]] object.

The [[previous]] pointer allows us to build a stack of decoder objects.
<<Sindarin parser: types>>=
  type, extends (builder_t), abstract :: pn_decoder_t
     private
     type(parse_node_t), pointer :: pn => null ()
     type(parse_node_t), pointer :: pn_next => null ()
     type(syntax_rule_t), pointer :: rule => null ()
     type(string_t), dimension(:), pointer :: prototypes => null ()
     type(position_t) :: position
     class(pn_decoder_t), pointer :: previous => null ()
   contains
   <<Sindarin parser: pn decoder: TBP>>
  end type pn_decoder_t
  
@ %def pn_decoder_t
@
\subsubsection{Finalizer}
Not needed in the default case.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: final => pn_decoder_final
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_final (builder)
    class(pn_decoder_t), intent(inout) :: builder
  end subroutine pn_decoder_final
  
@ %def pn_decoder_final
@
\subsubsection{Output}
Print rule keyword and item index.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: write => pn_decoder_write
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_write (builder, unit)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(2x)", advance="no")
    call builder%rule%write (u, short=.true., key_only=.true., advance=.false.)
    write (u, "(':',1x)", advance="no")
    call builder%position%write (u)
    write (u, *)
  end subroutine pn_decoder_write

@ %def pn_decoder_write
@
\subsubsection{Initialization}
Assign the parse node, determine the rule.  Also set the prototype index if
applicable.

The may have preset content, therefore intent(inout).
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: init => pn_decoder_init
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_init (builder, parse_node, rule, prototypes)
    class(pn_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    type(syntax_rule_t), intent(in), target :: rule
    type(string_t), dimension(:), target :: prototypes
    builder%pn => parse_node
    builder%rule => rule
    builder%prototypes => prototypes
  end subroutine pn_decoder_init
  
@ %def pn_decoder_init
@
\subsubsection{Build method}
The [[build]] method is not implemented for this type.  We just support
decoding, which is deferred to the rule-dependent implementation.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: build => pn_decoder_build
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_build (builder, code, success)
    class(pn_decoder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    success = .false.
    call msg_bug ("Parse-node decoder: build method not implemented")
  end subroutine pn_decoder_build
    
@ %def pn_decoder_build
@
\subsubsection{Prototype lookup}
Use the [[prototypes]] array to find a named entry, returning the index
within the array.  For convenience allow both fixed and variable strings.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: get_index => &
       pn_decoder_get_index_string, &
       pn_decoder_get_index_char
  procedure, private :: pn_decoder_get_index_string
  procedure, private :: pn_decoder_get_index_char
<<Sindarin parser: procedures>>=
  function pn_decoder_get_index_string (builder, key) result (i)
    class(pn_decoder_t), intent(in) :: builder
    type(string_t), intent(in) :: key
    integer :: i
    i = find_index (builder%prototypes, key)
  end function pn_decoder_get_index_string
  
  function pn_decoder_get_index_char (builder, key) result (i)
    class(pn_decoder_t), intent(in) :: builder
    character(len=*), intent(in) :: key
    integer :: i
    i = find_index (builder%prototypes, var_str (key))
  end function pn_decoder_get_index_char
  
@ %def pn_decoder_get_index
@ Auxiliary: return the index of a named prototype, using the prototype array.

NB: We do a simple linear search.  In case this becomes a bottleneck, we should
think about a hash table for the prototypes array.
<<Sindarin parser: procedures>>=
  function find_index (array, key) result (i_prototype)
    type(string_t), dimension(:), intent(in) :: array
    type(string_t), intent(in) :: key
    integer :: i_prototype
    integer :: i
    i_prototype = 0
    do i = 1, size (array)
       if (key == array(i)) then
          i_prototype = i
          return
       end if
    end do
  end function find_index

@ %def find_index
@
\subsubsection{Output navigation}
The decoder maintains a position marker.  We visit a decoder object several
times during the decoding process.  The position marker specifies where we
are.

Return the current value of the position-part marker.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: get_part => pn_decoder_get_part
<<Sindarin parser: procedures>>=
  function pn_decoder_get_part (builder) result (part)
    class(pn_decoder_t), intent(in) :: builder
    integer :: part
    part = builder%position%part
  end function pn_decoder_get_part
  
@ %def pn_decoder_get_part
@
These methods determine what to decode next, storing the appropriate position
data.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: next_part => pn_decoder_next_part
  procedure :: next_index => pn_decoder_next_index
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_next_part (builder, part)
    class(pn_decoder_t), intent(inout) :: builder
    integer, intent(in) :: part
    builder%position%part = part
    builder%position%i = 1
  end subroutine pn_decoder_next_part
  
  subroutine pn_decoder_next_index (builder)
    class(pn_decoder_t), intent(inout) :: builder
    builder%position%i = builder%position%i + 1
  end subroutine pn_decoder_next_index

@ %def pn_decoder_next_part
@ %def pn_decoder_next_index
@
\subsubsection{Parse tree queries}
The parse tree is the source for the decoding process.  We navigate by
assigning parse-node pointers.

Return the next parse (sub-)node to be interpreted, originating from the
current node.  If this is null, the current node has been digested fully.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: get_next_node => pn_decoder_get_next_node
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_get_next_node (builder, parse_node)
    class(pn_decoder_t), intent(in) :: builder
    type(parse_node_t), pointer, intent(out) :: parse_node
    parse_node => builder%pn_next
  end subroutine pn_decoder_get_next_node
  
@ %def pn_decoder_get_next_node
@ Return the number of terms in the associated parse node, i.e., the number of
sub-nodes.  If there is an argument, do this for a subnode as identified by
the argument index (array).
<<Sindarin parser: pn decoder: TBP>>=
  generic :: get_n_terms => &
       pn_decoder_get_n_terms, &
       pn_decoder_get_n_terms_index, &
       pn_decoder_get_n_terms_array
  procedure, private :: pn_decoder_get_n_terms
  procedure, private :: pn_decoder_get_n_terms_index
  procedure, private :: pn_decoder_get_n_terms_array
<<Sindarin parser: procedures>>=
  function pn_decoder_get_n_terms (builder) result (n)
    class(pn_decoder_t), intent(in) :: builder
    type(parse_node_t), pointer :: pn
    integer :: n
    call builder%get_pn0 (pn)
    n = pn%get_n_sub ()
  end function pn_decoder_get_n_terms
  
  function pn_decoder_get_n_terms_index (builder, i) result (n)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in) :: i
    type(parse_node_t), pointer :: pn
    integer :: n
    call builder%get_pn1 (i, pn)
    if (associated (pn)) then
       n = pn%get_n_sub ()
    else
       n = 0
    end if
  end function pn_decoder_get_n_terms_index
  
  function pn_decoder_get_n_terms_array (builder, ii) result (n)
    class(pn_decoder_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    type(parse_node_t), pointer :: pn
    integer :: n
    call builder%get_pn2 (ii, pn)
    if (associated (pn)) then
       n = pn%get_n_sub ()
    else
       n = 0
    end if
  end function pn_decoder_get_n_terms_array
  
@ %def pn_decoder_get_n_terms
@ Return the pointer to a particular sub-node and/or, if required, the
associated rule key.  If no argument is provided, this is the generic node.
The sub-node is identified by an index, relative to the builder 
node.  Alternatively, it is identified by an index array, corresponding to a
sub-node path to be followed.

Note that we also export the specific versions.  The reason is that we will
override them in some cases.  This is not possible with the generic.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: get_pn => get_pn0, get_pn1, get_pn2
  procedure :: get_pn0 => pn_decoder_get_pn
  procedure :: get_pn1 => pn_decoder_get_pn_index
  procedure :: get_pn2 => pn_decoder_get_pn_array
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_get_pn (builder, pn, key)
    class(pn_decoder_t), intent(in) :: builder
    type(parse_node_t), intent(out), pointer :: pn
    type(string_t), intent(out), optional :: key
    pn => builder%pn
    if (present (key)) then
       key = builder%rule%get_key ()
    end if
  end subroutine pn_decoder_get_pn
          
  subroutine pn_decoder_get_pn_index (builder, i, pn, key)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in) :: i
    type(parse_node_t), intent(out), pointer :: pn
    type(string_t), intent(out), optional :: key
    type(syntax_rule_t), pointer :: rule
    pn => builder%pn%get_sub_ptr (i)
    if (present (key)) then
       if (associated (pn)) then
          rule => pn%get_rule_ptr ()
          key = rule%get_key ()
       else
          key = ""
       end if
    end if
  end subroutine pn_decoder_get_pn_index
          
  subroutine pn_decoder_get_pn_array (builder, ii, pn, key)
    class(pn_decoder_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    type(parse_node_t), intent(out), pointer :: pn
    type(string_t), intent(out), optional :: key
    type(syntax_rule_t), pointer :: rule
    integer :: k
    pn => builder%pn
    do k = 1, size (ii)
       if (associated (pn)) then
          pn => pn%get_sub_ptr (ii(k))
       else
          exit
       end if
    end do
    if (present (key)) then
       if (associated (pn)) then
          rule => pn%get_rule_ptr ()
          key = rule%get_key ()
       else
          key = ""
       end if
    end if
  end subroutine pn_decoder_get_pn_array
          
@ %def pn_decoder_get_pn
@ %def pn_decoder_get_pn_index
@ %def pn_decoder_get_pn_array
@ Shortcut: return just the key.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: get_key => &
       pn_decoder_get_key, &
       pn_decoder_get_key_index, &
       pn_decoder_get_key_array
  procedure, private :: pn_decoder_get_key
  procedure, private :: pn_decoder_get_key_index
  procedure, private :: pn_decoder_get_key_array
<<Sindarin parser: procedures>>=
  function pn_decoder_get_key (builder) result (key)
    class(pn_decoder_t), intent(in) :: builder
    type(string_t) :: key
    type(parse_node_t), pointer :: pn
    call builder%get_pn0 (pn, key)
  end function pn_decoder_get_key
          
  function pn_decoder_get_key_index (builder, i) result (key)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in) :: i
    type(string_t) :: key
    type(parse_node_t), pointer :: pn
    call builder%get_pn1 (i, pn, key)
  end function pn_decoder_get_key_index
          
  function pn_decoder_get_key_array (builder, ii) result (key)
    class(pn_decoder_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    type(string_t) :: key
    type(parse_node_t), pointer :: pn
    call builder%get_pn2 (ii, pn, key)
  end function pn_decoder_get_key_array
          
@ %def pn_decoder_get_key
@ %def pn_decoder_get_key_index
@ %def pn_decoder_get_key_array
@ Return an integer value stored at the specified parse node.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: get_integer => &
       pn_decoder_get_integer, &
       pn_decoder_get_integer_index, &
       pn_decoder_get_integer_array
  procedure, private :: pn_decoder_get_integer
  procedure, private :: pn_decoder_get_integer_index
  procedure, private :: pn_decoder_get_integer_array
<<Sindarin parser: procedures>>=
  function pn_decoder_get_integer (builder) result (value)
    class(pn_decoder_t), intent(in) :: builder
    integer :: value
    type(parse_node_t), pointer :: pn
    call builder%get_pn0 (pn)
    value = pn%get_integer ()
  end function pn_decoder_get_integer
          
  function pn_decoder_get_integer_index (builder, i) result (value)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in) :: i
    integer :: value
    type(parse_node_t), pointer :: pn
    call builder%get_pn1 (i, pn)
    value = pn%get_integer ()
  end function pn_decoder_get_integer_index
          
  function pn_decoder_get_integer_array (builder, ii) result (value)
    class(pn_decoder_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    integer :: value
    type(parse_node_t), pointer :: pn
    call builder%get_pn2 (ii, pn)
    value = pn%get_integer ()
  end function pn_decoder_get_integer_array
          
@ %def pn_decoder_get_integer
@ %def pn_decoder_get_integer_index
@ %def pn_decoder_get_integer_array
@ Shortcut: check if the specified node exists.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: has_term => &
       pn_decoder_has_term, &
       pn_decoder_has_term_index, &
       pn_decoder_has_term_array
  procedure, private :: pn_decoder_has_term
  procedure, private :: pn_decoder_has_term_index
  procedure, private :: pn_decoder_has_term_array
<<Sindarin parser: procedures>>=
  function pn_decoder_has_term (builder) result (flag)
    class(pn_decoder_t), intent(in) :: builder
    logical :: flag
    type(parse_node_t), pointer :: pn
    call builder%get_pn0 (pn)
    flag = associated (pn)
  end function pn_decoder_has_term
          
  function pn_decoder_has_term_index (builder, i) result (flag)
    class(pn_decoder_t), intent(in) :: builder
    integer, intent(in) :: i
    logical :: flag
    type(parse_node_t), pointer :: pn
    call builder%get_pn1 (i, pn)
    flag = associated (pn)
  end function pn_decoder_has_term_index
          
  function pn_decoder_has_term_array (builder, ii) result (flag)
    class(pn_decoder_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    logical :: flag
    type(parse_node_t), pointer :: pn
    call builder%get_pn2 (ii, pn)
    flag = associated (pn)
  end function pn_decoder_has_term_array
          
@ %def pn_decoder_has_term
@ %def pn_decoder_has_term_index
@ %def pn_decoder_has_term_array
@
\subsubsection{Parse tree navigation}
The [[goto]] method specifies a parse node, a sub-node of the current one
identified by index, as the next parse node to analyze.  The second method
[[stay]] will force an immediate return to the current node, to create another
code entry.
<<Sindarin parser: pn decoder: TBP>>=
  generic :: goto => &
       pn_decoder_goto_self, &
       pn_decoder_goto_index, &
       pn_decoder_goto_array
  procedure, private :: pn_decoder_goto_self
  procedure, private :: pn_decoder_goto_index
  procedure, private :: pn_decoder_goto_array
  procedure :: stay => pn_decoder_stay
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_goto_self (builder)
    class(pn_decoder_t), intent(inout) :: builder
    call builder%get_pn0 (builder%pn_next)
  end subroutine pn_decoder_goto_self

  subroutine pn_decoder_goto_index (builder, i)
    class(pn_decoder_t), intent(inout) :: builder
    integer, intent(in) :: i
    call builder%get_pn1 (i, builder%pn_next)
  end subroutine pn_decoder_goto_index

  subroutine pn_decoder_goto_array (builder, ii)
    class(pn_decoder_t), intent(inout) :: builder
    integer, dimension(:), intent(in) :: ii
    call builder%get_pn2 (ii, builder%pn_next)
  end subroutine pn_decoder_goto_array

  subroutine pn_decoder_stay (builder)
    class(pn_decoder_t), intent(inout) :: builder
    builder%pn_next => null ()
  end subroutine pn_decoder_stay
  
@ %def pn_decoder_goto
@ %def pn_decoder_stay
@
Finish building by this decoder object.  We reset the position counter and
nullify the next-node pointer.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: done => pn_decoder_done
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_done (builder)
    class(pn_decoder_t), intent(inout) :: builder
    builder%position%part = POS_NONE
    builder%position%i = 0
    builder%pn_next => null ()
  end subroutine pn_decoder_done
  
@ %def pn_decoder_done
@
Finish building with a failure notice.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: fail => pn_decoder_fail
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_fail (builder, success)
    class(pn_decoder_t), intent(inout) :: builder
    logical, intent(out) :: success
    call builder%done ()
    success = .false.
  end subroutine pn_decoder_fail
  
@ %def pn_decoder_fail
@
\subsubsection{Code generation}
This deferred procedure generates the actual code for the master node of some
expression structure.  This is usually the first operation in decoding, when
the position marker is still at [[POS_HERE]].
<<Sindarin parser: pn decoder: TBP>>=
  procedure (pn_decoder_create_node_code), deferred :: create_node_code
<<Sindarin parser: interfaces>>=
  abstract interface
     subroutine pn_decoder_create_node_code (builder, code)
       import
       class(pn_decoder_t), intent(in) :: builder
       type(code_t), intent(out) :: code
     end subroutine pn_decoder_create_node_code
  end interface
  
@ %def pn_decoder_create_node_code
@ The core of an object, as it appears in the byte code, is often just an
empty (typeless) value.  Thus, we provide this default implementation.
<<Sindarin parser: pn decoder: TBP>>=
  procedure :: create_core_code => pn_decoder_create_empty_value
<<Sindarin parser: procedures>>=
  subroutine pn_decoder_create_empty_value (builder, code)
    class(pn_decoder_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_VALUE)
  end subroutine pn_decoder_create_empty_value

@ %def pn_decoder_create_empty_value
@
\subsection{Parse Tree Interpreter}
The Sindarin source is parsed by the [[parse_tree]] object, using the
[[sindarin_syntax]] table.  The next step is to convert the parse tree into
bytecode, corresponding to the Sindarin object tree structure.

This task is given to a the [[sindarin_decoder_t]] object, which is an
incarnation of the [[builder_t]] abstract type.  An abstract builder has
methods both for coding and decoding an object tree.  Here we just decode:
iterate over the parse tree and return a sequence of byte codes.

We store the array of prototype names, a pointer to the parse-tree root, and a
pointer to the node-decoder stack.  The prototype-name array is allocated via
pointer, so we can target it without worrying about TARGET attributes.

We also store the prototype index of the [[assignment]] statement, since this
will be frequently used and constant.
<<Sindarin parser: public>>=
  public :: sindarin_decoder_t
<<Sindarin parser: types>>=
  type, extends (builder_t) :: sindarin_decoder_t
     private
     type(string_t), dimension(:), pointer :: prototypes => null ()
     type(parse_node_t), pointer :: pn_root => null ()
     class(pn_decoder_t), pointer :: pn_decoder => null ()
   contains
   <<Sindarin parser: sindarin decoder: TBP>>
  end type sindarin_decoder_t
     
@ %def sindarin_decoder_t
@
\subsubsection{Finalizer}
Clear content accumulated by the decoder.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: final => sindarin_decoder_final
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_final (builder)
    class(sindarin_decoder_t), intent(inout) :: builder
    class(pn_decoder_t), pointer :: pn_decoder
    if (associated (builder%prototypes))  deallocate (builder%prototypes)
    do while (associated (builder%pn_decoder))
       pn_decoder => builder%pn_decoder
       builder%pn_decoder => pn_decoder%previous
       call pn_decoder%final ()
       deallocate (pn_decoder)
    end do
  end subroutine sindarin_decoder_final
  
@ %def sindarin_decoder_final
@
\subsubsection{Output}
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: write => sindarin_decoder_write
  procedure :: write_prototypes => sindarin_decoder_write_prototypes
  procedure :: write_tree => sindarin_decoder_write_tree
  procedure :: write_stack => sindarin_decoder_write_stack
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_write (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    write (u, "(A)")  "Parse-tree decoder state:"
    call builder%write_prototypes (u)
    call builder%write_tree (u)
    call builder%write_stack (u)
  end subroutine sindarin_decoder_write

  subroutine sindarin_decoder_write_prototypes (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (builder%prototypes)) then
       write (u, "(A)")  "Prototype names:"
       do i = 1, size (builder%prototypes)
          write (u, "(1x,I0,1x,A)")  i, char (builder%prototypes(i))
       end do
    else
       write (u, "(A)")  "[No prototype array]"
    end if
  end subroutine sindarin_decoder_write_prototypes

  subroutine sindarin_decoder_write_tree (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    if (associated (builder%pn_root)) then
       write (u, "(A)")  "Parse tree:"
       call builder%pn_root%write (unit, short=.true., depth = 1)
    else
       write (u, "(A)")  "[No parse tree]"
    end if
  end subroutine sindarin_decoder_write_tree

  subroutine sindarin_decoder_write_stack (builder, unit)
    class(sindarin_decoder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: u
    u = given_output_unit (unit)
    if (associated (builder%pn_decoder)) then
       write (u, "(A)")  "Node handler stack:"
       pn_decoder => builder%pn_decoder
       do while (associated (pn_decoder))
          call pn_decoder%write (u)
          pn_decoder => pn_decoder%previous
       end do
    else
       write (u, "(A)")  "[No pointer stack]"
    end if
  end subroutine sindarin_decoder_write_stack

@ %def sindarin_decoder_write
@ %def sindarin_decoder_write_tree
@ %def sindarin_decoder_write_stack
@
\subsubsection{Initialization}
The decoder is started by associating the root of an existing parse tree.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: init => sindarin_decoder_init
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_init (decoder, parse_tree, prototype_names)
    class(sindarin_decoder_t), intent(out) :: decoder
    type(parse_tree_t), intent(in) :: parse_tree
    type(string_t), dimension(:), intent(in) :: prototype_names
    class(pn_decoder_t), pointer :: pn_decoder
    integer :: i
    allocate (decoder%prototypes (size (prototype_names)))
    decoder%prototypes = prototype_names
    decoder%pn_root => parse_tree%get_root_ptr ()
    if (associated (decoder%pn_root)) then
       call decoder%push (decoder%pn_root, 0)
    end if
  end subroutine sindarin_decoder_init
  
@ %def sindarin_decoder_init
@
\subsubsection{Pointer Stack}
The decoder maintains a stack of decoder objects, which point to locations in
the parse tree.
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure, private :: push => sindarin_decoder_push
  procedure, private :: pop => sindarin_decoder_pop
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_push (builder, parse_node, context_part)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    integer, intent(in) :: context_part
    class(pn_decoder_t), pointer :: pn_decoder
    call builder%make_pn_decoder (parse_node, context_part, pn_decoder)
    pn_decoder%previous => builder%pn_decoder
    builder%pn_decoder => pn_decoder
  end subroutine sindarin_decoder_push
    
  subroutine sindarin_decoder_pop (builder)
    class(sindarin_decoder_t), intent(inout) :: builder
    class(pn_decoder_t), pointer :: pn_decoder
    pn_decoder => builder%pn_decoder
    builder%pn_decoder => pn_decoder%previous
    call pn_decoder%final ()
    deallocate (pn_decoder)
  end subroutine sindarin_decoder_pop
    
@ %def sindarin_decoder_push
@ %def sindarin_decoder_pop
@
\subsubsection{Decoding}
Decode the current object and advance to the next.  If there is a valid
sub-node for the current node, push this to the top of the stack for the next
iteration.  If there is no object left, return [[.false.]]
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: decode => sindarin_decoder_decode
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_decode (builder, code, success)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn_next
    integer :: context_part
    do while (associated (builder%pn_decoder))
       call builder%pn_decoder%decode (code, success)
       if (success) then
          call builder%pn_decoder%get_next_node (pn_next)
          if (associated (pn_next)) then
             context_part = builder%pn_decoder%get_part ()
             call builder%push (pn_next, context_part)
          end if
          if (code%get_cat () /= 0) then
             return
          end if
       else
          call builder%pop ()
       end if
    end do
    success = .false.
  end subroutine sindarin_decoder_decode

@ %def sindarin_decoder_decode
@
\subsubsection{Building}
This is not applicable for [[sindarin_decoder_t]].
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: build => sindarin_decoder_build
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_build (builder, code, success)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    success = .false.
    call msg_bug ("Sindarin decoder: build method not implemented")
  end subroutine sindarin_decoder_build
    
@ %def sindarin_decoder_build
@
\subsection{Handling Individual Parse Nodes}
This is the factory method for creating a specific parse-node handler.  We
check the syntax rule and allocate a matching extension of [[pn_decoder_t]].
This extension is initialized with pointers to the parse node and rule.

By default, the decoder objects are initialized with [[parse_node]].
Optionally, the decoder selection code may replace this with a subnode,
assigned to [[pn]].
<<Sindarin parser: sindarin decoder: TBP>>=
  procedure :: make_pn_decoder => sindarin_decoder_make_pn_decoder
<<Sindarin parser: procedures>>=
  subroutine sindarin_decoder_make_pn_decoder &
       (builder, parse_node, context_part, pn_decoder)
    class(sindarin_decoder_t), intent(inout) :: builder
    type(parse_node_t), intent(in), target :: parse_node
    integer, intent(in) :: context_part
    class(pn_decoder_t), intent(out), pointer :: pn_decoder
    type (parse_node_t), pointer :: pn
    type(syntax_rule_t), pointer :: rule
    pn => parse_node
    rule => parse_node%get_rule_ptr ()
    select case (char (rule%get_key ()))
     <<Sindarin parser: decoder selection>>
    case default
       call msg_bug ("Sindarin decoder: rule '" &
            // char (rule%get_key ()) // "' not supported")
    end select
    call pn_decoder%init (pn, rule, builder%prototypes)
  end subroutine sindarin_decoder_make_pn_decoder
    
@ %def sindarin_decoder_make_pn_decoder
@
\subsubsection{Script}
For the script, we store the number and locations of declarations and
commands, respectively.
<<Sindarin parser: decoder selection>>=
  case ("script")
     allocate (pnd_script_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_script_t
     private
     integer :: n_dec = 0
     integer :: n_com = 0
     integer, dimension(:), allocatable :: dec
     integer, dimension(:), allocatable :: com
   contains
   <<Sindarin parser: script: TBP>>
  end type pnd_script_t
  
@ %def pnd_script_t
@ Initialize: analyze the parse nodes and store data that we will need when
revisiting this builder object.
<<Sindarin parser: script: TBP>>=
  procedure :: setup => setup_script
<<Sindarin parser: procedures>>=
  subroutine setup_script (builder)
    class(pnd_script_t), intent(inout) :: builder
    logical, dimension(:), allocatable :: mask_dec, mask_com
    integer :: i, n_terms
    n_terms = builder%get_n_terms ()
    allocate (mask_dec (n_terms))
    allocate (mask_com (n_terms))
    do i = 1, n_terms
       select case (char (builder%get_key (i)))
       case ("declaration")
          mask_dec(i) = .true.
          mask_com(i) = builder%has_term ([i,3])
       case default
          mask_dec(i) = .false.
          mask_com(i) = .true.
       end select
    end do
    builder%n_dec = count (mask_dec)
    builder%n_com = count (mask_com)
    builder%dec = pack ([(i, i=1, n_terms)], mask_dec)
    builder%com = pack ([(i, i=1, n_terms)], mask_com)
  end subroutine setup_script
    
@ %def setup_script
@ Scanning the script, we have to separate declarations from other commands.
Declarations with initialization also generate a command.  This is recorded in
the masks [[mask_dec]] and [[mask_com]].
<<Sindarin parser: script: TBP>>=
  procedure :: decode => decode_script
<<Sindarin parser: procedures>>=
  recursive subroutine decode_script (builder, code, success)
    class(pnd_script_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    integer :: i
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       if (builder%n_dec > 0) then
          call builder%next_part (POS_MEMBER)
          call builder%goto (builder%dec(1))
       else if (builder%n_com > 0) then
          call builder%next_part (POS_PRIMER)
          call builder%goto (builder%com(1))
       else
          call builder%done ()
       end if
    case (POS_MEMBER)
       i = builder%position%i
       if (i < builder%n_dec) then
          call builder%next_index ()
          call builder%goto (builder%dec(i+1))
       else if (builder%n_com > 0) then
          call builder%next_part (POS_PRIMER)
          call builder%goto (builder%com(1))
       else
          call builder%done ()
       end if
    case (POS_PRIMER)
       i = builder%position%i
       if (i < builder%n_com) then
          call builder%next_index ()
          call builder%goto (builder%com(i+1))
       else
          call builder%done ()
       end if
    case default
       call builder%fail (success)
    end select
  end subroutine decode_script
  
@ %def decode_script
@ For the script object, we store the different numbers of member and primer
array sizes.
<<Sindarin parser: script: TBP>>=
  procedure :: create_node_code => create_node_code_script
<<Sindarin parser: procedures>>=
  subroutine create_node_code_script (builder, code)
    class(pnd_script_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [0, 0, 0, builder%n_dec, 0, builder%n_com])
    call code%create_string_val ([builder%rule%get_key ()])
  end subroutine create_node_code_script
  
@ %def create_node_code_script
@
\subsubsection{Declaration}
A declaration defines a new member of the current context.  When we encounter
the declaration statement, we decode it and prepare a member object with
undefined value.

The declaration may have an assignment clause.  To handle this, we create an
assignment builder instead (see below), when we encounter the parse node again
during primer generation.
<<Sindarin parser: decoder selection>>=
  case ("declaration")
     select case (context_part)
     case (POS_MEMBER)
        allocate (pnd_declaration_t :: pn_decoder)
     case (POS_PRIMER)
        allocate (pnd_assignment_t :: pn_decoder)
     end select
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_declaration_t
     private
     type(string_t) :: key
     type(string_t) :: var_name
   contains
   <<Sindarin parser: declaration: TBP>>
  end type pnd_declaration_t
  
@ %def pnd_declaration_t
@ Initialization: Find the strings for prototype and variable name.
<<Sindarin parser: declaration: TBP>>=
  procedure :: setup => setup_declaration
<<Sindarin parser: procedures>>=
  subroutine setup_declaration (builder)
    class(pnd_declaration_t), intent(inout) :: builder
    type(parse_node_t), pointer :: pn_var
    builder%key = builder%get_key (1)
    call builder%get_pn ([2], pn_var)
    builder%var_name = pn_var%get_string ()
  end subroutine setup_declaration
    
@ %def setup_declaration
@ Declaration: we handle the declaration of a variable with name and
prototype and generate the code for initializing this as a member object.

The current implementation supports only [[variable]] objects.
<<Sindarin parser: declaration: TBP>>=
  procedure :: decode => decode_declaration
<<Sindarin parser: procedures>>=
  recursive subroutine decode_declaration (builder, code, success)
    class(pnd_declaration_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       call builder%next_part (POS_CORE)
       call builder%stay ()
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_declaration
  
@ %def decode_declaration
@ The declaration code contains the variable name as string value.
<<Sindarin parser: declaration: TBP>>=
  procedure :: create_node_code => create_node_code_declaration
<<Sindarin parser: procedures>>=
  subroutine create_node_code_declaration (builder, code)
    class(pnd_declaration_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index (builder%key), MODE_VARIABLE])
    call code%create_string_val ([builder%var_name])
  end subroutine create_node_code_declaration
  
@ %def create_node_code_declaration
@
\subsubsection{Assignment}
Assign a variable: lhs is the variable name, rhs is an expression.  The
prototype index is constant.
<<Sindarin parser: decoder selection>>=
  case ("assignment")
     allocate (pnd_assignment_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_assignment_t
     private
     integer :: i_lhs = 0
     type(string_t) :: var_name
   contains
   <<Sindarin parser: assignment: TBP>>
  end type pnd_assignment_t
  
@ %def pnd_assignment_t
@ Initialize: find the variable name (LHS) and its location in the parse tree.
<<Sindarin parser: assignment: TBP>>=
  procedure :: setup => setup_assignment
<<Sindarin parser: procedures>>=
  subroutine setup_assignment (builder)
    class(pnd_assignment_t), intent(inout) :: builder
    type(parse_node_t), pointer :: pn_lhs
    integer :: i_lhs
    select case (char (builder%get_key ()))
    case ("assignment");  i_lhs = 1
    case ("declaration"); i_lhs = 2
    end select
    call builder%get_pn (i_lhs, pn_lhs)
    builder%i_lhs = i_lhs
    builder%var_name = pn_lhs%get_string ()
  end subroutine setup_assignment
    
@ %def setup_assignment
@ Decode.  There is a composite assignment object, a left-hand side (variable
name) as an ID object, and a right-hand side expression which becomes a member
object.
<<Sindarin parser: assignment: TBP>>=
  procedure :: decode => decode_assignment
<<Sindarin parser: procedures>>=
  recursive subroutine decode_assignment (builder, code, success)
    class(pnd_assignment_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       call builder%next_part (POS_ID)
       call builder%stay ()
    case (POS_ID)
       call builder%create_id_code (code)
       call builder%next_part (POS_MEMBER)
       call builder%stay ()
    case (POS_MEMBER)
       call builder%next_part (POS_NONE)
       call builder%goto ([builder%i_lhs+1, 2])
    case default
       call builder%fail (success)
    end select
  end subroutine decode_assignment
  
@ %def decode_assignment
@ The assignment code needs just a prototype lookup.
<<Sindarin parser: assignment: TBP>>=
  procedure :: create_node_code => create_node_code_assignment
<<Sindarin parser: procedures>>=
  subroutine create_node_code_assignment (builder, code)
    class(pnd_assignment_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, [builder%get_index ("assignment")])
  end subroutine create_node_code_assignment
  
@ %def create_node_code_assignment
@ This is the code for the LHS id, a variable name.
<<Sindarin parser: assignment: TBP>>=
  procedure :: create_id_code => create_id_code_assignment
<<Sindarin parser: procedures>>=
  subroutine create_id_code_assignment (builder, code)
    class(pnd_assignment_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_ID)
    call code%create_string_val ([builder%var_name])
  end subroutine create_id_code_assignment
  
@ %def create_id_code_assignment
@
\subsubsection{Atom}
This is a variable reference.

Note: current support only for simple variable name.
<<Sindarin parser: decoder selection>>=
  case ("atom")
     allocate (pnd_atom_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_atom_t
     private
   contains
   <<Sindarin parser: atom: TBP>>
  end type pnd_atom_t
  
@ %def pnd_atom_t
@ Decode.
<<Sindarin parser: atom: TBP>>=
  procedure :: decode => decode_atom
<<Sindarin parser: procedures>>=
  recursive subroutine decode_atom (builder, code, success)
    class(pnd_atom_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%create_node_code (code)
       call builder%next_part (POS_ID)
       call builder%stay ()
    case (POS_ID)
       call builder%create_id_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_atom
  
@ %def decode_atom
@ The atom code indicates a reference object.
<<Sindarin parser: atom: TBP>>=
  procedure :: create_node_code => create_node_code_atom
<<Sindarin parser: procedures>>=
  subroutine create_node_code_atom (builder, code)
    class(pnd_atom_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_REFERENCE)
  end subroutine create_node_code_atom
  
@ %def create_node_code_atom
@ This is the code for the variable ID.  Currently just a variable name.
<<Sindarin parser: atom: TBP>>=
  procedure :: create_id_code => create_id_code_atom
<<Sindarin parser: procedures>>=
  subroutine create_id_code_atom (builder, code)
    class(pnd_atom_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_ID)
    call code%create_string_val ([builder%pn%get_string ()])
  end subroutine create_id_code_atom
  
@ %def create_id_code_atom
@
\subsubsection{Expression}
Expressions with binary operators need special consideration.  In the current
syntax table, operator priorities are not represented, so all expressions look
flat in the parse tree.  It is the duty of the operator-expression decoder to
reorganize this into a master expression where subexpressions of higher
priority are separated by the lowest-priority operator in the original.

This regrouping is done explicitly, i.e., we construct a new parse node if
necessary and link this to the appropriate subnode.  When done, we can decode
the fake parse node as if it consists of a single flat expression, before we
consider the subnodes recursively, as the master-expression elements.

While [[n_sub]] is the original number of terms, [[n_terms]] is
the actual number after rearrangement.

The [[pn_expr_t]] object provides all necessary functionality, since
all operator expressions have similar structure.  The only distinction is in
the actual codes, which are therefore not implemented in this abstract base
type.

If the expression has no binary operation, so it contains of a single subnode,
the [[pnd_expr_t]] object just transfers decoding to this subnode.

An expression with an initial minus (or plus) sign is also handled here.  We
keep track of the sign by a flag in the decoder object and apply the decoding
to the expression behind the sign.
<<Sindarin parser: decoder selection>>=
  case ("expr")
     call allocate_expr_decoder (pn_decoder, pn, signed=.false.)
  case ("signed_expr")
     call allocate_expr_decoder (pn_decoder, pn, signed=.true.)
@ We allocate the approriate decoder for the expression.  To handle a sign
prefix, we allow to replace the master parse node [[pn]] by a sub-node and
encode the sign instead in the allocated builder type.  Also, a plus sign is
to be dropped.
<<Sindarin parser: procedures>>=
  subroutine allocate_expr_decoder (builder, pn, signed)
    class(pn_decoder_t), intent(inout), pointer :: builder
    type(parse_node_t), intent(inout), pointer :: pn
    logical, intent(in) :: signed
    logical :: minus_sign
    type(syntax_rule_t), pointer :: rule_sign
    type(parse_node_t), pointer :: pn_sub
    logical, dimension(:), allocatable :: is_master_op
    type(string_t), dimension(:), allocatable :: key, master_key
    type(string_t) :: select_key
    integer :: n_sub
    !    print *
    !    print *, "allocate expr decoder"
    !    call pn%write ()
    if (signed) then
       call get_sign (pn, minus_sign)
       pn_sub => pn%get_sub_ptr ()
       rule_sign => pn_sub%get_rule_ptr ()
       pn => pn%get_sub_ptr (2)
    else
       rule_sign => null ()
       minus_sign = .false.
    end if
    n_sub = pn%get_n_sub ()
    if (n_sub == 1) then
       pn => pn%get_sub_ptr ()
       if (minus_sign) then
          select case (char (pn%get_rule_key ()))
          case ("integer_literal")
             allocate (pnd_negative_integer_t :: builder)
          case default
             allocate (pnd_negative_wrapper_t :: builder)
          end select
       else
          select case (char (pn%get_rule_key ()))
          case ("integer_literal")
             allocate (pnd_positive_integer_t :: builder)
          case default
             allocate (pnd_positive_wrapper_t :: builder)
          end select
       end if
    else
       call get_all_opkeys (pn, n_sub, minus_sign, key)
       call identify_master_expression (key, minus_sign, is_master_op)
       if (signed .and. is_master_op(1)) then
          if (minus_sign) then
             allocate (pnd_negative_wrapper_t :: builder)
          else
             allocate (pnd_positive_wrapper_t :: builder)
          end if
       else
          is_master_op(1) = .true.
          ! master_key = pack (key, is_master_op)
          call pack_array (key, is_master_op, master_key)
          select_key = master_key(2)
          select case (char (select_key))
          case (":", ",", "=>")
             allocate (pnd_container_expr_t :: builder)
          case ("and", "or")
             allocate (pnd_logical_expr_t :: builder)
          case ("==", "<>", "<", ">", "<=", ">=")
             allocate (pnd_comparison_expr_t :: builder)
          case ("+", "-", "*", "/", "^")
             allocate (pnd_integer_expr_t :: builder)
          case default
             call msg_bug ("Sindarin parser: expr decoder: illegal key '" &
                  // char (select_key) // "'")
          end select
       end if
       select type (builder)
       class is (pnd_expr_t)
          builder%n_sub = n_sub
          builder%is_master_op = is_master_op
          builder%minus_sign = minus_sign
          builder%rule_sign => rule_sign
          builder%n_terms = count (is_master_op)
          allocate (builder%key (builder%n_terms))
          builder%key(1) = ""
          builder%key(2:) = master_key(2:)
       end select
    end if
  end subroutine allocate_expr_decoder
  
@ %def allocate_expr_decoder
@ Auxiliary, workaround for the PACK implementation of
gfortran.  (Update: probably unnecessary, but doesn't hurt either.)
<<Sindarin parser: procedures>>=
  subroutine pack_array (s_in, mask, s_out)
    type(string_t), dimension(:), intent(in) :: s_in
    logical, dimension(:), intent(in) :: mask
    type(string_t), dimension(:), allocatable, intent(inout) :: s_out
    integer :: i, k
    allocate (s_out (count (mask)))
    k = 1
    do i = 1, size (s_in)
       if (mask(i)) then
          s_out(k) = s_in(i)
          k = k + 1
       end if
    end do
  end subroutine pack_array
    
@ %def pack_array
@ Check the sign, assuming that this is a [[signed_expr]] node.
<<Sindarin parser: procedures>>=
  subroutine get_sign (pn, minus_sign)
    class(parse_node_t), intent(in), target :: pn
    logical, intent(out) :: minus_sign
    type(parse_node_t), pointer :: pn_key
    pn_key => pn%get_sub_ptr ()
    minus_sign = pn_key%get_rule_key () == "-"
  end subroutine get_sign
  
@ %def get_sign
@
<<Sindarin parser: procedures>>=
  subroutine get_all_opkeys (pn, n_sub, minus_sign, key)
    type(parse_node_t), intent(in), target :: pn
    integer, intent(in) :: n_sub
    logical, intent(in) :: minus_sign
    type(string_t), dimension(:), intent(inout), allocatable :: key
    type(parse_node_t), pointer :: pn_op_clause, pn_key
    integer :: i
    allocate (key (n_sub))
    if (minus_sign) then
       key(1) = "-"
    else
       key(1) = ""
    end if
    do i = 2, n_sub
       pn_op_clause => pn%get_sub_ptr (i)
       pn_key => pn_op_clause%get_sub_ptr ()
       key(i) = pn_key%get_rule_key ()
    end do
  end subroutine get_all_opkeys
  
@ %def get_opkeys
@ Identify the master expression by checking operator keys.  We set the true
flag for all operands that are preceded by an operator of lowest priority.

Flag for the first position: if there is a minus sign for the first item and
there are more operators of same priority (i.e., an addition), we unset the
flag for the first position.  That means, the sign should not apply to the
whole expression but be imported into the first item.  The same applies if
the operation is of lower priority.  If the minus sign is highest priority, it
will be applied to the whole expression.
<<Sindarin parser: procedures>>=
  subroutine identify_master_expression (key, minus_sign, is_master_op)
    type(string_t), dimension(:), intent(in) :: key
    logical, intent(in) :: minus_sign
    logical, dimension(:), intent(inout), allocatable :: is_master_op
    integer, dimension(:), allocatable :: prio
    integer :: i, n_sub, min_prio
    n_sub = size (key)
    allocate (prio (n_sub), is_master_op (n_sub))
    prio(1) = unary_priority (key(1))
    do i = 2, n_sub
       prio(i) = binary_priority (key(i))
    end do
    min_prio = minval (prio)
    is_master_op = prio == min_prio
    if (minus_sign) then
       if (any (is_master_op(2:)))  is_master_op(1) = .false.
    end if
  end subroutine identify_master_expression
  
@ %def identify_master_expression
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t), abstract :: pnd_expr_t
     private
     type(syntax_rule_t), pointer :: rule_orig => null ()
     integer :: n_sub = 0
     integer :: n_terms = 0
     logical, dimension(:), allocatable :: is_master_op
     type(string_t), dimension(:), allocatable :: key
     logical :: minus_sign = .false.
     type(syntax_rule_t), pointer :: rule_sign => null ()
     logical :: use_pn_sub = .false.
     logical, dimension(:), allocatable :: new_pn
     type(parse_node_p), dimension(:), allocatable :: pn_sub
   contains
   <<Sindarin parser: operator expr: TBP>>
  end type pnd_expr_t
  
@ %def pnd_expr_t
@ We need a specific finalizer that deallocates any made-up parse nodes for
nontrivial subexpressions.  Those nodes would be allocated via pointer,
therefore an explicit plain deallocate for the nodes and their immediate
sub-nodes.  However, there should not be any further finalization, since the
sub-nodes are shallow copies of nodes in the original parse tree.

Note: If the internal implementation of parse nodes is changed, we should
reconsider this and the following procedures, where memory and pointer
management indirectly depends on this implementation.
<<Sindarin parser: operator expr: TBP>>=
  procedure :: final => final_expr
<<Sindarin parser: procedures>>=
  subroutine final_expr (builder)
    class(pnd_expr_t), intent(inout) :: builder
    integer :: j, k, n_sub
    type(parse_node_t), pointer :: pn_branch, pn_sub
    if (allocated (builder%pn_sub)) then
       do k = 1, size (builder%pn_sub)
          if (.not. builder%new_pn(k))  cycle
          pn_branch => builder%pn_sub(k)%ptr
          n_sub = pn_branch%get_n_sub () 
          if (n_sub > 1) then
             do j = n_sub, 1, -1
                pn_sub => pn_branch%get_sub_ptr (j)
                deallocate (pn_sub)
             end do
             deallocate (pn_branch)
          end if
       end do
    end if
  end subroutine final_expr
  
@ %def final_expr
@ We override the index versions of those getter routines.  If there is an
allocate subexpression array, we point to that instead of the normal
sub-nodes.
<<Sindarin parser: operator expr: TBP>>=
  procedure :: get_pn1 => expr_get_pn_index
  procedure :: get_pn2 => expr_get_pn_array
<<Sindarin parser: procedures>>=
  subroutine expr_get_pn_index (builder, i, pn, key)
    class(pnd_expr_t), intent(in) :: builder
    integer, intent(in) :: i
    type(parse_node_t), intent(out), pointer :: pn
    type(string_t), intent(out), optional :: key
    type(syntax_rule_t), pointer :: rule
    if (builder%use_pn_sub) then
       pn => builder%pn_sub(i)%ptr
    else
       pn => builder%pn%get_sub_ptr (i)
    end if
    if (present (key)) then
       if (associated (pn)) then
          rule => pn%get_rule_ptr ()
          key = rule%get_key ()
       else
          key = ""
       end if
    end if
  end subroutine expr_get_pn_index
          
  subroutine expr_get_pn_array (builder, ii, pn, key)
    class(pnd_expr_t), intent(in) :: builder
    integer, dimension(:), intent(in) :: ii
    type(parse_node_t), intent(out), pointer :: pn
    type(string_t), intent(out), optional :: key
    type(syntax_rule_t), pointer :: rule
    integer :: k
    if (builder%use_pn_sub) then
       pn => builder%pn_sub(ii(1))%ptr
    else
       pn => builder%pn%get_sub_ptr (ii(1))
    end if
    do k = 2, size (ii)
       if (associated (pn)) then
          pn => pn%get_sub_ptr (ii(k))
       else
          exit
       end if
    end do
    if (present (key)) then
       if (associated (pn)) then
          rule => pn%get_rule_ptr ()
          key = rule%get_key ()
       else
          key = ""
       end if
    end if
  end subroutine expr_get_pn_array
          
@ %def expr_get_pn_index
@ %def expr_get_pn_array
@ Initialize the decoder for a generic operator expression.  

If the number of terms is just one, this represents actually a wrapper node,
which is skipped in the output code.

If the expression is a sequence of operations with uniform priority, we can
proceed and directly iterate through members and core.

However, if different priorities are present, we have to re-organize
the expression first.  We identify the operators of lowest priority and group
the sub-expressions that are bound more tightly together.  To this end, we
create a new array of parse nodes that represent those sub-expressions.  The
master object has to behave as if it was built out of those subexpressions.

The substructure of the new subexpression nodes has also to be re-created.  If a
subexpression behaves as an atom, we merely assign a pointer to the
original parse node.  If not, we have to create a new branch node with the
appropriate syntax rule for the subexpression.  Its children are allocated as
copies of their counterparts in the original parse tree.  When done, we can
present the made-up branch nodes to the parser in the next recursion step.

Note: If the internal implementation of parse nodes is changed, we should
reconsider the algorithm, where memory and pointer management indirectly
depends on this implementation.
<<Sindarin parser: operator expr: TBP>>=
  procedure :: setup => setup_expr
<<Sindarin parser: procedures>>=
  subroutine setup_expr (builder)
    class(pnd_expr_t), intent(inout) :: builder

   !   print *
   !   print *, "setup master expr"
   !   call builder%pn%write ()
    if (builder%n_terms < builder%n_sub .or. builder%minus_sign) then
       call create_fake_expr_node ()
       builder%use_pn_sub = .true.
    end if
  contains
    subroutine create_fake_expr_node ()
      integer :: i_start, k
      allocate (builder%pn_sub (builder%n_terms))
      allocate (builder%new_pn (builder%n_terms), source=.false.)
      i_start = 1
      ! print *, "create expr"
      do k = 1, builder%n_terms
         call create_fake_subexpr_node (builder%pn_sub(k)%ptr, k, i_start)
         !    print *, "subexpr", k
         !    call builder%pn_sub(k)%ptr%write ()
         ! print *, "k = ", k
         ! call builder%pn_sub(k)%ptr%write ()
      end do
    end subroutine create_fake_expr_node
    subroutine create_fake_subexpr_node (pn, k, i_start)
      type(parse_node_t), pointer, intent(inout) :: pn
      integer, intent(in) :: k
      integer, intent(inout) :: i_start
      logical, dimension(:), allocatable :: mask
      integer, dimension(:), allocatable :: ii
      type(parse_node_t), pointer :: pn_src, pn_sub
      integer :: i, j, m
      allocate (mask (builder%n_sub), source = .false.)
      mask(i_start) = .true.
      do j = i_start + 1, builder%n_sub
         if (builder%is_master_op(j)) exit
         mask(j) = .true.
      end do
      ii = pack ([(i, i=1, builder%n_sub)], mask)
      ! print *, "ii = ", ii
      if (size (ii) == 1) then
         call builder%get_pn (ii(1), pn)
      else
         !  call builder%pn%write ()
         call parse_node_create_branch (pn, builder%pn%get_rule_ptr ())
         if (ii(1) == 1) then
            call builder%get_pn (1, pn_src)
         else
            call builder%get_pn ([ii(1),2], pn_src)
         end if
         !   print *, "pn_src = "
         !   call pn_src%write ()
         call pn_src%copy (pn_sub)   ! shallow copy
         call pn%append_sub (pn_sub)
         do m = 2, size (ii)
            call builder%get_pn (ii(m), pn_src)
            call pn_src%copy (pn_sub)   ! shallow copy
            call pn%append_sub (pn_sub)
         end do
         call parse_node_freeze_branch (pn)
         if (builder%minus_sign .and. ii(1) == 1) then
            call insert_signed_expr_node (pn)
         end if
         builder%new_pn(k) = .true.
      end if
      if (j > builder%n_sub)  return
      i_start = j
    end subroutine create_fake_subexpr_node
    subroutine insert_signed_expr_node (pn)
      type(parse_node_t), intent(inout), pointer :: pn
      type(parse_node_t), pointer :: pn_signed, pn_sign
      allocate (pn_signed)
      call parse_node_create_branch (pn_signed, builder%rule)
      allocate (pn_sign)
      call parse_node_create_key (pn_sign, builder%rule_sign)
      call pn_signed%append_sub (pn_sign)
      call pn_signed%append_sub (pn)
      call parse_node_freeze_branch (pn_signed)
      pn => pn_signed
    end subroutine insert_signed_expr_node
  end subroutine setup_expr
    
@ %def setup_expr
@ Decode.  We scan the operator contents as member expressions.  The core is
an unassigned [[ref_array]] object.  We can assume that this is a genuine
operator expression, so there is more than one term.
<<Sindarin parser: operator expr: TBP>>=
  procedure :: decode => decode_expr
<<Sindarin parser: procedures>>=
  recursive subroutine decode_expr (builder, code, success)
    class(pnd_expr_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    integer :: i
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       call builder%next_part (POS_MEMBER)
       call builder%goto (1)
          !   print *, "goto 1"
    case (POS_MEMBER)
       i = builder%position%i
       if (i < builder%n_terms) then
          call builder%next_index ()
          if (builder%use_pn_sub) then
             if (builder%new_pn(i+1)) then
                call builder%goto (i+1)
             else
                call builder%goto ([i+1,2])          
             end if
          else
             call builder%goto ([i+1,2])          
          end if
          !   print *, "goto next"
          !   call builder%pn_next%write ()
       else
          call builder%next_part (POS_CORE)
          call builder%stay ()
          !   print *, "goto core"
       end if
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%next_part (POS_NONE)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_expr
  
@ %def decode_expr
@ We need the priorities of all possible operator symbols.
<<Sindarin parser: procedures>>=
  function binary_priority (op) result (p)
    type(string_t), intent(in) :: op
    integer :: p
    select case (char (op))
    case (":");    p = PRIO_COLON
    case (",");    p = PRIO_COMMA
    case ("=>");   p = PRIO_ARROW
    case ("*");    p = PRIO_MULTIPLY
    case ("/");    p = PRIO_MULTIPLY
    case ("+");    p = PRIO_ADD
    case ("-");    p = PRIO_ADD
    case ("==");   p = PRIO_COMPARE
    case ("<>");   p = PRIO_COMPARE
    case ("<");    p = PRIO_COMPARE
    case (">");    p = PRIO_COMPARE
    case ("<=");   p = PRIO_COMPARE
    case (">=");   p = PRIO_COMPARE
    case ("and");  p = PRIO_AND
    case ("or");   p = PRIO_OR
    case default
       p = 0
    end select
  end function binary_priority
  
@ %def binary_priority
@ In the unary case, currently only the minus sign is of relevance.
<<Sindarin parser: procedures>>=
  function unary_priority (op) result (p)
    type(string_t), intent(in) :: op
    integer :: p
    select case (char (op))
    case ("+");    p = PRIO_MINUS
    case ("-");    p = PRIO_MINUS
    case ("not");  p = PRIO_NOT
    case default
       p = 0
    end select
  end function unary_priority
  
@ %def unary_priority
@
\subsection{Expression wrapper}
If this decoder type is allocated, the current parse node is just a wrapper
for an enclosed expression.  There are two incarnations: the positive wrapper
should not produce code, just transfer control to the embedded node.  The
negative wrapper should insert a minus-sign node in the output code.
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_positive_wrapper_t
     private
   contains
   <<Sindarin parser: positive wrapper: TBP>>
  end type pnd_positive_wrapper_t
  
  type, extends (pn_decoder_t) :: pnd_negative_wrapper_t
     private
   contains
   <<Sindarin parser: negative wrapper: TBP>>
  end type pnd_negative_wrapper_t
  
@ %def pnd_expr_wrapper_t
@ Only in the minus-sign case, there is a return code, and also a core code
for the result.  

In both cases, we do not go to a sub-node next, but return the same node to
the iteration.  This is because the wrapper has been allocated by the
expression handler, and the sub-node has already been assigned by the handler.
<<Sindarin parser: positive wrapper: TBP>>=
  procedure :: decode => decode_positive_wrapper
<<Sindarin parser: negative wrapper: TBP>>=
  procedure :: decode => decode_negative_wrapper
<<Sindarin parser: procedures>>=
  recursive subroutine decode_positive_wrapper (builder, code, success)
    class(pnd_positive_wrapper_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%next_part (POS_NONE)
       call builder%goto ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_positive_wrapper
  
  recursive subroutine decode_negative_wrapper (builder, code, success)
    class(pnd_negative_wrapper_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%create_node_code (code)
       call builder%next_part (POS_CORE)
       call builder%goto ()
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%next_part (POS_NONE)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_negative_wrapper
  
@ %def decode_positive_wrapper
@ %def decode_negative_wrapper
@ The atom code indicates a reference object.
<<Sindarin parser: positive wrapper: TBP>>=
  procedure :: create_node_code => create_node_code_positive_wrapper
<<Sindarin parser: negative wrapper: TBP>>=
  procedure :: create_node_code => create_node_code_negative_wrapper
<<Sindarin parser: procedures>>=
  subroutine create_node_code_positive_wrapper (builder, code)
    class(pnd_positive_wrapper_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call msg_bug ("Sindarin parser: positive-sign code requested")
  end subroutine create_node_code_positive_wrapper
  
  subroutine create_node_code_negative_wrapper (builder, code)
    class(pnd_negative_wrapper_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("minus"), MODE_CONSTANT, &
         0, 1, 1])
  end subroutine create_node_code_negative_wrapper
  
@ %def create_node_code_positive_wrapper
@ %def create_node_code_negative_wrapper
@
\subsection{Container expression}
This part handles containers (list-like constructions).  The container items are
any expressions, separated by '[[:]]' or '[[,]]' or '[[=>]]'.  The three
separators have different priority, with the '[[:]]' sign binding most
tightly.

Containers are transformed into some incarnation of a container object.  The
actual kind of object is not related to the syntax for defining them.

The container expression is a particular case of an operator, syntactically.
<<Sindarin parser: decoder selection>>=
  case ("container_expr")
     allocate (pnd_container_expr_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pnd_expr_t) :: pnd_container_expr_t
     private
   contains
   <<Sindarin parser: container expr: TBP>>
  end type pnd_container_expr_t
  
@ %def pnd_container_expr_t
@ The operator code for the master node of a container expression.
<<Sindarin parser: container expr: TBP>>=
  procedure :: create_node_code => create_node_code_container_expr
<<Sindarin parser: procedures>>=
  subroutine create_node_code_container_expr (builder, code)
    class(pnd_container_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    integer :: n_terms
    n_terms = builder%n_terms
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("container"), MODE_CONSTANT, &
         0, n_terms, n_terms])
    call code%create_integer_val ([separator_code (builder%key(2))])
  end subroutine create_node_code_container_expr
    
@ %def create_node_code_container_expr
@ Decode the separator key.
<<Sindarin parser: procedures>>=
  function separator_code (key) result (code)
    type(string_t), intent(in) :: key
    integer :: code
    select case (char (key))
    case (":");  code = CT_TUPLE
    case (",");  code = CT_LIST
    case ("=>"); code = CT_SEQUENCE
    case default
       code = 0
    end select
  end function separator_code

@ %def separator_code
@ The value core is a reference-array object that needs to know its size.
<<Sindarin parser: container expr: TBP>>=
  procedure :: create_core_code => create_core_code_container_expr
<<Sindarin parser: procedures>>=
  subroutine create_core_code_container_expr (builder, code)
    class(pnd_container_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_REF_ARRAY, [builder%n_terms])
  end subroutine create_core_code_container_expr
    
@ %def create_core_code_container_expr
@
\subsubsection{Logical expressions}
This part handles logical algebra expressions.  The decoder type is a
straightforward extension of the generic expression decoder.
<<Sindarin parser: types>>=
  type, extends (pnd_expr_t) :: pnd_logical_expr_t
     private
   contains
   <<Sindarin parser: logical expr: TBP>>
  end type pnd_logical_expr_t
  
@ %def pnd_logical_expr_t
@ The operator code for the master node of a logical expression.
<<Sindarin parser: logical expr: TBP>>=
  procedure :: create_node_code => create_node_code_logical_expr
<<Sindarin parser: procedures>>=
  subroutine create_node_code_logical_expr (builder, code)
    class(pnd_logical_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    integer :: n_terms
    n_terms = builder%n_terms
    select case (char (builder%key (2)))
    case ("and")
       call code%set (CAT_COMPOSITE, &
            [builder%get_index ("and"), MODE_CONSTANT, &
            0, n_terms, n_terms])
    case ("or")
       call code%set (CAT_COMPOSITE, &
            [builder%get_index ("or"), MODE_CONSTANT, &
            0, n_terms, n_terms])
    end select
  end subroutine create_node_code_logical_expr
    
@ %def create_node_code_logical_expr
@
\subsubsection{Logical not}
The logical not applies to a restricted subset of expressions: comparisons and
logical terms.  This should be represented in the syntax, so we don't care in
the decoding process.
<<Sindarin parser: decoder selection>>=
  case ("not_clause")
     allocate (pnd_logical_not_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_logical_not_t
     private
   contains
   <<Sindarin parser: logical not: TBP>>
  end type pnd_logical_not_t
  
@ %def pnd_logical_not_t
@ Decode.  The [[not]] case is similar to the binary case, but has just one
member.
<<Sindarin parser: logical not: TBP>>=
  procedure :: decode => decode_logical_not
<<Sindarin parser: procedures>>=
  recursive subroutine decode_logical_not (builder, code, success)
    class(pnd_logical_not_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%create_node_code (code)
       call builder%next_part (POS_MEMBER)
       call builder%stay ()
    case (POS_MEMBER)
       call builder%next_part (POS_CORE)
       call builder%goto (2)
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_logical_not
  
@ %def decode_logical_not
@ The operator code.
<<Sindarin parser: logical not: TBP>>=
  procedure :: create_node_code => create_node_code_logical_not
<<Sindarin parser: procedures>>=
  subroutine create_node_code_logical_not (builder, code)
    class(pnd_logical_not_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("not"), MODE_CONSTANT, &
         0, 1, 1])
  end subroutine create_node_code_logical_not
    
@ %def create_node_code_logical_not
@
\subsubsection{Logical literal}
The logical values [[true]] and [[false]] are coded as [[logical]] objects
with a definite initial value.  They have their own syntax rules and decoder.
<<Sindarin parser: decoder selection>>=
  case ("true")
     allocate (pnd_logical_literal_t :: pn_decoder)
     select type (pn_decoder)
     type is (pnd_logical_literal_t)
        pn_decoder%value = .true.
     end select
  case ("false")
     allocate (pnd_logical_literal_t :: pn_decoder)
     select type (pn_decoder)
     type is (pnd_logical_literal_t)
        pn_decoder%value = .false.
     end select
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_logical_literal_t
     private
     logical :: value
   contains
   <<Sindarin parser: logical literal: TBP>>
  end type pnd_logical_literal_t
  
@ %def pnd_logical_literal_t
@ Decode.
<<Sindarin parser: logical literal: TBP>>=
  procedure :: decode => decode_logical_literal
<<Sindarin parser: procedures>>=
  recursive subroutine decode_logical_literal (builder, code, success)
    class(pnd_logical_literal_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn1, pn_op
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%create_node_code (code)
       call builder%next_part (POS_CORE)
       call builder%stay ()
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_logical_literal
  
@ %def decode_logical_literal
@ The operator code for the logical literal.
<<Sindarin parser: logical literal: TBP>>=
  procedure :: create_node_code => create_node_code_logical_literal
<<Sindarin parser: procedures>>=
  subroutine create_node_code_logical_literal (builder, code)
    class(pnd_logical_literal_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("logical"), MODE_CONSTANT])
  end subroutine create_node_code_logical_literal
    
@ %def create_node_code_logical_literal
@ For a literal, the core value is defined.
<<Sindarin parser: logical literal: TBP>>=
  procedure :: create_core_code => create_core_code_logical_literal
<<Sindarin parser: procedures>>=
  subroutine create_core_code_logical_literal (builder, code)
    class(pnd_logical_literal_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_VALUE)
    call code%create_logical_val ([builder%value])
  end subroutine create_core_code_logical_literal
    
@ %def create_core_code_logical_literal
@
\subsubsection{Comparison expression}
This part handles comparison algebra expressions, except for the literal
constants.
<<Sindarin parser: decoder selection>>=
  case ("comparison_expr")
     allocate (pnd_comparison_expr_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_comparison_expr_t
     private
     integer :: n_terms = 0
   contains
   <<Sindarin parser: comparison expr: TBP>>
  end type pnd_comparison_expr_t
  
@ %def pnd_comparison_expr_t
@ Initialize.  Again, [[n_terms]]=1 means that this node is just a wrapper
node.
<<Sindarin parser: comparison expr: TBP>>=
  procedure :: setup => setup_comparison_expr
<<Sindarin parser: procedures>>=
  subroutine setup_comparison_expr (builder)
    class(pnd_comparison_expr_t), intent(inout) :: builder
    builder%n_terms = builder%get_n_terms ()
  end subroutine setup_comparison_expr
    
@ %def setup_comparison_expr
@ Decode.
<<Sindarin parser: comparison expr: TBP>>=
  procedure :: decode => decode_comparison_expr
<<Sindarin parser: procedures>>=
  recursive subroutine decode_comparison_expr (builder, code, success)
    class(pnd_comparison_expr_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    integer :: i, n_terms
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       n_terms = builder%n_terms
       if (n_terms == 1) then
          call builder%next_part (POS_NONE)
          call builder%goto (1)
       else
          call builder%create_node_code (code)
          call builder%next_part (POS_MEMBER)
          call builder%goto (1)
       end if
    case (POS_MEMBER)
       i = builder%position%i
       if (i < builder%n_terms) then
          call builder%next_index ()
          call builder%goto ([i+1,2])
       else
          call builder%next_part (POS_CORE)
          call builder%stay ()
       end if
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_comparison_expr
  
@ %def decode_comparison_expr
@ The operator code for the master node of a comparison expression.  The
sequence of comparison sign is coded as a sequence of integers, associated to
the node.
<<Sindarin parser: comparison expr: TBP>>=
  procedure :: create_node_code => create_node_code_comparison_expr
<<Sindarin parser: procedures>>=
  subroutine create_node_code_comparison_expr (builder, code)
    class(pnd_comparison_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    integer, dimension(:), allocatable :: cmp_code
    integer :: n_terms, i
    n_terms = builder%n_terms
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("compare"), MODE_CONSTANT, &
         0, n_terms, n_terms])
    allocate (cmp_code (builder%n_terms), source = CMP_NONE)
    do i = 2, builder%n_terms
       select case (char (builder%get_key ([i,1])))
       case ("==");  cmp_code(i) = CMP_EQ
       case ("<>");  cmp_code(i) = CMP_NE
       case ("<");   cmp_code(i) = CMP_LT
       case (">");   cmp_code(i) = CMP_GT
       case ("<=");  cmp_code(i) = CMP_LE
       case (">=");  cmp_code(i) = CMP_GE
       end select
    end do
    call code%create_integer_val (cmp_code)
  end subroutine create_node_code_comparison_expr
    
@ %def create_node_code_comparison_expr
@
\subsubsection{Integer expression}
Here, we handle integer expressions including constants.  The possibility of
signed literals requires some transformation of expressions into literals.
<<Sindarin parser: types>>=
  type, extends (pnd_expr_t) :: pnd_integer_expr_t
     private
   contains
   <<Sindarin parser: integer expr: TBP>>
  end type pnd_integer_expr_t
  
@ %def pnd_integer_expr_t
@ The operator code for the master node of a integer expression.  We code the
sequence of operators as a sequence of logicals that distinguish between [[+]]
and [[-]] or [[*]] and [[/]], respectively.
<<Sindarin parser: integer expr: TBP>>=
  procedure :: create_node_code => create_node_code_integer_expr
<<Sindarin parser: procedures>>=
  subroutine create_node_code_integer_expr (builder, code)
    class(pnd_integer_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    logical, dimension(:), allocatable :: inverse
    integer :: n_terms, i
    n_terms = builder%n_terms
    select case (char (builder%key(2)))
    case ("*", "/")
       call code%set (CAT_COMPOSITE, &
            [builder%get_index ("multiply"), MODE_CONSTANT, &
            0, n_terms, n_terms])
    case ("+", "-")
       call code%set (CAT_COMPOSITE, &
            [builder%get_index ("add"), MODE_CONSTANT, &
            0, n_terms, n_terms])
    case default
       call msg_bug ("Sindarin: decode integer expr: illegal key")
    end select
    allocate (inverse (builder%n_terms), source = .false.)
    do i = 2, builder%n_terms
       select case (char (builder%get_key ([i,1])))
       case ("-", "/");  inverse(i) = .true.
       end select
    end do
    call code%create_logical_val (inverse)
  end subroutine create_node_code_integer_expr
    
@ %def create_node_code_integer_expr
@
\subsubsection{Integer literals}
Now handle (signed) integer literals.
<<Sindarin parser: decoder selection>>=
  case ("integer_literal")
     allocate (pnd_positive_integer_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t), abstract :: pnd_integer_literal_t
     private
     integer :: value
   contains
   <<Sindarin parser: integer literal: TBP>>
  end type pnd_integer_literal_t
  
  type, extends (pnd_integer_literal_t) :: pnd_positive_integer_t
     private
   contains
   <<Sindarin parser: positive integer: TBP>>
  end type pnd_positive_integer_t
  
  type, extends (pnd_integer_literal_t) :: pnd_negative_integer_t
     private
   contains
   <<Sindarin parser: negative integer: TBP>>
  end type pnd_negative_integer_t
  
@ %def pnd_integer_literal_t
@ %def pnd_positive_integer_t
@ %def pnd_negative_integer_t
@ We fetch the value upon initialization, taking care of a possible sign
node.
<<Sindarin parser: integer literal: TBP>>=
  procedure (setup_integer_literal), deferred :: setup
<<Sindarin parser: interfaces>>=
  abstract interface
     subroutine setup_integer_literal (builder)
       import
       class(pnd_integer_literal_t), intent(inout) :: builder
     end subroutine setup_integer_literal
  end interface
     
<<Sindarin parser: positive integer: TBP>>=
  procedure :: setup => setup_positive_integer
<<Sindarin parser: negative integer: TBP>>=
  procedure :: setup => setup_negative_integer
<<Sindarin parser: procedures>>=
  subroutine setup_positive_integer (builder)
    class(pnd_positive_integer_t), intent(inout) :: builder
    builder%value = builder%get_integer ()
  end subroutine setup_positive_integer
  
  subroutine setup_negative_integer (builder)
    class(pnd_negative_integer_t), intent(inout) :: builder
    builder%value = - builder%get_integer ()
  end subroutine setup_negative_integer
  
@ %def setup_positive_integer
@ %def setup_negative_integer
@ 
<<Sindarin parser: integer literal: TBP>>=
  procedure :: decode => decode_integer_literal
<<Sindarin parser: procedures>>=
  recursive subroutine decode_integer_literal (builder, code, success)
    class(pnd_integer_literal_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    type(parse_node_t), pointer :: pn1, pn_op
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       call builder%next_part (POS_CORE)
       call builder%stay ()
    case (POS_CORE)
       call builder%create_core_code (code)
       call code%set (CAT_VALUE)
       call code%create_integer_val ([builder%value])
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_integer_literal
  
@ %def decode_integer_literal
@ Simple lookup here.
<<Sindarin parser: integer literal: TBP>>=
  procedure :: create_node_code => create_node_code_integer_literal
<<Sindarin parser: procedures>>=
  subroutine create_node_code_integer_literal (builder, code)
    class(pnd_integer_literal_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("integer"), MODE_CONSTANT])
  end subroutine create_node_code_integer_literal
    
@ %def create_node_code_integer_literal
@ For a literal, the core value is defined.
<<Sindarin parser: integer literal: TBP>>=
  procedure :: create_core_code => create_core_code_integer_literal
<<Sindarin parser: procedures>>=
  subroutine create_core_code_integer_literal (builder, code)
    class(pnd_integer_literal_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_VALUE)
    call code%create_integer_val ([builder%value])
  end subroutine create_core_code_integer_literal
    
@ %def create_core_code_integer_literal
@
\subsubsection{Conditional expression}
This part handles conditionals (if-then-else).
<<Sindarin parser: decoder selection>>=
  case ("conditional_expr")
     allocate (pnd_conditional_expr_t :: pn_decoder)
<<Sindarin parser: types>>=
  type, extends (pn_decoder_t) :: pnd_conditional_expr_t
     private
     integer :: n_branches = 2
     integer :: n_terms = 3
     integer :: n_elsif = 0
     logical :: has_else = .false.
   contains
   <<Sindarin parser: conditional expr: TBP>>
  end type pnd_conditional_expr_t
  
@ %def pnd_conditional_expr_t
@ Initialize: check which parts are present and what is the total number of
terms.
<<Sindarin parser: conditional expr: TBP>>=
  procedure :: setup => setup_conditional_expr
<<Sindarin parser: procedures>>=
  subroutine setup_conditional_expr (builder)
    class(pnd_conditional_expr_t), intent(inout) :: builder
    integer :: i
    do i = 2, 3
       select case (char (builder%get_key (i)))
       case ("elsif_expr_part")
          builder%n_elsif = builder%get_n_terms (i)
       case ("else_expr_part")
          builder%has_else = .true.
       end select
    end do
    builder%n_branches = 2 + builder%n_elsif
    builder%n_terms = 2 * builder%n_branches - 1
  end subroutine setup_conditional_expr
  
@ %def setup_conditional_expr
@ Decode.

We have to take care of the members in alternating order, branch-values at odd
positions and conditions at even positions.  If there is no else-branch, we
supply one.  To this end, we append a composite of value type as the final
branch and then turn to a fake extra member index, where in fact we insert the
unknown core value of this branch in the code sequence.
<<Sindarin parser: conditional expr: TBP>>=
  procedure :: decode => decode_conditional_expr
<<Sindarin parser: procedures>>=
  recursive subroutine decode_conditional_expr (builder, code, success)
    class(pnd_conditional_expr_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    integer :: i, n_terms
    success = .true.
    select case (builder%position%part)
    case (POS_HERE)
       call builder%setup ()
       call builder%create_node_code (code)
       call builder%next_part (POS_MEMBER)
       call builder%goto ([1,4])         ! if-value
    case (POS_MEMBER)
       i = builder%position%i
       if (i == 1) then
          call builder%next_index ()
          call builder%goto ([1,2])      ! if-condition
       else if (i < 2 + 2 * builder%n_elsif .and. mod (i, 2) == 0) then
          call builder%next_index ()
          call builder%goto ([2,i/2,4])  ! elsif-value #i/2
       else if (i < 2 + 2 * builder%n_elsif .and. mod (i, 2) == 1) then
          call builder%next_index ()
          call builder%goto ([2,i/2,2])  ! elsif-condition #i/2
       else if (builder%has_else) then
          call builder%next_part (POS_CORE)
          if (builder%n_elsif > 0) then
             call builder%goto ([3,1,2]) ! else-value
          else
             call builder%goto ([2,1,2])
          end if
       else if (i < builder%n_terms) then
          call builder%create_else_code (code)
          call builder%next_index ()     ! fake else-value
          call builder%stay ()
       else
          call code%set (CAT_VALUE)      ! fake else-value core
          call builder%next_part (POS_CORE)
          call builder%stay ()
       end if
    case (POS_CORE)
       call builder%create_core_code (code)
       call builder%done ()
    case default
       call builder%fail (success)
    end select
  end subroutine decode_conditional_expr
  
@ %def decode_conditional_expr
@ Decode the master node.  We set the number of branches.
<<Sindarin parser: conditional expr: TBP>>=
  procedure :: create_node_code => create_node_code_conditional_expr
<<Sindarin parser: procedures>>=
  subroutine create_node_code_conditional_expr (builder, code)
    class(pnd_conditional_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    integer :: n_terms
    n_terms = builder%n_terms
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("conditional_expr"), MODE_CONSTANT, &
         0, n_terms, n_terms])
  end subroutine create_node_code_conditional_expr
    
@ %def create_node_code_conditional_expr
@ This comes into play when the Sindarin code did not contain the [[else]]
branch, so we have to fake it.
<<Sindarin parser: conditional expr: TBP>>=
  procedure :: create_else_code => create_else_code_conditional_expr
<<Sindarin parser: procedures>>=
  subroutine create_else_code_conditional_expr (builder, code)
    class(pnd_conditional_expr_t), intent(in) :: builder
    type(code_t), intent(out) :: code
    call code%set (CAT_COMPOSITE, &
         [builder%get_index ("integer"), MODE_CONSTANT])
  end subroutine create_else_code_conditional_expr
    
@ %def create_else_code_conditional_expr
@ 
\subsection{Unit tests}
Test module, followed by the stand-alone unit-test procedures.
<<[[sindarin_parser_ut.f90]]>>=
<<File header>>

module sindarin_parser_ut

  use unit_tests
  use sindarin_parser_uti
  
<<Standard module head>>

<<Sindarin parser: public test>>

contains
  
<<Sindarin parser: test driver>>

end module sindarin_parser_ut
@ %def sindarin_parser_ut
@ 
<<[[sindarin_parser_uti.f90]]>>=
<<File header>>

module sindarin_parser_uti
  
  <<Use strings>>
    use io_units
    use lexers
    use syntax_rules
    use parser
    use codes
    use object_base
    use object_builder
    use sindarin_parser

<<Standard module head>>

<<Sindarin parser: test declarations>>

contains
  
<<Sindarin parser: tests>>

end module sindarin_parser_uti
@ %def sindarin_parser_uti
@ API: driver for the unit tests below.
<<Sindarin parser: public test>>=
  public :: sindarin_parser_test
<<Sindarin parser: test driver>>=
  subroutine sindarin_parser_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Sindarin parser: execute tests>>  
  end subroutine sindarin_parser_test
@ %def sindarin_parser_test 
@
\subsubsection{Syntax table}
Build and display the Sindarin syntax
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_1, "sindarin_parser_1", &
       "syntax table", &
       u, results)
<<Sindarin parser: test declarations>>=  
  public :: sindarin_parser_1
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_1 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: sindarin_parser_1"
    write (u, "(A)")  "*   Purpose: build syntax table"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()
    call syntax_sindarin_write (u)
    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_1"
    
  end subroutine sindarin_parser_1

@ %def sindarin_parser_1
@
\subsubsection{Repository}
Build and display the Sindarin repository
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_2, "sindarin_parser_2", &
       "repository", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_2
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_2 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    type(string_t), dimension(:), allocatable :: name
    integer :: i

    write (u, "(A)")  "* Test output: sindarin_parser_2"
    write (u, "(A)")  "*   Purpose: build Sindarin repository"
    write (u, "(A)")      
    
    call make_sindarin_repository (repository)
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Name array"
    write (u, "(A)")
    
    call repository%get_prototype_names (name)
    do i = 1, size (name)
       write (u, "(I0,1x,A)")  i, char (name (i))
    end do

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_2"
    
  end subroutine sindarin_parser_2

@ %def sindarin_parser_2
@
\subsubsection{Logical expressions}
Parse a simple Sindarin script.
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_3, "sindarin_parser_3", &
       "parse script: logicals", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_3
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_3 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_pt, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_3"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")

    write (u_sin, "(A)")  "logical a"
    write (u_sin, "(A)")  "logical b = true"
    write (u_sin, "(A)")  "a = b and not false"          ! = true 
    write (u_sin, "(A)")  "b = (a or true) and (not b)"  ! = false
    write (u_sin, "(A)")  "a = true and true and true"   ! = true
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "()", &
         special_class = [ "=" ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder (see 'sindarin_parser_3.pt.dat')"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)

    u_pt = free_unit ()
    open (u_pt, file="sindarin_parser_3.pt.dat", &
         status="replace", action="readwrite")
    call decoder%write (u_pt)
    close (u_pt)

    write (u, "(A)")  "* Decode (see 'sindarin_parser_3.code.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_3.code.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_3"
    
  end subroutine sindarin_parser_3

@ %def sindarin_parser_3
@
\subsubsection{Integer expressions}
Parse a simple Sindarin script.
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_4, "sindarin_parser_4", &
       "parse script: integers", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_4
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_4 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_pt, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_4"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")
    
    write (u_sin, "(A)")  "integer a"
    write (u_sin, "(A)")  "integer b = -42"
    write (u_sin, "(A)")  "a = b / (7 - 1)"      ! = -7 
    write (u_sin, "(A)")  "b = -b * 2 + a"       ! = 77
    write (u_sin, "(A)")  "a = 1 + 2 - 3"        ! = 0
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "()", &
         special_class = [ &
         "=   " , &
         "+-*/" &
         ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder (see 'sindarin_parser_4.pt.dat')"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)

    u_pt = free_unit ()
    open (u_pt, file="sindarin_parser_4.pt.dat", &
         status="replace", action="readwrite")
    call decoder%write (u_pt)
    close (u_pt)

    write (u, "(A)")  "* Decode (see 'sindarin_parser_4.code.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_4.code.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_4"
    
  end subroutine sindarin_parser_4

@ %def sindarin_parser_4
@
\subsubsection{Comparison expressions}
Parse a simple Sindarin script.
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_5, "sindarin_parser_5", &
       "parse script: comparisons", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_5
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_5 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_pt, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_5"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")
    
    write (u_sin, "(A)")  "logical a"
    write (u_sin, "(A)")  "integer i = 42"
    write (u_sin, "(A)")  "a = i == 42"        ! = true
    write (u_sin, "(A)")  "a = 13 < i <= 42"   ! = true
    write (u_sin, "(A)")  "a = a and i < 0"    ! = false
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "()", &
         special_class = [ &
         "=<> " , &
         "+-*/" &
         ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder (see 'sindarin_parser_5.pt.dat')"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)

    u_pt = free_unit ()
    open (u_pt, file="sindarin_parser_5.pt.dat", &
         status="replace", action="readwrite")
    call decoder%write (u_pt)
    close (u_pt)

    write (u, "(A)")  "* Decode (see 'sindarin_parser_5.code.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_5.code.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_5"
    
  end subroutine sindarin_parser_5

@ %def sindarin_parser_5
@
\subsubsection{Conditional expressions}
Parse a simple Sindarin script.
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_6, "sindarin_parser_6", &
       "parse script: conditionals", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_6
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_6 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_pt, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_6"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")
    
    write (u_sin, "(A)")  "integer i = if true then 22 endif"
    write (u_sin, "(A)")  "integer j = if false then 23 else 34 endif"
    write (u_sin, "(A)")  "integer k = if false then 24 elsif true then 35&
         & endif"
    write (u_sin, "(A)")  "integer l = if false then 25 elsif false then 36&
         & elsif false then 45 else 56 endif"
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "()", &
         special_class = [ &
         "=<> " , &
         "+-*/" &
         ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder (see 'sindarin_parser_6.pt.dat')"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)

    u_pt = free_unit ()
    open (u_pt, file="sindarin_parser_6.pt.dat", &
         status="replace", action="readwrite")
    call decoder%write (u_pt)
    close (u_pt)

    write (u, "(A)")  "* Decode (see 'sindarin_parser_6.code.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_6.code.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_6"
    
  end subroutine sindarin_parser_6

@ %def sindarin_parser_6
@
\subsubsection{Lists}
Parse a simple Sindarin script.
<<Sindarin parser: execute tests>>=
  call test (sindarin_parser_7, "sindarin_parser_7", &
       "parse script: containers", &
       u, results)
<<Sindarin parser: test declarations>>=
  public :: sindarin_parser_7
<<Sindarin parser: tests>>=  
  subroutine sindarin_parser_7 (u)
    integer, intent(in) :: u
    type(lexer_t) :: lexer
    type(stream_t), target :: stream
    type(parse_tree_t) :: parse_tree
    type(sindarin_decoder_t) :: decoder
    type(repository_t), allocatable :: repository
    type(string_t), dimension(:), allocatable :: prototype_names
    type(object_builder_t) :: builder
    type(code_t) :: code
    class(object_t), pointer :: main
    logical :: success
    integer :: u_sin, u_pt, u_code, iostat
    character(80) :: buffer

    write (u, "(A)")  "* Test output: sindarin_parser_7"
    write (u, "(A)")  "*   Purpose: parse a simple script"
    write (u, "(A)")      
    
    call syntax_sindarin_init ()

    allocate (repository)
    call make_sindarin_repository (repository)

    write (u, "(A)")  "* Create script"
    write (u, "(A)")      

    u_sin = free_unit ()
    open (u_sin, status="scratch")
    
    write (u_sin, "(A)")  "a = 1, 2, 3"		 
    write (u_sin, "(A)")  "b = 1:2, 3"	 
    write (u_sin, "(A)")  "c = 1, 2:3"
    write (u_sin, "(A)")  "d = (1, 2):3"
    write (u_sin, "(A)")  "e = 1, 2 => 3, 4:5, 6 => 7"
    
    rewind (u_sin)
    do
       read (u_sin, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (u_sin)

    write (u, "(A)")      
    write (u, "(A)")  "* Parse script"
    write (u, "(A)")      

    call lexer%init ( &
         comment_chars = "", &
         quote_chars = '', &
         quote_match = '', &
         single_chars = "(),:", &
         special_class = [ &
         "=<> " , &
         "+-*/" &
         ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_sindarin))

    call stream%init (u_sin)
    call lexer%assign_stream (stream)

    call parse_tree%parse (syntax_sindarin, lexer)

    write (u, "(A)")  "* Setup decoder (see 'sindarin_parser_7.pt.dat')"
    write (u, "(A)")
    
    call repository%get_prototype_names (prototype_names)

    call decoder%init (parse_tree, prototype_names)

    u_pt = free_unit ()
    open (u_pt, file="sindarin_parser_7.pt.dat", &
         status="replace", action="readwrite")
    call decoder%write (u_pt)
    close (u_pt)

    write (u, "(A)")  "* Decode (see 'sindarin_parser_7.code.dat')"
    write (u, "(A)")
    
    u_code = free_unit ()
    open (u_code, file="sindarin_parser_7.code.dat", &
         status="replace", action="readwrite")
    
    do
       call decoder%decode (code, success)
       if (.not. success)  exit
       call code%write (u_code)
    end do
    
    write (u, "(A)")  "* Create object tree"
    write (u, "(A)")
    
    rewind (u_code)

    call builder%import_repository (repository)
    call builder%init_empty ()

    do
       call code%read (u_code, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (u_code)

    call builder%export (main)
    
    call main%write (u)
    call remove_object (main)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"
    
    call builder%final ()
    call parse_tree%final ()

    close (u_sin)
    close (u_code)
    call stream%final ()
    call lexer%final ()

    call syntax_sindarin_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sindarin_parser_7"
    
  end subroutine sindarin_parser_7

@ %def sin
darin_parser_7
