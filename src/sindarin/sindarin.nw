% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: Sindarin


\chapter{Sindarin}

\begin{description}
\item[codes]
  Elementary codes and parameters used by the Sindarin modules.
\item[builders]
  Abstract builder that makes use of bytecode.
\item[object\_base]
  Basic objects and methods.
\item[object\_builder]
  Enables building and decoding of objects via bytecode.
\item[object\_expr]
  Statements, assignment, expressions and operators.
\item[object\_logical]
  Logical values and expressions.
\end{description}

 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Codes}
This module contains predefined numerical codes.  It also introduces
[[code_t]] as a universal non-recursive representations for objects.
<<[[codes.f90]]>>=
<<File header>>

module codes
  
<<Use strings>>
<<Use kinds>>
  use unit_tests
  use io_units

<<Standard module head>>

<<Codes: public>>

<<Codes: parameters>>

<<Codes: types>>
  
<<Codes: interfaces>>

contains
  
<<Codes: procedures>>

<<Codes: tests>>

end module codes
@ %def codes
@
\subsection{Navigation}
These codes are useful for navigation within an object tree, they represent
locations within a (composite) object.
<<Codes: parameters>>=
  integer, parameter, public :: POS_NONE = -1
  integer, parameter, public :: POS_HERE = 0
  integer, parameter, public :: POS_ID = 1
  integer, parameter, public :: POS_CORE = 2
  integer, parameter, public :: POS_MEMBER = 3
  integer, parameter, public :: POS_PRIMER = 4

@ %def POS_NONE POS_HERE POS_ID POS_CORE POS_MEMBER POS_PRIMER
@
\subsection{Object categories}
Category codes for atomic objects.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_TAG = 1
  integer, parameter, public :: CAT_VALUE = 2
  integer, parameter, public :: CAT_ID = 3

@ %def CAT_TAG CAT_VALUE CAT_ID
@ Reference object.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_REFERENCE = 99

@ %def CAT_REFERENCE
@ Category code for a composite object.
<<Codes: parameters>>=
  integer, parameter, public :: CAT_COMPOSITE = 100

@ %def CAT_COMPOSITE
@ 
\subsection{Priority values}
A list of predefined priorities.  The default
priority for atomic objects is zero, so operators get negative values.
<<Codes: parameters>>=
  integer, parameter, public :: PRIO_NOT = -100
  integer, parameter, public :: PRIO_AND = -101
  integer, parameter, public :: PRIO_OR  = -102
  
@ %def PRIO_NOT PRIO_AND PRIO_OR
@
\subsection{Minimal value container}
The universal code for an object allows us to construct and transfer objects
via a list of code numbers and elementary values.  We provide value containers
in form of one-dimensional arrays which may be of any of the elementary
Fortran types.

Compiler compatibility prohibits a polymorphic value array.  Instead, we store
an array inside the polymorphic value object.
<<Codes: types>>=
  type, abstract :: val_t
   contains
   <<Codes: val: TBP>>
  end type val_t
  
@ %def val_t
@ Each concrete value type has a unique type code.
<<Codes: val: TBP>>=
  procedure(val_get_type), deferred :: get_type
<<Codes: interfaces>>=
  abstract interface
     function val_get_type (val) result (t)
       import
       class(val_t), intent(in) :: val
       integer :: t
     end function val_get_type
  end interface
  
@ %def val_get_type
@ The initializer has to allocate the array.
<<Codes: val: TBP>>=
  procedure(val_init), deferred :: init
<<Codes: interfaces>>=
  abstract interface
     subroutine val_init (val, nval)
       import
       class(val_t), intent(out) :: val
       integer, intent(in) :: nval
     end subroutine val_init
  end interface
  
@ %def val_init
@ Return array size.
<<Codes: val: TBP>>=
  procedure(val_get_nval), deferred :: get_nval
<<Codes: interfaces>>=
  abstract interface
     function val_get_nval (val) result (nval)
       import
       class(val_t), intent(in) :: val
       integer :: nval
     end function val_get_nval
  end interface
  
@ %def val_get_nval
@ Each concrete value must have an input and an output method.  We read/write
one value entry at a time.
<<Codes: val: TBP>>=
  procedure(val_read), deferred :: read
  procedure(val_write), deferred :: write
<<Codes: interfaces>>=
  abstract interface
     subroutine val_read (val, unit, i, iostat)
       import
       class(val_t), intent(inout) :: val
       integer, intent(in) :: unit, i
       integer, intent(out), optional :: iostat
     end subroutine val_read
  end interface
       
  abstract interface
     subroutine val_write (val, unit, i)
       import
       class(val_t), intent(in) :: val
       integer, intent(in) :: unit, i
     end subroutine val_write
  end interface
       
@ %def val_read 
@ %def val_write
@
\subsection{Universal code}
The code object consists of a category code which determines the
interpretation, a number of integer attribute codes, and an optional value.
For the attributes, we use a fixed-size array for simplicity.

We deliberately make all components public.
<<Codes: parameters>>=
  integer, parameter :: NATT_MAX = 16
  integer, parameter :: NAME_LEN_MAX = 256
  
<<Codes: public>>=
  public :: code_t
<<Codes: types>>=
  type :: code_t
     integer :: cat = 0
     integer :: natt = 0
     integer, dimension(NATT_MAX) :: att = 0
     class(val_t), allocatable :: val
   contains
   <<Codes: code: TBP>>
  end type code_t
     
@ %def code_t
@ Methods for input and output.  We mostly read integers.
<<Codes: code: TBP>>=
  procedure :: read => code_read
  procedure :: write => code_write
<<Codes: procedures>>=
  subroutine code_read (code, unit, iostat)
    class(code_t), intent(out) :: code
    integer, intent(in) :: unit
    integer, intent(out), optional :: iostat
    logical :: err
    integer :: cat, vt, nval, natt, i
    err = .false.
    if (present (iostat)) then
       read (unit, *, iostat=iostat) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
       call check;  if (err)  return
    else
       read (unit, *) &
            cat, vt, nval, natt, (code%att(i), i = 1, natt)
    end if
    code%cat = cat
    code%natt = natt
    if (vt > 0) then
       call code%create_val (code%val, vt, nval)
       do i = 1, nval
          call code%val%read (unit, i, iostat=iostat)
          if (present (iostat))  call check;  if (err)  return
       end do
    end if
  contains
    subroutine check
      err = iostat /= 0
    end subroutine check
  end subroutine code_read
    
  subroutine code_write (code, unit, iostat, verbose)
    class(code_t), intent(in) :: code
    integer, intent(in), optional :: unit
    integer, intent(out), optional :: iostat
    logical, intent(in), optional :: verbose
    logical :: verb
    integer :: natt, nval, i, u
    u = given_output_unit (unit)
    verb = .false.; if (present (verbose))  verb = verbose
    if (verb)  write (u, "(1x,A,1x)", advance="no")  "c="
    write (u, "(I0)", advance="no")  code%cat
    if (verb)  write (u, "(2x,A)", advance="no")  "vt="
    if (allocated (code%val)) then
       write (u, "(1x,I0)", advance="no")  code%val%get_type ()
       nval = code%val%get_nval ()
    else
       write (u, "(1x,I0)", advance="no")  0
       nval = 0
    end if
    if (verb)  write (u, "(2x,A)", advance="no")  "nv="
    write (u, "(1x,I0)", advance="no")  nval
    natt = code%natt
    if (.not. verb)  write (u, "(1x,I0)", advance="no")  natt
    if (natt > 0) then
       if (verb)  write (u, "(2x,A)", advance="no")  "att="
       write (u, "(*(1x,I0,:))")  code%att(1:natt)
    else
       write (u, *)
    end if
    do i = 1, nval
       if (verb)  write (u, "(5x)", advance="no")
       call code%val%write (u, i)
    end do
  end subroutine code_write
    
@ %def code_read
@ %def code_write
@
\subsection{Concrete value types}
These are the Fortran elementary types that we allow.

\subsubsection{Logical}
<<Codes: public>>=
  public :: val_logical_t
<<Codes: types>>=
  type, extends (val_t) :: val_logical_t
     logical, dimension(:), allocatable :: x
   contains
   <<Codes: val logical: TBP>>
  end type val_logical_t
     
@ %def val_logical_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_LOGICAL = 1
<<Codes: val cases>>=
  case (VT_LOGICAL);  allocate (val_logical_t :: val)
<<Codes: val logical: TBP>>=
  procedure :: get_type => val_logical_get_type
<<Codes: procedures>>=
  function val_logical_get_type (val) result (type)
    class(val_logical_t), intent(in) :: val
    integer :: type
    type = VT_LOGICAL
  end function val_logical_get_type
  
@ %def val_logical_get_type
@ Init.  Allocate the array.
<<Codes: val logical: TBP>>=
  procedure :: init => val_logical_init
<<Codes: procedures>>=
  subroutine val_logical_init (val, nval)
    class(val_logical_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_logical_init
  
@ %def val_logical_init
@ Return array size.
<<Codes: val logical: TBP>>=
  procedure :: get_nval => val_logical_get_nval
<<Codes: procedures>>=
  function val_logical_get_nval (val) result (nval)
    class(val_logical_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_logical_get_nval
  
@ %def val_logical_get_nval
@ I/O.  List-directed is ok.
<<Codes: val logical: TBP>>=
  procedure :: read => val_logical_read
  procedure :: write => val_logical_write
<<Codes: procedures>>=
  subroutine val_logical_read (val, unit, i, iostat)
    class(val_logical_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  val%x(i)
    else
       read (unit, *)  val%x(i)
    end if
  end subroutine val_logical_read
       
  subroutine val_logical_write (val, unit, i)
    class(val_logical_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(L1)")  val%x(i)
  end subroutine val_logical_write
       
@ %def val_logical_read 
@ %def val_logical_write
@
\subsubsection{String}
<<Codes: public>>=
  public :: val_string_t
<<Codes: types>>=
  type, extends (val_t) :: val_string_t
     type(string_t), dimension(:), allocatable :: x
   contains
   <<Codes: val string: TBP>>
  end type val_string_t
     
@ %def val_string_t
@ Type code.
<<Codes: parameters>>=
  integer, parameter, public :: VT_STRING = 2
<<Codes: val cases>>=
  case (VT_STRING);  allocate (val_string_t :: val)
<<Codes: val string: TBP>>=
  procedure :: get_type => val_string_get_type
<<Codes: procedures>>=
  function val_string_get_type (val) result (type)
    class(val_string_t), intent(in) :: val
    integer :: type
    type = VT_STRING
  end function val_string_get_type
  
@ %def val_string_get_type
@ Init.  Allocate the array.
<<Codes: val string: TBP>>=
  procedure :: init => val_string_init
<<Codes: procedures>>=
  subroutine val_string_init (val, nval)
    class(val_string_t), intent(out) :: val
    integer, intent(in) :: nval
    allocate (val%x (nval))
  end subroutine val_string_init
  
@ %def val_string_init
@ Return array size.
<<Codes: val string: TBP>>=
  procedure :: get_nval => val_string_get_nval
<<Codes: procedures>>=
  function val_string_get_nval (val) result (nval)
    class(val_string_t), intent(in) :: val
    integer :: nval
    if (allocated (val%x)) then
       nval = size (val%x)
    else
       nval = 0
    end if
  end function val_string_get_nval
  
@ %def val_string_get_nval
@ I/O.  We rely on the size being allocated before, using an attribute index
for input.  We write one array entry per line.  The string length is limited
to [[NAME_LEN_MAX]]
<<Codes: val string: TBP>>=
  procedure :: read => val_string_read
  procedure :: write => val_string_write
<<Codes: procedures>>=
  subroutine val_string_read (val, unit, i, iostat)
    class(val_string_t), intent(inout) :: val
    integer, intent(in) :: unit, i
    integer, intent(out), optional :: iostat
    character(NAME_LEN_MAX) :: buffer
    if (present (iostat)) then
       read (unit, *, iostat=iostat)  buffer
    else
       read (unit, *)  buffer
    end if
    val%x(i) = trim (adjustl (buffer))
  end subroutine val_string_read
       
  subroutine val_string_write (val, unit, i)
    class(val_string_t), intent(in) :: val
    integer, intent(in) :: unit, i
    write (unit, "(A)")  char (val%x(i))
  end subroutine val_string_write
       
@ %def val_string_read 
@ %def val_string_write
@
\subsection{Value constructor}
Depending on the value code, we allocate a specific value object.
<<Codes: code: TBP>>=
  procedure, nopass :: create_val
<<Codes: procedures>>=
  subroutine create_val (val, vt, nval)
    class(val_t), allocatable, intent(out) :: val
    integer, intent(in) :: vt, nval
    select case (vt)
  <<Codes: val cases>>
    end select
    call val%init (nval)
  end subroutine create_val
  
@ %def create_val
@ 
\subsection{Unit tests}
<<Codes: public>>=
  public :: codes_test
<<Codes: procedures>>=
  subroutine codes_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Codes: execute tests>>  
  end subroutine codes_test
  
@ %def codes_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Codes: execute tests>>=
  call test (codes_1, "codes_1", &
       "object codes: I/O", &
       u, results)
<<Codes: tests>>=  
  subroutine codes_1 (u)
    integer, intent(in) :: u
    integer :: utmp, i
    type(code_t) :: code
    character(256) :: buffer

    write (u, "(A)")  "* Test output: codes_1"
    write (u, "(A)")  "*   Purpose: check code I/O"
    write (u, "(A)")      

    utmp = free_unit ()
    open (utmp, status="scratch", action="readwrite")

    write (utmp, "(1x,A)")  "4 0 0 0"
    write (utmp, "(1x,A)")  "5 2 1 3 5 6 7"
    write (utmp, "(1x,A)")  "foo"
    write (utmp, "(1x,A)")  "7 1 2 0"
    write (utmp, "(1x,A)")  "T"
    write (utmp, "(1x,A)")  "F"
    
    rewind (utmp)
    do
       read (utmp, "(A)", end=1)  buffer
       write (u, "(A)") trim (buffer)
    end do
1   continue
    
    rewind (utmp)
    write (u, *)

    do i = 1, 3
       call code%read (utmp)
       call code%write (u, verbose=.true.)
    end do

    rewind (utmp)
    write (u, *)

    do i = 1, 3
       call code%read (utmp)
       call code%write (u)
    end do

    close (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: codes_1"
    
    end subroutine codes_1

@ %def codes_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Builder}
This module introduces an abstract type, designed for converting between
bytecode and an undefined kind of object tree.

The abstract type merely declares a finalizer, output, and one method for
building (from bytecode) and decoding (to bytecode), respectively.  We
implement a shortcut that converts between two builders.

Initialization, object extraction etc.\ will depend on the specific
implementations.
<<[[builders.f90]]>>=
<<File header>>

module builders

  use codes

<<Standard module head>>

<<Builder: public>>

<<Builder: types>>

<<Builder: interfaces>>

contains
  
<<Builder: procedures>>

end module builders
@ %def builders
@
\subsection{Abstract Type}
<<Builder: public>>=
  public :: builder_t
<<Builder: types>>=
  type, abstract :: builder_t
     private
   contains
   <<Builder: builder: TBP>>
  end type builder_t
   
@ %def builder_t
@ 
Finalizer:
<<Builder: builder: TBP>>=
  procedure(builder_final), deferred :: final
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_final (builder)
       import
       class(builder_t), intent(inout) :: builder
     end subroutine builder_final
  end interface

@ %def builder_final
@
Output:
<<Builder: builder: TBP>>=
procedure(builder_write), deferred :: write
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_write (builder, unit)
       import
       class(builder_t), intent(in) :: builder
       integer, intent(in), optional :: unit
     end subroutine builder_write
  end interface

@ %def builder_write
@
\subsection{Decoding}
Decode the current object and advance to the next.  If there is no object
left, return [[.false.]]
<<Builder: builder: TBP>>=
  procedure(builder_decode), deferred :: decode
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_decode (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(out) :: code
       logical, intent(out) :: success
     end subroutine builder_decode
  end interface

@ %def builder_decode
@
\subsection{Building}
Take the current code and build a new object in the current location, then
advance.
<<Builder: builder: TBP>>=
  procedure(builder_build), deferred :: build
<<Builder: interfaces>>=
  abstract interface
     subroutine builder_build (builder, code, success)
       import
       class(builder_t), intent(inout) :: builder
       type(code_t), intent(in) :: code
       logical, intent(out) :: success
     end subroutine builder_build
  end interface
    
@ %def builder_build
@
\subsection{Conversion}
Using bytecode as common language, we can directly copy/convert between two
builders.
<<Builder: builder: TBP>>=
  procedure :: copy => builder_copy
<<Builder: procedures>>=
  subroutine builder_copy (builder, builder_source, success)
    class(builder_t), intent(inout) :: builder
    class(builder_t), intent(inout) :: builder_source
    logical, intent(out) :: success
    type(code_t) :: code
    call builder_source%decode (code, success)
    if (.not. success)  return
    call builder%build (code, success)
  end subroutine builder_copy
    
@ %def builder_copy
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Basic objects}
This module implements the components of the actual object tree as a Sindarin
implementation.  We define
\begin{itemize}
\item
  Basic objects, abstract and completely generic
\item
  Tags as a trivial implementation
\item
  Abstract value objects
\item
  ID objects that allow object identification by name
\item
  Generic wrapper objects (for heterogeneous object arrays)
\item
  References to remote objects
\item
  Composite objects as the base for all more complex structures
\item
  Object repository that enable prototype handling
\item
  Object iterators for traversing an object tree structure
\end{itemize}
<<[[object_base.f90]]>>=
<<File header>>

module object_base

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use codes

<<Standard module head>>

<<Object base: public>>

<<Object base: parameters>>

<<Object base: types>>

<<Object base: interfaces>>

contains

<<Object base: procedures>>

<<Object base: tests>>

end module object_base
@ %def object_base
@
\subsection{Basic objects (abstract)}
Each object may be referred by other objects, either as a prototype or as a
value.  To keep track, we count the number of instances.  Since the object
itself also counts as an instance, we start with 1, which may be incremented
later.  Conversely, an object is finally deallocated if its instance
count becomes zero.

Any object that is part of a composite will have a context.  

A basic object has a [[defined]] status.  If defined, the value is
known and can be queried.  If undefined, the object signature is
determined but the value is unknown.  If there
is no value, we understand that the object is always defined.

For generic objects, that will be extensions of the abstract type, we
distinguish:
\begin{description}
\item[core]:  The value held by a composite object, target of a reference
\item[mantle]:  Any additional members, and any primer statements that
  initialize the object
\tiem[shell]:  Name and properties of the object.
\end{description}
<<Object base: public>>=
  public :: object_t
<<Object base: types>>=
  type, abstract :: object_t
     private
     class(wrapper_t), pointer :: context => null ()
     integer :: refcount = 1
   contains
   <<Object base: object: TBP>>
  end type object_t
  
@ %def object_t
@
\subsubsection{Finalizer and destructor}
The finalizer should not be called explicitly.  Instead, when an
object is ready for deletion, we should call this method, which calls
the specific finalizer, takes care of any prototype, and checks for
any extra instances before deallocating.

This procedure can't be type-bound.
<<Object base: public>>=
  public :: remove_object
<<Object base: procedures>>=
  recursive subroutine remove_object (object)
    class(object_t), intent(inout), pointer :: object
    if (associated (object)) then
       object%refcount = object%refcount - 1
       if (object%refcount == 0) then
          call object%final ()
          deallocate (object)
       else
          object => null ()
       end if
    end if
  end subroutine remove_object
  
@ %def remove_object
@ There must be a specific finalizer.  The finalizer might be empty,
but this method must be implemented.
<<Object base: object: TBP>>=
  procedure (object_final), deferred :: final
<<Object base: interfaces>>=
  abstract interface
     subroutine object_final (object)
       import
       class(object_t), intent(inout) :: object
     end subroutine object_final
  end interface
       
@ %def object_final
@ 
\subsubsection{Output}
Any object must have a [[write]] method, so we can print a
representation on screen.  The output format depends on the context.

The default [[write]] prints a verbose representation of the object, an
extended version of the declaration form.  All properties and members are
displayed.  Arrays of reference objects (wrappers) are shown explicitly.
If the object has a value, the value is also displayed.  The
[[refcount]] option displays the reference count, following the property
string.

[[write_as_declaration]] prints a concise version of the signature, and
suppresses wrapper objects.  The value is displayed.  Primer statements are
displayed in statement form, following the member declarations.

[[write_as_statement]] prints the object in statement form, if it is a
statement.  Other objects are written in declaration form.

[[write_as_expression]] prints the object as if it occurs inside an
expression.  For a data object, this would print the value, while for an
expression object, the expression (recursively).  Member objects are shown
after the expression, but arguments are not shown as members.  Primer
statements are suppressed.  This format also needs information about the
context, expressed by the [[priority]] and [[lr]] arguments.

[[write_as_value]] just prints the current value, regardless whether this is a
data object or an expression.
<<Object base: object: TBP>>=
  procedure :: write => object_write
  procedure :: write_as_declaration => object_write_as_declaration
  procedure :: write_as_statement => object_write_as_statement
  procedure :: write_as_expression => object_write_as_expression
  procedure :: write_as_value => object_write_as_value
<<Object base: procedures>>=
  recursive subroutine object_write &
       (object, unit, indent, refcount, core, mantle)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    logical, intent(in), optional :: core
    logical, intent(in), optional :: mantle
    logical :: ref, cor, man
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    ref = .false.;  if (present (refcount))  ref = refcount
    cor = .true.;  if (present (core))  cor = core
    man = .true.;  if (present (mantle))  man = mantle
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    write (u, "(1x,'||',A,'||')", advance="no") &
         char (object%get_signature (verbose=.true.))
    if (ref) then
       write (u, "(1x,'(',I0,')')", advance="no")  object%get_refcount ()
    end if
    if (man .and. object%has_mantle ()) then
       write (u, "(1x,'{')")
       call object%write_mantle (u, ind+1, ref)
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (cor .and. object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write
  
  recursive subroutine object_write_as_declaration (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    type(string_t) :: signature
    class(object_t), pointer :: member, primer
    integer :: u, ind, n_mem, n_pri, i
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    write (u, "(A)", advance="no")  char (object%get_prototype ())
    write (u, "(1x,A)", advance="no")  char (object%get_name ())
    signature = object%get_signature (verbose = .false.)
    if (signature /= "") then
       write (u, "(1x,'||',A,'||')", advance="no")  char (signature)
    end if
    n_mem = object%get_n_members ()
    n_pri = object%get_n_primers ()
    if (n_mem + n_pri > 0) then
       write (u, "(1x,'{')")
       do i = 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind)
          call member%write_as_declaration (u, ind+1)
       end do
       do i = 1, n_pri
          call object%get_primer_ptr (i, primer)
          call write_indent (u, ind)
          call primer%write_as_statement (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
    if (object%has_value ()) then
       write (u, "(1x,'=',1x)", advance="no")
       call object%write_core (u, ind+1)
    end if
    write (u, *)
  end subroutine object_write_as_declaration

  recursive subroutine object_write_as_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%is_statement ()) then
       call object%write_statement (unit, indent)
    else
       call object%write_as_declaration (unit, indent)
    end if
  end subroutine object_write_as_statement
  
  recursive subroutine object_write_as_expression (object, unit, indent, &
       priority, lr)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer, intent(in), optional :: priority
    logical, intent(in), optional :: lr
    class(object_t), pointer :: member
    logical :: paren
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    paren = .false.
    if (object%is_expression ()) then
       if (present (priority)) then
          if (lr) then
             paren = priority > object%get_priority ()
          else
             paren = priority >= object%get_priority ()
          end if
       end if
       if (paren)  write (u, "('(')", advance="no")
       call object%write_expression (u, indent)
       if (paren)  write (u, "(')')", advance="no")
    else if (object%is_value ()) then
       if (object%is_defined ()) then
          call object%write_expression (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else if (object%has_value ()) then
       call object%write_core (u, ind)
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_expression
  
  recursive subroutine object_write_as_value (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: member
    integer :: u, i, ind, n_mem, n_arg
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (object%is_expression () &
         .or. object%is_value () .or. object%has_value ()) then
       if (object%is_defined ()) then
          call object%write_value (u, indent)
       else
          write (u, "('???')", advance="no")
       end if
    else
       write (u, "(A)", advance="no")  char (object%get_name ())
    end if
    n_mem = object%get_n_members ()
    n_arg = object%get_n_arguments ()
    if (n_mem - n_arg > 0) then
       write (u, "(1x,'{')")
       do i = n_arg + 1, n_mem
          call object%get_member_ptr (i, member)
          call write_indent (u, ind+1)
          call member%write_as_declaration (u, ind+1)
       end do
       call write_indent (u, ind)
       write (u, "('}')", advance="no")
    end if
  end subroutine object_write_as_value
  
@ %def object_write
@ %def object_write_as_declaration
@ %def object_write_as_statement
@ %def object_write_as_expression
@ For these specific output functions we provide a default
implementation.   A bare object has the default prototype [[object]] and no
contents, value, or expression.
<<Object base: object: TBP>>=
  procedure :: write_core => object_write_stub
  procedure :: write_mantle => object_write_mantle
  procedure :: write_statement => object_write_statement
  procedure :: write_expression => object_write_stub
  procedure :: write_value => object_write_stub
<<Object base: procedures>>=
  subroutine object_write_stub (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "('<>')", advance="no")
  end subroutine object_write_stub
       
  subroutine object_write_mantle (object, unit, indent, refcount)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
  end subroutine object_write_mantle
  
  subroutine object_write_statement (object, unit, indent)
    class(object_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
  end subroutine object_write_statement
       
@ %def object_write_core
@ %def object_write_mantle
@ %def object_write_statement
@ %def object_write_expression
@ %def object_write_value
@
\subsubsection{Reference count and context}
Return the reference count explicitly.  This may be used for debugging
output.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: get_refcount => object_get_refcount
<<Object base: procedures>>=
  function object_get_refcount (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = object%refcount
  end function object_get_refcount
  
@ %def object_get_refcount
@
Set the context pointer.
<<Object base: object: TBP>>=
  procedure, non_overridable, private :: set_context => object_set_context
<<Object base: procedures>>=
  subroutine object_set_context (object, context)
    class(object_t), intent(inout) :: object
    class(wrapper_t), intent(in), target :: context
    object%context => context
  end subroutine object_set_context
  
@ %def object_set_context
@
\subsubsection{Queries}
Access the object's name.  The name may be just the type (for atomic
objects) or a variable name (for composites).
<<Object base: object: TBP>>=
  procedure (object_get_name), deferred :: get_name
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_name (object) result (name)
       import
       class(object_t), intent(in) :: object
       type(string_t) :: name
     end function object_get_name
  end interface
  
@ %def object_get_name
@ Return the object's prototype as a string.  The default prototype is `object'.
<<Object base: object: TBP>>=
  procedure :: get_prototype => object_get_prototype
<<Object base: procedures>>=
  function object_get_prototype (object) result (prototype)
    class(object_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "object"
  end function object_get_prototype
  
@ %def object_get_prototype
@ Return the object's signature as a string.  If [[verbose]] is set (default),
we need a complete account of all properties, otherwise a short version.
<<Object base: object: TBP>>=
  procedure (object_get_signature), deferred :: get_signature
<<Object base: interfaces>>=
  abstract interface
     pure function object_get_signature (object, verbose) result (signature)
       import
       class(object_t), intent(in) :: object
       logical, intent(in), optional :: verbose
       type(string_t) :: signature
     end function object_get_signature
  end interface
  
@ %def object_get_signature
@ Return the object priority.  This is relevant only for expressions and
operators.
<<Object base: object: TBP>>=
  procedure :: get_priority => object_get_priority
<<Object base: procedures>>=
  pure function object_get_priority (object) result (priority)
    class(object_t), intent(in) :: object
    integer :: priority
    priority = 0
  end function object_get_priority
  
@ %def object_get_priority
@ Check if this is a reference object.
<<Object base: object: TBP>>=
  procedure :: is_reference => object_is_reference
<<Object base: procedures>>=
  pure function object_is_reference (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_reference
  
@ %def object_is_reference
@ Identify statements and expressions (functions).
<<Object base: object: TBP>>=
  procedure :: is_statement => object_is_statement
  procedure :: is_expression => object_is_expression
<<Object base: procedures>>=
  pure function object_is_statement (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_statement
  
  pure function object_is_expression (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_expression
  
@ %def object_is_statement
@ %def object_is_expression
@ This query tells whether the object contains an ID subobject.
<<Object base: object: TBP>>=
  procedure :: has_id => object_has_id
<<Object base: procedures>>=
  pure function object_has_id (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_id
  
@ %def object_has_id
@ Return the pointer to the ID subobject, if any.
<<Object base: object: TBP>>=
  procedure :: get_id_ptr => object_get_id_ptr
<<Object base: procedures>>=
  subroutine object_get_id_ptr (object, id)
    class(object_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => null ()
  end subroutine object_get_id_ptr
  
@ %def object_get_id_ptr
@ This query tells whether the object is a wrapper which holds a core object.
The [[has_value]] variant is true if the core represents a value.  The
[[is_value]] is true if the object itself is a value.
<<Object base: object: TBP>>=
  procedure :: has_value => object_has_value
  procedure :: is_value => object_is_value
<<Object base: procedures>>=
  pure function object_has_value (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_value
  
  pure function object_is_value (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_value
  
@ %def object_has_value
@ %def object_is_value
@ Analogously, for the `mantle' (members, arguments, primer).
<<Object base: object: TBP>>=
  procedure :: has_mantle => object_has_mantle
<<Object base: procedures>>=
  pure function object_has_mantle (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_has_mantle
  
@ %def object_has_mantle
@ Return number of mantle components.  A default object has none.
<<Object base: object: TBP>>=
  procedure :: get_n_members => object_get_n_members
  procedure :: get_n_arguments => object_get_n_arguments
  procedure :: get_n_primers => object_get_n_primers
<<Object base: procedures>>=
  pure function object_get_n_members (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_members
  
  pure function object_get_n_arguments (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_arguments
  
  pure function object_get_n_primers (object) result (n)
    class(object_t), intent(in) :: object
    integer :: n
    n = 0
  end function object_get_n_primers
  
@ %def object_get_n_members
@ %def object_get_n_arguments
@ %def object_get_n_primers
@ Return pointers to mantle component.  Default: null.
<<Object base: object: TBP>>=
  procedure :: get_member_ptr => object_get_member_ptr
  procedure :: get_primer_ptr => object_get_primer_ptr
<<Object base: procedures>>=
  subroutine object_get_member_ptr (object, i, member)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    member => null ()
  end subroutine object_get_member_ptr
  
  subroutine object_get_primer_ptr (object, i, primer)
    class(object_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    primer => null ()
  end subroutine object_get_primer_ptr
  
@ %def object_get_member_ptr
@ %def object_get_primer_ptr
@ Return the evaluation status.  This is always true for a data object, but
varies for a statement or expression object.
<<Object base: object: TBP>>=
  procedure :: is_evaluated => object_is_evaluated
<<Object base: procedures>>=
  pure function object_is_evaluated (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function object_is_evaluated
  
@ %def object_is_evaluated
@ Return the definition status.  An object is defined if it has a value and
the value is defined.  Generic objects are undefined.
<<Object base: object: TBP>>=
  procedure :: is_defined => object_is_defined
<<Object base: procedures>>=
  pure function object_is_defined (object) result (flag)
    class(object_t), intent(in) :: object
    logical :: flag
    flag = .false.
  end function object_is_defined
  
@ %def object_is_defined
@
\subsubsection{Constructors}
Since we are basing the object structure on prototyping, each object
must provide an [[instantiate]] method.  As a rule, the instance
inherits the properties of the prototype with the exception of the
value (core value and member values).  In particular, the copy should
be of the same actual type as the prototype.

We require a pointer implementation for allocating objects, at this
point.  This allows us to freely use pointers without caring too much
about [[target]] attributes.
<<Object base: object: TBP>>=
  procedure (object_instantiate), deferred :: instantiate
<<Object base: interfaces>>=
  abstract interface
     subroutine object_instantiate (object, instance)
       import
       class(object_t), intent(inout), target :: object
       class(object_t), intent(out), pointer :: instance
     end subroutine object_instantiate
  end interface
       
@ %def object_instantiate
@
This is applicable to statements and expressions: resolve any references by
name or position into actual pointers, so evaluation can proceed.  For a bare
object, nothing needs to be resolved.
<<Object base: object: TBP>>=
  procedure :: resolve => object_resolve
<<Object base: procedures>>=
  subroutine object_resolve (object, success)
    class(object_t), intent(inout), target :: object
    logical, intent(out) :: success
    success = .true.
  end subroutine object_resolve
  
@ %def object_resolve
@
With all paths resolved, we can evaluate.  No-op for all objects that aren't
statements or expressions, or contain such objects as members.
<<Object base: object: TBP>>=
  procedure :: evaluate => object_evaluate
<<Object base: procedures>>=
  subroutine object_evaluate (object)
    class(object_t), intent(inout), target :: object
  end subroutine object_evaluate
  
@ %def object_evaluate
@
\subsubsection{Code}
Each object has a representation in terms of elementary values, which can be
used for object construction and data transfer.

The code includes the object's value (if any), which might be a large object.
To allow for passing a pointer, we require a [[target]] attribute.

Determining the code may require a repository lookup, so we need the extra
argument.
<<Object base: object: TBP>>=
  procedure (object_get_code), deferred :: get_code
<<Object base: interfaces>>=
  abstract interface
     function object_get_code (object, repository) result (code)
       import
       class(object_t), intent(in), target :: object
       type(repository_t), intent(in), optional :: repository
       type(code_t) :: code
     end function object_get_code
  end interface
  
@ %def object_get_code
@
Build the object from its code.  This is the inverse method to
[[object_get_code]] above, and to [[remove_object]].

Composite objects are built using a prototype in the repository.  Since the
prototype includes the core, we do not need to build value objects.
<<Object base: public>>=
  public :: build_object
<<Object base: procedures>>=
  subroutine build_object (object, code, repository)
    class(object_t), intent(out), pointer :: object
    type(code_t), intent(in) :: code
    type(repository_t), intent(in) :: repository
    integer :: prototype_index, mode
    select case (code%cat)
    case (CAT_COMPOSITE)
       prototype_index = code%att(1)
       if (prototype_index > 0) then
          call repository%spawn (prototype_index, object)
       else
          allocate (composite_t :: object)
       end if
       select type (object)
       class is (composite_t)
          call object%init_from_code (code)
       end select
    case (CAT_ID)
       allocate (id_t :: object)
       select type (object)
       type is (id_t)
          call object%init_from_code (code)
       end select
    case default
       object => null ()
    end select
  end subroutine build_object
  
@ %def build_object
@
\subsubsection{Iterator Support}
Iterate.  This procedure returns the next object in a given order, for
iteration over the object tree.  If there is a [[insert_object]] argument,
this object is inserted before returning it as the next object.

This implementation: the bare object has nothing that follows it, and the
inserted object is ignored.
<<Object base: object: TBP>>=
  procedure :: next_position => object_next_position
<<Object base: procedures>>=
  subroutine object_next_position (object, position, next_object, import_object)
    class(object_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    position%part = POS_NONE
    if (present (next_object))  next_object => null ()
  end subroutine object_next_position
  
@ %def object_next_position
@
\subsubsection{Tools}
Create a reference object.  The core is the previous object (via pointer).
We therefore can implement the method directly.
<<Object base: object: TBP>>=
  procedure :: make_reference => object_make_reference
<<Object base: procedures>>=
  subroutine object_make_reference (object, reference)
    class(object_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: reference
    allocate (reference_t :: reference)
    select type (reference)
    type is (reference_t)
       call reference%link_core (object)
    end select
  end subroutine object_make_reference
  
@ %def object_make_reference
@
Dereference: if this is not a reference, return the pointer to the object
itself.
<<Object base: object: TBP>>=
  procedure :: dereference => object_dereference
<<Object base: procedures>>=
  recursive function object_dereference (object) result (remote)
    class(object_t), intent(in), target :: object
    class(object_t), pointer :: remote
    remote => object
  end function object_dereference

@ %def object_dereference
@ Find an object within the object's contents: no result for a default
object.
<<Object base: object: TBP>>=
  procedure :: find => object_find
<<Object base: procedures>>=
  recursive subroutine object_find (object, path, member)
    class(object_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    member => null ()
  end subroutine object_find
    
@ %def object_find
@
\subsection{Tag Object Type}
A tag is an atomic object with no content, it just exists.  (As a
variable, it has a name but no value.)  The definition status is
always defined.

Tag objects are checked in matching types against a pattern.  The match fails
if a required tag is not found.

We introduce this here, so we have concrete objects that we can use in
unit tests.  Object types with value are defined elsewhere.
<<Object base: public>>=
  public :: tag_t
<<Object base: types>>=
  type, extends (object_t) :: tag_t
     private
   contains
   <<Object base: tag: TBP>>
  end type tag_t
  
@ %def tag_t
@ 
\subsubsection{Finalizer}
We do not need an initializer, there are no contents or value.

The finalizer is also empty.
<<Object base: tag: TBP>>=
  procedure :: final => tag_final
<<Object base: procedures>>=
  subroutine tag_final (object)
    class(tag_t), intent(inout) :: object
  end subroutine tag_final
 
@ %def tag_final
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[tag]].
<<Object base: tag: TBP>>=
  procedure :: get_name => tag_get_name
<<Object base: procedures>>=
  pure function tag_get_name (object) result (name)
    class(tag_t), intent(in) :: object
    type(string_t) :: name
    name = "tag"
  end function tag_get_name
  
@ %def tag_get_name
@ The full signature of a tag object is [[atom]].
<<Object base: tag: TBP>>=
  procedure :: get_signature => tag_get_signature
<<Object base: procedures>>=
  pure function tag_get_signature (object, verbose) result (signature)
    class(tag_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "atom"
    else
       signature = ""
    end if
  end function tag_get_signature
  
@ %def tag_get_signature
@
\subsubsection{Constructor}
For a new tag instance, nothing needs to be copied.
<<Object base: tag: TBP>>=
  procedure :: instantiate => tag_instantiate
<<Object base: procedures>>=
  subroutine tag_instantiate (object, instance)
    class(tag_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (tag_t :: instance)
  end subroutine tag_instantiate
    
@ %def tag_instantiate
@ Object code.  Only the category is nontrivial.
<<Object base: tag: TBP>>=
  procedure :: get_code => tag_get_code
<<Object base: procedures>>=
  function tag_get_code (object, repository) result (code)
    class(tag_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_TAG
  end function tag_get_code
  
@ %def tag_get_code
@
\subsection{Value object type (abstract)}
The [[value_t]] is the base type of all objects that holds a value.  The
abstract base type includes the [[defined]] property for the value.
<<Object base: public>>=
  public :: value_t
<<Object base: types>>=
  type, extends (object_t), abstract :: value_t
     private
     logical :: defined = .false.
   contains
   <<Object base: value: TBP>>
  end type value_t
  
@ %def value_t
@
\subsubsection{Queries}
The signature of value objects is [[value]].
<<Object base: value: TBP>>=
  procedure :: get_signature => value_get_signature
<<Object base: procedures>>=
  pure function value_get_signature (object, verbose) result (signature)
    class(value_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb) then
       signature = "value"
    else
       signature = ""
    end if
  end function value_get_signature
  
@ %def value_get_signature
@ A value is a value.
<<Object base: value: TBP>>=
  procedure :: is_value => value_is_value
<<Object base: procedures>>=
  pure function value_is_value (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function value_is_value
  
@ %def value_is_value
@
This overrides a base-type method.  The value may be defined or undefined.
<<Object base: value: TBP>>=
  procedure :: is_defined => value_is_defined
<<Object base: procedures>>=
  pure function value_is_defined (object) result (flag)
    class(value_t), intent(in) :: object
    logical :: flag
    flag = object%defined
  end function value_is_defined
  
@ %def value_is_defined
@
\subsubsection{Setting Content}
Initialize the value from a code object.
<<Object base: value: TBP>>=
  procedure(value_init_from_code), deferred :: init_from_code
<<Object base: interfaces>>=
  abstract interface
     subroutine value_init_from_code (object, code)
       import
       class(value_t), intent(out) :: object
       type(code_t), intent(in) :: code
     end subroutine value_init_from_code
  end interface

@ %def value_init_from_code
@ Set the definition status.
<<Object base: value: TBP>>=
  procedure :: set_defined => value_set_defined
<<Object base: procedures>>=
  pure subroutine value_set_defined (object, defined)
    class(value_t), intent(inout) :: object
    logical, intent(in) :: defined
    object%defined = defined
  end subroutine value_set_defined
  
@ %def value_set_defined
@
\subsubsection{Tools}
Assign value: there should be an allowed possibility for any value object.
The actual variants depend on the concrete type combination.  Before we call
the actual assignment, we should call the [[match]] method which checks
whether the assignment is allowed.
<<Object base: value: TBP>>=
  procedure :: match => value_match
  procedure :: assign => value_assign
<<Object base: procedures>>=
  subroutine value_match (object, source, success)
    class(value_t), intent(in) :: object
    class(object_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (value_t)
       call object%match_value (source, success)
    class default
       success = .false.
    end select
  end subroutine value_match
       
  subroutine value_assign (object, source)
    class(value_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    call object%final ()
    object%defined = source%defined
    if (source%defined)  call object%assign_value (source)
  end subroutine value_assign
       
@ %def value_match
@ %def value_assign
@ This must be implemented specifically.
<<Object base: value: TBP>>=
  procedure (value_match_value), deferred :: match_value
  procedure (value_assign_value), deferred :: assign_value
<<Object base: interfaces>>=
  abstract interface
     subroutine value_match_value (object, source, success)
       import
       class(value_t), intent(in) :: object
       class(value_t), intent(in) :: source
       logical, intent(out) :: success
     end subroutine value_match_value
  end interface
  
  abstract interface
     subroutine value_assign_value (object, source)
       import
       class(value_t), intent(inout) :: object
       class(value_t), intent(in) :: source
     end subroutine value_assign_value
  end interface
  
@ %def value_match_value
@ %def value_assign_value
@
\subsection{ID Object}
We define the [[id_t]] type that holds the ID of an object (the name / path to
an object) and can be used for searching and navigating.  The ID object is the
first implementation of the abstract value type.
<<Object base: public>>=
  public :: id_t
<<Object base: types>>=
  type, extends (value_t) :: id_t
     private
     type(string_t), dimension(:), allocatable :: path
   contains
   <<Object base: id: TBP>>
  end type id_t
  
@ %def id_t
@
\subsubsection{Finalizer}
Delete the path.
<<Object base: id: TBP>>=
  procedure :: final => id_final
<<Object base: procedures>>=
  subroutine id_final (object)
    class(id_t), intent(inout) :: object
    if (allocated (object%path))  deallocate (object%path)
    call object%set_defined (.false.)
  end subroutine id_final
  
@ %def id_final
@
\subsubsection{Output}
Expression form: write a representation of the ID string array as the ID
object value.
<<Object base: id: TBP>>=
  procedure :: write_expression => id_write_expression
<<Object base: procedures>>=
  subroutine id_write_expression (object, unit, indent)
    class(id_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u, i
    u = given_output_unit (unit)
    if (allocated (object%path)) then
       do i = 1, size (object%path)
          if (i > 1)  write (u, "('.')", advance="no")
          write (u, "(A)", advance="no")  char (object%path(i))
       end do
    else
       write (u, "(A)", advance="no")  "<id>"
    end if
  end subroutine id_write_expression
       
@ %def id_write_expression
@
\subsubsection{Queries}
The name is [[id]]
<<Object base: id: TBP>>=
  procedure :: get_name => id_get_name
<<Object base: procedures>>=
  pure function id_get_name (object) result (name)
    class(id_t), intent(in) :: object
    type(string_t) :: name
    name = "id"
  end function id_get_name

@ %def id_get_name  
@ Return the path.
<<Object base: id: TBP>>=
  procedure :: get_path => id_get_path
<<Object base: procedures>>=
  function id_get_path (object) result (path)
    class(id_t), intent(in) :: object
    type(string_t), dimension(:), allocatable :: path
    if (allocated (object%path)) then
       allocate (path (size (object%path)))
       path = object%path
    end if
  end function id_get_path
  
@ %def id_get_path
@
\subsubsection{Construction and initialization}
Instantiate: likely unused.
<<Object base: id: TBP>>=
  procedure :: instantiate => id_instantiate
<<Object base: procedures>>=
  subroutine id_instantiate (object, instance)
    class(id_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (id_t :: instance)
  end subroutine id_instantiate

@ %def id_instantiate
@ The ID object carries a string-array value.
<<Object base: id: TBP>>=
  procedure :: get_code => id_get_code
<<Object base: procedures>>=
  function id_get_code (object, repository) result (code)
    class(id_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    integer :: nval, i
    code%cat = CAT_ID
    if (allocated (object%path)) then
       nval = size (object%path)
       call code%create_val (code%val, VT_STRING, nval)
       select type (val => code%val)
       type is (val_string_t)
          do i = 1, nval
             val%x(i) = object%path(i)
          end do
       end select
    end if
  end function id_get_code
  
@ %def id_get_code
@ Initialize from a code object, which includes the path.
<<Object base: id: TBP>>=
  procedure :: init_from_code => id_init_from_code
<<Object base: procedures>>=
  subroutine id_init_from_code (object, code)
    class(id_t), intent(out) :: object
    type(code_t), intent(in) :: code
    select type (val => code%val)
    type is (val_string_t)
       call object%init (val%x)
    end select
  end subroutine id_init_from_code
    
@ %def id_init_from_code
@ Initialize with a path, specified as a string array.
<<Object base: id: TBP>>=
  procedure :: init => id_init_path
<<Object base: procedures>>=
  subroutine id_init_path (object, path)
    class(id_t), intent(out) :: object
    type(string_t), dimension(:), intent(in) :: path
    allocate (object%path (size (path)))
    object%path = path
    call object%set_defined (.true.)
  end subroutine id_init_path
    
@ %def id_init_path
@
\subsubsection{Tools}
Must be implemented due to the [[value_t]] base type: match/copy the path
value.
<<Object base: id: TBP>>=
  procedure :: match_value => id_match_value
  procedure :: assign_value => id_assign_value
<<Object base: procedures>>=
  subroutine id_match_value (object, source, success)
    class(id_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (id_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine id_match_value
       
  subroutine id_assign_value (object, source)
    class(id_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (id_t)
       call object%init (source%path)
    end select
  end subroutine id_assign_value
       
@ %def id_match_value
@ %def id_assign_value
@
\subsection{Wrapper}
A wrapper is an object that can hold another object, its [[core]].  This base
type allows us to define composite objects and references.  As a stand-alone
type, it enables arrays of heterogeneous concrete type.

All method calls are delegated to the core.
<<Object base: public>>=
  public :: wrapper_t
<<Object base: types>>=
  type, extends (object_t) :: wrapper_t
     private
     class(object_t), pointer :: core => null ()
   contains
   <<Object base: wrapper: TBP>>
  end type wrapper_t
  
@ %def wrapper_t
@ 
\subsubsection{Finalizer}
The finalizer should remove and deallocate the core object.
<<Object base: wrapper: TBP>>=
  procedure :: final => wrapper_final
<<Object base: procedures>>=
  recursive subroutine wrapper_final (object)
    class(wrapper_t), intent(inout) :: object
    if (associated (object%core)) then
       call object%core%final ()
       call remove_object (object%core)
    end if
  end subroutine wrapper_final
  
@ %def wrapper_final
@
\subsubsection{Output}
 Write the wrapper core.  Assuming this represents a value, we write in
expression form.
<<Object base: wrapper: TBP>>=
  procedure :: write_core => wrapper_write_core
<<Object base: procedures>>=
  recursive subroutine wrapper_write_core (object, unit, indent)
    class(wrapper_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%core%write_as_expression (unit, indent)
  end subroutine wrapper_write_core
       
@ %def wrapper_write_core  
@
\subsubsection{Queries}
Delegate name and signature as appropriate.
<<Object base: wrapper: TBP>>=
  procedure :: get_name => wrapper_get_name
<<Object base: procedures>>=
  pure recursive function wrapper_get_name (object) result (name)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: name
    if (associated (object%core)) then
       name = object%core%get_name ()
    else
       name = "<???>"
    end if
  end function wrapper_get_name
  
@ %def wrapper_get_name
@ Delegate the prototype.
<<Object base: wrapper: TBP>>=
  procedure :: get_prototype => wrapper_get_prototype
<<Object base: procedures>>=
  recursive function wrapper_get_prototype (object) result (prototype)
    class(wrapper_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%core)) then
       prototype = object%core%get_prototype ()
    else
       prototype = object_get_prototype (object)
    end if
  end function wrapper_get_prototype
  
@ %def wrapper_get_prototype
@ The signature is a plain [[wrapper]] string.
<<Object base: wrapper: TBP>>=
  procedure :: get_signature => wrapper_get_signature
<<Object base: procedures>>=
  pure function wrapper_get_signature (object, verbose) result (signature)
    class(wrapper_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = "wrapper"
  end function wrapper_get_signature
  
@ %def wrapper_get_signature
@ The [[is_reference]], [[has_value]], [[is_defined]] and [[is_statement]]
queries are delegated.
<<Object base: wrapper: TBP>>=
  procedure :: is_reference => wrapper_is_reference
  procedure :: is_statement => wrapper_is_statement
  procedure :: is_expression => wrapper_is_expression
  procedure :: is_evaluated => wrapper_is_evaluated
  procedure :: is_defined => wrapper_is_defined
<<Object base: procedures>>=
  pure recursive function wrapper_is_reference (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_reference ()
    else
       flag = .false.
    end if
  end function wrapper_is_reference
  
  pure recursive function wrapper_is_statement (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_statement ()
    else
       flag = .false.
    end if
  end function wrapper_is_statement
  
  pure recursive function wrapper_is_expression (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_expression ()
    else
       flag = .false.
    end if
  end function wrapper_is_expression
  
  pure recursive function wrapper_is_evaluated (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_evaluated ()
    else
       flag = .false.
    end if
  end function wrapper_is_evaluated
  
  pure recursive function wrapper_is_defined (object) result (flag)
    class(wrapper_t), intent(in) :: object
    logical :: flag
    if (associated (object%core)) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function wrapper_is_defined
  
@ %def wrapper_is_reference
@ %def wrapper_has_value
@ %def wrapper_is_statement
@ %def wrapper_is_expression
@ %def wrapper_is_defined
@ %def wrapper_is_evaluated
@ Return pointer to the core.
<<Object base: wrapper: TBP>>=
  procedure :: get_core_ptr => wrapper_get_core_ptr
<<Object base: procedures>>=
  subroutine wrapper_get_core_ptr (object, core)
    class(wrapper_t), intent(in) :: object
    class(object_t), intent(out), pointer :: core
    if (associated (object%core)) then
       core => object%core%dereference ()
    else
       core => null ()
    end if
  end subroutine wrapper_get_core_ptr
  
@ %def wrapper_get_core_ptr
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.  It should not be called for
a pure wrapper, however.
<<Object base: wrapper: TBP>>=
  procedure :: instantiate => wrapper_instantiate
<<Object base: procedures>>=
  recursive subroutine wrapper_instantiate (object, instance)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (wrapper_t :: instance)
  end subroutine wrapper_instantiate
    
@ %def wrapper_instantiate
@ Import an object as the new core.
<<Object base: wrapper: TBP>>=
  procedure, non_overridable :: import_core => wrapper_import_core
<<Object base: procedures>>=
  subroutine wrapper_import_core (object, core)
    class(wrapper_t), intent(inout), target :: object
    class(object_t), intent(inout), pointer :: core
    if (associated (object%core))  call remove_object (object%core)
    call core%set_context (object)
    object%core => core
    core => null ()
  end subroutine wrapper_import_core
    
@ %def wrapper_import_core
@ A wrapper should not appear explicitly in code, so return zero here.
<<Object base: wrapper: TBP>>=
  procedure :: get_code => wrapper_get_code
<<Object base: procedures>>=
  function wrapper_get_code (object, repository) result (code)
    class(wrapper_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = 0
  end function wrapper_get_code
  
@ %def wrapper_get_code
@
\subsubsection{Iterator Support}
Iterate: next is core, then context.  The import object, if present, is
inserted as the core before proceeding.
<<Object base: wrapper: TBP>>=
  procedure :: next_position => wrapper_next_position
<<Object base: procedures>>=
  subroutine wrapper_next_position &
       (object, position, next_object, import_object)
    class(wrapper_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_CORE)
       call object_next_position (object, position, next_object)
    case default
       if (present (import_object)) then
          call object%import_core (import_object)
       end if
       if (associated (object%core)) then
          position%part = POS_CORE
          if (present (next_object))  next_object => object%core
       else
          call object_next_position (object, position, next_object)
       end if
    end select
  end subroutine wrapper_next_position
  
@ %def wrapper_next_position
@
\subsubsection{Tools}
Find: refer to the context object.
<<Object base: wrapper: TBP>>=
  procedure :: find => wrapper_find
<<Object base: procedures>>=
  recursive subroutine wrapper_find (object, path, member)
    class(wrapper_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: context
    member => null ()
    if (size (path) > 0) then
       if (associated (object%context)) then
          context => object%context
          call context%find (path, member)
       end if
    end if
  end subroutine wrapper_find
    
@ %def wrapper_find
@
\subsection{Object references}
This extension of a wrapper behaves as a pointer to the core object.  We have
to assume that the target object of that core has been allocated remotely, and
should not be deallocated from here.
<<Object base: public>>=
  public :: reference_t
<<Object base: types>>=
  type, extends (wrapper_t) :: reference_t
     private
   contains
   <<Object base: reference: TBP>>
  end type reference_t
  
@ %def reference_t
@
\subsubsection{Finalizer}
The finalizer should not finalize the core.  However, it should call
[[remove_object]] as this takes care of reference counts.
<<Object base: reference: TBP>>=
  procedure :: final => reference_final
<<Object base: procedures>>=
  recursive subroutine reference_final (object)
    class(reference_t), intent(inout) :: object
    if (associated (object%core)) then
       call remove_object (object%core)
    end if
  end subroutine reference_final
  
@ %def reference_final
@
\subsubsection{Output}
The output procedures are delegated to the core as appropriate.
<<Object base: reference: TBP>>=
  procedure :: write_statement => reference_write_statement
  procedure :: write_expression => reference_write_expression
<<Object base: procedures>>=
  recursive subroutine reference_write_statement (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (associated (object%core)) then
       call object%core%write_statement (unit, indent)
    end if
  end subroutine reference_write_statement
       
  recursive subroutine reference_write_expression (object, unit, indent)
    class(reference_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (associated (object%core)) then
       call object%core%write_expression (unit, indent)
    end if
  end subroutine reference_write_expression
       
@ %def reference_write_statement
@ %def reference_write_expression
@
\subsubsection{Queries}
The signature includes a [[reference]] string.
<<Object base: reference: TBP>>=
  procedure :: get_signature => reference_get_signature
<<Object base: procedures>>=
  pure recursive function reference_get_signature (object, verbose) &
       result (signature)
    class(reference_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    if (associated (object%core)) then
       signature = object%core%get_signature ()
       if (signature /= "") then
          signature = "reference|" // signature
       else
          signature = "reference"
       end if
    else
       signature = "reference"
    end if
  end function reference_get_signature
  
@ %def reference_get_signature
@ A reference is a reference.
<<Object base: reference: TBP>>=
  procedure :: is_reference => reference_is_reference
<<Object base: procedures>>=
  pure function reference_is_reference (object) result (flag)
    class(reference_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function reference_is_reference
  
@ %def reference_is_reference
@
\subsubsection{Construction and Initialization}
The [[instantiate]] method must be implemented.
<<Object base: reference: TBP>>=
  procedure :: instantiate => reference_instantiate
<<Object base: procedures>>=
  recursive subroutine reference_instantiate (object, instance)
    class(reference_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (reference_t :: instance)
  end subroutine reference_instantiate
    
@ %def reference_instantiate
@ Code is simple.

TODO: We might need a way to identify a remote target.
<<Object base: reference: TBP>>=
  procedure :: get_code => reference_get_code
<<Object base: procedures>>=
  function reference_get_code (object, repository) result (code)
    class(reference_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_REFERENCE
  end function reference_get_code
  
@ %def reference_get_code
@ Link the core as a pointer to an existing object, updating the reference
count.
<<Object base: reference: TBP>>=
  procedure :: link_core => reference_link_core
<<Object base: procedures>>=
  subroutine reference_link_core (object, remote)
    class(reference_t), intent(inout) :: object
    class(object_t), intent(inout), target :: remote
    class(object_t), pointer :: remote_target
    call object%final ()
    remote_target => remote%dereference ()
    object%core => remote_target
    remote_target%refcount = remote_target%refcount + 1
  end subroutine reference_link_core
    
@ %def reference_link_core
@
\subsubsection{Tools}
Dereference.
<<Object base: reference: TBP>>=
  procedure :: dereference => reference_dereference
<<Object base: procedures>>=
  recursive function reference_dereference (object) result (remote)
    class(reference_t), intent(in), target :: object
    class(object_t), pointer :: remote
    if (associated (object%core)) then
       remote => object%core%dereference ()
    else
       remote => null ()
    end if
  end function reference_dereference

@ %def reference_dereference
@
\subsection{Composite object type}
A composite object is an extension of a wrapper: it consists of a core
(essentially, its value) and members (properties). 

Each object has a name which should be unique within the current scope
(i.e., as a member of the parent object, if any).  It also has a mode
(abstract, constant, variable) which controls the assignment of values.

Each object is derived from a [[prototype]].

Objects may be instrinsic or user-defined, inheriting from some intrinsic
prototype. 
<<Object base: parameters>>=
  integer, parameter, public :: MODE_ABSTRACT = 0
  integer, parameter, public :: MODE_CONSTANT = 1
  integer, parameter, public :: MODE_VARIABLE = 2

@ %def MODE_ABSTRACT MODE_CONSTANT MODE_VARIABLE
@
<<Object base: public>>=
  public :: composite_t
<<Object base: types>>=
  type, extends (wrapper_t) :: composite_t
     private
     type(string_t) :: name
     integer :: mode = MODE_ABSTRACT
     logical :: intrinsic = .true.
     logical :: constructed = .false.
     class(composite_t), pointer :: prototype => null ()
     logical, dimension(:), allocatable :: member_is_argument
     type(wrapper_t), dimension(:), pointer :: member => null ()
     type(wrapper_t), dimension(:), pointer :: primer => null ()
   contains
   <<Object base: composite: TBP>>
  end type composite_t

@ %def composite_t
@
\subsubsection{Finalizer}
The finalizer has to take care of core and members.
<<Object base: composite: TBP>>=
  procedure :: final => composite_final
<<Object base: procedures>>=
  recursive subroutine composite_final (object)
    class(composite_t), intent(inout) :: object
    integer :: i
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          if (associated (object%primer(i)%core)) then
             call remove_object (object%primer(i)%core)
          end if
       end do
       deallocate (object%primer)
    end if
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (associated (object%member(i)%core)) then
             call remove_object (object%member(i)%core)
          end if
       end do
       deallocate (object%member)
       deallocate (object%member_is_argument)
    end if
    call object%wrapper_t%final ()
    call object%unregister ()
  end subroutine composite_final
       
@ %def composite_final
@
\subsubsection{Output}
Value: this is the core, if any.
<<Object base: composite: TBP>>=
  procedure :: write_value => composite_write_value
<<Object base: procedures>>=
  recursive subroutine composite_write_value (object, unit, indent)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    if (object%has_value ()) then
       call object%core%write_as_value (unit, indent)
    else
       call object_write_stub (object, unit, indent)
    end if
  end subroutine composite_write_value
    
@ %def composite_write_value
@
Mantle: members/arguments and primer statements.  This explicit routine writes
indices for members.
<<Object base: composite: TBP>>=
  procedure :: write_mantle => composite_write_mantle
<<Object base: procedures>>=
  recursive subroutine composite_write_mantle (object, unit, indent, refcount)
    class(composite_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: member, primer
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call write_indent (u, ind)
          if (object%member_is_argument (i)) then
             write (u, "('A')", advance="no")
          else
             write (u, "('M')", advance="no")
          end if
          write (u, "(I0,':',1x)", advance="no") i
          if (object%member(i)%is_reference ()) then
             write (u, "('*')", advance="no")
          end if
          call object%get_member_ptr (i, member)
          if (associated (member)) then
             call member%write (u, ind, refcount)
          else
             write (u, "('<>')")
          end if
       end do
    end if
    if (associated (object%primer)) then
       do i = 1, size (object%primer)
          call write_indent (u, ind)
          write (u, "('P',I0,':',1x)", advance="no") i
          call object%get_primer_ptr (i, primer)
          if (associated (primer)) then
             call primer%write_as_statement (u, ind)
          end if
          write (u, *)
       end do
    end if
  end subroutine composite_write_mantle
  
@ %def composite_write_mantle
@
\subsubsection{Prototype feature}
When an instance of a composite is created, it should call the
[[register]] method with specified object as prototype.

The [[register]] method must be public, since the assignment type uses it.

The [[unregister]] method is called only by [[remove_object]] and therefore
is private.  It calls [[remove_object]] for the prototype, which will delete
the prototype object if there is no other instance of it.

The new object inherits the [[intrinsic]] tag from its prototype, so
we don't need to unset it manually.
<<Object base: composite: TBP>>=
  procedure, non_overridable :: register => composite_register
  procedure, non_overridable, private :: unregister => composite_unregister
<<Object base: procedures>>=
  subroutine composite_register (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    object%prototype => prototype
    prototype%refcount = prototype%refcount + 1
    object%intrinsic = prototype%intrinsic
  end subroutine composite_register

  recursive subroutine composite_unregister (object)
    class(composite_t), intent(inout) :: object
    class(object_t), pointer :: prototype
    prototype => object%prototype 
    call remove_object (prototype)
    object%prototype => null ()
  end subroutine composite_unregister

@ %def composite_register
@ %def composite_unregister
@ If the object is not an instance, we associate it to the given prototype.
<<Object base: composite: TBP>>=
  procedure :: set_default_prototype => composite_set_default_prototype
<<Object base: procedures>>=
  subroutine composite_set_default_prototype (object, prototype)
    class(composite_t), intent(inout) :: object
    class(composite_t), intent(inout), target :: prototype
    if (.not. associated (object%prototype)) then
       call object%register (prototype)
    end if
  end subroutine composite_set_default_prototype
    
@ %def composite_set_default_prototype
@ If the prototype is a repository member, we can obtain the index of the
prototype.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_index => composite_get_prototype_index
<<Object base: procedures>>=
  function composite_get_prototype_index (object, repository) result (i)
    class(composite_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    if (associated (object%prototype)) then
       call repository%find_member (object%prototype%get_name (), index=i)
    else
       i = 0
    end if
  end function composite_get_prototype_index

@ %def composite_get_prototype_index
@
\subsubsection{Queries}
Access the object's name.
<<Object base: composite: TBP>>=
  procedure :: get_name => composite_get_name
<<Object base: procedures>>=
  pure function composite_get_name (object) result (name)
    class(composite_t), intent(in) :: object
    type(string_t) :: name
    name = object%name
  end function composite_get_name
  
@ %def composite_get_name
@ Prototype string: actually, the prototype of the value object, i.e., the
core.  If there is a core, delegate the function.  Otherwise, delegate to the
prototype or revert to the plain object.

The exception are non-intrinsic objects, for which we write the prototype name
with an enclosing [[type(..)]] clause.
<<Object base: composite: TBP>>=
  procedure :: get_prototype => composite_get_prototype
<<Object base: procedures>>=
  recursive function composite_get_prototype (object) result (prototype)
    class(composite_t), intent(in) :: object
    type(string_t) :: prototype
    if (associated (object%prototype)) then
       if (object%prototype%intrinsic) then
          prototype = object%prototype%get_name ()
       else
          prototype = "type(" // object%prototype%get_name () // ")"
       end if
    else
       prototype = object_get_prototype (object)
    end if   
  end function composite_get_prototype
  
@ %def composite_get_prototype
@ The signature of a composite object.
<<Object base: composite: TBP>>=
  procedure :: get_signature => composite_get_signature
<<Object base: procedures>>=
  pure function composite_get_signature (object, verbose) result (signature)
    class(composite_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    select case (object%mode)
    case (MODE_ABSTRACT)
       signature = "abstract"
    case (MODE_CONSTANT)
       signature = "constant"
    case (MODE_VARIABLE)
       if (verb) then
          signature = "variable"
       else
          signature = ""
       end if
    end select
  end function composite_get_signature
       
@ %def composite_get_signature
@ This query tells whether the object has a core, and this core
describes a value.
<<Object base: composite: TBP>>=
  procedure :: has_value => composite_has_value
<<Object base: procedures>>=
  pure function composite_has_value (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    select case (object%mode)
    case (MODE_CONSTANT, MODE_VARIABLE)
       flag = associated (object%core)
    case default
       flag = .false.
    end select
  end function composite_has_value
  
@ %def composite_has_value
@ The definition status is delegated to the core.
<<Object base: composite: TBP>>=
  procedure :: is_defined => composite_is_defined
<<Object base: procedures>>=
  pure function composite_is_defined (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    if (object%has_value ()) then
       flag = object%core%is_defined ()
    else
       flag = .false.
    end if
  end function composite_is_defined
  
@ %def composite_is_defined
@ Yes if there are member or primer components.
<<Object base: composite: TBP>>=
  procedure :: has_mantle => composite_has_mantle
<<Object base: procedures>>=
  pure function composite_has_mantle (object) result (flag)
    class(composite_t), intent(in) :: object
    logical :: flag
    flag = object%get_n_members () + object%get_n_primers () > 0
  end function composite_has_mantle
  
@ %def composite_has_mantle
@ Return the number of members, of members that are marked as arguments, and
of primer statements, respectively.
<<Object base: composite: TBP>>=
  procedure :: get_n_members => composite_get_n_members
  procedure :: get_n_arguments => composite_get_n_arguments
  procedure :: get_n_primers => composite_get_n_primers
<<Object base: procedures>>=
  pure function composite_get_n_members (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = size (object%member)
    else
       n = 0
    end if
  end function composite_get_n_members
  
  pure function composite_get_n_arguments (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%member)) then
       n = count (object%member_is_argument)
    else
       n = 0
    end if
  end function composite_get_n_arguments
  
  pure function composite_get_n_primers (object) result (n)
    class(composite_t), intent(in) :: object
    integer :: n
    if (associated (object%primer)) then
       n = size (object%primer)
    else
       n = 0
    end if
  end function composite_get_n_primers
  
@ %def composite_get_n_members
@ %def composite_get_n_arguments
@ %def composite_get_n_primers
@ Return pointer to a specific member (dereference and return the core).
<<Object base: composite: TBP>>=
  procedure :: get_member_ptr => composite_get_member_ptr
  procedure :: get_primer_ptr => composite_get_primer_ptr
<<Object base: procedures>>=
  subroutine composite_get_member_ptr (object, i, member)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: member
    if (associated (object%member)) then
       if (associated (object%member(i)%core)) then
          member => object%member(i)%core%dereference ()
       else
          member => null ()
       end if
    else
       member => null ()
    end if
  end subroutine composite_get_member_ptr
  
  subroutine composite_get_primer_ptr (object, i, primer)
    class(composite_t), intent(in) :: object
    integer, intent(in) :: i
    class(object_t), pointer, intent(out) :: primer
    if (associated (object%primer)) then
       if (associated (object%primer(i)%core)) then
          primer => object%primer(i)%core%dereference ()
       else
          primer => null ()
       end if
    else
       primer => null ()
    end if
  end subroutine composite_get_primer_ptr
  
@ %def composite_get_member_ptr
@ %def composite_get_primer_ptr
@ Prototype status and pointer.
<<Object base: composite: TBP>>=
  procedure :: get_prototype_ptr => composite_get_prototype_ptr
<<Object base: procedures>>=
  subroutine composite_get_prototype_ptr (object, prototype)
    class(composite_t), intent(in) :: object
    class(composite_t), intent(out), pointer :: prototype
    prototype => object%prototype
  end subroutine composite_get_prototype_ptr
  
@ %def composite_get_prototype_ptr
@ Query the object mode.  The [[check_mode]] subroutine returns success if an
object is supposed to be mutable.
<<Object base: composite: TBP>>=
  procedure :: check_mode => composite_check_mode
<<Object base: procedures>>=
  pure subroutine composite_check_mode (object, mutable)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: mutable
    select case (object%mode)
    case (MODE_ABSTRACT);  mutable = .false.
    case default
       mutable = .true.
    end select
  end subroutine composite_check_mode
  
@ %def composite_check_mode
@ This query tells if the object is required in an assignment.
<<Object base: composite: TBP>>=
  procedure :: check_role => composite_check_role
<<Object base: procedures>>=
  pure subroutine composite_check_role (object, required)
    class(composite_t), intent(in) :: object
    logical, intent(out) :: required
    select case (object%mode)
    case (MODE_ABSTRACT)
       required = .false.
       if (associated (object%core)) then
          select type (core => object%core)
          type is (tag_t);  required = .true.
          end select
       end if
    case (MODE_CONSTANT, MODE_VARIABLE)
       required = .true.
    case default
       required = .false.
    end select
  end subroutine composite_check_role
  
@ %def composite_check_role
@
\subsubsection{Constructors and Initialization}
Instantiate: setup a composite with the same core as the prototype.
<<Object base: composite: TBP>>=
  procedure :: instantiate => composite_instantiate
<<Object base: procedures>>=
  recursive subroutine composite_instantiate (object, instance)
    class(composite_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (composite_t :: instance)
    select type (instance)
    class is (composite_t)
       call instance%register (object)
       if (associated (object%core)) &
            call object%core%instantiate (instance%core)
    end select
  end subroutine composite_instantiate
  
@ %def composite_instantiate
@
The attribute list consists of [[intrinsic]], [[mode]], and
[[constructed]], expressed as integers.

Attribute codes are assigned as follows:
\begin{enumerate}
\item Prototype index, from the repository
\item Number of members
\item Number of arguments (included in members)
\item Number of primer statements
\item [[mode]]
\item [[intrinsic]] status
\item [[constructed]] status
\end{enumerate}
<<Object base: composite: TBP>>=
  procedure :: get_code => composite_get_code
<<Object base: procedures>>=
  function composite_get_code (object, repository) result (code)
    class(composite_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_COMPOSITE
    code%natt = 7
    if (present (repository)) then
       code%att(1) = object%get_prototype_index (repository)
    end if
    code%att(2) = object%get_n_members ()
    code%att(3) = object%get_n_arguments ()
    code%att(4) = object%get_n_primers ()
    code%att(5) = object%mode
    if (.not. object%intrinsic) then
       code%att(6) = 1
    end if
    if (object%constructed) then
       code%att(7) = 1
    end if
    call code%create_val (code%val, VT_STRING, 1)
    select type (val => code%val)
    type is (val_string_t)
       val%x(1) = object%get_name ()
    end select
  end function composite_get_code
  
@ %def composite_get_code
@ Initialize from code.
<<Object base: composite: TBP>>=
  procedure :: init_from_code => composite_init_from_code
<<Object base: procedures>>=
  subroutine composite_init_from_code (object, code)
    class(composite_t), intent(inout) :: object
    type(code_t), intent(in) :: code
    type(string_t) :: name
    select type (val => code%val)
    type is (val_string_t);  name = val%x(1)
    class default;  name = ""
    end select
    call object%init ( &
         name = name, &
         mode = code%att(5), &
         n_members = code%att(2), &
         n_arguments = code%att(3), &
         n_primers = code%att(4))
    object%intrinsic = code%att(6) == 0
    object%constructed = code%att(7) /= 0
  end subroutine composite_init_from_code

@ %def composite_init_from_code
@ Initialize/reset.

The initializer will prepare for a member array sized [[n_members]], a primer
statement array sized [[n_primers]], and a number of named positional
arguments [[n_args]].  The latter are included in [[n_members]].  If a number
is not provided, the corresponding array is not allocated. 
<<Object base: composite: TBP>>=
  generic :: init => composite_init
  procedure, private :: composite_init
<<Object base: procedures>>=
  subroutine composite_init &
       (object, name, mode, n_members, n_arguments, n_primers)
    class(composite_t), intent(inout), target :: object
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: mode
    integer, intent(in), optional :: n_members
    integer, intent(in), optional :: n_arguments
    integer, intent(in), optional :: n_primers
    integer :: i
    object%name = name
    if (present (mode))  object%mode = mode
    if (present (n_members)) then
       allocate (object%member (n_members))
       do i = 1, n_members
          call object%member(i)%set_context (object)
       end do
       allocate (object%member_is_argument (n_members), source = .false.)
       if (present (n_arguments)) then
          object%member_is_argument(1:n_arguments) = .true.
       end if
    end if
    if (present (n_primers)) then
       allocate (object%primer (n_primers))
       do i = 1, n_primers
          call object%primer(i)%set_context (object)
       end do
       object%constructed = .false.
    else
       object%constructed = .true.
    end if
  end subroutine composite_init
 
@ %def composite_init
@
Mark the object as non-intrinsic.  Default is intrinsic.
<<Object base: composite: TBP>>=
  procedure :: tag_non_intrinsic => composite_tag_non_intrinsic
<<Object base: procedures>>=
  pure subroutine composite_tag_non_intrinsic (object)
    class(composite_t), intent(inout) :: object
    object%intrinsic = .false.
  end subroutine composite_tag_non_intrinsic
  
@ %def composite_tag_non_intrinsic
@ Import a member object which has been created previously.  The object will
become the member's core.  No copy is made, the original pointer is
discarded.
<<Object base: composite: TBP>>=
  procedure :: import_member => composite_import_member
  procedure :: link_member => composite_link_member
<<Object base: procedures>>=
  subroutine composite_import_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    call member%set_context (object%member(i))
    call object%member(i)%final ()
    call object%member(i)%import_core (member)
  end subroutine composite_import_member
    
  subroutine composite_link_member (object, i, member)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: member
    class(object_t), pointer :: ref
    call member%make_reference (ref)
    call object%import_member (i, ref)
  end subroutine composite_link_member
    
@ %def composite_import_member
@ %def composite_link_member
@ Import a primer object which has been created previously.  The object will
become the core of the primer reference.  No copy is made, the original
pointer is discarded.
<<Object base: composite: TBP>>=
  procedure :: import_primer => composite_import_primer
<<Object base: procedures>>=
  subroutine composite_import_primer (object, i, primer)
    class(composite_t), intent(inout), target :: object
    integer, intent(in) :: i
    class(object_t), intent(inout), pointer :: primer
    call primer%set_context (object%primer(i))
    call object%primer(i)%final ()
    object%primer(i)%core => primer
    primer => null ()
  end subroutine composite_import_primer
    
@ %def composite_import_primer
@
\subsubsection{Evaluation}
Construct: First resolve the primer statements, recursively, so pointers are
assigned.  Then evaluate.
<<Object base: composite: TBP>>=
  procedure :: construct => composite_construct
<<Object base: procedures>>=
  recursive subroutine composite_construct (object, success)
    class(composite_t), intent(inout), target :: object
    logical, intent(out) :: success
    integer :: i
    success = .true.
    if (.not. object%constructed) then
       do i = 1, size (object%primer)
          call object%primer(i)%core%resolve (success)
          if (.not. success)  return
       end do
       do i = 1, size (object%primer)
          call object%primer(i)%core%evaluate ()
       end do
    end if
    object%constructed = .true.
  end subroutine composite_construct
  
@ %def composite_construct
@ Evaluate all members that are marked as arguments, if they are local
references.  We can stop at the first member that is not an argument.
<<Object base: composite: TBP>>=
  procedure :: evaluate_arguments => composite_evaluate_arguments
<<Object base: procedures>>=
  recursive subroutine composite_evaluate_arguments (object)
    class(composite_t), intent(inout) :: object
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          if (object%member_is_argument(i)) then
             call object%member(i)%core%evaluate ()
          end if
       end do
    end if
  end subroutine composite_evaluate_arguments
       
@ %def composite_evaluate_arguments
@
\subsubsection{Iterator Support}
Iterate: first scan the members, then core.  Then, return to
context.
<<Object base: composite: TBP>>=
  procedure :: next_position => composite_next_position
<<Object base: procedures>>=
  subroutine composite_next_position &
       (object, position, next_object, import_object)
    class(composite_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE, POS_ID)
       if (object%get_n_members () > 0) then
          position%part = POS_MEMBER
          position%i = 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call object%wrapper_t%next_position &
               (position, next_object, import_object)
       end if
    case (POS_MEMBER)
       if (position%i < size (object%member)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_member (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%member(position%i)%core
       else if (object%get_n_primers () > 0) then
          position%part = POS_PRIMER
          position%i = 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object)) &
               next_object => object%primer(position%i)%core
       else
          call object%wrapper_t%next_position &
               (position, next_object, import_object)
       end if
    case (POS_PRIMER)
       if (position%i < size (object%primer)) then
          position%i = position%i + 1
          if (present (import_object)) then
             call object%import_primer (position%i, import_object)
          end if
          if (present (next_object))  next_object => object%primer(position%i)
       else
          call object%wrapper_t%next_position &
               (position, next_object, import_object)
       end if
    case default
       call object%wrapper_t%next_position &
            (position, next_object, import_object)
    end select
  end subroutine composite_next_position
  
@ %def composite_next_position
@
\subsubsection{Tools}
Return a pointer to a path, given in form of an array of strings.  If no
object is found, return a null pointer.  Otherwise, return a pointer to the
object as [[member]].

First search the immediate members of the current object.  Then search the
prototype object.
<<Object base: composite: TBP>>=
  procedure :: find => composite_find
<<Object base: procedures>>=
  recursive subroutine composite_find (object, path, member)
    class(composite_t), intent(in) :: object
    type(string_t), dimension(:), intent(in) :: path
    class(object_t), intent(out), pointer :: member
    class(object_t), pointer :: parent
    member => null ()
    if (size (path) > 0) then
       call object%find_member (path(1), member)
       if (associated (member)) then
          if (size (path) > 1) then
             parent => member
             call parent%find (path(2:), member)
          end if
       else
          if (associated (object%prototype)) then
             call object%prototype%find (path, member)
          end if
          if (.not. associated (member)) then
             call wrapper_find (object, path, member)
          end if
       end if
    end if
  end subroutine composite_find
    
@ %def composite_find_member
@ Return a pointer to a specific member.  If the object has no members, or the
member is not found, return a null pointer.
<<Object base: composite: TBP>>=
  procedure :: find_member => composite_find_member
<<Object base: procedures>>=
  subroutine composite_find_member (object, name, member, index)
    class(composite_t), intent(in) :: object
    type(string_t), intent(in) :: name
    class(object_t), intent(out), optional, pointer :: member
    integer, intent(out), optional :: index
    class(object_t), pointer :: core
    integer :: i
    if (associated (object%member)) then
       do i = 1, size (object%member)
          call object%member(i)%get_core_ptr (core)
          if (core%get_name () == name) then
             if (present (member))  member => core%dereference ()
             if (present (index))  index = i
             return
          end if
       end do
    end if
    if (present (member))  member => null ()
    if (present (index))  index = 0
  end subroutine composite_find_member
    
@ %def composite_find_member
@
\subsection{Repository}
A repository is a simple extension of a generic [[composite_t]] object.  It
collects the objects that are supposed to act as prototypes.  We hold those
objects as members and access them by name or by index.

It has a [[spawn]] method which allows it to create new objects from those
prototypes.
<<Object base: public>>=
  public :: repository_t
<<Object base: types>>=
  type, extends (composite_t) :: repository_t
     private
   contains
   <<Object base: repository: TBP>>
  end type repository_t
  
@ %def repository_t
@ Include: add a new object as a prototype to the repository member array.  We
have to extend the array by one.  The new object is stored as a non-local
reference.
<<Object base: repository: TBP>>=
  procedure :: include => repository_include
<<Object base: procedures>>=
  subroutine repository_include (repository, object)
    class(repository_t), intent(inout), target :: repository
    class(object_t), intent(inout), target :: object
    type(wrapper_t), dimension(:), pointer :: new_member
    logical, dimension(:), allocatable :: member_is_argument
    class(object_t), pointer :: ref
    integer :: n
    n = size (repository%member) 
    allocate (new_member (n + 1))
    new_member(1:n) = repository%member
    deallocate (repository%member)
    call object%make_reference (ref)
    call new_member(n+1)%import_core (ref)
    call new_member(n+1)%set_context (repository)
    repository%member => new_member
    deallocate (repository%member_is_argument)
    allocate (repository%member_is_argument (n+1), source=.false.)
  end subroutine repository_include
    
@ %def repository_include
@ There are two variants of the [[spawn]] method: either search for the
prototype name or use a known member index.
<<Object base: repository: TBP>>=
  generic :: spawn => spawn_by_name, spawn_by_index
  procedure, private :: spawn_by_name
  procedure, private :: spawn_by_index
<<Object base: procedures>>=
  subroutine spawn_by_name (repository, name, object)
    class(repository_t), intent(in) :: repository
    type(string_t), intent(in) :: name
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%find_member (name, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_name
    
  subroutine spawn_by_index (repository, i, object)
    class(repository_t), intent(in) :: repository
    integer, intent(in) :: i
    class(object_t), intent(out), pointer :: object
    class(object_t), pointer :: prototype
    call repository%get_member_ptr (i, prototype)
    if (associated (prototype)) then
       call prototype%instantiate (object)
    else
       object => null ()
    end if
  end subroutine spawn_by_index
    
@ %def spawn_by_name
@ %def spawn_by_index
@
\subsection{Object iterator}
The object iterator allows us to traverse the object tree in a well-defined
order.   

\subsubsection{Position object}
The index allows us to track members.  Objects should communicate with the
iterator via the [[position_t]] object, therefore public and transparent.
<<Object base: public>>=
  public :: position_t
<<Object base: types>>=
  type :: position_t
     integer :: part = POS_HERE
     integer :: i = 0
  end type position_t

@ %def position_t
@ 
\subsubsection{Iterator stack}
Positions objects are pushed on a stack (LIFO).  This constitutes the
iterator, the last stack entry provides the current object pointer.
<<Object base: types>>=
  type, extends (position_t) :: position_entry_t
     private
     class(object_t), pointer :: object => null ()
     type(position_entry_t), pointer :: previous => null ()
  end type position_entry_t
  
@ %def position_entry_t
<<Object base: public>>=
  public :: object_iterator_t
<<Object base: types>>=
  type :: object_iterator_t
     private
     type(position_entry_t), pointer :: current => null ()
   contains
   <<Object base: object iterator: TBP>>
  end type object_iterator_t
  
@ %def object_iterator
@ Recursively clear.
<<Object base: object iterator: TBP>>=
  procedure :: final => object_iterator_final
<<Object base: procedures>>=
  subroutine object_iterator_final (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    do while (associated (it%current))
       call it%pop ()
    end do
  end subroutine object_iterator_final
    
@ %def object_iterator_final
@ Output for debugging purposes.
<<Object base: object iterator: TBP>>=
  procedure :: write => object_iterator_write
<<Object base: procedures>>=
  subroutine object_iterator_write (it, unit)
    class(object_iterator_t), intent(in) :: it
    integer, intent(in), optional :: unit
    type(position_entry_t), pointer :: entry
    integer :: u
    u = given_output_unit (unit)
    entry => it%current
    do while (associated (entry))
       select case (entry%part)
       case (POS_NONE)
          write (u, "(1x,'-')", advance="no")
       case (POS_HERE)
          write (u, "(1x,'H')", advance="no")
       case (POS_ID)
          write (u, "(1x,'I')", advance="no")
       case (POS_CORE)
          write (u, "(1x,'C')", advance="no")
       case (POS_MEMBER)
          write (u, "(1x,'M',I0)", advance="no")  entry%i
       case (POS_PRIMER)
          write (u, "(1x,'P',I0)", advance="no")  entry%i
       case default
          write (u, "(1x,'?')", advance="no")
       end select
       entry => entry%previous
    end do
  end subroutine object_iterator_write
  
@ %def object_iterator_write
@ Push/pop a fresh position object at the it entry point.
<<Object base: object iterator: TBP>>=
  procedure, private :: push => object_iterator_push
  procedure, private :: pop => object_iterator_pop
<<Object base: procedures>>=
  subroutine object_iterator_push (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    allocate (entry)
    entry%previous => it%current
    it%current => entry
  end subroutine object_iterator_push
    
  subroutine object_iterator_pop (it)
    class(object_iterator_t), intent(inout) :: it
    type(position_entry_t), pointer :: entry
    entry => it%current
    if (associated (entry)) then
       it%current => entry%previous
       deallocate (entry)
    else
       it%current => null ()
    end if
  end subroutine object_iterator_pop
  
@ %def object_iterator_push
@ %def object_iterator_pop
@
\subsubsection{Iterator: initialization and query}
Create a single-entry it and position at the root object.
<<Object base: object iterator: TBP>>=
  procedure :: init => object_iterator_init
<<Object base: procedures>>=
  subroutine object_iterator_init (it, object)
    class(object_iterator_t), intent(out) :: it
    class(object_t), intent(in), target :: object
    call it%push ()
    it%current%object => object
  end subroutine object_iterator_init
    
@ %def object_iterator_init
@ The iterator is valid as long as the stack has a
current entry, associated with the current object.
<<Object base: object iterator: TBP>>=
  procedure :: is_valid => object_iterator_is_valid
<<Object base: procedures>>=
  function object_iterator_is_valid (it) result (flag)
    class(object_iterator_t), intent(in) :: it
    logical :: flag
    flag = associated (it%current)
  end function object_iterator_is_valid
  
@ %def object_iterator_is_valid
@ Return the object pointer.
<<Object base: object iterator: TBP>>=
  procedure :: get_object => object_iterator_get_object
<<Object base: procedures>>=
  subroutine object_iterator_get_object (it, object)
    class(object_iterator_t), intent(in) :: it
    class(object_t), pointer, intent(out) :: object
    if (associated (it%current)) then
       object => it%current%object
    else
       object => null ()
    end if
  end subroutine object_iterator_get_object
  
@ %def object_iterator_get_object
@ Return the code for the next object in automatic navigation order.
<<Object base: object iterator: TBP>>=
  procedure :: get_next_position => object_iterator_get_next_position
<<Object base: procedures>>=
  subroutine object_iterator_get_next_position (it, position)
    class(object_iterator_t), intent(inout) :: it
    type(position_t), intent(out) :: position
    if (associated (it%current)) then
       position = it%current%position_t
       call it%current%object%next_position (position)
    end if
  end subroutine object_iterator_get_next_position
    
@ %def object_iterator_get_next_position
@
\subsubsection{Automatic navigation}
Advance, traversing the objects in well-defined order.  The order is under
control of the current object.  It should increment the position counter and
return a pointer to the next object in line, if possible.

If the [[import_object]] argument is given, insert this as the next object in
the object tree, before moving to it.  If the insertion was successful, the
[[import_object]] pointer will be null on exit.
<<Object base: object iterator: TBP>>=
  procedure :: advance => object_iterator_advance
<<Object base: procedures>>=
  recursive subroutine object_iterator_advance (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    class(position_t), pointer :: position
    class(object_t), pointer :: next_object
    position => it%current
    call it%current%object%next_position (position, next_object, import_object)
    select case (position%part)
    case (POS_NONE)
       call it%skip (import_object)
    case default
       call it%push ()
       it%current%object => next_object
    end select
  end subroutine object_iterator_advance
       
@ %def object_iterator_advance
@ This is a variant that tells the iterator to skip the current object and all
of its subobjects, returning to the previous stack entry and advancing from
there.  The routine is also called by [[advance]] when the current object is
already exhausted.
<<Object base: object iterator: TBP>>=
  procedure :: skip => object_iterator_skip
<<Object base: procedures>>=
  recursive subroutine object_iterator_skip (it, import_object)
    class(object_iterator_t), intent(inout) :: it
    class(object_t), pointer, intent(inout), optional :: import_object
    call it%pop ()
    if (it%is_valid ()) then
       call it%advance (import_object)
    else
       call it%final ()
    end if
  end subroutine object_iterator_skip
       
@ %def object_iterator_skip
@
\subsubsection{Manual navigation}
Navigate in specific ways.
<<Object base: object iterator: TBP>>=
  procedure :: to_context => object_iterator_to_context
  procedure :: to_id => object_iterator_to_id
  procedure :: to_core => object_iterator_to_core
  procedure :: to_member => object_iterator_to_member
  procedure :: to_primer => object_iterator_to_primer
<<Object base: procedures>>=
  subroutine object_iterator_to_context (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    if (it%is_valid ()) then
       call it%pop ()
       success = .true.
    else
       success = .false.
    end if
  end subroutine object_iterator_to_context

  subroutine object_iterator_to_id (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = .false.
    object => it%current%object
    if (object%has_id ()) then
       it%current%part = POS_ID
       call it%push ()
       call object%get_id_ptr (it%current%object)
       success = .true.
    end if
  end subroutine object_iterator_to_id

  subroutine object_iterator_to_core (it, success)
    class(object_iterator_t), intent(inout) :: it
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (wrapper_t)
       if (associated (object%core)) then
          it%current%part = POS_CORE
          call it%push ()
          it%current%object => object%core
          success = .true.
       end if
    end select
  end subroutine object_iterator_to_core

  subroutine object_iterator_to_member (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%member)) then
          if (0 < i .and. i <= size (object%member)) then
             if (associated (object%member(i)%core)) then
                it%current%part = POS_MEMBER
                it%current%i = i
                call it%push ()
                it%current%object => object%member(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_member

  subroutine object_iterator_to_primer (it, i, success)
    class(object_iterator_t), intent(inout) :: it
    integer, intent(in) :: i
    logical, intent(out) :: success
    success = .false.
    select type (object => it%current%object)
    class is (composite_t)
       if (associated (object%primer)) then
          if (0 < i .and. i <= size (object%primer)) then
             if (associated (object%primer(i)%core)) then
                it%current%part = POS_PRIMER
                it%current%i = i
                call it%push ()
                it%current%object => object%primer(i)%core
                success = .true.
             end if
          end if
       end if
    end select
  end subroutine object_iterator_to_primer

@ %def object_iterator_to_context
@ %def object_iterator_to_id
@ %def object_iterator_to_core
@ %def object_iterator_to_member
@ %def object_iterator_to_primer
@ 
\subsection{Unit tests}
<<Object base: public>>=
  public :: object_base_test
<<Object base: procedures>>=
  subroutine object_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object base: execute tests>>  
  end subroutine object_base_test
  
@ %def object_base_test 
@
\subsubsection{Prototype Implementation}
Create a tag object and use it as a prototype.
<<Object base: execute tests>>=
  call test (object_base_1, "object_base_1", &
       "object and prototype", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: obj1, obj2
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_1"
    write (u, "(A)")  "*   Purpose: elementary operations with objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Trivial object (tag): create, instantiate, display"

    allocate (tag_t :: obj1)
    call obj1%instantiate (obj2)
    
    write (u, "(A)")
    call obj1%write (u, refcount=.true.)
    call obj2%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Object code:"
    write (u, "(A)")

    code = obj1%get_code ()
    call code%write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    call remove_object (obj1)
    call remove_object (obj2)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (obj1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (obj2)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_1"
    
    end subroutine object_base_1

@ %def object_base_1
@ Create a composite object.
<<Object base: execute tests>>=
  call test (object_base_2, "object_base_2", &
       "composite object", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, object1, object2, object3
    class(object_t), pointer :: member
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_2"
    write (u, "(A)")  "*   Purpose: build composite objects"

    write (u, "(A)")      
    write (u, "(A)")  "* Create tag prototype"
    
    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite without members"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%init (name = var_str ("obj1"))
    end select
   
    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate as composite with two members"
    
    call prototype%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%tag_non_intrinsic ()
       call object2%init (name = var_str ("obj2"), n_members = 2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object2%import_member (1, member)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (2, member)
    end select
    
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Code of obj2"
    
    code = object2%get_code ()

    write (u, "(A)")
    call code%write (u, verbose=.true.)

    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Instantiate further with additional member"
    
    call object2%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("new"))
       end select
       call object3%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj3"
    
    call remove_object (object3)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj2"
    
    call remove_object (object2)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Remove obj1"
    
    call remove_object (object1)

    write (u, "(A)")      
    write (u, "(A)")  "* Prototype status"
    
    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    call remove_object (prototype)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup:"

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj1 allocated =", associated (object1)
    write (u, "(A,1x,L1)")  "obj2 allocated =", associated (object2)
    write (u, "(A,1x,L1)")  "obj3 allocated =", associated (object3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_2"
    
    end subroutine object_base_2

@ %def object_base_2
@ Find objects by path.
<<Object base: execute tests>>=
  call test (object_base_3, "object_base_3", &
       "object path search", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, foo, bar

    write (u, "(A)")  "* Test output: object_base_3"
    write (u, "(A)")  "*   Purpose: find objects by path"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1"

    object1 => null ()
    select type (object3)
    class is (composite_t)
       call object3%find_member (var_str ("obj1"), object1)
    end select

    write (u, "(A)")
    call object1%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj1.foo"

    foo => null ()
    call object3%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Return pointer to obj2.foo"

    foo => null ()
    call object3%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2"

    object2 => null ()
    call object1%find ([var_str ("obj2")], object2)

    if (associated (object2)) then
       write (u, "(A)")
       call object2%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to obj2.foo"

    foo => null ()
    call object1%find ([var_str ("obj2"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at obj1, return pointer to bar"

    bar => null ()
    call object1%find ([var_str ("bar")], bar)

    if (associated (bar)) then
       write (u, "(A)")
       call bar%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")      
    write (u, "(A)")  "* Starting at bar, return pointer to obj1.foo"

    foo => null ()
    call bar%find ([var_str ("obj1"), var_str ("foo")], foo)

    if (associated (foo)) then
       write (u, "(A)")
       call foo%write (u, refcount=.true.)
    end if
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)

    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_3"
    
    end subroutine object_base_3

@ %def object_base_3
@ Handle references and copies.
<<Object base: execute tests>>=
  call test (object_base_4, "object_base_4", &
       "object references and copies", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: obj, ref

    write (u, "(A)")  "* Test output: object_base_4"
    write (u, "(A)")  "*   Purpose: create references and copies"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create object"
    
    call prototype%instantiate (obj)
    select type (obj)
    class is (composite_t)
       call obj%init (name = var_str ("obj"))
    end select
    
    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create reference"

    call obj%make_reference (ref)

    write (u, "(A)")      
    call prototype%write (u, refcount=.true.)
    call obj%write (u, refcount=.true.)
    call ref%write (u, refcount=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (ref)
    call remove_object (obj)
    call remove_object (prototype)
    call remove_object (tag)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "tag allocated =", associated (tag)
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "obj allocated =", associated (obj)
    write (u, "(A,1x,L1)")  "ref allocated =", associated (ref)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_4"
    
  end subroutine object_base_4

@ %def object_base_4
@ Iterate.
<<Object base: execute tests>>=
  call test (object_base_5, "object_base_5", &
       "object iterator", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype, member
    class(object_t), pointer :: object1, object2, object3, ptr
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_5"
    write (u, "(A)")  "*   Purpose: use iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create prototypes for tag and tag composite"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select

    write (u, "(A)")      
    write (u, "(A)")  "* Create nested composite"
    
    call prototype%instantiate (object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select

    call object1%instantiate (object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"))
    end select

    call prototype%instantiate (object3)
    select type (object3)
    class is (composite_t)
       call object3%init (name = var_str ("obj3"), n_members = 3)
       call object3%import_member (1, object1)
       call object3%import_member (2, object2)
       call prototype%instantiate (member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object3%import_member (3, member)
    end select
    
    write (u, "(A)")
    call object3%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through obj3, skipping obj2"
    write (u, "(A)")      

    call it%init (object3)
    do while (it%is_valid ())
       call it%get_object (ptr)
       if (ptr%get_name () == "obj2") then
          call it%skip ()
          cycle
       end if
       call ptr%write (u, mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call remove_object (object3)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_5"
    
    end subroutine object_base_5

@ %def object_base_5
@ Repository for prototypes.
<<Object base: execute tests>>=
  call test (object_base_6, "object_base_6", &
       "prototype repository", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object1, object2, object3, member
    type(repository_t), target :: repository
    type(code_t) :: code

    write (u, "(A)")  "* Test output: object_base_6"
    write (u, "(A)")  "*   Purpose: use prototype repository"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create composite with member of type tag"
     
    call repository%spawn (var_str ("tag"), object1)
    select type (object1)
    class is (composite_t)
       call object1%tag_non_intrinsic ()
       call object1%init (name = var_str ("obj1"), n_members = 1)
       call repository%spawn (1, member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("foo"))
       end select
       call object1%import_member (1, member)
    end select
 
    write (u, "(A)")
    call object1%write (u, refcount=.true.)

    write (u, "(A)")      
    code = object1%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Create extension of object1"
    
    call repository%include (object1)
    call repository%spawn (var_str ("obj1"), object2)
    select type (object2)
    class is (composite_t)
       call object2%init (name = var_str ("obj2"), n_members = 1)
       call repository%spawn (var_str ("tag"), member)
       select type (member)
       type is (composite_t);  call member%init (name = var_str ("bar"))
       end select
       call object2%import_member (1, member)
    end select
       
    write (u, "(A)")
    call object2%write (u, refcount=.true.)
    
    write (u, "(A)")      
    code = object2%get_code (repository)
    call code%write (u, verbose=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Repository state"
     
    write (u, "(A)")
    call repository%write (u, refcount=.true.)

    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (object2)
    call remove_object (object1)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_6"
    
    end subroutine object_base_6

@ %def object_base_6
@ Object building.
<<Object base: execute tests>>=
  call test (object_base_7, "object_base_7", &
       "build composite using code", &
       u, results)
<<Object base: tests>>=  
  subroutine object_base_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: main, object
    type(repository_t), target :: repository
    integer, parameter :: ncode = 4
    integer :: utmp, i
    type(code_t), dimension(ncode) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_base_7"
    write (u, "(A)")  "*   Purpose: object building using code and iterator"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    call repository%init (name = var_str ("repo"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create anonymous wrapper"
    
    allocate (wrapper_t :: main)

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Code array for composite with member"
     
    utmp = free_unit ()
    open (utmp, status="scratch")
    ! Composite with 1 member, named 'obj1'
    write (utmp, "(A)")  "100 2 1 7 1 1 0 0 0 1 1"
    write (utmp, "(A)")  " obj1"
    ! Member: composite named 'foo'
    write (utmp, "(A)")  "100 2 1 7 1 0 0 0 0 1 1"
    write (utmp, "(A)")  " foo"
    ! Member core: tag
    write (utmp, "(A)")  "  1 0 0 0"
    ! Parent core: tag
    write (utmp, "(A)")  "  1 0 0 0"

    rewind (utmp)
    write (u, "(A)")
    do i = 1, ncode
       call code(i)%read (utmp)
       call code(i)%write (u, verbose=.true.)
    end do
    close (utmp)

    write (u, "(A)")      
    write (u, "(A)")  "* Build composite using code array"
     
    call it%init (main)
    do i = 1, ncode
       call build_object (object, code(i), repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
    end do

    write (u, "(A)")
    select type (main)
    class is (wrapper_t)
       if (associated (main%core)) then
          call main%core%write (u)
       end if
    end select
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)

    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_base_7"
    
    end subroutine object_base_7

@ %def object_base_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Builder}
This module introduces an [[object_builder_t]] which allows us to convert
bytecode into an object tree and back.  This is an implementation of
abstract [[builder_t]].

The code definitions are in the [[codes]] module, while the [[object_base]]
module provides a [[build_object]] procedure.  Furthermore, we need an object
repository.
<<[[object_builder.f90]]>>=
<<File header>>

module object_builder

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use codes
  use builders
  use object_base

<<Standard module head>>

<<Object builder: public>>

<<Object builder: types>>

contains

<<Object builder: procedures>>

<<Object builder: tests>>

end module object_builder
@ %def object_builder
@
\subsection{Type}
<<Object builder: public>>=
  public :: object_builder_t
<<Object builder: types>>=
  type, extends (builder_t) :: object_builder_t
     private
     type(repository_t), allocatable :: repository
     class(object_t), pointer :: main => null ()
     type(object_iterator_t) :: it
   contains
   <<Object builder: object builder: TBP>>
  end type object_builder_t
  
@ %def object_builder_t
@ 
Finalizer:
<<Object builder: object builder: TBP>>=
  procedure :: final => object_builder_final
<<Object builder: procedures>>=
  subroutine object_builder_final (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    if (allocated (builder%repository)) then
       call builder%repository%final ()
       deallocate (builder%repository)
    end if
  end subroutine object_builder_final

@ %def object_builder_final
@
Output:
<<Object builder: object builder: TBP>>=
  procedure :: write => object_builder_write
<<Object builder: procedures>>=
  subroutine object_builder_write (builder, unit)
    class(object_builder_t), intent(in) :: builder
    integer, intent(in), optional :: unit
    class(object_t), pointer :: core
    integer :: u
    u = given_output_unit (unit)
    write (u, "(A)")  "Object builder:"
    write (u, "(1x)", advance="no")
    if (allocated (builder%repository)) then
       call builder%repository%write (u)
    else
       write (u, "(A)")  "[no repository]"
    end if
    write (u, "(1x)", advance="no")
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (core)
          if (associated (core)) then
             call core%write (u)
          else
             write (u, "(A)")  "[Empty object]"
          end if
       end select
    else
       write (u, "(A)")  "[No object]"
    end if
    if (builder%it%is_valid ()) then
       write (u, "(1x,A)", advance="no")  "Iterator:"
       call builder%it%write (u)
       write (u, *)
    else
       write (u, "(1x,A)")  "[Null iterator]"
    end if
  end subroutine object_builder_write

@ %def object_builder_write
@
\subsection{Initialization}
This is probably done only once.
<<Object builder: object builder: TBP>>=
  procedure :: import_repository => object_builder_import_repository
<<Object builder: procedures>>=
  subroutine object_builder_import_repository (builder, repository)
    class(object_builder_t), intent(inout) :: builder
    type(repository_t), intent(inout), allocatable :: repository
    call move_alloc (from=repository, to=builder%repository)
  end subroutine object_builder_import_repository
  
@ %def object_builder_import_repository
@ This can be done repeatedly.
<<Object builder: object builder: TBP>>=
  procedure :: reset => object_builder_reset
<<Object builder: procedures>>=
  subroutine object_builder_reset (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%it%final ()
    if (associated (builder%main)) then
       call remove_object (builder%main)
    end if
  end subroutine object_builder_reset
    
@ %def object_builder_reset
@ Initialize for decoding an existing object tree.  The object is allocated as
a reference to the object.  The repository is not touched.
<<Object builder: object builder: TBP>>=
  procedure :: init_object => object_builder_init_object
<<Object builder: procedures>>=
  subroutine object_builder_init_object (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(inout), target :: object
    call builder%reset ()
    call object%make_reference (builder%main)
    call builder%it%init (builder%main%dereference ())
  end subroutine object_builder_init_object
  
@ %def object_builder_init_object
@ Initialize for building a new object tree.  The object is allocated as a
wrapper.
<<Object builder: object builder: TBP>>=
  procedure :: init_empty => object_builder_init_empty
<<Object builder: procedures>>=
  subroutine object_builder_init_empty (builder)
    class(object_builder_t), intent(inout) :: builder
    call builder%reset ()
    allocate (wrapper_t :: builder%main)
    call builder%it%init (builder%main)
  end subroutine object_builder_init_empty
    
@ %def object_builder_init_empty
@
\subsection{Decoding}
Decode the current object and advance the iterator.  If there is no object
left, return [[.false.]]
<<Object builder: object builder: TBP>>=
  procedure :: decode => object_builder_decode
<<Object builder: procedures>>=
  subroutine object_builder_decode (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(out) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    success = builder%it%is_valid ()
    if (success) then
       call builder%it%get_object (object)
       code = object%get_code (builder%repository)
       call builder%it%advance ()
    end if
  end subroutine object_builder_decode
  
@ %def object_builder_decode
@
\subsection{Building}
Take the current code, build a new object if appropriate, and insert this (or
the value given by the code) at the next location in the object tree.  Then
advance the iterator to the new location.
<<Object builder: object builder: TBP>>=
  procedure :: build => object_builder_build
<<Object builder: procedures>>=
  subroutine object_builder_build (builder, code, success)
    class(object_builder_t), intent(inout) :: builder
    type(code_t), intent(in) :: code
    logical, intent(out) :: success
    class(object_t), pointer :: object
    call build_object (object, code, builder%repository)
    if (associated (object)) then
       call builder%it%advance (import_object = object)
    else
       call builder%it%advance ()
    end if
    call builder%it%get_object (object)
    select type (object)
    class is (value_t)
       call object%init_from_code (code)
    end select
    success = builder%it%is_valid ()
  end subroutine object_builder_build
    
@ %def object_builder_build
@ Extract the complete object tree.  The builder is reset to empty state.
<<Object builder: object builder: TBP>>=
  procedure :: export => object_builder_export
<<Object builder: procedures>>=
  subroutine object_builder_export (builder, object)
    class(object_builder_t), intent(inout) :: builder
    class(object_t), intent(out), pointer :: object
    object => null ()
    if (associated (builder%main)) then
       select type (main => builder%main)
       class is (wrapper_t)
          call main%get_core_ptr (object)
       end select
       deallocate (builder%main)
    end if
    call builder%reset ()
  end subroutine object_builder_export
          
@ %def object_builder_export
@ 
\subsection{Unit tests}
<<Object builder: public>>=
  public :: object_builder_test
<<Object builder: procedures>>=
  subroutine object_builder_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Object builder: execute tests>>  
  end subroutine object_builder_test
  
@ %def object_builder_test 
@ Object building.
<<Object builder: execute tests>>=
  call test (object_builder_1, "object_builder_1", &
       "build composite using builder", &
       u, results)
<<Object builder: tests>>=  
  subroutine object_builder_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: tag, prototype
    class(object_t), pointer :: object, member
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    type(code_t) :: code
    logical :: success
    integer :: utmp, iostat

    write (u, "(A)")  "* Test output: object_builder_1"
    write (u, "(A)")  "*   Purpose: object building using builder"

    write (u, "(A)")      
    write (u, "(A)")  "* Create repository with tag prototype"

    allocate (tag_t :: tag)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("tag"))
       call prototype%import_core (tag)
    end select
    
    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 1)
    call repository%import_member (1, prototype)

    write (u, "(A)")
    call repository%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create composite"
    
    call repository%spawn (var_str ("tag"), member)
    select type (member)
    class is (composite_t)
       call member%init (name = var_str ("foo"))
    end select
    
    call repository%spawn (var_str ("tag"), object)
    select type (object)
    class is (composite_t)
       call object%init (name = var_str ("obj1"), n_members = 1)
       call object%import_member (1, member)
    end select
    
    write (u, "(A)")
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Create builder"
    
    call builder%import_repository (repository)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Initialize builder with object"
    
    call builder%init_object (object)

    write (u, "(A)")
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Decode"
    write (u, "(A)")      
      
    utmp = free_unit ()
    open (utmp, status="scratch")

    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do

    call remove_object (object)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Reset builder"
    write (u, "(A)")     
 
    call builder%init_empty ()
    call builder%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Reconstruct object"
    write (u, "(A)")      

    rewind (utmp)
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    close (utmp)

    call builder%export (object)
    call object%write (u)
    
    write (u, "(A)")      
    write (u, "(A)")  "* Cleanup"

    call builder%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_builder_1"
    
    end subroutine object_builder_1

@ %def object_builder_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Expressions}
This module supplements the system of basic objects by statements and
expressions.  Those are composite objects that can be evaluated.  We
furthermore implement assignments as special statements, and define unary and
binary operators as special expressions.
<<[[object_expr.f90]]>>=
<<File header>>

module object_expr

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units
  use codes
  use object_base

<<Standard module head>>

<<Expr: public>>

<<Expr: parameters>>

<<Expr: types>>

<<Expr: interfaces>>

contains

<<Expr: procedures>>

end module object_expr
@ %def object_expr
@
\subsection{Statements}
A statement is an extended composite.  The first few of the members are
interpreted as arguments.  There is no core.
<<Expr: public>>=
  public :: statement_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: statement_t
     private
   contains
   <<Expr: statement: TBP>>
  end type statement_t
  
@ %def statement_t
@
\subsubsection{Queries}
The default prototype for all statements.
<<Expr: statement: TBP>>=
  procedure :: get_prototype => statement_get_prototype
<<Expr: procedures>>=
  function statement_get_prototype (object) result (prototype)
    class(statement_t), intent(in) :: object
    type(string_t) :: prototype
    prototype = "statement"
  end function statement_get_prototype
  
@ %def statement_get_prototype
@ The statement is a statement.
<<Expr: statement: TBP>>=
  procedure :: is_statement => statement_is_statement
<<Expr: procedures>>=
  pure function statement_is_statement (object) result (flag)
    class(statement_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function statement_is_statement
  
@ %def statement_is_statement
@
\subsection{Assignment item}
An assignment item combines pointers for the left-hand and right-hand sides of
an elementary value assignment.  A list of such items constitutes a composite
assignment.
<<Expr: types>>=
  type :: item_t
     private
     class(value_t), pointer :: lhs => null ()
     class(value_t), pointer :: rhs => null ()
     class(item_t), pointer :: next => null ()
  end type item_t
  
@ %def item_t
@
\subsection{Assignment object}
The ID object should be allocated and owned by the assignment object.  It
denotes the ID (object path) of the LHS.  The [[lhs]] object is just a pointer
to the actual LHS object that is stored elsewhere.  It is the root of the
object list for assignment, and set by the [[resolve]] method.  Finally, the
[[item]] list indicates the actual assignments to perform.
<<Expr: public>>=
  public :: assignment_t
<<Expr: types>>=
  type, extends (statement_t) :: assignment_t
     private
     class(object_t), pointer :: id => null ()
     class(object_t), pointer :: lhs => null ()
     class(item_t), pointer :: item => null ()
   contains
   <<Expr: assignment: TBP>>
  end type assignment_t
     
@ %def assignment_t
@
\subsubsection{Finalizer}
The core (rhs) will be finalized depending on whether it is
stored as a reference or a local component.  The lhs pointer is never
finalized.
<<Expr: assignment: TBP>>=
  procedure :: final => assignment_final
<<Expr: procedures>>=
  recursive subroutine assignment_final (object)
    class(assignment_t), intent(inout) :: object
    class(item_t), pointer :: item
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    do while (associated (object%item))
       item => object%item
       object%item => item%next
       deallocate (item)
    end do
    call object%composite_t%final ()
  end subroutine assignment_final
    
@ %def assignment_final
@
\subsubsection{Output}
Output in statement form.  For the LHS, we try to write the path
expression.  The RHS is written as an expression.
<<Expr: assignment: TBP>>=
  procedure :: write_statement => assignment_write_statement
<<Expr: procedures>>=
  recursive subroutine assignment_write_statement (object, unit, indent)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: rhs
    integer :: u, i
    u = given_output_unit (unit)
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, indent)
       else
          write (u, "('<LHS>')", advance="no")
       end if
    else
       write (u, "('<LHS>')", advance="no")
    end if
    write (u, "(1x,'=',1x)", advance="no")
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write_as_expression (unit, indent)
    else
       write (u, "(A)") "<???>"
    end if
  end subroutine assignment_write_statement
    
@ %def assignment_write_statement
@ The mantle (statement contents) are presented in a special way.
<<Expr: assignment: TBP>>=
  procedure :: write_mantle => assignment_write_mantle
<<Expr: procedures>>=
  recursive subroutine assignment_write_mantle (object, unit, indent, refcount)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    logical, intent(in), optional :: refcount
    class(object_t), pointer :: rhs
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "LHS:"
    if (associated (object%id)) then
       if (object%id%is_defined ()) then
          call object%id%write_as_expression (unit, ind+1)
          write (u, *)
       else
          write (u, "('<LHS>')")
       end if
    else
       write (u, *)
    end if
    call write_indent (u, ind)
    write (u, "(A,1x)", advance="no")  "RHS:"
    call object%get_member_ptr (1, rhs)
    if (associated (rhs)) then
       call rhs%write (unit, ind+1)
    else
       write (u, "(A)") "<???>"
    end if
  end subroutine assignment_write_mantle
  
@ %def assignment_write_mantle
@ Extra output for debugging.
<<Expr: assignment: TBP>>=
  procedure :: write_stack => assignment_write_stack
<<Expr: procedures>>=
  subroutine assignment_write_stack (object, unit)
    class(assignment_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    class(item_t), pointer :: item
    u = given_output_unit (unit)
    call object%write (u)
    item => object%item
    do while (associated (item))
       write (u, "('+')", advance="no")
       write (u, "(1x,'LHS: ')", advance="no")
       if (associated (item%lhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%lhs%get_name ())
          if (item%lhs%is_defined ()) then
             call item%lhs%write_as_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, "(2x,'RHS: ')", advance="no")
       if (associated (item%rhs)) then
          write (u, "(A,1x,'=',1x)", advance="no")  char (item%rhs%get_name ())
          if (item%rhs%is_defined ()) then
             call item%rhs%write_expression (u)
          else
             write (u, "('???')", advance="no")
          end if
       else
          write (u, "(1x,'?')", advance="no")
       end if
       write (u, *)
       item => item%next
    end do
  end subroutine assignment_write_stack
  
@ %def assignment_write_stack
@
\subsubsection{Queries}
This query tells whether the object contains an ID subobject.
<<Expr: assignment: TBP>>=
  procedure :: has_id => assignment_has_id
<<Expr: procedures>>=
  pure function assignment_has_id (object) result (flag)
    class(assignment_t), intent(in) :: object
    logical :: flag
    flag = associated (object%id)
  end function assignment_has_id
  
@ %def assignment_has_id
@ Return the pointer to the ID subobject, if any.
<<Expr: assignment: TBP>>=
  procedure :: get_id_ptr => assignment_get_id_ptr
<<Expr: procedures>>=
  subroutine assignment_get_id_ptr (object, id)
    class(assignment_t), intent(in) :: object
    class(object_t), pointer, intent(out) :: id
    id => object%id
  end subroutine assignment_get_id_ptr
  
@ %def assignment_get_id_ptr
@
\subsubsection{Construction}
The [[instantiate]] method must be implemented.
<<Expr: assignment: TBP>>=
  procedure :: instantiate => assignment_instantiate
<<Expr: procedures>>=
  recursive subroutine assignment_instantiate (object, instance)
    class(assignment_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (assignment_t :: instance)
    select type (instance)
    type is (assignment_t)
       call instance%register (object)
       call instance%init (mode = MODE_CONSTANT)
    end select
  end subroutine assignment_instantiate
    
@ %def assignment_instantiate
@
The assignment object doesn't require the attribute list of generic composites.
<<Expr: assignment: TBP>>=
  procedure :: get_code => assignment_get_code
<<Expr: procedures>>=
  function assignment_get_code (object, repository) result (code)
    class(assignment_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_COMPOSITE
    code%natt = 1
    if (present (repository)) then
       code%att(1) = object%get_prototype_index (repository)
    end if
  end function assignment_get_code
  
@ %def assignment_get_code
@ Initialize from code: since the [[instantiate]] method already does
everything, we must not initialize anything here, just override the method.
<<Expr: assignment: TBP>>=
  procedure :: init_from_code => assignment_init_from_code
<<Expr: procedures>>=
  subroutine assignment_init_from_code (object, code)
    class(assignment_t), intent(inout) :: object
    type(code_t), intent(in) :: code
  end subroutine assignment_init_from_code

@ %def assignment_init_from_code
@ Initialize: Set the path for the LHS and import the object pointer for the
RHS.  Alternatively, ignore the part and set the LHS pointer directly.

If [[link]] is true, the [[rhs]] component is interpreted as a reference.  If
false, it is imported, nullifying the original pointer.
<<Expr: assignment: TBP>>=
  generic :: init => assignment_init
  procedure, private :: assignment_init
  procedure :: set_path => assignment_set_path
<<Expr: procedures>>=
  subroutine assignment_init (object, mode)
    class(assignment_t), intent(inout) :: object
    integer, intent(in), optional :: mode
    call object%init (name=var_str ("assignment"), mode = mode, &
         n_members=1, n_arguments=1)
  end subroutine assignment_init
    
  subroutine assignment_set_path (object, lhs_path)
    class(assignment_t), intent(inout) :: object
    type(string_t), dimension(:), intent(in) :: lhs_path
    allocate (id_t :: object%id)
    select type (id => object%id)
    type is (id_t)
       call id%init (lhs_path)
    end select
  end subroutine assignment_set_path
    
@ %def assignment_init
@ %def assignment_set_path
@ Assign ID, LHS pointer, RHS object.
<<Expr: assignment: TBP>>=
  procedure :: import_id => assignment_import_id
  procedure :: set_lhs => assignment_set_lhs
  procedure :: set_rhs => assignment_set_rhs
<<Expr: procedures>>=
  subroutine assignment_import_id (object, id)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: id
    if (associated (object%id)) then
       call object%id%final ()
       deallocate (object%id)
    end if
    object%id => id
    id => null ()
  end subroutine assignment_import_id
    
  subroutine assignment_set_lhs (object, lhs)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(in), pointer :: lhs
    object%lhs => lhs
  end subroutine assignment_set_lhs

  subroutine assignment_set_rhs (object, rhs, link)
    class(assignment_t), intent(inout) :: object
    class(object_t), intent(inout), pointer :: rhs
    logical, intent(in) :: link
    if (link) then
       call object%link_member (1, rhs)
    else
       call object%import_member (1, rhs)
    end if
  end subroutine assignment_set_rhs
    
@ %def assignment_set_lhs
@ %def assignment_set_rhs
@
\subsubsection{Evaluation}
Push a lhs-rhs combination onto the assigment stack.
<<Expr: assignment: TBP>>=
  procedure :: push => assignment_push
<<Expr: procedures>>=
  subroutine assignment_push (object, lhs, rhs)
    class(assignment_t), intent(inout) :: object
    class(value_t), intent(in), pointer :: lhs, rhs
    class(item_t), pointer :: item
    allocate (item)
    item%lhs => lhs
    item%rhs => rhs
    item%next => object%item
    object%item => item
  end subroutine assignment_push
  
@ %def assignment_push
@ Resolve: Find the object that belongs to the LHS, match the RHS signature
against it, and build an assignment-item list for the matching values.  The
algorithm implements duck typing, i.e., the match is successful if all
required items are present at the correct position and with correct value type
in the RHS object tree.

TODO: find should not extend beyond the immediate composite-object context.

We use a pair of iterators, one for the lhs and one for the rhs.  We iterate
over the lhs and track the moves of the iterator.  Whenever we go to a core,
we go to the core of the rhs and match the values, if any.  For a successful
match, the lhs and rhs value pointer pair is pushed onto the assignment item
stack.  When we go to a member, we check if we actually can assign it.  If
yes, we take its name and find the corresponding member on the rhs.  The
member indices need not coincide, then we navigate to the member core(s).
Finally, when the current lhs object is exhausted, we also skip the current
rhs object.

Also, the match fails if any [[lhs]] object has mode ABSTRACT.

TODO: distinguish VARIABLE/CONSTANT

TODO: assignment for primer statements.

Any mismatch immediately aborts the matching procedure.
<<Expr: assignment: TBP>>=
  procedure :: resolve => assignment_resolve
<<Expr: procedures>>=
  subroutine assignment_resolve (object, success)
    class(assignment_t), intent(inout), target :: object
    logical, intent(out) :: success
    type(object_iterator_t) :: it_lhs, it_rhs
    class(object_t), pointer :: lhs, rhs, rhs_context
    class(value_t), pointer :: lval, rval
    type(position_t) :: position
    integer :: part, i
    logical :: mutable, required
    if (object%has_id ()) then
       select type (id => object%id)
       type is (id_t)
          call object%find (id%get_path (), object%lhs)
       end select
    end if
    success = associated (object%lhs)
    if (success) then
       select type (lhs => object%lhs)
       type is (composite_t);  call lhs%check_mode (mutable)
          success = mutable
       end select
    end if
    if (success) then
       lhs => object%lhs
       call object%get_member_ptr (1, rhs)
       call it_lhs%init (lhs)
       call it_rhs%init (rhs)
       ITERATE: do while (it_lhs%is_valid ())
          call it_lhs%get_next_position (position)
          select case (position%part)
          case (POS_NONE)
             call it_lhs%to_context (success);  if (.not. success)  exit ITERATE
             call it_rhs%to_context (success);  if (.not. success)  exit ITERATE
          case (POS_ID)
             call it_lhs%to_id (success);  if (.not. success)  exit ITERATE
             call it_rhs%to_id (success);  if (.not. success)  exit ITERATE
             call it_lhs%get_object (lhs)
             call it_rhs%get_object (rhs)
             select type (lhs)
             class is (id_t)
                call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
                select type (rhs)
                class is (id_t)
                   lval => lhs
                   rval => rhs
                   call object%push (lval, rval)
                 end select
             end select
          case (POS_CORE)
             call it_lhs%to_core (success);  if (.not. success)  exit ITERATE
             call it_rhs%to_core (success);  if (.not. success)  exit ITERATE
             call it_lhs%get_object (lhs)
             call it_rhs%get_object (rhs)
             select type (lhs)
             class is (value_t)
                call lhs%match (rhs, success);  if (.not. success)  exit ITERATE
                select type (rhs)
                class is (value_t)
                   lval => lhs
                   rval => rhs
                   call object%push (lval, rval)
                 end select
             end select
          case (POS_MEMBER)
             call it_lhs%to_member &
                  (position%i, success);  if (.not. success)  exit ITERATE
             call it_lhs%get_object (lhs)
             select type (lhs)
             class is (composite_t)
               call lhs%check_mode (mutable)
               call lhs%check_role (required)
             end select
             if (mutable .or. required) then
                call it_rhs%get_object (rhs_context)
                select type (rhs_context)
                class is (composite_t)
                   call rhs_context%find_member (lhs%get_name (), index=i)
                end select
                if (i > 0) then
                   call it_rhs%to_member &
                        (i, success);  if (.not. success)  exit ITERATE
                else if (required) then
                   success = .false.;  exit ITERATE
                else
                   call it_lhs%to_context &
                        (success);  if (.not. success)  exit ITERATE
                end if
             else
                call it_lhs%to_context &
                     (success);  if (.not. success)  exit ITERATE
             end if
          case default
             call it_lhs%to_context &
                  (success);  if (.not. success)  exit ITERATE
          end select
       end do ITERATE
    end if
  end subroutine assignment_resolve
    
@ %def assignment_resolve
@ Evaluate: Assign values, using the resolved pointers.

We iterate over the assignment list which should contain pointers to the
matching lhs-rhs combinations.
<<Expr: assignment: TBP>>=
  procedure :: evaluate => assignment_evaluate
<<Expr: procedures>>=
  subroutine assignment_evaluate (object)
    class(assignment_t), intent(inout), target :: object
    class(item_t), pointer :: item
    item => object%item
    do while (associated (item))
       call item%lhs%assign (item%rhs)
       item => item%next
    end do
  end subroutine assignment_evaluate
    
@ %def assignment_evaluate
@
\subsubsection{Iterator Support}
Iterate: scan the ID object (the LHS) before the rest.
<<Expr: assignment: TBP>>=
  procedure :: next_position => assignment_next_position
<<Expr: procedures>>=
  subroutine assignment_next_position &
       (object, position, next_object, import_object)
    class(assignment_t), intent(inout), target :: object
    type(position_t), intent(inout) :: position
    class(object_t), intent(out), pointer, optional :: next_object
    class(object_t), intent(inout), pointer, optional :: import_object
    select case (position%part)
    case (POS_HERE)
       if (object%has_id ()) then
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else if (present (import_object)) then
          call object%import_id (import_object)
          position%part = POS_ID
          if (present (next_object))  next_object => object%id
       else
          call object%composite_t%next_position &
               (position, next_object, import_object)
       end if
    case default
       call object%composite_t%next_position &
            (position, next_object, import_object)
    end select
  end subroutine assignment_next_position
  
@ %def assignment_next_position
@
\subsection{Expressions}
An expression is an extended composite.  The first few of the members are
interpreted as arguments.
<<Expr: public>>=
  public :: expression_t
<<Expr: types>>=
  type, extends (composite_t), abstract :: expression_t
     private
     logical :: evaluated = .false.
   contains
   <<Expr: expression: TBP>>
  end type expression_t
  
@ %def expression_t
@
\subsubsection{Queries}
The expression has an expression, unless it is marked [[abstract]].
<<Expr: expression: TBP>>=
  procedure :: is_expression => expression_is_expression
<<Expr: procedures>>=
  pure function expression_is_expression (object) result (flag)
    class(expression_t), intent(in) :: object
    logical :: flag
    call object%check_mode (flag)
  end function expression_is_expression
  
@ %def expression_is_expression
@ Evaluation status.
<<Expr: expression: TBP>>=
  procedure :: is_evaluated => expression_is_evaluated
<<Expr: procedures>>=
  pure function expression_is_evaluated (object) result (flag)
    class(expression_t), intent(in) :: object
    logical :: flag
    flag = object%evaluated
  end function expression_is_evaluated
  
@ %def expression_is_evaluated
@ For expressions, we should look for the name of the object itself, not the
name of the prototype object (which is the prototype of the value).
<<Expr: expression: TBP>>=
  procedure :: get_prototype_index => expression_get_prototype_index
<<Expr: procedures>>=
  function expression_get_prototype_index (object, repository) result (i)
    class(expression_t), intent(in) :: object
    type(repository_t), intent(in) :: repository
    integer :: i
    call repository%find_member (object%get_name (), index=i)
  end function expression_get_prototype_index

@ %def expression_get_prototype_index
@
\subsection{Construction / Decoding}
Expressions don't require the attribute list of generic composites.
<<Expr: expression: TBP>>=
  procedure :: get_code => expression_get_code
<<Expr: procedures>>=
  function expression_get_code (object, repository) result (code)
    class(expression_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_COMPOSITE
    code%natt = 1
    if (present (repository)) then
       code%att(1) = object%get_prototype_index (repository)
    end if
  end function expression_get_code
  
@ %def expression_get_code
@
\subsubsection{Evaluation}
Mark as evaluated / unmark.
<<Expr: expression: TBP>>=
  procedure :: mark_as_evaluated => expression_mark_as_evaluated
  procedure :: reset => expression_reset
<<Expr: procedures>>=
  subroutine expression_mark_as_evaluated (object)
    class(expression_t), intent(inout) :: object
    object%evaluated = .true.
  end subroutine expression_mark_as_evaluated
  
  subroutine expression_reset (object)
    class(expression_t), intent(inout) :: object
    object%evaluated = .false.
  end subroutine expression_reset
  
@ %def expression_mark_as_evaluated
@ %def expression_reset
@
\subsection{Operators}
An operator is an expression with a specific notation.  We have unary and
binary operators.
<<Expr: public>>=
  public :: operator_unary_t
  public :: operator_binary_t
<<Expr: types>>=
  type, extends (expression_t), abstract :: operator_t
     private
   contains
   <<Expr: operator: TBP>>
  end type operator_t
  
  type, extends (operator_t), abstract :: operator_unary_t
     private
   contains
   <<Expr: operator unary: TBP>>
  end type operator_unary_t
  
  type, extends (operator_t), abstract :: operator_binary_t
     private
   contains
   <<Expr: operator binary: TBP>>
  end type operator_binary_t
  
@ %def operator_t
@ %def operator_unary_t
@ %def operator_binary_t
@
\subsubsection{Output}
Unary or binary operators in prefix or infix notation,
respectively.  We pass the current object's priority to the subexpression
output, so there we decide about extra brackets to write.
<<Expr: operator unary: TBP>>=
  procedure :: write_expression => operator_unary_write_expression
<<Expr: operator binary: TBP>>=
  procedure :: write_expression => operator_binary_write_expression
<<Expr: procedures>>=
  recursive subroutine operator_unary_write_expression (object, unit, indent)
    class(operator_unary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority
    u = given_output_unit (unit)
    priority = object%get_priority ()
    write (u, "(A,1x)", advance="no")  char (object%get_name ())
    call object%get_member_ptr (1, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       call arg%write_as_expression &
            (unit, indent, priority=priority, lr=.true.)
    else
       write (u, "(A)", advance="no") "???"
    end if
  end subroutine operator_unary_write_expression
    
  recursive subroutine operator_binary_write_expression (object, unit, indent)
    class(operator_binary_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    class(object_t), pointer :: arg
    integer :: u, priority
    u = given_output_unit (unit)
    priority = object%get_priority ()
    call object%get_member_ptr (1, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       call arg%write_as_expression &
            (unit, indent, priority=priority, lr=.true.)
    else
       write (u, "(A)", advance="no") "???"
    end if
    write (u, "(1x,A,1x)", advance="no")  char (object%get_name ())
    call object%get_member_ptr (2, arg)
    if (associated (arg)) then
       arg => arg%dereference ()
       call arg%write_as_expression &
            (unit, indent, priority=priority, lr=.false.)
    else
       write (u, "(A)", advance="no") "???"
    end if
  end subroutine operator_binary_write_expression
    
@ %def operator_unary_write_expression
@ %def operator_binary_write_expression
@
\subsubsection{Queries}
The written prototype is the prototype of the result.
<<Expr: operator: TBP>>=
  procedure :: get_prototype => operator_get_prototype
<<Expr: procedures>>=
  recursive function operator_get_prototype (object) result (prototype)
    class(operator_t), intent(in) :: object
    type(string_t) :: prototype
    class(object_t), pointer :: core
    call object%get_core_ptr (core)
    if (associated (core)) then
       select type (core)
       class is (composite_t)
          prototype = core%get_prototype ()
       class default
          prototype = core%get_name ()
       end select
    else
       prototype = "operator"
    end if
  end function operator_get_prototype
  
@ %def operator_get_prototype
@ The signature of a operator object contains the [[operator]] attribute,
qualified as either [[unary]] or [[binary]].
<<Expr: operator unary: TBP>>=
  procedure :: get_signature => operator_unary_get_signature
<<Expr: operator binary: TBP>>=
  procedure :: get_signature => operator_binary_get_signature
<<Expr: procedures>>=
  pure function operator_unary_get_signature (object, verbose) &
       result (signature)
    class(operator_unary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|unary|" // signature
    else
       signature = "operator|unary"
    end if
  end function operator_unary_get_signature
       
  pure function operator_binary_get_signature (object, verbose) &
       result (signature)
    class(operator_binary_t), intent(in) :: object
    logical, intent(in), optional :: verbose
    type(string_t) :: signature
    signature = object%composite_t%get_signature ()
    if (signature /= "") then
       signature = "operator|binary|" // signature
    else
       signature = "operator|binary"
    end if
  end function operator_binary_get_signature
       
@ %def operator_get_unary_signature
@ %def operator_binary_get_signature
@
\subsubsection{Construction}
Build object from code: in contrast to composites, we don't need
initialization here since this is achieved by instantiating the prototype.
<<Expr: operator: TBP>>=
  procedure :: init_from_code => operator_init_from_code
<<Expr: procedures>>=
  subroutine operator_init_from_code (object, code)
    class(operator_t), intent(inout) :: object
    type(code_t), intent(in) :: code
  end subroutine operator_init_from_code

@ %def operator_init_from_code
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Logical values}
Logical values are a concrete implementation of [[value_t]].  We also define
logical expressions.

Logical values and expressions allow us to write unit tests for assignment,
expression evaluation, building and decoding.
<<[[object_logical.f90]]>>=
<<File header>>

module object_logical

<<Use strings>>
  use unit_tests
  use format_utils
  use io_units

  use codes
  use object_base
  use object_builder
  use object_expr

<<Standard module head>>

<<Logical: public>>

<<Logical: parameters>>

<<Logical: types>>

<<Logical: interfaces>>

contains

<<Logical: procedures>>

<<Logical: tests>>

end module object_logical
@ %def object_logical
@ 
\subsection{Type definition}
A logical object carries a logical value.  The [[defined]] status also
applies, inherited from [[value_t]].
<<Logical: public>>=
  public :: logical_t
<<Logical: types>>=
  type, extends (value_t) :: logical_t
     private
     logical :: value = .false.
   contains
   <<Logical: logical: TBP>>
  end type logical_t
  
@ %def logical_t
@
\subsubsection{Finalizer}
Finalizer is empty.
<<Logical: logical: TBP>>=
  procedure :: final => logical_final
<<Logical: procedures>>=
  pure subroutine logical_final (object)
    class(logical_t), intent(inout) :: object
  end subroutine logical_final
 
@ %def logical_final
@
\subsubsection{Output}
Display the value.
<<Logical: logical: TBP>>=
  procedure :: write_expression => logical_write_value
  procedure :: write_value => logical_write_value
<<Logical: procedures>>=
  subroutine logical_write_value (object, unit, indent)
    class(logical_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: indent
    integer :: u
    u = given_output_unit (unit)
    if (object%value) then
       write (u, "(A)", advance="no")  "true"
    else
       write (u, "(A)", advance="no")  "false"
    end if
  end subroutine logical_write_value
       
@ %def logical_write_expression
@ %def logical_write_value
@
\subsubsection{Queries}
The name of atomic objects is the type, here [[logical]].
<<Logical: logical: TBP>>=
  procedure :: get_name => logical_get_name
<<Logical: procedures>>=
  pure function logical_get_name (object) result (name)
    class(logical_t), intent(in) :: object
    type(string_t) :: name
    name = "logical"
  end function logical_get_name
  
@ %def logical_get_name
@
\subsubsection{Construction}
For a new tag instance, nothing needs to be copied.
<<Logical: logical: TBP>>=
  procedure :: instantiate => logical_instantiate
<<Logical: procedures>>=
  subroutine logical_instantiate (object, instance)
    class(logical_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    allocate (logical_t :: instance)
  end subroutine logical_instantiate
    
@ %def logical_instantiate
@ Logical value: the code includes the value.
<<Logical: logical: TBP>>=
  procedure :: get_code => logical_get_code
<<Logical: procedures>>=
  function logical_get_code (object, repository) result (code)
    class(logical_t), intent(in), target :: object
    type(repository_t), intent(in), optional :: repository
    type(code_t) :: code
    code%cat = CAT_VALUE
    if (object%is_defined ()) then
       allocate (val_logical_t :: code%val)
       select type (val => code%val)
       type is (val_logical_t)
          call val%init (1)
          val%x(1) = object%value
       end select
    end if
  end function logical_get_code
  
@ %def logical_get_code
@ Initialize the value, given a code object.
<<Logical: logical: TBP>>=
  procedure :: init_from_code => logical_init_from_code
<<Logical: procedures>>=
  subroutine logical_init_from_code (object, code)
    class(logical_t), intent(out) :: object
    type(code_t), intent(in) :: code
    if (allocated (code%val)) then
       select type (val => code%val)
       type is (val_logical_t)
          if (val%get_nval () > 0)  call object%init (val%x(1))
       end select
    end if
  end subroutine logical_init_from_code
    
@ %def logical_init_from_code
@ Initializer: we may define or undefine the value.
<<Logical: logical: TBP>>=
  procedure :: init => logical_init
<<Logical: procedures>>=
  pure subroutine logical_init (object, value)
    class(logical_t), intent(inout) :: object
    logical, intent(in), optional :: value
    if (present (value)) then
       object%value = value
       call object%set_defined (.true.)
    else
       call object%set_defined (.false.)
    end if
  end subroutine logical_init
 
@ %def logical_init
@
\subsubsection{Assignment}
Copy the value.  LHS and RHS must both be logical.
<<Logical: logical: TBP>>=
  procedure :: match_value => logical_match_value
  procedure :: assign_value => logical_assign_value
<<Logical: procedures>>=
  subroutine logical_match_value (object, source, success)
    class(logical_t), intent(in) :: object
    class(value_t), intent(in) :: source
    logical, intent(out) :: success
    select type (source)
    class is (logical_t)
       success = .true.
    class default
       success = .false.
    end select
  end subroutine logical_match_value
       
  subroutine logical_assign_value (object, source)
    class(logical_t), intent(inout) :: object
    class(value_t), intent(in) :: source
    select type (source)
    class is (logical_t)
       object%value = source%value
    end select
  end subroutine logical_assign_value
       
@ %def logical_match_value
@ %def logical_assign_value
@ 
\subsection{Operators: not}
The [[not]] operator is a unary operator.  Both argument and result are of
type [[logical_t]].  We define pointer shortcuts for both argument and
result.
<<Logical: public>>=
  public :: not_t
<<Logical: types>>=
  type, extends (operator_unary_t) :: not_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_t), pointer :: arg => null ()
   contains
   <<Logical: not: TBP>>
  end type not_t
  
@ %def not_t
@
\subsubsection{Queries}
Priority value.
<<Logical: not: TBP>>=
  procedure :: get_priority => not_get_priority
<<Logical: procedures>>=
  pure function not_get_priority (object) result (priority)
    class(not_t), intent(in) :: object
    integer :: priority
    priority = PRIO_NOT
  end function not_get_priority
  
@ %def not_get_priority
@
\subsubsection{Construction}
Instantiate: we have to initialize, so the core and argument types are fixed.
<<Logical: not: TBP>>=
  procedure :: instantiate => not_instantiate
<<Logical: procedures>>=
  subroutine not_instantiate (object, instance)
    class(not_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (not_t :: instance)
    select type (instance)
    class is (not_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype)
    end select
  end subroutine not_instantiate
  
@ %def not_instantiate
@ Initialize: one argument, no extra members.  We need the [[logical]]
prototype for initializing core and argument.  If this is not an instance, we
also declare the prototype for the object itself.
<<Logical: not: TBP>>=
  generic :: init => not_init
  procedure, private :: not_init
<<Logical: procedures>>=
  subroutine not_init (object, prototype)
    class(not_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    class(object_t), pointer :: value, core, member
    call object%composite_t%init &
         (var_str ("not"), mode = MODE_CONSTANT, n_members = 1, &
         n_arguments = 1)
    call prototype%instantiate (member)
    select type (member)
    type is (composite_t)
       call member%init (mode = MODE_VARIABLE, name = var_str ("arg"))
    end select
    call object%import_member (1, member)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine not_init
  
@ %def not_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical.
<<Logical: not: TBP>>=
  procedure :: resolve => not_resolve
<<Logical: procedures>>=
  recursive subroutine not_resolve (object, success)
    class(not_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    success = .false.
    object%res => null ()
    object%arg => null ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (object%has_value ()) then
       call object%get_member_ptr (1, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             object%arg => core
             success = .true.
          end select
       end select
    end if
  end subroutine not_resolve
  
@ %def not_resolve
@ Evaluate the operation.
<<Logical: not: TBP>>=
  procedure :: evaluate => not_evaluate
<<Logical: procedures>>=
  recursive subroutine not_evaluate (object)
    class(not_t), intent(inout), target :: object
    call object%evaluate_arguments ()
    if (object%arg%is_defined ()) then
       call object%res%init (.not. object%arg%value)
    else
       call object%res%init ()
    end if
    call object%mark_as_evaluated ()
  end subroutine not_evaluate
  
@ %def not_evaluate
@ 
\subsection{Operators: and, or}
The [[and]] and [[or]] operators are binary operators.  Both arguments and
result are of type [[logical_t]].  We define pointer shortcuts for both
arguments and result.
<<Logical: types>>=
  type, extends (operator_binary_t), abstract :: logical_binary_t
     private
     type(logical_t), pointer :: res => null ()
     type(logical_t), pointer :: arg1 => null ()
     type(logical_t), pointer :: arg2 => null ()
   contains
   <<Logical: logical binary: TBP>>
  end type logical_binary_t

@ %def logical_binary_t
<<Logical: public>>=
  public :: and_t
  public :: or_t
<<Logical: types>>=
  type, extends (logical_binary_t) :: and_t
     private
   contains
   <<Logical: and: TBP>>
  end type and_t
  
  type, extends (logical_binary_t) :: or_t
     private
   contains
   <<Logical: or: TBP>>
  end type or_t
  
@ %def and_t
@ %def or_t
@
\subsubsection{Queries}
Priority value.
<<Logical: and: TBP>>=
  procedure :: get_priority => and_get_priority
<<Logical: or: TBP>>=
  procedure :: get_priority => or_get_priority
<<Logical: procedures>>=
  pure function and_get_priority (object) result (priority)
    class(and_t), intent(in) :: object
    integer :: priority
    priority = PRIO_AND
  end function and_get_priority
  
  pure function or_get_priority (object) result (priority)
    class(or_t), intent(in) :: object
    integer :: priority
    priority = PRIO_OR
  end function or_get_priority
  
@ %def and_get_priority
@ %def or_get_priority
@
\subsubsection{Construction}
Instantiate: initialize using the generic logical binary initializer.
<<Logical: and: TBP>>=
  procedure :: instantiate => and_instantiate
<<Logical: or: TBP>>=
  procedure :: instantiate => or_instantiate
<<Logical: procedures>>=
  subroutine and_instantiate (object, instance)
    class(and_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (and_t :: instance)
    select type (instance)
    class is (and_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype)
    end select
  end subroutine and_instantiate
  
  subroutine or_instantiate (object, instance)
    class(or_t), intent(inout), target :: object
    class(object_t), intent(out), pointer :: instance
    class(composite_t), pointer :: prototype
    allocate (or_t :: instance)
    select type (instance)
    class is (or_t)
       call object%get_prototype_ptr (prototype)
       call instance%init (prototype)
    end select
  end subroutine or_instantiate
  
@ %def and_instantiate
@ %def or_instantiate
@ Initialize: two arguments, no extra members.  We need the [[logical]]
prototype for initializing core and arguments.
<<Logical: procedures>>=
  subroutine logical_binary_init (object, prototype, name)
    class(logical_binary_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    type(string_t), intent(in), optional :: name
    class(object_t), pointer :: value, core, member
    call object%init (name, mode = MODE_CONSTANT, n_members = 2, &
         n_arguments = 2)
    call prototype%instantiate (member)
    select type (member)
    type is (composite_t)
       call member%init (mode = MODE_VARIABLE, name = var_str ("arg1"))
    end select
    call object%import_member (1, member)
    call prototype%instantiate (member)
    select type (member)
    type is (composite_t)
       call member%init (mode = MODE_VARIABLE, name = var_str ("arg2"))
    end select
    call object%import_member (2, member)
    select type (prototype)
    class is (composite_t)
       call prototype%get_core_ptr (value)
       call object%set_default_prototype (prototype)
    end select
    call value%instantiate (core)
    call object%import_core (core)
  end subroutine logical_binary_init
  
@ %def logical_binary_init 
@ Specific initializers.
<<Logical: and: TBP>>=
  generic :: init => and_init
  procedure, private :: and_init
<<Logical: or: TBP>>=
  generic :: init => or_init
  procedure, private :: or_init
<<Logical: procedures>>=
  subroutine and_init (object, prototype)
    class(and_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    call logical_binary_init (object, prototype, var_str ("and"))
  end subroutine and_init
  
  subroutine or_init (object, prototype)
    class(or_t), intent(inout) :: object
    class(object_t), intent(inout), target :: prototype
    call logical_binary_init (object, prototype, var_str ("or"))
  end subroutine or_init
  
@ %def and_init 
@ %def or_init 
@
\subsubsection{Evaluation}
Resolve: check argument and assign pointer shortcuts.  The argument must be
of type logical, otherwise the routine is universal for binary operators.
<<Logical: logical binary: TBP>>=
  procedure :: resolve => logical_binary_resolve
<<Logical: procedures>>=
  recursive subroutine logical_binary_resolve (object, success)
    class(logical_binary_t), intent(inout), target :: object
    logical, intent(out) :: success
    class(object_t), pointer :: arg, core
    success = .false.
    object%res => null ()
    object%arg1 => null ()
    object%arg2 => null ()
    call object%get_core_ptr (core)
    call core%resolve (success);  if (.not. success)  return
    select type (core)
    type is (logical_t)
       object%res => core
    class default
       return
    end select
    if (object%has_value ()) then
       call object%get_member_ptr (1, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             object%arg1 => core
             success = .true.
          end select
       end select
       if (.not. success)  return
       call object%get_member_ptr (2, arg)
       call arg%resolve (success);  if (.not. success)  return
       select type (arg)
       class is (wrapper_t)
          call arg%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             object%arg2 => core
             success = .true.
          end select
       end select
    end if
  end subroutine logical_binary_resolve
  
@ %def logical_binary_resolve
@ Evaluate the operation.
<<Logical: and: TBP>>=
  procedure :: evaluate => and_evaluate
<<Logical: or: TBP>>=
  procedure :: evaluate => or_evaluate
<<Logical: procedures>>=
  recursive subroutine and_evaluate (object)
    class(and_t), intent(inout), target :: object
    call object%evaluate_arguments ()
    if (object%arg1%is_defined () .and. object%arg2%is_defined ()) then
       call object%res%init (object%arg1%value .and. object%arg2%value)
    else
       call object%res%init ()
    end if
    call object%mark_as_evaluated ()
  end subroutine and_evaluate
  
  recursive subroutine or_evaluate (object)
    class(or_t), intent(inout), target :: object
    call object%evaluate_arguments ()
    if (object%arg1%is_defined () .and. object%arg2%is_defined ()) then
       call object%res%init (object%arg1%value .or. object%arg2%value)
    else
       call object%res%init ()
    end if
    call object%mark_as_evaluated ()
  end subroutine or_evaluate
  
@ %def and_evaluate
@ %def or_evaluate
@ 
\subsection{Unit tests}
<<Logical: public>>=
  public :: object_logical_test
<<Logical: procedures>>=
  subroutine object_logical_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Logical: execute tests>>  
  end subroutine object_logical_test
  
@ %def object_logical_test 
@
\subsubsection{Values}
Create logical objects.
<<Logical: execute tests>>=
  call test (object_logical_1, "object_logical_1", &
       "values", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_1 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: bare_logical, core
    class(object_t), pointer :: prototype, true, false, undef

    write (u, "(A)")  "* Test output: object_logical_1"
    write (u, "(A)")  "*   Purpose: construct logical value objects"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Logical objects: prototype"

    allocate (logical_t :: bare_logical)
    
    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (name = var_str ("logical"))
       call prototype%import_core (bare_logical)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Logical objects: true, false, undefined"

    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value=.false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (undef)
    select type (undef)
    type is (composite_t)
       call undef%init (mode = MODE_CONSTANT, name = var_str ("undef"))
       allocate (logical_t :: core)
       call undef%import_core (core)
    end select

    write (u, "(A)")
    call prototype%write (u, refcount=.true.)

    write (u, "(A)")
    call true%write (u, refcount=.true.)
    call false%write (u, refcount=.true.)
    call undef%write (u, refcount=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (undef)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)
    call remove_object (bare_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_1"
    
    end subroutine object_logical_1

@ %def object_logical_1
@ 
\subsubsection{Atomic assignment}
Perform assignments of elementary logicals.
<<Logical: execute tests>>=
  call test (object_logical_2, "object_logical_2", &
       "assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_2 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core, rhs
    class(object_t), pointer :: prototype, true, false, lval1, lval2, lval3
    type(assignment_t) :: asg
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_2"
    write (u, "(A)")  "*   Purpose: assignments"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Create objects"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .true.)
       end select
       call true%import_core (core)
    end select

    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .false.)
       end select
       call false%import_core (core)
    end select

    call prototype%instantiate (lval1)
    select type (lval1)
    type is (composite_t)
       call lval1%init (mode = MODE_VARIABLE, name = var_str ("lval1"))
    end select
    
    call prototype%instantiate (lval2)
    select type (lval2)
    type is (composite_t)
       call lval2%init (mode = MODE_VARIABLE, name = var_str ("lval2"))
    end select
    
    call prototype%instantiate (lval3)
    select type (lval3)
    type is (composite_t)
       call lval3%init (mode = MODE_VARIABLE, name = var_str ("lval3"))
    end select
    
    write (u, "(A)")
    call true%write (u)
    call false%write (u)

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval1 = true"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval1)
    call asg%set_rhs (true, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = false"
  
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (false, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()
    
    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval1"
  
    rhs => lval1
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)
  
    write (u, "(A)")
    write (u, "(A)")  "* lval2 = lval3"
  
    rhs => lval3
    call asg%init (mode=MODE_CONSTANT)
    call asg%set_lhs (lval2)
    call asg%set_rhs (rhs, link=.true.)
    call asg%resolve (success)

    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success
    if (success) then
       call asg%evaluate ()
    end if
    call asg%final ()

    write (u, "(A)")
    call lval1%write_as_declaration (u)
    call lval2%write_as_declaration (u)
    call lval3%write_as_declaration (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (lval1)
    call remove_object (lval2)
    call remove_object (lval3)
    call remove_object (true)
    call remove_object (false)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "true allocated =", associated (true)
    write (u, "(A,1x,L1)")  "false allocated =", associated (false)
    write (u, "(A,1x,L1)")  "lval1 allocated =", associated (lval1)
    write (u, "(A,1x,L1)")  "lval2 allocated =", associated (lval2)
    write (u, "(A,1x,L1)")  "lval3 allocated =", associated (lval3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_2"
    
    end subroutine object_logical_2

@ %def object_logical_2
@ 
\subsubsection{Composite assignment}
Perform assignments of composites with elementary logical core.
<<Logical: execute tests>>=
  call test (object_logical_3, "object_logical_3", &
       "composite assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_3 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: prototype, proto2, main, val, core, rhs, asg
    type(object_iterator_t) :: it
    class(object_t), pointer :: object
    type(code_t) :: code
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_3"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("val"))
    end select
    
    call setup_assignment ()
    write (u, "(A)")
    write (u, "(A)")  "* Assignment object"
    write (u, "(A)")
    call asg%write (u)

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Main object"
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%construct (success)
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Check name mismatch"

    call remove_object (main)

    call prototype%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (mode=MODE_CONSTANT, name = var_str ("foo"))
    end select
    
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%construct (success)
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Check mode/type mismatch"

    call remove_object (main)

    allocate (composite_t :: proto2)
    select type (proto2)
    type is (composite_t)
       call proto2%init (var_str ("tag"))
       allocate (tag_t :: core)
       call proto2%import_core (core)
    end select

    call proto2%instantiate (val)
    select type (val)
    type is (composite_t)
       call val%init (name = var_str ("val"))
    end select
   
    call setup_assignment ()

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    select type (main)
    type is (composite_t)
       call main%construct (success)
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (proto2)
    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_3"
    
    contains
      
      subroutine setup_assignment
        allocate (assignment_t :: asg)
        select type (asg)
        type is (assignment_t)
           call prototype%instantiate (rhs)
           select type (rhs)
           type is (composite_t)
              call rhs%init (mode=MODE_CONSTANT, name=var_str ("rhs"))
              call rhs%get_core_ptr (core)
              select type (core)
              type is (logical_t)
                 call core%init (value = .true.)
              end select
           end select
           call asg%init (MODE=MODE_CONSTANT)
           call asg%set_path ([var_str ("val")])
           call asg%set_rhs (rhs=rhs, link=.false.)
        end select
      end subroutine setup_assignment

    end subroutine object_logical_3

@ %def object_logical_3
@ 
\subsubsection{Nested composite assignment}
Perform assignments of composites with multiple and composite members.
<<Logical: execute tests>>=
  call test (object_logical_4, "object_logical_4", &
       "nontrivial assignment", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_4 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: pro_logical, pro_tag
    class(object_t), pointer :: main, foo, bar, a, core, member, rhs, asg, ptr
    type(object_iterator_t) :: it
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_4"
    write (u, "(A)")  "*   Purpose: nested composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare composite object with primer"

    allocate (composite_t :: pro_tag)
    select type (pro_tag)
    type is (composite_t)
       call pro_tag%init (var_str ("tag"))
       allocate (tag_t :: core)
       call pro_tag%import_core (core)
    end select

    allocate (composite_t :: pro_logical)
    select type (pro_logical)
    type is (composite_t)
       call pro_logical%init (var_str ("logical"))
       allocate (logical_t :: core)
       call pro_logical%import_core (core)
    end select

    call pro_logical%instantiate (bar)
    select type (bar)
    type is (composite_t)
       call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
    end select

    call pro_tag%instantiate (a)
    select type (a)
    type is (composite_t)
       call a%init (name = var_str ("a"))
    end select

    call pro_logical%instantiate (foo)
    select type (foo)
    type is (composite_t)
       call foo%init (mode=MODE_CONSTANT, name = var_str ("foo"), &
            n_members=2)
       call foo%import_member (1, a)
       call foo%import_member (2, bar)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t)
          call core%init (value = .true.)
       end select

       call pro_logical%instantiate (bar)
       select type (bar)
       type is (composite_t)
          call bar%init (mode=MODE_CONSTANT, name = var_str ("bar"))
          call bar%get_core_ptr (core)
          select type (core)
          type is (logical_t);  call core%init (value = .false.)
          end select
       end select

       call pro_tag%instantiate (a)
       select type (a)
       type is (composite_t)
          call a%init (name = var_str ("a"))
       end select

       allocate (composite_t :: rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (mode=MODE_CONSTANT, name = var_str ("rhs"), &
               n_members = 2)
          allocate (logical_t :: core)
          select type (core)
          type is (logical_t);  call core%init (value = .true.)
          end select
          call rhs%import_core (core)
          call rhs%import_member (1, bar)
          call rhs%import_member (2, a)
       end select

       call asg%init (mode=MODE_CONSTANT)
       call asg%set_path ([var_str ("foo")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, foo)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize: evaluate primer"
    
    select type (main)
    type is (composite_t)
       call main%construct (success)
    end select
    write (u, "(A)")
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Iterate through main"
    write (u, "(A)")      

    call it%init (main)
    do while (it%is_valid ())
       call it%get_object (ptr)
       call ptr%write (u, core=.false., mantle=.false.)
       call it%write (u)
       write (u, *)
       call it%advance ()
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call remove_object (pro_tag)
    call remove_object (pro_logical)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_4"
    
    end subroutine object_logical_4

@ %def object_logical_4
@ 
\subsubsection{Operators: not}
Build and evaluate simple logical expressions.  We first introduce shortcuts
for creating logical constants:
<<Logical: tests>>=
  subroutine create_true (true, prototype)
    class(object_t), pointer, intent(out) :: true
    class(object_t), target, intent(inout) :: prototype
    class(object_t), pointer :: core
    call prototype%instantiate (true)
    select type (true)
    type is (composite_t)
       call true%init (mode = MODE_CONSTANT, name = var_str ("true"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .true.)
       end select
       call true%import_core (core)
    end select
  end subroutine create_true
    
  subroutine create_false (false, prototype)
    class(object_t), pointer, intent(out) :: false
    class(object_t), target, intent(inout) :: prototype
    class(object_t), pointer :: core
    call prototype%instantiate (false)
    select type (false)
    type is (composite_t)
       call false%init (mode = MODE_CONSTANT, name = var_str ("false"))
       allocate (logical_t :: core)
       select type (core)
       type is (logical_t);  call core%init (value = .false.)
       end select
       call false%import_core (core)
    end select
  end subroutine create_false

  subroutine create_undef (undef, prototype)
    class(object_t), pointer, intent(out) :: undef
    class(object_t), target, intent(inout) :: prototype
    class(object_t), pointer :: core
    call prototype%instantiate (undef)
    select type (undef)
    type is (composite_t)
       call undef%init (mode = MODE_CONSTANT, name = var_str ("undef"))
       allocate (logical_t :: core)
       call undef%import_core (core)
    end select
  end subroutine create_undef

@ %def create_true    
@ %def create_false    
@ %def create_undef    
@ Now the test for [[not]].
<<Logical: execute tests>>=
  call test (object_logical_5, "object_logical_5", &
       "operator: not", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_5 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype, true, false, undef
    class(object_t), pointer :: not, expr1, expr2, expr3
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_5"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: not"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    write (u, "(A)")
    call not%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"

    call create_true (true, prototype)
    call create_false (false, prototype)
    call create_undef (undef, prototype)
    
    write (u, "(A)")
    
    call not%instantiate (expr1)
    select type (expr1)
    class is (composite_t)
       call expr1%import_member (1, true)
    end select
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    select type (expr2)
    class is (composite_t)
       call expr2%import_member (1, false)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr3)
    select type (expr3)
    class is (composite_t)
       call expr3%import_member (1, undef)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u);  write (u, *)
    call expr2%write_as_expression (u);  write (u, *)
    call expr3%write_as_expression (u);  write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A,1x,L1)")  "prototype allocated =", associated (prototype)
    write (u, "(A,1x,L1)")  "not allocated =", associated (not)
    write (u, "(A,1x,L1)")  "true allocated =", associated (true)
    write (u, "(A,1x,L1)")  "false allocated =", associated (false)
    write (u, "(A,1x,L1)")  "undef allocated =", associated (undef)
    write (u, "(A,1x,L1)")  "expr1 allocated =", associated (expr1)
    write (u, "(A,1x,L1)")  "expr2 allocated =", associated (expr2)
    write (u, "(A,1x,L1)")  "expr3 allocated =", associated (expr3)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_5"
    
    end subroutine object_logical_5

@ %def object_logical_5
@ 
\subsubsection{Operators: and}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_6, "object_logical_6", &
       "operator: and", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_6 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype, true, false, undef
    class(object_t), pointer :: and
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_6"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: and"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    write (u, "(A)")
    call and%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    select type (expr1)
    class is (composite_t)
       call create_true (true, prototype)
       call expr1%import_member (1, true)
       call create_true (true, prototype)
       call expr1%import_member (2, true)
    end select
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr2)
    select type (expr2)
    class is (composite_t)
       call create_true (true, prototype)
       call expr2%import_member (1, true)
       call create_false (false, prototype)
       call expr2%import_member (2, false)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    select type (expr3)
    class is (composite_t)
       call create_false (false, prototype)
       call expr3%import_member (1, false)
       call create_true (true, prototype)
       call expr3%import_member (2, true)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    select type (expr4)
    class is (composite_t)
       call create_false (false, prototype)
       call expr4%import_member (1, false)
       call create_false (false, prototype)
       call expr4%import_member (2, false)
    end select
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    select type (expr5)
    class is (composite_t)
       call create_undef (undef, prototype)
       call expr5%import_member (1, undef)
       call create_true (true, prototype)
       call expr5%import_member (2, true)
    end select
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr6)
    select type (expr6)
    class is (composite_t)
       call create_false (false, prototype)
       call expr6%import_member (1, false)
       call create_undef (undef, prototype)
       call expr6%import_member (2, undef)
    end select
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr7)
    select type (expr7)
    class is (composite_t)
       call create_undef (undef, prototype)
       call expr7%import_member (1, undef)
       call create_undef (undef, prototype)
       call expr7%import_member (2, undef)
    end select
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (and)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_6"
    
    end subroutine object_logical_6

@ %def object_logical_6
@ 
\subsubsection{Operators: or}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_7, "object_logical_7", &
       "operator: or", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_7 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype, true, false, undef
    class(object_t), pointer :: or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5, expr6, expr7
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_7"
    write (u, "(A)")  "*   Purpose: check logical operators"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototype: or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    call or%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call or%instantiate (expr1)
    select type (expr1)
    class is (composite_t)
       call create_true (true, prototype)
       call expr1%import_member (1, true)
       call create_true (true, prototype)
       call expr1%import_member (2, true)
    end select
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr2)
    select type (expr2)
    class is (composite_t)
       call create_true (true, prototype)
       call expr2%import_member (1, true)
       call create_false (false, prototype)
       call expr2%import_member (2, false)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr3)
    select type (expr3)
    class is (composite_t)
       call create_false (false, prototype)
       call expr3%import_member (1, false)
       call create_true (true, prototype)
       call expr3%import_member (2, true)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr4)
    select type (expr4)
    class is (composite_t)
       call create_false (false, prototype)
       call expr4%import_member (1, false)
       call create_false (false, prototype)
       call expr4%import_member (2, false)
    end select
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr5)
    select type (expr5)
    class is (composite_t)
       call create_undef (undef, prototype)
       call expr5%import_member (1, undef)
       call create_true (true, prototype)
       call expr5%import_member (2, true)
    end select
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr6)
    select type (expr6)
    class is (composite_t)
       call create_false (false, prototype)
       call expr6%import_member (1, false)
       call create_undef (undef, prototype)
       call expr6%import_member (2, undef)
    end select
    call expr6%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call or%instantiate (expr7)
    select type (expr7)
    class is (composite_t)
       call create_undef (undef, prototype)
       call expr7%import_member (1, undef)
       call create_undef (undef, prototype)
       call expr7%import_member (2, undef)
    end select
    call expr7%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)
    call expr6%write_as_expression (u)
    write (u, *)
    call expr7%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()
    call expr6%evaluate ()
    call expr7%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    call expr2%write (u)
    call expr3%write (u)
    call expr4%write (u)
    call expr5%write (u)
    call expr6%write (u)
    call expr7%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)
    call expr6%write_as_value (u)
    write (u, *)
    call expr7%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (expr6)
    call remove_object (expr7)
    call remove_object (or)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_7"
    
    end subroutine object_logical_7

@ %def object_logical_7
@ 
\subsubsection{Operators: or}
Build and evaluate simple logical expressions.
<<Logical: execute tests>>=
  call test (object_logical_8, "object_logical_8", &
       "nested expressions", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_8 (u)
    integer, intent(in) :: u
    class(object_t), pointer :: core
    class(object_t), pointer :: prototype, true, false, undef
    class(object_t), pointer :: not, and, or
    class(object_t), pointer :: expr1, expr2, expr3, expr4, expr5
    class(object_t), pointer :: arg1, arg2
    logical :: success

    write (u, "(A)")  "* Test output: object_logical_8"
    write (u, "(A)")  "*   Purpose: check nested logical expressions"
    write (u, "(A)")      
    
    write (u, "(A)") "* Create expression prototypes: not, and, or"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select
    
    allocate (not_t :: not)
    select type (not)
    type is (not_t)
       call not%init (prototype)
    end select
    
    allocate (and_t :: and)
    select type (and)
    type is (and_t)
       call and%init (prototype)
    end select
    
    allocate (or_t :: or)
    select type (or)
    type is (or_t)
       call or%init (prototype)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Create expressions"
    write (u, "(A)")
    
    call and%instantiate (expr1)
    select type (expr1)
    class is (composite_t)
       call not%instantiate (arg1)
       select type (arg1)
       class is (composite_t)
          call create_true (true, prototype)
          call arg1%import_member (1, true)
       end select
       call expr1%import_member (1, arg1)
       call create_false (false, prototype)
       call expr1%import_member (2, false)
    end select
    call expr1%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call not%instantiate (expr2)
    select type (expr2)
    class is (composite_t)
       call and%instantiate (arg1)
       select type (arg1)
       class is (composite_t)
          call create_true (true, prototype)
          call arg1%import_member (1, true)
          call create_false (false, prototype)
          call arg1%import_member (2, false)
       end select
       call expr2%import_member (1, arg1)
    end select
    call expr2%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr3)
    select type (expr3)
    class is (composite_t)
       call create_true (true, prototype)
       call expr3%import_member (1, true)
       call or%instantiate (arg2)
       select type (arg2)
       class is (composite_t)
          call create_false (false, prototype)
          call arg2%import_member (1, false)
          call create_true (true, prototype)
          call arg2%import_member (2, true)
       end select
       call expr3%import_member (2, arg2)
    end select
    call expr3%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr4)
    select type (expr4)
    class is (composite_t)
       call create_true (true, prototype)
       call expr4%import_member (1, true)
       call and%instantiate (arg2)
       select type (arg2)
       class is (composite_t)
          call create_false (false, prototype)
          call arg2%import_member (1, false)
          call create_true (true, prototype)
          call arg2%import_member (2, true)
       end select
       call expr4%import_member (2, arg2)
    end select
    call expr4%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    call and%instantiate (expr5)
    select type (expr5)
    class is (composite_t)
       call and%instantiate (arg1)
       select type (arg1)
       class is (composite_t)
          call create_true (true, prototype)
          call arg1%import_member (1, true)
          call create_false (false, prototype)
          call arg1%import_member (2, false)
       end select
       call expr5%import_member (1, arg1)
       call create_true (true, prototype)
       call expr5%import_member (2, true)
    end select
    call expr5%resolve (success)
    write (u, "(A,L1)")  "success = ", success

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_expression (u)
    write (u, *)
    call expr2%write_as_expression (u)
    write (u, *)
    call expr3%write_as_expression (u)
    write (u, *)
    call expr4%write_as_expression (u)
    write (u, *)
    call expr5%write_as_expression (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
  
    call expr1%evaluate ()
    call expr2%evaluate ()
    call expr3%evaluate ()
    call expr4%evaluate ()
    call expr5%evaluate ()

    write (u, "(A)")
    call expr1%write (u)
    write (u, "(A)")
    call expr2%write (u)
    write (u, "(A)")
    call expr3%write (u)
    write (u, "(A)")
    call expr4%write (u)
    write (u, "(A)")
    call expr5%write (u)

    write (u, "(A)")
    call expr1%write_as_value (u)
    write (u, *)
    call expr2%write_as_value (u)
    write (u, *)
    call expr3%write_as_value (u)
    write (u, *)
    call expr4%write_as_value (u)
    write (u, *)
    call expr5%write_as_value (u)
    write (u, *)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (expr1)
    call remove_object (expr2)
    call remove_object (expr3)
    call remove_object (expr4)
    call remove_object (expr5)
    call remove_object (and)
    call remove_object (or)
    call remove_object (not)
    call remove_object (prototype)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_8"
    
    end subroutine object_logical_8

@ %def object_logical_8
@ 
\subsubsection{Build assignment}
Generate code for an assignment object and reconstruct the object from code.
<<Logical: execute tests>>=
  call test (object_logical_9, "object_logical_9", &
       "build assignment from code", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_9 (u)
    integer, intent(in) :: u
    type(repository_t), allocatable :: repository
    type(object_builder_t) :: builder
    class(object_t), pointer :: prototype, main, val, core, rhs, asg
    type(code_t) :: code
    logical :: success
    integer :: iostat
    integer :: utmp

    write (u, "(A)")  "* Test output: object_logical_9"
    write (u, "(A)")  "*   Purpose: simple composite assignment"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: prototype)
    select type (prototype)
    type is (composite_t)
       call prototype%init (var_str ("logical"))
       allocate (logical_t :: core)
       call prototype%import_core (core)
    end select

    allocate (assignment_t :: asg)
    select type (asg)
    type is (assignment_t)
       call asg%init ()
    end select

    allocate (repository)
    call repository%init (name = var_str ("repository"), n_members = 2)
    call repository%import_member (1, prototype)
    call repository%import_member (2, asg)


    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Prepare composite object with primer"

    call repository%spawn (var_str ("logical"), val)
    select type (val)
    class is (composite_t)
       call val%init (name = var_str ("val"), mode = MODE_CONSTANT)
    end select
    
    call repository%spawn (var_str ("assignment"), asg)
    select type (asg)
    type is (assignment_t)
       call repository%spawn (var_str ("logical"), rhs)
       select type (rhs)
       type is (composite_t)
          call rhs%init (name = var_str ("rhs"), mode = MODE_CONSTANT)
          call rhs%get_core_ptr (core)
          select type (core)
          type is (logical_t)
             call core%init (value = .true.)
          end select
       end select
       call asg%set_path ([var_str ("val")])
       call asg%set_rhs (rhs=rhs, link=.false.)
    end select

    allocate (composite_t :: main)
    select type (main)
    type is (composite_t)
       call main%init (name = var_str ("main"), n_members = 1, n_primers = 1)
       call main%import_member (1, val)
       call main%import_primer (1, asg)
    end select

    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Code"

    call builder%import_repository (repository)

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")
    call builder%init_object (main)
    do
       call builder%decode (code, success)
       if (.not. success)  exit
       call code%write (u, verbose=.true.)
       call code%write (utmp)
    end do
    rewind (utmp)

    write (u, "(A)")
    write (u, "(A)")  "* Reconstruct object"

    call remove_object (main)

    call builder%init_empty ()
    do
       call code%read (utmp, iostat=iostat)
       if (iostat /= 0)  exit
       call builder%build (code, success)
       if (.not. success)  exit
    end do
    call builder%export (main)

    close (utmp)
    
    write (u, "(A)")
    call main%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (prototype)
    call remove_object (main)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_9"
    
  end subroutine object_logical_9

@ %def object_logical_9
@ 
\subsubsection{Code: not}
Construct logical expressions from bytecode.
<<Logical: execute tests>>=
  call test (object_logical_10, "object_logical_10", &
       "build expressions from code", &
       u, results)
<<Logical: tests>>=  
  subroutine object_logical_10 (u)
    integer, intent(in) :: u
    type(repository_t) :: repository
    class(object_t), pointer :: p_log, p_not, p_and, p_or, core, main, object
    class(object_t), pointer :: val1, val2, expr
    integer :: utmp, ncode, i
    character(80) :: buffer
    type(code_t) :: code
    type(object_iterator_t) :: it

    write (u, "(A)")  "* Test output: object_logical_10"
    write (u, "(A)")  "*   Purpose: construct expressions from code"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Prepare repository"

    allocate (composite_t :: p_log)
    select type (p_log)
    type is (composite_t)
       call p_log%init (var_str ("logical"))
       allocate (logical_t :: core)
       call p_log%import_core (core)
    end select

    allocate (not_t :: p_not)
    select type (p_not)
    type is (not_t)
       call p_not%init (p_log)
    end select

    allocate (and_t :: p_and)
    select type (p_and)
    type is (and_t)
       call p_and%init (p_log)
    end select

    allocate (or_t :: p_or)
    select type (p_or)
    type is (or_t)
       call p_or%init (p_log)
    end select

    call repository%init (name = var_str ("repository"), n_members = 4)
    call repository%import_member (1, p_log)
    call repository%import_member (2, p_not)
    call repository%import_member (3, p_and)
    call repository%import_member (4, p_or)

    write (u, "(A)")
    call repository%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Construct object: not"
    

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("not"), expr)
    select type (expr)
    class is (composite_t)
       call expr%import_member (1, val1)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 4
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: and"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("and"), expr)
    select type (expr)
    class is (composite_t)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object: or"

    call remove_object (object)

    call repository%spawn (var_str ("logical"), val1)
    select type (val1)
    class is (composite_t)
       call val1%init (name = var_str ("val_true"), mode = MODE_CONSTANT)
       call val1%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.true.)
       end select
    end select

    call repository%spawn (var_str ("logical"), val2)
    select type (val2)
    class is (composite_t)
       call val2%init (name = var_str ("val_false"), mode = MODE_CONSTANT)
       call val2%get_core_ptr (core)
       select type (core)
       type is (logical_t)
          call core%init (.false.)
       end select
    end select

    call repository%spawn (var_str ("or"), expr)
    select type (expr)
    class is (composite_t)
       call expr%import_member (1, val1)
       call expr%import_member (2, val2)
    end select

    allocate (wrapper_t :: main)
    select type (main)
    class is (wrapper_t)
       call main%import_core (expr)
    end select
    
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Code from object"

    utmp = free_unit ()
    open (utmp, status="scratch")

    write (u, "(A)")

    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
    end select

    call it%init (object)
    do while (it%is_valid ())
       call it%get_object (object)
       code = object%get_code (repository)
       call code%write (u, verbose=.true.)
       call code%write (utmp)
       call it%advance ()
    end do

    rewind (utmp)
    
    write (u, "(A)")
    write (u, "(A)")  "* Construct object from code"

    ncode = 6
    
    call remove_object (main)
    allocate (wrapper_t :: main)
    call it%init (main)
    do i = 1, ncode
       call code%read (utmp)
       call build_object (object, code, repository)
       if (associated (object)) then
          call it%advance (import_object = object)
       else
          call it%advance ()
       end if
       call it%get_object (object)
       select type (object)
       class is (value_t)
          call object%init_from_code (code)
       end select
    end do
    close (utmp)
 
    write (u, "(A)")
    select type (main)
    class is (wrapper_t);  call main%get_core_ptr (object)
       call object%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call remove_object (main)
    call repository%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: object_logical_10"

  end subroutine object_logical_10

@ %def object_logical_10

