%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: particle objects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Particles}

This chapter collects modules that implement particle objects, for use in
event records.

While within interactions, all correlations are
manifest, a particle array is derived by selecting a particular
quantum number set.  This involves tracing over all other particles,
as far as polarization is concerned.  Thus, a particle has definite
flavor, color, and a single-particle density matrix for polarization.
\begin{description}
\item[su\_algebra]
  We make use of $su(N)$ generators as the basis for representing
  polarization matrices.  This module defines the basis and provides
  the necessary transformation routines.
\item[bloch\_vectors]
  This defines polarization objects in Bloch representation.  The
  object describes the spin density matrix of a particle,
  currently restricted to spin $0\ldots 2$.
\item[polarizations]
  This extends the basic polarization object such that it supports
  properties of physical particles and appropriate constructors.
\item[particles]
  Particle objects and particle lists, as the base of event records.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{$su(N)$ Algebra}
We need a specific choice of basis for a well-defined component
representation.  The matrix elements of $T^a$ are
ordered as $m=\ell,\ell-1,\ldots -\ell$, i.e., from highest down to
lowest weight, for both row and column.  

We list first the generators of the $su(2)$ subalgebras which leave
$|m|$ invariant ($|m|\neq 0$):
\begin{equation}
  T^{b+1,b+2,b+3} \equiv \sigma^{1,2,3}
\end{equation}
acting on the respective subspace $|m|=\ell,\ell-1,\ldots$ for
$b=0,1,\ldots$.  This defines generators $T^a$ for $a=1,\ldots 3N/2$
($\ldots 3(N-1)/2$) for $N$ even (odd), respectively.

The following generators successively extend this to $su(4)$, $su(6)$,
\ldots until $su(N)$ by adding first the missing off-diagonal and then
diagonal generators.  The phase conventions are analogous.

(It should be possible to code these conventions for generic spin, but
in the current implementation we restrict ourselves to $s\leq 2$, i.e.,
$N\leq 5$.)
<<[[su_algebra.f90]]>>=
<<File header>>

module su_algebra

<<Use kinds>>
  use physics_defs, only: SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR

<<Standard module head>>

<<su algebra: public>>

contains

<<su algebra: procedures>>

end module su_algebra
@ %def su_algebra
@
\subsection{$su(N)$ fundamental representation}
The dimension of the basis for a given spin type.  consecutively, starting at
[[SCALAR=1]].
<<su algebra: public>>=
  public :: algebra_dimension
<<su algebra: procedures>>=
  function algebra_dimension (s) result (n)
    integer :: n
    integer, intent(in) :: s
    n = fundamental_dimension (s) ** 2 - 1
  end function algebra_dimension
    
@ %def algebra_dimension
@ The dimension of the fundamental (defining) representation that we
use.  This implementation assumes that the spin type is numerically
equal to the fundamental dimension.
<<su algebra: public>>=
  public :: fundamental_dimension
<<su algebra: procedures>>=
  function fundamental_dimension (s) result (d)
    integer :: d
    integer, intent(in) :: s
    d = s
  end function fundamental_dimension
  
@ %def fundamental_dimension
@
\subsection{Mapping between helicity and matrix index}
Return the helicity that corresponds to a particular entry in the
polarization matrix representation.  Helicities are counted downwards,
in integers, and zero helicity is included (omitted) for odd (even)
spin, respectively.
<<su algebra: public>>=
  public :: helicity_value
<<su algebra: procedures>>=
  function helicity_value (s, i) result (h)
    integer :: h
    integer, intent(in) :: s, i
    integer, dimension(1), parameter :: hh1 = [0]
    integer, dimension(2), parameter :: hh2 = [1, -1]
    integer, dimension(3), parameter :: hh3 = [1,  0, -1]
    integer, dimension(4), parameter :: hh4 = [2,  1, -1, -2]
    integer, dimension(5), parameter :: hh5 = [2,  1,  0, -1, -2]
    h = 0
    select case (s)
    case (SCALAR)
       select case (i)
       case (1:1);  h = hh1(i)
       end select
    case (SPINOR)
       select case (i)
       case (1:2);  h = hh2(i)
       end select
    case (VECTOR)
       select case (i)
       case (1:3);  h = hh3(i)
       end select
    case (VECTORSPINOR)
       select case (i)
       case (1:4);  h = hh4(i)
       end select
    case (TENSOR)
       select case (i)
       case (1:5);  h = hh5(i)
       end select
    end select
  end function helicity_value
  
@ %def helicity_value
@ Inverse: return the index that corresponds to a certain
helicity value in the chosen representation.
<<su algebra: public>>=
  public :: helicity_index
<<su algebra: procedures>>=
  function helicity_index (s, h) result (i)
    integer, intent(in) :: s, h
    integer :: i
    integer, dimension(0:0), parameter :: hi1 = [1]
    integer, dimension(-1:1), parameter :: hi2 = [2, 0, 1]
    integer, dimension(-1:1), parameter :: hi3 = [3, 2, 1]
    integer, dimension(-2:2), parameter :: hi4 = [4, 3, 0, 2, 1]
    integer, dimension(-2:2), parameter :: hi5 = [5, 4, 3, 2, 1]
    select case (s)
    case (SCALAR)
       i = hi1(h)
    case (SPINOR)
       i = hi2(h)
    case (VECTOR)
       i = hi3(h)
    case (VECTORSPINOR)
       i = hi4(h)
    case (TENSOR)
       i = hi5(h)
    end select
  end function helicity_index
  
@ %def helicity_index
@
\subsection{Generator Basis: Cartan Generators}
For each supported spin type, we return specific properties of the
set of generators via inquiry functions.  This is equivalent to using
explicit representations of the generators.

For easy access, the properties are hard-coded and selected via case
expressions.

Return true if the generator \#[[i]] is in the Cartan subalgebra,
i.e., a diagonal matrix for spin type [[s]].
<<su algebra: public>>=
  public :: is_cartan_generator
<<su algebra: procedures>>=
  elemental function is_cartan_generator (s, i) result (cartan)
    logical :: cartan
    integer, intent(in) :: s, i
    select case (s)
    case (SCALAR)
    case (SPINOR)
       select case (i)
       case (3);  cartan = .true.
       case default
          cartan = .false.
       end select
    case (VECTOR)
       select case (i)
       case (3,8);  cartan = .true.
       case default
          cartan = .false.
       end select
    case (VECTORSPINOR)
       select case (i)
       case (3,6,15);  cartan = .true.
       case default
          cartan = .false.
       end select
    case (TENSOR)
       select case (i)
       case (3,6,15,24);  cartan = .true.
       case default
          cartan = .false.
       end select
    case default
       cartan = .false.
    end select
  end function is_cartan_generator
  
@ %def is_cartan_generator
@ Return the index of Cartan generator \#[[k]] in the chosen
representation.  This has to conform to [[cartan]] above.
<<su algebra: public>>=
  public :: cartan_index
<<su algebra: procedures>>=
  elemental function cartan_index (s, k) result (ci)
    integer :: ci
    integer, intent(in) :: s, k
    integer, dimension(1), parameter :: ci2 = [3]
    integer, dimension(2), parameter :: ci3 = [3,8]
    integer, dimension(3), parameter :: ci4 = [3,6,15]
    integer, dimension(4), parameter :: ci5 = [3,6,15,24]
    select case (s)
    case (SPINOR)
       ci = ci2(k)
    case (VECTOR)
       ci = ci3(k)
    case (VECTORSPINOR)
       ci = ci4(k)
    case (TENSOR)
       ci = ci5(k)
    case default
       ci = 0
    end select
  end function cartan_index
  
@ %def cartan_index
@ The element \#[[k]] of the result vector [[a]] is equal to the
$(h,h)$ diagonal entry of the generator matrix $T^k$.  That is,
evaluating this for all allowed values of [[h]], we recover the set of
Cartan generator matrices.
<<su algebra: public>>=
  public :: cartan_element
<<su algebra: procedures>>=
  function cartan_element (s, h) result (a)
    real(default), dimension(:), allocatable :: a
    integer, intent(in) :: s, h
    real(default), parameter :: sqrt2 = sqrt (2._default)
    real(default), parameter :: sqrt3 = sqrt (3._default)
    real(default), parameter :: sqrt10 = sqrt (10._default)
    allocate (a (algebra_dimension (s)), source = 0._default)
    select case (s)
    case (SCALAR)
    case (SPINOR)
       select case (h)
       case (1)
          a(3) =  1._default / 2
       case (-1)
          a(3) = -1._default / 2
       end select
    case (VECTOR)
       select case (h)
       case (1)
          a(3) =  1._default / 2
          a(8) =  1._default / (2 * sqrt3)
       case (-1)
          a(3) = -1._default / 2
          a(8) =  1._default / (2 * sqrt3)
       case (0)
          a(8) = -1._default / sqrt3
       end select
    case (VECTORSPINOR)
       select case (h)
       case (2)
          a(3)  =  1._default / 2
          a(15) =  1._default / (2 * sqrt2)
       case (-2)
          a(3)  = -1._default / 2
          a(15) =  1._default / (2 * sqrt2)
       case (1)
          a(6)  =  1._default / 2
          a(15) = -1._default / (2 * sqrt2)
       case (-1)
          a(6)  = -1._default / 2
          a(15) = -1._default / (2 * sqrt2)
       end select
    case (TENSOR)
       select case (h)
       case (2)
          a(3)  =  1._default / 2
          a(15) =  1._default / (2 * sqrt2)
          a(24) =  1._default / (2 * sqrt10)
       case (-2)
          a(3)  = -1._default / 2
          a(15) =  1._default / (2 * sqrt2)
          a(24) =  1._default / (2 * sqrt10)
       case (1)
          a(6)  =  1._default / 2
          a(15) = -1._default / (2 * sqrt2)
          a(24) =  1._default / (2 * sqrt10)
       case (-1)
          a(6)  = -1._default / 2
          a(15) = -1._default / (2 * sqrt2)
          a(24) =  1._default / (2 * sqrt10)
       case (0)
          a(24) = -4._default / (2 * sqrt10)
       end select
    end select
  end function cartan_element
       
@ %def cartan_element
@ Given an array of diagonal matrix elements [[rd]] of a generator,
compute the array [[a]] of basis coefficients.  The array must be
ordered as defined by [[helicity_value]], i.e., highest weight first.
The calculation is organized such that the trace of the generator,
i.e., the sum of [[rd]] values, drops out.  The result array [[a]] has
coefficients for all basis generators, but only Cartan generators can
get a nonzero coefficient.
<<su algebra: public>>=
  public :: cartan_coeff
<<su algebra: procedures>>=
  function cartan_coeff (s, rd) result (a)
    real(default), dimension(:), allocatable :: a
    integer, intent(in) :: s
    real(default), dimension(:), intent(in) :: rd
    real(default), parameter :: sqrt2 = sqrt (2._default)
    real(default), parameter :: sqrt3 = sqrt (3._default)
    real(default), parameter :: sqrt10 = sqrt (10._default)
    integer :: n
    n = algebra_dimension (s)
    allocate (a (n), source = 0._default)
    select case (s)
    case (SPINOR)
       a(3) = rd(1) - rd(2)
    case (VECTOR)
       a(3) = rd(1) - rd(3)
       a(8) = (rd(1) - 2 * rd(2) + rd(3)) / sqrt3
    case (VECTORSPINOR)
       a(3) = rd(1) - rd(4)
       a(6) = rd(2) - rd(3)
       a(15) = (rd(1) - rd(2) - rd(3) + rd(4)) / sqrt2
    case (TENSOR)
       a(3) = rd(1) - rd(5)
       a(6) = rd(2) - rd(4)
       a(15) = (rd(1) - rd(2) - rd(4) + rd(5)) / sqrt2
       a(24) = (rd(1) + rd(2) - 4 * rd(3) + rd(4) + rd(5)) / sqrt10
    end select
  end function cartan_coeff
          
@ %def cartan_coeff
@
\subsection{Roots (Off-Diagonal Generators)}
Return the appropriate generator index for a given off-diagonal helicity
combination.  We require $h_1>h_2$.  We return the index of the
appropriate real-valued generator if [[r]] is true, else the
complex-valued one.

This is separate from the [[cartan_coeff]] function above.  The reason
is that the off-diagonal generators have only a single nonzero matrix
element, so there is a one-to-one correspondence of helicity and index.
<<su algebra: public>>=
  public :: root_index
<<su algebra: procedures>>=
  function root_index (s, h1, h2, r) result (ai)
    integer :: ai
    integer, intent(in) :: s, h1, h2
    logical :: r
    ai = 0
    select case (s)
    case (SCALAR)
    case (SPINOR)
       select case (h1)
       case (1)
          select case (h2)
          case (-1);  ai = 1
          end select
       end select
    case (VECTOR)
       select case (h1)
       case (1)
          select case (h2)
          case (-1);  ai = 1
          case (0);   ai = 4
          end select
       case (0)
          select case (h2)
          case (-1);  ai = 6
          end select
       end select
    case (VECTORSPINOR)
       select case (h1)
       case (2)
          select case (h2)
          case (-2);  ai = 1
          case (1);   ai = 7
          case (-1);  ai = 11
          end select
       case (1)
          select case (h2)
          case (-1);  ai = 4
          case (-2);  ai = 13
          end select
       case (-1)
          select case (h2)
          case (-2);  ai = 9
          end select
       end select
    case (TENSOR)
       select case (h1)
       case (2)
          select case (h2)
          case (-2);  ai = 1
          case (1);   ai = 7
          case (-1);  ai = 11
          case (0);   ai = 16
          end select
       case (1)
          select case (h2)
          case (-1);  ai = 4
          case (-2);  ai = 13
          case (0);   ai = 20
          end select
       case (-1)
          select case (h2)
          case (-2);  ai = 9
          end select
       case (0)
          select case (h2)
          case (-2);  ai = 18
          case (-1);  ai = 22
          end select
       end select
    end select
    if (ai /= 0 .and. .not. r)  ai = ai + 1
  end function root_index

@ %def root_index
@ Inverse: return the helicity values ($h_2>h_1$) for an off-diagonal
generator.  The flag [[r]] tells whether this is a real or diagonal
generator.   The others are Cartan generators.
<<su algebra: public>>=
  public :: root_helicity
<<su algebra: procedures>>=
  subroutine root_helicity (s, i, h1, h2, r)
    integer, intent(in) :: s, i
    integer, intent(out) :: h1, h2
    logical, intent(out) :: r
    h1 = 0
    h2 = 0
    r  = .false.
    select case (s)
    case (SCALAR)
    case (SPINOR)
       select case (i)
       case ( 1, 2);  h1 =  1;  h2 = -1;  r = i == 1
       end select
    case (VECTOR)
       select case (i)
       case ( 1, 2);  h1 =  1;  h2 = -1;  r = i == 1
       case ( 4, 5);  h1 =  1;  h2 =  0;  r = i == 4
       case ( 6, 7);  h1 =  0;  h2 = -1;  r = i == 6
       end select
    case (VECTORSPINOR)
       select case (i)
       case ( 1, 2);  h1 =  2;  h2 = -2;  r = i == 1
       case ( 4, 5);  h1 =  1;  h2 = -1;  r = i == 4
       case ( 7, 8);  h1 =  2;  h2 =  1;  r = i == 7
       case ( 9,10);  h1 = -1;  h2 = -2;  r = i == 9
       case (11,12);  h1 =  2;  h2 = -1;  r = i ==11
       case (13,14);  h1 =  1;  h2 = -2;  r = i ==13
       end select
    case (TENSOR)
       select case (i)
       case ( 1, 2);  h1 =  2;  h2 = -2;  r = i == 1
       case ( 4, 5);  h1 =  1;  h2 = -1;  r = i == 4
       case ( 7, 8);  h1 =  2;  h2 =  1;  r = i == 7
       case ( 9,10);  h1 = -1;  h2 = -2;  r = i == 9
       case (11,12);  h1 =  2;  h2 = -1;  r = i ==11
       case (13,14);  h1 =  1;  h2 = -2;  r = i ==13
       case (16,17);  h1 =  2;  h2 =  0;  r = i ==16
       case (18,19);  h1 =  0;  h2 = -2;  r = i ==18
       case (20,21);  h1 =  1;  h2 =  0;  r = i ==20
       case (22,23);  h1 =  0;  h2 = -1;  r = i ==22
       end select
    end select
  end subroutine root_helicity
  
@ %def root_helicity
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[su_algebra_ut.f90]]>>=
<<File header>>

module su_algebra_ut
  use unit_tests
  use su_algebra_uti
  
<<Standard module head>>

<<su algebra: public test>>

contains
  
<<su algebra: test driver>>

end module su_algebra_ut
@ %def su_algebra_ut
@
<<[[su_algebra_uti.f90]]>>=
<<File header>>

module su_algebra_uti

<<Use kinds>>
  use physics_defs, only: SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use su_algebra

<<Standard module head>>

<<su algebra: test declarations>>

contains

<<su algebra: tests>>

end module su_algebra_uti
@ %def su_algebra_ut
@ API: driver for the unit tests below.
<<su algebra: public test>>=
  public :: su_algebra_test
<<su algebra: test driver>>=
  subroutine su_algebra_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<su algebra: execute tests>>
  end subroutine su_algebra_test

@  %def su_algebra_test
@
\subsubsection{Generator Ordering}
Show the position of Cartan generators in the sequence of basis generators.
<<su algebra: execute tests>>=
  call test (su_algebra_1, "su_algebra_1", &
       "generator ordering", &
       u, results)
<<su algebra: test declarations>>= 
  public :: su_algebra_1
<<su algebra: tests>>= 
  subroutine su_algebra_1 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: su_algebra_1"
    write (u, "(A)")  "*   Purpose: test su(N) algebra implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* su(N) generators: &
         &list and mark Cartan subalgebra"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call cartan_check (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call cartan_check (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call cartan_check (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call cartan_check (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call cartan_check (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: su_algebra_1"    
      
  contains
    
    subroutine cartan_check (s)
      integer, intent(in) :: s
      integer :: i
      write (u, *)
      do i = 1, algebra_dimension (s)
         write (u, "(1x,L1)", advance="no")  is_cartan_generator (s, i)
      end do
      write (u, *)
      
    end subroutine cartan_check

  end subroutine su_algebra_1

@ %def su_algebra_1
@
\subsubsection{Cartan Generator Basis}
Show the explicit matrix representation for all Cartan generators and
check their traces and Killing products.

Also test helicity index mappings.
<<su algebra: execute tests>>=
  call test (su_algebra_2, "su_algebra_2", &
       "Cartan generator representation", &
       u, results)
<<su algebra: test declarations>>= 
  public :: su_algebra_2
<<su algebra: tests>>= 
  subroutine su_algebra_2 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: su_algebra_2"
    write (u, "(A)")  "*   Purpose: test su(N) algebra implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* diagonal su(N) generators: &
         &show explicit representation"
    write (u, "(A)")  "* and check trace and Killing form"

    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call cartan_show (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call cartan_show (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call cartan_show (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call cartan_show (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: su_algebra_2"    
      
  contains
    
    subroutine cartan_show (s)
      integer, intent(in) :: s
      real(default), dimension(:,:), allocatable :: rd
      integer, dimension(:), allocatable :: ci
      integer :: n, d, h, i, j, k, l

      n = algebra_dimension (s)
      d = fundamental_dimension (s)
      
      write (u, *)
      write (u, "(A2,5X)", advance="no")  "h:"
      do i = 1, d
         j = helicity_index (s, helicity_value (s, i))
         write (u, "(1x,I2,5X)", advance="no")  helicity_value (s, j)
      end do
      write (u, "(8X)", advance="no")
      write (u, "(1X,A)")  "tr"
      
      allocate (rd (n,d), source = 0._default)
      do i = 1, d
         h = helicity_value (s, i)
         rd(:,i) = cartan_element (s, h)
      end do

      allocate (ci (d-1), source = 0)
      do k = 1, d-1
         ci(k) = cartan_index (s, k)
      end do

      write (u, *)
      do k = 1, d-1
         write (u, "('T',I2,':',1X)", advance="no")  ci(k)
         do i = 1, d
            write (u, 1, advance="no")  rd(ci(k),i)
         end do
         write (u, "(8X)", advance="no")
         write (u, 1)  sum (rd(ci(k),:))
      end do
      
      write (u, *)
      write (u, "(6X)", advance="no")
      do k = 1, d-1
         write (u, "(2X,'T',I2,3X)", advance="no")  ci(k)
      end do 
      write (u, *)
      
      do k = 1, d-1
         write (u, "('T',I2,2X)", advance="no")  ci(k)
         do l = 1, d-1
            write (u, 1, advance="no")  dot_product (rd(ci(k),:), rd(ci(l),:))
         end do
         write (u, *)
      end do

1     format (1x,F7.4)
      
    end subroutine cartan_show

  end subroutine su_algebra_2

@ %def su_algebra_2
@
\subsubsection{Bloch Representation: Cartan Generators}
Transform from Bloch vectors to matrix and back, considering Cartan
generators only.
<<su algebra: execute tests>>=
  call test (su_algebra_3, "su_algebra_3", &
       "Cartan generator mapping", &
       u, results)
<<su algebra: test declarations>>= 
  public :: su_algebra_3
<<su algebra: tests>>= 
  subroutine su_algebra_3 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: su_algebra_3"
    write (u, "(A)")  "*   Purpose: test su(N) algebra implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* diagonal su(N) generators: &
         &transform to matrix and back"

    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call cartan_expand (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call cartan_expand (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call cartan_expand (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call cartan_expand (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: su_algebra_3"    
      
  contains
    
    subroutine cartan_expand (s)
      integer, intent(in) :: s
      real(default), dimension(:,:), allocatable :: rd
      integer, dimension(:), allocatable :: ci
      real(default), dimension(:), allocatable :: a
      logical, dimension(:), allocatable :: mask
      integer :: n, d, h, i, k, l

      n = algebra_dimension (s)
      d = fundamental_dimension (s)
      
      allocate (rd (n,d), source = 0._default)
      do i = 1, d
         h = helicity_value (s, i)
         rd(:,i) = cartan_element (s, h)
      end do

      allocate (ci (d-1), source = 0)
      do k = 1, d-1
         ci(k) = cartan_index (s, k)
      end do

      allocate (a (n))

      write (u, *)
      do k = 1, d-1
         a(:) = cartan_coeff (s, rd(ci(k),:))
         write (u, "('T',I2,':',1X)", advance="no")  ci(k)
         do i = 1, n
            if (is_cartan_generator (s, i)) then
               write (u, 1, advance="no")  a(i)
            else if (a(i) /= 0) then
               ! this should not happen (nonzero non-Cartan entry)
               write (u, "(1X,':',I2,':',3X)", advance="no")  i
            end if
         end do
         write (u, *)
      end do

1     format (1X,F7.4)
      
    end subroutine cartan_expand

  end subroutine su_algebra_3

@ %def su_algebra_3
@
\subsubsection{Bloch Representation: Roots}
List the mapping between helicity transitions and (real) off-diagonal
generators.
<<su algebra: execute tests>>=
  call test (su_algebra_4, "su_algebra_4", &
       "Root-helicity mapping", &
       u, results)
<<su algebra: test declarations>>= 
  public :: su_algebra_4
<<su algebra: tests>>= 
  subroutine su_algebra_4 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: su_algebra_4"
    write (u, "(A)")  "*   Purpose: test su(N) algebra implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* off-diagonal su(N) generators: &
         &mapping from/to helicity pair"

    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call root_expand (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call root_expand (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call root_expand (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call root_expand (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: su_algebra_4"    
      
  contains
    
    subroutine root_expand (s)
      integer, intent(in) :: s
      integer :: n, d, i, j, h1, h2
      logical :: r

      n = algebra_dimension (s)
      
      write (u, *)
      do i = 1, n
         if (is_cartan_generator (s, i))  cycle
         call root_helicity (s, i, h1, h2, r)
         j = root_index (s, h1, h2, r)
         write (u, "('T',I2,':')", advance="no")  j
         write (u, "(2(1x,I2))", advance="no")  h1, h2
         if (r) then
            write (u, *)
         else
            write (u, "('*')")
         end if
      end do
      
    end subroutine root_expand

  end subroutine su_algebra_4

@ %def su_algebra_4
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bloch Representation}
Particle polarization is determined by a particular quantum state
which has just helicity information.  Physically, this is the spin
density matrix $\rho$, where we do not restrict ourselves to pure
states. 

We adopt the phase convention for a spin-1/2 particle that
\begin{equation}
  \rho = \tfrac12(1 + \vec\alpha\cdot\vec\sigma)
\end{equation}
with the polarization axis $\vec\alpha$.  For a particle with
arbitrary spin $s$, and thus $N=2s+1$ spin states, we extend the above
definition to generalized Bloch form
\begin{equation}
  \rho = \frac1N\left(1 + \sqrt{2N(N-1)}\alpha^aT^a\right)
\end{equation}
where the $T^a$ ($a=1,\ldots N^2-1$) are a basis of $su(N)$ algebra
generators.  These $N\times N$ matrices are hermitean, traceless, and
orthogonal via
\begin{equation}
  \mathop{\rm Tr}T^aT^b = \frac12 \delta^{ab}
\end{equation}
In the spin-1/2 case, this reduces to the above (standard Bloch)
representation since $T^a = \sigma^a/2$, $a=1,2,3$.  For the spin-1
case, we could use $T^a = \lambda^a/2$ with the Gell-Mann matrices,
\begin{equation}
  \rho = \frac13\left(1 + \sqrt{3}\alpha^a\lambda^a\right),
\end{equation}
The normalization is chosen that $|alpha|\leq 1$ for allowed density
matrix, where $|\alpha|=1$ is a necessary, but not sufficient,
condition for a pure state.

We need a specific choice of basis for a well-defined component
representation.  The matrix elements of $T^a$ are
ordered as $m=\ell,\ell-1,\ldots -\ell$, i.e., from highest down to
lowest weight, for both row and column.  

We list first the generators of the $su(2)$ subalgebras which leave
$|m|$ invariant ($|m|\neq 0$):
\begin{equation}
  T^{b+1,b+2,b+3} \equiv \sigma^{1,2,3}
\end{equation}
acting on the respective subspace $|m|=\ell,\ell-1,\ldots$ for
$b=0,1,\ldots$.  This defines generators $T^a$ for $a=1,\ldots 3N/2$
($\ldots 3(N-1)/2$) for $N$ even (odd), respectively.

The following generators successively extend this to $su(4)$, $su(6)$,
\ldots until $su(N)$ by adding first the missing off-diagonal and then
diagonal generators.  The phase conventions are analogous.

(It should be possible to code these conventions for generic spin, but
in the current implementation we restrict ourselves to $s\leq 2$, i.e.,
$N\leq 5$.)

Particle polarization is determined by a particular quantum state
which has just helicity information.  Physically, this is the spin
density matrix $\rho$, where we do not restrict ourselves to pure
states. 

We adopt the phase convention for a spin-1/2 particle that
\begin{equation}
  \rho = \tfrac12(1 + \vec\alpha\cdot\vec\sigma)
\end{equation}
with the polarization axis $\vec\alpha$.  For a particle with
arbitrary spin $s$, and thus $N=2s+1$ spin states, we extend the above
definition to generalized Bloch form
\begin{equation}
  \rho = \frac1N\left(1 + \sqrt{2N(N-1)}\alpha^aT^a\right)
\end{equation}
where the $T^a$ ($a=1,\ldots N^2-1$) are a basis of $su(N)$ algebra
generators.  These $N\times N$ matrices are hermitean, traceless, and
orthogonal via
\begin{equation}
  \mathop{\rm Tr}T^aT^b = \frac12 \delta^{ab}
\end{equation}
In the spin-1/2 case, this reduces to the above (standard Bloch)
representation since $T^a = \sigma^a/2$, $a=1,2,3$.  For the spin-1
case, we could use $T^a = \lambda^a/2$ with the Gell-Mann matrices,
\begin{equation}
  \rho = \frac13\left(1 + \sqrt{3}\alpha^a\lambda^a\right),
\end{equation}
The normalization is chosen that $|alpha|\leq 1$ for allowed density
matrix, where $|\alpha|=1$ is a necessary, but not sufficient,
condition for a pure state.
<<[[bloch_vectors.f90]]>>=
<<File header>>

module bloch_vectors

<<Use kinds>>
  use physics_defs, only: UNKNOWN, SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use su_algebra

<<Standard module head>>

<<Bloch vectors: public>>

<<Bloch vectors: types>>

contains

<<Bloch vectors: procedures>>

end module bloch_vectors
@ %def bloch_vectors
@
\subsection{Preliminaries}
The normalization factor $\sqrt{2N(N-1)}/N$ that enters the Bloch
representation.
<<Bloch vectors: procedures>>=
  function bloch_factor (s) result (f)
    real(default) :: f
    integer, intent(in) :: s
    select case (s)
    case (SCALAR)
       f = 0
    case (SPINOR)
       f = 1
    case (VECTOR)
       f = 2 * sqrt (3._default) / 3
    case (VECTORSPINOR)
       f = 2 * sqrt (6._default) / 4
    case (TENSOR)
       f = 2 * sqrt (10._default) / 5
    case default
       f = 0
    end select
  end function bloch_factor
    
@ %def bloch_factor
@ 
\subsection{The basic polarization type}
The basic polarization object holds just the entries of the Bloch
vector as an allocatable array. 

Bloch is active whenever the coefficient array is allocated.
For convenience, we store the spin type ($2s$) and the multiplicity
($N$) together with the coefficient array ($\alpha$).  We have to allow for
the massless case where $s$ is arbitrary $>0$ but $N=2$, and
furthermore the chiral massless case where $N=1$.  In the latter case,
the array remains deallocated but the chirality is set to $\pm 1$.

In the Bloch vector implementation, we do not distinguish between
particle and antiparticle.  If the distinction applies, it must be
made by the caller when transforming between density matrix and Bloch vector.
<<Bloch vectors: public>>=
  public :: bloch_vector_t
<<Bloch vectors: types>>=
  type :: bloch_vector_t
     private
     integer :: spin_type = UNKNOWN
     real(default), dimension(:), allocatable :: a
   contains
   <<Bloch vectors: bloch vector: TBP>>
end type bloch_vector_t

@ %def bloch_vector_t
@ 
\subsection{Direct Access}
This basic initializer just sets the spin type, leaving the Bloch vector
unallocated.  The object therefore does not support nonzero polarization.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: init_unpolarized => bloch_vector_init_unpolarized
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init_unpolarized (pol, spin_type)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    pol%spin_type = spin_type
  end subroutine bloch_vector_init_unpolarized
    
@ %def bloch_vector_init_unpolarized
@ The standard initializer allocates the Bloch vector and initializes
with zeros, so we can define a polarization later.  We make sure that
this works only for the supported spin type.  Initializing with
[[UNKNOWN]] spin type resets the Bloch vector to undefined, i.e.,
unpolarized state.
<<Bloch vectors: bloch vector: TBP>>=
  generic :: init => bloch_vector_init
  procedure, private :: bloch_vector_init
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init (pol, spin_type)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    pol%spin_type = spin_type
    select case (spin_type)
    case (SCALAR,SPINOR,VECTOR,VECTORSPINOR,TENSOR)
       allocate (pol%a (algebra_dimension (spin_type)), source = 0._default)
    end select
  end subroutine bloch_vector_init
    
@ %def bloch_vector_init
@ 
Fill the Bloch vector from an array, no change of normalization.  No
initialization and no check, we assume that the shapes do match.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: from_array => bloch_vector_from_array
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_from_array (pol, a)
    class(bloch_vector_t), intent(inout) :: pol
    real(default), dimension(:), allocatable, intent(in) :: a
    pol%a(:) = a
  end subroutine bloch_vector_from_array
    
@ %def bloch_vector_from_array
@
Transform to an array of reals, i.e., extract the Bloch vector as-is.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: to_array => bloch_vector_to_array
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_to_array (pol, a)
    class(bloch_vector_t), intent(in) :: pol
    real(default), dimension(:), allocatable, intent(out) :: a
    if (pol%is_defined ())  allocate (a (size (pol%a)), source = pol%a)
  end subroutine bloch_vector_to_array

@ %def bloch_vector_to_array
@
\subsection{Raw I/O}
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: write_raw => bloch_vector_write_raw
  procedure :: read_raw => bloch_vector_read_raw
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_write_raw (pol, u)
    class(bloch_vector_t), intent(in) :: pol
    integer, intent(in) :: u
    write (u) pol%spin_type
    write (u) allocated (pol%a)
    if (allocated (pol%a)) then
       write (u) pol%a
    end if
  end subroutine bloch_vector_write_raw

  subroutine bloch_vector_read_raw (pol, u, iostat)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    integer :: s
    logical :: polarized
    read (u, iostat=iostat) s
    read (u, iostat=iostat) polarized
    if (iostat /= 0)  return
    if (polarized) then
       call pol%init (s)
       read (u, iostat=iostat) pol%a
    else
       call pol%init_unpolarized (s)
    end if
  end subroutine bloch_vector_read_raw

@ %def bloch_vector_write_raw
@ %def bloch_vector_read_raw
@ 
\subsection{Properties}
Re-export algebra functions that depend on the spin type.  These
functions do not depend on the Bloch vector being allocated.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: get_n_states
  procedure :: get_length
  procedure :: hel_index => bv_helicity_index
  procedure :: hel_value => bv_helicity_value
  procedure :: bloch_factor => bv_factor
<<Bloch vectors: procedures>>=
  function get_n_states (pol) result (n)
    class(bloch_vector_t), intent(in) :: pol
    integer :: n
    n = fundamental_dimension (pol%spin_type)
  end function get_n_states
    
  function get_length (pol) result (n)
    class(bloch_vector_t), intent(in) :: pol
    integer :: n
    n = algebra_dimension (pol%spin_type)
  end function get_length

  function bv_helicity_index (pol, h) result (i)
    class(bloch_vector_t), intent(in) :: pol
    integer, intent(in) :: h
    integer :: i
    i = helicity_index (pol%spin_type, h)
  end function bv_helicity_index
    
  function bv_helicity_value (pol, i) result (h)
    class(bloch_vector_t), intent(in) :: pol
    integer, intent(in) :: i
    integer :: h
    h = helicity_value (pol%spin_type, i)
  end function bv_helicity_value
    
  function bv_factor (pol) result (f)
    class(bloch_vector_t), intent(in) :: pol
    real(default) :: f
    f = bloch_factor (pol%spin_type)
  end function bv_factor

@ %def get_n_states
@ %def helicity_index
@ %def helicity_value
@ If the Bloch vector object is defined, the spin type is anything else but
[[UNKNOWN]].  This allows us the provide the representation-specific
functions above.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: is_defined => bloch_vector_is_defined
<<Bloch vectors: procedures>>=
  function bloch_vector_is_defined (pol) result (flag)
    class(bloch_vector_t), intent(in) :: pol
    logical :: flag
    flag = pol%spin_type /= UNKNOWN
  end function bloch_vector_is_defined
  
@ %def bloch_vector_is_defined
@ If the Bloch vector object is (technically) polarized, it is
defined, and the vector coefficient array has been allocated.
However, the vector value may be zero.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: is_polarized => bloch_vector_is_polarized
<<Bloch vectors: procedures>>=
  function bloch_vector_is_polarized (pol) result (flag)
    class(bloch_vector_t), intent(in) :: pol
    logical :: flag
    flag = allocated (pol%a)
  end function bloch_vector_is_polarized
  
@ %def bloch_vector_is_polarized
@ Return true if the polarization is diagonal, i.e., all entries in
the density matrix are on the diagonal.  This is equivalent to
requiring that only Cartan generator coefficients are nonzero in the
Bloch vector.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: is_diagonal => bloch_vector_is_diagonal
<<Bloch vectors: procedures>>=
  function bloch_vector_is_diagonal (pol) result (diagonal)
    class(bloch_vector_t), intent(in) :: pol
    logical :: diagonal
    integer :: s, i
    s = pol%spin_type
    diagonal = .true.
    if (pol%is_polarized ()) then
       do i = 1, size (pol%a)
          if (is_cartan_generator (s, i))  cycle
          if (pol%a(i) /= 0) then
             diagonal = .false.
             return
          end if
       end do
    end if
  end function bloch_vector_is_diagonal

@ %def bloch_vector_is_diagonal
@
Return the Euclidean norm of the Bloch vector.  This is equal to the
Killing form value of the corresponding algebra generator.  We assume
that the polarization object has been initialized. 

For a pure state, the norm is unity.  All other allowed states have a
norm less than unity.  (For $s\geq 1$, this is a necessary but not
sufficient condition.)
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: get_norm => bloch_vector_get_norm
<<Bloch vectors: procedures>>=
  function bloch_vector_get_norm (pol) result (norm)
    class(bloch_vector_t), intent(in) :: pol
    real(default) :: norm
    select case (pol%spin_type)
    case (SPINOR,VECTOR,VECTORSPINOR,TENSOR)
       norm = sqrt (dot_product (pol%a, pol%a))
    case default
       norm = 1
    end select
  end function bloch_vector_get_norm
       
@ %def bloch_vector_get_norm
@
\subsection{Diagonal density matrix}
This initializer takes a diagonal density matrix, represented by a
real-valued array.  We assume that the trace is unity, and that the
array has the correct shape for the given [[spin_type]].

The [[bloch_factor]] renormalization is necessary such that a pure
state maps to a Bloch vector with unit norm.
<<Bloch vectors: bloch vector: TBP>>=
  generic :: init => bloch_vector_init_diagonal
  procedure, private :: bloch_vector_init_diagonal
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init_diagonal (pol, spin_type, rd)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    real(default), dimension(:), intent(in) :: rd
    call pol%init (spin_type)
    call pol%set (rd)
  end subroutine bloch_vector_init_diagonal
    
@ %def bloch_vector_init_diagonal
@ Set a Bloch vector, given a diagonal density matrix as a real array.
The Bloch vector must be initialized with correct characteristics.
<<Bloch vectors: bloch vector: TBP>>=
  generic :: set => bloch_vector_set_diagonal
  procedure, private :: bloch_vector_set_diagonal
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_set_diagonal (pol, rd)
    class(bloch_vector_t), intent(inout) :: pol
    real(default), dimension(:), intent(in) :: rd
    integer :: s
    s = pol%spin_type
    select case (s)
    case (SCALAR,SPINOR,VECTOR,VECTORSPINOR,TENSOR)
       pol%a(:) = cartan_coeff (s, rd) / bloch_factor (s)
    end select
  end subroutine bloch_vector_set_diagonal
  
@ %def bloch_vector_set_diagonal
@
@
\subsection{Massless density matrix}
This is a specific variant which initializes an equipartition for
the maximum helicity, corresponding to an unpolarized massless particle.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: init_max_weight => bloch_vector_init_max_weight
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init_max_weight (pol, spin_type)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    call pol%init (spin_type)
    select case (spin_type)
    case (VECTOR)
       call pol%set ([0.5_default, 0._default, 0.5_default])
    case (VECTORSPINOR)
       call pol%set ([0.5_default, 0._default, 0._default, 0.5_default])
    case (TENSOR)
       call pol%set ([0.5_default, 0._default, 0._default, 0._default, 0.5_default])
    end select
  end subroutine bloch_vector_init_max_weight
  
@ %def bloch_vector_init_max_weight
@ Initialize the maximum-weight submatrix with a three-component Bloch
vector.  This is not as trivial as it seems because we need the above
initialization for the generalized Bloch in order to remove the lower
weights from the density matrix.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: init_vector => bloch_vector_init_vector
  procedure :: to_vector => bloch_vector_to_vector
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init_vector (pol, s, a)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: s
    real(default), dimension(3), intent(in) :: a
    call pol%init_max_weight (s)
    select case (s)
    case (SPINOR, VECTOR, VECTORSPINOR, TENSOR)
       pol%a(1:3) = a / bloch_factor (s)
    end select
  end subroutine bloch_vector_init_vector
  
  subroutine bloch_vector_to_vector (pol, a)
    class(bloch_vector_t), intent(in) :: pol
    real(default), dimension(3), intent(out) :: a
    integer :: s
    s = pol%spin_type
    select case (s)
    case (SPINOR, VECTOR, VECTORSPINOR, TENSOR)
       a = pol%a(1:3) * bloch_factor (s)
    case default
       a = 0
    end select
  end subroutine bloch_vector_to_vector
  
@ %def bloch_vector_init_vector
@ %def bloch_vector_to_vector
@
\subsection{Arbitrary density matrix}
Initialize the Bloch vector from a density matrix.  We assume that the
density is valid.  In particular, the shape should match, the matrix
should be hermitian, and the trace should be unity.

We first fill the diagonal, then add the off-diagonal parts.
<<Bloch vectors: bloch vector: TBP>>=
  generic :: init => bloch_vector_init_matrix
  procedure, private :: bloch_vector_init_matrix
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_init_matrix (pol, spin_type, r)
    class(bloch_vector_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    complex(default), dimension(:,:), intent(in) :: r
    select case (spin_type)
    case (SCALAR,SPINOR,VECTOR,VECTORSPINOR,TENSOR)
       call pol%init (spin_type)
       call pol%set (r)
    case default
       call pol%init (UNKNOWN)
    end select
  end subroutine bloch_vector_init_matrix

@ %def bloch_vector_init_matrix
@ Set a Bloch vector, given an arbitrary density matrix as a real
array.  The Bloch vector must be initialized with correct
characteristics.
<<Bloch vectors: bloch vector: TBP>>=
  generic :: set => bloch_vector_set_matrix
  procedure, private :: bloch_vector_set_matrix
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_set_matrix (pol, r)
    class(bloch_vector_t), intent(inout) :: pol
    complex(default), dimension(:,:), intent(in) :: r
    real(default), dimension(:), allocatable :: rd
    integer :: s, d, i, j, h1, h2, ir, ii
    s = pol%spin_type
    select case (s)
    case (SCALAR,SPINOR,VECTOR,VECTORSPINOR,TENSOR)
       d = fundamental_dimension (s)
       allocate (rd (d))
       do i = 1, d
          rd(i) = r(i,i)
       end do
       call pol%set (rd)
       do i = 1, d
          h1 = helicity_value (s, i)
          do j = i+1, d
             h2 = helicity_value (s, j)
             ir = root_index (s, h1, h2, .true.)
             ii = root_index (s, h1, h2, .false.)
             pol%a(ir) = real (r(j,i) + r(i,j)) / bloch_factor (s)
             pol%a(ii) = aimag (r(j,i) - r(i,j)) / bloch_factor (s)
          end do
       end do
    end select
  end subroutine bloch_vector_set_matrix
  
@ %def bloch_vector_set_matrix
@ Allocate and fill the density matrix [[r]] (with the index ordering as
defined in [[su_algebra]]) that corresponds to a given Bloch vector.

If the optional [[only_max_weight]] is set, the resulting matrix has
entries only for $\pm h_\text{max}$, as appropriate for a massless
particle (for spin $\geq 1$).  Note that we always add the unit
matrix, as this is part of the Bloch-vector definition.
<<Bloch vectors: bloch vector: TBP>>=
  procedure :: to_matrix => bloch_vector_to_matrix
<<Bloch vectors: procedures>>=
  subroutine bloch_vector_to_matrix (pol, r, only_max_weight)
    class(bloch_vector_t), intent(in) :: pol
    complex(default), dimension(:,:), intent(out), allocatable :: r
    logical, intent(in), optional :: only_max_weight
    integer :: d, s, h0, ng, ai, h, h1, h2, i, j
    logical :: is_real, only_max
    complex(default) :: val
    if (.not. pol%is_polarized ())  return
    s = pol%spin_type
    only_max = .false.
    select case (s)
    case (VECTOR, VECTORSPINOR, TENSOR)
       if (present (only_max_weight))  only_max = only_max_weight
    end select
    if (only_max) then
       ng = 2
       h0 = helicity_value (s, 1)
    else
       ng = algebra_dimension (s)
       h0 = 0
    end if
    d = fundamental_dimension (s)
    allocate (r (d, d), source = (0._default, 0._default))
    do i = 1, d
       h = helicity_value (s, i)
       if (abs (h) < h0)  cycle
       r(i,i) = 1._default / d &
            + dot_product (cartan_element (s, h), pol%a) * bloch_factor (s)
    end do
    do ai = 1, ng
       if (is_cartan_generator (s, ai))  cycle
       call root_helicity (s, ai, h1, h2, is_real)
       i = helicity_index (s, h1)
       j = helicity_index (s, h2)
       if (is_real) then
          val = cmplx (pol%a(ai) / 2 * bloch_factor (s), 0._default, &
               kind=default)
          r(i,j) = r(i,j) + val
          r(j,i) = r(j,i) + val
       else
          val = cmplx (0._default, pol%a(ai) / 2 * bloch_factor (s), &
               kind=default)
          r(i,j) = r(i,j) - val
          r(j,i) = r(j,i) + val
       end if
    end do
  end subroutine bloch_vector_to_matrix
    
@ %def bloch_vector_to_matrix
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[bloch_vectors_ut.f90]]>>=
<<File header>>

module bloch_vectors_ut
  use unit_tests
  use bloch_vectors_uti
  
<<Standard module head>>

<<Bloch vectors: public test>>

contains
  
<<Bloch vectors: test driver>>

end module bloch_vectors_ut
@ %def bloch_vectors_ut
@
<<[[bloch_vectors_uti.f90]]>>=
<<File header>>

module bloch_vectors_uti

<<Use kinds>>
  use physics_defs, only: UNKNOWN, SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use su_algebra, only: algebra_dimension, fundamental_dimension, helicity_value

  use bloch_vectors

<<Standard module head>>

<<Bloch vectors: test declarations>>

contains

<<Bloch vectors: tests>>

end module bloch_vectors_uti
@ %def bloch_vectors_ut
@ API: driver for the unit tests below.
<<Bloch vectors: public test>>=
  public :: bloch_vectors_test
<<Bloch vectors: test driver>>=
  subroutine bloch_vectors_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Bloch vectors: execute tests>>
  end subroutine bloch_vectors_test

@  %def bloch_vectors_test
@
\subsubsection{Initialization}
Initialize the Bloch vector for any spin type.  First as unpolarized
(no array), then as polarized but with zero polarization.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_1, "bloch_vectors_1", &
       "initialization", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_1
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_1 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_1"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization (unpolarized)"

    write (u, "(A)")
    write (u, "(A)")  "* unknown"
    call bloch_init (UNKNOWN)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_init (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_init (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_init (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_init (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_init (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_1"    
      
  contains
    
    subroutine bloch_init (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      real(default), dimension(:), allocatable :: a
      integer :: i
      write (u, *)
      write (u, "(1X,L1,L1)", advance="no") &
           pol%is_defined (), pol%is_polarized ()
      call pol%init_unpolarized (s)
      write (u, "(1X,L1,L1)", advance="no") &
           pol%is_defined (), pol%is_polarized ()
      call pol%init (s)
      write (u, "(1X,L1,L1)", advance="no") &
           pol%is_defined (), pol%is_polarized ()
      write (u, *)
      call pol%to_array (a)
      if (allocated (a)) then
         write (u, "(*(F7.4))")  a
         a(:) = [(real (mod (i, 10), kind=default), i = 1, size (a))]
         call pol%from_array (a)
         call pol%to_array (a)
         write (u, "(*(F7.4))")  a
      else
         write (u, *)
         write (u, *)
      end if
    end subroutine bloch_init

  end subroutine bloch_vectors_1

@ %def bloch_vectors_1
@
\subsubsection{Pure state (diagonal)}
Initialize the Bloch vector with a pure state of definite helicity and
check the normalization.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_2, "bloch_vectors_2", &
       "pure state (diagonal)", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_2
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_2 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_2"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization (polarized, diagonal): &
         &display vector and norm"
    write (u, "(A)")  "*   transform back"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_diagonal (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_diagonal (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_diagonal (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_diagonal (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_diagonal (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_2"    
      
  contains
    
    subroutine bloch_diagonal (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      real(default), dimension(:), allocatable :: a
      real(default), dimension(:), allocatable :: rd
      complex(default), dimension(:,:), allocatable :: r
      integer :: i, j, d
      real(default) :: rj
      real, parameter :: tolerance = 1.E-14_default
      d = fundamental_dimension (s)
      do i = 1, d
         allocate (rd (d), source = 0._default)
         rd(i) = 1
         call pol%init (s, rd)
         call pol%to_array (a)
         write (u, *)
         write (u, "(A,1X,I2)")  "h:", helicity_value (s, i)
         write (u, 1, advance="no")  a
         write (u, "(1X,L1)")  pol%is_diagonal ()
         write (u, 1)  pol%get_norm ()
         call pol%to_matrix (r)
         do j = 1, d
            rj = real (r(j,j))
            if (abs (rj) < tolerance)  rj = 0
            write (u, 1, advance="no")  rj
         end do
         write (u, "(1X,L1)")  matrix_is_diagonal (r)
         deallocate (a, rd, r)
      end do
1     format (99(1X,F7.4,:))
    end subroutine bloch_diagonal

    function matrix_is_diagonal (r) result (diagonal)
      complex(default), dimension(:,:), intent(in) :: r
      logical :: diagonal
      integer :: i, j
      diagonal = .true.
      do j = 1, size (r, 2)
         do i = 1, size (r, 1)
            if (i == j)  cycle
            if (r(i,j) /= 0) then
               diagonal = .false.
               return
            end if
         end do
      end do
    end function matrix_is_diagonal

  end subroutine bloch_vectors_2

@ %def bloch_vectors_2
@
\subsubsection{Pure state (arbitrary)}
Initialize the Bloch vector with an arbitrarily chosen pure state,
check the normalization, and transform back to the density matrix.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_3, "bloch_vectors_3", &
       "pure state (arbitrary)", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_3
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_3 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_3"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization (pure polarized, arbitrary):"
    write (u, "(A)")  "*   input matrix, transform, display norm, transform back"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_arbitrary (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_arbitrary (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_arbitrary (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_arbitrary (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_arbitrary (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_3"    
      
  contains
    
    subroutine bloch_arbitrary (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      complex(default), dimension(:,:), allocatable :: r
      integer :: d
      d = fundamental_dimension (s)
      write (u, *)
      call init_matrix (d, r)
      call write_matrix (d, r)
      call pol%init (s, r)
      write (u, *)
      write (u, 2)  pol%get_norm (), pol%is_diagonal ()
      write (u, *)
      call pol%to_matrix (r)
      call write_matrix (d, r)
2     format (1X,F7.4,1X,L1)
    end subroutine bloch_arbitrary

    subroutine init_matrix (d, r)
      integer, intent(in) :: d
      complex(default), dimension(:,:), allocatable, intent(out) :: r
      complex(default), dimension(:), allocatable :: a
      real(default) :: norm
      integer :: i, j
      allocate (a (d))
      norm = 0
      do i = 1, d
         a(i) = cmplx (2*i-1, 2*i, kind=default)
         norm = norm + conjg (a(i)) * a(i)
      end do
      a = a / sqrt (norm)
      allocate (r (d,d))
      do i = 1, d
         do j = 1, d
            r(i,j) = conjg (a(i)) * a(j)
         end do
      end do
    end subroutine init_matrix
    
    subroutine write_matrix (d, r)
      integer, intent(in) :: d
      complex(default), dimension(:,:), intent(in) :: r
      integer :: i, j
      do i = 1, d
         do j = 1, d
            write (u, 1, advance="no")  r(i,j)
         end do
         write (u, *)
      end do
1     format (99(1X,'(',F7.4,',',F7.4,')',:))
    end subroutine write_matrix

  end subroutine bloch_vectors_3

@ %def bloch_vectors_3
@
\subsubsection{Raw I/O}
Check correct input/output in raw format.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_4, "bloch_vectors_4", &
       "raw I/O", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_4
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_4 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_4"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Raw I/O"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_io (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_io (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_io (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_io (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_io (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_4"    
      
  contains
    
    subroutine bloch_io (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      real(default), dimension(:), allocatable :: a
      integer :: n, i, utmp, iostat
      n = algebra_dimension (s)
      allocate (a (n))
      a(:) = [(real (mod (i, 10), kind=default), i = 1, size (a))]
      write (u, *)
      write (u, "(*(F7.4))")  a
      call pol%init (s)
      call pol%from_array (a)
      open (newunit = utmp, status = "scratch", action = "readwrite", &
           form = "unformatted")
      call pol%write_raw (utmp)
      rewind (utmp)
      call pol%read_raw (utmp, iostat=iostat)
      close (utmp)
      call pol%to_array (a)
      write (u, "(*(F7.4))")  a
    end subroutine bloch_io

  end subroutine bloch_vectors_4

@ %def bloch_vectors_4
@
\subsubsection{Convenience Methods}
Check some further TBP that are called by the [[polarizations]]
module.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_5, "bloch_vectors_5", &
       "massless state (unpolarized)", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_5
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_5 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_5"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Massless states: equipartition"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_massless_unpol (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_massless_unpol (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_massless_unpol (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_massless_unpol (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_massless_unpol (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_5"    
      
  contains
    
    subroutine bloch_massless_unpol (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      complex(default), dimension(:,:), allocatable :: r
      real(default), dimension(:), allocatable :: a
      integer :: d
      d = fundamental_dimension (s)
      call pol%init_max_weight (s)
      call pol%to_matrix (r, only_max_weight = .false.)
      write (u, *)
      where (abs (r) < 1.e-14_default)  r = 0
      call write_matrix (d, r)
      call pol%to_matrix (r, only_max_weight = .true.)
      write (u, *)
      call write_matrix (d, r)
    end subroutine bloch_massless_unpol

    subroutine write_matrix (d, r)
      integer, intent(in) :: d
      complex(default), dimension(:,:), intent(in) :: r
      integer :: i, j
      do i = 1, d
         do j = 1, d
            write (u, 1, advance="no")  r(i,j)
         end do
         write (u, *)
      end do
1     format (99(1X,'(',F7.4,',',F7.4,')',:))
    end subroutine write_matrix

  end subroutine bloch_vectors_5

@ %def bloch_vectors_5
@
\subsubsection{Massless state (arbitrary)}
Initialize the Bloch vector with an arbitrarily chosen pure state
which consists only of highest-weight components.  Transform back to
the density matrix.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_6, "bloch_vectors_6", &
       "massless state (arbitrary)", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_6
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_6 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_6"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization (pure polarized massless, arbitrary):"
    write (u, "(A)")  "*   input matrix, transform, display norm, transform back"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_massless (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_massless (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_massless (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_massless (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_massless (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_6"    
      
  contains
    
    subroutine bloch_massless (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      complex(default), dimension(:,:), allocatable :: r
      integer :: d
      d = fundamental_dimension (s)
      write (u, *)
      call init_matrix (d, r)
      call write_matrix (d, r)
      call pol%init (s, r)
      write (u, *)
      write (u, 2)  pol%get_norm (), pol%is_diagonal ()
      write (u, *)
      call pol%to_matrix (r, only_max_weight = .true.)
      call write_matrix (d, r)
2     format (1X,F7.4,1X,L1)
    end subroutine bloch_massless

    subroutine init_matrix (d, r)
      integer, intent(in) :: d
      complex(default), dimension(:,:), allocatable, intent(out) :: r
      complex(default), dimension(:), allocatable :: a
      real(default) :: norm
      integer :: i, j
      allocate (a (d), source = (0._default, 0._default))
      norm = 0
      do i = 1, d, max (d-1, 1)
         a(i) = cmplx (2*i-1, 2*i, kind=default)
         norm = norm + conjg (a(i)) * a(i)
      end do
      a = a / sqrt (norm)
      allocate (r (d,d), source = (0._default, 0._default))
      do i = 1, d, max (d-1, 1)
         do j = 1, d, max (d-1, 1)
            r(i,j) = conjg (a(i)) * a(j)
         end do
      end do
    end subroutine init_matrix
    
    subroutine write_matrix (d, r)
      integer, intent(in) :: d
      complex(default), dimension(:,:), intent(in) :: r
      integer :: i, j
      do i = 1, d
         do j = 1, d
            write (u, 1, advance="no")  r(i,j)
         end do
         write (u, *)
      end do
1     format (99(1X,'(',F7.4,',',F7.4,')',:))
    end subroutine write_matrix

  end subroutine bloch_vectors_6

@ %def bloch_vectors_6
@
\subsubsection{Massless state (Bloch vector)}
Initialize the (generalized) Bloch vector with an ordinary
three-component Bloch vector that applies to the highest-weight part only.
<<Bloch vectors: execute tests>>=
  call test (bloch_vectors_7, "bloch_vectors_7", &
       "massless state (vector)", &
       u, results)
<<Bloch vectors: test declarations>>= 
  public :: bloch_vectors_7
<<Bloch vectors: tests>>= 
  subroutine bloch_vectors_7 (u)
    integer, intent(in) :: u

    write (u, "(A)")  "* Test output: bloch_vectors_7"
    write (u, "(A)")  "*   Purpose: test Bloch-vector &
         &polarization implementation"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization &
         &(pure polarized massless, arbitrary Bloch vector):"
    write (u, "(A)")  "*   input vector, transform, display norm, &
         &transform back"

    write (u, "(A)")
    write (u, "(A)")  "* s = 0"
    call bloch_massless_vector (SCALAR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1/2"
    call bloch_massless_vector (SPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 1"
    call bloch_massless_vector (VECTOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 3/2"
    call bloch_massless_vector (VECTORSPINOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* s = 2"
    call bloch_massless_vector (TENSOR)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: bloch_vectors_7"    
      
  contains
    
    subroutine bloch_massless_vector (s)
      integer, intent(in) :: s
      type(bloch_vector_t) :: pol
      real(default), dimension(3) :: a
      complex(default), dimension(:,:), allocatable :: r
      write (u, *)
      a =  [1._default, 2._default, 4._default]
      a = a / sqrt (sum (a ** 2))
      write (u, 2)  a
      call pol%init_vector (s, a)
      write (u, 2)  pol%get_norm ()
      call pol%to_vector (a)
      write (u, 2)  a
      call pol%to_matrix (r, only_max_weight = .false.)
      write (u, *)
      where (abs (r) < 1.e-14_default)  r = 0
      call write_matrix (r)
      call pol%to_matrix (r, only_max_weight = .true.)
      write (u, *)
      call write_matrix (r)
2     format (99(1X,F7.4,:))
    end subroutine bloch_massless_vector

    subroutine write_matrix (r)
      complex(default), dimension(:,:), intent(in) :: r
      integer :: i, j
      do i = 1, size (r, 1)
         do j = 1, size (r, 2)
            write (u, 1, advance="no")  r(i,j)
         end do
         write (u, *)
      end do
1     format (99(1X,'(',F7.4,',',F7.4,')',:))
    end subroutine write_matrix

  end subroutine bloch_vectors_7

@ %def bloch_vectors_7
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polarization}
Using generalized Bloch vectors and the $su(N)$ algebra (see above)
for the internal representation, we can define various modes of
polarization.  For 
spin-1/2, and analogously for massless spin-$s$ particles, we introduce
\begin{enumerate}
\item Trivial polarization: $\vec\alpha=0$. [This is unpolarized, but
  distinct from the particular undefined polarization matrix which has
  the same meaning.]
\item Circular polarization: $\vec\alpha$ points in $\pm z$ direction.
\item Transversal polarization: $\vec\alpha$ points orthogonal to the
  $z$ direction, with a phase $\phi$ that is $0$ for the $x$ axis, and
  $\pi/2=90^\circ$ for the $y$ axis.  For antiparticles, the phase
  switches sign, corresponding to complex conjugation.
\item Axis polarization, where we explicitly give $\vec\alpha$.
\end{enumerate}
For higher spin, we retain this definition, but apply it to the two
components with maximum and minimum weight.  In effect, we concentrate
on the first three entries in the $\alpha^a$ array.  For massless
particles, this is sufficient.  For massive particles, we then add the
possibilities:
\begin{enumerate}\setcounter{enumi}{4}
\item Longitudinal polarization: Only the 0-component is set.  This is
  possible only for bosons.
\item Diagonal polarization: Explicitly specify all components in the
  helicity basis.  The $su(N)$ representation consists of diagonal
  generators only, the Cartan subalgebra.
\end{enumerate}
Obviously, this does not exhaust the possible density matrices for
higher spin, but it should cover practical applications.
<<[[polarizations.f90]]>>=
<<File header>>

module polarizations

<<Use kinds>>
  use io_units
  use format_defs, only: FMT_19
  use diagnostics
  use physics_defs, only: SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices
  use bloch_vectors

<<Standard module head>>

<<Polarizations: public>>

<<Polarizations: types>>

<<Polarizations: interfaces>>

contains

<<Polarizations: procedures>>

end module polarizations
@ %def polarizations
@ 
\subsection{The polarization type}
Polarization is active whenever the coefficient array is allocated.
For convenience, we store the spin type ($2s$) and the multiplicity
($N$) together with the coefficient array ($\alpha$).  We have to allow for
the massless case where $s$ is arbitrary $>0$ but $N=2$, and
furthermore the chiral massless case where $N=1$.  In the latter case,
the array remains deallocated but the chirality is set to $\pm 1$.

There is a convention that an antiparticle transforms according to the
complex conjugate representation.  We apply this only when
transforming from/to polarization defined by a three-vector.  For
antiparticles, the two-component flips sign in that case.  When
transforming from/to a state matrix or [[pmatrix]] representation, we
do not apply this sign flip.

TODO: Check these conventions for consistency.
<<Polarizations: public>>=
  public :: polarization_t
<<Polarizations: types>>=
  type :: polarization_t
     private
     integer :: spin_type = SCALAR
     integer :: multiplicity = 1
     integer :: chirality = 0
     logical :: anti = .false.
     type(bloch_vector_t) :: bv
   contains
   <<Polarizations: polarization: TBP>>
  end type polarization_t

@ %def polarization_t
@ 
\subsection{Basic initializer and finalizer}
We need the particle flavor for determining the allowed helicity
values.  The Bloch vector is left undefined, so this initializer (in
two versions) creates an unpolarized particle.  Exception: a chiral
particle is always polarized with definite helicity, it doesn't need a
Bloch vector.

This is private.
<<Polarizations: polarization: TBP>>=
  generic, private :: init => polarization_init, polarization_init_flv
  procedure, private :: polarization_init
  procedure, private :: polarization_init_flv
<<Polarizations: procedures>>=
  subroutine polarization_init (pol, spin_type, multiplicity, &
       anti, left_handed, right_handed)
    class(polarization_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    integer, intent(in) :: multiplicity
    logical, intent(in) :: anti
    logical, intent(in) :: left_handed
    logical, intent(in) :: right_handed
    pol%spin_type = spin_type
    pol%multiplicity = multiplicity
    pol%anti = anti
    select case (pol%multiplicity)
    case (1)
       if (left_handed) then
          pol%chirality = -1
       else if (right_handed) then
          pol%chirality = 1
       end if
    end select
    select case (pol%chirality)
    case (0)
       call pol%bv%init_unpolarized (spin_type)
    end select
  end subroutine polarization_init
    
  subroutine polarization_init_flv (pol, flv)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    call pol%init ( &
         spin_type = flv%get_spin_type (), &
         multiplicity = flv%get_multiplicity (), &
         anti = flv%is_antiparticle (), &
         left_handed = flv%is_left_handed (), &
         right_handed = flv%is_right_handed ())
  end subroutine polarization_init_flv
    
@ %def polarization_init polarization_init_flv
@ Generic polarization: as before, but create a polarized particle
(Bloch vector defined) with initial polarization zero.
<<Polarizations: polarization: TBP>>=
  generic :: init_generic => &
       polarization_init_generic, &
       polarization_init_generic_flv
  procedure, private :: polarization_init_generic
  procedure, private :: polarization_init_generic_flv
<<Polarizations: procedures>>=
  subroutine polarization_init_generic (pol, spin_type, multiplicity, &
       anti, left_handed, right_handed)
    class(polarization_t), intent(out) :: pol
    integer, intent(in) :: spin_type
    integer, intent(in) :: multiplicity
    logical, intent(in) :: anti
    logical, intent(in) :: left_handed
    logical, intent(in) :: right_handed
    call pol%init (spin_type, multiplicity, &
         anti, left_handed, right_handed)
    select case (pol%chirality)
    case (0)
       if (pol%multiplicity == pol%bv%get_n_states ()) then
          call pol%bv%init (spin_type)
       else
          call pol%bv%init_max_weight (spin_type)
       end if
    end select
  end subroutine polarization_init_generic

  subroutine polarization_init_generic_flv (pol, flv)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    call pol%init_generic ( &
         spin_type = flv%get_spin_type (), &
         multiplicity = flv%get_multiplicity (), &
         anti = flv%is_antiparticle (), &
         left_handed = flv%is_left_handed (), &
         right_handed = flv%is_right_handed ())
  end subroutine polarization_init_generic_flv

@ %def polarization_init_generic
@ A finalizer is no longer necessary.

\subsection{I/O}
The default setting produces a tabular output of the polarization
vector entries.  Optionally, we can create a state matrix and write
its contents, emulating the obsolete original implementation.

If [[all_states]] is true (default), we generate all helity
combinations regardless of the matrix-element value.  Otherwise, skip
helicities with zero entry, or absolute value less than [[tolerance]],
if also given.
<<Polarizations: polarization: TBP>>=
  procedure :: write => polarization_write
<<Polarizations: procedures>>=
  subroutine polarization_write (pol, unit, state_matrix, all_states, tolerance)
    class(polarization_t), intent(in) :: pol
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: state_matrix, all_states
    real(default), intent(in), optional :: tolerance
    logical :: state_m
    type(state_matrix_t) :: state
    real(default), dimension(:), allocatable :: a
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    state_m = .false.;  if (present (state_matrix))  state_m = state_matrix
    if (pol%anti) then
       write (u, "(1x,A,I1,A,I1,A,L1,A)")  &
            "Polarization: [spin_type = ", pol%spin_type, &
            ", mult = ", pol%multiplicity, ", anti = ", pol%anti, "]"
    else
       write (u, "(1x,A,I1,A,I1,A)")  &
            "Polarization: [spin_type = ", pol%spin_type, &
            ", mult = ", pol%multiplicity, "]"
    end if
    if (state_m) then
       call pol%to_state (state, all_states, tolerance)
       call state%write (unit=unit)
       call state%final ()
    else if (pol%chirality == 1) then
       write (u, "(1x,A)")  "chirality = +"
    else if (pol%chirality == -1) then
       write (u, "(1x,A)")  "chirality = -"
    else if (pol%bv%is_polarized ()) then
       call pol%bv%to_array (a)
       do i = 1, size (a)
          write (u, "(1x,I2,':',1x,F10.7)")  i, a(i)
       end do
    else
       write (u, "(1x,A)")  "[unpolarized]"
    end if
  end subroutine polarization_write

@ %def polarization_write
@ Binary I/O.
<<Polarizations: polarization: TBP>>=
  procedure :: write_raw => polarization_write_raw
  procedure :: read_raw => polarization_read_raw
<<Polarizations: procedures>>=
  subroutine polarization_write_raw (pol, u)
    class(polarization_t), intent(in) :: pol
    integer, intent(in) :: u
    write (u) pol%spin_type
    write (u) pol%multiplicity
    write (u) pol%chirality
    write (u) pol%anti
    call pol%bv%write_raw (u)
  end subroutine polarization_write_raw

  subroutine polarization_read_raw (pol, u, iostat)
    class(polarization_t), intent(out) :: pol
    integer, intent(in) :: u
    integer, intent(out), optional :: iostat
    read (u, iostat=iostat) pol%spin_type
    read (u, iostat=iostat) pol%multiplicity
    read (u, iostat=iostat) pol%chirality
    read (u, iostat=iostat) pol%anti
    call pol%bv%read_raw (u, iostat)
  end subroutine polarization_read_raw

@ %def polarization_read_raw
@ 
\subsection{Accessing contents}
Return true if the particle is technically polarized.  The particle
is either chiral, or its Bloch vector has been defined.  The
function returns true even if the Bloch vector is zero or the particle
is scalar.
<<Polarizations: polarization: TBP>>=
  procedure :: is_polarized => polarization_is_polarized
<<Polarizations: procedures>>=
  function polarization_is_polarized (pol) result (polarized)
    class(polarization_t), intent(in) :: pol
    logical :: polarized
    polarized = pol%chirality /= 0 .or. pol%bv%is_polarized ()
  end function polarization_is_polarized

@ %def polarization_is_polarized
@ Return true if the polarization is diagonal, i.e., all entries in
the density matrix are diagonal.  For an unpolarized particle, we also
return [[.true.]] since the density matrix is proportional to the unit
matrix.
<<Polarizations: polarization: TBP>>=
  procedure :: is_diagonal => polarization_is_diagonal
<<Polarizations: procedures>>=
  function polarization_is_diagonal (pol) result (diagonal)
    class(polarization_t), intent(in) :: pol
    logical :: diagonal
    select case (pol%chirality)
    case (0)
       diagonal = pol%bv%is_diagonal ()
    case default
       diagonal = .true.
    end select
  end function polarization_is_diagonal

@ %def polarization_is_diagonal
@ 
\subsection{Mapping between polarization and state matrix}
Create the polarization object that corresponds to a state matrix.  The state
matrix is not necessarily normalized.  The result will be either unpolarized,
or a generalized Bloch vector that we compute in terms of the appropriate spin
generator basis.  To this end, we first construct the complete density
matrix, then set the Bloch vector with this input.

For a naturally chiral particle (i.e., neutrino), we do not set the
polarization vector, it is implied.

TODO: The state matrix does not support an antiparticle flag.
Therefore, we cannot account for any sign flip and transform as-is.
<<Polarizations: polarization: TBP>>=
  procedure :: init_state_matrix => polarization_init_state_matrix
<<Polarizations: procedures>>=
  subroutine polarization_init_state_matrix (pol, state)
    class(polarization_t), intent(out) :: pol
    type(state_matrix_t), intent(in), target :: state
    type(state_iterator_t) :: it
    type(flavor_t) :: flv
    type(helicity_t) :: hel
    integer :: d, h1, h2, i, j
    complex(default), dimension(:,:), allocatable :: r
    complex(default) :: me
    real(default) :: trace
    call it%init (state)
    flv = it%get_flavor (1)
    hel = it%get_helicity (1)
    if (hel%is_defined ()) then
       call pol%init_generic (flv)
       select case (pol%chirality)
       case (0)
          trace = 0
          d = pol%bv%get_n_states ()
          allocate (r (d, d), source = (0._default, 0._default))
          do while (it%is_valid ())
             hel = it%get_helicity (1)
             call hel%get_indices (h1, h2)
             i = pol%bv%hel_index (h1)
             j = pol%bv%hel_index (h2)
             me = it%get_matrix_element ()
             r(i,j) = me
             if (i == j)  trace = trace + real (me)
             call it%advance ()
          end do
          if (trace /= 0)  call pol%bv%set (r / trace)
       end select
    else
       call pol%init (flv)
    end if
  end subroutine polarization_init_state_matrix

@ %def polarization_init_state_matrix
@ Create the state matrix that corresponds to a given polarization.  We make
use of the polarization iterator as defined below, which should iterate
according to the canonical helicity ordering.
<<Polarizations: polarization: TBP>>=
  procedure :: to_state => polarization_to_state_matrix
<<Polarizations: procedures>>=
  subroutine polarization_to_state_matrix (pol, state, all_states, tolerance)
    class(polarization_t), intent(in), target :: pol
    type(state_matrix_t), intent(out) :: state
    logical, intent(in), optional :: all_states
    real(default), intent(in), optional :: tolerance
    type(polarization_iterator_t) :: it
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    call it%init (pol, all_states, tolerance)
    call state%init (store_values = .true.)
    do while (it%is_valid ())
       value = it%get_value ()
       qn(1) = it%get_quantum_numbers ()
       call state%add_state (qn, value = value)
       call it%advance ()
    end do
    call state%freeze ()
  end subroutine polarization_to_state_matrix
    
@ %def polarization_to_state_matrix
@
\subsection{Specific initializers}
Unpolarized particle, no nontrivial entries in the density matrix.  This
is the default initialization mode.
<<Polarizations: polarization: TBP>>=
  procedure :: init_unpolarized => polarization_init_unpolarized
<<Polarizations: procedures>>=
  subroutine polarization_init_unpolarized (pol, flv)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    call pol%init (flv)
  end subroutine polarization_init_unpolarized
    
@ %def polarization_init_unpolarized
@ The following three modes are useful mainly for spin-1/2 particle
and massless particles of any nonzero spin.  Only the highest-weight
components are filled.

Circular polarization: The density matrix of the two highest-weight
states is
\begin{equation*}
  \rho(f) = 
  \frac{1-|f|}{2}\mathbf{1} +
  |f| \times
  \begin{cases}
    \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}, & f > 0; \\[6pt]
    \begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}, & f < 0,
  \end{cases}
\end{equation*}
In the generalized Bloch representation, this is an entry for the $T^3$
generator only, regardless of the spin representation.

A chiral particle is not affected.
<<Polarizations: polarization: TBP>>=
  procedure :: init_circular => polarization_init_circular
<<Polarizations: procedures>>=
  subroutine polarization_init_circular (pol, flv, f)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: f
    call pol%init (flv)
    select case (pol%chirality)
    case (0)
       call pol%bv%init_vector (pol%spin_type, &
            [0._default, 0._default, f])
    end select
  end subroutine polarization_init_circular

@ %def polarization_init_circular
@ Transversal polarization is analogous to circular, but we get a
density matrix
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1-|f|}{2}\mathbf{1}
  + \frac{|f|}{2}  \begin{pmatrix} 1 & e^{-i\phi} \\ e^{i\phi} & 1
  \end{pmatrix}.
\end{equation*}
for the highest-weight subspace.  The lower weights are unaffected.
The phase is $\phi=0$ for the $x$-axis, $\phi=90^\circ$ for the $y$
axis as polarization vector.  

For an antiparticle, the phase switches sign, and for $f<0$, the
off-diagonal elements switch sign.

A chiral particle is not affected.
<<Polarizations: polarization: TBP>>=
  procedure :: init_transversal => polarization_init_transversal
<<Polarizations: procedures>>=
  subroutine polarization_init_transversal (pol, flv, phi, f)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: phi, f
    call pol%init (flv)
    select case (pol%chirality)
    case (0)
       if (pol%anti) then
          call pol%bv%init_vector (pol%spin_type, &
               [f * cos (phi), f * sin (phi), 0._default])
       else
          call pol%bv%init_vector (pol%spin_type, &
               [f * cos (phi),-f * sin (phi), 0._default])
       end if
    end select
  end subroutine polarization_init_transversal

@ %def polarization_init_transversal
@ For axis polarization, we again set only the entries with maximum weight,
which for spin $1/2$ means
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1}{2} \begin{pmatrix} 
                 1 + \alpha_3 & \alpha_1 - i\alpha_2 \\ 
                 \alpha_1 + i\alpha_2 & 1 - \alpha_3 
              \end{pmatrix}.
\end{equation*}
For an antiparticle, the imaginary part proportional to $\alpha_2$ switches
sign (complex conjugate).  A chiral particle is not affected.

In the generalized Bloch representation, this translates into coefficients for
$T^{1,2,3}$, all others stay zero.
<<Polarizations: polarization: TBP>>=
  procedure :: init_axis => polarization_init_axis
<<Polarizations: procedures>>=
  subroutine polarization_init_axis (pol, flv, alpha)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(3), intent(in) :: alpha
    call pol%init (flv)
    select case (pol%chirality)
    case (0)
       if (pol%anti) then
          call pol%bv%init_vector (pol%spin_type, &
               [alpha(1), alpha(2), alpha(3)])
       else
          call pol%bv%init_vector (pol%spin_type, &
               [alpha(1),-alpha(2), alpha(3)])
       end if
    end select
  end subroutine polarization_init_axis

@ %def polarization_init_axis
@ This version specifies the polarization axis in terms of $r$
(polarization degree) and $\theta,\phi$ (polar and azimuthal angles).

If one of the angles is a nonzero multiple of $\pi$, roundoff errors
typically will result in tiny contributions to unwanted components.
Therefore, include a catch for small numbers.
<<Polarizations: polarization: TBP>>=
  procedure :: init_angles => polarization_init_angles
<<Polarizations: procedures>>=
  subroutine polarization_init_angles (pol, flv, r, theta, phi)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default), parameter :: eps = 10 * epsilon (1._default)
    
    alpha(1) = r * sin (theta) * cos (phi)
    alpha(2) = r * sin (theta) * sin (phi)
    alpha(3) = r * cos (theta)
    where (abs (alpha) < eps)  alpha = 0
    call pol%init_axis (flv, alpha)
  end subroutine polarization_init_angles

@ %def polarization_init_angles
@ Longitudinal polarization is defined only for massive bosons.  Only
the zero component is filled.  Otherwise, unpolarized.

In the generalized Bloch representation, the zero component corresponds to a
linear combination of all diagonal (Cartan) generators.
<<Polarizations: polarization: TBP>>=
  procedure :: init_longitudinal => polarization_init_longitudinal
<<Polarizations: procedures>>=
  subroutine polarization_init_longitudinal (pol, flv, f)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: f
    real(default), dimension(:), allocatable :: rd
    integer :: s, d
    s = flv%get_spin_type ()
    select case (s)
    case (VECTOR, TENSOR)
       call pol%init_generic (flv)
       if (pol%bv%is_polarized ()) then
          d = pol%bv%get_n_states ()
          allocate (rd (d), source = 0._default)
          rd(pol%bv%hel_index (0)) = f
          call pol%bv%set (rd)
       end if
    case default
       call pol%init_unpolarized (flv)
    end select
  end subroutine polarization_init_longitudinal

@ %def polarization_init_longitudinal
@ This is diagonal polarization: we specify all components explicitly.
[[rd]] is the array of diagonal elements of the density matrix.  We
assume that the length of [[rd]] is equal to the particle
multiplicity.
<<Polarizations: polarization: TBP>>=
  procedure :: init_diagonal => polarization_init_diagonal
<<Polarizations: procedures>>=
  subroutine polarization_init_diagonal (pol, flv, rd)
    class(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(:), intent(in) :: rd
    real(default) :: trace
    call pol%init_generic (flv)
    if (pol%bv%is_polarized ()) then
       trace = sum (rd)
       if (trace /= 0)  call pol%bv%set (rd / trace)
    end if
  end subroutine polarization_init_diagonal

@ %def polarization_init_diagonal
@ 
\subsection{Operations}
Combine polarization states by computing the outer product of the
state matrices.
<<Polarizations: public>>=
  public :: combine_polarization_states
<<Polarizations: procedures>>=
  subroutine combine_polarization_states (pol, state)
    type(polarization_t), dimension(:), intent(in), target :: pol
    type(state_matrix_t), intent(out) :: state
    type(state_matrix_t), dimension(size(pol)), target :: pol_state
    integer :: i
    do i = 1, size (pol)
       call pol(i)%to_state (pol_state(i))
    end do
    call outer_multiply (pol_state, state)
    do i = 1, size (pol)
       call pol_state(i)%final ()
    end do
  end subroutine combine_polarization_states

@ %def combine_polarization_states
@ Transform a polarization density matrix into a polarization vector.  This is
possible without information loss only for spin-1/2 and for massless
particles.  To get a unique answer in all cases, we consider only the
components with highest weight.  Obviously, this loses the longitudinal
component of a massive vector, for instance.  The norm of the returned axis is
the polarization fraction for the highest-weight subspace.  For a scalar
particle, we return a zero vector.  The same result applies if the
highest-weight component vanishes.

This is the inverse operation of [[polarization_init_axis]] above,
where the polarization fraction is set to unity.

For an antiparticle, the [[alpha(2)]] coefficient flips sign.
<<Polarizations: polarization: TBP>>=
  procedure :: get_axis => polarization_get_axis
<<Polarizations: procedures>>=
  function polarization_get_axis (pol) result (alpha)
    class(polarization_t), intent(in), target :: pol
    real(default), dimension(3) :: alpha
    select case (pol%chirality)
    case (0)
       call pol%bv%to_vector (alpha)
       if (.not. pol%anti)  alpha(2) = - alpha(2)
    case (-1)
       alpha = [0._default, 0._default, -1._default]
    case (1)
       alpha = [0._default, 0._default, 1._default]
    end select
  end function polarization_get_axis

@ %def polarization_get_axis
@ This function returns polarization degree and polar and azimuthal
angles ($\theta,\phi$) of the polarization axis.  The same restrictions apply
as above.

Since we call the [[get_axis]] method, the phase flips sign for an
antiparticle.
<<Polarizations: polarization: TBP>>=
  procedure :: to_angles => polarization_to_angles
<<Polarizations: procedures>>=
  subroutine polarization_to_angles (pol, r, theta, phi)
    class(polarization_t), intent(in) :: pol
    real(default), intent(out) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default) :: norm, r12
    alpha = pol%get_axis ()
    norm = sum (alpha**2)
    r = sqrt (norm)
    if (norm > 0) then
       r12 = sqrt (alpha(1)**2 + alpha(2)**2)
       theta = atan2 (r12, alpha(3))
       if (any (alpha(1:2) /= 0)) then
          phi = atan2 (alpha(2), alpha(1))
       else
          phi = 0
       end if
    else
       theta = 0
       phi = 0
    end if
  end subroutine polarization_to_angles

@ %def polarization_to_angles
@
\subsection{Polarization Iterator}
The iterator acts like a state matrix iterator, i.e., it points to one
helicity combination at a time and can return the corresponding helicity
object and matrix-element value.

Since the polarization is stored as a Bloch vector, we recover the
whole density matrix explicitly upon initialization, store it inside
the iterator object, and then just return its elements one at a time.

For an unpolarized particle, the iterator returns a single state with
undefined helicity.  The value is the value of any diagonal density
matrix element, $1/n$ where $n$ is the multiplicity.
<<Polarizations: public>>=
  public :: polarization_iterator_t
<<Polarizations: types>>=
  type :: polarization_iterator_t
     private
     type(polarization_t), pointer :: pol => null ()
     logical :: polarized = .false.
     integer :: h1 = 0
     integer :: h2 = 0
     integer :: i = 0
     integer :: j = 0
     complex(default), dimension(:,:), allocatable :: r
     complex(default) :: value = 1._default
     real(default) :: tolerance = -1._default
     logical :: valid = .false.
   contains
   <<Polarizations: polarization iterator: TBP>>
  end type polarization_iterator_t
  
@ %def polarization_iterator_t
@ Output for debugging purposes only, therefore no format for real/complex.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: write => polarization_iterator_write
<<Polarizations: procedures>>=
  subroutine polarization_iterator_write (it, unit)
    class(polarization_iterator_t), intent(in) :: it
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1X,A)")  "Polarization iterator:"
    write (u, "(3X,A,L1)")  "assigned = ", associated (it%pol)
    write (u, "(3X,A,L1)")  "valid    = ", it%valid
    if (it%valid) then
       write (u, "(3X,A,2(1X,I2))")  "i, j     = ", it%i, it%j
       write (u, "(3X,A,2(1X,I2))")  "h1, h2   = ", it%h1, it%h2
       write (u, "(3X,A)", advance="no")  "value    = "
       write (u, *)  it%value
       if (allocated (it%r)) then
          do i = 1, size (it%r, 2)
             write (u, *)  it%r(i,:)
          end do
       end if
    end if
  end subroutine polarization_iterator_write
  
@ %def polarization_iterator_write
@ Initialize, i.e., (virtually) point to the first helicity state
supported by the polarization object.  If the density matrix is
nontrivial, we calculate it here.

Following the older state-matrix
conventions, the iterator sequence starts at the lowest helicity
value.  In the current internal representation, this corresponds to
the highest index value. 

If the current matrix-element value is zero, advance the iterator.
Advancing will stop at a nonzero value or if the iterator becomes
invalid.

If [[tolerance]] is given, any state matrix entry less or equal will
be treated as zero, causing the iterator to skip an entry.  By
default, the value is negative, so no entry is skipped.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: init => polarization_iterator_init
<<Polarizations: procedures>>=
  subroutine polarization_iterator_init (it, pol, all_states, tolerance)
    class(polarization_iterator_t), intent(out) :: it
    type(polarization_t), intent(in), target :: pol
    logical, intent(in), optional :: all_states
    real(default), intent(in), optional :: tolerance
    integer :: d
    logical :: only_max_weight
    it%pol => pol
    if (present (all_states)) then
       if (.not. all_states) then
          if (present (tolerance)) then
             it%tolerance = tolerance
          else
             it%tolerance = 0
          end if
       end if
    end if
    select case (pol%chirality)
    case (0)
       d = pol%bv%get_n_states ()
       only_max_weight = pol%multiplicity < d
       it%polarized = pol%bv%is_polarized ()
       if (it%polarized) then
          it%i = d
          it%j = it%i
          it%h1 = pol%bv%hel_value (it%i)
          it%h2 = it%h1
          call pol%bv%to_matrix (it%r, only_max_weight)
          it%value = it%r(it%i, it%j)
       else
          it%value = 1._default / d
       end if
       it%valid = .true.
    case (1,-1)
       it%polarized = .true.
       select case (pol%spin_type)
       case (SPINOR)
          it%h1 = pol%chirality
       case (VECTORSPINOR)
          it%h1 = 2 * pol%chirality
       end select
       it%h2 = it%h1
       it%valid = .true.
    end select
    if (it%valid .and. abs (it%value) <= it%tolerance)  call it%advance ()
  end subroutine polarization_iterator_init
  
@ %def polarization_iterator_init
@ Advance to the next valid helicity state.  Repeat if the returned value is
zero.

For an unpolarized object, we iterate through the diagonal helicity
states with a constant value.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: advance => polarization_iterator_advance
<<Polarizations: procedures>>=
  recursive subroutine polarization_iterator_advance (it)
    class(polarization_iterator_t), intent(inout) :: it
    if (it%valid) then
       select case (it%pol%chirality)
       case (0)
          if (it%polarized) then
             if (it%j > 1) then
                it%j = it%j - 1
                it%h2 = it%pol%bv%hel_value (it%j)
                it%value = it%r(it%i, it%j)
             else if (it%i > 1) then
                it%j = it%pol%bv%get_n_states ()
                it%h2 = it%pol%bv%hel_value (it%j)
                it%i = it%i - 1
                it%h1 = it%pol%bv%hel_value (it%i)
                it%value = it%r(it%i, it%j)
             else
                it%valid = .false.
             end if
          else
             it%valid = .false.
          end if
       case default
          it%valid = .false.
       end select
       if (it%valid .and. abs (it%value) <= it%tolerance)  call it%advance ()
    end if
  end subroutine polarization_iterator_advance

@ %def polarization_iterator_advance
@ This is true as long as the iterator points to a valid helicity state.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: is_valid => polarization_iterator_is_valid
<<Polarizations: procedures>>=
  function polarization_iterator_is_valid (it) result (is_valid)
    logical :: is_valid
    class(polarization_iterator_t), intent(in) :: it
    is_valid = it%valid
  end function polarization_iterator_is_valid

@ %def polarization_iterator_is_valid
@ Return the matrix element value for the helicity that we are currently
pointing at.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: get_value => polarization_iterator_get_value
<<Polarizations: procedures>>=
  function polarization_iterator_get_value (it) result (value)
    complex(default) :: value
    class(polarization_iterator_t), intent(in) :: it
    if (it%valid) then
       value = it%value
    else
       value = 0
    end if
  end function polarization_iterator_get_value
  
@ %def polarization_iterator_get_value
@ Return a quantum number object for the helicity that we are currently
pointing at.  This is a single quantum number object, not an array.

Note that the [[init]] method of the helicity object has the order reversed.
<<Polarizations: polarization iterator: TBP>>=
  procedure :: get_quantum_numbers => polarization_iterator_get_quantum_numbers
<<Polarizations: procedures>>=
  function polarization_iterator_get_quantum_numbers (it) result (qn)
    class(polarization_iterator_t), intent(in) :: it
    type(helicity_t) :: hel
    type(quantum_numbers_t) :: qn
    if (it%polarized) then
       call hel%init (it%h2, it%h1)
    end if
    call qn%init (hel)
  end function polarization_iterator_get_quantum_numbers
    
@ %def polarization_iterator_get_quantum_numbers
@
\subsection{Sparse Matrix}
We introduce a simple implementation of a sparse matrix that can represent
polarization (or similar concepts) for transfer to I/O within the
program.  It consists of an integer array that represents the index 
values, and a complex array that represents the nonvanishing entries.  The
number of nonvanishing entries must be known for initialization, but the
entries are filled one at a time.

Here is a base type without the special properties of a spin-density matrix.
<<Polarizations: public>>=
  public :: smatrix_t
<<Polarizations: types>>=
  type :: smatrix_t
     private
     integer :: dim = 0
     integer :: n_entry = 0
     integer, dimension(:,:), allocatable :: index
     complex(default), dimension(:), allocatable :: value
   contains
   <<Polarizations: smatrix: TBP>>
  end type smatrix_t
  
@ %def smatrix_t
@ Output.
<<Polarizations: smatrix: TBP>>=
  procedure :: write => smatrix_write
<<Polarizations: procedures>>=
  subroutine smatrix_write (object, unit, indent)
    class(smatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (allocated (object%value)) then
       if (size (object%value) > 0) then
          do i = 1, object%n_entry
             write (u, "(1x,A,'@(')", advance="no")  repeat ("  ", ind)
             write (u, "(SP,9999(I2.1,':',1x))", advance="no") &
                  object%index(:,i)
             write (u, "('('," // FMT_19 // ",','," // FMT_19 // &
                  ",'))')")  object%value(i)
          end do
       else
          write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
          write (u, "(A)")  "[empty matrix]"
       end if
    else
       write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
       write (u, "(A)")  "[undefined matrix]"
    end if
  end subroutine smatrix_write
  
@ %def smatrix_write
@ Initialization: allocate arrays to the correct size.  We specify both the
dimension of the matrix (if different from two, this is rather a generic
tensor) and the number of nonvanishing entries.
<<Polarizations: smatrix: TBP>>=
  procedure :: init => smatrix_init
<<Polarizations: procedures>>=
  subroutine smatrix_init (smatrix, dim, n_entry)
    class(smatrix_t), intent(out) :: smatrix
    integer, intent(in) :: dim
    integer, intent(in) :: n_entry
    smatrix%dim = dim
    smatrix%n_entry = n_entry
    allocate (smatrix%index (dim, n_entry))
    allocate (smatrix%value (n_entry))
  end subroutine smatrix_init
  
@ %def smatrix_init
@ Fill: one entry at a time.
<<Polarizations: smatrix: TBP>>=
  procedure :: set_entry => smatrix_set_entry
<<Polarizations: procedures>>=
  subroutine smatrix_set_entry (smatrix, i, index, value)
    class(smatrix_t), intent(inout) :: smatrix
    integer, intent(in) :: i
    integer, dimension(:), intent(in) :: index
    complex(default), intent(in) :: value
    smatrix%index(:,i) = index
    smatrix%value(i) = value
  end subroutine smatrix_set_entry
  
@ %def smatrix_set_entry
@
<<Polarizations: smatrix: TBP>>=
  procedure :: exists => smatrix_exists
<<Polarizations: procedures>>=
  elemental function smatrix_exists (smatrix) result (exist)
    logical :: exist
    class(smatrix_t), intent(in) :: smatrix
    exist = .not. all (smatrix%value == 0)
  end function smatrix_exists

@ %def smatrix_exists
@
\subsection{Polarization Matrix}
As an extension of the more generic [[smatrix]] type, we implement a proper
spin-density matrix.  After the matrix has been filled, we can fix spin type
and multiplicity for a particle, check the matrix for consistency, and
normalize it if necessary.

TODO: This implementation does not have an antiparticle flag, just
like the state matrix object.  We therefore cannot account for sign
flips when using this object.

TODO: The [[pure]] flag is for informational purposes only, and it
only represents a necessary condition if spin is greater than $1/2$.
We may either check purity for all spins or drop this.
<<Polarizations: public>>=
  public :: pmatrix_t
<<Polarizations: types>>=
  type, extends (smatrix_t) :: pmatrix_t
     private
     integer :: spin_type = 0
     integer :: multiplicity = 0
     logical :: massive = .true.
     integer :: chirality = 0
     real(default) :: degree = 1
     logical :: pure = .false.
   contains
   <<Polarizations: pmatrix: TBP>>
  end type pmatrix_t
  
@ %def pmatrix_t
@ Output, including extra data.  (The [[indent]] argument is ignored.)
<<Polarizations: pmatrix: TBP>>=
  procedure :: write => pmatrix_write
<<Polarizations: procedures>>=
  subroutine pmatrix_write (object, unit, indent)
    class(pmatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Polarization: spin density matrix"
    write (u, "(3x,A,I0)")  "spin type     = ", object%spin_type
    write (u, "(3x,A,I0)")  "multiplicity  = ", object%multiplicity
    write (u, "(3x,A,L1)")  "massive       = ", object%massive
    write (u, "(3x,A,I0)")  "chirality     = ", object%chirality
    write (u, "(3x,A,F10.7)")  "pol.degree    =", object%degree
    write (u, "(3x,A,L1)")  "pure state    = ", object%pure
    call object%smatrix_t%write (u, 1)
  end subroutine pmatrix_write
  
@ %def pmatrix_write
@ This assignment is trivial, but must be coded explicitly.
<<Polarizations: pmatrix: TBP>>=
  generic :: assignment(=) => pmatrix_assign_from_smatrix
  procedure, private :: pmatrix_assign_from_smatrix
<<Polarizations: procedures>>=
  subroutine pmatrix_assign_from_smatrix (pmatrix, smatrix)
    class(pmatrix_t), intent(out) :: pmatrix
    type(smatrix_t), intent(in) :: smatrix
    pmatrix%smatrix_t = smatrix
  end subroutine pmatrix_assign_from_smatrix
  
@ %def pmatrix_assign_from_smatrix
@ Declare spin, multiplicity, and polarization degree.  Check whether all
entries fit, and whether this is a valid matrix.

The required properties are:
\begin{enumerate}
\item all entries apply to the given spin and mass type
\item the diagonal is real
\item only the upper of corresponding off-diagonal elements is specified,
  i.e., the row index is less than the column index
\item the trace is nonnegative and equal to the polarization degree (the
  remainder, proportional to the unit matrix, is understood to be present)
\item the trace of the matrix square is positive and less or equal
  to the trace of the matrix itself, which is the polarization degree.
\item If the trace of the matrix square and the trace of the matrix are unity,
  we may have a pure state.  (For spin up to $1/2$, this is actually
  sufficient.)
\end{enumerate}
<<Polarizations: pmatrix: TBP>>=
  procedure :: normalize => pmatrix_normalize
<<Polarizations: procedures>>=
  subroutine pmatrix_normalize (pmatrix, flv, degree, tolerance)
    class(pmatrix_t), intent(inout) :: pmatrix
    type(flavor_t), intent(in) :: flv
    real(default), intent(in), optional :: degree
    real(default), intent(in), optional :: tolerance
    integer :: i, hmax
    logical :: fermion, ok
    real(default) :: trace, trace_sq
    real(default) :: tol
    tol = 0;  if (present (tolerance))  tol = tolerance
    pmatrix%spin_type = flv%get_spin_type ()
    pmatrix%massive = flv%get_mass () /= 0
    if (.not. pmatrix%massive) then
       if (flv%is_left_handed ()) then
          pmatrix%chirality = -1
       else if (flv%is_right_handed ()) then
          pmatrix%chirality = +1
       end if
    end if
    if (pmatrix%spin_type == SCALAR) then
       pmatrix%multiplicity = 1
    else if (pmatrix%massive) then
       pmatrix%multiplicity = pmatrix%spin_type
    else if (pmatrix%chirality == 0) then
       pmatrix%multiplicity = 2
    else
       pmatrix%multiplicity = 1
    end if
    if (present (degree)) then
       if (degree < 0 .or. degree > 1) &
            call msg_error ("polarization degree must be between 0 and 1")
       pmatrix%degree = degree
    end if
    if (size (pmatrix%index, 1) /= 2)  call error ("wrong array rank")
    fermion = mod (pmatrix%spin_type, 2) == 0
    hmax = pmatrix%spin_type / 2
    if (pmatrix%n_entry > 0) then
       if (fermion) then
          if (pmatrix%massive) then
             ok = all (pmatrix%index /= 0) &
                  .and. all (abs (pmatrix%index) <= hmax)
          else if (pmatrix%chirality == -1) then
             ok = all (pmatrix%index == -hmax)
          else if (pmatrix%chirality == +1) then
             ok = all (pmatrix%index == +hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       else
          if (pmatrix%massive) then
             ok = all (abs (pmatrix%index) <= hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       end if
       if (.not. ok)  call error ("illegal index value")
    else
       pmatrix%degree = 0
       pmatrix%pure = pmatrix%multiplicity == 1
       return
    end if
    trace = 0
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            if (abs (aimag (value)) > tol)  call error ("diagonal must be real")
            value = real (value, kind=default)
            trace = trace + value
            
         else if (any (pmatrix%index(1,:) == index(2) &
              .and.    pmatrix%index(2,:) == index(1))) then
            call error ("redundant off-diagonal entry")
         else if (index(2) < index (1)) then
            index = index([2,1])
            value = conjg (value)
         end if
       end associate
    end do
    if (abs (trace) <= tol)  call error ("trace must not vanish")
    trace = real (trace, kind=default)
    pmatrix%value = pmatrix%value / trace * pmatrix%degree
    trace_sq = (1 - pmatrix%degree ** 2) / pmatrix%multiplicity
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            trace_sq = trace_sq + abs (value) ** 2
         else
            trace_sq = trace_sq + 2 * abs (value) ** 2
         end if
       end associate
    end do
    if (pmatrix%multiplicity == 1) then
       pmatrix%pure = .true.
    else if (abs (trace_sq - 1) <= tol) then
       pmatrix%pure = .true.
    else if (trace_sq - 1 > tol .or. trace_sq < -tol) then
       print *, "Trace of matrix square = ", trace_sq
       call error ("not permissible as density matrix")
    end if
  contains
    subroutine error (msg)
      character(*), intent(in) :: msg
      call pmatrix%write ()
      call msg_fatal ("Spin density matrix: " // msg)
    end subroutine error
  end subroutine pmatrix_normalize
  
@ %def pmatrix_normalize
@
A polarized matrix is defined as one with a positive polarization degree, even
if the actual matrix is trivial.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_polarized => pmatrix_is_polarized
<<Polarizations: procedures>>=
  elemental function pmatrix_is_polarized (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = pmatrix%degree > 0
  end function pmatrix_is_polarized
  
@ %def pmatrix_is_polarized
@
Check if there are only diagonal entries.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_diagonal => pmatrix_is_diagonal
<<Polarizations: procedures>>=
  elemental function pmatrix_is_diagonal (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = all (pmatrix%index(1,:) == pmatrix%index(2,:))
  end function pmatrix_is_diagonal
  
@ %def pmatrix_is_diagonal
@
\subsection{Data Transformation}
Create a [[polarization_t]] object from the contents of a normalized
[[pmatrix_t]] object.  We scan the entries as present in [[pmatrix]] and
transform them into a density matrix, if necessary.  The density
matrix then initializes the Bloch vector.  This is
analogous to [[polarization_init_state_matrix]].

There is a subtlety associated with massless particles.  Since the
[[pmatrix]] doesn't contain the full density matrix but just the
nontrivial part, we have to initialize the polarization object with
the massless equipartion, which contains nonzero entries for the
Cartan generators.  The [[set]] method therefore should not erase
those initial contents.  This is a constraint for the implementation
of [[set]], as applied to the Bloch vector.

TODO: As mentioned above, [[pmatrix_t]] does not support an
antiparticle flag.
<<Polarizations: polarization: TBP>>=
  procedure :: init_pmatrix => polarization_init_pmatrix
<<Polarizations: procedures>>=
  subroutine polarization_init_pmatrix (pol, pmatrix)
    class(polarization_t), intent(out) :: pol
    type(pmatrix_t), intent(in) :: pmatrix
    integer :: d, i, j, k, h1, h2
    complex(default), dimension(:,:), allocatable :: r
    call pol%init_generic ( &
         spin_type = pmatrix%spin_type, &
         multiplicity = pmatrix%multiplicity, &
         anti = .false., &                     !!! SUFFICIENT?
         left_handed = pmatrix%chirality < 0, &
         right_handed = pmatrix%chirality > 0)
    if (pol%bv%is_polarized ()) then
       d = pol%bv%get_n_states ()
       allocate (r (d, d), source = (0._default, 0._default))
       if (d == pmatrix%multiplicity) then
          do i = 1, d
             r(i,i) = (1 - pmatrix%degree) / d
          end do
       else if (d > pmatrix%multiplicity) then
          r(1,1) = (1 - pmatrix%degree) / 2
          r(d,d) = r(1,1)
       end if
       do k = 1, size (pmatrix%value)
          h1 = pmatrix%index(1,k)
          h2 = pmatrix%index(2,k)
          i = pol%bv%hel_index (h1)
          j = pol%bv%hel_index (h2)
          r(i,j) = r(i,j) + pmatrix%value(k)
          r(j,i) = conjg (r(i,j))
       end do
       call pol%bv%set (r)
    end if
  end subroutine polarization_init_pmatrix

@ %def polarization_init_pmatrix
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[polarizations_ut.f90]]>>=
<<File header>>

module polarizations_ut
  use unit_tests
  use polarizations_uti
  
<<Standard module head>>

<<Polarizations: public test>>

contains
  
<<Polarizations: test driver>>

end module polarizations_ut
@ %def polarizations_ut
@
<<[[polarizations_uti.f90]]>>=
<<File header>>

module polarizations_uti

<<Use kinds>>
  use flavors
  use model_data

  use polarizations

<<Standard module head>>

<<Polarizations: test declarations>>

contains

<<Polarizations: tests>>

end module polarizations_uti
@ %def polarizations_ut
@ API: driver for the unit tests below.
<<Polarizations: public test>>=
  public :: polarizations_test
<<Polarizations: test driver>>=
  subroutine polarizations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Polarizations: execute tests>>
  end subroutine polarizations_test

@  %def polarizations_test
@
\subsubsection{Polarization type}
Checking the setup for polarization. 
<<Polarizations: execute tests>>=
  call test (polarization_1, "polarization_1", &
       "check polarization setup", &
       u, results)
<<Polarizations: test declarations>>= 
  public :: polarization_1
<<Polarizations: tests>>= 
  subroutine polarization_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(polarization_t) :: pol
    type(flavor_t) :: flv
    real(default), dimension(3) :: alpha
    real(default) :: r, theta, phi
    real(default), parameter :: tolerance = 1.E-14_default

    write (u, "(A)")  "* Test output: polarization_1"
    write (u, "(A)")  "*   Purpose: test polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)")      
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flv%init (1, model)
    call pol%init_unpolarized (flv)
    call pol%write (u, state_matrix = .true.)
    write (u, "(A,L1)")  "   diagonal =", pol%is_diagonal ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Unpolarized fermion"
    write (u, "(A)") 
    
    call pol%init_circular (flv, 0._default)
    call pol%write (u, state_matrix = .true., all_states = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call pol%init_transversal (flv, 0._default, 1._default)
    call pol%write (u, state_matrix = .true.)
    write (u, "(A,L1)")  "   diagonal =", pol%is_diagonal ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call pol%init_transversal (flv, 0.9_default, 0.8_default)
    call pol%write (u, state_matrix = .true.)
    write (u, "(A,L1)")  "   diagonal =", pol%is_diagonal ()
    
    write (u, "(A)")
    write (u, "(A)") "* All polarization directions of a fermion"
    write (u, "(A)")
    
    call pol%init_generic (flv)
    call pol%write (u, state_matrix = .true.)

    
    call flv%init (21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call pol%init_circular (flv, 0.3_default)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)

    
    call flv%init (23, model)
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=-0.7"
    write (u, "(A)") 
    
    call pol%init_circular (flv,  -0.7_default)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call pol%init_circular (flv, 1._default)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call pol%init_longitudinal (flv, 0.4_default)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call pol%init_longitudinal (flv, 1._default)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Diagonally polarized massive vector"
    write (u, "(A)")
    
    call pol%init_diagonal &
         (flv, [2._default, 1._default, 0._default])
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)") 
    write (u, "(A)")  "* All polarization directions of a massive vector"
    write (u, "(A)") 

    call pol%init_generic (flv)
    call pol%write (u, state_matrix = .true.)
    call flv%init (21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    alpha = [0.2_default, 0.4_default, 0.6_default]
    call pol%init_axis (flv, alpha)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    
    write (u, "(A)")
    write (u, "(1X,A)")  "Recovered axis:"
    alpha = pol%get_axis ()
    write (u, "(3(1X,F10.7))")  alpha
    
    write (u, "(A)")
    write (u, "(A)")  "* Angle polarization (0.5, 0.6, -1)"
    r = 0.5_default
    theta = 0.6_default
    phi = -1._default
    call pol%init_angles (flv, r, theta, phi)
    write (u, "(A)")
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)

    write (u, "(A)")
    write (u, "(1X,A)")  "Recovered parameters (r, theta, phi):"
    call pol%to_angles (r, theta, phi)
    write (u, "(3(1x,F10.7))")  r, theta, phi
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_1"    
      
  end subroutine polarization_1

@ %def polarization_1
@
\subsubsection{Sparse-Matrix type}
Use a sparse density matrix universally as the input for setting up
polarization.
<<Polarizations: execute tests>>=
  call test (polarization_2, "polarization_2", &
       "matrix polarization setup", &
       u, results)
<<Polarizations: test declarations>>= 
  public :: polarization_2
<<Polarizations: tests>>= 
  subroutine polarization_2 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(polarization_t) :: pol
    real(default), dimension(3) :: alpha
    type(pmatrix_t) :: pmatrix
    real(default), parameter :: tolerance = 1e-8_default

    write (u, "(A)")  "* Test output: polarization_2"
    write (u, "(A)")  "*   Purpose: matrix polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flv%init (1, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 0._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], exp ((0._default, -0.9_default)))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true.)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=1"
    write (u, "(A)")
    
    call flv%init (11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=0.8"
    write (u, "(A)")
    
    call flv%init (11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massless fermion"
    write (u, "(A)")
    
    call flv%init (12, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true.)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Right-handed massless fermion, frac=0.5"
    write (u, "(A)")
    
    call flv%init (-12, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.5_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true.)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call flv%init (21, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.3_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()   
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=0.7"
    write (u, "(A)") 
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.7_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.4_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true., &
         all_states = .false., tolerance = tolerance)
    ! call pol%final ()
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    call flv%init (11, model)
    alpha = [0.2_default, 0.4_default, 0.6_default]
    alpha = alpha / sqrt (sum (alpha**2))
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], cmplx (1 - alpha(3), kind=default))
    call pmatrix%set_entry (2, [1,-1], &
         cmplx (alpha(1),-alpha(2), kind=default))
    call pmatrix%set_entry (3, [1,1], cmplx (1 + alpha(3), kind=default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call pol%init_pmatrix (pmatrix)
    call pol%write (u, state_matrix = .true.)
    ! call pol%final ()
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_2"    
      
  end subroutine polarization_2

@ %def polarization_2
@ 
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Particles}
This module defines the [[particle_t]] object type, and the methods
and operations that deal with it.
<<[[particles.f90]]>>=
<<File header>>

module particles

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use format_utils, only: write_compressed_integer_array, write_separator
  use format_utils, only: pac_fmt
  use format_defs, only: FMT_16, FMT_19
  use numeric_utils
  use diagnostics
  use lorentz
  use model_data
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use subevents
  use polarizations
  use pdg_arrays, only: is_quark, is_gluon

<<Standard module head>>

<<Particles: public>>

<<Particles: parameters>>
       
<<Particles: types>>

<<Particles: interfaces>>

contains

<<Particles: procedures>>

end module particles
@ %def particles
@
\subsection{The particle type}
\subsubsection{Particle status codes}
The overall status codes (incoming/outgoing etc.) are inherited from
the module [[subevents]].

Polarization status:
<<Particles: parameters>>=
  integer, parameter, public :: PRT_UNPOLARIZED = 0
  integer, parameter, public :: PRT_DEFINITE_HELICITY = 1
  integer, parameter, public :: PRT_GENERIC_POLARIZATION = 2

@ %def PRT_UNPOLARIZED PRT_DEFINITE_HELICITY PRT_GENERIC_POLARIZATION
@
\subsubsection{Definition}
The quantum numbers are flavor (from which invariant particle
properties can be derived), color, and polarization.  The particle may
be unpolarized.  In this case, [[hel]] and [[pol]] are unspecified.
If it has a definite helicity, the [[hel]] component is defined.  If
it has a generic polarization, the [[pol]] component is defined.  For
each particle we store the four-momentum and the invariant mass
squared, i.e., the squared norm of the four-momentum.  There is also
an optional list of parent and child particles, for bookkeeping in
physical events. The [[vertex]] is an optional component that consists of
a Lorentz 4-vector, denoting the position and time of the vertex
(displaced vertex/time). [[lifetime]] is an optional component that
accounts for the finite lifetime $\tau$ of a decaying particle. In
case there is no magnetic field etc., the true decay vertex of a
particle in the detector would be $\vec{v}^\prime = \vec{v} + \tau
\times \vec{p}/p^0$, where $p^0$ and $\vec{p}$ are the energy and
3-momentum of the particle.

<<Particles: public>>=
  public :: particle_t
<<Particles: types>>=
  type :: particle_t
     !private
     integer :: status = PRT_UNDEFINED
     integer :: polarization = PRT_UNPOLARIZED
     type(flavor_t) :: flv
     type(color_t) :: col
     type(helicity_t) :: hel
     type(polarization_t) :: pol
     type(vector4_t) :: p = vector4_null
     real(default) :: p2 = 0
     type(vector4_t), allocatable :: vertex
     real(default), allocatable :: lifetime
     integer, dimension(:), allocatable :: parent
     integer, dimension(:), allocatable :: child
   contains
  <<Particles: particle: TBP>>  
  end type particle_t

@ %def particle_t
@ Copy a particle.  (Deep copy)  This excludes the parent-child
relations.
<<Particles: particle: TBP>>=
  generic :: init => init_particle
  procedure :: init_particle => particle_init_particle
<<Particles: procedures>>=
  subroutine particle_init_particle (prt_out, prt_in)
    class(particle_t), intent(out) :: prt_out
    type(particle_t), intent(in) :: prt_in
    prt_out%status = prt_in%status
    prt_out%polarization = prt_in%polarization
    prt_out%flv = prt_in%flv
    prt_out%col = prt_in%col
    prt_out%hel = prt_in%hel
    prt_out%pol = prt_in%pol
    prt_out%p = prt_in%p
    prt_out%p2 = prt_in%p2
    if (allocated (prt_in%vertex))  &
       allocate (prt_out%vertex, source=prt_in%vertex)
    if (allocated (prt_in%lifetime))  &
         allocate (prt_out%lifetime, source=prt_in%lifetime)
  end subroutine particle_init_particle

@ %def particle_init_particle
@ Initialize a particle using external information.
<<Particles: particle: TBP>>=
  generic :: init => init_external
  procedure :: init_external => particle_init_external
<<Particles: procedures>>=
  subroutine particle_init_external &
         (particle, status, pdg, model, col, anti_col, mom)
    class(particle_t), intent(out) :: particle
    integer, intent(in) :: status, pdg, col, anti_col
    class(model_data_t), pointer, intent(in) :: model
    type(vector4_t), intent(in) :: mom
    type(flavor_t) :: flavor
    type(color_t) :: color
    call flavor%init (pdg, model)
    call particle%set_flavor (flavor)
    call color%init_col_acl (col, anti_col)
    call particle%set_color (color)
    call particle%set_status (status)
    call particle%set_momentum (mom)
  end subroutine particle_init_external

@ %def particle_init_external
@ Initialize a particle using a single-particle state matrix which
determines flavor, color, and polarization.  The state matrix must
have unique flavor and color.  The factorization mode determines
whether the particle is unpolarized, has definite helicity, or generic
polarization.  This mode is translated into the polarization status.
<<Particles: particle: TBP>>=
  generic :: init => init_state
  procedure :: init_state => particle_init_state
<<Particles: procedures>>=
  subroutine particle_init_state (prt, state, status, mode)
    class(particle_t), intent(out) :: prt
    type(state_matrix_t), intent(in), target :: state
    integer, intent(in) :: status, mode
    type(state_iterator_t) :: it
    prt%status = status
    call it%init (state)
    prt%flv = it%get_flavor (1)
    if (prt%flv%is_radiated ())  prt%status = PRT_BEAM_REMNANT
    prt%col = it%get_color (1)
    select case (mode)
    case (FM_SELECT_HELICITY)
       prt%hel = it%get_helicity (1)
       if (prt%hel%is_defined ()) then
          prt%polarization = PRT_DEFINITE_HELICITY
       end if
    case (FM_FACTOR_HELICITY)
       call prt%pol%init_state_matrix (state)
       prt%polarization = PRT_GENERIC_POLARIZATION
    end select
  end subroutine particle_init_state

@ %def particle_init_state
@ Finalizer.
<<Particles: particle: TBP>>=
  procedure :: final => particle_final
<<Particles: procedures>>=
  subroutine particle_final (prt)
    class(particle_t), intent(inout) :: prt
    if (allocated (prt%vertex))  deallocate (prt%vertex)
    if (allocated (prt%lifetime))  deallocate (prt%lifetime)
  end subroutine particle_final

@ %def particle_final
@ 
\subsubsection{I/O}
<<Particles: particle: TBP>>=
  procedure :: write => particle_write
<<Particles: procedures>>=
  subroutine particle_write (prt, unit, testflag, compressed, polarization)
    class(particle_t), intent(in) :: prt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, compressed, polarization
    logical :: comp, pacified, pol
    integer :: u, h1, h2
    real(default) :: pp2
    character(len=7) :: fmt
    character(len=20) :: buffer
    comp = .false.; if (present (compressed))  comp = compressed
    pacified = .false.;  if (present (testflag))  pacified = testflag
    pol = .true.;  if (present (polarization))  pol = polarization
    call pac_fmt (fmt, FMT_19, FMT_16, testflag)
    u = given_output_unit (unit);  if (u < 0)  return
    pp2 = prt%p2
    if (pacified)  call pacify (pp2, tolerance = 1E-10_default)
    select case (prt%status)
    case (PRT_UNDEFINED);    write (u, "(1x, A)", advance="no")  "[-]"
    case (PRT_BEAM);         write (u, "(1x, A)", advance="no")  "[b]"
    case (PRT_INCOMING);     write (u, "(1x, A)", advance="no")  "[i]"
    case (PRT_OUTGOING);     write (u, "(1x, A)", advance="no")  "[o]"
    case (PRT_VIRTUAL);      write (u, "(1x, A)", advance="no")  "[v]"
    case (PRT_RESONANT);     write (u, "(1x, A)", advance="no")  "[r]"
    case (PRT_BEAM_REMNANT); write (u, "(1x, A)", advance="no")  "[x]"
    end select
    write (u, "(1x)", advance="no")
    if (comp) then
       write (u, "(A7,1X)", advance="no") char (prt%flv%get_name ())
       if (pol) then
          select case (prt%polarization)
          case (PRT_DEFINITE_HELICITY)
             ! Integer helicity, assumed diagonal
             call prt%hel%get_indices (h1, h2)
             write (u, "(I2,1X)", advance="no") h1
          case (PRT_GENERIC_POLARIZATION)
             ! No space for full density matrix here
             write (u, "(A2,1X)", advance="no") "*"
          case default
             ! Blank entry if helicity is undefined
             write (u, "(A2,1X)", advance="no") " "
          end select
       end if
       write (u, "(2(I4,1X))", advance="no") &
            prt%col%get_col (), prt%col%get_acl ()
       call write_compressed_integer_array (buffer, prt%parent)
       write (u, "(A,1X)", advance="no") buffer
       call write_compressed_integer_array (buffer, prt%child)
       write (u, "(A,1X)", advance="no") buffer
       call prt%p%write(u, testflag = testflag, compressed = comp)
       write (u, "(F12.3)") pp2
    else
       call prt%flv%write (unit)
       if (prt%col%is_nonzero ()) then
          call color_write (prt%col, unit)
       end if
       if (pol) then
          select case (prt%polarization)
          case (PRT_DEFINITE_HELICITY)
             call prt%hel%write (unit)
             write (u, *)
          case (PRT_GENERIC_POLARIZATION)
             write (u, *)
             call prt%pol%write (unit, state_matrix = .true.)
          case default
             write (u, *)
          end select
       else
          write (u, *)
       end if
       call prt%p%write (unit, testflag = testflag)
       write (u, "(1x,A,1x," // fmt // ")")  "T = ", pp2
       if (allocated (prt%parent)) then
          if (size (prt%parent) /= 0) then
             write (u, "(1x,A,40(1x,I0))")  "Parents: ", prt%parent
          end if
       end if
       if (allocated (prt%child)) then
          if (size (prt%child) /= 0) then
             write (u, "(1x,A,40(1x,I0))")  "Children:", prt%child
          end if
       end if
       if (allocated (prt%vertex)) then
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx t = ", prt%vertex%p(0)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx x = ", prt%vertex%p(1)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx y = ", prt%vertex%p(2)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx z = ", prt%vertex%p(3)
       end if
       if (allocated (prt%lifetime)) then
          write (u, "(1x,A,1x," // fmt // ")")  "Lifetime = ", &
               prt%lifetime
       end if
    end if
  end subroutine particle_write

@ %def particle_write
@ Binary I/O:
<<Particles: particle: TBP>>=
  procedure :: write_raw => particle_write_raw
  procedure :: read_raw => particle_read_raw
<<Particles: procedures>>=
  subroutine particle_write_raw (prt, u)
    class(particle_t), intent(in) :: prt
    integer, intent(in) :: u
    write (u) prt%status, prt%polarization
    call prt%flv%write_raw (u)
    call prt%col%write_raw (u)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call prt%hel%write_raw (u)
    case (PRT_GENERIC_POLARIZATION)
       call prt%pol%write_raw (u)
    end select
    call vector4_write_raw (prt%p, u)
    write (u) prt%p2
    write (u) allocated (prt%parent)
    if (allocated (prt%parent)) then
       write (u) size (prt%parent)
       write (u) prt%parent
    end if
    write (u) allocated (prt%child)
    if (allocated (prt%child)) then
       write (u) size (prt%child)
       write (u) prt%child
    end if
    write (u) allocated (prt%vertex)
    if (allocated (prt%vertex)) then
       call vector4_write_raw (prt%vertex, u)
    end if    
    write (u) allocated (prt%lifetime)
    if (allocated (prt%lifetime)) then
       write (u) prt%lifetime
    end if
  end subroutine particle_write_raw

  subroutine particle_read_raw (prt, u, iostat)
    class(particle_t), intent(out) :: prt
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    logical :: allocated_parent, allocated_child
    logical :: allocated_vertex, allocated_lifetime
    integer :: size_parent, size_child
    read (u, iostat=iostat) prt%status, prt%polarization
    call prt%flv%read_raw (u, iostat=iostat)
    call prt%col%read_raw (u, iostat=iostat)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call prt%hel%read_raw (u, iostat=iostat)
    case (PRT_GENERIC_POLARIZATION)
       call prt%pol%read_raw (u, iostat=iostat)
    end select
    call vector4_read_raw (prt%p, u, iostat=iostat)
    read (u, iostat=iostat) prt%p2
    read (u, iostat=iostat) allocated_parent
    if (allocated_parent) then
       read (u, iostat=iostat) size_parent
       allocate (prt%parent (size_parent))
       read (u, iostat=iostat) prt%parent
    end if
    read (u, iostat=iostat) allocated_child
    if (allocated_child) then
       read (u, iostat=iostat) size_child
       allocate (prt%child (size_child))
       read (u, iostat=iostat) prt%child
    end if
    read (u, iostat=iostat) allocated_vertex
    if (allocated_vertex) then
       allocate (prt%vertex)
       read (u, iostat=iostat) prt%vertex%p
    end if
    read (u, iostat=iostat) allocated_lifetime
    if (allocated_lifetime) then
       allocate (prt%lifetime)
       read (u, iostat=iostat) prt%lifetime
    end if
  end subroutine particle_read_raw

@ %def particle_write_raw particle_read_raw
@ 
\subsubsection{Setting contents}
Reset the status code.  Where applicable, set $p^2$ assuming that the
particle is on-shell.
<<Particles: particle: TBP>>=
  procedure :: reset_status => particle_reset_status
<<Particles: procedures>>=
  elemental subroutine particle_reset_status (prt, status)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: status
    prt%status = status
    select case (status)
    case (PRT_BEAM, PRT_INCOMING, PRT_OUTGOING)
       prt%p2 = prt%flv%get_mass () ** 2
    end select
  end subroutine particle_reset_status

@ %def particle_reset_status
@ The color can be given explicitly.
<<Particles: particle: TBP>>=
  procedure :: set_color => particle_set_color
<<Particles: procedures>>=
  elemental subroutine particle_set_color (prt, col)
    class(particle_t), intent(inout) :: prt
    type(color_t), intent(in) :: col
    prt%col = col
  end subroutine particle_set_color

@ %def particle_set_color
@ The flavor can be given explicitly.
<<Particles: particle: TBP>>=
  procedure :: set_flavor => particle_set_flavor
<<Particles: procedures>>=
  subroutine particle_set_flavor (prt, flv)
    class(particle_t), intent(inout) :: prt
    type(flavor_t), intent(in) :: flv
    prt%flv = flv
  end subroutine particle_set_flavor

@ %def particle_set_flavor
@ As can the helicity.
<<Particles: particle: TBP>>=
  procedure :: set_helicity => particle_set_helicity
<<Particles: procedures>>=
  subroutine particle_set_helicity (prt, hel)
    class(particle_t), intent(inout) :: prt
    type(helicity_t), intent(in) :: hel
    prt%hel = hel
  end subroutine particle_set_helicity

@ %def particle_set_helicity
@ And the polarization.
<<Particles: particle: TBP>>=
  procedure :: set_pol => particle_set_pol
<<Particles: procedures>>=
  subroutine particle_set_pol (prt, pol)
    class(particle_t), intent(inout) :: prt
    type(polarization_t), intent(in) :: pol
    prt%pol = pol
  end subroutine particle_set_pol

@ %def particle_set_pol
@ Manually set the model for the particle flavor.  This is required, e.g., if
the particle has been read from file.
<<Particles: particle: TBP>>=
  procedure :: set_model => particle_set_model
<<Particles: procedures>>=
  subroutine particle_set_model (prt, model)
    class(particle_t), intent(inout) :: prt
    class(model_data_t), intent(in), target :: model
    call prt%flv%set_model (model)
  end subroutine particle_set_model
  
@ %def particle_set_model
@ The momentum is set independent of the quantum numbers.
<<Particles: particle: TBP>>=
  procedure :: set_momentum => particle_set_momentum
<<Particles: procedures>>=
  elemental subroutine particle_set_momentum (prt, p, p2, on_shell)
    class(particle_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: p
    real(default), intent(in), optional :: p2
    logical, intent(in), optional :: on_shell
    prt%p = p
    if (present (on_shell)) then
       if (on_shell) then
          if (prt%flv%is_associated ()) then
             prt%p2 = prt%flv%get_mass () ** 2
             return
          end if
       end if
    end if
    if (present (p2)) then
       prt%p2 = p2
    else
       prt%p2 = p ** 2
    end if
  end subroutine particle_set_momentum

@ %def particle_set_momentum
@ Set resonance information.  This should be done after momentum
assignment, because we need to know wheter the particle is spacelike
or timelike.  The resonance flag is defined only for virtual
particles. 
<<Particle: particle: TBP>>=
  procedure :: set_resonance_flag => particle_set_resonance_flag
<<Particles: procedures>>=
  elemental subroutine particle_set_resonance_flag (prt, resonant)
    class(particle_t), intent(inout) :: prt
    logical, intent(in) :: resonant
    select case (prt%status)
    case (PRT_VIRTUAL)
       if (resonant)  prt%status = PRT_RESONANT
    end select
  end subroutine particle_set_resonance_flag

@ %def particle_set_resonance_flag
@ Set children and parents information.
<<Particles: particle: TBP>>=
  procedure :: set_children => particle_set_children
  procedure :: set_parents => particle_set_parents
<<Particles: procedures>>=
  subroutine particle_set_children (prt, idx)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%child))  deallocate (prt%child)
    allocate (prt%child (count (idx /= 0)))
    prt%child = pack (idx, idx /= 0)
  end subroutine particle_set_children

  subroutine particle_set_parents (prt, idx)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%parent))  deallocate (prt%parent) 
    allocate (prt%parent (count (idx /= 0)))
    prt%parent = pack (idx, idx /= 0)
  end subroutine particle_set_parents

@ %def particle_set_children particle_set_parents
@ 
<<Particles: particle: TBP>>=
  procedure :: add_child => particle_add_child
<<Particles: procedures>>=
  subroutine particle_add_child (prt, new_child)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: new_child
    integer, dimension(:), allocatable :: idx
    integer :: n, i
    n = prt%get_n_children()
    if (n == 0) then
       call prt%set_children ([new_child])
    else
       do i = 1, n
          if (prt%child(i) == new_child) then
             return
          end if
       end do
       allocate (idx (1:n+1))
       idx(1:n) = prt%get_children ()
       idx(n+1) = new_child
       call prt%set_children (idx)
    end if
  end subroutine particle_add_child

@ %def particle_add_child
@
<<Particles: particle: TBP>>=
  procedure :: add_children => particle_add_children
<<Particles: procedures>>=
  subroutine particle_add_children (prt, new_child)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: new_child
    integer, dimension(:), allocatable :: idx
    integer :: n
    n = prt%get_n_children()
    if (n == 0) then
       call prt%set_children (new_child)
    else
       allocate (idx (1:n+size(new_child)))
       idx(1:n) = prt%get_children ()
       idx(n+1:n+size(new_child)) = new_child
       call prt%set_children (idx)
    end if
  end subroutine particle_add_children

@ %def particle_add_children
@
<<Particles: particle: TBP>>=
  procedure :: set_status => particle_set_status
<<Particles: procedures>>=
  elemental subroutine particle_set_status (prt, status)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: status
    prt%status = status
  end subroutine particle_set_status

@ %def particle_set_status 
@
<<Particles: particle: TBP>>=
  procedure :: set_polarization => particle_set_polarization
<<Particles: procedures>>=
  subroutine particle_set_polarization (prt, polarization)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: polarization
    prt%polarization = polarization
  end subroutine particle_set_polarization

@ %def particle_set_polarization 
@
<<Particles: particle: TBP>>=
  generic :: set_vertex => set_vertex_from_vector3, set_vertex_from_xyz, &
       set_vertex_from_vector4, set_vertex_from_xyzt
  procedure :: set_vertex_from_vector4 => particle_set_vertex_from_vector4
  procedure :: set_vertex_from_vector3 => particle_set_vertex_from_vector3
  procedure :: set_vertex_from_xyzt => particle_set_vertex_from_xyzt
  procedure :: set_vertex_from_xyz => particle_set_vertex_from_xyz
<<Particles: procedures>>=
  subroutine particle_set_vertex_from_vector4 (prt, vertex)
    class(particle_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_vector4

  subroutine particle_set_vertex_from_vector3 (prt, vertex)
    class(particle_t), intent(inout) :: prt
    type(vector3_t), intent(in) :: vertex
    type(vector4_t) :: vtx
    vtx = vector4_moving (0._default, vertex)
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    allocate (prt%vertex, source=vtx)
  end subroutine particle_set_vertex_from_vector3
  
  subroutine particle_set_vertex_from_xyzt (prt, vx, vy, vz, t)
    class(particle_t), intent(inout) :: prt
    real(default), intent(in) :: vx, vy, vz, t
    type(vector4_t) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    vertex = vector4_moving (t, vector3_moving ([vx, vy, vz]))
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_xyzt
  
  subroutine particle_set_vertex_from_xyz (prt, vx, vy, vz)
    class(particle_t), intent(inout) :: prt
    real(default), intent(in) :: vx, vy, vz
    type(vector4_t) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    vertex = vector4_moving (0._default, vector3_moving ([vx, vy, vz]))
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_xyz

@ %def particle_set_vertex_from_vector3
@ %def particle_set_vertex_from_vector4
@ %def particle_set_vertex_from_xyz
@ %def particle_set_vertex_from_xyzt
@ Set the lifetime of a particle.
<<Particles: particle: TBP>>=
  procedure :: set_lifetime => particle_set_lifetime
<<Particles: procedures>>=
  elemental subroutine particle_set_lifetime (prt, lifetime)
    class(particle_t), intent(inout) :: prt
    real(default), intent(in) :: lifetime
    if (allocated (prt%lifetime))  deallocate (prt%lifetime)
    allocate (prt%lifetime, source=lifetime)
  end subroutine particle_set_lifetime

@ %def particle_set_lifetime
@
\subsubsection{Accessing contents}
The status code.
<<Particles: particle: TBP>>=
  procedure :: get_status => particle_get_status
<<Particles: procedures>>=
  elemental function particle_get_status (prt) result (status)
    integer :: status
    class(particle_t), intent(in) :: prt
    status = prt%status
  end function particle_get_status

@ %def particle_get_status
@ Return true if the status is either [[INCOMING]],
[[OUTGOING]] or [[RESONANT]]. [[BEAM]] is kept, if 
[[keep_beams]] is set true.
<<Particles: particle: TBP>>=
  procedure :: is_real => particle_is_real
<<Particles: procedures>>=
  elemental function particle_is_real (prt, keep_beams) result (flag)
    logical :: flag, kb
    class(particle_t), intent(in) :: prt
    logical, intent(in), optional :: keep_beams
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    select case (prt%status)
    case (PRT_INCOMING, PRT_OUTGOING, PRT_RESONANT)
       flag = .true.
    case (PRT_BEAM)
       flag = kb 
    case default
       flag = .false.
    end select
  end function particle_is_real

@ %def particle_is_real
@
<<Particles: particle: TBP>>=
  procedure :: is_colored => particle_is_colored
<<Particles: procedures>>=
  elemental function particle_is_colored (particle) result (flag)
    logical :: flag
    class(particle_t), intent(in) :: particle
    flag = particle%col%is_nonzero ()
  end function particle_is_colored

@ %def particle_is_colored
@ $[90,100]$ hopefully catches all of them and not too many.
<<Particles: particle: TBP>>=
  procedure :: is_hadronic_beam_remnant => particle_is_hadronic_beam_remnant
<<Particles: procedures>>=
  elemental function particle_is_hadronic_beam_remnant (particle) result (flag)
    class(particle_t), intent(in) :: particle
    logical :: flag
    integer :: pdg
    pdg = particle%flv%get_pdg ()
    flag = particle%status == PRT_BEAM_REMNANT .and. &
         abs(pdg) >= 90 .and. abs(pdg) <= 100
  end function particle_is_hadronic_beam_remnant

@ %def particle_is_hadronic_beam_remnant
@
<<Particles: particle: TBP>>=
  procedure :: is_beam_remnant => particle_is_beam_remnant
<<Particles: procedures>>=
  elemental function particle_is_beam_remnant (particle) result (flag)
    class(particle_t), intent(in) :: particle
    logical :: flag
    flag = particle%status == PRT_BEAM_REMNANT
  end function particle_is_beam_remnant

@ %def particle_is_beam_remnant
@ Polarization status.
<<Particles: particle: TBP>>=
  procedure :: get_polarization_status => particle_get_polarization_status
<<Particles: procedures>>=
  elemental function particle_get_polarization_status (prt) result (status)
    integer :: status
    class(particle_t), intent(in) :: prt
    status = prt%polarization
  end function particle_get_polarization_status

@ %def particle_get_polarization_status
@ Return the PDG code from the flavor component directly.
<<Particles: particle: TBP>>=
  procedure :: get_pdg => particle_get_pdg
<<Particles: procedures>>=
  elemental function particle_get_pdg (prt) result (pdg)
    integer :: pdg
    class(particle_t), intent(in) :: prt
    pdg = prt%flv%get_pdg ()
  end function particle_get_pdg

@ %def particle_get_pdg
@ Return the color and anticolor quantum numbers.
<<Particles: particle: TBP>>=
  procedure :: get_color => particle_get_color
<<Particles: procedures>>=
  pure function particle_get_color (prt) result (col)
    integer, dimension(2) :: col
    class(particle_t), intent(in) :: prt
    col(1) = prt%col%get_col ()
    col(2) = prt%col%get_acl ()
  end function particle_get_color
  
@ %def particle_get_color  
@ Return a copy of the polarization density matrix.
<<Particles: particle: TBP>>=
  procedure :: get_polarization => particle_get_polarization
<<Particles: procedures>>=
  function particle_get_polarization (prt) result (pol)
    class(particle_t), intent(in) :: prt
    type(polarization_t) :: pol
    pol = prt%pol
  end function particle_get_polarization

@ %def particle_get_polarization
@ Return the flavor, color and helicity.
<<Particles: particle: TBP>>=
  procedure :: get_flv => particle_get_flv
  procedure :: get_col => particle_get_col 
  procedure :: get_hel => particle_get_hel
<<Particles: procedures>>=
  function particle_get_flv (prt) result (flv)
    class(particle_t), intent(in) :: prt
    type(flavor_t) :: flv
    flv = prt%flv
  end function particle_get_flv 
  
  function particle_get_col (prt) result (col)
    class(particle_t), intent(in) :: prt
    type(color_t) :: col
    col = prt%col
  end function particle_get_col
  
  function particle_get_hel (prt) result (hel)
    class(particle_t), intent(in) :: prt
    type(helicity_t) :: hel
    hel = prt%hel
  end function particle_get_hel
  
@ %def particle_get_flv particle_get_col particle_get_hel
@ Return the helicity (if defined and diagonal).
<<Particles: particle: TBP>>=
  procedure :: get_helicity => particle_get_helicity
<<Particles: procedures>>=
  elemental function particle_get_helicity (prt) result (hel)
    integer :: hel
    integer, dimension(2) :: hel_arr
    class(particle_t), intent(in) :: prt    
    hel = 0
    if (prt%hel%is_defined () .and. prt%hel%is_diagonal ()) then
       hel_arr = prt%hel%to_pair ()
       hel = hel_arr (1)
    end if
  end function particle_get_helicity  
  
@ %def particle_get_helicity
@ Return the number of children/parents
<<Particles: particle: TBP>>=
  procedure :: get_n_parents => particle_get_n_parents
  procedure :: get_n_children => particle_get_n_children
<<Particles: procedures>>=
  elemental function particle_get_n_parents (prt) result (n)
    integer :: n
    class(particle_t), intent(in) :: prt
    if (allocated (prt%parent)) then
       n = size (prt%parent)
    else
       n = 0
    end if
  end function particle_get_n_parents
    
  elemental function particle_get_n_children (prt) result (n)
    integer :: n
    class(particle_t), intent(in) :: prt
    if (allocated (prt%child)) then
       n = size (prt%child)
    else
       n = 0
    end if
  end function particle_get_n_children
    
@ %def particle_get_n_parents particle_get_n_children
@ Return the array of parents/children.
<<Particles: particle: TBP>>=
  procedure :: get_parents => particle_get_parents
  procedure :: get_children => particle_get_children
<<Particles: procedures>>=
  function particle_get_parents (prt) result (parent)
    class(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: parent
    if (allocated (prt%parent)) then
       allocate (parent (size (prt%parent)))
       parent = prt%parent
    else
       allocate (parent (0))
    end if
  end function particle_get_parents

  function particle_get_children (prt) result (child)
    class(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: child
    if (allocated (prt%child)) then
       allocate (child (size (prt%child)))
       child = prt%child
    else
       allocate (child (0))
    end if
  end function particle_get_children

@ %def particle_get_children
@
<<Particles: particle: TBP>>=
  procedure :: has_children => particle_has_children
<<Particles: procedures>>=
  elemental function particle_has_children (prt) result (has_children)
    logical :: has_children
    class(particle_t), intent(in) :: prt
    has_children = .false.
    if (allocated (prt%child)) then
       has_children = size (prt%child) > 0
    end if
  end function particle_has_children

@ %def particle_has_children
@
<<Particles: particle: TBP>>=
  procedure :: has_parents => particle_has_parents
<<Particles: procedures>>=
  elemental function particle_has_parents (prt) result (has_parents)
    logical :: has_parents
    class(particle_t), intent(in) :: prt
    has_parents = .false.
    if (allocated (prt%parent)) then
       has_parents = size (prt%parent) > 0
    end if
  end function particle_has_parents

@ %def particle_has_parents
@ Return momentum and momentum squared.
<<Particles: particle: TBP>>=
  procedure :: get_momentum => particle_get_momentum
  procedure :: get_p2 => particle_get_p2
<<Particles: procedures>>=
  elemental function particle_get_momentum (prt) result (p)
    type(vector4_t) :: p
    class(particle_t), intent(in) :: prt
    p = prt%p
  end function particle_get_momentum

  elemental function particle_get_p2 (prt) result (p2)
    real(default) :: p2
    class(particle_t), intent(in) :: prt
    p2 = prt%p2
  end function particle_get_p2

@ %def particle_get_momentum particle_get_p2
@ Return the particle vertex, if allocated.
<<Particles: particle: TBP>>=
  procedure :: get_vertex => particle_get_vertex
<<Particles: procedures>>=
  elemental function particle_get_vertex (prt) result (vtx)
    type(vector4_t) :: vtx
    class(particle_t), intent(in) :: prt
    if (allocated (prt%vertex)) then
       vtx = prt%vertex
    else
       vtx = vector4_null
    end if
  end function particle_get_vertex

@ %def particle_get_vertex
@ Return the lifetime of a particle.
<<Particles: particle: TBP>>=
  procedure :: get_lifetime => particle_get_lifetime
<<Particles: procedures>>=
  elemental function particle_get_lifetime (prt) result (lifetime)
    real(default) :: lifetime
    class(particle_t), intent(in) :: prt
    if (allocated (prt%lifetime)) then
       lifetime = prt%lifetime
    else
       lifetime = 0
    end if
  end function particle_get_lifetime

@ %def particle_get_lifetime
@
<<Particles: particle: TBP>>=
  procedure :: momentum_to_pythia6 => particle_momentum_to_pythia6
<<Particles: procedures>>=
  pure function particle_momentum_to_pythia6 (prt) result (p)
    real(double), dimension(1:5) :: p
    class(particle_t), intent(in) :: prt
    p = prt%p%to_pythia6 (sqrt (prt%p2))
  end function particle_momentum_to_pythia6

@ %def particle_momentum_to_pythia6
@
\subsection{Particle sets}
A particle set is what is usually called an event: an array of
particles.  The individual particle entries carry momentum, quantum
numbers, polarization, and optionally connections.  There is (also
optionally) a correlated state-density matrix that maintains spin
correlations that are lost in the individual particle entries.
<<Particles: public>>=
  public :: particle_set_t
<<Particles: types>>=
  type :: particle_set_t
     integer :: n_beam = 0
     integer :: n_in  = 0
     integer :: n_vir = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     integer :: factorization_mode = FM_IGNORE_HELICITY
     type(particle_t), dimension(:), allocatable :: prt
     type(state_matrix_t) :: correlated_state
   contains
   <<Particles: particle set: TBP>>
  end type particle_set_t

@ %def particle_set_t
@ A particle set can be initialized from an interaction or from a
HepMC event record.
<<Particles: particle set: TBP>>=
  generic :: init => init_interaction
  procedure :: init_interaction => particle_set_init_interaction
@ When a particle set is initialized from a given interaction, we have
to determine the branch within the original state matrix that fixes
the particle quantum numbers.  This is done with the appropriate
probabilities, based on a random number [[x]].  The [[mode]]
determines whether the individual particles become unpolarized, or
take a definite (diagonal) helicity, or acquire single-particle
polarization matrices.  The flag [[keep_correlations]] tells whether
the spin-correlation matrix is to be calculated and stored in addition
to the particles.  The flag [[keep_virtual]] tells whether virtual
particles should be dropped.  Note that if virtual particles are
dropped, the spin-correlation matrix makes no sense, and parent-child
relations are not set.

For a correct disentangling of color and flavor (in the presence of
helicity), we consider two interactions.  [[int]] has no color
information, and is used to select a flavor state.  Consequently, we
trace over helicities here.  [[int_flows]] contains color-flow and
potentially helicity information, but is useful only after the flavor
combination has been chosen.  So this interaction is used to select
helicity and color, but restricted to the selected flavor combination.

[[int]] and [[int_flows]] may be identical if there is only a single
(or no) color flow.  If there is just a single flavor combination,
[[x(1)]] can be set to zero.

The current algorithm of evaluator convolution requires that the beam
particles are assumed outgoing (in the beam interaction) and become
virtual in all derived interactions.  In the particle set they should
be re-identified as incoming.  The optional integer [[n_incoming]]
can be used to perform this correction.
    
The flag [[is_valid]] is false if factorization of the state is not
possible, in particular if the squared matrix element is zero.
<<Particles: procedures>>=
  subroutine particle_set_init_interaction &
       (particle_set, is_valid, int, int_flows, mode, x, &
        keep_correlations, keep_virtual, n_incoming)
    class(particle_set_t), intent(out) :: particle_set
    logical, intent(out) :: is_valid
    type(interaction_t), intent(in), target :: int, int_flows
    integer, intent(in) :: mode
    real(default), dimension(2), intent(in) :: x
    logical, intent(in) :: keep_correlations, keep_virtual
    integer, intent(in), optional :: n_incoming
    type(state_matrix_t), dimension(:), allocatable, target :: flavor_state
    type(state_matrix_t), dimension(:), allocatable, target :: single_state
    integer :: n_in, n_vir, n_out, n_tot
    type(quantum_numbers_t), dimension(:,:), allocatable :: qn
    logical :: ok
    integer :: i, j
    if (present (n_incoming)) then
       n_in  = n_incoming
       n_vir = int%get_n_vir () - n_incoming
    else
       n_in  = int%get_n_in  ()
       n_vir = int%get_n_vir ()
    end if
    n_out = int%get_n_out ()
    n_tot = int%get_n_tot ()
    particle_set%n_in  = n_in
    particle_set%n_out = n_out
    if (keep_virtual) then
       particle_set%n_vir = n_vir
       particle_set%n_tot = n_tot
    else
       particle_set%n_vir = 0
       particle_set%n_tot = n_in + n_out
    end if
    particle_set%factorization_mode = mode
    call int%factorize &
         (FM_IGNORE_HELICITY, x(1), is_valid, flavor_state)
    allocate (qn (n_tot,1))
    do i = 1, n_tot
       qn(i,:) = flavor_state(i)%get_quantum_numbers (1)
    end do
    if (keep_correlations .and. keep_virtual) then
       call particle_set%correlated_state%final ()
       call int_flows%factorize (mode, x(2), ok, &
            single_state, particle_set%correlated_state, qn(:,1))
    else
       call int_flows%factorize (mode, x(2), ok, &
            single_state, qn_in=qn(:,1))
    end if
    is_valid = is_valid .and. ok
    allocate (particle_set%prt (particle_set%n_tot))
    j = 1
    do i = 1, n_tot
       if (i <= n_in) then
          call particle_set%prt(j)%init (single_state(i), PRT_INCOMING, mode)
          call particle_set%prt(j)%set_momentum (int%get_momentum (i))
       else if (i <= n_in + n_vir) then
          if (.not. keep_virtual)  cycle
          call particle_set%prt(j)%init &
               (single_state(i), PRT_VIRTUAL, mode) 
          call particle_set%prt(j)%set_momentum (int%get_momentum (i))
       else
          call particle_set%prt(j)%init (single_state(i), PRT_OUTGOING, mode)
          call particle_set%prt(j)%set_momentum &
               (int%get_momentum (i), on_shell = .true.)
       end if
       if (keep_virtual) then
          call particle_set%prt(j)%set_children &
               (interaction_get_children (int, i))
          call particle_set%prt(j)%set_parents &
               (interaction_get_parents (int, i))
       end if
       j = j + 1
    end do
    if (keep_virtual) then
       call particle_set_resonance_flag &
            (particle_set%prt, int%get_resonance_flags ())
    end if
    do i = 1, size(flavor_state)
       call flavor_state(i)%final ()
    end do
    do i = 1, size(single_state)
       call single_state(i)%final ()
    end do
  end subroutine particle_set_init_interaction

@ %def particle_set_init_interaction
<<Particles: particle set: TBP>>=
  generic :: init => init_particle_set
  procedure :: init_particle_set => particle_set_init_particle_set
<<Particles: procedures>>=
  subroutine particle_set_init_particle_set (pset_out, pset_in)
    class(particle_set_t), intent(out) :: pset_out
    type(particle_set_t), intent(in) :: pset_in
    integer :: i
    pset_out%n_beam = pset_in%n_beam
    pset_out%n_in   = pset_in%n_in
    pset_out%n_vir  = pset_in%n_vir
    pset_out%n_out  = pset_in%n_out
    pset_out%n_tot  = pset_in%n_tot
    pset_out%factorization_mode = pset_in%factorization_mode
    if (allocated (pset_in%prt)) then
       allocate (pset_out%prt (size (pset_in%prt)))
       do i = 1, size (pset_in%prt)
          pset_out%prt(i) = pset_in%prt(i)
       end do
    end if
    pset_out%correlated_state = pset_in%correlated_state
  end subroutine particle_set_init_particle_set

@ %def particle_set_init_particle_set
@ Manually set the model for the stored particles.
<<Particles: particle set: TBP>>=
  procedure :: set_model => particle_set_set_model
<<Particles: procedures>>=
  subroutine particle_set_set_model (particle_set, model)
    class(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    integer :: i
    do i = 1, particle_set%n_tot
       call particle_set%prt(i)%set_model (model)
    end do
    call particle_set%correlated_state%set_model (model)
  end subroutine particle_set_set_model

@ %def particle_set_set_model
@ Duplicate implementation.
<<Particles: interfaces>>=
  interface assignment(=)
     module procedure particle_set_init_particle_set
  end interface

@
@ Pointer components are hidden inside the particle polarization, and
in the correlated state matrix.
<<Particles: particle set: TBP>>=
  procedure :: final => particle_set_final
<<Particles: procedures>>=
  subroutine particle_set_final (particle_set)
    class(particle_set_t), intent(inout) :: particle_set
    integer :: i
    if (allocated (particle_set%prt)) then
       do i = 1, size(particle_set%prt)
          call particle_set%prt(i)%final ()
       end do
       deallocate (particle_set%prt)
    end if
    call particle_set%correlated_state%final ()
  end subroutine particle_set_final

@ %def particle_set_final
@
<<Particles: particle set: TBP>>=
  generic :: get_momenta => get_momenta_all
  generic :: get_momenta => get_momenta_indices
  procedure :: get_momenta_all => particle_set_get_momenta_all
  procedure :: get_momenta_indices => particle_set_get_momenta_indices
<<Particles: procedures>>=
  function particle_set_get_momenta_all (particle_set) result (p)
    class(particle_set_t), intent(in) :: particle_set
    type(vector4_t), dimension(:), allocatable :: p
    allocate (p (size (particle_set%prt)))
    p = particle_set%prt%p
  end function particle_set_get_momenta_all

@ %def particle_set_get_momenta_all
@
<<Particles: procedures>>=
  function particle_set_get_momenta_indices (particle_set, indices) result (p)
     type(vector4_t), dimension(:), allocatable :: p
     class(particle_set_t), intent(in) :: particle_set
     integer, intent(in), dimension(:), allocatable :: indices
     integer :: i
     allocate (p (size (indices)))
     do i = 1, size (indices)
        p(i) = particle_set%prt(indices(i))%p
     end do
  end function particle_set_get_momenta_indices

@ %def particle_set_get_momenta_indices
@
<<Particles: particle set: TBP>>=
  procedure :: set_momenta => particle_set_set_momenta
<<Particles: procedures>>=
  pure subroutine particle_set_set_momenta (particle_set, p)
    class(particle_set_t), intent(inout) :: particle_set
    type(vector4_t), dimension(:), intent(in) :: p
    if (.not. allocated (particle_set%prt)) then
       allocate (particle_set%prt (size (p)))
    end if
    particle_set%prt%p = p
  end subroutine particle_set_set_momenta

@ %def particle_set_set_momenta
@
<<Particles: particle set: TBP>>=
  procedure :: parent_add_child => particle_set_parent_add_child
<<Particles: procedures>>=
  subroutine particle_set_parent_add_child (particle_set, parent, child)
    class(particle_set_t), intent(inout) :: particle_set
    integer, intent(in) :: parent, child
    call particle_set%prt(child)%set_parents ([parent])
    call particle_set%prt(parent)%add_child (child)
  end subroutine particle_set_parent_add_child

@ %def particle_set_parent_add_child
@ Given the [[particle_set]] before radiation, the new momenta
[[p_radiated]], the [[emitter]] and the [[flv_radiated]] as well as the
[[model]] and a random number [[r_color]] for chosing a color, we update
the [[particle_set]].
<<Particles: particle set: TBP>>=
  procedure :: build_radiation => particle_set_build_radiation
<<Particles: procedures>>=
  subroutine particle_set_build_radiation (particle_set, p_radiated, &
     emitter, flv_radiated, model, r_color)
     class(particle_set_t), intent(inout) :: particle_set
     type(vector4_t), intent(in), dimension(:) :: p_radiated
     integer, intent(in) :: emitter
     integer, intent(in), dimension(:) :: flv_radiated
     class(model_data_t), intent(in), target :: model
     real(default), intent(in) :: r_color
     type(particle_set_t) :: new_particle_set
     type(particle_t) :: new_particle
     integer :: i
     integer :: pdg_index_emitter, pdg_index_radiation
     integer, dimension(:), allocatable :: parents, children
     type(flavor_t) :: new_flv
     logical, dimension(:), allocatable :: status_mask
     integer, dimension(:), allocatable :: &
          i_in1, i_beam1, i_remnant1, i_virt1, i_out1
     integer, dimension(:), allocatable :: &
          i_in2, i_beam2, i_remnant2, i_virt2, i_out2
     integer :: n_in1, n_beam1, n_remnant1, n_virt1, n_out1
     integer :: n_in2, n_beam2, n_remnant2, n_virt2, n_out2
     integer :: n, n_tot
     integer :: i_emitter
     
     n = particle_set%get_n_tot ()
     allocate (status_mask (n))
     !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
     do i = 1, n
        status_mask(i) = particle_set%prt(i)%get_status () == PRT_INCOMING
     end do
     !!! status_mask = particle_set%prt%get_status () == PRT_INCOMING     
     n_in1 = count (status_mask)
     allocate (i_in1 (n_in1))
     i_in1 = particle_set%get_indices (status_mask)
     do i = 1, n
        status_mask(i) = particle_set%prt(i)%get_status () == PRT_BEAM
     end do
     n_beam1 = count (status_mask)
     allocate (i_beam1 (n_beam1))
     i_beam1 = particle_set%get_indices (status_mask)
     do i = 1, n
        status_mask(i) = particle_set%prt(i)%get_status () == PRT_BEAM_REMNANT
     end do
     n_remnant1 = count (status_mask)
     allocate (i_remnant1 (n_remnant1))
     i_remnant1 = particle_set%get_indices (status_mask)
     do i = 1, n
        status_mask(i) = particle_set%prt(i)%get_status () == PRT_VIRTUAL
     end do
     n_virt1 = count (status_mask)
     allocate (i_virt1 (n_virt1))
     i_virt1 = particle_set%get_indices (status_mask)
     do i = 1, n
        status_mask(i) = particle_set%prt(i)%get_status () == PRT_OUTGOING
     end do
     n_out1 = count (status_mask)
     allocate (i_out1 (n_out1))
     i_out1 = particle_set%get_indices (status_mask)

     n_in2 = n_in1; n_beam2 = n_beam1; n_remnant2 = n_remnant1
     n_virt2 = n_virt1 + n_out1
     n_out2 = n_out1 + 1
     n_tot = n_in2 + n_beam2 + n_remnant2 + n_virt2 + n_out2

     allocate (i_in2 (n_in2), i_beam2 (n_beam2), i_remnant2 (n_remnant2))
     i_in2 = i_in1; i_beam2 = i_beam1; i_remnant2 = i_remnant1

     allocate (i_virt2 (n_virt2))
     i_virt2(1 : n_virt1) = i_virt1
     i_virt2(n_virt1 + 1 : n_virt2) = i_out1 

     allocate (i_out2 (n_out2))
     i_out2(1 : n_out1) = i_out1(1 : n_out1) + n_out1
     i_out2(n_out2) = n_tot 
 
     new_particle_set%n_beam = n_beam2
     new_particle_set%n_in = n_in2
     new_particle_set%n_vir = n_virt2
     new_particle_set%n_out = n_out2
     new_particle_set%n_tot = n_tot
     new_particle_set%correlated_state = particle_set%correlated_state
     allocate (new_particle_set%prt (n_tot))
     if (size (i_beam1) > 0) new_particle_set%prt(i_beam2) = particle_set%prt(i_beam1)
     if (size (i_remnant1) > 0) new_particle_set%prt(i_remnant2) = particle_set%prt(i_remnant1)
     do i = 1, n_virt1
        new_particle_set%prt(i_virt2(i)) = particle_set%prt(i_virt1(i))
     end do

     do i = n_virt1 + 1, n_virt2
        new_particle_set%prt(i_virt2(i)) = particle_set%prt(i_out1(i - n_virt1))
        call new_particle_set%prt(i_virt2(i))%reset_status (PRT_VIRTUAL)
     end do
     
     do i = 1, n_in2
        new_particle_set%prt(i_in2(i)) = particle_set%prt(i_in1(i))
        new_particle_set%prt(i_in2(i))%p = p_radiated (i)
     end do

     do i = 1, n_out2 - 1
        new_particle_set%prt(i_out2(i)) = particle_set%prt(i_out1(i))
        new_particle_set%prt(i_out2(i))%p = p_radiated(i + n_in2)
        call new_particle_set%prt(i_out2(i))%reset_status (PRT_OUTGOING)
     end do
 
     call new_particle%reset_status (PRT_OUTGOING)
     call new_particle%set_momentum (p_radiated (n_in2 + n_out2))

     !!! Helicity and polarization handling is missing at this point
     !!! Also, no helicities or polarizations yet
     pdg_index_emitter = flv_radiated (emitter)
     pdg_index_radiation = flv_radiated (n_in2 + n_out2)
     call new_flv%init (pdg_index_radiation, model)
     i_emitter = emitter + n_virt2 + n_remnant2 + n_beam2

     call reassign_colors (new_particle, new_particle_set%prt(i_emitter), &
        pdg_index_radiation, pdg_index_emitter, r_color)

     call new_particle%set_flavor (new_flv)
     new_particle_set%prt(n_tot) = new_particle

     allocate (children (n_out2))
     children = i_out2
     do i = n_in2 + n_beam2 + n_remnant2 + n_virt1 + 1, n_in2 + n_beam2 + n_remnant2 + n_virt2
        call new_particle_set%prt(i)%set_children (children)
     end do
          
     !!! Set proper parents for outgoing particles
     allocate (parents (n_out1))
     parents = i_out1
     do i = n_in2 + n_beam2 + n_remnant2 + n_virt2 + 1, n_tot
        call new_particle_set%prt(i)%set_parents (parents)
     end do
     call particle_set%init (new_particle_set)
  contains

    <<build radiation: set color offset>>
    subroutine reassign_colors (prt_radiated, prt_emitter, i_rad, i_em, r_col)
      type(particle_t), intent(inout) :: prt_radiated, prt_emitter
      integer, intent(in) :: i_rad, i_em
      real(default), intent(in) :: r_col
      type(color_t) :: col_rad, col_em
      if (is_quark (i_em) .and. is_gluon (i_rad)) then
         call reassign_colors_qg (prt_emitter, col_rad, col_em)
      else if (is_gluon (i_em) .and. is_gluon (i_rad)) then
         call reassign_colors_gg (prt_emitter, r_col, col_rad, col_em)
      else if (is_gluon (i_em) .and. is_quark (i_rad)) then
         call reassign_colors_qq (prt_emitter, i_em, col_rad, col_em)
      else
         call msg_fatal ("Invalid splitting")
      end if
      call prt_emitter%set_color (col_em)
      call prt_radiated%set_color (col_rad)
    end subroutine reassign_colors

    subroutine reassign_colors_qg (prt_emitter, col_rad, col_em)
      type(particle_t), intent(in) :: prt_emitter
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      integer :: new_color_index
      logical :: is_anti_quark

      color_em = prt_emitter%get_color ()
      i1 = 1; i2 = 2
      is_anti_quark = color_em(2) /= 0
      if (is_anti_quark) then
         i1 = 2; i2 = 1
      end if
      new_color_index = color_em(i1)+1
      color_rad(i1) = color_em(i1)
      color_rad(i2) = new_color_index
      color_em(i1) = new_color_index
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_qg

    subroutine reassign_colors_gg (prt_emitter, random, col_rad, col_em)
      !!! NOT TESTED YET
      type(particle_t), intent(in) :: prt_emitter
      real(default), intent(in) :: random
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      integer :: new_color_index

      color_em = prt_emitter%get_color ()
      new_color_index = maxval (abs (color_em))
      i1 = 1; i2 = 2
      if (random < 0.5) then
         i1 = 2; i2 = 1
      end if
      color_rad(i1) = new_color_index
      color_rad(i2) = color_em(i2)
      color_em(i2) = new_color_index
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_gg

    subroutine reassign_colors_qq (prt_emitter, pdg_emitter, col_rad, col_em)
      !!! NOT TESTED YET
      type(particle_t), intent(in) :: prt_emitter
      integer, intent(in) :: pdg_emitter
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      logical :: is_anti_quark

      color_em = prt_emitter%get_color ()
      i1 = 1; i2 = 2
      is_anti_quark = pdg_emitter < 0
      if (is_anti_quark) then
         i1 = 2; i1 = 1
      end if
      color_em(i2) = 0
      color_rad(i1) = 0
      color_rad(i2) = color_em(i1)
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_qq
  end subroutine particle_set_build_radiation

@ %def particle_set_build_radiation   
@ Increments the color indices of all particles by their maximal value to distinguish them
from the record-keeping Born particles in the LHE-output if the virtual entries are kept. 
<<build radiation: set color offset>>=
  subroutine set_color_offset (particle_set)
    type(particle_set_t), intent(inout) :: particle_set
    integer, dimension(2) :: color
    integer :: i, i_color_max
    type(color_t) :: new_color

    i_color_max = 0
    do i = 1, size (particle_set%prt)
       associate (prt => particle_set%prt(i))
          if (prt%get_status () <= PRT_INCOMING) cycle
          color = prt%get_color ()
          i_color_max = maxval([i_color_max, color(1), color(2)])
       end associate
    end do

    
    do i = 1, size (particle_set%prt)
       associate (prt => particle_set%prt(i))
          if (prt%get_status () /= PRT_OUTGOING) cycle
          color = prt%get_color ()
          where (color /= 0) color = color + i_color_max
          call new_color%init_col_acl (color(1), color(2))
          call prt%set_color (new_color)
       end associate
    end do
  end subroutine set_color_offset

@ %def set_color_offset      
@ Output (default format)
<<Particles: particle set: TBP>>=
  procedure :: write => particle_set_write
<<Particles: procedures>>=
  subroutine particle_set_write &
    (particle_set, unit, testflag, summary, compressed)
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, summary, compressed
    logical :: summ, comp, pol
    type(vector4_t) :: sum_vec
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    summ = .false.; if (present (summary)) summ = summary
    comp = .false.; if (present (compressed)) comp = compressed
    pol = particle_set%factorization_mode /= FM_IGNORE_HELICITY
    write (u, "(1x,A)") "Particle set:"
    call write_separator (u)
    if (comp) then
       if (pol) then
          write (u, &
               "((A4,1X),(A6,1X),(A7,1X),(A3),2(A4,1X),2(A20,1X),5(A12,1X))") &
               "Nr", "Status", "Flavor", "Hel", "Col", "ACol", &
               "Parents", "Children", &
               "P(0)", "P(1)", "P(2)", "P(3)", "P^2"
       else
          write (u, &
               "((A4,1X),(A6,1X),(A7,1X),2(A4,1X),2(A20,1X),5(A12,1X))") &
               "Nr", "Status", "Flavor", "Col", "ACol", &
               "Parents", "Children", &
               "P(0)", "P(1)", "P(2)", "P(3)", "P^2"
       end if
    end if
    if (particle_set%n_tot /= 0) then
       do i = 1, particle_set%n_tot
          if (comp) then
             write (u, "(I4,1X,2X)", advance="no") i
          else
             write (u, "(1x,A,1x,I0)", advance="no") "Particle", i
          end if
          call particle_set%prt(i)%write (u, testflag = testflag, &
               compressed = comp, polarization = pol)
       end do
       if (particle_set%correlated_state%is_defined ()) then
          call write_separator (u)
          write (u, *) "Correlated state density matrix:"
          call particle_set%correlated_state%write (u)
       end if
       if (summ) then
          call write_separator (u)
          write (u, "(A)", advance="no") &
               "Sum of incoming momenta: p(0:3) =     "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_INCOMING)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, *)
          write (u, "(A)", advance="no") &
               "Sum of beam remnant momenta: p(0:3) = "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_BEAM_REMNANT)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, *)
          write (u, "(A)", advance="no") &
               "Sum of outgoing momenta: p(0:3) =     "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_OUTGOING)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, "(A)") ""
       end if
    else
       write (u, "(3x,A)") "[empty]"
    end if
  end subroutine particle_set_write

@ %def particle_set_write
@ 
\subsection{I/O formats}
Here, we define input/output of particle sets in various formats.
This is the right place since particle sets contain most of the event
information.

All write/read routines take as first argument the object, as second
argument the I/O unit which in this case is a mandatory argument.
Then follow further event data.

\subsubsection{Internal binary format}
This format is supposed to contain the complete information, so
the particle data set can be fully reconstructed.  The exception is
the model part of the particle flavors; this is unassigned for the
flavor values read from file.
<<Particles: particle set: TBP>>=
  procedure :: write_raw => particle_set_write_raw 
  procedure :: read_raw => particle_set_read_raw 
<<Particles: procedures>>=
  subroutine particle_set_write_raw (particle_set, u)
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: u
    integer :: i
    write (u) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    write (u) particle_set%factorization_mode
    write (u) particle_set%n_tot
    do i = 1, particle_set%n_tot
       call particle_set%prt(i)%write_raw (u)
    end do
    call particle_set%correlated_state%write_raw (u)
  end subroutine particle_set_write_raw

  subroutine particle_set_read_raw (particle_set, u, iostat)
    class(particle_set_t), intent(out) :: particle_set
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    integer :: i
    read (u, iostat=iostat) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    read (u, iostat=iostat) particle_set%factorization_mode
    read (u, iostat=iostat) particle_set%n_tot
    allocate (particle_set%prt (particle_set%n_tot))
    do i = 1, size (particle_set%prt)
       call particle_set%prt(i)%read_raw (u, iostat=iostat)
    end do
    call particle_set%correlated_state%read_raw (u, iostat=iostat)
  end subroutine particle_set_read_raw

@ %def particle_set_write_raw particle_set_read_raw
@ 
\subsubsection{Get contents}
Find parents/children of a particular particle recursively; the
search terminates if a parent/child has status [[BEAM]], [[INCOMING]],
[[OUTGOING]] or [[RESONANT]].
<<Particles: particle set: TBP>>=
  procedure :: get_real_parents => particle_set_get_real_parents
  procedure :: get_real_children => particle_set_get_real_children
<<Particles: procedures>>=
  function particle_set_get_real_parents (pset, i, keep_beams) result (parent)
    integer, dimension(:), allocatable :: parent
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, intent(in), optional :: keep_beams
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_parent, is_real_parent
    logical :: kb
    integer :: j, k
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
    do j = 1, pset%n_tot
       is_real(j) = pset%prt(j)%is_real (kb)
    end do
    !!! is_real = pset%prt%is_real (kb)
    allocate (is_parent (pset%n_tot), is_real_parent (pset%n_tot))
    is_real_parent = .false.
    is_parent = .false.
    is_parent(pset%prt(i)%get_parents()) = .true.
    do while (any (is_parent))
       where (is_real .and. is_parent)
          is_real_parent = .true.
          is_parent = .false.
       end where
       mark_next_parent: do j = size (is_parent), 1, -1
          if (is_parent(j)) then
             is_parent(pset%prt(j)%get_parents()) = .true.
             is_parent(j) = .false.
             exit mark_next_parent
          end if
       end do mark_next_parent
    end do
    allocate (parent (count (is_real_parent)))
    j = 0
    do k = 1, size (is_parent)
       if (is_real_parent(k)) then
          j = j + 1
          parent(j) = k
       end if
    end do
  end function particle_set_get_real_parents

  function particle_set_get_real_children (pset, i, keep_beams) result (child)
    integer, dimension(:), allocatable :: child
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_child, is_real_child
    logical, intent(in), optional :: keep_beams
    integer :: j, k
    logical :: kb
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
    do j = 1, pset%n_tot
       is_real(j) = pset%prt(j)%is_real (kb)
    end do
    is_real = pset%prt%is_real (kb)
    allocate (is_child (pset%n_tot), is_real_child (pset%n_tot))
    is_real_child = .false.
    is_child = .false.
    is_child(pset%prt(i)%get_children()) = .true.
    do while (any (is_child))
       where (is_real .and. is_child)
          is_real_child = .true.
          is_child = .false.
       end where
       mark_next_child: do j = 1, size (is_child)
          if (is_child(j)) then
             is_child(pset%prt(j)%get_children()) = .true.
             is_child(j) = .false.
             exit mark_next_child
          end if
       end do mark_next_child
    end do
    allocate (child (count (is_real_child)))
    j = 0
    do k = 1, size (is_child)
       if (is_real_child(k)) then
          j = j + 1
          child(j) = k
       end if
    end do
  end function particle_set_get_real_children

@ %def particle_set_get_real_parents
@ %def particle_set_get_real_children
@ Get the [[n_tot]], [[n_in]], and [[n_out]] values out of the
particle set.
<<Particles: particle set: TBP>>=
  procedure :: get_n_beam => particle_set_get_n_beam
  procedure :: get_n_in => particle_set_get_n_in
  procedure :: get_n_vir => particle_set_get_n_vir
  procedure :: get_n_out => particle_set_get_n_out
  procedure :: get_n_tot => particle_set_get_n_tot
  procedure :: get_n_remnants => particle_set_get_n_remnants
<<Particles: procedures>>=
  function particle_set_get_n_beam (pset) result (n_beam)
     class(particle_set_t), intent(in) :: pset
     integer :: n_beam
     n_beam = pset%n_beam
  end function particle_set_get_n_beam

  function particle_set_get_n_in (pset) result (n_in)
     class(particle_set_t), intent(in) :: pset
     integer :: n_in
     n_in = pset%n_in
  end function particle_set_get_n_in

  function particle_set_get_n_vir (pset) result (n_vir)
     class(particle_set_t), intent(in) :: pset
     integer :: n_vir
     n_vir = pset%n_vir
   end function particle_set_get_n_vir

  function particle_set_get_n_out (pset) result (n_out)
     class(particle_set_t), intent(in) :: pset
     integer :: n_out
     n_out = pset%n_out
  end function particle_set_get_n_out
  
  function particle_set_get_n_tot (pset) result (n_tot)
     class(particle_set_t), intent(in) :: pset
     integer :: n_tot
     n_tot = pset%n_tot
  end function particle_set_get_n_tot

  function particle_set_get_n_remnants (pset) result (n_rad)
    class(particle_set_t), intent(in) :: pset
    integer :: n_rad
    n_rad = count (pset%prt%get_status () == PRT_BEAM_REMNANT)
  end function particle_set_get_n_remnants

@ %def particle_set_get_n_beam
@ %def particle_set_get_n_in
@ %def particle_set_get_n_vir
@ %def particle_set_get_n_out
@ %def particle_set_get_n_tot
@ %def particle_set_get_n_remnants
@ Return a pointer to the particle corresponding to the number
<<Particles: particle set: TBP>>=
  procedure :: get_particle => particle_set_get_particle
<<Particles: procedures>>=
  function particle_set_get_particle (pset, index) result (particle)
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: index
    type(particle_t) :: particle
    particle = pset%prt(index)
  end function particle_set_get_particle

@ %def particle_set_get_particle
@
<<Particles: particle set: TBP>>=
  procedure :: get_indices => particle_set_get_indices
<<Particles: procedures>>=
  pure function particle_set_get_indices (pset, mask) result (finals)
    integer, dimension(:), allocatable :: finals
    class(particle_set_t), intent(in) :: pset
    logical, dimension(:), intent(in) :: mask
    integer, dimension(size(mask)) :: indices
    integer :: i
    allocate (finals (count (mask)))
    indices = [(i, i=1, pset%n_tot)]
    finals = pack (indices, mask)
  end function particle_set_get_indices

@ %def particle_set_get_indices
@
<<Particles: particle set: TBP>>=
  procedure :: get_in_and_out_momenta => particle_set_get_in_and_out_momenta
<<Particles: procedures>>=
  function particle_set_get_in_and_out_momenta (pset) result (phs_point)
    type(phs_point_t) :: phs_point
    class(particle_set_t), intent(in) :: pset
    logical, dimension(:), allocatable :: mask
    integer, dimension(:), allocatable :: indices
    type(vector4_t), dimension(:), allocatable :: p
    allocate (mask (pset%get_n_tot ()))
    allocate (p (size (pset%prt)))
    mask = pset%prt%status == PRT_INCOMING .or. &
           pset%prt%status == PRT_OUTGOING
    allocate (indices (count (mask)))
    indices = pset%get_indices (mask) 
    phs_point = pset%get_momenta (indices)
  end function particle_set_get_in_and_out_momenta

@ %def particle_set_get_in_and_out_momenta
@
\subsubsection{Tools}
Build a new particles array without hadronic remnants but with
[[n_extra]] additional spots.  We also update the mother-daughter
relations assuming the ordering [[b]], [[i]], [[r]], [[x]], [[o]].
<<Particles: particle set: TBP>>=
  procedure :: without_hadronic_remnants => &
       particle_set_without_hadronic_remnants
<<Particles: procedures>>=
  subroutine particle_set_without_hadronic_remnants &
         (particle_set, particles, n_particles, n_extra)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), dimension(:), allocatable, intent(out) :: particles
    integer, intent(out) :: n_particles
    integer, intent(in) :: n_extra
    logical, dimension(:), allocatable :: no_hadronic_remnants, &
         no_hadronic_children
    integer, dimension(:), allocatable :: children, new_children
    integer :: i, j, k, first_remnant
    first_remnant = particle_set%n_tot
    do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%is_hadronic_beam_remnant ()) then
          first_remnant = i
          exit
       end if
    end do
    n_particles = count (.not. particle_set%prt%is_hadronic_beam_remnant ())
    allocate (no_hadronic_remnants (particle_set%n_tot))
    !!! !!! !!! Workaround for intel 16.0 standard-semantics bug
    !!! no_hadronic_remnants = .not. particle_set%prt%is_hadronic_beam_remnant ()
    do i = 1, particle_set%n_tot
       no_hadronic_remnants(i) = .not. particle_set%prt(i)%is_hadronic_beam_remnant ()
    end do
    allocate (particles (n_particles + n_extra))
    k = 1
    do i = 1, particle_set%n_tot
       if (no_hadronic_remnants(i)) then
          particles(k) = particle_set%prt(i)
          k = k + 1
       end if
    end do
    if (n_particles /= particle_set%n_tot) then
       do i = 1, n_particles
          select case (particles(i)%get_status ())
          case (PRT_BEAM)
             if (allocated (children))  deallocate (children)
             allocate (children (particles(i)%get_n_children ()))
             children = particles(i)%get_children ()
             if (allocated (no_hadronic_children)) &
                  deallocate (no_hadronic_children)
             allocate (no_hadronic_children (particles(i)%get_n_children ()))
             no_hadronic_children = .not. &
                  particle_set%prt(children)%is_hadronic_beam_remnant ()             
             if (allocated (new_children))  deallocate (new_children)
             allocate (new_children (count (no_hadronic_children)))
             new_children = pack (children, no_hadronic_children)
             call particles(i)%set_children (new_children) 
          case (PRT_INCOMING, PRT_RESONANT)
             <<update children after remnant>>
          case (PRT_OUTGOING, PRT_BEAM_REMNANT)
          case default
          end select
       end do
    end if
  end subroutine particle_set_without_hadronic_remnants

@ %def particle_set_without_hadronic_remnants
<<update children after remnant>>=
if (allocated (children))  deallocate (children)
allocate (children (particles(i)%get_n_children ()))  
children = particles(i)%get_children ()
do j = 1, size (children)
   if (children(j) > first_remnant) then
      children(j) = children (j) - &
           (particle_set%n_tot - n_particles)
   end if
end do
call particles(i)%set_children (children)
@
Build a new particles array without remnants but with
[[n_extra]] additional spots.  We also update the mother-daughter
relations assuming the ordering [[b]], [[i]], [[r]], [[x]], [[o]].
<<Particles: particle set: TBP>>=
  procedure :: without_remnants => particle_set_without_remnants
<<Particles: procedures>>=
  subroutine particle_set_without_remnants &
         (particle_set, particles, n_particles, n_extra)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), dimension(:), allocatable, intent(out) :: particles
    integer, intent(in) :: n_extra
    integer, intent(out) :: n_particles
    logical, dimension(:), allocatable :: no_remnants, no_children
    integer, dimension(:), allocatable :: children, new_children
    integer :: i,j, k, first_remnant
    first_remnant = particle_set%n_tot
    do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%is_beam_remnant ()) then
          first_remnant = i
          exit
       end if
    end do
    allocate (no_remnants (particle_set%n_tot))
    no_remnants = .not. (particle_set%prt%is_beam_remnant ())    
    n_particles = count (no_remnants)
    allocate (particles (n_particles + n_extra))
    k = 1
    do i = 1, particle_set%n_tot
       if (no_remnants(i)) then
          particles(k) = particle_set%prt(i)
          k = k + 1
       end if
    end do
    if (n_particles /= particle_set%n_tot) then
       do i = 1, n_particles
          select case (particles(i)%get_status ())
          case (PRT_BEAM)
             if (allocated (children))  deallocate (children)
             allocate (children (particles(i)%get_n_children ()))
             children = particles(i)%get_children ()
             if (allocated (no_children))  deallocate (no_children)
             allocate (no_children (particles(i)%get_n_children ()))
             no_children = .not. (particle_set%prt(children)%is_beam_remnant ())
             if (allocated (new_children))  deallocate (new_children)
             allocate (new_children (count (no_children)))
             new_children = pack (children, no_children)
             call particles(i)%set_children (new_children)
          case (PRT_INCOMING, PRT_RESONANT)
             <<update children after remnant>>
          case (PRT_OUTGOING, PRT_BEAM_REMNANT)
          case default
          end select
       end do
    end if
  end subroutine particle_set_without_remnants

@ %def particle_set_without_remnants
@
<<Particles: particle set: TBP>>=
  procedure :: find_particle => particle_set_find_particle
<<Particles: procedures>>=
  pure function particle_set_find_particle &
         (particle_set, pdg, momentum, abs_smallness, rel_smallness) result (idx)
    integer :: idx
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: pdg
    type(vector4_t), intent(in) :: momentum
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    integer :: i, j
    logical, dimension(0:3) :: equals
    idx = 0
    do i = 1, size (particle_set%prt)
       if (particle_set%prt(i)%flv%get_pdg () == pdg) then
          !!! Workaround for gfortran 4.8.3 with overloaded elemental function
          do j = 0, 3
            equals(j) = nearly_equal (particle_set%prt(i)%p%p(j), momentum%p(j), &
                                   abs_smallness, rel_smallness)
          end do
          if (all (equals)) then
             idx = i
             return
          end if
       end if
    end do
  end function particle_set_find_particle

@ %def particle_set_find_particle
<<Particles: particle set: TBP>>=
  procedure :: reverse_find_particle => particle_set_reverse_find_particle
<<Particles: procedures>>=
  pure function particle_set_reverse_find_particle &
         (particle_set, pdg, momentum, abs_smallness, rel_smallness) result (idx)
    integer :: idx
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: pdg
    type(vector4_t), intent(in) :: momentum
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    integer :: i
    idx = 0
    do i = size (particle_set%prt), 1, -1
       if (particle_set%prt(i)%flv%get_pdg () == pdg) then
          if (all (nearly_equal (particle_set%prt(i)%p%p, momentum%p, &
                                 abs_smallness, rel_smallness))) then
             idx = i
             return
          end if
       end if
    end do
  end function particle_set_reverse_find_particle

@ %def particle_set_reverse_find_particle
@ This connects broken links of the form
$\text{something} \to i \to \text{none or} j$ and
$\text{none} \to j \to \text{something or none}$ where the particles $i$ and $j$
are \emph{identical}.  It also works if $i \to j$, directly, and thus
removes duplicates.  We are removing $j$ and connect the possible
daughters to $i$.
<<Particles: particle set: TBP>>=
  procedure :: remove_duplicates => particle_set_remove_duplicates
<<Particles: procedures>>=
  subroutine particle_set_remove_duplicates (particle_set, smallness)
    class(particle_set_t), intent(inout) :: particle_set
    real(default), intent(in) :: smallness
    integer :: n_removals
    integer, dimension(particle_set%n_tot) :: to_remove
    type(particle_t), dimension(:), allocatable :: particles
    type(vector4_t) :: p_i
    integer, dimension(:), allocatable :: map
    to_remove = 0
    call find_duplicates ()
    n_removals = count (to_remove > 0)
    if (n_removals > 0) then
       call strip_duplicates (particles)
       call particle_set%replace (particles)
    end if

  contains

  <<Particles: remove duplicates: procedures>>

  end subroutine particle_set_remove_duplicates

@ %def particle_set_remove_duplicates
@ This doesn't catch all cases. Missing are splittings of the type
$i \to \text{something and} j$.
<<Particles: remove duplicates: procedures>>=
  subroutine find_duplicates ()
    integer :: pdg_i, child_i, i, j
    OUTER: do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%status == PRT_OUTGOING .or. &
            particle_set%prt(i)%status == PRT_VIRTUAL .or. &
            particle_set%prt(i)%status == PRT_RESONANT) then
          if (allocated (particle_set%prt(i)%child)) then
             if (size (particle_set%prt(i)%child) > 1) cycle OUTER
             if (size (particle_set%prt(i)%child) == 1) then
                child_i = particle_set%prt(i)%child(1)
             else
                child_i = 0
             end if
          else
             child_i = 0
          end if
          pdg_i = particle_set%prt(i)%flv%get_pdg ()
          p_i = particle_set%prt(i)%p
          do j = i + 1, particle_set%n_tot
             if (pdg_i == particle_set%prt(j)%flv%get_pdg ()) then
                if (all (nearly_equal (particle_set%prt(j)%p%p, p_i%p, &
                     abs_smallness = smallness, &
                     rel_smallness = 1E4_default * smallness))) then
                   if (child_i == 0 .or. j == child_i) then
                      to_remove(j) = i
                      call msg_debug2 (D_PARTICLES, &
                           "Particles: Will remove duplicate of i", i)
                      call msg_debug2 (D_PARTICLES, &
                           "Particles: j", j)
                   end if
                   cycle OUTER
                end if
             end if
          end do
       end if
    end do OUTER
  end subroutine find_duplicates 

@
<<Particles: remove duplicates: procedures>>=
  recursive function get_alive_index (try) result (alive)
    integer :: alive
    integer :: try
    if (map(try) > 0) then
       alive = map(try)
    else
       alive = get_alive_index (to_remove(try))
    end if
  end function get_alive_index

@
<<Particles: remove duplicates: procedures>>=
  subroutine strip_duplicates (particles)
    type(particle_t), dimension(:), allocatable, intent(out) :: particles
    integer :: kept, removed, i, j
    integer, dimension(:), allocatable :: old_children
    logical, dimension(:), allocatable :: parent_set
    call msg_debug (D_PARTICLES, "Particles: Removing duplicates")
    call msg_debug (D_PARTICLES, "Particles: n_removals", n_removals)
    if (debug2_active (D_PARTICLES)) then
       call msg_debug2 (D_PARTICLES, "Particles: Given set before removing:")
       call particle_set%write (summary=.true., compressed=.true.)
    end if
    allocate (particles (particle_set%n_tot - n_removals))
    allocate (map (particle_set%n_tot))
    allocate (parent_set (particle_set%n_tot))
    parent_set = .false.
    map = 0
    j = 0
    do i = 1, particle_set%n_tot
       if (to_remove(i) == 0) then
          j = j + 1
          map(i) = j
          call particles(j)%init (particle_set%prt(i))
       end if
    end do
    do i = 1, particle_set%n_tot
       if (map(i) /= 0) then
          if (.not. parent_set(map(i))) then
             call particles(map(i))%set_parents &
                  (map (particle_set%prt(i)%get_parents ()))
          end if
          call particles(map(i))%set_children &
               (map (particle_set%prt(i)%get_children ()))
       else
          removed = i
          kept = to_remove(i)
          if (particle_set%prt(removed)%has_children ()) then
             old_children = particle_set%prt(removed)%get_children ()
             do j = 1, size (old_children)
                if (map(old_children(j)) > 0) then
                   call particles(map(old_children(j)))%set_parents &
                        ([get_alive_index (kept)])
                   parent_set(map(old_children(j))) = .true.
                   call particles(get_alive_index (kept))%add_child &
                        (map(old_children(j)))
                end if
             end do
             particles(get_alive_index (kept))%status = PRT_RESONANT
          else
             particles(get_alive_index (kept))%status = PRT_OUTGOING
          end if
       end if
    end do
  end subroutine strip_duplicates

@ Given a subevent, reset status codes.  If the new status is beam,
incoming, or outgoing, we also make sure that the stored $p^2$ value
is equal to the on-shell mass squared.
<<Particles: particle set: TBP>>=
  procedure :: reset_status => particle_set_reset_status
<<Particles: procedures>>=
  subroutine particle_set_reset_status (particle_set, index, status)
    class(particle_set_t), intent(inout) :: particle_set
    integer, dimension(:), intent(in) :: index
    integer, intent(in) :: status
    integer :: i
    if (allocated (particle_set%prt)) then
       do i = 1, size (index)
          call particle_set%prt(index(i))%reset_status (status)
       end do
    end if
    particle_set%n_beam  = &
         count (particle_set%prt%get_status () == PRT_BEAM)
    particle_set%n_in  = &
         count (particle_set%prt%get_status () == PRT_INCOMING)
    particle_set%n_out = &
         count (particle_set%prt%get_status () == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_reset_status

@ %def particle_set_reset_status
@ Reduce a particle set to the essential entries.  The entries kept
are those with status [[INCOMING]], [[OUTGOING]] or
[[RESONANT]]. [[BEAM]] is kept if [[keep_beams]] is true. Other
entries are skipped. The correlated state matrix, if any, is also
ignored.
<<Particles: particle set: TBP>>=
  procedure :: reduce => particle_set_reduce
<<Particles: procedures>>=
  subroutine particle_set_reduce (pset_in, pset_out, keep_beams)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams
    integer, dimension(:), allocatable :: status, map
    integer :: i, j
    logical :: kb
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    allocate (status (pset_in%n_tot))    
    pset_out%factorization_mode = pset_in%factorization_mode
    !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
    do i = 1, pset_in%n_tot
       status(i) = pset_in%prt(i)%get_status ()
    end do
    !!! status = pset_in%prt%get_status ()
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    pset_out%n_vir = count (status == PRT_RESONANT)
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    map = 0
    j = 0
    if (kb) call copy_particles (PRT_BEAM)
    call copy_particles (PRT_INCOMING)
    call copy_particles (PRT_RESONANT)
    call copy_particles (PRT_OUTGOING)
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       !!! !!! triggers nagfor bug!
       !!!  call particle_set_parents (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_parents (pset_in, i)))
       !!!  call particle_set_children (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_children (pset_in, i)))
       !!! !!! workaround:
       call pset_out%prt(map(i))%set_parents &
            (pset_in%get_real_parents (i, kb))
       call pset_out%prt(map(i))%set_parents &
            (map (pset_out%prt(map(i))%parent))
       call pset_out%prt(map(i))%set_children &
            (pset_in%get_real_children (i, kb))
       call pset_out%prt(map(i))%set_children &
            (map (pset_out%prt(map(i))%child))
    end do
  contains
    subroutine copy_particles (stat)
      integer, intent(in) :: stat
      integer :: i
      do i = 1, pset_in%n_tot
         if (status(i) == stat) then
            j = j + 1
            map(i) = j
            call particle_init_particle (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles
  end subroutine particle_set_reduce

@ %def particles_set_reduce
@ Remove the beam particles and beam remnants from the particle set if the
keep beams flag is false. If keep beams is not given, the beam particles
and the beam remnants are removed.
The correlated state matrix, if any, is also ignored.
<<Particles: particle set: TBP>>=
  procedure :: filter_particles => particle_set_filter_particles
<<Particles: procedures>>=
  subroutine particle_set_filter_particles &
       (pset_in, pset_out, keep_beams, real_parents, keep_virtuals)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams, real_parents, keep_virtuals
    integer, dimension(:), allocatable :: status, map
    logical, dimension(:), allocatable :: filter
    integer :: i, j
    logical :: kb, rp, kv
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    rp = .false.; if (present (real_parents)) rp = real_parents
    kv = .true.; if (present (keep_virtuals)) kv = keep_virtuals
    call msg_debug (D_PARTICLES, "filter_particles")
    if (debug2_active (D_PARTICLES)) then
       print *, 'keep_beams =    ', kb
       print *, 'real_parents =    ', rp
       print *, 'keep_virtuals =    ', kv
       print *, '>>> pset_in : '
       call pset_in%write(compressed=.true.)
    end if
    call count_and_allocate()
    map = 0
    j = 0
    filter = .false.
    if (.not. kb) filter = status == PRT_BEAM .or. status == PRT_BEAM_REMNANT
    if (.not. kv) filter = filter .or. status == PRT_VIRTUAL
    call copy_particles ()
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       if (rp) then
          call pset_out%prt(map(i))%set_parents &
               (map (pset_in%get_real_parents (i, kb)))
          call pset_out%prt(map(i))%set_children &
               (map (pset_in%get_real_children (i, kb)))
       else
          call pset_out%prt(map(i))%set_parents &
               (map (pset_in%prt(i)%get_parents ()))
          call pset_out%prt(map(i))%set_children &
               (map (pset_in%prt(i)%get_children ()))
       end if
    end do
    if (debug2_active (D_PARTICLES)) then
       print *, '>>> pset_out : '
       call pset_out%write(compressed=.true.)
    end if
  contains
    <<filter particles: procedures>>
  end subroutine particle_set_filter_particles

@ %def particles_set_filter_particles
<<filter particles: procedures>>=
    subroutine copy_particles ()
      integer :: i
      do i = 1, pset_in%n_tot
         if (.not. filter(i)) then
            j = j + 1
            map(i) = j
            call particle_init_particle (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles

<<filter particles: procedures>>=
  subroutine count_and_allocate
    allocate (status (pset_in%n_tot))
    !!! !!! !!! Workaround for ifort standard-semantics bug
    do i = 1, pset_in%n_tot
       status(i) = particle_get_status (pset_in%prt(i))
    end do
    !!! status = particle_get_status (pset_in%prt)
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    if (kb .and. kv) then
       pset_out%n_vir = count (status == PRT_VIRTUAL) + &
            count (status == PRT_RESONANT) + &
            count (status == PRT_BEAM_REMNANT)
    else if (kb .and. .not. kv) then
       pset_out%n_vir = count (status == PRT_RESONANT) + &
            count (status == PRT_BEAM_REMNANT)
    else if (.not. kb .and. kv) then
       pset_out%n_vir = count (status == PRT_VIRTUAL) + &
            count (status == PRT_RESONANT)
    else 
       pset_out%n_vir = count (status == PRT_RESONANT)
    end if
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    allocate (filter (pset_in%n_tot))
  end subroutine count_and_allocate

@ Transform a particle set into HEPEVT-compatible form.  In this form, for each
particle, the parents and the children are contiguous in the particle array.
Usually, this requires to clone some particles.

We do not know in advance how many particles the canonical form will have.
To be on the safe side, allocate four times the original size.
<<Particles: particle set: TBP>>=
  procedure :: to_hepevt_form => particle_set_to_hepevt_form
<<Particles: procedures>>=
  subroutine particle_set_to_hepevt_form (pset_in, pset_out)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    type :: particle_entry_t
       integer :: src = 0
       integer :: status = 0
       integer :: orig = 0
       integer :: copy = 0
    end type particle_entry_t
    type(particle_entry_t), dimension(:), allocatable :: prt
    integer, dimension(:), allocatable :: map1, map2
    integer, dimension(:), allocatable :: parent, child
    integer :: n_tot, n_parents, n_children, i, j, c, n

    n_tot = pset_in%n_tot
    allocate (prt (4 * n_tot))
    allocate (map1(4 * n_tot))
    allocate (map2(4 * n_tot))
    map1 = 0
    map2 = 0
    allocate (child (n_tot))
    allocate (parent (n_tot))
    n = 0
    do i = 1, n_tot
       if (pset_in%prt(i)%get_n_parents () == 0) then
          call append (i)
       end if
    end do
    do i = 1, n_tot
       n_children = pset_in%prt(i)%get_n_children ()
       if (n_children > 0) then
          child(1:n_children) = pset_in%prt(i)%get_children ()
          c = child(1)
          if (map1(c) == 0) then
             n_parents = pset_in%prt(c)%get_n_parents ()
             if (n_parents > 1) then
                parent(1:n_parents) = pset_in%prt(c)%get_parents ()
                if (i == parent(1) .and. &
                    any( [(map1(i)+j-1, j=1,n_parents)] /= &
                           map1(parent(1:n_parents)))) then
                   do j = 1, n_parents
                      call append (parent(j))
                   end do
                end if
             else if (map1(i) == 0) then
                call append (i)
             end if
             do j = 1, n_children
                call append (child(j))
             end do
          end if
       else if (map1(i) == 0) then
          call append (i)
       end if
    end do
    do i = n, 1, -1
       if (prt(i)%status /= PRT_OUTGOING) then
          do j = 1, i-1
             if (prt(j)%status == PRT_OUTGOING) then
                call append(prt(j)%src)
             end if
          end do
          exit
       end if
    end do
    pset_out%n_beam = count (prt(1:n)%status == PRT_BEAM)
    pset_out%n_in   = count (prt(1:n)%status == PRT_INCOMING)
    pset_out%n_vir  = count (prt(1:n)%status == PRT_RESONANT)
    pset_out%n_out  = count (prt(1:n)%status == PRT_OUTGOING)
    pset_out%n_tot = n
    allocate (pset_out%prt (n))
    do i = 1, n
       call particle_init_particle (pset_out%prt(i), pset_in%prt(prt(i)%src))
       call pset_out%prt(i)%reset_status (prt(i)%status)
       if (prt(i)%orig == 0) then
          call pset_out%prt(i)%set_parents &
               (map2 (pset_in%prt(prt(i)%src)%get_parents ()))
       else
          call pset_out%prt(i)%set_parents ([ prt(i)%orig ])
       end if
       if (prt(i)%copy == 0) then
          call pset_out%prt(i)%set_children &
               (map1 (pset_in%prt(prt(i)%src)%get_children ()))
       else
          call pset_out%prt(i)%set_children ([ prt(i)%copy ])
       end if
    end do
  contains
    subroutine append (i)
      integer, intent(in) :: i
      n = n + 1
      if (n > size (prt)) &
           call msg_bug ("Particle set transform to HEPEVT: insufficient space")
      prt(n)%src = i
      prt(n)%status = pset_in%prt(i)%get_status ()
      if (map1(i) == 0) then
         map1(i) = n
      else
         prt(map2(i))%status = PRT_VIRTUAL
         prt(map2(i))%copy = n
         prt(n)%orig = map2(i)
      end if
      map2(i) = n
    end subroutine append
  end subroutine particle_set_to_hepevt_form

@ %def particle_set_to_hepevt_form
@ This procedure aims at reconstructing the momenta of an interaction,
given a particle set.  Since the particle orderings
<<Particles: particle set: TBP>>=
  procedure :: fill_interaction => particle_set_fill_interaction
<<Particles: procedures>>=
  subroutine particle_set_fill_interaction &
       (pset, int, n_in, recover_beams, check_match, state_flv)
    class(particle_set_t), intent(in) :: pset
    type(interaction_t), intent(inout) :: int
    integer, intent(in) :: n_in
    logical, intent(in), optional :: recover_beams, check_match
    type(state_flv_content_t), intent(in), optional :: state_flv
    integer, dimension(:), allocatable :: map, pdg
    integer, dimension(:), allocatable :: i_in, i_out, p_in, p_out
    logical, dimension(:), allocatable :: i_set
    integer :: n_out, i, p
    logical :: r_beams, check
    r_beams = .false.;  if (present (recover_beams))  r_beams = recover_beams
    check = .true.;  if (present (check_match))  check = check_match
    if (check) then
       call find_hard_process_in_int  (i_in, i_out)
       call find_hard_process_in_pset (p_in, p_out)
       n_out = size (i_out)
       if (size (i_in) /= n_in)  call err_int_n_in
       if (size (p_in) /= n_in)  call err_pset_n_in
       if (size (p_out) /= n_out)  call err_pset_n_out
       call extract_hard_process_from_pset (pdg)
       call determine_map_for_hard_process (map, state_flv)
       if (.not. r_beams) then
          select case (n_in)
          case (1)
             call recover_parents (p_in(1), map)
          case (2)
             do i = 1, 2
                call recover_parents (p_in(i), map)
             end do
             do p = 1, 2
                call recover_radiation (p, map)
             end do
          end select
       end if
    else
       allocate (map (int%get_n_tot ()))
       map = [(i, i = 1, size (map))]
       r_beams = .false.
    end if
    allocate (i_set (int%get_n_tot ()), source = .false.)
    do p = 1, size (map)
       if (map(p) /= 0) then
          i_set(map(p)) = .true.
          call int%set_momentum &
               (pset%prt(p)%get_momentum (), map(p))
       end if
    end do
    if (r_beams) then
       do i = 1, n_in
          call reconstruct_beam_and_radiation (i, i_set)
       end do
    end if
    if (any (.not. i_set))  call err_map
  contains
    subroutine find_hard_process_in_pset (p_in, p_out)
      integer, dimension(:), allocatable, intent(out) :: p_in, p_out
      integer, dimension(:), allocatable :: p_status, p_idx
      integer :: n_out_p
      integer :: i
      allocate (p_status (pset%n_tot), p_idx (pset%n_tot))
      !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
      !!! p_status = pset%prt%get_status ()
      do i = 1, pset%n_tot
         p_status(i) = pset%prt(i)%get_status ()
      end do
      p_idx = [(i, i = 1, pset%n_tot)]
      allocate (p_in (n_in))
      p_in = pack (p_idx, p_status == PRT_INCOMING)
      if (size (p_in) == 0)  call err_pset_hard
      i = p_in(1)
      n_out_p = particle_get_n_children (pset%prt(i))
      allocate (p_out (n_out_p))
      p_out = particle_get_children (pset%prt(i))
    end subroutine find_hard_process_in_pset
    subroutine find_hard_process_in_int (i_in, i_out)
      integer, dimension(:), allocatable, intent(out) :: i_in, i_out
      integer :: n_in_i
      integer :: i
      i = int%get_n_tot ()
      n_in_i = interaction_get_n_parents (int, i)
      if (n_in_i /= n_in)  call err_int_n_in
      allocate (i_in (n_in))
      i_in = interaction_get_parents (int, i)
      i = i_in(1)
      n_out = interaction_get_n_children (int, i)
      allocate (i_out (n_out))
      i_out = interaction_get_children (int, i)
    end subroutine find_hard_process_in_int
    subroutine extract_hard_process_from_pset (pdg)
      integer, dimension(:), allocatable, intent(out) :: pdg
      integer, dimension(:), allocatable :: pdg_p
      logical, dimension(:), allocatable :: mask_p
      integer :: i
      allocate (pdg_p (pset%n_tot))
      !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
      !!! pdg_p = pset%prt%get_pdg ()
      do i = 1, pset%n_tot
         pdg_p(i) = pset%prt(i)%get_pdg ()      
      end do
      allocate (mask_p (pset%n_tot), source = .false.)
      mask_p (p_in) = .true.
      mask_p (p_out) = .true.
      allocate (pdg (n_in + n_out))
      pdg = pack (pdg_p, mask_p)
    end subroutine extract_hard_process_from_pset
    subroutine determine_map_for_hard_process (map, state_flv)
      integer, dimension(:), allocatable, intent(out) :: map
      type(state_flv_content_t), intent(in), optional :: state_flv
      integer, dimension(:), allocatable :: pdg_i, map_i
      integer :: n_tot
      logical, dimension(:), allocatable :: mask_i, mask_p
      logical :: success
      n_tot = int%get_n_tot ()
      if (present (state_flv)) then
         allocate (mask_i (n_tot), source = .false.)
         mask_i (i_in) = .true.
         mask_i (i_out) = .true.
         allocate (pdg_i (n_tot), map_i (n_tot))
         pdg_i = unpack (pdg, mask_i, 0)
         call state_flv%match (pdg_i, success, map_i)
         allocate (mask_p (pset%n_tot), source = .false.)
         mask_p (p_in) = .true.
         mask_p (p_out) = .true.
         allocate (map (size (mask_p)), &
              source = unpack (pack (map_i, mask_i), mask_p, 0))
         if (.not. success)  call err_mismatch
      else
         allocate (map (n_tot), source = 0)         
         map(p_in) = i_in
         map(p_out) = i_out
      end if
    end subroutine determine_map_for_hard_process
    recursive subroutine recover_parents (p, map)
      integer, intent(in) :: p
      integer, dimension(:), intent(inout) :: map
      integer :: i, n, n_p, q, k
      integer, dimension(:), allocatable :: i_parents, p_parents
      integer, dimension(1) :: pp
      i = map(p)
      n = interaction_get_n_parents (int, i)
      q = p
      n_p = particle_get_n_parents (pset%prt(q))
      do while (n_p == 1)
         pp = particle_get_parents (pset%prt(q))
         if (pset%prt(pp(1))%get_n_children () > 1)  exit
         q = pp(1)
         n_p = pset%prt(q)%get_n_parents ()
      end do
      if (n_p /= n)  call err_map
      allocate (i_parents (n), p_parents (n))
      i_parents = interaction_get_parents (int, i)
      p_parents = pset%prt(q)%get_parents ()
      do k = 1, n
         q = p_parents(k)
         if (map(q) == 0) then
            map(q) = i_parents(k)
            call recover_parents (q, map)
         end if
      end do
    end subroutine recover_parents
    recursive subroutine recover_radiation (p, map)
      integer, intent(in) :: p
      integer, dimension(:), intent(inout) :: map
      integer :: i, n, n_p, q, k
      integer, dimension(:), allocatable :: i_children, p_children
      if (particle_get_status (pset%prt(p)) == PRT_INCOMING)  return
      i = map(p)
      n = interaction_get_n_children (int, i)
      n_p = pset%prt(p)%get_n_children ()
      if (n_p /= n)  call err_map
      allocate (i_children (n), p_children (n))
      i_children = interaction_get_children (int, i)
      p_children = pset%prt(p)%get_children ()
      do k = 1, n
         q = p_children(k)
         if (map(q) == 0) then
            i = i_children(k)
            if (interaction_get_n_children (int, i) == 0) then
               map(q) = i
            else
               select case (n)
               case (2)
                  select case (k)
                  case (1);  map(q) = i_children(2)
                  case (2);  map(q) = i_children(1)
                  end select
               case (4)
                  select case (k)
                  case (1);  map(q) = i_children(3)
                  case (2);  map(q) = i_children(4)
                  case (3);  map(q) = i_children(1)
                  case (4);  map(q) = i_children(2)
                  end select
               case default
                  call err_radiation
               end select
            end if
         else
            call recover_radiation (q, map)
         end if
      end do
    end subroutine recover_radiation
    subroutine reconstruct_beam_and_radiation (k, i_set)
      integer, intent(in) :: k
      logical, dimension(:), intent(inout) :: i_set
      integer :: k_src, k_in, k_rad
      type(interaction_t), pointer :: int_src
      integer, dimension(2) :: i_child
      call int%find_source (k, int_src, k_src)
      call int%set_momentum (int_src%get_momentum (k_src), k)
      i_set(k) = .true.
      if (n_in == 2) then
         i_child = interaction_get_children (int, k)
         if (interaction_get_n_children (int, i_child(1)) > 0) then
            k_in = i_child(1);  k_rad = i_child(2)
         else
            k_in = i_child(2);  k_rad = i_child(1)
         end if
         if (.not. i_set(k_in))  call err_beams
         call int%set_momentum &
              (int%get_momentum (k) - int%get_momentum (k_in), k_rad)
         i_set(k_rad) = .true.
      end if
    end subroutine reconstruct_beam_and_radiation
    subroutine err_pset_hard
      call msg_fatal ("Reading particle set: no particles marked as incoming")
    end subroutine err_pset_hard
    subroutine err_int_n_in
      integer :: n
      if (allocated (i_in)) then
         n = size (i_in)
      else
         n = 0
      end if
      write (msg_buffer, "(A,I0,A,I0)") &
           "Filling hard process from particle set: expect ", n_in, &
           " incoming particle(s), found ", n
      call msg_bug
    end subroutine err_int_n_in
    subroutine err_pset_n_in
      write (msg_buffer, "(A,I0,A,I0)") &
           "Reading hard-process particle set: should contain ", n_in, &
           " incoming particle(s), found ", size (p_in)
      call msg_fatal
    end subroutine err_pset_n_in
    subroutine err_pset_n_out
      write (msg_buffer, "(A,I0,A,I0)") &
           "Reading hard-process particle set: should contain ", n_out, &
           " outgoing particle(s), found ", size (p_out)
      call msg_fatal
    end subroutine err_pset_n_out
    subroutine err_mismatch
      call pset%write ()
      call state_flv%write ()
      call msg_fatal ("Reading particle set: Flavor combination " &
           // "does not match requested process")
    end subroutine err_mismatch
    subroutine err_map
      call pset%write ()
      call int%basic_write ()
      call msg_fatal ("Reading hard-process particle set: " &
           // "Incomplete mapping from particle set to interaction")
    end subroutine err_map
    subroutine err_beams
      call pset%write ()
      call int%basic_write ()
      call msg_fatal ("Reading particle set: Beam structure " &
           // "does not match requested process")
    end subroutine err_beams
    subroutine err_radiation
      call int%basic_write ()
      call msg_bug ("Reading particle set: Interaction " &
           // "contains inconsistent radiation pattern.")
    end subroutine err_radiation
  end subroutine particle_set_fill_interaction
    
@ %def particle_set_fill_interaction
@
This procedure reconstructs an array of vertex indices from the
parent-child information in the particle entries, according to the
HepMC scheme.  For each particle, we determine which vertex it comes
from and which vertex it goes to.  We return the two arrays and the
maximum vertex index.

For each particle in the list, we first check its parents.  If for any
parent the vertex where it goes to is already known, this vertex index
is assigned as the current 'from' vertex.  Otherwise, a new index is
created, assigned as the current 'from' vertex, and as the 'to' vertex
for all parents.

Then, the analogous procedure is done for the children.

Furthermore, we assign to each vertex the vertex position from the
parent(s). We check that these vertex positions coincide, and if not
return a null vector.
<<Particles: particle set: TBP>>=
  procedure :: assign_vertices => particle_set_assign_vertices
<<Particles: procedures>>=
  subroutine particle_set_assign_vertices &
       (particle_set, v_from, v_to, n_vertices)
    class(particle_set_t), intent(in) :: particle_set
    integer, dimension(:), intent(out) :: v_from, v_to
    integer, intent(out) :: n_vertices
    integer, dimension(:), allocatable :: parent, child
    integer :: n_parents, n_children, vf, vt
    integer :: i, j, v
    v_from = 0
    v_to = 0
    vf = 0
    vt = 0
    do i = 1, particle_set%n_tot
       n_parents = particle_set%prt(i)%get_n_parents ()
       if (n_parents /= 0) then
          allocate (parent (n_parents))
          parent = particle_set%prt(i)%get_parents ()
          SCAN_PARENTS: do j = 1, size (parent)
             v = v_to(parent(j))
             if (v /= 0) then
                v_from(i) = v;  exit SCAN_PARENTS
             end if
          end do SCAN_PARENTS
          if (v_from(i) == 0) then
             vf = vf + 1;  v_from(i) = vf
             v_to(parent) = vf
          end if
          deallocate (parent)
       end if
       n_children = particle_set%prt(i)%get_n_children ()
       if (n_children /= 0) then
          allocate (child (n_children))
          child = particle_set%prt(i)%get_children ()
          SCAN_CHILDREN: do j = 1, size (child)
             v = v_from(child(j))
             if (v /= 0) then
                v_to(i) = v;  exit SCAN_CHILDREN
             end if
          end do SCAN_CHILDREN
          if (v_to(i) == 0) then
             vt = vt + 1;  v_to(i) = vt
             v_from(child) = vt
          end if
          deallocate (child)
       end if
    end do
    n_vertices = max (vf, vt)
  end subroutine particle_set_assign_vertices

@ %def particle_set_assign_vertices
@ 
\subsection{Expression interface}
This converts a [[particle_set]] object as defined here to a more
concise [[subevt]] object that can be used as the event root of an
expression.  In particular, the latter lacks virtual particles, spin
correlations and parent-child relations.

We keep beam particles, incoming partons, and outgoing partons.
Furthermore, we keep radiated particles (a.k.a.\ beam remnants) if
they have no children in the current particle set, and mark them as
outgoing particles.
<<Particles: particle set: TBP>>=
  procedure :: to_subevt => particle_set_to_subevt
<<Particles: procedures>>=
  subroutine particle_set_to_subevt (particle_set, subevt)
    class(particle_set_t), intent(in) :: particle_set
    type(subevt_t), intent(out) :: subevt
    integer :: n_tot, n_beam, n_in, n_out, n_rad
    integer :: i, k, n_active
    integer, dimension(2) :: hel
    logical :: keep
    n_tot  = particle_set_get_n_tot      (particle_set)
    n_beam = particle_set_get_n_beam     (particle_set)
    n_in   = particle_set_get_n_in       (particle_set)
    n_out  = particle_set_get_n_out      (particle_set)
    n_rad  = particle_set_get_n_remnants (particle_set)
    call subevt_init (subevt, n_beam + n_rad + n_in + n_out)
    k = 0
    do i = 1, n_tot
       associate (prt => particle_set%prt(i))
         keep = .false.
         select case (particle_get_status (prt))
         case (PRT_BEAM)
            k = k + 1
            call subevt_set_beam (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_INCOMING)
            k = k + 1
            call subevt_set_incoming (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_OUTGOING)
            k = k + 1
            call subevt_set_outgoing (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_BEAM_REMNANT)
            if (particle_get_n_children (prt) == 0) then
               k = k + 1
               call subevt_set_outgoing (subevt, k, &
                    particle_get_pdg (prt), &
                    particle_get_momentum (prt), &
                    particle_get_p2 (prt))
               keep = .true.
            end if
         end select
         if (keep) then
            if (prt%polarization == PRT_DEFINITE_HELICITY) then
               if (prt%hel%is_diagonal ()) then
                  hel = prt%hel%to_pair ()
                  call subevt_polarize (subevt, k, hel(1))
               end if
            end if
         end if
       end associate
       n_active = k
    end do
    call subevt_reset (subevt, n_active)
  end subroutine particle_set_to_subevt

@ %def particle_set_to_subevt
@ 
This replaces the [[particle\_set\%prt array]] with a given array of particles
<<Particles: particle set: TBP>>=
  procedure :: replace => particle_set_replace
<<Particles: procedures>>=
  subroutine particle_set_replace (particle_set, newprt)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), intent(in), dimension(:), allocatable :: newprt
    if (allocated (particle_set%prt))  deallocate (particle_set%prt)
    allocate (particle_set%prt(size (newprt)))
    particle_set%prt = newprt
    particle_set%n_tot = size (newprt)
    particle_set%n_beam = count (particle_get_status (newprt) == PRT_BEAM)
    particle_set%n_in = count (particle_get_status (newprt) == PRT_INCOMING)
    particle_set%n_out = count (particle_get_status (newprt) == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_replace

@ %def particle_set_replace
@
Eliminate numerical noise
<<Particles: public>>=
  public :: pacify
<<Particles: interfaces>>=
  interface pacify
     module procedure pacify_particle
     module procedure pacify_particle_set
  end interface pacify

<<Particles: procedures>>=
  subroutine pacify_particle (prt)
    class(particle_t), intent(inout) :: prt
    real(default) :: e
    e = epsilon (1._default) * energy (prt%p)
    call pacify (prt%p, 10 * e)
    call pacify (prt%p2, 1e4 * e)
  end subroutine pacify_particle
  
  subroutine pacify_particle_set (pset)
    class(particle_set_t), intent(inout) :: pset
    integer :: i
    do i = 1, pset%n_tot
       call pacify (pset%prt(i))
    end do
  end subroutine pacify_particle_set

@ %def pacify
@ 
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[particles_ut.f90]]>>=
<<File header>>

module particles_ut
  use unit_tests
  use particles_uti
  
<<Standard module head>>

<<Particles: public test>>

contains
  
<<Particles: test driver>>

end module particles_ut
@ %def particles_ut
@
<<[[particles_uti.f90]]>>=
<<File header>>

module particles_uti

<<Use kinds>>
  use io_units
  use numeric_utils
  use constants, only: one, tiny_07
  use lorentz
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use model_data
  use subevents

  use particles

<<Standard module head>>

<<Particles: test declarations>>

contains

<<Particles: tests>>

<<Particles: test auxiliary>>

end module particles_uti
@ %def particles_ut
@ API: driver for the unit tests below.
<<Particles: public test>>=
  public :: particles_test
<<Particles: test driver>>=
  subroutine particles_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Particles: execute tests>>  
  end subroutine particles_test

@ %def particles_test  
@
Check the basic setup of the [[particle_set_t]] type:
Set up a chain of production and decay and factorize the result into
particles.  The process is $d\bar d \to Z \to q\bar q$.
<<Particles: execute tests>>=
  call test (particles_1, "particles_1", &
       "check particle_set routines", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_1
<<Particles: tests>>=  
  subroutine particles_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(3) :: flv
    type(color_t), dimension(3) :: col
    type(helicity_t), dimension(3) :: hel
    type(quantum_numbers_t), dimension(3) :: qn
    type(vector4_t), dimension(3) :: p
    type(interaction_t), target :: int1, int2
    type(quantum_numbers_mask_t) :: qn_mask_conn
    type(evaluator_t), target :: eval
    type(interaction_t) :: int
    type(particle_set_t) :: particle_set1, particle_set2
    type(particle_set_t) :: particle_set3, particle_set4
    type(subevt_t) :: subevt
    logical :: ok
    integer :: unit, iostat      

    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: test particle_set routines"
    write (u, "(A)")      

    write (u, "(A)")  "* Reading model file"

    call model%init_sm_test ()

    write (u, "(A)")
    write (u, "(A)")  "* Initializing production process"

    call int1%basic_init (2, 0, 1, set_relations=.true.)
    call flv%init ([1, -1, 23], model)
    call col%init_col_acl ([0, 0, 0], [0, 0, 0])
    call hel(3)%init (1, 1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.25_default, 0._default))
    call hel(3)%init (1,-1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0._default, 0.25_default))
    call hel(3)%init (-1, 1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0._default,-0.25_default))
    call hel(3)%init (-1,-1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.25_default, 0._default))
    call hel(3)%init (0, 0)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.5_default, 0._default))
    call int1%freeze ()
    p(1) = vector4_moving (45._default, 45._default, 3)
    p(2) = vector4_moving (45._default,-45._default, 3)
    p(3) = p(1) + p(2)
    call int1%set_momenta (p)

    write (u, "(A)")
    write (u, "(A)")  "* Setup decay process"

    call int2%basic_init (1, 0, 2, set_relations=.true.)
    call flv%init ([23, 1, -1], model)
    call col%init_col_acl ([0, 501, 0], [0, 0, 501])
    call hel%init ([1, 1, 1], [1, 1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(1._default, 0._default))
    call hel%init ([1, 1, 1], [-1,-1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0._default, 0.1_default))
    call hel%init ([-1,-1,-1], [1, 1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0._default,-0.1_default))
    call hel%init ([-1,-1,-1], [-1,-1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(1._default, 0._default))
    call hel%init ([0, 1,-1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(4._default, 0._default))
    call hel%init ([0,-1, 1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(2._default, 0._default))
    call hel%init ([0, 1,-1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(2._default, 0._default))
    call hel%init ([0,-1, 1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(4._default, 0._default))
    call flv%init ([23, 2, -2], model)
    call hel%init ([0, 1,-1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0.5_default, 0._default))
    call hel%init ([0,-1, 1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0.5_default, 0._default))
    call int2%freeze ()
    p(2) = vector4_moving (45._default, 45._default, 2)
    p(3) = vector4_moving (45._default,-45._default, 2)
    call int2%set_momenta (p)
    call int2%set_source_link (1, int1, 3)
    call int1%basic_write (u)
    call int2%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Concatenate production and decay"

    call eval%init_product (int1, int2, qn_mask_conn, &
         connections_are_resonant=.true.)
    call eval%receive_momenta ()
    call eval%evaluate ()
    call eval%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, polarized)"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set1%init &
         (ok, int, int, FM_FACTOR_HELICITY, &
          [0.2_default, 0.2_default], .false., .true.)
    call particle_set1%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (in/out only, selected helicity)"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set2%init &
         (ok, int, int, FM_SELECT_HELICITY, &
          [0.9_default, 0.9_default], .false., .false.)
    call particle_set2%write (u)
    call particle_set2%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, selected helicity)"
    write (u, "(A)") 
    
    int = eval%interaction_t
    call particle_set2%init &
         (ok, int, int, FM_SELECT_HELICITY, &
          [0.7_default, 0.7_default], .false., .true.)
    call particle_set2%write (u)      
        
    write (u, "(A)")
    write (u, "(A)")  &
         "* Factorize (complete, polarized, correlated); write and read again"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set3%init &
         (ok, int, int, FM_FACTOR_HELICITY, &
          [0.7_default, 0.7_default], .true., .true.)
    call particle_set3%write (u)

    unit = free_unit ()
    open (unit, action="readwrite", form="unformatted", status="scratch")
    call particle_set3%write_raw (unit)
    rewind (unit)
    call particle_set4%read_raw (unit, iostat=iostat)
    call particle_set4%set_model (model)
    close (unit)
    
    write (u, "(A)")
    write (u, "(A)")  "* Result from reading"
    write (u, "(A)")

    call particle_set4%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transform to a subevt object"
    write (u, "(A)")
    
    call particle_set4%to_subevt (subevt)
    call subevt_write (subevt, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call particle_set1%final ()
    call particle_set2%final ()
    call particle_set3%final ()
    call particle_set4%final ()
    call eval%final ()
    call int1%final ()
    call int2%final ()

    call model%final ()
       
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_1"        
    
  end subroutine particles_1

@ %def particles_1
@ 
Reconstruct a hard interaction from a particle set.
<<Particles: execute tests>>=
  call test (particles_2, "particles_2", &
       "reconstruct hard interaction", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_2
<<Particles: tests>>=  
  subroutine particles_2 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct simple interaction"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 3 interaction"
    write (u, "(A)")  "    + incoming partons marked as virtual"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 2, 3)
    do i = 1, 2
       do j = 3, 5
          call int%relate (i, j)
       end do
    end do

    allocate (qn (5))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [11, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 2
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 5
    allocate (pset%prt (pset%n_tot))
    do i = 1, 2
       call pset%prt(i)%reset_status (PRT_INCOMING)
       call pset%prt(i)%set_children ([3,4,5])
    end do
    do i = 3, 5
       call pset%prt(i)%reset_status (PRT_OUTGOING)
       call pset%prt(i)%set_parents ([1,2])
    end do
    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))

    allocate (flv (5))
    call flv%init ([11,12,5,4,3])
    do i = 1, 5
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_2"

  end subroutine particles_2
  
@ %def particles_2
@ 
Reconstruct an interaction with beam structure, e.g., a hadronic
interaction, from a particle set.
<<Particles: execute tests>>=
  call test (particles_3, "particles_3", &
       "reconstruct interaction with beam structure", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_3
<<Particles: tests>>=  
  subroutine particles_3 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct simple interaction"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")

    call create_test_particle_set_1 (pset)

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_3"

  end subroutine particles_3
  
@ %def particles_3
@
<<Particles: test auxiliary>>=
  subroutine create_test_particle_set_1 (pset)
    type(particle_set_t), intent(out) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 2
    pset%n_out  = 3
    pset%n_tot  = 9

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_INCOMING)
    call pset%prt(4)%reset_status (PRT_INCOMING)
    call pset%prt(5)%reset_status (PRT_BEAM_REMNANT)
    call pset%prt(6)%reset_status (PRT_BEAM_REMNANT)
    call pset%prt(7)%reset_status (PRT_OUTGOING)
    call pset%prt(8)%reset_status (PRT_OUTGOING)
    call pset%prt(9)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,5])
    call pset%prt(2)%set_children ([4,6])
    call pset%prt(3)%set_children ([7,8,9])
    call pset%prt(4)%set_children ([7,8,9])

    call pset%prt(3)%set_parents ([1])
    call pset%prt(4)%set_parents ([2])
    call pset%prt(5)%set_parents ([1])
    call pset%prt(6)%set_parents ([2])
    call pset%prt(7)%set_parents ([3,4])
    call pset%prt(8)%set_parents ([3,4])
    call pset%prt(9)%set_parents ([3,4])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(9)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (9))
    call flv%init ([2011, 2012, 11, 12, 91, 92, 3, 4, 5])
    do i = 1, 9
       call pset%prt(i)%set_flavor (flv(i))
    end do
  end subroutine create_test_particle_set_1

@ %def create_test_particle_set_1

@ 
Reconstruct an interaction with beam structure, e.g., a hadronic
interaction, from a particle set that is missing the beam information.
<<Particles: execute tests>>=
  call test (particles_4, "particles_4", &
       "reconstruct interaction with missing beams", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_4
<<Particles: tests>>=  
  subroutine particles_4 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(interaction_t), target :: int_beams
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct beams"
    write (u, "(A)")      

    call reset_interaction_counter ()

    write (u, "(A)")  "* Set up an interaction that contains beams only"
    write (u, "(A)")      

    call int_beams%basic_init (0, 0, 2)
    call int_beams%set_momentum (vector4_at_rest (1._default), 1)
    call int_beams%set_momentum (vector4_at_rest (2._default), 2)
    allocate (qn (2))
    call int_beams%add_state (qn)
    call int_beams%freeze ()
    
    call int_beams%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do
    do i = 1, 2
       call int%set_source_link (i, int_beams, i)
    end do

    deallocate (qn)
    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 2
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 5

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_INCOMING)
    call pset%prt(2)%reset_status (PRT_INCOMING)
    call pset%prt(3)%reset_status (PRT_OUTGOING)
    call pset%prt(4)%reset_status (PRT_OUTGOING)
    call pset%prt(5)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4,5])
    call pset%prt(2)%set_children ([3,4,5])

    call pset%prt(3)%set_parents ([1,2])
    call pset%prt(4)%set_parents ([1,2])
    call pset%prt(5)%set_parents ([1,2])

    call pset%prt(1)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (5._default))

    allocate (flv (5))
    call flv%init ([11, 12, 3, 4, 5])
    do i = 1, 5
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv, &
         recover_beams = .true.)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_4"

  end subroutine particles_4
  
@ %def particles_4
@ 
Reconstruct an interaction with beam structure and cloned particles
(radiated particles repeated in the event record, to maintain some
canonical ordering).
<<Particles: execute tests>>=
  call test (particles_5, "particles_5", &
       "reconstruct interaction with beams and duplicate entries", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_5
<<Particles: tests>>=  
  subroutine particles_5 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct event with duplicate entries"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 4
    pset%n_out  = 5
    pset%n_tot  = 13

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_VIRTUAL)
    call pset%prt(4)%reset_status (PRT_VIRTUAL)
    call pset%prt(5)%reset_status (PRT_VIRTUAL)
    call pset%prt(6)%reset_status (PRT_VIRTUAL)
    call pset%prt(7)%reset_status (PRT_INCOMING)
    call pset%prt(8)%reset_status (PRT_INCOMING)
    call pset%prt( 9)%reset_status (PRT_OUTGOING)
    call pset%prt(10)%reset_status (PRT_OUTGOING)
    call pset%prt(11)%reset_status (PRT_OUTGOING)
    call pset%prt(12)%reset_status (PRT_OUTGOING)
    call pset%prt(13)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4])
    call pset%prt(2)%set_children ([5,6])
    call pset%prt(3)%set_children ([ 7])
    call pset%prt(4)%set_children ([ 9])
    call pset%prt(5)%set_children ([ 8])
    call pset%prt(6)%set_children ([10])
    call pset%prt(7)%set_children ([11,12,13])
    call pset%prt(8)%set_children ([11,12,13])

    call pset%prt(3)%set_parents ([1])
    call pset%prt(4)%set_parents ([1])
    call pset%prt(5)%set_parents ([2])
    call pset%prt(6)%set_parents ([2])
    call pset%prt( 7)%set_parents ([3])
    call pset%prt( 8)%set_parents ([5])
    call pset%prt( 9)%set_parents ([4])
    call pset%prt(10)%set_parents ([6])
    call pset%prt(11)%set_parents ([7,8])
    call pset%prt(12)%set_parents ([7,8])
    call pset%prt(13)%set_parents ([7,8])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (6._default))
    call pset%prt( 9)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(10)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(11)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(12)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(13)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (13))
    call flv%init ([2011, 2012, 11, 91, 12, 92, 11, 12, 91, 92, 3, 4, 5])
    do i = 1, 13
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_5"

  end subroutine particles_5
  
@ %def particles_5
@ 
Reconstruct an interaction with pair spectrum, e.g., beamstrahlung from a
particle set. 
<<Particles: execute tests>>=
  call test (particles_6, "particles_6", &
       "reconstruct interaction with pair spectrum", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_6
<<Particles: tests>>=  
  subroutine particles_6 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct interaction with pair spectrum"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    do i = 1, 2
       do j = 3, 6
          call int%relate (i, j)
       end do
    end do
    do i = 5, 6
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [1011, 1012, 21, 22, 11, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 2
    pset%n_out  = 3
    pset%n_tot  = 9

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_INCOMING)
    call pset%prt(4)%reset_status (PRT_INCOMING)
    call pset%prt(5)%reset_status (PRT_OUTGOING)
    call pset%prt(6)%reset_status (PRT_OUTGOING)
    call pset%prt(7)%reset_status (PRT_OUTGOING)
    call pset%prt(8)%reset_status (PRT_OUTGOING)
    call pset%prt(9)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4,5,6])
    call pset%prt(2)%set_children ([3,4,5,6])
    call pset%prt(3)%set_children ([7,8,9])
    call pset%prt(4)%set_children ([7,8,9])

    call pset%prt(3)%set_parents ([1,2])
    call pset%prt(4)%set_parents ([1,2])
    call pset%prt(5)%set_parents ([1,2])
    call pset%prt(6)%set_parents ([1,2])
    call pset%prt(7)%set_parents ([3,4])
    call pset%prt(8)%set_parents ([3,4])
    call pset%prt(9)%set_parents ([3,4])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(9)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (9))
    call flv%init ([1011, 1012, 11, 12, 21, 22, 3, 4, 5])
    do i = 1, 9
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_6"

  end subroutine particles_6
  
@ %def particles_6
@ 
Reconstruct a hard decay interaction from a shuffled particle set.
<<Particles: execute tests>>=
  call test (particles_7, "particles_7", &
       "reconstruct decay interaction with reordering", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_7
<<Particles: tests>>=  
  subroutine particles_7 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct decay interaction with reordering"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 1 -> 3 interaction"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 1, 3)
    do j = 2, 4
       call int%relate (1, j)
    end do

    allocate (qn (4))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")  "*   assumed interaction: 6 12 5 -11"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [6, 5, -11, 12], &
         map = [1, 4, 2, 3])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 1
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 4
    allocate (pset%prt (pset%n_tot))
    do i = 1, 1
       call pset%prt(i)%reset_status (PRT_INCOMING)
       call pset%prt(i)%set_children ([2,3,4])
    end do
    do i = 2, 4
       call pset%prt(i)%reset_status (PRT_OUTGOING)
       call pset%prt(i)%set_parents ([1])
    end do
    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))

    allocate (flv (4))
    call flv%init ([6,5,12,-11])
    do i = 1, 4
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 1, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_7"

  end subroutine particles_7
  
@ %def particles_7
@
<<Particles: execute tests>>=
  call test (particles_8, "particles_8", &
            "Test functions on particle sets", u, results)
<<Particles: test declarations>>= 
  public :: particles_8
<<Particles: tests>>=
  subroutine particles_8 (u)
    integer, intent(in) :: u
    type(particle_set_t) :: particle_set
    type(particle_t), dimension(:), allocatable :: particles
    integer, allocatable, dimension(:) :: children, parents
    integer :: n_particles, i
    write (u, "(A)")  "* Test output: particles_8"
    write (u, "(A)")  "*   Purpose: Test functions on particle sets"
    write (u, "(A)")

    call create_test_particle_set_1 (particle_set)
    call particle_set%write (u)
    call assert_equal (u, particle_set%n_tot, 9)
    call assert_equal (u, particle_set%n_beam, 2)
    allocate (children (particle_set%prt(3)%get_n_children ()))
    children = particle_set%prt(3)%get_children()
    call assert_equal (u, particle_set%prt(children(1))%get_pdg (), 3)
    call assert_equal (u, size (particle_set%prt(1)%get_children ()), 2)
    call assert_equal (u, size (particle_set%prt(2)%get_children ()), 2)

    call particle_set%without_hadronic_remnants &
         (particles, n_particles, 3)
    call particle_set%replace (particles)
    write (u, "(A)")
    call particle_set%write (u)

    call assert_equal (u, n_particles, 7)
    call assert_equal (u, size(particles), 10)
    call assert_equal (u, particle_set%n_tot, 10)
    call assert_equal (u, particle_set%n_beam, 2)
    do i = 3, 4
       if (allocated (children))  deallocate (children)
       allocate (children (particle_set%prt(i)%get_n_children ()))
       children = particle_set%prt(i)%get_children()
       call assert_equal (u, particle_set%prt(children(1))%get_pdg (), 3)
       call assert_equal (u, particle_set%prt(children(2))%get_pdg (), 4)
       call assert_equal (u, particle_set%prt(children(3))%get_pdg (), 5)
    end do
    do i = 5, 7
       if (allocated (parents))  deallocate (parents)
       allocate (parents (particle_set%prt(i)%get_n_parents ()))
       parents = particle_set%prt(i)%get_parents()
       call assert_equal (u, particle_set%prt(parents(1))%get_pdg (), 11)
       call assert_equal (u, particle_set%prt(parents(2))%get_pdg (), 12)
    end do
    call assert_equal (u, size (particle_set%prt(1)%get_children ()), &
         1, "get children of 1")
    call assert_equal (u, size (particle_set%prt(2)%get_children ()), &
         1, "get children of 2")

    call assert_equal(u, particle_set%find_particle &
         (particle_set%prt(1)%get_pdg (), particle_set%prt(1)%p), &
         1, "find 1st particle")
    call assert_equal(u, particle_set%find_particle &
         (particle_set%prt(2)%get_pdg (), particle_set%prt(2)%p * &
          (one + tiny_07), rel_smallness=1.0E-6_default), &
         2, "find 2nd particle fuzzy")

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_8"
  end subroutine particles_8

@ %def particles_8
