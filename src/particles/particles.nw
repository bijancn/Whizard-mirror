%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: particle objects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Particles}

This chapter collects modules that implement particle objects, for use in
event records.

While within interactions, all correlations are
manifest, a particle array is derived by selecting a particular
quantum number set.  This involves tracing over all other particles,
as far as polarization is concerned.  Thus, a particle has definite
flavor, color, and a single-particle density matrix for polarization.
\begin{description}
\item[polarizations]
  The polarization object is based on a [[state_matrix_t]] object.  It
  describes the spin density matrix of a particle.
\item[particles]
  Particle objects and particle lists, as the base of event records.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polarization}
Particle polarization is determined by a particular quantum state
which has just helicity information.  For defining polarizations, we
adopt the phase convention for a spin-1/2 particle that
\begin{equation}
  \rho = \tfrac12(1 + \vec\alpha\cdot\vec\sigma)
\end{equation}
with the polarization axis $\vec\alpha$.  Using this, we define
\begin{enumerate}
\item Trivial polarization: $\vec\alpha=0$. [This is unpolarized, but
  distinct from the particular undefined polarization matrix which has
  the same meaning.]
\item Circular polarization: $\vec\alpha$ points in $\pm z$ direction.
\item Transversal polarization: $\vec\alpha$ points orthogonal to the
  $z$ direction, with a phase $\phi$ that is $0$ for the $x$ axis, and
  $\pi/2=90^\circ$ for the $y$ axis.  For antiparticles, the phase
  switches sign, corresponding to complex conjugation.
\item Axis polarization, where we explicitly give $\vec\alpha$.
\end{enumerate}
For higher spin, we retain this definition, but apply it to the two
components with maximum and minimum weight.  For massless particles,
this is sufficient.  For massive particles, we add the possibilities:
\begin{enumerate}\setcounter{enumi}{4}
\item Longitudinal polarization: Only the 0-component is set.  This is
  possible only for bosons.
\item Diagonal polarization: Explicitly specify all components in the
  helicity basis.
\end{enumerate}
Obviously, this does not exhaust the possible density matrices for
higher spin, but it should cover all practical applications.
<<[[polarizations.f90]]>>=
<<File header>>

module polarizations

<<Use kinds>>
  use constants, only: imago
  use io_units
  use format_defs, only: FMT_19
  use diagnostics
  use physics_defs, only: SCALAR
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices

<<Standard module head>>

<<Polarizations: public>>

<<Polarizations: types>>

<<Polarizations: interfaces>>

contains

<<Polarizations: procedures>>

end module polarizations
@ %def polarizations
@ 
\subsection{The polarization type}
This is not an extension, but rather a restriction of the quantum
state.  Flavor and color are ignored, there is just a one-particle
helicity density matrix.
<<Polarizations: public>>=
  public :: polarization_t
<<Polarizations: types>>=
  type :: polarization_t
     logical :: polarized = .false.
     integer :: spin_type = 0
     integer :: multiplicity = 0
     type(state_matrix_t) :: state
  end type polarization_t

@ %def polarization_t
@ 
\subsection{Basic initializer and finalizer}
We need the particle flavor for determining the allowed helicity
values.  The density matrix is not set, but prepared to be filled
later.  This is private.
<<Polarizations: procedures>>=
  subroutine polarization_init (pol, flv)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    pol%spin_type = flv%get_spin_type ()
    pol%multiplicity = flv%get_multiplicity ()
    call pol%state%init (store_values = .true.)
  end subroutine polarization_init
    
@ %def polarization_init
@ The finalizer has to be public.  The quantum state contains memory
allocated to pointers.
<<Polarizations: public>>=
  public :: polarization_final
<<Polarizations: procedures>>=
  subroutine polarization_final (pol)
    type(polarization_t), intent(inout) :: pol
    call pol%state%final ()
  end subroutine polarization_final

@ %def polarization_final
@ 
\subsection{I/O}
<<Polarizations: public>>=
  public :: polarization_write
<<Polarizations: procedures>>=
  subroutine polarization_write (pol, unit)
    type(polarization_t), intent(in) :: pol
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A,I1,A,I1,A)")  &
         "Polarization: [spin_type = ", pol%spin_type, &
         ", mult = ", pol%multiplicity, "]"
    call pol%state%write (unit=unit)
  end subroutine polarization_write

@ %def polarization_write
@ Defined assignment: deep copy
<<Polarizations: public>>=
  public :: assignment(=)
<<Polarizations: interfaces>>=
  interface assignment(=)
     module procedure polarization_assign
  end interface

<<Polarizations: procedures>>=
  subroutine polarization_assign (pol_out, pol_in)
    type(polarization_t), intent(out) :: pol_out
    type(polarization_t), intent(in) :: pol_in
    pol_out%polarized = pol_in%polarized
    pol_out%spin_type = pol_in%spin_type
    pol_out%multiplicity = pol_in%multiplicity
    pol_out%state = pol_in%state
  end subroutine polarization_assign

@ %def polarization_assign
@ Binary I/O.
<<Polarizations: public>>=
  public :: polarization_write_raw
  public :: polarization_read_raw
<<Polarizations: procedures>>=
  subroutine polarization_write_raw (pol, u)
    type(polarization_t), intent(in) :: pol
    integer, intent(in) :: u
    write (u) pol%polarized
    write (u) pol%spin_type
    write (u) pol%multiplicity
    call pol%state%write_raw (u)
  end subroutine polarization_write_raw

  subroutine polarization_read_raw (pol, u, iostat)
    type(polarization_t), intent(out) :: pol
    integer, intent(in) :: u
    integer, intent(out), optional :: iostat
    read (u, iostat=iostat) pol%polarized
    read (u, iostat=iostat) pol%spin_type
    read (u, iostat=iostat) pol%multiplicity
    call pol%state%read_raw (u, iostat=iostat)
  end subroutine polarization_read_raw

@ %def polarization_read_raw
@ 
\subsection{Accessing contents}
Return true if the particle is polarized.  This is the case if the
first (and only) entry in the quantum state has undefined helicity.
<<Polarizations: public>>=
  public :: polarization_is_polarized
<<Polarizations: procedures>>=
  elemental function polarization_is_polarized (pol) result (polarized)
    logical :: polarized
    type(polarization_t), intent(in) :: pol
    polarized = pol%polarized
  end function polarization_is_polarized

@ %def polarization_is_polarized
@ Return true if the polarization is diagonal, i.e., all entries in
the density matrix are diagonal.
<<Polarizations: public>>=
  public :: polarization_is_diagonal
<<Polarizations: interfaces>>=
  interface polarization_is_diagonal
     module procedure polarization_is_diagonal0
     module procedure polarization_is_diagonal1
  end interface

<<Polarizations: procedures>>=
  function polarization_is_diagonal0 (pol) result (diagonal)
    logical :: diagonal
    type(polarization_t), intent(in) :: pol
    type(state_iterator_t) :: it
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    diagonal = .true.
    allocate (qn (pol%state%get_depth ()))
    call it%init (pol%state)
    do while (it%is_valid ())
       qn = it%get_quantum_numbers ()
       diagonal = all (qn%are_diagonal ())
       if (.not. diagonal) exit
       call it%advance ()
    end do
  end function polarization_is_diagonal0

  function polarization_is_diagonal1 (pol) result (diagonal)
    type(polarization_t), dimension(:), intent(in) :: pol
    logical, dimension(size(pol)) :: diagonal
    integer :: i
    do i = 1, size (pol)
       diagonal(i) = polarization_is_diagonal0 (pol(i))
    end do
  end function polarization_is_diagonal1

@ %def polarization_is_diagonal
@ 
\subsection{Initialization from state matrix}
Here, the state matrix is already known (but not necessarily
normalized).  The result will be either unpolarized, or a normalized
spin density matrix.
<<Polarizations: public>>=
  public :: polarization_init_state_matrix
<<Polarizations: procedures>>=
  subroutine polarization_init_state_matrix (pol, state)
    type(polarization_t), intent(out) :: pol
    type(state_matrix_t), intent(in), target :: state
    type(state_iterator_t) :: it
    type(flavor_t) :: flv
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value, t
    call it%init (state)
    flv = it%get_flavor (1)
    hel = it%get_helicity (1)
    if (hel%is_defined ()) then
       call polarization_init (pol, flv)
       pol%polarized = .true.
       t = 0
       do while (it%is_valid ())
          hel = it%get_helicity (1)
          call qn(1)%init (hel)
          value = it%get_matrix_element ()
          call pol%state%add_state (qn, value=value)
          if (hel%is_diagonal ())  t = t + value
          call it%advance ()
       end do
       call pol%state%freeze ()
       if (t /= 0)  call pol%state%renormalize (1._default / t)
    else
       call polarization_init_unpolarized (pol, flv)
    end if
  end subroutine polarization_init_state_matrix

@ %def polarization_init_state_matrix
@
\subsection{Specific initializers}
Unpolarized particle, no helicity labels in the density matrix.  The
value is specified as $1/N$, where $N$ is the multiplicity.

Exception: for left-handed or right-handed particles (neutrinos),
polarization is always circular with fraction unity.
<<Polarizations: public>>=
  public :: polarization_init_unpolarized
<<Polarizations: procedures>>=
  subroutine polarization_init_unpolarized (pol, flv)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    if (flv%is_left_handed ()) then
       call polarization_init_circular (pol, flv, -1._default)
    else if (flv%is_right_handed ()) then
       call polarization_init_circular (pol, flv, 1._default)
    else
       call polarization_init (pol, flv)
       value = 1._default / flv%get_multiplicity ()
       call pol%state%add_state (qn)
       call pol%state%freeze ()
       call pol%state%set_matrix_element (value)
    end if
  end subroutine polarization_init_unpolarized
    
@ %def polarization_init_unpolarized
@ Unpolarized particle, but explicit density matrix with helicity
states allocated according to given flavor.  Note that fermions have
even spin type, bosons odd.  The spin density matrix entries are
scaled by [[fraction]].  This is used for initializing other
polarizations:
\begin{equation*}
  \rho(f) = 
  \frac{|f|}{N}\mathbf{1}.
\end{equation*}
<<Polarizations: public>>=
  public :: polarization_init_trivial
<<Polarizations: procedures>>=
  subroutine polarization_init_trivial (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in), optional :: fraction
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    integer :: h, hmax
    logical :: fermion
    complex(default) :: value
    call polarization_init (pol, flv)
    pol%polarized = .true.
    if (present (fraction)) then
       value = fraction / pol%multiplicity
    else
       value = 1._default / pol%multiplicity
    end if
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    select case (pol%multiplicity)
    case (1)
       if (flv%is_left_handed ()) then
          call hel%init (-hmax)
       else if (flv%is_right_handed ()) then
          call hel%init (hmax)
       else
          call hel%init (0)
       end if
       call qn(1)%init (hel)
       call pol%state%add_state (qn)
    case (2)
       do h = -hmax, hmax, 2*hmax
          call hel%init (h)
          call qn(1)%init (hel)
          call pol%state%add_state (qn)
       end do
    case default
       do h = -hmax, hmax
          if (fermion .and. h == 0)  cycle
          call hel%init (h)
          call qn(1)%init (hel)
          call pol%state%add_state (qn)
       end do
    end select
    call pol%state%freeze ()
    call pol%state%set_matrix_element (value)
  end subroutine polarization_init_trivial

@ %def polarization_init_trivial
@ The following three modes are useful mainly for spin-1/2 particle
and massless particles of any nonzero spin.  Only the highest-weight
components are filled.

Circular polarization: The density matrix of the two highest-weight
states is
\begin{equation*}
  \rho(f) = 
  \frac{1-|f|}{2}\mathbf{1} +
  |f| \times
  \begin{cases}
    \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}, & f > 0; \\[6pt]
    \begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}, & f < 0,
  \end{cases}
\end{equation*}
If the polarization fraction $|f|$ is unity, we need only one entry in the
density matrix.
<<Polarizations: public>>=
  public :: polarization_init_circular
<<Polarizations: procedures>>=
  subroutine polarization_init_circular (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: fraction
    type(helicity_t), dimension(2) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    integer :: hmax
    call polarization_init (pol, flv)
    pol%polarized = .true.
    hmax = pol%spin_type / 2
    call hel(1)%init ( hmax)
    call hel(2)%init (-hmax)
    if (abs (fraction) /= 1) then
       value = (1 + fraction) / 2
       call qn(1)%init (hel(1))
       call pol%state%add_state (qn, value=value)
       value = (1 - fraction) / 2
       call qn(1)%init (hel(2))
       call pol%state%add_state (qn, value=value)
    else
       value = abs (fraction)
       if (fraction > 0) then
          call qn(1)%init (hel(1))
       else
          call qn(1)%init (hel(2))
       end if
       call pol%state%add_state (qn, value=value)
    end if
    call pol%state%freeze ()
  end subroutine polarization_init_circular

@ %def polarization_init_circular
@ Transversal polarization is analogous to circular, but we get a
density matrix
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1-|f|}{2}\mathbf{1}
  + \frac{|f|}{2}  \begin{pmatrix} 1 & e^{-i\phi} \\ e^{i\phi} & 1
  \end{pmatrix}.
\end{equation*}
The phase is $\phi=0$ for the $x$-axis, $\phi=90^\circ$ for the $y$
axis as polarization vector.  For an antiparticle, the phase switches
sign, and for $f<0$, the off-diagonal elements switch sign.  
<<Polarizations: public>>=
  public :: polarization_init_transversal
<<Polarizations: procedures>>=
  subroutine polarization_init_transversal (pol, flv, phi, fraction)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: phi, fraction
    call polarization_init_axis &
         (pol, flv, fraction * [ cos (phi), sin (phi), 0._default])
  end subroutine polarization_init_transversal

@ %def polarization_init_transversal
@ For axis polarization, we again set only the entries with maximum weight.
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1}{2} \begin{pmatrix} 
                 1 + \alpha_3 & \alpha_1 - i\alpha_2 \\ 
                 \alpha_1 + i\alpha_2 & 1 - \alpha_3 
              \end{pmatrix}.
\end{equation*}
For an antiparticle, $\alpha_2$ switches sign (complex conjugate).
<<Polarizations: public>>=
  public :: polarization_init_axis
<<Polarizations: procedures>>=
  subroutine polarization_init_axis (pol, flv, alpha)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(3), intent(in) :: alpha
    type(quantum_numbers_t), dimension(1) :: qn
    type(helicity_t), dimension(2,2) :: hel
    complex(default), dimension(2,2) :: value
    integer :: hmax
    call polarization_init (pol, flv)
    pol%polarized = .true.
    hmax = pol%spin_type / 2
    call hel(1,1)%init ( hmax, hmax)
    call hel(1,2)%init ( hmax,-hmax)
    call hel(2,1)%init (-hmax, hmax)
    call hel(2,2)%init (-hmax,-hmax)
    value(1,1) = (1 + alpha(3)) / 2
    value(2,2) = (1 - alpha(3)) / 2
    if (flv%is_antiparticle ()) then
       value(1,2) = (alpha(1) + imago * alpha(2)) / 2
    else
       value(1,2) = (alpha(1) - imago * alpha(2)) / 2
    end if
    value(2,1) = conjg (value(1,2))
    if (value(1,1) /= 0) then
       call qn(1)%init (hel(1,1))
       call pol%state%add_state (qn, value=value(1,1))
    end if
    if (value(2,2) /= 0) then
       call qn(1)%init (hel(2,2))
       call pol%state%add_state (qn, value=value(2,2))
    end if
    if (value(1,2) /= 0) then
       call qn(1)%init (hel(1,2))
       call pol%state%add_state (qn, value=value(1,2))
       call qn(1)%init (hel(2,1))
       call pol%state%add_state (qn, value=value(2,1))
    end if
    call pol%state%freeze ()
  end subroutine polarization_init_axis

@ %def polarization_init_axis
@ This version specifies the polarization axis in terms of $r$
(polarization degree) and $\theta,\phi$ (polar and azimuthal angles).

If one of the angles is a nonzero multiple of $\pi$, roundoff errors
typically will result in tiny contributions to unwanted components.
Therefore, include a catch for small numbers.
<<Polarizations: public>>=
  public :: polarization_init_angles
<<Polarizations: procedures>>=
  subroutine polarization_init_angles (pol, flv, r, theta, phi)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default), parameter :: eps = 10 * epsilon (1._default)
    alpha(1) = r * sin (theta) * cos (phi)
    alpha(2) = r * sin (theta) * sin (phi)
    alpha(3) = r * cos (theta)
    where (abs (alpha) < eps)  alpha = 0
    call polarization_init_axis (pol, flv, alpha)
  end subroutine polarization_init_angles

@ %def polarization_init_angles
@ Longitudinal polarization is defined only for massive bosons.  Only
the zero component is filled.  Otherwise, unpolarized.
<<Polarizations: public>>=
  public :: polarization_init_longitudinal
<<Polarizations: procedures>>=
  subroutine polarization_init_longitudinal (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: fraction
    integer :: spin_type, multiplicity
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    integer :: n_values
    value = abs (fraction)
    spin_type = flv%get_spin_type ()
    multiplicity = flv%get_multiplicity ()
    if (mod (spin_type, 2) == 1 .and. multiplicity > 2) then
       if (fraction /= 1) then
          call polarization_init_trivial (pol, flv, 1 - fraction)
          n_values = pol%state%get_n_matrix_elements ()
          call pol%state%add_to_matrix_element (n_values/2 + 1, value)
       else
          call polarization_init (pol, flv)
          pol%polarized = .true.
          call hel%init (0)
          call qn(1)%init (hel)
          call pol%state%add_state (qn)
          call pol%state%freeze ()
          call pol%state%set_matrix_element (value)
       end if
    else
       call polarization_init_unpolarized (pol, flv)
    end if
  end subroutine polarization_init_longitudinal

@ %def polarization_init_longitudinal
@ This is diagonal polarization: we specify all components explicitly.
We use only the positive components.  The sum is normalized to unity.
We assume that the length of [[alpha]] is equal to the particle
multiplicity.
<<Polarizations: public>>=
  public :: polarization_init_diagonal
<<Polarizations: procedures>>=
  subroutine polarization_init_diagonal (pol, flv, alpha)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(:), intent(in) :: alpha
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    logical, dimension(size(alpha)) :: mask
    real(default) :: norm
    complex(default), dimension(:), allocatable :: value
    logical :: fermion
    integer :: h, hmax, i
    mask = alpha > 0
    norm = sum (alpha, mask);  if (norm == 0)  norm = 1
    allocate (value (count (mask)))
    value = pack (alpha / norm, mask)
    call polarization_init (pol, flv)
    pol%polarized = .true.
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    i = 0
    select case (pol%multiplicity)
    case (1)
       if (flv%is_left_handed ()) then
          call hel%init (-hmax)
       else if (flv%is_right_handed ()) then
          call hel%init ( hmax)
       else
          call hel%init (0)
       end if
       call qn(1)%init (hel)
       call pol%state%add_state (qn)
    case (2)
       do h = -hmax, hmax, 2*hmax
          i = i + 1
          if (mask(i)) then
             call hel%init (h)
             call qn(1)%init (hel)
             call pol%state%add_state (qn)
          end if
       end do
    case default
       do h = -hmax, hmax
          if (fermion .and. h == 0)  cycle
          i = i + 1
          if (mask(i)) then
             call hel%init (h)
             call qn(1)%init (hel)
             call pol%state%add_state (qn)
          end if
       end do
    end select
    call pol%state%freeze ()
    call pol%state%set_matrix_element (value)
  end subroutine polarization_init_diagonal

@ %def polarization_init_diagonal
@ Generic polarization: we generate all possible density matrix
entries, but the values are left zero.
<<Polarizations: public>>=
  public :: polarization_init_generic
<<Polarizations: procedures>>=
  subroutine polarization_init_generic (pol, flv)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    logical :: fermion
    integer :: hmax, h1, h2
    call polarization_init (pol, flv)
    pol%polarized = .true.
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    select case (pol%multiplicity)
    case (1)
       if (flv%is_left_handed ()) then
          call hel%init (-hmax)
       else if (flv%is_right_handed ()) then
          call hel%init ( hmax)
       else
          call hel%init (0)
       end if
       call qn(1)%init (hel)
       call pol%state%add_state (qn)
    case (2)
       do h1 = -hmax, hmax, 2*hmax
          do h2 = -hmax, hmax, 2*hmax
             call hel%init (h1, h2)
             call qn(1)%init (hel)
             call pol%state%add_state (qn)
          end do
       end do
    case default
       do h1 = -hmax, hmax
          if (fermion .and. h1 == 0)  cycle
          do h2 = -hmax, hmax
             if (fermion .and. h2 == 0)  cycle
             call hel%init (h1, h2)
             call qn(1)%init (hel)
             call pol%state%add_state (qn)
          end do
       end do
    end select
    call pol%state%freeze ()
  end subroutine polarization_init_generic

@ %def polarization_init_generic
@ 
\subsection{Operations}
Combine polarization states by computing the outer product of the
state matrices.
<<Polarizations: public>>=
  public :: combine_polarization_states
<<Polarizations: procedures>>=
  subroutine combine_polarization_states (pol, state)
    type(polarization_t), dimension(:), intent(in), target :: pol
    type(state_matrix_t), intent(out) :: state
    call outer_multiply (pol%state, state)
  end subroutine combine_polarization_states

@ %def combine_polarization_states
@ 
Transform a polarization density matrix into a polarization vector.
This is possible without information loss only for spin-1/2 and for
massless particles.  To get a unique answer in all cases, we consider
only the components with highest weight.  Obviously, this loses the
longitudinal component of a massive vector, for instance.

This is the inverse operation of [[polarization_init_axis]] above,
where the polarization fraction is set to unity.
<<Polarizations: public>>=
  public :: polarization_get_axis
<<Polarizations: procedures>>=
  function polarization_get_axis (pol) result (alpha)
    real(default), dimension(3) :: alpha
    type(polarization_t), intent(in), target :: pol
    type(state_iterator_t) :: it
    complex(default), dimension(2,2) :: value
    type(helicity_t), dimension(2,2) :: hel
    type(helicity_t), dimension(1) :: hel1
    integer :: hmax, i, j
    if (pol%polarized) then
       hmax = pol%spin_type / 2
       call hel(1,1)%init ( hmax, hmax)
       call hel(1,2)%init ( hmax,-hmax)
       call hel(2,1)%init (-hmax, hmax)
       call hel(2,2)%init (-hmax,-hmax)
       value = 0
       call it%init (pol%state)
       do while (it%is_valid ())
          hel1 = it%get_helicity ()
          SCAN_HEL: do i = 1, 2
             do j = 1, 2
                if (hel1(1) == hel(i,j)) then
                   value(i,j) = it%get_matrix_element ()
                   exit SCAN_HEL
                end if
             end do
          end do SCAN_HEL
          call it%advance ()
       end do
       alpha(1) = real(value(1,2) + value(2,1))
       alpha(2) = - aimag(value(1,2) - value(2,1))
       alpha(3) = real(value(1,1) - value(2,2))
    else
       alpha = 0
    end if
  end function polarization_get_axis

@ %def polarization_get_axis
@ This function returns polarization degree and polar and azimuthal
angles ($\theta,\phi$) of the polarization axis.
<<Polarizations: public>>=
  public :: polarization_to_angles
<<Polarizations: procedures>>=
  subroutine polarization_to_angles (pol, r, theta, phi)
    type(polarization_t), intent(in) :: pol
    real(default), intent(out) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default) :: r12
    if (pol%polarized) then
       alpha = polarization_get_axis (pol)
       r = sqrt (sum (alpha**2))
       if (any (alpha /= 0)) then
          r12 = sqrt (alpha(1)**2 + alpha(2)**2)
          theta = atan2 (r12, alpha(3))
          if (any (alpha(1:2) /= 0)) then
             phi = atan2 (alpha(2), alpha(1))
          else
             phi = 0
          end if
       else
          theta = 0
       end if
    else
       r = 0
       theta = 0
       phi = 0
    end if
  end subroutine polarization_to_angles

@ %def polarization_to_angles
@
\subsection{Sparse Matrix}
We introduce a simpler implementation of a sparse matrix that should represent
polarization.  It consists of an integer array that represents the index
values, and a complex array that represents the nonvanishing entries.  The
number of nonvanishing entries must be known for initialization, but the
entries are filled one at a time.

This should eventually replace the more baroque polarization definition above,
but in the first stage we introduce it just as an intermediage storage
container.

Here is a base type without the special properties of a spin-density matrix.
<<Polarizations: public>>=
  public :: smatrix_t
<<Polarizations: types>>=
  type :: smatrix_t
     private
     integer :: dim = 0
     integer :: n_entry = 0
     integer, dimension(:,:), allocatable :: index
     complex(default), dimension(:), allocatable :: value
   contains
   <<Polarizations: smatrix: TBP>>
  end type smatrix_t
  
@ %def smatrix_t
@ Output.
<<Polarizations: smatrix: TBP>>=
  procedure :: write => smatrix_write
<<Polarizations: procedures>>=
  subroutine smatrix_write (object, unit, indent)
    class(smatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (allocated (object%value)) then
       if (size (object%value) > 0) then
          do i = 1, object%n_entry
             write (u, "(1x,A,'@(')", advance="no")  repeat ("  ", ind)
             write (u, "(SP,9999(I2.1,':',1x))", advance="no") &
                  object%index(:,i)
             write (u, "('('," // FMT_19 // ",','," // FMT_19 // &
                  ",'))')")  object%value(i)
          end do
       else
          write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
          write (u, "(A)")  "[empty matrix]"
       end if
    else
       write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
       write (u, "(A)")  "[undefined matrix]"
    end if
  end subroutine smatrix_write
  
@ %def smatrix_write
@ Initialization: allocate arrays to the correct size.  We specify both the
dimension of the matrix (if different from two, this is rather a generic
tensor) and the number of nonvanishing entries.
<<Polarizations: smatrix: TBP>>=
  procedure :: init => smatrix_init
<<Polarizations: procedures>>=
  subroutine smatrix_init (smatrix, dim, n_entry)
    class(smatrix_t), intent(out) :: smatrix
    integer, intent(in) :: dim
    integer, intent(in) :: n_entry
    smatrix%dim = dim
    smatrix%n_entry = n_entry
    allocate (smatrix%index (dim, n_entry))
    allocate (smatrix%value (n_entry))
  end subroutine smatrix_init
  
@ %def smatrix_init
@ Fill: one entry at a time.
<<Polarizations: smatrix: TBP>>=
  procedure :: set_entry => smatrix_set_entry
<<Polarizations: procedures>>=
  subroutine smatrix_set_entry (smatrix, i, index, value)
    class(smatrix_t), intent(inout) :: smatrix
    integer, intent(in) :: i
    integer, dimension(:), intent(in) :: index
    complex(default), intent(in) :: value
    smatrix%index(:,i) = index
    smatrix%value(i) = value
  end subroutine smatrix_set_entry
  
@ %def smatrix_set_entry
@
\subsection{Polarization Matrix}
As an extension of the more generic [[smatrix]] type, we implement a proper
spin-density matrix.  After the matrix has been filled, we can fix spin type
and multiplicity for a particle, check the matrix for consistency, and
normalize it if necessary.
<<Polarizations: public>>=
  public :: pmatrix_t
<<Polarizations: types>>=
  type, extends (smatrix_t) :: pmatrix_t
     private
     integer :: spin_type = 0
     integer :: multiplicity = 0
     logical :: massive = .true.
     integer :: chirality = 0
     real(default) :: degree = 1
     logical :: pure = .false.
   contains
   <<Polarizations: pmatrix: TBP>>
  end type pmatrix_t
  
@ %def pmatrix_t
@ Output, including extra data.  (The [[indent]] argument is ignored.)
<<Polarizations: pmatrix: TBP>>=
  procedure :: write => pmatrix_write
<<Polarizations: procedures>>=
  subroutine pmatrix_write (object, unit, indent)
    class(pmatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Polarization: spin density matrix"
    write (u, "(3x,A,I0)")  "spin type     = ", object%spin_type
    write (u, "(3x,A,I0)")  "multiplicity  = ", object%multiplicity
    write (u, "(3x,A,L1)")  "massive       = ", object%massive
    write (u, "(3x,A,I0)")  "chirality     = ", object%chirality
    write (u, "(3x,A,F10.7)")  "pol.degree    =", object%degree
    write (u, "(3x,A,L1)")  "pure state    = ", object%pure
    call object%smatrix_t%write (u, 1)
  end subroutine pmatrix_write
  
@ %def pmatrix_write
@ This assignment is trivial, but must be coded explicitly.
<<Polarizations: pmatrix: TBP>>=
  generic :: assignment(=) => pmatrix_assign_from_smatrix
  procedure, private :: pmatrix_assign_from_smatrix
<<Polarizations: procedures>>=
  subroutine pmatrix_assign_from_smatrix (pmatrix, smatrix)
    class(pmatrix_t), intent(out) :: pmatrix
    type(smatrix_t), intent(in) :: smatrix
    pmatrix%smatrix_t = smatrix
  end subroutine pmatrix_assign_from_smatrix
  
@ %def pmatrix_assign_from_smatrix
@ Declare spin, multiplicity, and polarization degree.  Check whether all
entries fit, and whether this is a valid matrix.

The required properties are:
\begin{enumerate}
\item all entries apply to the given spin and mass type
\item the diagonal is real
\item only the upper of corresponding off-diagonal elements is specified,
  i.e., the row index is less than the column index
\item the trace is nonnegative and equal to the polarization degree (the
  remainder, proportional to the unit matrix, is understood to be present)
\item the trace of the matrix square is positive and less or equal
  to the trace of the matrix itself, which is the polarization degree.  (If it
  is equal, we are dealing with a pure state).
\end{enumerate}
<<Polarizations: pmatrix: TBP>>=
  procedure :: normalize => pmatrix_normalize
<<Polarizations: procedures>>=
  subroutine pmatrix_normalize (pmatrix, flv, degree, tolerance)
    class(pmatrix_t), intent(inout) :: pmatrix
    type(flavor_t), intent(in) :: flv
    real(default), intent(in), optional :: degree
    real(default), intent(in), optional :: tolerance
    integer :: i, hmax
    logical :: fermion, ok
    real(default) :: trace, trace_sq
    real(default) :: tol
    tol = 0;  if (present (tolerance))  tol = tolerance
    pmatrix%spin_type = flv%get_spin_type ()
    pmatrix%massive = flv%get_mass () /= 0
    if (.not. pmatrix%massive) then
       if (flv%is_left_handed ()) then
          pmatrix%chirality = -1
       else if (flv%is_right_handed ()) then
          pmatrix%chirality = +1
       end if
    end if
    if (pmatrix%spin_type == SCALAR) then
       pmatrix%multiplicity = 1
    else if (pmatrix%massive) then
       pmatrix%multiplicity = pmatrix%spin_type
    else if (pmatrix%chirality == 0) then
       pmatrix%multiplicity = 2
    else
       pmatrix%multiplicity = 1
    end if
    if (present (degree)) then
       if (degree < 0 .or. degree > 1) &
            call msg_error ("polarization degree must be between 0 and 1")
       pmatrix%degree = degree
    end if
    if (size (pmatrix%index, 1) /= 2)  call error ("wrong array rank")
    fermion = mod (pmatrix%spin_type, 2) == 0
    hmax = pmatrix%spin_type / 2
    if (pmatrix%n_entry > 0) then
       if (fermion) then
          if (pmatrix%massive) then
             ok = all (pmatrix%index /= 0) &
                  .and. all (abs (pmatrix%index) <= hmax)
          else if (pmatrix%chirality == -1) then
             ok = all (pmatrix%index == -hmax)
          else if (pmatrix%chirality == +1) then
             ok = all (pmatrix%index == +hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       else
          if (pmatrix%massive) then
             ok = all (abs (pmatrix%index) <= hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       end if
       if (.not. ok)  call error ("illegal index value")
    else
       pmatrix%degree = 0
       pmatrix%pure = pmatrix%multiplicity == 1
       return
    end if
    trace = 0
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            if (abs (aimag (value)) > tol)  call error ("diagonal must be real")
            value = real (value, kind=default)
            trace = trace + value
            
         else if (any (pmatrix%index(1,:) == index(2) &
              .and.    pmatrix%index(2,:) == index(1))) then
            call error ("redundant off-diagonal entry")
         else if (index(2) < index (1)) then
            index = index([2,1])
            value = conjg (value)
         end if
       end associate
    end do
    if (abs (trace) <= tol)  call error ("trace must not vanish")
    trace = real (trace, kind=default)
    pmatrix%value = pmatrix%value / trace * pmatrix%degree
    trace_sq = (1 - pmatrix%degree ** 2) / pmatrix%multiplicity
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            trace_sq = trace_sq + abs (value) ** 2
         else
            trace_sq = trace_sq + 2 * abs (value) ** 2
         end if
       end associate
    end do
    if (pmatrix%multiplicity == 1) then
       pmatrix%pure = .true.
    else if (abs (trace_sq - 1) <= tol) then
       pmatrix%pure = .true.
    else if (trace_sq - 1 > tol .or. trace_sq < -tol) then
       print *, "Trace of matrix square = ", trace_sq
       call error ("not permissible as density matrix")
    end if
  contains
    subroutine error (msg)
      character(*), intent(in) :: msg
      call pmatrix%write ()
      call msg_fatal ("Spin density matrix: " // msg)
    end subroutine error
  end subroutine pmatrix_normalize
  
@ %def pmatrix_normalize
@
A polarized matrix is defined as one with a positive polarization degree, even
if the actual matrix is trivial.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_polarized => pmatrix_is_polarized
<<Polarizations: procedures>>=
  elemental function pmatrix_is_polarized (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = pmatrix%degree > 0
  end function pmatrix_is_polarized
  
@ %def pmatrix_is_polarized
@
Check if there are only diagonal entries.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_diagonal => pmatrix_is_diagonal
<<Polarizations: procedures>>=
  elemental function pmatrix_is_diagonal (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = all (pmatrix%index(1,:) == pmatrix%index(2,:))
  end function pmatrix_is_diagonal
  
@ %def pmatrix_is_diagonal
@
\subsection{Data Translation}
Create a [[polarization_t]] object from the contents of a normalized
[[pmatrix_t]] object.

Note for off diagonal entries: the convention for the arguments of
[[helicity_init]] is [[(h2,h1)]], so the helicity of the conjugate state is
inserted first.
<<Polarizations: public>>=
  public :: polarization_init_pmatrix
<<Polarizations: procedures>>=
  subroutine polarization_init_pmatrix (pol, pmatrix)
    type(polarization_t), intent(out) :: pol
    type(pmatrix_t), intent(in) :: pmatrix
    type(quantum_numbers_t), dimension(1) :: qn
    type(helicity_t) :: hel
    integer :: i, h, h1, h2, hmin, hmax, dh
    logical :: fermion
    complex(default) :: value
    pol%polarized = .true.
    pol%spin_type = pmatrix%spin_type
    pol%multiplicity = pmatrix%multiplicity
    call pol%state%init (store_values = .true.)
    fermion = mod (pol%spin_type, 2) == 0
    h = pol%spin_type / 2
    select case (pmatrix%chirality)
    case (-1)
       hmin = -h
       hmax = -h
    case (0)
       hmin = -h
       hmax = h
    case (1)
       hmin = h
       hmax = h
    end select
    if (pol%multiplicity == 1) then
       dh = 1
    else if (pol%multiplicity == 2) then
       dh = hmax - hmin
    else
       dh = 1
    end if
    if (pmatrix%degree < 1) then
       value = (1 - pmatrix%degree) / pol%multiplicity
       do h = hmin, hmax, dh
          if (h == 0 .and. fermion)  cycle
          call hel%init (h)
          call qn(1)%init (hel)
          call pol%state%add_state (qn, value = value)
       end do
    end if
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         h1 = index(1)
         h2 = index(2)
         if (h1 == h2) then
            call hel%init (h1)
            call qn(1)%init (hel)
            call pol%state%add_state (qn, value = value, &
                 sum_values = .true.)
         else
            call hel%init (h2, h1)
            call qn(1)%init (hel)
            call pol%state%add_state (qn, value = value)
            call hel%init (h1, h2)
            call qn(1)%init (hel)
            call pol%state%add_state (qn, value = conjg (value))
         end if
       end associate
    end do
    call pol%state%freeze ()
  end subroutine polarization_init_pmatrix

@ %def polarization_init_generic
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[polarizations_ut.f90]]>>=
<<File header>>

module polarizations_ut
  use unit_tests
  use polarizations_uti
  
<<Standard module head>>

<<Polarizations: public test>>

contains
  
<<Polarizations: test driver>>

end module polarizations_ut
@ %def polarizations_ut
@
<<[[polarizations_uti.f90]]>>=
<<File header>>

module polarizations_uti

<<Use kinds>>
  use format_defs, only: FMT_12
  use flavors
  use model_data

  use polarizations

<<Standard module head>>

<<Polarizations: test declarations>>

contains

<<Polarizations: tests>>

end module polarizations_uti
@ %def polarizations_ut
@ API: driver for the unit tests below.
<<Polarizations: public test>>=
  public :: polarizations_test
<<Polarizations: test driver>>=
  subroutine polarizations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Polarizations: execute tests>>
  end subroutine polarizations_test

@  %def polarizations_test
@
\subsubsection{Polarization type}
Checking the setup for polarization. 
<<Polarizations: execute tests>>=
  call test (polarization_1, "polarization_1", &
       "check polarization setup", &
       u, results)
<<Polarizations: test declarations>>= 
  public :: polarization_1
<<Polarizations: tests>>= 
  subroutine polarization_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(polarization_t) :: pol
    type(flavor_t) :: flv
    real(default), dimension(3) :: alpha
    real(default) :: r, theta, phi

    write (u, "(A)")  "* Test output: polarization_1"
    write (u, "(A)")  "*   Purpose: test polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)")      
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flv%init (1, model)
    call polarization_init_unpolarized (pol, flv)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Unpolarized fermion"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv, 0._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call polarization_init_transversal (pol, flv, 0._default, 1._default)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call polarization_init_transversal (pol, flv, 0.9_default, 0.8_default)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)") "* All polarization directions of a fermion"
    write (u, "(A)")
    
    call polarization_init_generic (pol, flv)
    call polarization_write (pol, u)
    call polarization_final (pol)
    call flv%init (21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv, 0.3_default)
    call polarization_write (pol, u)
    call polarization_final (pol)   
    call flv%init (23, model)
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=-0.7"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv,  -0.7_default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call polarization_init_circular (pol, flv, 1._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call polarization_init_longitudinal (pol, flv, 0.4_default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call polarization_init_longitudinal (pol, flv, 1._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Diagonally polarized massive vector"
    write (u, "(A)")
    
    call polarization_init_diagonal &
         (pol, flv, [0._default, 1._default, 2._default])
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* All polarization directions of a massive vector"
    write (u, "(A)") 

    call polarization_init_generic (pol, flv)
    call polarization_write (pol, u)
    call polarization_final (pol)
    call flv%init (21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    alpha = [0.2_default, 0.4_default, 0.6_default]
    call polarization_init_axis (pol, flv, alpha)
    call polarization_write (pol, u)
    
    write (u, "(A)")  "   Recovered axis:"
    alpha = polarization_get_axis (pol)
    write (u, "(A)")  "   Angle polarization (0.5, 0.6, -1)"
    r = 0.5_default
    theta = 0.6_default
    phi = -1._default
    call polarization_init_angles (pol, flv, r, theta, phi)
    call polarization_write (pol, u)
    write (u, "(A)")  "   Recovered parameters (r, theta, phi):"
    call polarization_to_angles (pol, r, theta, phi)
    write (u, "(A,3(1x," // FMT_12 // "))")  "     ", r, theta, phi
    call polarization_final (pol)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_1"    
      
  end subroutine polarization_1

@ %def polarization_1
@
\subsubsection{Sparse-Matrix type}
Use a sparse density matrix universally as the input for setting up
polarization.
<<Polarizations: execute tests>>=
  call test (polarization_2, "polarization_2", &
       "matrix polarization setup", &
       u, results)
<<Polarizations: test declarations>>= 
  public :: polarization_2
<<Polarizations: tests>>= 
  subroutine polarization_2 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(polarization_t) :: pol
    real(default), dimension(3) :: alpha
    type(pmatrix_t) :: pmatrix
    real(default), parameter :: tolerance = 1e-8_default

    write (u, "(A)")  "* Test output: polarization_2"
    write (u, "(A)")  "*   Purpose: matrix polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flv%init (1, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 0._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], exp ((0._default, -0.9_default)))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=1"
    write (u, "(A)")
    
    call flv%init (11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=0.8"
    write (u, "(A)")
    
    call flv%init (11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massless fermion"
    write (u, "(A)")
    
    call flv%init (12, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Right-handed massless fermion, frac=0.5"
    write (u, "(A)")
    
    call flv%init (-12, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.5_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call flv%init (21, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.3_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)   
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=0.7"
    write (u, "(A)") 
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.7_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.4_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call flv%init (23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    call flv%init (11, model)
    alpha = [0.2_default, 0.4_default, 0.6_default]
    alpha = alpha / sqrt (sum (alpha**2))
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], cmplx (1 - alpha(3), kind=default))
    call pmatrix%set_entry (2, [1,-1], &
         cmplx (alpha(1), -alpha(2), kind=default))
    call pmatrix%set_entry (3, [1,1], cmplx (1 + alpha(3), kind=default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_2"    
      
  end subroutine polarization_2

@ %def polarization_2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Particles}
This module defines the [[particle_t]] object type, and the methods
and operations that deal with it.
<<[[particles.f90]]>>=
<<File header>>

module particles

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use format_utils, only: write_compressed_integer_array, write_separator
  use format_utils, only: pac_fmt
  use format_defs, only: FMT_16, FMT_19
  use unit_tests, only: nearly_equal
  use diagnostics
  use lorentz
  use model_data
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use subevents
  use polarizations
  use pdg_arrays, only: is_quark, is_gluon

<<Standard module head>>

<<Particles: public>>

<<Particles: parameters>>
       
<<Particles: types>>

<<Particles: interfaces>>

contains

<<Particles: procedures>>

end module particles
@ %def particles
@
\subsection{The particle type}
\subsubsection{Particle status codes}
The overall status codes (incoming/outgoing etc.) are inherited from
the module [[subevents]].

Polarization status:
<<Particles: parameters>>=
  integer, parameter, public :: PRT_UNPOLARIZED = 0
  integer, parameter, public :: PRT_DEFINITE_HELICITY = 1
  integer, parameter, public :: PRT_GENERIC_POLARIZATION = 2

@ %def PRT_UNPOLARIZED PRT_DEFINITE_HELICITY PRT_GENERIC_POLARIZATION
@
\subsubsection{Definition}
The quantum numbers are flavor (from which invariant particle
properties can be derived), color, and polarization.  The particle may
be unpolarized.  In this case, [[hel]] and [[pol]] are unspecified.
If it has a definite helicity, the [[hel]] component is defined.  If
it has a generic polarization, the [[pol]] component is defined.  For
each particle we store the four-momentum and the invariant mass
squared, i.e., the squared norm of the four-momentum.  There is also
an optional list of parent and child particles, for bookkeeping in
physical events. The vertex is an optional component that consists of
a Lorentz 4-vector, denoting the position and time of the vertex
(displaced vertex/time).
<<Particles: public>>=
  public :: particle_t
<<Particles: types>>=
  type :: particle_t
     !private
     integer :: status = PRT_UNDEFINED
     integer :: polarization = PRT_UNPOLARIZED
     type(flavor_t) :: flv
     type(color_t) :: col
     type(helicity_t) :: hel
     type(polarization_t) :: pol
     type(vector4_t) :: p = vector4_null
     real(default) :: p2 = 0
     type(vector4_t), allocatable :: vertex
     integer, dimension(:), allocatable :: parent
     integer, dimension(:), allocatable :: child
   contains
  <<Particles: particle: TBP>>  
  end type particle_t

@ %def particle_t
@ Copy a particle.  (Deep copy)  This excludes the parent-child
relations.
<<Particles: particle: TBP>>=
  generic :: init => init_particle
  procedure :: init_particle => particle_init_particle
<<Particles: procedures>>=
  subroutine particle_init_particle (prt_out, prt_in)
    class(particle_t), intent(out) :: prt_out
    type(particle_t), intent(in) :: prt_in
    prt_out%status = prt_in%status
    prt_out%polarization = prt_in%polarization
    prt_out%flv = prt_in%flv
    prt_out%col = prt_in%col
    prt_out%hel = prt_in%hel
    prt_out%pol = prt_in%pol
    prt_out%p = prt_in%p
    prt_out%p2 = prt_in%p2
    if (allocated (prt_in%vertex))  &
       allocate (prt_out%vertex, source=prt_in%vertex)
  end subroutine particle_init_particle

@ %def particle_init_particle
@ Initialize a particle using external information.
<<Particles: particle: TBP>>=
  generic :: init => init_external
  procedure :: init_external => particle_init_external
<<Particles: procedures>>=
  subroutine particle_init_external &
         (particle, status, pdg, model, col, anti_col, mom)
    class(particle_t), intent(out) :: particle
    integer, intent(in) :: status, pdg, col, anti_col
    class(model_data_t), pointer, intent(in) :: model
    type(vector4_t) :: mom
    type(flavor_t) :: flavor
    type(color_t) :: color
    call flavor%init (pdg, model)
    call particle%set_flavor (flavor)
    call color%init_col_acl (col, anti_col)
    call particle%set_color (color)
    call particle%set_status (status)
    call particle%set_momentum (mom)
  end subroutine particle_init_external

@ %def particle_init_external
@ Initialize a particle using a single-particle state matrix which
determines flavor, color, and polarization.  The state matrix must
have unique flavor and color.  The factorization mode determines
whether the particle is unpolarized, has definite helicity, or generic
polarization.  This mode is translated into the polarization status.
<<Particles: particle: TBP>>=
  generic :: init => init_state
  procedure :: init_state => particle_init_state
<<Particles: procedures>>=
  subroutine particle_init_state (prt, state, status, mode)
    class(particle_t), intent(out) :: prt
    type(state_matrix_t), intent(in) :: state
    integer, intent(in) :: status, mode
    type(state_iterator_t) :: it
    prt%status = status
    call it%init (state)
    prt%flv = it%get_flavor (1)
    if (prt%flv%is_radiated ())  prt%status = PRT_BEAM_REMNANT
    prt%col = it%get_color (1)
    select case (mode)
    case (FM_SELECT_HELICITY)
       prt%hel = it%get_helicity (1)
       if (prt%hel%is_defined ()) then
          prt%polarization = PRT_DEFINITE_HELICITY
       end if
    case (FM_FACTOR_HELICITY)
       call polarization_init_state_matrix (prt%pol, state)
       prt%polarization = PRT_GENERIC_POLARIZATION
    end select
  end subroutine particle_init_state

@ %def particle_init_state
@ Finalizer.  The polarization component has pointers allocated.
<<Particles: particle: TBP>>=
  procedure :: final => particle_final
<<Particles: procedures>>=
  subroutine particle_final (prt)
    class(particle_t), intent(inout) :: prt
    call polarization_final (prt%pol)
    if (allocated (prt%vertex))  deallocate (prt%vertex)
  end subroutine particle_final

@ %def particle_final
@ 
\subsubsection{I/O}
<<Particles: particle: TBP>>=
  procedure :: write => particle_write
<<Particles: procedures>>=
  subroutine particle_write (prt, unit, testflag, compressed)
    class(particle_t), intent(in) :: prt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, compressed
    logical :: comp, pacified
    integer :: u
    real(default) :: pp2
    character(len=7) :: fmt
    character(len=20) :: buffer
    comp = .false.; if (present (compressed))  comp = compressed
    pacified = .false.;  if (present (testflag))  pacified = testflag
    call pac_fmt (fmt, FMT_19, FMT_16, testflag)
    u = given_output_unit (unit);  if (u < 0)  return
    pp2 = prt%p2
    if (pacified)  call pacify (pp2, tolerance = 1E-10_default)
    select case (prt%status)
    case (PRT_UNDEFINED);    write (u, "(1x, A)", advance="no")  "[-]"
    case (PRT_BEAM);         write (u, "(1x, A)", advance="no")  "[b]"
    case (PRT_INCOMING);     write (u, "(1x, A)", advance="no")  "[i]"
    case (PRT_OUTGOING);     write (u, "(1x, A)", advance="no")  "[o]"
    case (PRT_VIRTUAL);      write (u, "(1x, A)", advance="no")  "[v]"
    case (PRT_RESONANT);     write (u, "(1x, A)", advance="no")  "[r]"
    case (PRT_BEAM_REMNANT); write (u, "(1x, A)", advance="no")  "[x]"
    end select
    write (u, "(1x)", advance="no")
    if (comp) then
       write (u, "(A7,1X)", advance="no") char (prt%flv%get_name ())
       write (u, "(2(I4,1X))", advance="no") &
            prt%col%get_col (), prt%col%get_acl ()
       call write_compressed_integer_array (buffer, prt%parent)
       write (u, "(A,1X)", advance="no") buffer
       call write_compressed_integer_array (buffer, prt%child)
       write (u, "(A,1X)", advance="no") buffer
       call prt%p%write(u, testflag = testflag, compressed = comp)
       write (u, "(F12.3)") pp2
    else
       call prt%flv%write (unit)
       if (prt%col%is_nonzero ()) then
          call color_write (prt%col, unit)
       end if
       select case (prt%polarization)
       case (PRT_DEFINITE_HELICITY)
          call prt%hel%write (unit)
          write (u, *)
       case (PRT_GENERIC_POLARIZATION)
          write (u, *)
          call polarization_write (prt%pol, unit)
       case default
          write (u, *)
       end select
       call prt%p%write (unit, testflag = testflag)
       write (u, "(1x,A,1x," // fmt // ")")  "T = ", pp2
       if (allocated (prt%parent)) then
          if (size (prt%parent) /= 0) then
             write (u, "(1x,A,40(1x,I0))")  "Parents: ", prt%parent
          end if
       end if
       if (allocated (prt%child)) then
          if (size (prt%child) /= 0) then
             write (u, "(1x,A,40(1x,I0))")  "Children:", prt%child
          end if
       end if
       if (allocated (prt%vertex)) then
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx t = ", prt%vertex%p(0)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx x = ", prt%vertex%p(1)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx y = ", prt%vertex%p(2)
          write (u, "(1x,A,1x," // fmt // ")")  "Vtx z = ", prt%vertex%p(3)
       end if
    end if
  end subroutine particle_write

@ %def particle_write
@ Binary I/O:
<<Particles: particle: TBP>>=
  procedure :: write_raw => particle_write_raw
  procedure :: read_raw => particle_read_raw
<<Particles: procedures>>=
  subroutine particle_write_raw (prt, u)
    class(particle_t), intent(in) :: prt
    integer, intent(in) :: u
    write (u) prt%status, prt%polarization
    call prt%flv%write_raw (u)
    call prt%col%write_raw (u)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call prt%hel%write_raw (u)
    case (PRT_GENERIC_POLARIZATION)
       call polarization_write_raw (prt%pol, u)
    end select
    call vector4_write_raw (prt%p, u)
    write (u) prt%p2
    write (u) allocated (prt%parent)
    if (allocated (prt%parent)) then
       write (u) size (prt%parent)
       write (u) prt%parent
    end if
    write (u) allocated (prt%child)
    if (allocated (prt%child)) then
       write (u) size (prt%child)
       write (u) prt%child
    end if
    write (u) allocated (prt%vertex)
    if (allocated (prt%vertex)) then
       call vector4_write_raw (prt%vertex, u)
    end if    
  end subroutine particle_write_raw

  subroutine particle_read_raw (prt, u, iostat)
    class(particle_t), intent(out) :: prt
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    logical :: allocated_parent, allocated_child, allocated_vertex
    integer :: size_parent, size_child
    read (u, iostat=iostat) prt%status, prt%polarization
    call prt%flv%read_raw (u, iostat=iostat)
    call prt%col%read_raw (u, iostat=iostat)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call prt%hel%read_raw (u, iostat=iostat)
    case (PRT_GENERIC_POLARIZATION)
       call polarization_read_raw (prt%pol, u, iostat=iostat)
    end select
    call vector4_read_raw (prt%p, u, iostat=iostat)
    read (u, iostat=iostat) prt%p2
    read (u, iostat=iostat) allocated_parent
    if (allocated_parent) then
       read (u, iostat=iostat) size_parent
       allocate (prt%parent (size_parent))
       read (u, iostat=iostat) prt%parent
    end if
    read (u, iostat=iostat) allocated_child
    if (allocated_child) then
       read (u, iostat=iostat) size_child
       allocate (prt%child (size_child))
       read (u, iostat=iostat) prt%child
    end if
    read (u, iostat=iostat) allocated_vertex
    if (allocated_vertex) then
       allocate (prt%vertex)
       read (u, iostat=iostat) prt%vertex%p
    end if
  end subroutine particle_read_raw

@ %def particle_write_raw particle_read_raw
@ 
\subsubsection{Setting contents}
Reset the status code.  Where applicable, set $p^2$ assuming that the
particle is on-shell.
<<Particles: particle: TBP>>=
  procedure :: reset_status => particle_reset_status
<<Particles: procedures>>=
  elemental subroutine particle_reset_status (prt, status)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: status
    prt%status = status
    select case (status)
    case (PRT_BEAM, PRT_INCOMING, PRT_OUTGOING)
       prt%p2 = prt%flv%get_mass () ** 2
    end select
  end subroutine particle_reset_status

@ %def particle_reset_status
@ The color can be given explicitly.
<<Particles: particle: TBP>>=
  procedure :: set_color => particle_set_color
<<Particles: procedures>>=
  elemental subroutine particle_set_color (prt, col)
    class(particle_t), intent(inout) :: prt
    type(color_t), intent(in) :: col
    prt%col = col
  end subroutine particle_set_color

@ %def particle_set_color
@ The flavor can be given explicitly.
<<Particles: particle: TBP>>=
  procedure :: set_flavor => particle_set_flavor
<<Particles: procedures>>=
  subroutine particle_set_flavor (prt, flv)
    class(particle_t), intent(inout) :: prt
    type(flavor_t), intent(in) :: flv
    prt%flv = flv
  end subroutine particle_set_flavor

@ %def particle_set_flavor
@ As can the helicity.
<<Particles: particle: TBP>>=
  procedure :: set_helicity => particle_set_helicity
<<Particles: procedures>>=
  subroutine particle_set_helicity (prt, hel)
    class(particle_t), intent(inout) :: prt
    type(helicity_t), intent(in) :: hel
    prt%hel = hel
  end subroutine particle_set_helicity

@ %def particle_set_helicity
@ And the polarization.
<<Particles: particle: TBP>>=
  procedure :: set_pol => particle_set_pol
<<Particles: procedures>>=
  subroutine particle_set_pol (prt, pol)
    class(particle_t), intent(inout) :: prt
    type(polarization_t), intent(in) :: pol
    prt%pol = pol
  end subroutine particle_set_pol

@ %def particle_set_pol
@ Manually set the model for the particle flavor.  This is required, e.g., if
the particle has been read from file.
<<Particles: particle: TBP>>=
  procedure :: set_model => particle_set_model
<<Particles: procedures>>=
  subroutine particle_set_model (prt, model)
    class(particle_t), intent(inout) :: prt
    class(model_data_t), intent(in), target :: model
    call prt%flv%set_model (model)
  end subroutine particle_set_model
  
@ %def particle_set_model
@ The momentum is set independent of the quantum numbers.
<<Particles: particle: TBP>>=
  procedure :: set_momentum => particle_set_momentum
<<Particles: procedures>>=
  elemental subroutine particle_set_momentum (prt, p, p2, on_shell)
    class(particle_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: p
    real(default), intent(in), optional :: p2
    logical, intent(in), optional :: on_shell
    prt%p = p
    if (present (on_shell)) then
       if (on_shell) then
          if (prt%flv%is_associated ()) then
             prt%p2 = prt%flv%get_mass () ** 2
             return
          end if
       end if
    end if
    if (present (p2)) then
       prt%p2 = p2
    else
       prt%p2 = p ** 2
    end if
  end subroutine particle_set_momentum

@ %def particle_set_momentum
@ Set resonance information.  This should be done after momentum
assignment, because we need to know wheter the particle is spacelike
or timelike.  The resonance flag is defined only for virtual
particles. 
<<Particle: particle: TBP>>=
  procedure :: set_resonance_flag => particle_set_resonance_flag
<<Particles: procedures>>=
  elemental subroutine particle_set_resonance_flag (prt, resonant)
    class(particle_t), intent(inout) :: prt
    logical, intent(in) :: resonant
    select case (prt%status)
    case (PRT_VIRTUAL)
       if (resonant)  prt%status = PRT_RESONANT
    end select
  end subroutine particle_set_resonance_flag

@ %def particle_set_resonance_flag
@ Set children and parents information.
<<Particles: particle: TBP>>=
  procedure :: set_children => particle_set_children
  procedure :: set_parents => particle_set_parents
<<Particles: procedures>>=
  subroutine particle_set_children (prt, idx)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%child))  deallocate (prt%child)
    allocate (prt%child (count (idx /= 0)))
    prt%child = pack (idx, idx /= 0)
  end subroutine particle_set_children

  subroutine particle_set_parents (prt, idx)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%parent))  deallocate (prt%parent) 
    allocate (prt%parent (count (idx /= 0)))
    prt%parent = pack (idx, idx /= 0)
  end subroutine particle_set_parents

@ %def particle_set_children particle_set_parents
@ 
<<Particles: particle: TBP>>=
  procedure :: add_child => particle_add_child
<<Particles: procedures>>=
  subroutine particle_add_child (prt, new_child)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: new_child
    integer, dimension(:), allocatable :: idx
    integer :: n, i
    n = prt%get_n_children()
    if (n == 0) then
       call prt%set_children ([new_child])
    else
       do i = 1, n
          if (prt%child(i) == new_child) then
             return
          end if
       end do
       allocate (idx (1:n+1))
       idx(1:n) = prt%get_children ()
       idx(n+1) = new_child
       call prt%set_children (idx)
    end if
  end subroutine particle_add_child

@ %def particle_add_child
@
<<Particles: particle: TBP>>=
  procedure :: add_children => particle_add_children
<<Particles: procedures>>=
  subroutine particle_add_children (prt, new_child)
    class(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: new_child
    integer, dimension(:), allocatable :: idx
    integer :: n
    n = prt%get_n_children()
    if (n == 0) then
       call prt%set_children (new_child)
    else
       allocate (idx (1:n+size(new_child)))
       idx(1:n) = prt%get_children ()
       idx(n+1:n+size(new_child)) = new_child
       call prt%set_children (idx)
    end if
  end subroutine particle_add_children

@ %def particle_add_children
@
<<Particles: particle: TBP>>=
  procedure :: set_status => particle_set_status
<<Particles: procedures>>=
  elemental subroutine particle_set_status (prt, status)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: status
    prt%status = status
  end subroutine particle_set_status

@ %def particle_set_status 
@
<<Particles: particle: TBP>>=
  procedure :: set_polarization => particle_set_polarization
<<Particles: procedures>>=
  subroutine particle_set_polarization (prt, polarization)
    class(particle_t), intent(inout) :: prt
    integer, intent(in) :: polarization
    prt%polarization = polarization
  end subroutine particle_set_polarization

@ %def particle_set_polarization 
@
<<Particles: particle: TBP>>=
  generic :: set_vertex => set_vertex_from_vector3, set_vertex_from_xyz, &
       set_vertex_from_vector4, set_vertex_from_xyzt
  procedure :: set_vertex_from_vector4 => particle_set_vertex_from_vector4
  procedure :: set_vertex_from_vector3 => particle_set_vertex_from_vector3
  procedure :: set_vertex_from_xyzt => particle_set_vertex_from_xyzt
  procedure :: set_vertex_from_xyz => particle_set_vertex_from_xyz
<<Particles: procedures>>=
  subroutine particle_set_vertex_from_vector4 (prt, vertex)
    class(particle_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_vector4

  subroutine particle_set_vertex_from_vector3 (prt, vertex)
    class(particle_t), intent(inout) :: prt
    type(vector3_t), intent(in) :: vertex
    type(vector4_t) :: vtx
    vtx = vector4_moving (0._default, vertex)
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    allocate (prt%vertex, source=vtx)
  end subroutine particle_set_vertex_from_vector3
  
  subroutine particle_set_vertex_from_xyzt (prt, vx, vy, vz, t)
    class(particle_t), intent(inout) :: prt
    real(default), intent(in) :: vx, vy, vz, t
    type(vector4_t) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    vertex = vector4_moving (t, vector3_moving ([vx, vy, vz]))
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_xyzt
  
  subroutine particle_set_vertex_from_xyz (prt, vx, vy, vz)
    class(particle_t), intent(inout) :: prt
    real(default), intent(in) :: vx, vy, vz
    type(vector4_t) :: vertex
    if (allocated (prt%vertex)) deallocate (prt%vertex)
    vertex = vector4_moving (0._default, vector3_moving ([vx, vy, vz]))
    allocate (prt%vertex, source=vertex)
  end subroutine particle_set_vertex_from_xyz

@ %def particle_set_vertex_from_vector3
@ %def particle_set_vertex_from_vector4
@ %def particle_set_vertex_from_xyz
@ %def particle_set_vertex_from_xyzt
@
\subsubsection{Accessing contents}
The status code.
<<Particles: particle: TBP>>=
  procedure :: get_status => particle_get_status
<<Particles: procedures>>=
  elemental function particle_get_status (prt) result (status)
    integer :: status
    class(particle_t), intent(in) :: prt
    status = prt%status
  end function particle_get_status

@ %def particle_get_status
@ Return true if the status is either [[INCOMING]],
[[OUTGOING]] or [[RESONANT]]. [[BEAM]] is kept, if 
[[keep_beams]] is set true.
<<Particles: particle: TBP>>=
  procedure :: is_real => particle_is_real
<<Particles: procedures>>=
  elemental function particle_is_real (prt, keep_beams) result (flag)
    logical :: flag, kb
    class(particle_t), intent(in) :: prt
    logical, intent(in), optional :: keep_beams
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    select case (prt%status)
    case (PRT_INCOMING, PRT_OUTGOING, PRT_RESONANT)
       flag = .true.
    case (PRT_BEAM)
       flag = kb 
    case default
       flag = .false.
    end select
  end function particle_is_real

@ %def particle_is_real
@
<<Particles: particle: TBP>>=
  procedure :: is_colored => particle_is_colored
<<Particles: procedures>>=
  elemental function particle_is_colored (particle) result (flag)
    logical :: flag
    class(particle_t), intent(in) :: particle
    flag = particle%col%is_nonzero ()
  end function particle_is_colored

@ %def particle_is_colored
@ $[90,100]$ hopefully catches all of them and not too many.
<<Particles: particle: TBP>>=
  procedure :: is_hadronic_beam_remnant => particle_is_hadronic_beam_remnant
<<Particles: procedures>>=
  elemental function particle_is_hadronic_beam_remnant (particle) result (flag)
    class(particle_t), intent(in) :: particle
    logical :: flag
    integer :: pdg
    pdg = particle%flv%get_pdg ()
    flag = particle%status == PRT_BEAM_REMNANT .and. &
         abs(pdg) >= 90 .and. abs(pdg) <= 100
  end function particle_is_hadronic_beam_remnant

@ %def particle_is_hadronic_beam_remnant
@
<<Particles: particle: TBP>>=
  procedure :: is_beam_remnant => particle_is_beam_remnant
<<Particles: procedures>>=
  elemental function particle_is_beam_remnant (particle) result (flag)
    class(particle_t), intent(in) :: particle
    logical :: flag
    flag = particle%status == PRT_BEAM_REMNANT
  end function particle_is_beam_remnant

@ %def particle_is_beam_remnant
@ Polarization status.
<<Particles: particle: TBP>>=
  procedure :: get_polarization_status => particle_get_polarization_status
<<Particles: procedures>>=
  elemental function particle_get_polarization_status (prt) result (status)
    integer :: status
    class(particle_t), intent(in) :: prt
    status = prt%polarization
  end function particle_get_polarization_status

@ %def particle_get_polarization_status
@ Return the PDG code from the flavor component directly.
<<Particles: particle: TBP>>=
  procedure :: get_pdg => particle_get_pdg
<<Particles: procedures>>=
  elemental function particle_get_pdg (prt) result (pdg)
    integer :: pdg
    class(particle_t), intent(in) :: prt
    pdg = prt%flv%get_pdg ()
  end function particle_get_pdg

@ %def particle_get_pdg
@ Return the color and anticolor quantum numbers.
<<Particles: particle: TBP>>=
  procedure :: get_color => particle_get_color
<<Particles: procedures>>=
  pure function particle_get_color (prt) result (col)
    integer, dimension(2) :: col
    class(particle_t), intent(in) :: prt
    col(1) = prt%col%get_col ()
    col(2) = prt%col%get_acl ()
  end function particle_get_color
  
@ %def particle_get_color  
@ Return the polarization density matrix (as a shallow copy).
<<Particles: particle: TBP>>=
  procedure :: get_polarization => particle_get_polarization
<<Particles: procedures>>=
  function particle_get_polarization (prt) result (pol)
    class(particle_t), intent(in) :: prt
    class(polarization_t), allocatable :: pol
    pol = prt%pol
  end function particle_get_polarization

@ %def particle_get_polarization
@ Return the flavor, color and helicity.
<<Particles: particle: TBP>>=
  procedure :: get_flv => particle_get_flv
  procedure :: get_col => particle_get_col 
  procedure :: get_hel => particle_get_hel
<<Particles: procedures>>=
  function particle_get_flv (prt) result (flv)
    class(particle_t), intent(in) :: prt
    type(flavor_t) :: flv
    flv = prt%flv
  end function particle_get_flv 
  
  function particle_get_col (prt) result (col)
    class(particle_t), intent(in) :: prt
    type(color_t) :: col
    col = prt%col
  end function particle_get_col
  
  function particle_get_hel (prt) result (hel)
    class(particle_t), intent(in) :: prt
    type(helicity_t) :: hel
    hel = prt%hel
  end function particle_get_hel
  
@ %def particle_get_flv particle_get_col particle_get_hel
@ Return the helicity (if defined and diagonal).
<<Particles: particle: TBP>>=
  procedure :: get_helicity => particle_get_helicity
<<Particles: procedures>>=
  elemental function particle_get_helicity (prt) result (hel)
    integer :: hel
    integer, dimension(2) :: hel_arr
    class(particle_t), intent(in) :: prt    
    hel = 0
    if (prt%hel%is_defined () .and. prt%hel%is_diagonal ()) then
       hel_arr = prt%hel%to_pair ()
       hel = hel_arr (1)
    end if
  end function particle_get_helicity  
  
@ %def particle_get_helicity
@ Return the number of children/parents
<<Particles: particle: TBP>>=
  procedure :: get_n_parents => particle_get_n_parents
  procedure :: get_n_children => particle_get_n_children
<<Particles: procedures>>=
  elemental function particle_get_n_parents (prt) result (n)
    integer :: n
    class(particle_t), intent(in) :: prt
    if (allocated (prt%parent)) then
       n = size (prt%parent)
    else
       n = 0
    end if
  end function particle_get_n_parents
    
  elemental function particle_get_n_children (prt) result (n)
    integer :: n
    class(particle_t), intent(in) :: prt
    if (allocated (prt%child)) then
       n = size (prt%child)
    else
       n = 0
    end if
  end function particle_get_n_children
    
@ %def particle_get_n_parents particle_get_n_children
@ Return the array of parents/children.
<<Particles: particle: TBP>>=
  procedure :: get_parents => particle_get_parents
  procedure :: get_children => particle_get_children
<<Particles: procedures>>=
  function particle_get_parents (prt) result (parent)
    class(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: parent
    if (allocated (prt%parent)) then
       allocate (parent (size (prt%parent)))
       parent = prt%parent
    else
       allocate (parent (0))
    end if
  end function particle_get_parents

  function particle_get_children (prt) result (child)
    class(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: child
    if (allocated (prt%child)) then
       allocate (child (size (prt%child)))
       child = prt%child
    else
       allocate (child (0))
    end if
  end function particle_get_children

@ %def particle_get_children
@
<<Particles: particle: TBP>>=
  procedure :: has_children => particle_has_children
<<Particles: procedures>>=
  elemental function particle_has_children (prt) result (has_children)
    logical :: has_children
    class(particle_t), intent(in) :: prt
    has_children = .false.
    if (allocated (prt%child)) then
       has_children = size (prt%child) > 0
    end if
  end function particle_has_children

@ %def particle_has_children
@
<<Particles: particle: TBP>>=
  procedure :: has_parents => particle_has_parents
<<Particles: procedures>>=
  elemental function particle_has_parents (prt) result (has_parents)
    logical :: has_parents
    class(particle_t), intent(in) :: prt
    has_parents = .false.
    if (allocated (prt%parent)) then
       has_parents = size (prt%parent) > 0
    end if
  end function particle_has_parents

@ %def particle_has_parents
@ Return momentum and momentum squared.
<<Particles: particle: TBP>>=
  procedure :: get_momentum => particle_get_momentum
  procedure :: get_p2 => particle_get_p2
<<Particles: procedures>>=
  elemental function particle_get_momentum (prt) result (p)
    type(vector4_t) :: p
    class(particle_t), intent(in) :: prt
    p = prt%p
  end function particle_get_momentum

  elemental function particle_get_p2 (prt) result (p2)
    real(default) :: p2
    class(particle_t), intent(in) :: prt
    p2 = prt%p2
  end function particle_get_p2

@ %def particle_get_momentum particle_get_p2
@ Return the particle vertex, if allocated.
<<Particles: particle: TBP>>=
  procedure :: get_vertex => particle_get_vertex
<<Particles: procedures>>=
  elemental function particle_get_vertex (prt) result (vtx)
    type(vector4_t) :: vtx
    class(particle_t), intent(in) :: prt
    if (allocated (prt%vertex)) then
       vtx = prt%vertex
    else
       vtx = vector4_null
    end if
  end function particle_get_vertex

@ %def particle_get_vertex
@
<<Particles: particle: TBP>>=
  procedure :: momentum_to_pythia6 => particle_momentum_to_pythia6
<<Particles: procedures>>=
  pure function particle_momentum_to_pythia6 (prt) result (p)
    real(double), dimension(1:5) :: p
    class(particle_t), intent(in) :: prt
    p = prt%p%to_pythia6 (sqrt (prt%p2))
  end function particle_momentum_to_pythia6

@ %def particle_momentum_to_pythia6
@
\subsection{Particle sets}
A particle set is what is usually called an event: an array of
particles.  The individual particle entries carry momentum, quantum
numbers, polarization, and optionally connections.  There is (also
optionally) a correlated state-density matrix that maintains spin
correlations that are lost in the individual particle entries.
<<Particles: public>>=
  public :: particle_set_t
<<Particles: types>>=
  type :: particle_set_t
     integer :: n_beam = 0
     integer :: n_in  = 0
     integer :: n_vir = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     type(particle_t), dimension(:), allocatable :: prt
     type(state_matrix_t) :: correlated_state
   contains
   <<Particles: particle set: TBP>>
  end type particle_set_t

@ %def particle_set_t
@ A particle set can be initialized from an interaction or from a
HepMC event record.
<<Particles: particle set: TBP>>=
  generic :: init => init_interaction
  procedure :: init_interaction => particle_set_init_interaction
@ %def particle_set_init 
@ When a particle set is initialized from a given interaction, we have
to determine the branch within the original state matrix that fixes
the particle quantum numbers.  This is done with the appropriate
probabilities, based on a random number [[x]].  The [[mode]]
determines whether the individual particles become unpolarized, or
take a definite (diagonal) helicity, or acquire single-particle
polarization matrices.  The flag [[keep_correlations]] tells whether
the spin-correlation matrix is to be calculated and stored in addition
to the particles.  The flag [[keep_virtual]] tells whether virtual
particles should be dropped.  Note that if virtual particles are
dropped, the spin-correlation matrix makes no sense, and parent-child
relations are not set.

For a correct disentangling of color and flavor (in the presence of
helicity), we consider two interactions.  [[int]] has no color
information, and is used to select a flavor state.  Consequently, we
trace over helicities here.  [[int_flows]] contains color-flow and
potentially helicity information, but is useful only after the flavor
combination has been chosen.  So this interaction is used to select
helicity and color, but restricted to the selected flavor combination.

[[int]] and [[int_flows]] may be identical if there is only a single
(or no) color flow.  If there is just a single flavor combination,
[[x(1)]] can be set to zero.

The current algorithm of evaluator convolution requires that the beam
particles are assumed outgoing (in the beam interaction) and become
virtual in all derived interactions.  In the particle set they should
be re-identified as incoming.  The optional integer [[n_incoming]]
can be used to perform this correction.
    
The flag [[is_valid]] is false if factorization of the state is not
possible, in particular if the squared matrix element is zero.
<<Particles: procedures>>=
  subroutine particle_set_init_interaction &
       (particle_set, is_valid, int, int_flows, mode, x, &
        keep_correlations, keep_virtual, n_incoming)
    class(particle_set_t), intent(out) :: particle_set
    logical, intent(out) :: is_valid
    type(interaction_t), intent(in), target :: int, int_flows
    integer, intent(in) :: mode
    real(default), dimension(2), intent(in) :: x
    logical, intent(in) :: keep_correlations, keep_virtual
    integer, intent(in), optional :: n_incoming
    type(state_matrix_t), dimension(:), allocatable, target :: flavor_state
    type(state_matrix_t), dimension(:), allocatable, target :: single_state
    integer :: n_in, n_vir, n_out, n_tot
    type(quantum_numbers_t), dimension(:,:), allocatable :: qn
    logical :: ok
    integer :: i, j
    if (present (n_incoming)) then
       n_in  = n_incoming
       n_vir = int%get_n_vir () - n_incoming
    else
       n_in  = int%get_n_in  ()
       n_vir = int%get_n_vir ()
    end if
    n_out = int%get_n_out ()
    n_tot = int%get_n_tot ()
    particle_set%n_in  = n_in
    particle_set%n_out = n_out
    if (keep_virtual) then
       particle_set%n_vir = n_vir
       particle_set%n_tot = n_tot
    else
       particle_set%n_vir = 0
       particle_set%n_tot = n_in + n_out
    end if
    call int%factorize &
         (FM_IGNORE_HELICITY, x(1), is_valid, flavor_state)
    allocate (qn (n_tot,1))
    do i = 1, n_tot
       qn(i,:) = flavor_state(i)%get_quantum_numbers (1)
    end do
    if (keep_correlations .and. keep_virtual) then
       call int_flows%factorize (mode, x(2), ok, &
            single_state, particle_set%correlated_state, qn(:,1))
    else
       call int_flows%factorize (mode, x(2), ok, &
            single_state, qn_in=qn(:,1))
    end if
    is_valid = is_valid .and. ok
    allocate (particle_set%prt (particle_set%n_tot))
    j = 1
    do i = 1, n_tot
       if (i <= n_in) then
          call particle_set%prt(j)%init (single_state(i), PRT_INCOMING, mode)
          call particle_set%prt(j)%set_momentum (int%get_momentum (i))
       else if (i <= n_in + n_vir) then
          if (.not. keep_virtual)  cycle
          call particle_set%prt(j)%init &
               (single_state(i), PRT_VIRTUAL, mode) 
          call particle_set%prt(j)%set_momentum (int%get_momentum (i))
       else
          call particle_set%prt(j)%init (single_state(i), PRT_OUTGOING, mode)
          call particle_set%prt(j)%set_momentum &
               (int%get_momentum (i), on_shell = .true.)
       end if
       if (keep_virtual) then
          call particle_set%prt(j)%set_children &
               (interaction_get_children (int, i))
          call particle_set%prt(j)%set_parents &
               (interaction_get_parents (int, i))
       end if
       j = j + 1
    end do
    if (keep_virtual) then
       call particle_set_resonance_flag &
            (particle_set%prt, int%get_resonance_flags ())
    end if
    do i = i, size(flavor_state)
       call flavor_state(i)%final ()
    end do
    do i = i, size(single_state)
       call single_state(i)%final ()
    end do
  end subroutine particle_set_init_interaction

@ %def particle_set_init_interaction
@ Manually set the model for the stored particles.
<<Particles: particle set: TBP>>=
  procedure :: set_model => particle_set_set_model
<<Particles: procedures>>=
  subroutine particle_set_set_model (particle_set, model)
    class(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    integer :: i
    do i = 1, particle_set%n_tot
       call particle_set%prt(i)%set_model (model)
    end do
    call particle_set%correlated_state%set_model (model)
  end subroutine particle_set_set_model
    
@ %def particle_set_set_model
@ Pointer components are hidden inside the particle polarization, and
in the correlated state matrix.
<<Particles: particle set: TBP>>=
  procedure :: final => particle_set_final
<<Particles: procedures>>=
  subroutine particle_set_final (particle_set)
    class(particle_set_t), intent(inout) :: particle_set
    integer :: i
    if (allocated (particle_set%prt)) then
       do i = 1, size(particle_set%prt)
          call particle_set%prt(i)%final ()
       end do
       deallocate (particle_set%prt)
    end if
    call particle_set%correlated_state%final ()
  end subroutine particle_set_final

@ %def particle_set_final
@
<<Particles: particle set: TBP>>=
  procedure :: get_momenta => particle_set_get_momenta
<<Particles: procedures>>=
  function particle_set_get_momenta (particle_set) result (p)
    class(particle_set_t), intent(in) :: particle_set
    type(vector4_t), dimension(:), allocatable :: p
    allocate (p (size (particle_set%prt)))
    p = particle_set%prt%p
  end function particle_set_get_momenta

@ %def particle_set_get_momenta
@
<<Particles: particle set: TBP>>=
  procedure :: set_momenta => particle_set_set_momenta
<<Particles: procedures>>=
  pure subroutine particle_set_set_momenta (particle_set, p)
    class(particle_set_t), intent(inout) :: particle_set
    type(vector4_t), dimension(:), intent(in) :: p
    if (.not. allocated (particle_set%prt)) then
       allocate (particle_set%prt (size (p)))
    end if
    particle_set%prt%p = p
  end subroutine particle_set_set_momenta

@ %def particle_set_set_momenta
@
<<Particles: particle set: TBP>>=
  procedure :: parent_add_child => particle_set_parent_add_child
<<Particles: procedures>>=
  subroutine particle_set_parent_add_child (particle_set, parent, child)
    class(particle_set_t), intent(inout) :: particle_set
    integer, intent(in) :: parent, child
    call particle_set%prt(child)%set_parents ([parent])
    call particle_set%prt(parent)%add_child (child)
  end subroutine particle_set_parent_add_child

@ %def particle_set_parent_add_child
@ Given the [[particle_set]] before radiation, the new momenta
[[p_radiated]], the [[emitter]] and the [[flv_radiated]] as well as the
[[model]] and a random number [[r_color]] for chosing a color, we update
the [[particle_set]].
<<Particles: particle set: TBP>>=
  procedure :: build_radiation => particle_set_build_radiation
<<Particles: procedures>>=
  subroutine particle_set_build_radiation (particle_set, p_radiated, &
     emitter, flv_radiated, model, r_color)
     class(particle_set_t), intent(inout) :: particle_set
     type(vector4_t), intent(in), dimension(:) :: p_radiated
     integer, intent(in) :: emitter
     integer, intent(in), dimension(:) :: flv_radiated
     class(model_data_t), intent(in), target :: model
     real(default), intent(in) :: r_color
     type(particle_set_t) :: new_particle_set
     type(particle_t) :: new_particle
     integer :: i, n_particles
     integer :: pdg_index_emitter, pdg_index_radiation
     integer :: n_in, n_vir, n_out, n_tot
     integer, dimension(:), allocatable :: parents, children
     type(flavor_t) :: new_flv

     n_particles = size (particle_set%prt)
     if (n_particles+1 /= size (p_radiated))  call msg_fatal &
        ("Number of particles does not equal number of momenta")

     new_particle_set%n_beam = particle_set%n_beam
     new_particle_set%n_in = particle_set%n_in
     new_particle_set%n_vir = particle_set%n_vir
     new_particle_set%n_out = particle_set%n_out+1
     new_particle_set%n_tot = particle_set%n_tot+1
     new_particle_set%correlated_state = particle_set%correlated_state
     allocate (new_particle_set%prt (new_particle_set%n_tot))
     n_in = new_particle_set%n_in; n_vir = new_particle_set%n_vir
     n_out = new_particle_set%n_out; n_tot = new_particle_set%n_tot
     do i = 1, n_in
        new_particle_set%prt(i) = particle_set%prt(i)
        call new_particle_set%prt(i)%set_momentum (p_radiated(i))
        call new_particle_set%prt(i)%reset_status (PRT_INCOMING)
     end  do
     do i = n_in+1, n_in+n_vir
        new_particle_set%prt(i) = particle_set%prt(i)
        call new_particle_set%prt(i)%set_momentum (particle_set%prt(i)%p)
        call new_particle_set%prt(i)%reset_status (PRT_VIRTUAL)
     end do
     !!! Parents correct, care for children
     allocate (children (n_out))
     do i = 1, n_out
        children(i) = n_in+n_vir+i
     end do
     do i = n_in+1, n_in+n_vir
        call new_particle_set%prt(i)%set_children (children)
     end do
     do i = n_in+n_vir+1, n_tot-1
        new_particle_set%prt(i) = particle_set%prt(i-n_vir)
        call new_particle_set%prt(i)%set_momentum (p_radiated(i-n_vir))
        call new_particle_set%prt(i)%reset_status (PRT_OUTGOING)
     end do
     call new_particle%reset_status (PRT_OUTGOING)
     call new_particle%set_momentum (p_radiated (n_tot-n_vir))
     !!! Helicity and polarization handling is missing at this point
     pdg_index_emitter = flv_radiated (emitter)
     pdg_index_radiation = flv_radiated (n_tot-n_vir)
     call new_flv%init (pdg_index_radiation, model)
     call reassign_colors (new_particle, new_particle_set%prt(n_vir+emitter), &
                           pdg_index_radiation, pdg_index_emitter, r_color)
     !!! Also, no helicities or polarizations yet
     call new_particle%set_flavor (new_flv)
     new_particle_set%prt(n_tot) = new_particle
     !!! Set proper parents for outgoing particles
     allocate (parents (n_in))
     do i = 1, n_in
        parents(i) = n_in+i
     end do
     do i = n_in+n_vir+1, n_tot
        call new_particle_set%prt(i)%set_parents (parents)
     end do
     !!! Overwrite old particle set
     select type (particle_set)
     type is (particle_set_t)
        particle_set = new_particle_set
     end select
  contains
    subroutine reassign_colors (prt_radiated, prt_emitter, i_rad, i_em, r_col)
      type(particle_t), intent(inout) :: prt_radiated, prt_emitter
      integer, intent(in) :: i_rad, i_em
      real(default), intent(in) :: r_col
      type(color_t) :: col_rad, col_em
      if (is_quark (abs (i_em)) .and. is_gluon (i_rad)) then
         call reassign_colors_qg (prt_emitter, col_rad, col_em)
      else if (is_gluon (i_em) .and. is_gluon (i_rad)) then
         call reassign_colors_gg (prt_emitter, r_col, col_rad, col_em)
      else if (is_gluon (i_em) .and. is_quark (abs (i_rad))) then
         call reassign_colors_qq (prt_emitter, i_em, col_rad, col_em)
      else
         call msg_fatal ("Invalid splitting")
      end if
      call prt_emitter%set_color (col_em)
      call prt_radiated%set_color (col_rad)
    end subroutine reassign_colors

    subroutine reassign_colors_qg (prt_emitter, col_rad, col_em)
      type(particle_t), intent(in) :: prt_emitter
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      integer :: new_color_index
      logical :: is_anti_quark

      color_em = prt_emitter%get_color ()
      i1 = 1; i2 = 2
      is_anti_quark = color_em(2) /= 0
      if (is_anti_quark) then
         i1 = 2; i2 = 1
      end if
      new_color_index = color_em(i1)+1
      color_rad(i1) = color_em(i1)
      color_rad(i2) = new_color_index
      color_em(i1) = new_color_index
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_qg

    subroutine reassign_colors_gg (prt_emitter, random, col_rad, col_em)
      !!! NOT TESTED YET
      type(particle_t), intent(in) :: prt_emitter
      real(default), intent(in) :: random
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      integer :: new_color_index

      color_em = prt_emitter%get_color ()
      new_color_index = maxval (abs (color_em))
      i1 = 1; i2 = 2
      if (random < 0.5) then
         i1 = 2; i2 = 1
      end if
      color_rad(i1) = new_color_index
      color_rad(i2) = color_em(i2)
      color_em(i2) = new_color_index
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_gg

    subroutine reassign_colors_qq (prt_emitter, pdg_emitter, col_rad, col_em)
      !!! NOT TESTED YET
      type(particle_t), intent(in) :: prt_emitter
      integer, intent(in) :: pdg_emitter
      type(color_t), intent(out) :: col_rad, col_em
      integer, dimension(2) :: color_rad, color_em
      integer :: i1, i2
      logical :: is_anti_quark

      color_em = prt_emitter%get_color ()
      i1 = 1; i2 = 2
      is_anti_quark = pdg_emitter < 0
      if (is_anti_quark) then
         i1 = 2; i1 = 1
      end if
      color_em(i2) = 0
      color_rad(i1) = 0
      color_rad(i2) = color_em(i1)
      call col_em%init_col_acl (color_em(1), color_em(2))
      call col_rad%init_col_acl (color_rad(1), color_rad(2))
    end subroutine reassign_colors_qq
  end subroutine particle_set_build_radiation

@ %def particle_set_build_radiation   
@ Output (default format)
<<Particles: particle set: TBP>>=
  procedure :: write => particle_set_write
<<Particles: procedures>>=
  subroutine particle_set_write &
    (particle_set, unit, testflag, summary, compressed)
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, summary, compressed
    logical :: summ, comp
    type(vector4_t) :: sum_vec
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    summ = .false.; if (present (summary)) summ = summary
    comp = .false.; if (present (compressed)) comp = compressed
    write (u, "(1x,A)") "Particle set:"
    call write_separator (u)
    if (comp) write (u, &
         "((A4,1X),(A6,1X),(A7,1X),2(A4,1X),2(A20,1X),5(A12,1X))") &
         "Nr", "Status", "Flavor", "Col", "ACol", "Parents", "Children", &
         "P(0)", "P(1)", "P(2)", "P(3)", "P^2"
    if (particle_set%n_tot /= 0) then
       do i = 1, particle_set%n_tot
          if (comp) then
             write (u, "(I4,1X,2X)", advance="no") i
          else
             write (u, "(1x,A,1x,I0)", advance="no") "Particle", i
          end if
          call particle_set%prt(i)%write (u, testflag = testflag, &
               compressed = comp)
       end do
       if (particle_set%correlated_state%is_defined ()) then
          call write_separator (u)
          write (u, *) "Correlated state density matrix:"
          call particle_set%correlated_state%write (u)
       end if
       if (summ) then
          call write_separator (u)
          write (u, "(A)", advance="no") &
               "Sum of incoming momenta: p(0:3) =     "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_INCOMING)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, *)
          write (u, "(A)", advance="no") &
               "Sum of beam remnant momenta: p(0:3) = "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_BEAM_REMNANT)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, *)
          write (u, "(A)", advance="no") &
               "Sum of outgoing momenta: p(0:3) =     "
          sum_vec = sum (particle_set%prt%p, &
               mask=particle_set%prt%get_status () == PRT_OUTGOING)
          call pacify (sum_vec, tolerance = 1E-3_default)
          call sum_vec%write (u, compressed=.true.)
          write (u, "(A)") ""
       end if
    else
       write (u, "(3x,A)") "[empty]"
    end if
  end subroutine particle_set_write

@ %def particle_set_write
@ 
\subsection{I/O formats}
Here, we define input/output of particle sets in various formats.
This is the right place since particle sets contain most of the event
information.

All write/read routines take as first argument the object, as second
argument the I/O unit which in this case is a mandatory argument.
Then follow further event data.

\subsubsection{Internal binary format}
This format is supposed to contain the complete information, so
the particle data set can be fully reconstructed.  The exception is
the model part of the particle flavors; this is unassigned for the
flavor values read from file.
<<Particles: particle set: TBP>>=
  procedure :: write_raw => particle_set_write_raw 
  procedure :: read_raw => particle_set_read_raw 
<<Particles: procedures>>=
  subroutine particle_set_write_raw (particle_set, u)
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: u
    integer :: i
    write (u) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    write (u) particle_set%n_tot
    do i = 1, particle_set%n_tot
       call particle_set%prt(i)%write_raw (u)
    end do
    call particle_set%correlated_state%write_raw (u)
  end subroutine particle_set_write_raw

  subroutine particle_set_read_raw (particle_set, u, iostat)
    class(particle_set_t), intent(out) :: particle_set
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    integer :: i
    read (u, iostat=iostat) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    read (u, iostat=iostat) particle_set%n_tot
    allocate (particle_set%prt (particle_set%n_tot))
    do i = 1, size (particle_set%prt)
       call particle_set%prt(i)%read_raw (u, iostat=iostat)
    end do
    call particle_set%correlated_state%read_raw (u, iostat=iostat)
  end subroutine particle_set_read_raw

@ %def particle_set_write_raw particle_set_read_raw
@ 
\subsubsection{Get contents}
Find parents/children of a particular particle recursively; the
search terminates if a parent/child has status [[BEAM]], [[INCOMING]],
[[OUTGOING]] or [[RESONANT]].
<<Particles: particle set: TBP>>=
  procedure :: get_real_parents => particle_set_get_real_parents
  procedure :: get_real_children => particle_set_get_real_children
<<Particles: procedures>>=
  function particle_set_get_real_parents (pset, i, keep_beams) result (parent)
    integer, dimension(:), allocatable :: parent
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, intent(in), optional :: keep_beams
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_parent, is_real_parent
    logical :: kb
    integer :: j, k
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    is_real = pset%prt%is_real (kb)
    allocate (is_parent (pset%n_tot), is_real_parent (pset%n_tot))
    is_real_parent = .false.
    is_parent = .false.
    is_parent(pset%prt(i)%get_parents()) = .true.
    do while (any (is_parent))
       where (is_real .and. is_parent)
          is_real_parent = .true.
          is_parent = .false.
       end where
       mark_next_parent: do j = size (is_parent), 1, -1
          if (is_parent(j)) then
             is_parent(pset%prt(j)%get_parents()) = .true.
             is_parent(j) = .false.
             exit mark_next_parent
          end if
       end do mark_next_parent
    end do
    allocate (parent (count (is_real_parent)))
    j = 0
    do k = 1, size (is_parent)
       if (is_real_parent(k)) then
          j = j + 1
          parent(j) = k
       end if
    end do
  end function particle_set_get_real_parents

  function particle_set_get_real_children (pset, i, keep_beams) result (child)
    integer, dimension(:), allocatable :: child
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_child, is_real_child
    logical, intent(in), optional :: keep_beams
    integer :: j, k
    logical :: kb
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    is_real = pset%prt%is_real (kb)
    allocate (is_child (pset%n_tot), is_real_child (pset%n_tot))
    is_real_child = .false.
    is_child = .false.
    is_child(pset%prt(i)%get_children()) = .true.
    do while (any (is_child))
       where (is_real .and. is_child)
          is_real_child = .true.
          is_child = .false.
       end where
       mark_next_child: do j = 1, size (is_child)
          if (is_child(j)) then
             is_child(pset%prt(j)%get_children()) = .true.
             is_child(j) = .false.
             exit mark_next_child
          end if
       end do mark_next_child
    end do
    allocate (child (count (is_real_child)))
    j = 0
    do k = 1, size (is_child)
       if (is_real_child(k)) then
          j = j + 1
          child(j) = k
       end if
    end do
  end function particle_set_get_real_children

@ %def particle_set_get_real_parents
@ %def particle_set_get_real_children
@ Get the [[n_tot]], [[n_in]], and [[n_out]] values out of the
particle set.
<<Particles: particle set: TBP>>=
  procedure :: get_n_beam => particle_set_get_n_beam
  procedure :: get_n_in => particle_set_get_n_in
  procedure :: get_n_vir => particle_set_get_n_vir
  procedure :: get_n_out => particle_set_get_n_out
  procedure :: get_n_tot => particle_set_get_n_tot
  procedure :: get_n_remnants => particle_set_get_n_remnants
<<Particles: procedures>>=
  function particle_set_get_n_beam (pset) result (n_beam)
     class(particle_set_t), intent(in) :: pset
     integer :: n_beam
     n_beam = pset%n_beam
  end function particle_set_get_n_beam

  function particle_set_get_n_in (pset) result (n_in)
     class(particle_set_t), intent(in) :: pset
     integer :: n_in
     n_in = pset%n_in
  end function particle_set_get_n_in

  function particle_set_get_n_vir (pset) result (n_vir)
     class(particle_set_t), intent(in) :: pset
     integer :: n_vir
     n_vir = pset%n_vir
   end function particle_set_get_n_vir

  function particle_set_get_n_out (pset) result (n_out)
     class(particle_set_t), intent(in) :: pset
     integer :: n_out
     n_out = pset%n_out
  end function particle_set_get_n_out
  
  function particle_set_get_n_tot (pset) result (n_tot)
     class(particle_set_t), intent(in) :: pset
     integer :: n_tot
     n_tot = pset%n_tot
  end function particle_set_get_n_tot

  function particle_set_get_n_remnants (pset) result (n_rad)
    class(particle_set_t), intent(in) :: pset
    integer :: n_rad
    n_rad = count (pset%prt%get_status () == PRT_BEAM_REMNANT)
  end function particle_set_get_n_remnants

@ %def particle_set_get_n_beam
@ %def particle_set_get_n_in
@ %def particle_set_get_n_vir
@ %def particle_set_get_n_out
@ %def particle_set_get_n_tot
@ %def particle_set_get_n_remnants
@ Return a pointer to the particle corresponding to the number
<<Particles: particle set: TBP>>=
  procedure :: get_particle => particle_set_get_particle
<<Particles: procedures>>=
  function particle_set_get_particle (pset, index) result (particle)
    class(particle_set_t), intent(in) :: pset
    integer, intent(in) :: index
    type(particle_t) :: particle
    particle = pset%prt(index)
  end function particle_set_get_particle

@ %def particle_set_get_particle
@
<<Particles: particle set: TBP>>=
  procedure :: get_indices => particle_set_get_indices
<<Particles: procedures>>=
  pure function particle_set_get_indices (pset, mask) result (finals)
    integer, dimension(:), allocatable :: finals
    class(particle_set_t), intent(in) :: pset
    logical, dimension(:), intent(in) :: mask
    integer, dimension(size(mask)) :: indices
    integer :: i
    allocate (finals (count (mask)))
    indices = [(i, i=1, pset%n_tot)]
    finals = pack (indices, mask)
  end function particle_set_get_indices

@ %def particle_set_get_indices
@
\subsubsection{Tools}
Build a new particles array without hadronic remnants but with
[[n_extra]] additional spots.  We also update the mother-daughter
relations assuming the ordering [[b]], [[i]], [[r]], [[x]], [[o]].
<<Particles: particle set: TBP>>=
  procedure :: without_hadronic_remnants => &
       particle_set_without_hadronic_remnants
<<Particles: procedures>>=
  subroutine particle_set_without_hadronic_remnants &
         (particle_set, particles, n_particles, n_extra)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), allocatable, dimension(:), intent(out) :: particles
    integer, intent(out) :: n_particles
    integer, intent(in) :: n_extra
    logical, allocatable, dimension(:) :: no_hadronic_remnants
    integer, allocatable, dimension(:) :: children, new_children
    integer :: i, j, first_remnant
    first_remnant = particle_set%n_tot
    do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%is_hadronic_beam_remnant ()) then
          first_remnant = i
          exit
       end if
    end do
    n_particles = count (.not. particle_set%prt%is_hadronic_beam_remnant ())
    allocate (no_hadronic_remnants (n_particles)) 
    no_hadronic_remnants = .not. particle_set%prt%is_hadronic_beam_remnant ()
    allocate (particles (n_particles + n_extra))
    particles (1:n_particles) = pack (particle_set%prt, no_hadronic_remnants)
    if (n_particles /= particle_set%n_tot) then
       do i = 1, n_particles
          select case (particles(i)%get_status ())
          case (PRT_BEAM)
             children = particles(i)%get_children ()
             no_hadronic_remnants = .not. &
                  (particle_set%prt(children)%is_hadronic_beam_remnant ())
             new_children = pack (children, no_hadronic_remnants)
             call particles(i)%set_children (new_children)
          case (PRT_INCOMING, PRT_RESONANT)
             <<update children after remnant>>
          case (PRT_OUTGOING, PRT_BEAM_REMNANT)
          case default
          end select
       end do
    end if
  end subroutine particle_set_without_hadronic_remnants

@ %def particle_set_without_hadronic_remnants
<<update children after remnant>>=
children = particles(i)%get_children ()
do j = 1, size (children)
   if (children(j) > first_remnant) then
      children(j) = children (j) - (particle_set%n_tot - n_particles)
   end if
end do
call particles(i)%set_children (children)
@
Build a new particles array without remnants but with
[[n_extra]] additional spots.  We also update the mother-daughter
relations assuming the ordering [[b]], [[i]], [[r]], [[x]], [[o]].
<<Particles: particle set: TBP>>=
  procedure :: without_remnants => particle_set_without_remnants
<<Particles: procedures>>=
  subroutine particle_set_without_remnants &
         (particle_set, particles, n_particles, n_extra)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), allocatable, dimension(:), intent(out) :: particles
    integer, intent(in) :: n_extra
    integer, intent(out) :: n_particles
    logical, allocatable, dimension(:) :: no_remnants
    integer, allocatable, dimension(:) :: children, new_children
    integer :: i,j, first_remnant
    first_remnant = particle_set%n_tot
    do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%is_beam_remnant ()) then
          first_remnant = i
          exit
       end if
    end do
    no_remnants = .not. (particle_set%prt%is_beam_remnant ())
    n_particles = count (no_remnants)
    allocate (particles (n_particles + n_extra))
    particles (1:n_particles) = pack (particle_set%prt, no_remnants)
    if (n_particles /= particle_set%n_tot) then
       do i = 1, n_particles
          select case (particles(i)%get_status ())
          case (PRT_BEAM)
             children = particles(i)%get_children ()
             no_remnants = .not. (particle_set%prt(children)%is_beam_remnant ())
             new_children = pack (children, no_remnants)
             call particles(i)%set_children (new_children)
          case (PRT_INCOMING, PRT_RESONANT)
             <<update children after remnant>>
          case (PRT_OUTGOING, PRT_BEAM_REMNANT)
          case default
          end select
       end do
    end if
  end subroutine particle_set_without_remnants

@ %def particle_set_without_remnants
@
<<Particles: particle set: TBP>>=
  procedure :: find_particle => particle_set_find_particle
<<Particles: procedures>>=
  pure function particle_set_find_particle &
         (particle_set, pdg, momentum, abs_smallness, rel_smallness) result (idx)
    integer :: idx
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: pdg
    type(vector4_t), intent(in) :: momentum
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    integer :: i
    idx = 0
    do i = 1, size (particle_set%prt)
       if (particle_set%prt(i)%flv%get_pdg () == pdg) then
          if (all (nearly_equal (particle_set%prt(i)%p%p, momentum%p, &
                                 abs_smallness, rel_smallness))) then
             idx = i
             return
          end if
       end if
    end do
  end function particle_set_find_particle

@ %def particle_set_find_particle
<<Particles: particle set: TBP>>=
  procedure :: reverse_find_particle => particle_set_reverse_find_particle
<<Particles: procedures>>=
  pure function particle_set_reverse_find_particle &
         (particle_set, pdg, momentum, abs_smallness, rel_smallness) result (idx)
    integer :: idx
    class(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: pdg
    type(vector4_t), intent(in) :: momentum
    real(default), intent(in), optional :: abs_smallness, rel_smallness
    integer :: i
    idx = 0
    do i = size (particle_set%prt), 1, -1
       if (particle_set%prt(i)%flv%get_pdg () == pdg) then
          if (all (nearly_equal (particle_set%prt(i)%p%p, momentum%p, &
                                 abs_smallness, rel_smallness))) then
             idx = i
             return
          end if
       end if
    end do
  end function particle_set_reverse_find_particle

@ %def particle_set_reverse_find_particle
@ This connects broken links of the form
$\text{something} \to i \to \text{none or} j$ and
$\text{none} \to j \to \text{something or none}$ where the particles $i$ and $j$
are \emph{identical}.  It also works if $i \to j$, directly, and thus
removes duplicates.  We are removing $j$ and connect the possible
daughters to $i$.
<<Particles: particle set: TBP>>=
  procedure :: remove_duplicates => particle_set_remove_duplicates
<<Particles: procedures>>=
  subroutine particle_set_remove_duplicates (particle_set, smallness)
    class(particle_set_t), intent(inout) :: particle_set
    real(default), intent(in) :: smallness
    integer :: n_removals
    integer, dimension(particle_set%n_tot) :: to_remove
    type(particle_t), dimension(:), allocatable :: particles
    type(vector4_t) :: p_i
    integer, dimension(:), allocatable :: map
    to_remove = 0
    call find_duplicates ()
    n_removals = count (to_remove > 0)
    if (n_removals > 0) then
       call strip_duplicates (particles)
       call particle_set%replace (particles)
    end if

  contains

  <<Particles: remove duplicates: procedures>>

  end subroutine particle_set_remove_duplicates

@ %def particle_set_remove_duplicates
@ This doesn't catch all cases. Missing are splittings of the type
$i \to \text{something and} j$.
<<Particles: remove duplicates: procedures>>=
  subroutine find_duplicates ()
    integer :: pdg_i, child_i, i, j
    OUTER: do i = 1, particle_set%n_tot
       if (particle_set%prt(i)%status == PRT_OUTGOING .or. &
            particle_set%prt(i)%status == PRT_VIRTUAL .or. &
            particle_set%prt(i)%status == PRT_RESONANT) then
          if (allocated (particle_set%prt(i)%child)) then
             if (size (particle_set%prt(i)%child) > 1) cycle OUTER
             if (size (particle_set%prt(i)%child) == 1) then
                child_i = particle_set%prt(i)%child(1)
             else
                child_i = 0
             end if
          else
             child_i = 0
          end if
          pdg_i = particle_set%prt(i)%flv%get_pdg ()
          p_i = particle_set%prt(i)%p
          do j = i + 1, particle_set%n_tot
             if (pdg_i == particle_set%prt(j)%flv%get_pdg ()) then
                if (all (nearly_equal (particle_set%prt(j)%p%p, p_i%p, &
                     abs_smallness = smallness, &
                     rel_smallness = 1E4_default * smallness))) then
                   if (child_i == 0 .or. j == child_i) then
                      to_remove(j) = i
                      call msg_debug2 (D_PARTICLES, &
                           "Particles: Will remove duplicate of i", i)
                      call msg_debug2 (D_PARTICLES, &
                           "Particles: j", j)
                   end if
                   cycle OUTER
                end if
             end if
          end do
       end if
    end do OUTER
  end subroutine find_duplicates 

@
<<Particles: remove duplicates: procedures>>=
  recursive function get_alive_index (try) result (alive)
    integer :: alive
    integer :: try
    if (map(try) > 0) then
       alive = map(try)
    else
       alive = get_alive_index (to_remove(try))
    end if
  end function get_alive_index

@
<<Particles: remove duplicates: procedures>>=
  subroutine strip_duplicates (particles)
    type(particle_t), dimension(:), allocatable, intent(out) :: particles
    integer :: kept, removed, i, j
    integer, dimension(:), allocatable :: old_children
    logical, dimension(:), allocatable :: parent_set
    call msg_debug (D_PARTICLES, "Particles: Removing duplicates")
    call msg_debug (D_PARTICLES, "Particles: n_removals", n_removals)
    if (debug2_active (D_PARTICLES)) then
       call msg_debug2 (D_PARTICLES, "Particles: Given set before removing:")
       call particle_set%write (summary=.true., compressed=.true.)
    end if
    allocate (particles (particle_set%n_tot - n_removals))
    allocate (map (particle_set%n_tot))
    allocate (parent_set (particle_set%n_tot))
    parent_set = .false.
    map = 0
    j = 0
    do i = 1, particle_set%n_tot
       if (to_remove(i) == 0) then
          j = j + 1
          map(i) = j
          call particles(j)%init (particle_set%prt(i))
       end if
    end do
    do i = 1, particle_set%n_tot
       if (map(i) /= 0) then
          if (.not. parent_set(map(i))) then
             call particles(map(i))%set_parents &
                  (map (particle_set%prt(i)%get_parents ()))
          end if
          call particles(map(i))%set_children &
               (map (particle_set%prt(i)%get_children ()))
       else
          removed = i
          kept = to_remove(i)
          if (particle_set%prt(removed)%has_children ()) then
             old_children = particle_set%prt(removed)%get_children ()
             do j = 1, size (old_children)
                if (map(old_children(j)) > 0) then
                   call particles(map(old_children(j)))%set_parents &
                        ([get_alive_index (kept)])
                   parent_set(map(old_children(j))) = .true.
                   call particles(get_alive_index (kept))%add_child &
                        (map(old_children(j)))
                end if
             end do
             particles(get_alive_index (kept))%status = PRT_RESONANT
          else
             particles(get_alive_index (kept))%status = PRT_OUTGOING
          end if
       end if
    end do
  end subroutine strip_duplicates

@ Given a subevent, reset status codes.  If the new status is beam,
incoming, or outgoing, we also make sure that the stored $p^2$ value
is equal to the on-shell mass squared.
<<Particles: particle set: TBP>>=
  procedure :: reset_status => particle_set_reset_status
<<Particles: procedures>>=
  subroutine particle_set_reset_status (particle_set, index, status)
    class(particle_set_t), intent(inout) :: particle_set
    integer, dimension(:), intent(in) :: index
    integer, intent(in) :: status
    integer :: i
    if (allocated (particle_set%prt)) then
       do i = 1, size (index)
          call particle_set%prt(index(i))%reset_status (status)
       end do
    end if
    particle_set%n_beam  = &
         count (particle_set%prt%get_status () == PRT_BEAM)
    particle_set%n_in  = &
         count (particle_set%prt%get_status () == PRT_INCOMING)
    particle_set%n_out = &
         count (particle_set%prt%get_status () == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_reset_status

@ %def particle_set_reset_status
@ Reduce a particle set to the essential entries.  The entries kept
are those with status [[INCOMING]], [[OUTGOING]] or
[[RESONANT]]. [[BEAM]] is kept if [[keep_beams]] is true. Other
entries are skipped. The correlated state matrix, if any, is also
ignored.
<<Particles: particle set: TBP>>=
  procedure :: reduce => particle_set_reduce
<<Particles: procedures>>=
  subroutine particle_set_reduce (pset_in, pset_out, keep_beams)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams
    integer, dimension(:), allocatable :: status, map
    integer :: i, j
    logical :: kb
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    allocate (status (pset_in%n_tot))    
    status = pset_in%prt%get_status ()
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    pset_out%n_vir = count (status == PRT_RESONANT)
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    map = 0
    j = 0
    if (kb) call copy_particles (PRT_BEAM)
    call copy_particles (PRT_INCOMING)
    call copy_particles (PRT_RESONANT)
    call copy_particles (PRT_OUTGOING)
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       !!! !!! triggers nagfor bug!
       !!!  call particle_set_parents (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_parents (pset_in, i)))
       !!!  call particle_set_children (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_children (pset_in, i)))
       !!! !!! workaround:
       call pset_out%prt(map(i))%set_parents &
            (pset_in%get_real_parents (i, kb))
       call pset_out%prt(map(i))%set_parents &
            (map (pset_out%prt(map(i))%parent))
       call pset_out%prt(map(i))%set_children &
            (pset_in%get_real_children (i, kb))
       call pset_out%prt(map(i))%set_children &
            (map (pset_out%prt(map(i))%child))
    end do
  contains
    subroutine copy_particles (stat)
      integer, intent(in) :: stat
      integer :: i
      do i = 1, pset_in%n_tot
         if (status(i) == stat) then
            j = j + 1
            map(i) = j
            call particle_init_particle (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles
  end subroutine particle_set_reduce

@ %def particles_set_reduce
@ Remove the beam particles and beam remnants from the particle set if the
keep beams flag is false. If keep beams is not given, the beam particles
and the beam remnants are removed.
The correlated state matrix, if any, is also ignored.
<<Particles: particle set: TBP>>=
  procedure :: apply_keep_beams => particle_set_apply_keep_beams
<<Particles: procedures>>=
  subroutine particle_set_apply_keep_beams &
       (pset_in, pset_out, keep_beams, real_parents)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams, real_parents
    integer, dimension(:), allocatable :: status, map
    integer :: i, j
    logical :: kb, rp
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    rp = .false.; if (present (real_parents)) rp = real_parents
    allocate (status (pset_in%n_tot))    
    status = particle_get_status (pset_in%prt)
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    if (kb) then
       pset_out%n_vir = count (status == PRT_VIRTUAL) + &
            count (status == PRT_RESONANT) + &
            count (status == PRT_BEAM_REMNANT)
    else 
       pset_out%n_vir = count (status == PRT_VIRTUAL) + &
            count (status == PRT_RESONANT)
    end if
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    map = 0
    j = 0
    if (kb) call copy_particles (PRT_BEAM)
    call copy_particles (PRT_INCOMING)
    if (kb) call copy_particles (PRT_BEAM_REMNANT)
    call copy_particles (PRT_RESONANT)
    call copy_particles (PRT_VIRTUAL)
    call copy_particles (PRT_OUTGOING)
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       if (rp) then
          call pset_out%prt(map(i))%set_parents &
               (map (pset_in%get_real_parents (i, kb)))
          call pset_out%prt(map(i))%set_children &
               (map (pset_in%get_real_children (i, kb)))
       else
          call pset_out%prt(map(i))%set_parents &
               (map (pset_in%prt(i)%get_parents ()))
          call pset_out%prt(map(i))%set_children &
               (map (pset_in%prt(i)%get_children ()))
       end if
    end do
  contains
    subroutine copy_particles (stat)
      integer, intent(in) :: stat
      integer :: i
      do i = 1, pset_in%n_tot
         if (status(i) == stat) then
            j = j + 1
            map(i) = j
            call particle_init_particle (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles
  end subroutine particle_set_apply_keep_beams

@ %def particles_set_apply_keep_beams
@ Transform a particle set into HEPEVT-compatible form.  In this form, for each
particle, the parents and the children are contiguous in the particle array.
Usually, this requires to clone some particles.

We do not know in advance how many particles the canonical form will have.
To be on the safe side, allocate four times the original size.
<<Particles: particle set: TBP>>=
  procedure :: to_hepevt_form => particle_set_to_hepevt_form
<<Particles: procedures>>=
  subroutine particle_set_to_hepevt_form (pset_in, pset_out)
    class(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    type :: particle_entry_t
       integer :: src = 0
       integer :: status = 0
       integer :: orig = 0
       integer :: copy = 0
    end type particle_entry_t
    type(particle_entry_t), dimension(:), allocatable :: prt
    integer, dimension(:), allocatable :: map1, map2
    integer, dimension(:), allocatable :: parent, child
    integer :: n_tot, n_parents, n_children, i, j, c, n

    n_tot = pset_in%n_tot
    allocate (prt (4 * n_tot))
    allocate (map1(4 * n_tot))
    allocate (map2(4 * n_tot))
    map1 = 0
    map2 = 0
    allocate (child (n_tot))
    allocate (parent (n_tot))
    n = 0
    do i = 1, n_tot
       if (pset_in%prt(i)%get_n_parents () == 0) then
          call append (i)
       end if
    end do
    do i = 1, n_tot
       n_children = pset_in%prt(i)%get_n_children ()
       if (n_children > 0) then
          child(1:n_children) = pset_in%prt(i)%get_children ()
          c = child(1)
          if (map1(c) == 0) then
             n_parents = pset_in%prt(c)%get_n_parents ()
             if (n_parents > 1) then
                parent(1:n_parents) = pset_in%prt(c)%get_parents ()
                if (i == parent(1) .and. &
                    any( [(map1(i)+j-1, j=1,n_parents)] /= &
                           map1(parent(1:n_parents)))) then
                   do j = 1, n_parents
                      call append (parent(j))
                   end do
                end if
             else if (map1(i) == 0) then
                call append (i)
             end if
             do j = 1, n_children
                call append (child(j))
             end do
          end if
       else if (map1(i) == 0) then
          call append (i)
       end if
    end do
    do i = n, 1, -1
       if (prt(i)%status /= PRT_OUTGOING) then
          do j = 1, i-1
             if (prt(j)%status == PRT_OUTGOING) then
                call append(prt(j)%src)
             end if
          end do
          exit
       end if
    end do
    pset_out%n_beam = count (prt(1:n)%status == PRT_BEAM)
    pset_out%n_in   = count (prt(1:n)%status == PRT_INCOMING)
    pset_out%n_vir  = count (prt(1:n)%status == PRT_RESONANT)
    pset_out%n_out  = count (prt(1:n)%status == PRT_OUTGOING)
    pset_out%n_tot = n
    allocate (pset_out%prt (n))
    do i = 1, n
       call particle_init_particle (pset_out%prt(i), pset_in%prt(prt(i)%src))
       call pset_out%prt(i)%reset_status (prt(i)%status)
       if (prt(i)%orig == 0) then
          call pset_out%prt(i)%set_parents &
               (map2 (pset_in%prt(prt(i)%src)%get_parents ()))
       else
          call pset_out%prt(i)%set_parents ([ prt(i)%orig ])
       end if
       if (prt(i)%copy == 0) then
          call pset_out%prt(i)%set_children &
               (map1 (pset_in%prt(prt(i)%src)%get_children ()))
       else
          call pset_out%prt(i)%set_children ([ prt(i)%copy ])
       end if
    end do
  contains
    subroutine append (i)
      integer, intent(in) :: i
      n = n + 1
      if (n > size (prt)) &
           call msg_bug ("Particle set transform to HEPEVT: insufficient space")
      prt(n)%src = i
      prt(n)%status = pset_in%prt(i)%get_status ()
      if (map1(i) == 0) then
         map1(i) = n
      else
         prt(map2(i))%status = PRT_VIRTUAL
         prt(map2(i))%copy = n
         prt(n)%orig = map2(i)
      end if
      map2(i) = n
    end subroutine append
  end subroutine particle_set_to_hepevt_form

@ %def particle_set_to_hepevt_form
@ This procedure aims at reconstructing the momenta of an interaction,
given a particle set.  Since the particle orderings
<<Particles: particle set: TBP>>=
  procedure :: fill_interaction => particle_set_fill_interaction
<<Particles: procedures>>=
  subroutine particle_set_fill_interaction &
       (pset, int, n_in, recover_beams, check_match, state_flv)
    class(particle_set_t), intent(in) :: pset
    type(interaction_t), intent(inout) :: int
    integer, intent(in) :: n_in
    logical, intent(in), optional :: recover_beams, check_match
    type(state_flv_content_t), intent(in), optional :: state_flv
    integer, dimension(:), allocatable :: map, pdg
    integer, dimension(:), allocatable :: i_in, i_out, p_in, p_out
    logical, dimension(:), allocatable :: i_set
    integer :: n_out, i, p
    logical :: r_beams, check
    r_beams = .false.;  if (present (recover_beams))  r_beams = recover_beams
    check = .true.;  if (present (check_match))  check = check_match
    if (check) then
       call find_hard_process_in_int  (i_in, i_out)
       call find_hard_process_in_pset (p_in, p_out)
       n_out = size (i_out)
       if (size (i_in) /= n_in)  call err_int_n_in
       if (size (p_in) /= n_in)  call err_pset_n_in
       if (size (p_out) /= n_out)  call err_pset_n_out
       call extract_hard_process_from_pset (pdg)
       call determine_map_for_hard_process (map, state_flv)
       if (.not. r_beams) then
          select case (n_in)
          case (1)
             call recover_parents (p_in(1), map)
          case (2)
             do i = 1, 2
                call recover_parents (p_in(i), map)
             end do
             do p = 1, 2
                call recover_radiation (p, map)
             end do
          end select
       end if
    else
       allocate (map (int%get_n_tot ()))
       map = [(i, i = 1, size (map))]
       r_beams = .false.
    end if
    allocate (i_set (int%get_n_tot ()), source = .false.)
    do p = 1, size (map)
       if (map(p) /= 0) then
          i_set(map(p)) = .true.
          call int%set_momentum &
               (pset%prt(p)%get_momentum (), map(p))
       end if
    end do
    if (r_beams) then
       do i = 1, n_in
          call reconstruct_beam_and_radiation (i, i_set)
       end do
    end if
    if (any (.not. i_set))  call err_map
  contains
    subroutine find_hard_process_in_pset (p_in, p_out)
      integer, dimension(:), allocatable, intent(out) :: p_in, p_out
      integer, dimension(:), allocatable :: p_status, p_idx
      integer :: n_in_p, n_out_p
      integer :: i
      allocate (p_status (pset%n_tot), p_idx (pset%n_tot))
      p_status = particle_get_status (pset%prt)
      p_idx = [(i, i = 1, pset%n_tot)]
      n_in_p = count (p_status == PRT_INCOMING)
      allocate (p_in (n_in))
      p_in = pack (p_idx, p_status == PRT_INCOMING)
      if (size (p_in) == 0)  call err_pset_hard
      i = p_in(1)
      n_out_p = particle_get_n_children (pset%prt(i))
      allocate (p_out (n_out_p))
      p_out = particle_get_children (pset%prt(i))
    end subroutine find_hard_process_in_pset
    subroutine find_hard_process_in_int (i_in, i_out)
      integer, dimension(:), allocatable, intent(out) :: i_in, i_out
      integer :: n_in_i
      integer :: i
      i = int%get_n_tot ()
      n_in_i = interaction_get_n_parents (int, i)
      if (n_in_i /= n_in)  call err_int_n_in
      allocate (i_in (n_in))
      i_in = interaction_get_parents (int, i)
      i = i_in(1)
      n_out = interaction_get_n_children (int, i)
      allocate (i_out (n_out))
      i_out = interaction_get_children (int, i)
    end subroutine find_hard_process_in_int
    subroutine extract_hard_process_from_pset (pdg)
      integer, dimension(:), allocatable, intent(out) :: pdg
      integer, dimension(:), allocatable :: pdg_p
      logical, dimension(:), allocatable :: mask_p
      allocate (pdg_p (pset%n_tot))
      pdg_p = particle_get_pdg (pset%prt)
      allocate (mask_p (pset%n_tot), source = .false.)
      mask_p (p_in) = .true.
      mask_p (p_out) = .true.
      allocate (pdg (n_in + n_out))
      pdg = pack (pdg_p, mask_p)
    end subroutine extract_hard_process_from_pset
    subroutine determine_map_for_hard_process (map, state_flv)
      integer, dimension(:), allocatable, intent(out) :: map
      type(state_flv_content_t), intent(in), optional :: state_flv
      integer, dimension(:), allocatable :: pdg_i, map_i
      integer :: n_tot
      logical, dimension(:), allocatable :: mask_i, mask_p
      logical :: success
      n_tot = int%get_n_tot ()
      allocate (map (n_tot), source = 0)
      if (present (state_flv)) then
         allocate (mask_i (n_tot), source = .false.)
         mask_i (i_in) = .true.
         mask_i (i_out) = .true.
         allocate (pdg_i (n_tot), map_i (n_tot))
         pdg_i = unpack (pdg, mask_i, 0)
         call state_flv%match (pdg_i, success, map_i)
         allocate (mask_p (pset%n_tot), source = .false.)
         mask_p (p_in) = .true.
         mask_p (p_out) = .true.
         map = unpack (pack (map_i, mask_i), mask_p, 0)
         if (.not. success)  call err_mismatch
      else
         map(p_in) = i_in
         map(p_out) = i_out
      end if
    end subroutine determine_map_for_hard_process
    recursive subroutine recover_parents (p, map)
      integer, intent(in) :: p
      integer, dimension(:), intent(inout) :: map
      integer :: i, n, n_p, q, k
      integer, dimension(:), allocatable :: i_parents, p_parents
      integer, dimension(1) :: pp
      i = map(p)
      n = interaction_get_n_parents (int, i)
      q = p
      n_p = particle_get_n_parents (pset%prt(q))
      do while (n_p == 1)
         pp = particle_get_parents (pset%prt(q))
         if (pset%prt(pp(1))%get_n_children () > 1)  exit
         q = pp(1)
         n_p = pset%prt(q)%get_n_parents ()
      end do
      if (n_p /= n)  call err_map
      allocate (i_parents (n), p_parents (n))
      i_parents = interaction_get_parents (int, i)
      p_parents = pset%prt(q)%get_parents ()
      do k = 1, n
         q = p_parents(k)
         if (map(q) == 0) then
            map(q) = i_parents(k)
            call recover_parents (q, map)
         end if
      end do
    end subroutine recover_parents
    recursive subroutine recover_radiation (p, map)
      integer, intent(in) :: p
      integer, dimension(:), intent(inout) :: map
      integer :: i, n, n_p, q, k
      integer, dimension(:), allocatable :: i_children, p_children
      if (particle_get_status (pset%prt(p)) == PRT_INCOMING)  return
      i = map(p)
      n = interaction_get_n_children (int, i)
      n_p = pset%prt(p)%get_n_children ()
      if (n_p /= n)  call err_map
      allocate (i_children (n), p_children (n))
      i_children = interaction_get_children (int, i)
      p_children = pset%prt(p)%get_children ()
      do k = 1, n
         q = p_children(k)
         if (map(q) == 0) then
            i = i_children(k)
            if (interaction_get_n_children (int, i) == 0) then
               map(q) = i
            else
               select case (n)
               case (2)
                  select case (k)
                  case (1);  map(q) = i_children(2)
                  case (2);  map(q) = i_children(1)
                  end select
               case (4)
                  select case (k)
                  case (1);  map(q) = i_children(3)
                  case (2);  map(q) = i_children(4)
                  case (3);  map(q) = i_children(1)
                  case (4);  map(q) = i_children(2)
                  end select
               case default
                  call err_radiation
               end select
            end if
         else
            call recover_radiation (q, map)
         end if
      end do
    end subroutine recover_radiation
    subroutine reconstruct_beam_and_radiation (k, i_set)
      integer, intent(in) :: k
      logical, dimension(:), intent(inout) :: i_set
      integer :: k_src, k_in, k_rad
      type(interaction_t), pointer :: int_src
      integer, dimension(2) :: i_child
      call int%find_source (k, int_src, k_src)
      call int%set_momentum (int_src%get_momentum (k_src), k)
      i_set(k) = .true.
      if (n_in == 2) then
         i_child = interaction_get_children (int, k)
         if (interaction_get_n_children (int, i_child(1)) > 0) then
            k_in = i_child(1);  k_rad = i_child(2)
         else
            k_in = i_child(2);  k_rad = i_child(1)
         end if
         if (.not. i_set(k_in))  call err_beams
         call int%set_momentum &
              (int%get_momentum (k) - int%get_momentum (k_in), k_rad)
         i_set(k_rad) = .true.
      end if
    end subroutine reconstruct_beam_and_radiation
    subroutine err_pset_hard
      call msg_fatal ("Reading particle set: no particles marked as incoming")
    end subroutine err_pset_hard
    subroutine err_int_n_in
      integer :: n
      if (allocated (i_in)) then
         n = size (i_in)
      else
         n = 0
      end if
      write (msg_buffer, "(A,I0,A,I0)") &
           "Filling hard process from particle set: expect ", n_in, &
           " incoming particle(s), found ", n
      call msg_bug
    end subroutine err_int_n_in
    subroutine err_pset_n_in
      write (msg_buffer, "(A,I0,A,I0)") &
           "Reading hard-process particle set: should contain ", n_in, &
           " incoming particle(s), found ", size (p_in)
      call msg_fatal
    end subroutine err_pset_n_in
    subroutine err_pset_n_out
      write (msg_buffer, "(A,I0,A,I0)") &
           "Reading hard-process particle set: should contain ", n_out, &
           " outgoing particle(s), found ", size (p_out)
      call msg_fatal
    end subroutine err_pset_n_out
    subroutine err_mismatch
      call pset%write ()
      call state_flv%write ()
      call msg_fatal ("Reading particle set: Flavor combination " &
           // "does not match requested process")
    end subroutine err_mismatch
    subroutine err_map
      call pset%write ()
      call int%basic_write ()
      call msg_fatal ("Reading hard-process particle set: " &
           // "Incomplete mapping from particle set to interaction")
    end subroutine err_map
    subroutine err_beams
      call pset%write ()
      call int%basic_write ()
      call msg_fatal ("Reading particle set: Beam structure " &
           // "does not match requested process")
    end subroutine err_beams
    subroutine err_radiation
      call int%basic_write ()
      call msg_bug ("Reading particle set: Interaction " &
           // "contains inconsistent radiation pattern.")
    end subroutine err_radiation
  end subroutine particle_set_fill_interaction
    
@ %def particle_set_fill_interaction
@
This procedure reconstructs an array of vertex indices from the
parent-child information in the particle entries, according to the
HepMC scheme.  For each particle, we determine which vertex it comes
from and which vertex it goes to.  We return the two arrays and the
maximum vertex index.

For each particle in the list, we first check its parents.  If for any
parent the vertex where it goes to is already known, this vertex index
is assigned as the current 'from' vertex.  Otherwise, a new index is
created, assigned as the current 'from' vertex, and as the 'to' vertex
for all parents.

Then, the analogous procedure is done for the children.

Furthermore, we assign to each vertex the vertex position from the
parent(s). We check that these vertex positions coincide, and if not
return a null vector.
<<Particles: particle set: TBP>>=
  procedure :: assign_vertices => particle_set_assign_vertices
<<Particles: procedures>>=
  subroutine particle_set_assign_vertices &
       (particle_set, v_from, v_to, n_vertices)
    class(particle_set_t), intent(in) :: particle_set
    integer, dimension(:), intent(out) :: v_from, v_to
    integer, intent(out) :: n_vertices
    integer, dimension(:), allocatable :: parent, child
    integer :: n_parents, n_children, vf, vt
    integer :: i, j, v
    v_from = 0
    v_to = 0
    vf = 0
    vt = 0
    do i = 1, particle_set%n_tot
       n_parents = particle_set%prt(i)%get_n_parents ()
       if (n_parents /= 0) then
          allocate (parent (n_parents))
          parent = particle_set%prt(i)%get_parents ()
          SCAN_PARENTS: do j = 1, size (parent)
             v = v_to(parent(j))
             if (v /= 0) then
                v_from(i) = v;  exit SCAN_PARENTS
             end if
          end do SCAN_PARENTS
          if (v_from(i) == 0) then
             vf = vf + 1;  v_from(i) = vf
             v_to(parent) = vf
          end if
          deallocate (parent)
       end if
       n_children = particle_set%prt(i)%get_n_children ()
       if (n_children /= 0) then
          allocate (child (n_children))
          child = particle_set%prt(i)%get_children ()
          SCAN_CHILDREN: do j = 1, size (child)
             v = v_from(child(j))
             if (v /= 0) then
                v_to(i) = v;  exit SCAN_CHILDREN
             end if
          end do SCAN_CHILDREN
          if (v_to(i) == 0) then
             vt = vt + 1;  v_to(i) = vt
             v_from(child) = vt
          end if
          deallocate (child)
       end if
    end do
    n_vertices = max (vf, vt)
  end subroutine particle_set_assign_vertices

@ %def particle_set_assign_vertices
@ 
\subsection{Expression interface}
This converts a [[particle_set]] object as defined here to a more
concise [[subevt]] object that can be used as the event root of an
expression.  In particular, the latter lacks virtual particles, spin
correlations and parent-child relations.

We keep beam particles, incoming partons, and outgoing partons.
Furthermore, we keep radiated particles (a.k.a.\ beam remnants) if
they have no children in the current particle set, and mark them as
outgoing particles.
<<Particles: particle set: TBP>>=
  procedure :: to_subevt => particle_set_to_subevt
<<Particles: procedures>>=
  subroutine particle_set_to_subevt (particle_set, subevt)
    class(particle_set_t), intent(in) :: particle_set
    type(subevt_t), intent(out) :: subevt
    integer :: n_tot, n_beam, n_in, n_out, n_rad
    integer :: i, k, n_active
    integer, dimension(2) :: hel
    logical :: keep
    n_tot  = particle_set_get_n_tot      (particle_set)
    n_beam = particle_set_get_n_beam     (particle_set)
    n_in   = particle_set_get_n_in       (particle_set)
    n_out  = particle_set_get_n_out      (particle_set)
    n_rad  = particle_set_get_n_remnants (particle_set)
    call subevt_init (subevt, n_beam + n_rad + n_in + n_out)
    k = 0
    do i = 1, n_tot
       associate (prt => particle_set%prt(i))
         keep = .false.
         select case (particle_get_status (prt))
         case (PRT_BEAM)
            k = k + 1
            call subevt_set_beam (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_INCOMING)
            k = k + 1
            call subevt_set_incoming (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_OUTGOING)
            k = k + 1
            call subevt_set_outgoing (subevt, k, &
                 particle_get_pdg (prt), &
                 particle_get_momentum (prt), &
                 particle_get_p2 (prt))
            keep = .true.
         case (PRT_BEAM_REMNANT)
            if (particle_get_n_children (prt) == 0) then
               k = k + 1
               call subevt_set_outgoing (subevt, k, &
                    particle_get_pdg (prt), &
                    particle_get_momentum (prt), &
                    particle_get_p2 (prt))
               keep = .true.
            end if
         end select
         if (keep) then
            if (prt%polarization == PRT_DEFINITE_HELICITY) then
               if (prt%hel%is_diagonal ()) then
                  hel = prt%hel%to_pair ()
                  call subevt_polarize (subevt, k, hel(1))
               end if
            end if
         end if
       end associate
       n_active = k
    end do
    call subevt_reset (subevt, n_active)
  end subroutine particle_set_to_subevt

@ %def particle_set_to_subevt
@ 
This replaces the [[particle\_set\%prt array]] with a given array of particles
<<Particles: particle set: TBP>>=
  procedure :: replace => particle_set_replace
<<Particles: procedures>>=
  subroutine particle_set_replace (particle_set, newprt)
    class(particle_set_t), intent(inout) :: particle_set
    type(particle_t), intent(in), dimension(:), allocatable :: newprt
    if (allocated (particle_set%prt))  deallocate (particle_set%prt)
    allocate (particle_set%prt(size (newprt)))
    particle_set%prt = newprt
    particle_set%n_tot = size (newprt)
    particle_set%n_beam = count (particle_get_status (newprt) == PRT_BEAM)
    particle_set%n_in = count (particle_get_status (newprt) == PRT_INCOMING)
    particle_set%n_out = count (particle_get_status (newprt) == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_replace

@ %def particle_set_replace
@
Eliminate numerical noise
<<Particles: public>>=
  public :: pacify
<<Particles: interfaces>>=
  interface pacify
     module procedure pacify_particle
     module procedure pacify_particle_set
  end interface pacify

<<Particles: procedures>>=
  subroutine pacify_particle (prt)
    class(particle_t), intent(inout) :: prt
    real(default) :: e
    e = epsilon (1._default) * energy (prt%p)
    call pacify (prt%p, 10 * e)
    call pacify (prt%p2, 1e4 * e)
  end subroutine pacify_particle
  
  subroutine pacify_particle_set (pset)
    class(particle_set_t), intent(inout) :: pset
    integer :: i
    do i = 1, pset%n_tot
       call pacify (pset%prt(i))
    end do
  end subroutine pacify_particle_set

@ %def pacify
@ 
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[particles_ut.f90]]>>=
<<File header>>

module particles_ut
  use unit_tests
  use particles_uti
  
<<Standard module head>>

<<Particles: public test>>

contains
  
<<Particles: test driver>>

end module particles_ut
@ %def particles_ut
@
<<[[particles_uti.f90]]>>=
<<File header>>

module particles_uti

<<Use kinds>>
  use io_units
  use unit_tests, only: assert_equal
  use constants, only: one, tiny_07
  use lorentz
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use model_data
  use subevents

  use particles

<<Standard module head>>

<<Particles: test declarations>>

contains

<<Particles: tests>>

<<Particles: test auxiliary>>

end module particles_uti
@ %def particles_ut
@ API: driver for the unit tests below.
<<Particles: public test>>=
  public :: particles_test
<<Particles: test driver>>=
  subroutine particles_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Particles: execute tests>>  
  end subroutine particles_test

@ %def particles_test  
@
Check the basic setup of the [[particle_set_t]] type:
Set up a chain of production and decay and factorize the result into
particles.  The process is $d\bar d \to Z \to q\bar q$.
<<Particles: execute tests>>=
  call test (particles_1, "particles_1", &
       "check particle_set routines", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_1
<<Particles: tests>>=  
  subroutine particles_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(3) :: flv
    type(color_t), dimension(3) :: col
    type(helicity_t), dimension(3) :: hel
    type(quantum_numbers_t), dimension(3) :: qn
    type(vector4_t), dimension(3) :: p
    type(interaction_t), target :: int1, int2
    type(quantum_numbers_mask_t) :: qn_mask_conn
    type(evaluator_t), target :: eval
    type(interaction_t) :: int
    type(particle_set_t) :: particle_set1, particle_set2
    type(particle_set_t) :: particle_set3, particle_set4
    type(subevt_t) :: subevt
    logical :: ok
    integer :: unit, iostat      

    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: test particle_set routines"
    write (u, "(A)")      

    write (u, "(A)")  "* Reading model file"

    call model%init_sm_test ()

    write (u, "(A)")
    write (u, "(A)")  "* Initializing production process"

    call int1%basic_init (2, 0, 1, set_relations=.true.)
    call flv%init ([1, -1, 23], model)
    call col%init_col_acl ([0, 0, 0], [0, 0, 0])
    call hel(3)%init (1, 1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.25_default, 0._default))
    call hel(3)%init (1,-1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0._default, 0.25_default))
    call hel(3)%init (-1, 1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0._default,-0.25_default))
    call hel(3)%init (-1,-1)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.25_default, 0._default))
    call hel(3)%init (0, 0)
    call qn%init (flv, col, hel)
    call int1%add_state (qn, value=(0.5_default, 0._default))
    call int1%freeze ()
    p(1) = vector4_moving (45._default, 45._default, 3)
    p(2) = vector4_moving (45._default,-45._default, 3)
    p(3) = p(1) + p(2)
    call int1%set_momenta (p)

    write (u, "(A)")
    write (u, "(A)")  "* Setup decay process"

    call int2%basic_init (1, 0, 2, set_relations=.true.)
    call flv%init ([23, 1, -1], model)
    call col%init_col_acl ([0, 501, 0], [0, 0, 501])
    call hel%init ([1, 1, 1], [1, 1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(1._default, 0._default))
    call hel%init ([1, 1, 1], [-1,-1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0._default, 0.1_default))
    call hel%init ([-1,-1,-1], [1, 1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0._default,-0.1_default))
    call hel%init ([-1,-1,-1], [-1,-1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(1._default, 0._default))
    call hel%init ([0, 1,-1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(4._default, 0._default))
    call hel%init ([0,-1, 1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(2._default, 0._default))
    call hel%init ([0, 1,-1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(2._default, 0._default))
    call hel%init ([0,-1, 1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(4._default, 0._default))
    call flv%init ([23, 2, -2], model)
    call hel%init ([0, 1,-1], [0, 1,-1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0.5_default, 0._default))
    call hel%init ([0,-1, 1], [0,-1, 1])
    call qn%init (flv, col, hel)
    call int2%add_state (qn, value=(0.5_default, 0._default))
    call int2%freeze ()
    p(2) = vector4_moving (45._default, 45._default, 2)
    p(3) = vector4_moving (45._default,-45._default, 2)
    call int2%set_momenta (p)
    call int2%set_source_link (1, int1, 3)
    call int1%basic_write (u)
    call int2%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Concatenate production and decay"

    call eval%init_product (int1, int2, qn_mask_conn, &
         connections_are_resonant=.true.)
    call eval%receive_momenta ()
    call eval%evaluate ()
    call eval%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, polarized)"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set1%init &
         (ok, int, int, FM_FACTOR_HELICITY, &
          [0.2_default, 0.2_default], .false., .true.)
    call particle_set1%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (in/out only, selected helicity)"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set2%init &
         (ok, int, int, FM_SELECT_HELICITY, &
          [0.9_default, 0.9_default], .false., .false.)
    call particle_set2%write (u)
    call particle_set2%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, selected helicity)"
    write (u, "(A)") 
    
    int = eval%interaction_t
    call particle_set2%init &
         (ok, int, int, FM_SELECT_HELICITY, &
          [0.7_default, 0.7_default], .false., .true.)
    call particle_set2%write (u)      
        
    write (u, "(A)")
    write (u, "(A)")  &
         "* Factorize (complete, polarized, correlated); write and read again"
    write (u, "(A)")
    
    int = eval%interaction_t
    call particle_set3%init &
         (ok, int, int, FM_FACTOR_HELICITY, &
          [0.7_default, 0.7_default], .true., .true.)
    call particle_set3%write (u)

    unit = free_unit ()
    open (unit, action="readwrite", form="unformatted", status="scratch")
    call particle_set3%write_raw (unit)
    rewind (unit)
    call particle_set4%read_raw (unit, iostat=iostat)
    call particle_set4%set_model (model)
    close (unit)
    
    write (u, "(A)")
    write (u, "(A)")  "* Result from reading"
    write (u, "(A)")

    call particle_set4%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transform to a subevt object"
    write (u, "(A)")
    
    call particle_set4%to_subevt (subevt)
    call subevt_write (subevt, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call particle_set1%final ()
    call particle_set2%final ()
    call particle_set3%final ()
    call particle_set4%final ()
    call eval%final ()
    call int1%final ()
    call int2%final ()

    call model%final ()
       
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_1"        
    
  end subroutine particles_1

@ %def particles_1
@ 
Reconstruct a hard interaction from a particle set.
<<Particles: execute tests>>=
  call test (particles_2, "particles_2", &
       "reconstruct hard interaction", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_2
<<Particles: tests>>=  
  subroutine particles_2 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct simple interaction"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 3 interaction"
    write (u, "(A)")  "    + incoming partons marked as virtual"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 2, 3)
    do i = 1, 2
       do j = 3, 5
          call int%relate (i, j)
       end do
    end do

    allocate (qn (5))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [11, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 2
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 5
    allocate (pset%prt (pset%n_tot))
    do i = 1, 2
       call pset%prt(i)%reset_status (PRT_INCOMING)
       call pset%prt(i)%set_children ([3,4,5])
    end do
    do i = 3, 5
       call pset%prt(i)%reset_status (PRT_OUTGOING)
       call pset%prt(i)%set_parents ([1,2])
    end do
    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))

    allocate (flv (5))
    call flv%init ([11,12,5,4,3])
    do i = 1, 5
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_2"

  end subroutine particles_2
  
@ %def particles_2
@ 
Reconstruct an interaction with beam structure, e.g., a hadronic
interaction, from a particle set.
<<Particles: execute tests>>=
  call test (particles_3, "particles_3", &
       "reconstruct interaction with beam structure", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_3
<<Particles: tests>>=  
  subroutine particles_3 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct simple interaction"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")

    call create_test_particle_set_1 (pset)

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_3"

  end subroutine particles_3
  
@ %def particles_3
@
<<Particles: test auxiliary>>=
  subroutine create_test_particle_set_1 (pset)
    type(particle_set_t), intent(out) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 2
    pset%n_out  = 3
    pset%n_tot  = 9

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_INCOMING)
    call pset%prt(4)%reset_status (PRT_INCOMING)
    call pset%prt(5)%reset_status (PRT_BEAM_REMNANT)
    call pset%prt(6)%reset_status (PRT_BEAM_REMNANT)
    call pset%prt(7)%reset_status (PRT_OUTGOING)
    call pset%prt(8)%reset_status (PRT_OUTGOING)
    call pset%prt(9)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,5])
    call pset%prt(2)%set_children ([4,6])
    call pset%prt(3)%set_children ([7,8,9])
    call pset%prt(4)%set_children ([7,8,9])

    call pset%prt(3)%set_parents ([1])
    call pset%prt(4)%set_parents ([2])
    call pset%prt(5)%set_parents ([1])
    call pset%prt(6)%set_parents ([2])
    call pset%prt(7)%set_parents ([3,4])
    call pset%prt(8)%set_parents ([3,4])
    call pset%prt(9)%set_parents ([3,4])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(9)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (9))
    call flv%init ([2011, 2012, 11, 12, 91, 92, 3, 4, 5])
    do i = 1, 9
       call pset%prt(i)%set_flavor (flv(i))
    end do
  end subroutine create_test_particle_set_1

@ %def create_test_particle_set_1

@ 
Reconstruct an interaction with beam structure, e.g., a hadronic
interaction, from a particle set that is missing the beam information.
<<Particles: execute tests>>=
  call test (particles_4, "particles_4", &
       "reconstruct interaction with missing beams", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_4
<<Particles: tests>>=  
  subroutine particles_4 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(interaction_t), target :: int_beams
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct beams"
    write (u, "(A)")      

    call reset_interaction_counter ()

    write (u, "(A)")  "* Set up an interaction that contains beams only"
    write (u, "(A)")      

    call int_beams%basic_init (0, 0, 2)
    call int_beams%set_momentum (vector4_at_rest (1._default), 1)
    call int_beams%set_momentum (vector4_at_rest (2._default), 2)
    allocate (qn (2))
    call int_beams%add_state (qn)
    call int_beams%freeze ()
    
    call int_beams%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do
    do i = 1, 2
       call int%set_source_link (i, int_beams, i)
    end do

    deallocate (qn)
    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 2
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 5

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_INCOMING)
    call pset%prt(2)%reset_status (PRT_INCOMING)
    call pset%prt(3)%reset_status (PRT_OUTGOING)
    call pset%prt(4)%reset_status (PRT_OUTGOING)
    call pset%prt(5)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4,5])
    call pset%prt(2)%set_children ([3,4,5])

    call pset%prt(3)%set_parents ([1,2])
    call pset%prt(4)%set_parents ([1,2])
    call pset%prt(5)%set_parents ([1,2])

    call pset%prt(1)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (5._default))

    allocate (flv (5))
    call flv%init ([11, 12, 3, 4, 5])
    do i = 1, 5
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv, &
         recover_beams = .true.)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_4"

  end subroutine particles_4
  
@ %def particles_4
@ 
Reconstruct an interaction with beam structure and cloned particles
(radiated particles repeated in the event record, to maintain some
canonical ordering).
<<Particles: execute tests>>=
  call test (particles_5, "particles_5", &
       "reconstruct interaction with beams and duplicate entries", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_5
<<Particles: tests>>=  
  subroutine particles_5 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct event with duplicate entries"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    call int%relate (1, 3)
    call int%relate (1, 4)
    call int%relate (2, 5)
    call int%relate (2, 6)
    do i = 4, 6, 2
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [2011, 2012, 91, 11, 92, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 4
    pset%n_out  = 5
    pset%n_tot  = 13

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_VIRTUAL)
    call pset%prt(4)%reset_status (PRT_VIRTUAL)
    call pset%prt(5)%reset_status (PRT_VIRTUAL)
    call pset%prt(6)%reset_status (PRT_VIRTUAL)
    call pset%prt(7)%reset_status (PRT_INCOMING)
    call pset%prt(8)%reset_status (PRT_INCOMING)
    call pset%prt( 9)%reset_status (PRT_OUTGOING)
    call pset%prt(10)%reset_status (PRT_OUTGOING)
    call pset%prt(11)%reset_status (PRT_OUTGOING)
    call pset%prt(12)%reset_status (PRT_OUTGOING)
    call pset%prt(13)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4])
    call pset%prt(2)%set_children ([5,6])
    call pset%prt(3)%set_children ([ 7])
    call pset%prt(4)%set_children ([ 9])
    call pset%prt(5)%set_children ([ 8])
    call pset%prt(6)%set_children ([10])
    call pset%prt(7)%set_children ([11,12,13])
    call pset%prt(8)%set_children ([11,12,13])

    call pset%prt(3)%set_parents ([1])
    call pset%prt(4)%set_parents ([1])
    call pset%prt(5)%set_parents ([2])
    call pset%prt(6)%set_parents ([2])
    call pset%prt( 7)%set_parents ([3])
    call pset%prt( 8)%set_parents ([5])
    call pset%prt( 9)%set_parents ([4])
    call pset%prt(10)%set_parents ([6])
    call pset%prt(11)%set_parents ([7,8])
    call pset%prt(12)%set_parents ([7,8])
    call pset%prt(13)%set_parents ([7,8])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (6._default))
    call pset%prt( 9)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(10)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(11)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(12)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(13)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (13))
    call flv%init ([2011, 2012, 11, 91, 12, 92, 11, 12, 91, 92, 3, 4, 5])
    do i = 1, 13
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_5"

  end subroutine particles_5
  
@ %def particles_5
@ 
Reconstruct an interaction with pair spectrum, e.g., beamstrahlung from a
particle set. 
<<Particles: execute tests>>=
  call test (particles_6, "particles_6", &
       "reconstruct interaction with pair spectrum", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_6
<<Particles: tests>>=  
  subroutine particles_6 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct interaction with pair spectrum"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 2 -> 2 -> 3 interaction with radiation"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 6, 3)
    do i = 1, 2
       do j = 3, 6
          call int%relate (i, j)
       end do
    end do
    do i = 5, 6
       do j = 7, 9
          call int%relate (i, j)
       end do
    end do

    allocate (qn (9))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .false., .false., .false., .false., .false., &
         .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [1011, 1012, 21, 22, 11, 12, 3, 4, 5], &
         map = [1, 2, 3, 4, 5, 6, 7, 8, 9])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 2
    pset%n_in   = 2
    pset%n_vir  = 2
    pset%n_out  = 3
    pset%n_tot  = 9

    allocate (pset%prt (pset%n_tot))
    call pset%prt(1)%reset_status (PRT_BEAM)
    call pset%prt(2)%reset_status (PRT_BEAM)
    call pset%prt(3)%reset_status (PRT_INCOMING)
    call pset%prt(4)%reset_status (PRT_INCOMING)
    call pset%prt(5)%reset_status (PRT_OUTGOING)
    call pset%prt(6)%reset_status (PRT_OUTGOING)
    call pset%prt(7)%reset_status (PRT_OUTGOING)
    call pset%prt(8)%reset_status (PRT_OUTGOING)
    call pset%prt(9)%reset_status (PRT_OUTGOING)

    call pset%prt(1)%set_children ([3,4,5,6])
    call pset%prt(2)%set_children ([3,4,5,6])
    call pset%prt(3)%set_children ([7,8,9])
    call pset%prt(4)%set_children ([7,8,9])

    call pset%prt(3)%set_parents ([1,2])
    call pset%prt(4)%set_parents ([1,2])
    call pset%prt(5)%set_parents ([1,2])
    call pset%prt(6)%set_parents ([1,2])
    call pset%prt(7)%set_parents ([3,4])
    call pset%prt(8)%set_parents ([3,4])
    call pset%prt(9)%set_parents ([3,4])

    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (5._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (6._default))
    call pset%prt(5)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(6)%set_momentum (vector4_at_rest (4._default))
    call pset%prt(7)%set_momentum (vector4_at_rest (7._default))
    call pset%prt(8)%set_momentum (vector4_at_rest (8._default))
    call pset%prt(9)%set_momentum (vector4_at_rest (9._default))

    allocate (flv (9))
    call flv%init ([1011, 1012, 11, 12, 21, 22, 3, 4, 5])
    do i = 1, 9
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)
 
    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 2, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_6"

  end subroutine particles_6
  
@ %def particles_6
@ 
Reconstruct a hard decay interaction from a shuffled particle set.
<<Particles: execute tests>>=
  call test (particles_7, "particles_7", &
       "reconstruct decay interaction with reordering", &
       u, results)
<<Particles: test declarations>>= 
  public :: particles_7
<<Particles: tests>>=  
  subroutine particles_7 (u)

    integer, intent(in) :: u
    type(interaction_t) :: int
    type(state_flv_content_t) :: state_flv
    type(particle_set_t) :: pset
    type(flavor_t), dimension(:), allocatable :: flv
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, j
    
    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: reconstruct decay interaction with reordering"
    write (u, "(A)")      

    write (u, "(A)")  "* Set up a 1 -> 3 interaction"
    write (u, "(A)")  "    + no quantum numbers"
    write (u, "(A)")      

    call reset_interaction_counter ()
    call int%basic_init (0, 1, 3)
    do j = 2, 4
       call int%relate (1, j)
    end do

    allocate (qn (4))
    call int%add_state (qn)
    call int%freeze ()

    call int%basic_write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually set up a flavor-content record"
    write (u, "(A)")  "*   assumed interaction: 6 12 5 -11"
    write (u, "(A)")      

    call state_flv%init (1, &
         mask = [.false., .true., .true., .true.])
    call state_flv%set_entry (1, &
         pdg = [6, 5, -11, 12], &
         map = [1, 4, 2, 3])
    
    call state_flv%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "* Manually create a matching particle set"
    write (u, "(A)")      

    pset%n_beam = 0
    pset%n_in   = 1
    pset%n_vir  = 0
    pset%n_out  = 3
    pset%n_tot  = 4
    allocate (pset%prt (pset%n_tot))
    do i = 1, 1
       call pset%prt(i)%reset_status (PRT_INCOMING)
       call pset%prt(i)%set_children ([2,3,4])
    end do
    do i = 2, 4
       call pset%prt(i)%reset_status (PRT_OUTGOING)
       call pset%prt(i)%set_parents ([1])
    end do
    call pset%prt(1)%set_momentum (vector4_at_rest (1._default))
    call pset%prt(2)%set_momentum (vector4_at_rest (3._default))
    call pset%prt(3)%set_momentum (vector4_at_rest (2._default))
    call pset%prt(4)%set_momentum (vector4_at_rest (4._default))

    allocate (flv (5))
    call flv%init ([6,5,12,-11])
    do i = 1, 4
       call pset%prt(i)%set_flavor (flv(i))
    end do

    call pset%write (u)

    write (u, "(A)")      
    write (u, "(A)")  "*   Fill interaction from particle set"
    write (u, "(A)")

    call pset%fill_interaction (int, 1, state_flv=state_flv)
    call int%basic_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call int%final ()
    call pset%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_7"

  end subroutine particles_7
  
@ %def particles_7
@
<<Particles: execute tests>>=
  call test (particles_8, "particles_8", &
            "Test functions on particle sets", u, results)
<<Particles: test declarations>>= 
  public :: particles_8
<<Particles: tests>>=
  subroutine particles_8 (u)
    integer, intent(in) :: u
    type(particle_set_t) :: particle_set
    type(particle_t), dimension(:), allocatable :: particles
    integer, allocatable, dimension(:) :: children, parents
    integer :: n_particles, i
    write (u, "(A)")  "* Test output: particles_8"
    write (u, "(A)")  "*   Purpose: Test functions on particle sets"
    write (u, "(A)")

    call create_test_particle_set_1 (particle_set)
    call particle_set%write (u)
    call assert_equal (u, particle_set%n_tot, 9)
    call assert_equal (u, particle_set%n_beam, 2)
    children = particle_set%prt(3)%get_children()
    call assert_equal (u, particle_set%prt(children(1))%get_pdg (), 3)
    call assert_equal (u, size (particle_set%prt(1)%get_children ()), 2)
    call assert_equal (u, size (particle_set%prt(2)%get_children ()), 2)

    call particle_set%without_hadronic_remnants &
         (particles, n_particles, 3)
    call particle_set%replace (particles)
    write (u, "(A)")
    call particle_set%write (u)

    call assert_equal (u, n_particles, 7)
    call assert_equal (u, size(particles), 10)
    call assert_equal (u, particle_set%n_tot, 10)
    call assert_equal (u, particle_set%n_beam, 2)
    do i = 3, 4
       children = particle_set%prt(i)%get_children()
       call assert_equal (u, particle_set%prt(children(1))%get_pdg (), 3)
       children = particle_set%prt(i)%get_children()
       call assert_equal (u, particle_set%prt(children(2))%get_pdg (), 4)
       children = particle_set%prt(i)%get_children()
       call assert_equal (u, particle_set%prt(children(3))%get_pdg (), 5)
    end do
    do i = 5, 7
       parents = particle_set%prt(i)%get_parents()
       call assert_equal (u, particle_set%prt(parents(1))%get_pdg (), 11)
       call assert_equal (u, particle_set%prt(parents(2))%get_pdg (), 12)
    end do
    call assert_equal (u, size (particle_set%prt(1)%get_children ()), &
         1, "get children of 1")
    call assert_equal (u, size (particle_set%prt(2)%get_children ()), &
         1, "get children of 2")

    call assert_equal(u, particle_set%find_particle &
         (particle_set%prt(1)%get_pdg (), particle_set%prt(1)%p), &
         1, "find 1st particle")
    call assert_equal(u, particle_set%find_particle &
         (particle_set%prt(2)%get_pdg (), particle_set%prt(2)%p * &
          (one + tiny_07), rel_smallness=1.0E-6_default), &
         2, "find 2nd particle fuzzy")

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_8"
  end subroutine particles_8

@ %def particles_8
