%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: particle objects
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\chapter{Particles}

This chapter collects modules that implement particle objects, for use in
event records.

While within interactions, all correlations are
manifest, a particle array is derived by selecting a particular
quantum number set.  This involves tracing over all other particles,
as far as polarization is concerned.  Thus, a particle has definite
flavor, color, and a single-particle density matrix for polarization.
\begin{description}
\item[polarizations]
  The polarization object is based on a [[state_matrix_t]] object.  It
  describes the spin density matrix of a particle.
\item[hepmc\_interface]
  Access particle objects of the HepMC package.  Functional only if this
  package is linked.
\item[lcio\_interface]
  Access objects of the LCIO package.  Functional only if this
  package is linked.  
\item[particles]
  Particle objects and particle lists, as the base of event records.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Polarization}
Particle polarization is determined by a particular quantum state
which has just helicity information.  For defining polarizations, we
adopt the phase convention for a spin-1/2 particle that
\begin{equation}
  \rho = \tfrac12(1 + \vec\alpha\cdot\vec\sigma)
\end{equation}
with the polarization axis $\vec\alpha$.  Using this, we define
\begin{enumerate}
\item Trivial polarization: $\vec\alpha=0$. [This is unpolarized, but
  distinct from the particular undefined polarization matrix which has
  the same meaning.]
\item Circular polarization: $\vec\alpha$ points in $\pm z$ direction.
\item Transversal polarization: $\vec\alpha$ points orthogonal to the
  $z$ direction, with a phase $\phi$ that is $0$ for the $x$ axis, and
  $\pi/2=90^\circ$ for the $y$ axis.  For antiparticles, the phase
  switches sign, corresponding to complex conjugation.
\item Axis polarization, where we explicitly give $\vec\alpha$.
\end{enumerate}
For higher spin, we retain this definition, but apply it to the two
components with maximum and minimum weight.  For massless particles,
this is sufficient.  For massive particles, we add the possibilities:
\begin{enumerate}\setcounter{enumi}{4}
\item Longitudinal polarization: Only the 0-component is set.  This is
  possible only for bosons.
\item Diagonal polarization: Explicitly specify all components in the
  helicity basis.
\end{enumerate}
Obviously, this does not exhaust the possible density matrices for
higher spin, but it should cover all practical applications.
<<[[polarizations.f90]]>>=
<<File header>>

module polarizations

<<Use kinds>>
<<Use strings>>
  use constants, only: imago
  use io_units
  use format_defs, only: FMT_12, FMT_19
  use unit_tests
  use diagnostics
  use physics_defs, only: SCALAR
  use lorentz
  use model_data
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
!  use models

<<Standard module head>>

<<Polarizations: public>>

<<Polarizations: types>>

<<Polarizations: interfaces>>

contains

<<Polarizations: procedures>>

<<Polarizations: tests>>

end module polarizations
@ %def polarizations
@ 
\subsection{The polarization type}
This is not an extension, but rather a restriction of the quantum
state.  Flavor and color are ignored, there is just a one-particle
helicity density matrix.
<<Polarizations: public>>=
  public :: polarization_t
<<Polarizations: types>>=
  type :: polarization_t
     logical :: polarized = .false.
     integer :: spin_type = 0
     integer :: multiplicity = 0
     type(state_matrix_t) :: state
  end type polarization_t

@ %def polarization_t
@ 
\subsection{Basic initializer and finalizer}
We need the particle flavor for determining the allowed helicity
values.  The density matrix is not set, but prepared to be filled
later.  This is private.
<<Polarizations: procedures>>=
  elemental subroutine polarization_init (pol, flv)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    pol%spin_type = flavor_get_spin_type (flv)
    pol%multiplicity = flavor_get_multiplicity (flv)
    call state_matrix_init (pol%state, store_values = .true.)
  end subroutine polarization_init
    
@ %def polarization_init
@ The finalizer has to be public.  The quantum state contains memory
allocated to pointers.
<<Polarizations: public>>=
  public :: polarization_final
<<Polarizations: procedures>>=
  elemental subroutine polarization_final (pol)
    type(polarization_t), intent(inout) :: pol
    call state_matrix_final (pol%state)
  end subroutine polarization_final

@ %def polarization_final
@ 
\subsection{I/O}
<<Polarizations: public>>=
  public :: polarization_write
<<Polarizations: procedures>>=
  subroutine polarization_write (pol, unit)
    type(polarization_t), intent(in) :: pol
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A,I1,A,I1,A)")  &
         "Polarization: [spin_type = ", pol%spin_type, &
         ", mult = ", pol%multiplicity, "]"
    call state_matrix_write (pol%state, unit=unit)
  end subroutine polarization_write

@ %def polarization_write
@ Defined assignment: deep copy
<<Polarizations: public>>=
  public :: assignment(=)
<<Polarizations: interfaces>>=
  interface assignment(=)
     module procedure polarization_assign
  end interface

<<Polarizations: procedures>>=
  subroutine polarization_assign (pol_out, pol_in)
    type(polarization_t), intent(out) :: pol_out
    type(polarization_t), intent(in) :: pol_in
    pol_out%polarized = pol_in%polarized
    pol_out%spin_type = pol_in%spin_type
    pol_out%multiplicity = pol_in%multiplicity
    pol_out%state = pol_in%state
  end subroutine polarization_assign

@ %def polarization_assign
@ Binary I/O.

Note: currently disabled; state matrix raw I/O questionable.
<<Polarizations: public>>=
  public :: polarization_write_raw
  public :: polarization_read_raw
<<Polarizations: procedures>>=
  subroutine polarization_write_raw (pol, u)
    type(polarization_t), intent(in) :: pol
    integer, intent(in) :: u
    write (u) pol%polarized
    write (u) pol%spin_type
    write (u) pol%multiplicity
    if (state_matrix_is_defined (pol%state)) then
       call msg_bug ("Write polarization (raw): nontrivial state matrix not supported yet")
    else
       call state_matrix_write_raw (pol%state, u)
    end if
  end subroutine polarization_write_raw

  subroutine polarization_read_raw (pol, u, iostat)
    type(polarization_t), intent(out) :: pol
    integer, intent(in) :: u
    integer, intent(out), optional :: iostat
    read (u, iostat=iostat) pol%polarized
    read (u, iostat=iostat) pol%spin_type
    read (u, iostat=iostat) pol%multiplicity
    call state_matrix_read_raw (pol%state, u, iostat=iostat)
  end subroutine polarization_read_raw

@ %def polarization_read_raw
@ 
\subsection{Accessing contents}
Return true if the particle is polarized.  This is the case if the
first (and only) entry in the quantum state has undefined helicity.
<<Polarizations: public>>=
  public :: polarization_is_polarized
<<Polarizations: procedures>>=
  elemental function polarization_is_polarized (pol) result (polarized)
    logical :: polarized
    type(polarization_t), intent(in) :: pol
    polarized = pol%polarized
  end function polarization_is_polarized

@ %def polarization_is_polarized
@ Return true if the polarization is diagonal, i.e., all entries in
the density matrix are diagonal.
<<Polarizations: public>>=
  public :: polarization_is_diagonal
<<Polarizations: interfaces>>=
  interface polarization_is_diagonal
     module procedure polarization_is_diagonal0
     module procedure polarization_is_diagonal1
  end interface

<<Polarizations: procedures>>=
  function polarization_is_diagonal0 (pol) result (diagonal)
    logical :: diagonal
    type(polarization_t), intent(in) :: pol
    type(state_iterator_t) :: it
    diagonal = .true.
    call state_iterator_init (it, pol%state)
    do while (state_iterator_is_valid (it))
       diagonal = all (quantum_numbers_are_diagonal &
            (state_iterator_get_quantum_numbers (it)))
       if (.not. diagonal) exit
       call state_iterator_advance (it)
    end do
  end function polarization_is_diagonal0

  function polarization_is_diagonal1 (pol) result (diagonal)
    type(polarization_t), dimension(:), intent(in) :: pol
    logical, dimension(size(pol)) :: diagonal
    integer :: i
    do i = 1, size (pol)
       diagonal(i) = polarization_is_diagonal0 (pol(i))
    end do
  end function polarization_is_diagonal1

@ %def polarization_is_diagonal
@ 
\subsection{Initialization from state matrix}
Here, the state matrix is already known (but not necessarily
normalized).  The result will be either unpolarized, or a normalized
spin density matrix.
<<Polarizations: public>>=
  public :: polarization_init_state_matrix
<<Polarizations: procedures>>=
  subroutine polarization_init_state_matrix (pol, state)
    type(polarization_t), intent(out) :: pol
    type(state_matrix_t), intent(in), target :: state
    type(state_iterator_t) :: it
    type(flavor_t) :: flv
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value, t
    call state_iterator_init (it, state)
    flv = state_iterator_get_flavor (it, 1)
    hel = state_iterator_get_helicity (it, 1)
    if (helicity_is_defined (hel)) then
       call polarization_init (pol, flv)
       pol%polarized = .true.
       t = 0
       do while (state_iterator_is_valid (it))
          hel = state_iterator_get_helicity (it, 1)
          call quantum_numbers_init (qn(1), hel)
          value = state_iterator_get_matrix_element (it)
          call state_matrix_add_state (pol%state, qn, value=value)
          if (helicity_is_diagonal (hel))  t = t + value
          call state_iterator_advance (it)
       end do
       call state_matrix_freeze (pol%state)
       if (t /= 0)  call state_matrix_renormalize (pol%state, 1._default / t)
    else
       call polarization_init_unpolarized (pol, flv)
    end if
  end subroutine polarization_init_state_matrix

@ %def polarization_init_state_matrix
@
\subsection{Specific initializers}
Unpolarized particle, no helicity labels in the density matrix.  The
value is specified as $1/N$, where $N$ is the multiplicity.

Exception: for left-handed or right-handed particles (neutrinos),
polarization is always circular with fraction unity.
<<Polarizations: public>>=
  public :: polarization_init_unpolarized
<<Polarizations: procedures>>=
  subroutine polarization_init_unpolarized (pol, flv)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    if (flavor_is_left_handed (flv)) then
       call polarization_init_circular (pol, flv, -1._default)
    else if (flavor_is_right_handed (flv)) then
       call polarization_init_circular (pol, flv, 1._default)
    else
       call polarization_init (pol, flv)
       value = 1._default / flavor_get_multiplicity (flv)
       call state_matrix_add_state (pol%state, qn)
       call state_matrix_freeze (pol%state)
       call state_matrix_set_matrix_element (pol%state, value)
    end if
  end subroutine polarization_init_unpolarized
    
@ %def polarization_init_unpolarized
@ Unpolarized particle, but explicit density matrix with helicity
states allocated according to given flavor.  Note that fermions have
even spin type, bosons odd.  The spin density matrix entries are
scaled by [[fraction]].  This is used for initializing other
polarizations:
\begin{equation*}
  \rho(f) = 
  \frac{|f|}{N}\mathbf{1}.
\end{equation*}
<<Polarizations: public>>=
  public :: polarization_init_trivial
<<Polarizations: procedures>>=
  subroutine polarization_init_trivial (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in), optional :: fraction
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    integer :: h, hmax
    logical :: fermion
    complex(default) :: value
    call polarization_init (pol, flv)
    pol%polarized = .true.
    if (present (fraction)) then
       value = fraction / pol%multiplicity
    else
       value = 1._default / pol%multiplicity
    end if
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    select case (pol%multiplicity)
    case (1)
       if (flavor_is_left_handed (flv)) then
          call helicity_init (hel, -hmax)
       else if (flavor_is_right_handed (flv)) then
          call helicity_init (hel, hmax)
       else
          call helicity_init (hel, 0)
       end if
       call quantum_numbers_init (qn(1), hel)
       call state_matrix_add_state (pol%state, qn)
    case (2)
       do h = -hmax, hmax, 2*hmax
          call helicity_init (hel, h)
          call quantum_numbers_init (qn(1), hel)
          call state_matrix_add_state (pol%state, qn)
       end do
    case default
       do h = -hmax, hmax
          if (fermion .and. h == 0)  cycle
          call helicity_init (hel, h)
          call quantum_numbers_init (qn(1), hel)
          call state_matrix_add_state (pol%state, qn)
       end do
    end select
    call state_matrix_freeze (pol%state)
    call state_matrix_set_matrix_element (pol%state, value)
  end subroutine polarization_init_trivial

@ %def polarization_init_trivial
@ The following three modes are useful mainly for spin-1/2 particle
and massless particles of any nonzero spin.  Only the highest-weight
components are filled.

Circular polarization: The density matrix of the two highest-weight
states is
\begin{equation*}
  \rho(f) = 
  \frac{1-|f|}{2}\mathbf{1} +
  |f| \times
  \begin{cases}
    \begin{pmatrix} 1 & 0 \\ 0 & 0 \end{pmatrix}, & f > 0; \\[6pt]
    \begin{pmatrix} 0 & 0 \\ 0 & 1 \end{pmatrix}, & f < 0,
  \end{cases}
\end{equation*}
If the polarization fraction $|f|$ is unity, we need only one entry in the
density matrix.
<<Polarizations: public>>=
  public :: polarization_init_circular
<<Polarizations: procedures>>=
  subroutine polarization_init_circular (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: fraction
    type(helicity_t), dimension(2) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    integer :: hmax
    call polarization_init (pol, flv)
    pol%polarized = .true.
    hmax = pol%spin_type / 2
    call helicity_init (hel(1), hmax)
    call helicity_init (hel(2),-hmax)
    if (abs (fraction) /= 1) then
       value = (1 + fraction) / 2
       call quantum_numbers_init (qn(1), hel(1))
       call state_matrix_add_state (pol%state, qn, value=value)
       value = (1 - fraction) / 2
       call quantum_numbers_init (qn(1), hel(2))
       call state_matrix_add_state (pol%state, qn, value=value)
    else
       value = abs (fraction)
       if (fraction > 0) then
          call quantum_numbers_init (qn(1), hel(1))
       else
          call quantum_numbers_init (qn(1), hel(2))
       end if
       call state_matrix_add_state (pol%state, qn, value=value)
    end if
    call state_matrix_freeze (pol%state)
  end subroutine polarization_init_circular

@ %def polarization_init_circular
@ Transversal polarization is analogous to circular, but we get a
density matrix
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1-|f|}{2}\mathbf{1}
  + \frac{|f|}{2}  \begin{pmatrix} 1 & e^{-i\phi} \\ e^{i\phi} & 1
  \end{pmatrix}.
\end{equation*}
The phase is $\phi=0$ for the $x$-axis, $\phi=90^\circ$ for the $y$
axis as polarization vector.  For an antiparticle, the phase switches
sign, and for $f<0$, the off-diagonal elements switch sign.  
<<Polarizations: public>>=
  public :: polarization_init_transversal
<<Polarizations: procedures>>=
  subroutine polarization_init_transversal (pol, flv, phi, fraction)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: phi, fraction
    call polarization_init_axis &
         (pol, flv, fraction * [ cos (phi), sin (phi), 0._default])
  end subroutine polarization_init_transversal

@ %def polarization_init_transversal
@ For axis polarization, we again set only the entries with maximum weight.
\begin{equation*}
  \rho(f,\phi) = 
  \frac{1}{2} \begin{pmatrix} 
                 1 + \alpha_3 & \alpha_1 - i\alpha_2 \\ 
                 \alpha_1 + i\alpha_2 & 1 - \alpha_3 
              \end{pmatrix}.
\end{equation*}
For an antiparticle, $\alpha_2$ switches sign (complex conjugate).
<<Polarizations: public>>=
  public :: polarization_init_axis
<<Polarizations: procedures>>=
  subroutine polarization_init_axis (pol, flv, alpha)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(3), intent(in) :: alpha
    type(quantum_numbers_t), dimension(1) :: qn
    type(helicity_t), dimension(2,2) :: hel
    complex(default), dimension(2,2) :: value
    integer :: hmax
    call polarization_init (pol, flv)
    pol%polarized = .true.
    hmax = pol%spin_type / 2
    call helicity_init (hel(1,1), hmax, hmax)
    call helicity_init (hel(1,2), hmax,-hmax)
    call helicity_init (hel(2,1),-hmax, hmax)
    call helicity_init (hel(2,2),-hmax,-hmax)
    value(1,1) = (1 + alpha(3)) / 2
    value(2,2) = (1 - alpha(3)) / 2
    if (flavor_is_antiparticle (flv)) then
       value(1,2) = (alpha(1) + imago * alpha(2)) / 2
    else
       value(1,2) = (alpha(1) - imago * alpha(2)) / 2
    end if
    value(2,1) = conjg (value(1,2))
    if (value(1,1) /= 0) then
       call quantum_numbers_init (qn(1), hel(1,1))
       call state_matrix_add_state (pol%state, qn, value=value(1,1))
    end if
    if (value(2,2) /= 0) then
       call quantum_numbers_init (qn(1), hel(2,2))
       call state_matrix_add_state (pol%state, qn, value=value(2,2))
    end if
    if (value(1,2) /= 0) then
       call quantum_numbers_init (qn(1), hel(1,2))
       call state_matrix_add_state (pol%state, qn, value=value(1,2))
       call quantum_numbers_init (qn(1), hel(2,1))
       call state_matrix_add_state (pol%state, qn, value=value(2,1))
    end if
    call state_matrix_freeze (pol%state)
  end subroutine polarization_init_axis

@ %def polarization_init_axis
@ This version specifies the polarization axis in terms of $r$
(polarization degree) and $\theta,\phi$ (polar and azimuthal angles).

If one of the angles is a nonzero multiple of $\pi$, roundoff errors
typically will result in tiny contributions to unwanted components.
Therefore, include a catch for small numbers.
<<Polarizations: public>>=
  public :: polarization_init_angles
<<Polarizations: procedures>>=
  subroutine polarization_init_angles (pol, flv, r, theta, phi)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default), parameter :: eps = 10 * epsilon (1._default)
    alpha(1) = r * sin (theta) * cos (phi)
    alpha(2) = r * sin (theta) * sin (phi)
    alpha(3) = r * cos (theta)
    where (abs (alpha) < eps)  alpha = 0
    call polarization_init_axis (pol, flv, alpha)
  end subroutine polarization_init_angles

@ %def polarization_init_angles
@ Longitudinal polarization is defined only for massive bosons.  Only
the zero component is filled.  Otherwise, unpolarized.
<<Polarizations: public>>=
  public :: polarization_init_longitudinal
<<Polarizations: procedures>>=
  subroutine polarization_init_longitudinal (pol, flv, fraction)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), intent(in) :: fraction
    integer :: spin_type, multiplicity
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    complex(default) :: value
    integer :: n_values
    value = abs (fraction)
    spin_type = flavor_get_spin_type (flv)
    multiplicity = flavor_get_multiplicity (flv)
    if (mod (spin_type, 2) == 1 .and. multiplicity > 2) then
       if (fraction /= 1) then
          call polarization_init_trivial (pol, flv, 1 - fraction)
          n_values = state_matrix_get_n_matrix_elements (pol%state)
          call state_matrix_add_to_matrix_element &
               (pol%state, n_values/2 + 1, value)
       else
          call polarization_init (pol, flv)
          pol%polarized = .true.
          call helicity_init (hel, 0)
          call quantum_numbers_init (qn(1), hel)
          call state_matrix_add_state (pol%state, qn)
          call state_matrix_freeze (pol%state)
          call state_matrix_set_matrix_element (pol%state, value)
       end if
    else
       call polarization_init_unpolarized (pol, flv)
    end if
  end subroutine polarization_init_longitudinal

@ %def polarization_init_longitudinal
@ This is diagonal polarization: we specify all components explicitly.
We use only the positive components.  The sum is normalized to unity.
We assume that the length of [[alpha]] is equal to the particle
multiplicity.
<<Polarizations: public>>=
  public :: polarization_init_diagonal
<<Polarizations: procedures>>=
  subroutine polarization_init_diagonal (pol, flv, alpha)
    type(polarization_t), intent(inout) :: pol
    type(flavor_t), intent(in) :: flv
    real(default), dimension(:), intent(in) :: alpha
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    logical, dimension(size(alpha)) :: mask
    real(default) :: norm
    complex(default), dimension(:), allocatable :: value
    logical :: fermion
    integer :: h, hmax, i
    mask = alpha > 0
    norm = sum (alpha, mask);  if (norm == 0)  norm = 1
    allocate (value (count (mask)))
    value = pack (alpha / norm, mask)
    call polarization_init (pol, flv)
    pol%polarized = .true.
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    i = 0
    select case (pol%multiplicity)
    case (1)
       if (flavor_is_left_handed (flv)) then
          call helicity_init (hel, -hmax)
       else if (flavor_is_right_handed (flv)) then
          call helicity_init (hel, hmax)
       else
          call helicity_init (hel, 0)
       end if
       call quantum_numbers_init (qn(1), hel)
       call state_matrix_add_state (pol%state, qn)
    case (2)
       do h = -hmax, hmax, 2*hmax
          i = i + 1
          if (mask(i)) then
             call helicity_init (hel, h)
             call quantum_numbers_init (qn(1), hel)
             call state_matrix_add_state (pol%state, qn)
          end if
       end do
    case default
       do h = -hmax, hmax
          if (fermion .and. h == 0)  cycle
          i = i + 1
          if (mask(i)) then
             call helicity_init (hel, h)
             call quantum_numbers_init (qn(1), hel)
             call state_matrix_add_state (pol%state, qn)
          end if
       end do
    end select
    call state_matrix_freeze (pol%state)
    call state_matrix_set_matrix_element (pol%state, value)
  end subroutine polarization_init_diagonal

@ %def polarization_init_diagonal
@ Generic polarization: we generate all possible density matrix
entries, but the values are left zero.
<<Polarizations: public>>=
  public :: polarization_init_generic
<<Polarizations: procedures>>=
  subroutine polarization_init_generic (pol, flv)
    type(polarization_t), intent(out) :: pol
    type(flavor_t), intent(in) :: flv
    type(helicity_t) :: hel
    type(quantum_numbers_t), dimension(1) :: qn
    logical :: fermion
    integer :: hmax, h1, h2
    call polarization_init (pol, flv)
    pol%polarized = .true.
    fermion = mod (pol%spin_type, 2) == 0
    hmax = pol%spin_type / 2
    select case (pol%multiplicity)
    case (1)
       if (flavor_is_left_handed (flv)) then
          call helicity_init (hel, -hmax)
       else if (flavor_is_right_handed (flv)) then
          call helicity_init (hel, hmax)
       else
          call helicity_init (hel, 0)
       end if
       call quantum_numbers_init (qn(1), hel)
       call state_matrix_add_state (pol%state, qn)
    case (2)
       do h1 = -hmax, hmax, 2*hmax
          do h2 = -hmax, hmax, 2*hmax
             call helicity_init (hel, h1, h2)
             call quantum_numbers_init (qn(1), hel)
             call state_matrix_add_state (pol%state, qn)
          end do
       end do
    case default
       do h1 = -hmax, hmax
          if (fermion .and. h1 == 0)  cycle
          do h2 = -hmax, hmax
             if (fermion .and. h2 == 0)  cycle
             call helicity_init (hel, h1, h2)
             call quantum_numbers_init (qn(1), hel)
             call state_matrix_add_state (pol%state, qn)
          end do
       end do
    end select
    call state_matrix_freeze (pol%state)
  end subroutine polarization_init_generic

@ %def polarization_init_generic
@ 
\subsection{Operations}
Combine polarization states by computing the outer product of the
state matrices.
<<Polarizations: public>>=
  public :: combine_polarization_states
<<Polarizations: procedures>>=
  subroutine combine_polarization_states (pol, state)
    type(polarization_t), dimension(:), intent(in), target :: pol
    type(state_matrix_t), intent(out) :: state
    call outer_multiply (pol%state, state)
  end subroutine combine_polarization_states

@ %def combine_polarization_states
@ 
Transform a polarization density matrix into a polarization vector.
This is possible without information loss only for spin-1/2 and for
massless particles.  To get a unique answer in all cases, we consider
only the components with highest weight.  Obviously, this loses the
longitudinal component of a massive vector, for instance.

This is the inverse operation of [[polarization_init_axis]] above,
where the polarization fraction is set to unity.
<<Polarizations: public>>=
  public :: polarization_get_axis
<<Polarizations: procedures>>=
  function polarization_get_axis (pol) result (alpha)
    real(default), dimension(3) :: alpha
    type(polarization_t), intent(in), target :: pol
    type(state_iterator_t) :: it
    complex(default), dimension(2,2) :: value
    type(helicity_t), dimension(2,2) :: hel
    type(helicity_t), dimension(1) :: hel1
    integer :: hmax, i, j
    if (pol%polarized) then
       hmax = pol%spin_type / 2
       call helicity_init (hel(1,1), hmax, hmax)
       call helicity_init (hel(1,2), hmax,-hmax)
       call helicity_init (hel(2,1),-hmax, hmax)
       call helicity_init (hel(2,2),-hmax,-hmax)
       value = 0
       call state_iterator_init (it, pol%state)
       do while (state_iterator_is_valid (it))
          hel1 = state_iterator_get_helicity (it)
          SCAN_HEL: do i = 1, 2
             do j = 1, 2
                if (hel1(1) == hel(i,j)) then
                   value(i,j) = state_iterator_get_matrix_element (it)
                   exit SCAN_HEL
                end if
             end do
          end do SCAN_HEL
          call state_iterator_advance (it)
       end do
       alpha(1) = real(value(1,2) + value(2,1))
       alpha(2) = - aimag(value(1,2) - value(2,1))
       alpha(3) = real(value(1,1) - value(2,2))
    else
       alpha = 0
    end if
  end function polarization_get_axis

@ %def polarization_get_axis
@ This function returns polarization degree and polar and azimuthal
angles ($\theta,\phi$) of the polarization axis.
<<Polarizations: public>>=
  public :: polarization_to_angles
<<Polarizations: procedures>>=
  subroutine polarization_to_angles (pol, r, theta, phi)
    type(polarization_t), intent(in) :: pol
    real(default), intent(out) :: r, theta, phi
    real(default), dimension(3) :: alpha
    real(default) :: r12
    if (pol%polarized) then
       alpha = polarization_get_axis (pol)
       r = sqrt (sum (alpha**2))
       if (any (alpha /= 0)) then
          r12 = sqrt (alpha(1)**2 + alpha(2)**2)
          theta = atan2 (r12, alpha(3))
          if (any (alpha(1:2) /= 0)) then
             phi = atan2 (alpha(2), alpha(1))
          else
             phi = 0
          end if
       else
          theta = 0
       end if
    else
       r = 0
       theta = 0
       phi = 0
    end if
  end subroutine polarization_to_angles

@ %def polarization_to_angles
@
\subsection{Sparse Matrix}
We introduce a simpler implementation of a sparse matrix that should represent
polarization.  It consists of an integer array that represents the index
values, and a complex array that represents the nonvanishing entries.  The
number of nonvanishing entries must be known for initialization, but the
entries are filled one at a time.

This should eventually replace the more baroque polarization definition above,
but in the first stage we introduce it just as an intermediage storage
container.

Here is a base type without the special properties of a spin-density matrix.
<<Polarizations: public>>=
  public :: smatrix_t
<<Polarizations: types>>=
  type :: smatrix_t
     private
     integer :: dim = 0
     integer :: n_entry = 0
     integer, dimension(:,:), allocatable :: index
     complex(default), dimension(:), allocatable :: value
   contains
   <<Polarizations: smatrix: TBP>>
  end type smatrix_t
  
@ %def smatrix_t
@ Output.
<<Polarizations: smatrix: TBP>>=
  procedure :: write => smatrix_write
<<Polarizations: procedures>>=
  subroutine smatrix_write (object, unit, indent)
    class(smatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    if (allocated (object%value)) then
       if (size (object%value) > 0) then
          do i = 1, object%n_entry
             write (u, "(1x,A,'@(')", advance="no")  repeat ("  ", ind)
             write (u, "(SP,9999(I2.1,':',1x))", advance="no") &
                  object%index(:,i)
             write (u, "('('," // FMT_19 // ",','," // FMT_19 // &
                  ",'))')")  object%value(i)
          end do
       else
          write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
          write (u, "(A)")  "[empty matrix]"
       end if
    else
       write (u, "(1x,A)", advance="no")  repeat ("  ", ind)
       write (u, "(A)")  "[undefined matrix]"
    end if
  end subroutine smatrix_write
  
@ %def smatrix_write
@ Initialization: allocate arrays to the correct size.  We specify both the
dimension of the matrix (if different from two, this is rather a generic
tensor) and the number of nonvanishing entries.
<<Polarizations: smatrix: TBP>>=
  procedure :: init => smatrix_init
<<Polarizations: procedures>>=
  subroutine smatrix_init (smatrix, dim, n_entry)
    class(smatrix_t), intent(out) :: smatrix
    integer, intent(in) :: dim
    integer, intent(in) :: n_entry
    smatrix%dim = dim
    smatrix%n_entry = n_entry
    allocate (smatrix%index (dim, n_entry))
    allocate (smatrix%value (n_entry))
  end subroutine smatrix_init
  
@ %def smatrix_init
@ Fill: one entry at a time.
<<Polarizations: smatrix: TBP>>=
  procedure :: set_entry => smatrix_set_entry
<<Polarizations: procedures>>=
  subroutine smatrix_set_entry (smatrix, i, index, value)
    class(smatrix_t), intent(inout) :: smatrix
    integer, intent(in) :: i
    integer, dimension(:), intent(in) :: index
    complex(default), intent(in) :: value
    smatrix%index(:,i) = index
    smatrix%value(i) = value
  end subroutine smatrix_set_entry
  
@ %def smatrix_set_entry
@
\subsection{Polarization Matrix}
As an extension of the more generic [[smatrix]] type, we implement a proper
spin-density matrix.  After the matrix has been filled, we can fix spin type
and multiplicity for a particle, check the matrix for consistency, and
normalize it if necessary.
<<Polarizations: public>>=
  public :: pmatrix_t
<<Polarizations: types>>=
  type, extends (smatrix_t) :: pmatrix_t
     private
     integer :: spin_type = 0
     integer :: multiplicity = 0
     logical :: massive = .true.
     integer :: chirality = 0
     real(default) :: degree = 1
     logical :: pure = .false.
   contains
   <<Polarizations: pmatrix: TBP>>
  end type pmatrix_t
  
@ %def pmatrix_t
@ Output, including extra data.  (The [[indent]] argument is ignored.)
<<Polarizations: pmatrix: TBP>>=
  procedure :: write => pmatrix_write
<<Polarizations: procedures>>=
  subroutine pmatrix_write (object, unit, indent)
    class(pmatrix_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Polarization: spin density matrix"
    write (u, "(3x,A,I0)")  "spin type     = ", object%spin_type
    write (u, "(3x,A,I0)")  "multiplicity  = ", object%multiplicity
    write (u, "(3x,A,L1)")  "massive       = ", object%massive
    write (u, "(3x,A,I0)")  "chirality     = ", object%chirality
    write (u, "(3x,A,F10.7)")  "pol.degree    =", object%degree
    write (u, "(3x,A,L1)")  "pure state    = ", object%pure
    call object%smatrix_t%write (u, 1)
  end subroutine pmatrix_write
  
@ %def pmatrix_write
@ This assignment is trivial, but must be coded explicitly.
<<Polarizations: pmatrix: TBP>>=
  generic :: assignment(=) => pmatrix_assign_from_smatrix
  procedure, private :: pmatrix_assign_from_smatrix
<<Polarizations: procedures>>=
  subroutine pmatrix_assign_from_smatrix (pmatrix, smatrix)
    class(pmatrix_t), intent(out) :: pmatrix
    type(smatrix_t), intent(in) :: smatrix
    pmatrix%smatrix_t = smatrix
  end subroutine pmatrix_assign_from_smatrix
  
@ %def pmatrix_assign_from_smatrix
@ Declare spin, multiplicity, and polarization degree.  Check whether all
entries fit, and whether this is a valid matrix.

The required properties are:
\begin{enumerate}
\item all entries apply to the given spin and mass type
\item the diagonal is real
\item only the upper of corresponding off-diagonal elements is specified,
  i.e., the row index is less than the column index
\item the trace is nonnegative and equal to the polarization degree (the
  remainder, proportional to the unit matrix, is understood to be present)
\item the trace of the matrix square is positive and less or equal
  to the trace of the matrix itself, which is the polarization degree.  (If it
  is equal, we are dealing with a pure state).
\end{enumerate}
<<Polarizations: pmatrix: TBP>>=
  procedure :: normalize => pmatrix_normalize
<<Polarizations: procedures>>=
  subroutine pmatrix_normalize (pmatrix, flv, degree, tolerance)
    class(pmatrix_t), intent(inout) :: pmatrix
    type(flavor_t), intent(in) :: flv
    real(default), intent(in), optional :: degree
    real(default), intent(in), optional :: tolerance
    integer :: i, hmax
    logical :: fermion, ok
    real(default) :: trace, trace_sq
    real(default) :: tol
    tol = 0;  if (present (tolerance))  tol = tolerance
    pmatrix%spin_type = flavor_get_spin_type (flv)
    pmatrix%massive = flavor_get_mass (flv) /= 0
    if (.not. pmatrix%massive) then
       if (flavor_is_left_handed (flv)) then
          pmatrix%chirality = -1
       else if (flavor_is_right_handed (flv)) then
          pmatrix%chirality = +1
       end if
    end if
    if (pmatrix%spin_type == SCALAR) then
       pmatrix%multiplicity = 1
    else if (pmatrix%massive) then
       pmatrix%multiplicity = pmatrix%spin_type
    else if (pmatrix%chirality == 0) then
       pmatrix%multiplicity = 2
    else
       pmatrix%multiplicity = 1
    end if
    if (present (degree)) then
       if (degree < 0 .or. degree > 1) &
            call msg_error ("polarization degree must be between 0 and 1")
       pmatrix%degree = degree
    end if
    if (size (pmatrix%index, 1) /= 2)  call error ("wrong array rank")
    fermion = mod (pmatrix%spin_type, 2) == 0
    hmax = pmatrix%spin_type / 2
    if (pmatrix%n_entry > 0) then
       if (fermion) then
          if (pmatrix%massive) then
             ok = all (pmatrix%index /= 0) &
                  .and. all (abs (pmatrix%index) <= hmax)
          else if (pmatrix%chirality == -1) then
             ok = all (pmatrix%index == -hmax)
          else if (pmatrix%chirality == +1) then
             ok = all (pmatrix%index == +hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       else
          if (pmatrix%massive) then
             ok = all (abs (pmatrix%index) <= hmax)
          else
             ok = all (abs (pmatrix%index) == hmax)
          end if
       end if
       if (.not. ok)  call error ("illegal index value")
    else
       pmatrix%degree = 0
       pmatrix%pure = pmatrix%multiplicity == 1
       return
    end if
    trace = 0
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            if (abs (aimag (value)) > tol)  call error ("diagonal must be real")
            value = real (value, kind=default)
            trace = trace + value
            
         else if (any (pmatrix%index(1,:) == index(2) &
              .and.    pmatrix%index(2,:) == index(1))) then
            call error ("redundant off-diagonal entry")
         else if (index(2) < index (1)) then
            index = index([2,1])
            value = conjg (value)
         end if
       end associate
    end do
    if (abs (trace) <= tol)  call error ("trace must not vanish")
    trace = real (trace, kind=default)
    pmatrix%value = pmatrix%value / trace * pmatrix%degree
    trace_sq = (1 - pmatrix%degree ** 2) / pmatrix%multiplicity
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         if (index(1) == index(2)) then
            trace_sq = trace_sq + abs (value) ** 2
         else
            trace_sq = trace_sq + 2 * abs (value) ** 2
         end if
       end associate
    end do
    if (pmatrix%multiplicity == 1) then
       pmatrix%pure = .true.
    else if (abs (trace_sq - 1) <= tol) then
       pmatrix%pure = .true.
    else if (trace_sq - 1 > tol .or. trace_sq < -tol) then
       print *, "Trace of matrix square = ", trace_sq
       call error ("not permissible as density matrix")
    end if
  contains
    subroutine error (msg)
      character(*), intent(in) :: msg
      call pmatrix%write ()
      call msg_fatal ("Spin density matrix: " // msg)
    end subroutine error
  end subroutine pmatrix_normalize
  
@ %def pmatrix_normalize
@
A polarized matrix is defined as one with a positive polarization degree, even
if the actual matrix is trivial.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_polarized => pmatrix_is_polarized
<<Polarizations: procedures>>=
  elemental function pmatrix_is_polarized (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = pmatrix%degree > 0
  end function pmatrix_is_polarized
  
@ %def pmatrix_is_polarized
@
Check if there are only diagonal entries.
<<Polarizations: pmatrix: TBP>>=
  procedure :: is_diagonal => pmatrix_is_diagonal
<<Polarizations: procedures>>=
  elemental function pmatrix_is_diagonal (pmatrix) result (flag)
    class(pmatrix_t), intent(in) :: pmatrix
    logical :: flag
    flag = all (pmatrix%index(1,:) == pmatrix%index(2,:))
  end function pmatrix_is_diagonal
  
@ %def pmatrix_is_diagonal
@
\subsection{Data Translation}
Create a [[polarization_t]] object from the contents of a normalized
[[pmatrix_t]] object.

Note for off diagonal entries: the convention for the arguments of
[[helicity_init]] is [[(h2,h1)]], so the helicity of the conjugate state is
inserted first.
<<Polarizations: public>>=
  public :: polarization_init_pmatrix
<<Polarizations: procedures>>=
  subroutine polarization_init_pmatrix (pol, pmatrix)
    type(polarization_t), intent(out) :: pol
    type(pmatrix_t), intent(in) :: pmatrix
    type(quantum_numbers_t), dimension(1) :: qn
    type(helicity_t) :: hel
    integer :: i, h, h1, h2, hmin, hmax, dh
    logical :: fermion
    complex(default) :: value
    pol%polarized = .true.
    pol%spin_type = pmatrix%spin_type
    pol%multiplicity = pmatrix%multiplicity
    call state_matrix_init (pol%state, store_values = .true.)
    fermion = mod (pol%spin_type, 2) == 0
    h = pol%spin_type / 2
    select case (pmatrix%chirality)
    case (-1)
       hmin = -h
       hmax = -h
    case (0)
       hmin = -h
       hmax = h
    case (1)
       hmin = h
       hmax = h
    end select
    if (pol%multiplicity == 1) then
       dh = 1
    else if (pol%multiplicity == 2) then
       dh = hmax - hmin
    else
       dh = 1
    end if
    if (pmatrix%degree < 1) then
       value = (1 - pmatrix%degree) / pol%multiplicity
       do h = hmin, hmax, dh
          if (h == 0 .and. fermion)  cycle
          call helicity_init (hel, h)
          call quantum_numbers_init (qn(1), hel)
          call state_matrix_add_state (pol%state, qn, value = value)
       end do
    end if
    do i = 1, pmatrix%n_entry
       associate (index => pmatrix%index(:,i), value => pmatrix%value(i))
         h1 = index(1)
         h2 = index(2)
         if (h1 == h2) then
            call helicity_init (hel, h1)
            call quantum_numbers_init (qn(1), hel)
            call state_matrix_add_state (pol%state, qn, value = value, &
                 sum_values = .true.)
         else
            call helicity_init (hel, h2, h1)
            call quantum_numbers_init (qn(1), hel)
            call state_matrix_add_state (pol%state, qn, value = value)
            call helicity_init (hel, h1, h2)
            call quantum_numbers_init (qn(1), hel)
            call state_matrix_add_state (pol%state, qn, value = conjg (value))
         end if
       end associate
    end do
    call state_matrix_freeze (pol%state)
  end subroutine polarization_init_pmatrix

@ %def polarization_init_generic
\subsection{Unit tests}
<<Polarizations: public>>=
  public :: polarization_test
<<Polarizations: procedures>>= 
  subroutine polarization_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Polarizations: execute tests>>
  end subroutine polarization_test

@  %def polarization_test
@
\subsubsection{Polarization type}
Checking the setup for polarization. 
<<Polarizations: execute tests>>=
  call test (polarization_1, "polarization_1", &
       "check polarization setup", &
       u, results)
<<Polarizations: tests>>= 
  subroutine polarization_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(polarization_t) :: pol
    type(flavor_t) :: flv
    real(default), dimension(3) :: alpha
    real(default) :: r, theta, phi

    write (u, "(A)")  "* Test output: polarization_1"
    write (u, "(A)")  "*   Purpose: test polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)")      
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flavor_init (flv, 1, model)
    call polarization_init_unpolarized (pol, flv)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Unpolarized fermion"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv, 0._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call polarization_init_transversal (pol, flv, 0._default, 1._default)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call polarization_init_transversal (pol, flv, 0.9_default, 0.8_default)
    call polarization_write (pol, u)
    write (u, "(A,L1)")  "   diagonal =", polarization_is_diagonal (pol)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)") "* All polarization directions of a fermion"
    write (u, "(A)")
    
    call polarization_init_generic (pol, flv)
    call polarization_write (pol, u)
    call polarization_final (pol)
    call flavor_init (flv, 21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv, 0.3_default)
    call polarization_write (pol, u)
    call polarization_final (pol)   
    call flavor_init (flv, 23, model)
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=-0.7"
    write (u, "(A)") 
    
    call polarization_init_circular (pol, flv,  -0.7_default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call polarization_init_circular (pol, flv, 1._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call polarization_init_longitudinal (pol, flv, 0.4_default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call polarization_init_longitudinal (pol, flv, 1._default)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Diagonally polarized massive vector"
    write (u, "(A)")
    
    call polarization_init_diagonal &
         (pol, flv, [0._default, 1._default, 2._default])
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* All polarization directions of a massive vector"
    write (u, "(A)") 

    call polarization_init_generic (pol, flv)
    call polarization_write (pol, u)
    call polarization_final (pol)
    call flavor_init (flv, 21, model)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    alpha = [0.2_default, 0.4_default, 0.6_default]
    call polarization_init_axis (pol, flv, alpha)
    call polarization_write (pol, u)
    
    write (u, "(A)")  "   Recovered axis:"
    alpha = polarization_get_axis (pol)
    write (u, "(A)")  "   Angle polarization (0.5, 0.6, -1)"
    r = 0.5_default
    theta = 0.6_default
    phi = -1._default
    call polarization_init_angles (pol, flv, r, theta, phi)
    call polarization_write (pol, u)
    write (u, "(A)")  "   Recovered parameters (r, theta, phi):"
    call polarization_to_angles (pol, r, theta, phi)
    write (u, "(A,3(1x," // FMT_12 // "))")  "     ", r, theta, phi
    call polarization_final (pol)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_1"    
      
  end subroutine polarization_1

@ %def polarization_1
@
\subsubsection{Sparse-Matrix type}
Use a sparse density matrix universally as the input for setting up
polarization.
<<Polarizations: execute tests>>=
  call test (polarization_2, "polarization_2", &
       "matrix polarization setup", &
       u, results)
<<Polarizations: tests>>= 
  subroutine polarization_2 (u)
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(polarization_t) :: pol
    real(default), dimension(3) :: alpha
    type(pmatrix_t) :: pmatrix
    real(default), parameter :: tolerance = 1e-8_default

    write (u, "(A)")  "* Test output: polarization_2"
    write (u, "(A)")  "*   Purpose: matrix polarization setup"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 
    
    call model%init_sm_test ()

    write (u, "(A)") "* Unpolarized fermion"
    write (u, "(A)")
    
    call flavor_init (flv, 1, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 0._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)")
    write (u, "(A)")  "* Transversally polarized fermion, phi=0"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Transversally polarized fermion, phi=0.9, frac=0.8"
    write (u, "(A)")
    
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%set_entry (2, [+1,+1], (1._default, 0._default))
    call pmatrix%set_entry (3, [-1,+1], exp ((0._default, -0.9_default)))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=1"
    write (u, "(A)")
    
    call flavor_init (flv, 11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massive fermion, frac=0.8"
    write (u, "(A)")
    
    call flavor_init (flv, 11, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [-1,-1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.8_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Left-handed massless fermion"
    write (u, "(A)")
    
    call flavor_init (flv, 12, model)
    call pmatrix%init (2, 0)
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Right-handed massless fermion, frac=0.5"
    write (u, "(A)")
    
    call flavor_init (flv, -12, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.5_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized gluon, frac=0.3"
    write (u, "(A)") 
    
    call flavor_init (flv, 21, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.3_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)   
    
    write (u, "(A)") 
    write (u, "(A)") "* Circularly polarized massive vector, frac=0.7"
    write (u, "(A)") 
    
    call flavor_init (flv, 23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.7_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Circularly polarized massive vector"
    write (u, "(A)")
    
    call flavor_init (flv, 23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [1,1], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector, frac=0.4"
    write (u, "(A)")
    
    call flavor_init (flv, 23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 0.4_default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Longitudinally polarized massive vector"
    write (u, "(A)") 
    
    call flavor_init (flv, 23, model)
    call pmatrix%init (2, 1)
    call pmatrix%set_entry (1, [0,0], (1._default, 0._default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 
    write (u, "(1x,A,L1)")  "polarized = ", pmatrix%is_polarized ()
    write (u, "(1x,A,L1)")  "diagonal = ", pmatrix%is_diagonal ()
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    write (u, "(A)") 
    write (u, "(A)")  "* Axis polarization (0.2, 0.4, 0.6)"
    write (u, "(A)") 
    
    call flavor_init (flv, 11, model)
    alpha = [0.2_default, 0.4_default, 0.6_default]
    alpha = alpha / sqrt (sum (alpha**2))
    call pmatrix%init (2, 3)
    call pmatrix%set_entry (1, [-1,-1], cmplx (1 - alpha(3), kind=default))
    call pmatrix%set_entry (2, [1,-1], &
         cmplx (alpha(1), -alpha(2), kind=default))
    call pmatrix%set_entry (3, [1,1], cmplx (1 + alpha(3), kind=default))
    call pmatrix%normalize (flv, 1._default, tolerance)
    call pmatrix%write (u)
    write (u, *) 

    call polarization_init_pmatrix (pol, pmatrix)
    call polarization_write (pol, u)
    call polarization_final (pol)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: polarization_2"    
      
  end subroutine polarization_2

@ %def polarization_2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{HepMC events}
This section provides the interface to the HepMC C++ library for handling
Monte-Carlo events.

Each C++ class of HepMC that we use is mirrored by a Fortran type,
which contains as its only component the C pointer to the C++ object.

Each C++ method of HepMC that we use has a C wrapper function.  This
function takes a pointer to the host object as its first argument.
Further arguments are either C pointers, or in the case of simple
types (integer, real), interoperable C/Fortran objects.

The C wrapper functions have explicit interfaces in the Fortran
module.  They are called by Fortran wrapper procedures.  These are
treated as methods of the corresponding Fortran type.
<<[[hepmc_interface.f90]]>>=
<<File header>>

module hepmc_interface

  use, intrinsic :: iso_c_binding !NODEP!
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use lorentz
  use unit_tests
  use model_data
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use polarizations

<<Standard module head>>

<<HepMC interface: public>>

<<HepMC interface: types>>

<<HepMC interface: interfaces>>

contains

<<HepMC interface: procedures>>

<<HepMC interface: tests>>

end module hepmc_interface
@ %def hepmc_interface
@ 
\subsection{Interface check}
This function can be called in order to verify that we are using the
actual HepMC library, and not the dummy version.
<<HepMC interface: interfaces>>=
  interface
     logical(c_bool) function hepmc_available () bind(C)
       import
     end function hepmc_available
  end interface
<<HepMC interface: public>>=
  public :: hepmc_is_available
<<HepMC interface: procedures>>=
  function hepmc_is_available () result (flag)
    logical :: flag
    flag = hepmc_available ()
  end function hepmc_is_available

@ %def hepmc_is_available
@ 
\subsection{FourVector}
The C version of four-vectors is often transferred by value, and the
associated procedures are all inlined.  The wrapper needs to transfer
by reference, so we create FourVector objects on the heap which have
to be deleted explicitly.  The input is a [[vector4_t]] or
[[vector3_t]] object from the [[lorentz]] module.
<<HepMC interface: public>>=
  public :: hepmc_four_vector_t
<<HepMC interface: types>>=
  type :: hepmc_four_vector_t
     private
     type(c_ptr) :: obj
  end type hepmc_four_vector_t

@ %def hepmc_four_vector_t
@ In the C constructor, the zero-component (fourth argument) is
optional; if missing, it is set to zero.  The Fortran version has
initializer form and takes either a three-vector or a four-vector.
A further version extracts the four-vector from a HepMC particle
object.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_four_vector_xyz (x, y, z) bind(C)
       import
       real(c_double), value :: x, y, z
     end function new_four_vector_xyz
  end interface
  interface
     type(c_ptr) function new_four_vector_xyzt (x, y, z, t) bind(C)
       import
       real(c_double), value :: x, y, z, t
     end function new_four_vector_xyzt
  end interface
@ %def new_four_vector_xyz new_four_vector_xyzt
<<HepMC interface: public>>=
  public :: hepmc_four_vector_init
<<HepMC interface: interfaces>>=
  interface hepmc_four_vector_init
     module procedure hepmc_four_vector_init_v4
     module procedure hepmc_four_vector_init_v3
     module procedure hepmc_four_vector_init_hepmc_prt
  end interface
<<HepMC interface: procedures>>=
  subroutine hepmc_four_vector_init_v4 (pp, p)
    type(hepmc_four_vector_t), intent(out) :: pp
    type(vector4_t), intent(in) :: p
    real(default), dimension(0:3) :: pa
    pa = vector4_get_components (p)
    pp%obj = new_four_vector_xyzt &
         (real (pa(1), c_double), &
          real (pa(2), c_double), &
          real (pa(3), c_double), &
          real (pa(0), c_double))
  end subroutine hepmc_four_vector_init_v4
  
  subroutine hepmc_four_vector_init_v3 (pp, p)
    type(hepmc_four_vector_t), intent(out) :: pp
    type(vector3_t), intent(in) :: p
    real(default), dimension(3) :: pa
    pa = vector3_get_components (p)
    pp%obj = new_four_vector_xyz &
         (real (pa(1), c_double), &
          real (pa(2), c_double), &
          real (pa(3), c_double))
  end subroutine hepmc_four_vector_init_v3
  
  subroutine hepmc_four_vector_init_hepmc_prt (pp, prt)
    type(hepmc_four_vector_t), intent(out) :: pp
    type(hepmc_particle_t), intent(in) :: prt
    pp%obj = gen_particle_momentum (prt%obj)
  end subroutine hepmc_four_vector_init_hepmc_prt
  
@ %def hepmc_four_vector_init
@ Here, the destructor is explicitly needed.
<<HepMC interface: interfaces>>=
  interface
     subroutine four_vector_delete (p_obj) bind(C)
       import
       type(c_ptr), value :: p_obj
     end subroutine four_vector_delete
  end interface
@ %def four_vector_delete
<<HepMC interface: public>>=
  public :: hepmc_four_vector_final
<<HepMC interface: procedures>>=
  subroutine hepmc_four_vector_final (p)
    type(hepmc_four_vector_t), intent(inout) :: p
    call four_vector_delete (p%obj)
  end subroutine hepmc_four_vector_final

@ %def hepmc_four_vector_final
@ Convert to a Lorentz vector.
<<HepMC interface: interfaces>>=
  interface
     function four_vector_px (p_obj) result (px) bind(C)
       import
       real(c_double) :: px
       type(c_ptr), value :: p_obj
     end function four_vector_px
  end interface
  interface
     function four_vector_py (p_obj) result (py) bind(C)
       import
       real(c_double) :: py
       type(c_ptr), value :: p_obj
     end function four_vector_py
  end interface
  interface
     function four_vector_pz (p_obj) result (pz) bind(C)
       import
       real(c_double) :: pz
       type(c_ptr), value :: p_obj
     end function four_vector_pz
  end interface
  interface
     function four_vector_e (p_obj) result (e) bind(C)
       import
       real(c_double) :: e
       type(c_ptr), value :: p_obj
     end function four_vector_e
  end interface
@ %def four_vector_px four_vector_py four_vector_pz four_vector_e
<<HepMC interface: public>>=
  public :: hepmc_four_vector_to_vector4
<<HepMC interface: procedures>>=
  subroutine hepmc_four_vector_to_vector4 (pp, p)
    type(hepmc_four_vector_t), intent(in) :: pp
    type(vector4_t), intent(out) :: p
    real(default) :: E
    real(default), dimension(3) :: p3
    E = four_vector_e (pp%obj)
    p3(1) = four_vector_px (pp%obj)
    p3(2) = four_vector_py (pp%obj)
    p3(3) = four_vector_pz (pp%obj)
    p = vector4_moving (E, vector3_moving (p3))
  end subroutine hepmc_four_vector_to_vector4

@ %def hepmc_four_vector_to_vector4
@ 
\subsection{Polarization}
Polarization objects are temporarily used for assigning particle
polarization.  We add a flag [[polarized]].  If this is false, the
polarization is not set and should not be transferred to
[[hepmc_particle]] objects.
<<HepMC interface: public>>=
  public :: hepmc_polarization_t
<<HepMC interface: types>>=
  type :: hepmc_polarization_t
     private
     logical :: polarized = .false.
     type(c_ptr) :: obj
  end type hepmc_polarization_t

@ %def hepmc_polarization_t
@ Constructor.  The C wrapper takes polar and azimuthal angle as
arguments.  The Fortran version allows for either a complete
polarization density matrix, or for a definite (diagonal) helicity.

\emph{HepMC does not allow to specify the degree of polarization,
  therefore we have to map it to either 0 or 1.  We choose 0 for
  polarization less than $0.5$ and 1 for polarization greater than
  $0.5$.  Even this simplification works only for spin-1/2 and for
  massless particles; massive vector bosons cannot be treated this
  way.  In particular, zero helicity is always translated as
  unpolarized.}

\emph{For massive vector bosons, we arbitrarily choose the convention
  that the longitudinal (zero) helicity state is mapped to the theta
  angle $\pi/2$.  This works under the condition that helicity is
  projected onto one of the basis states.}
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_polarization (theta, phi) bind(C)
       import
       real(c_double), value :: theta, phi
     end function new_polarization
  end interface
@ %def new_polarization
<<HepMC interface: public>>=
  public :: hepmc_polarization_init
<<HepMC interface: interfaces>>=
  interface hepmc_polarization_init
     module procedure hepmc_polarization_init_pol
     module procedure hepmc_polarization_init_hel
     module procedure hepmc_polarization_init_int
  end interface
<<HepMC interface: procedures>>=
  subroutine hepmc_polarization_init_pol (hpol, pol)
    type(hepmc_polarization_t), intent(out) :: hpol
    type(polarization_t), intent(in) :: pol
    real(default) :: r, theta, phi
    if (polarization_is_polarized (pol)) then
       call polarization_to_angles (pol, r, theta, phi)
       if (r >= 0.5) then
          hpol%polarized = .true.
          hpol%obj = new_polarization &
               (real (theta, c_double), real (phi, c_double))
       end if
    end if
  end subroutine hepmc_polarization_init_pol

  subroutine hepmc_polarization_init_hel (hpol, hel)
    type(hepmc_polarization_t), intent(out) :: hpol
    type(helicity_t), intent(in) :: hel
    integer, dimension(2) :: h
    if (helicity_is_defined (hel)) then
       h = helicity_get (hel)
       select case (h(1))
       case (1:)
          hpol%polarized = .true.
          hpol%obj = new_polarization (0._c_double, 0._c_double)
       case (:-1)
          hpol%polarized = .true.
          hpol%obj = new_polarization (real (pi, c_double), 0._c_double)
       case (0)
          hpol%polarized = .true.
          hpol%obj = new_polarization (real (pi/2, c_double), 0._c_double)
       end select
    end if
  end subroutine hepmc_polarization_init_hel

  subroutine hepmc_polarization_init_int (hpol, hel)
    type(hepmc_polarization_t), intent(out) :: hpol
    integer, intent(in) :: hel
    select case (hel)
    case (1:)
       hpol%polarized = .true.
       hpol%obj = new_polarization (0._c_double, 0._c_double)
    case (:-1)
       hpol%polarized = .true.
       hpol%obj = new_polarization (real (pi, c_double), 0._c_double)
    case (0)
       hpol%polarized = .true.
       hpol%obj = new_polarization (real (pi/2, c_double), 0._c_double)
    end select
  end subroutine hepmc_polarization_init_int

@ %def hepmc_polarization_init
@ Destructor.  The C object is deallocated only if the [[polarized]]
flag is set.
<<HepMC interface: interfaces>>=
  interface
     subroutine polarization_delete (pol_obj) bind(C)
       import
       type(c_ptr), value :: pol_obj
     end subroutine polarization_delete
  end interface
@ %def polarization_delete
<<HepMC interface: public>>=
  public :: hepmc_polarization_final
<<HepMC interface: procedures>>=
  subroutine hepmc_polarization_final (hpol)
    type(hepmc_polarization_t), intent(inout) :: hpol
    if (hpol%polarized)  call polarization_delete (hpol%obj)
  end subroutine hepmc_polarization_final

@ %def hepmc_polarization_final
@ Recover polarization from HepMC polarization object (with the
abovementioned deficiencies).
<<HepMC interface: interfaces>>=
  interface
     function polarization_theta (pol_obj) result (theta) bind(C)
       import
       real(c_double) :: theta
       type(c_ptr), value :: pol_obj
     end function polarization_theta
  end interface
  interface
     function polarization_phi (pol_obj) result (phi) bind(C)
       import
       real(c_double) :: phi
       type(c_ptr), value :: pol_obj
     end function polarization_phi
  end interface
@ %def polarization_theta polarization_phi
<<HepMC interface: public>>=
  public :: hepmc_polarization_to_pol
<<HepMC interface: procedures>>=
  subroutine hepmc_polarization_to_pol (hpol, flv, pol)
    type(hepmc_polarization_t), intent(in) :: hpol
    type(flavor_t), intent(in) :: flv
    type(polarization_t), intent(out) :: pol
    real(default) :: theta, phi
    theta = polarization_theta (hpol%obj)
    phi = polarization_phi (hpol%obj)
    call polarization_init_angles (pol, flv, 1._default, theta, phi)
  end subroutine hepmc_polarization_to_pol

@ %def hepmc_polarization_to_pol
@ Recover helicity.  Here, $\phi$ is ignored and only the sign of
$\cos\theta$ is relevant, mapped to positive/negative helicity.
<<HepMC interface: public>>=
  public :: hepmc_polarization_to_hel
<<HepMC interface: procedures>>=
  subroutine hepmc_polarization_to_hel (hpol, flv, hel)
    type(hepmc_polarization_t), intent(in) :: hpol
    type(flavor_t), intent(in) :: flv
    type(helicity_t), intent(out) :: hel
    real(default) :: theta
    integer :: hmax
    theta = polarization_theta (hpol%obj)
    hmax = flavor_get_spin_type (flv) / 2
    call helicity_init (hel, sign (hmax, nint (cos (theta))))
  end subroutine hepmc_polarization_to_hel

@ %def hepmc_polarization_to_hel
@ 
\subsection{GenParticle}
Particle objects have the obvious meaning.
<<HepMC interface: public>>=
  public :: hepmc_particle_t
<<HepMC interface: types>>=
  type :: hepmc_particle_t
     private
     type(c_ptr) :: obj
  end type hepmc_particle_t

@ %def hepmc_particle_t
@ Constructor.  The C version takes a FourVector object, which in the
Fortran wrapper is created on the fly from a [[vector4]] Lorentz
vector.

No destructor is needed as long as all particles are entered into
vertex containers.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_gen_particle (prt_obj, pdg_id, status) bind(C)
       import
       type(c_ptr), value :: prt_obj
       integer(c_int), value :: pdg_id, status
     end function new_gen_particle
  end interface
@ %def new_gen_particle
<<HepMC interface: public>>=
  public :: hepmc_particle_init
<<HepMC interface: procedures>>=
  subroutine hepmc_particle_init (prt, p, pdg, status)
    type(hepmc_particle_t), intent(out) :: prt
    type(vector4_t), intent(in) :: p
    integer, intent(in) :: pdg, status
    type(hepmc_four_vector_t) :: pp
    call hepmc_four_vector_init (pp, p)
    prt%obj = new_gen_particle (pp%obj, int (pdg, c_int), int (status, c_int))
    call hepmc_four_vector_final (pp)
  end subroutine hepmc_particle_init

@ %def hepmc_particle_init
@ Set the particle color flow.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_particle_set_flow (prt_obj, code_index, code) bind(C)
       import
       type(c_ptr), value :: prt_obj
       integer(c_int), value :: code_index, code
     end subroutine gen_particle_set_flow
  end interface
@ %def gen_particle_set_flow
@ Set the particle color.  Either from a [[color_t]] object or
directly from a pair of integers.
<<HepMC interface: interfaces>>=
  interface hepmc_particle_set_color
     module procedure hepmc_particle_set_color_col
     module procedure hepmc_particle_set_color_int
  end interface hepmc_particle_set_color
<<HepMC interface: public>>=
  public :: hepmc_particle_set_color
<<HepMC interface: procedures>>=
  subroutine hepmc_particle_set_color_col (prt, col)
    type(hepmc_particle_t), intent(inout) :: prt
    type(color_t), intent(in) :: col
    integer(c_int) :: c
    c = color_get_col (col)
    if (c /= 0)  call gen_particle_set_flow (prt%obj, 1_c_int, c)
    c = color_get_acl (col)
    if (c /= 0)  call gen_particle_set_flow (prt%obj, 2_c_int, c)
  end subroutine hepmc_particle_set_color_col

  subroutine hepmc_particle_set_color_int (prt, col)
    type(hepmc_particle_t), intent(inout) :: prt
    integer, dimension(2), intent(in) :: col
    integer(c_int) :: c
    c = col(1)
    if (c /= 0)  call gen_particle_set_flow (prt%obj, 1_c_int, c)
    c = col(2)
    if (c /= 0)  call gen_particle_set_flow (prt%obj, 2_c_int, c)
  end subroutine hepmc_particle_set_color_int

@ %def hepmc_particle_set_color
@ Set the particle polarization.  For the restrictions on particle
polarization in HepMC, see above [[hepmc_polarization_init]].
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_particle_set_polarization (prt_obj, pol_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj, pol_obj
     end subroutine gen_particle_set_polarization
  end interface
@ %def gen_particle_set_polarization
<<HepMC interface: public>>=
  public :: hepmc_particle_set_polarization
<<HepMC interface: interfaces>>=
  interface hepmc_particle_set_polarization
     module procedure hepmc_particle_set_polarization_pol
     module procedure hepmc_particle_set_polarization_hel
     module procedure hepmc_particle_set_polarization_int
  end interface
<<HepMC interface: procedures>>=
  subroutine hepmc_particle_set_polarization_pol (prt, pol)
    type(hepmc_particle_t), intent(inout) :: prt
    type(polarization_t), intent(in) :: pol
    type(hepmc_polarization_t) :: hpol
    call hepmc_polarization_init (hpol, pol)
    if (hpol%polarized)  call gen_particle_set_polarization (prt%obj, hpol%obj)
    call hepmc_polarization_final (hpol)
  end subroutine hepmc_particle_set_polarization_pol

  subroutine hepmc_particle_set_polarization_hel (prt, hel)
    type(hepmc_particle_t), intent(inout) :: prt
    type(helicity_t), intent(in) :: hel
    type(hepmc_polarization_t) :: hpol
    call hepmc_polarization_init (hpol, hel)
    if (hpol%polarized)  call gen_particle_set_polarization (prt%obj, hpol%obj)
    call hepmc_polarization_final (hpol)
  end subroutine hepmc_particle_set_polarization_hel

  subroutine hepmc_particle_set_polarization_int (prt, hel)
    type(hepmc_particle_t), intent(inout) :: prt
    integer, intent(in) :: hel
    type(hepmc_polarization_t) :: hpol
    call hepmc_polarization_init (hpol, hel)
    if (hpol%polarized)  call gen_particle_set_polarization (prt%obj, hpol%obj)
    call hepmc_polarization_final (hpol)
  end subroutine hepmc_particle_set_polarization_int

@ %def hepmc_particle_set_polarization
@ Return the HepMC barcode (unique integer ID) of the particle.
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_barcode (prt_obj) result (barcode) bind(C)
       import
       integer(c_int) :: barcode
       type(c_ptr), value :: prt_obj
     end function gen_particle_barcode
  end interface
@ %def gen_particle_barcode
<<HepMC interface: public>>=
  public :: hepmc_particle_get_barcode
<<HepMC interface: procedures>>=
  function hepmc_particle_get_barcode (prt) result (barcode)
    integer :: barcode
    type(hepmc_particle_t), intent(in) :: prt
    barcode = gen_particle_barcode (prt%obj)
  end function hepmc_particle_get_barcode

@ %def hepmc_particle_get_barcode
@ Return the four-vector component of the particle object as a [[vector4_t]] Lorentz vector.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function gen_particle_momentum (prt_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj
     end function gen_particle_momentum
  end interface
@ %def gen_particle_momentum
<<HepMC interface: public>>=
  public :: hepmc_particle_get_momentum
<<HepMC interface: procedures>>=
  function hepmc_particle_get_momentum (prt) result (p)
    type(vector4_t) :: p
    type(hepmc_particle_t), intent(in) :: prt
    type(hepmc_four_vector_t) :: pp
    call hepmc_four_vector_init (pp, prt)
    call hepmc_four_vector_to_vector4 (pp, p)
    call hepmc_four_vector_final (pp)
  end function hepmc_particle_get_momentum

@ %def hepmc_particle_get_momentum
@ Return the invariant mass squared of the particle object.  HepMC
stores the signed invariant mass (no squaring).
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_generated_mass (prt_obj) result (mass) bind(C)
       import
       real(c_double) :: mass
       type(c_ptr), value :: prt_obj
     end function gen_particle_generated_mass
  end interface
@ %def gen_particle_generated_mass
<<HepMC interface: public>>=
  public :: hepmc_particle_get_mass_squared
<<HepMC interface: procedures>>=
  function hepmc_particle_get_mass_squared (prt) result (m2)
    real(default) :: m2
    type(hepmc_particle_t), intent(in) :: prt
    real(default) :: m
    m = gen_particle_generated_mass (prt%obj)
    m2 = sign (m**2, m)
  end function hepmc_particle_get_mass_squared

@ %def hepmc_particle_get_mass_squared
@ Return the PDG ID:
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_pdg_id (prt_obj) result (pdg_id) bind(C)
       import
       integer(c_int) :: pdg_id
       type(c_ptr), value :: prt_obj
     end function gen_particle_pdg_id
  end interface
@ %def gen_particle_pdg_id
<<HepMC interface: public>>=
  public :: hepmc_particle_get_pdg
<<HepMC interface: procedures>>=
  function hepmc_particle_get_pdg (prt) result (pdg)
    integer :: pdg
    type(hepmc_particle_t), intent(in) :: prt
    pdg = gen_particle_pdg_id (prt%obj)
  end function hepmc_particle_get_pdg

@ %def hepmc_particle_get_pdg
@ Return the status code:
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_status (prt_obj) result (status) bind(C)
       import
       integer(c_int) :: status
       type(c_ptr), value :: prt_obj
     end function gen_particle_status
  end interface
@ %def gen_particle_status
<<HepMC interface: public>>=
  public :: hepmc_particle_get_status
<<HepMC interface: procedures>>=
  function hepmc_particle_get_status (prt) result (status)
    integer :: status
    type(hepmc_particle_t), intent(in) :: prt
    status = gen_particle_status (prt%obj)
  end function hepmc_particle_get_status

@ %def hepmc_particle_get_status
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_is_beam (prt_obj) result (is_beam) bind(C)
       import
       logical(c_bool) :: is_beam
       type(c_ptr), value :: prt_obj
     end function gen_particle_is_beam
  end interface
@ %def gen_particle_is_beam
@ Determine whether a particle is a beam particle. 
<<HepMC interface: public>>=
  public :: hepmc_particle_is_beam
<<HepMC interface: procedures>>=
  function hepmc_particle_is_beam (prt) result (is_beam)
    logical :: is_beam
    type(hepmc_particle_t), intent(in) :: prt
    is_beam = gen_particle_is_beam (prt%obj)
  end function hepmc_particle_is_beam
    
@ %def hepmc_particle_is_beam
@ Return the production/decay vertex (as a pointer, no finalization
necessary).
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function gen_particle_production_vertex (prt_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj
     end function gen_particle_production_vertex
  end interface
  interface
     type(c_ptr) function gen_particle_end_vertex (prt_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj
     end function gen_particle_end_vertex
  end interface
@ %def gen_particle_production_vertex gen_particle_end_vertex
<<HepMC interface: public>>=
  public :: hepmc_particle_get_production_vertex
  public :: hepmc_particle_get_decay_vertex
<<HepMC interface: procedures>>=
  function hepmc_particle_get_production_vertex (prt) result (v)
    type(hepmc_vertex_t) :: v
    type(hepmc_particle_t), intent(in) :: prt
    v%obj = gen_particle_production_vertex (prt%obj)
  end function hepmc_particle_get_production_vertex

  function hepmc_particle_get_decay_vertex (prt) result (v)
    type(hepmc_vertex_t) :: v
    type(hepmc_particle_t), intent(in) :: prt
    v%obj = gen_particle_end_vertex (prt%obj)
  end function hepmc_particle_get_decay_vertex

@ %def hepmc_particle_get_production_vertex hepmc_particle_get_decay_vertex
@ Return the number of parents/children.
<<HepMC interface: public>>=
  public :: hepmc_particle_get_n_parents
  public :: hepmc_particle_get_n_children
<<HepMC interface: procedures>>=
  function hepmc_particle_get_n_parents (prt) result (n_parents)
    integer :: n_parents
    type(hepmc_particle_t), intent(in) :: prt
    type(hepmc_vertex_t) :: v
    v = hepmc_particle_get_production_vertex (prt)
    if (hepmc_vertex_is_valid (v)) then
       n_parents = hepmc_vertex_get_n_in (v)
    else
       n_parents = 0
    end if
  end function hepmc_particle_get_n_parents

  function hepmc_particle_get_n_children (prt) result (n_children)
    integer :: n_children
    type(hepmc_particle_t), intent(in) :: prt
    type(hepmc_vertex_t) :: v
    v = hepmc_particle_get_decay_vertex (prt)
    if (hepmc_vertex_is_valid (v)) then
       n_children = hepmc_vertex_get_n_out (v)
    else
       n_children = 0
    end if
  end function hepmc_particle_get_n_children

@ %def hepmc_particle_get_n_parents
@ %def hepmc_particle_get_n_children
@ Convenience function: Return the array of parent particles for a
given HepMC particle.  The contents are HepMC barcodes that still have
to be mapped to the particle indices.
<<HepMC interface: public>>=
  public :: hepmc_particle_get_parent_barcodes
  public :: hepmc_particle_get_child_barcodes
<<HepMC interface: procedures>>=
  function hepmc_particle_get_parent_barcodes (prt) result (parent_barcode)
    type(hepmc_particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: parent_barcode
    type(hepmc_vertex_t) :: v
    type(hepmc_vertex_particle_in_iterator_t) :: it
    integer :: i
    v = hepmc_particle_get_production_vertex (prt)
    if (hepmc_vertex_is_valid (v)) then
       allocate (parent_barcode (hepmc_vertex_get_n_in (v)))
       if (size (parent_barcode) /= 0) then
          call hepmc_vertex_particle_in_iterator_init (it, v)
          do i = 1, size (parent_barcode)
             parent_barcode(i) = hepmc_particle_get_barcode &
                  (hepmc_vertex_particle_in_iterator_get (it))
             call hepmc_vertex_particle_in_iterator_advance (it)
          end do
          call hepmc_vertex_particle_in_iterator_final (it)
       end if
    else
       allocate (parent_barcode (0))
    end if
  end function hepmc_particle_get_parent_barcodes

  function hepmc_particle_get_child_barcodes (prt) result (child_barcode)
    type(hepmc_particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: child_barcode
    type(hepmc_vertex_t) :: v
    type(hepmc_vertex_particle_out_iterator_t) :: it
    integer :: i
    v = hepmc_particle_get_decay_vertex (prt)
    if (hepmc_vertex_is_valid (v)) then
       allocate (child_barcode (hepmc_vertex_get_n_out (v)))
       call hepmc_vertex_particle_out_iterator_init (it, v)
       if (size (child_barcode) /= 0) then
          do i = 1, size (child_barcode)
             child_barcode(i) = hepmc_particle_get_barcode &
                  (hepmc_vertex_particle_out_iterator_get (it))
             call hepmc_vertex_particle_out_iterator_advance (it)
          end do
          call hepmc_vertex_particle_out_iterator_final (it)
       end if
    else
       allocate (child_barcode (0))
    end if
  end function hepmc_particle_get_child_barcodes

@ %def hepmc_particle_get_parent_barcodes hepmc_particle_get_child_barcodes
@ Return the polarization (assuming that the particle is completely
polarized).  Note that the generated polarization object needs finalization.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function gen_particle_polarization (prt_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj
     end function gen_particle_polarization
  end interface
@ %def gen_particle_polarization
<<HepMC interface: public>>=
  public :: hepmc_particle_get_polarization
<<HepMC interface: procedures>>=
  function hepmc_particle_get_polarization (prt) result (pol)
    type(hepmc_polarization_t) :: pol
    type(hepmc_particle_t), intent(in) :: prt
    pol%obj = gen_particle_polarization (prt%obj)
  end function hepmc_particle_get_polarization

@ %def hepmc_particle_get_polarization
@ Return the particle color as a two-dimensional array (color, anticolor).
<<HepMC interface: interfaces>>=
  interface
     function gen_particle_flow (prt_obj, code_index) result (code) bind(C)
       import
       integer(c_int) :: code
       type(c_ptr), value :: prt_obj
       integer(c_int), value :: code_index
     end function gen_particle_flow
  end interface
@ %def gen_particle_flow
<<HepMC interface: public>>=
  public :: hepmc_particle_get_color
<<HepMC interface: procedures>>=
  function hepmc_particle_get_color (prt) result (col)
    integer, dimension(2) :: col
    type(hepmc_particle_t), intent(in) :: prt
    col(1) = gen_particle_flow (prt%obj, 1)
    col(2) = - gen_particle_flow (prt%obj, 2)
  end function hepmc_particle_get_color

@ %def hepmc_particle_get_color
@
\subsection{GenVertex}
Vertices are made of particles (incoming and outgoing).
<<HepMC interface: public>>=
  public :: hepmc_vertex_t
<<HepMC interface: types>>=
  type :: hepmc_vertex_t
     private
     type(c_ptr) :: obj
  end type hepmc_vertex_t

@ %def hepmc_vertex_t
@ Constructor.  Two versions, one plain, one with the position in
space and time (measured in mm) as argument.  The Fortran version has
initializer form, and the vertex position is an optional argument.

A destructor is unnecessary as long as all vertices are entered into
an event container.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_gen_vertex () bind(C)
       import
     end function new_gen_vertex
  end interface
  interface
     type(c_ptr) function new_gen_vertex_pos (prt_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj
     end function new_gen_vertex_pos
  end interface
@ %def new_gen_vertex new_gen_vertex_pos
<<HepMC interface: public>>=
  public :: hepmc_vertex_init
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_init (v, x)
    type(hepmc_vertex_t), intent(out) :: v
    type(vector4_t), intent(in), optional :: x
    type(hepmc_four_vector_t) :: pos
    if (present (x)) then
       call hepmc_four_vector_init (pos, x)
       v%obj = new_gen_vertex_pos (pos%obj)
       call hepmc_four_vector_final (pos)
    else
       v%obj = new_gen_vertex ()
    end if
  end subroutine hepmc_vertex_init

@ %def hepmc_vertex_init
@ Return true if the vertex pointer is non-null:
<<HepMC interface: interfaces>>=
  interface
     function gen_vertex_is_valid (v_obj) result (flag) bind(C)
       import
       logical(c_bool) :: flag
       type(c_ptr), value :: v_obj
     end function gen_vertex_is_valid
  end interface
@ %def gen_vertex_is_valid
<<HepMC interface: public>>=
  public :: hepmc_vertex_is_valid
<<HepMC interface: procedures>>=
  function hepmc_vertex_is_valid (v) result (flag)
    logical :: flag
    type(hepmc_vertex_t), intent(in) :: v
    flag = gen_vertex_is_valid (v%obj)
  end function hepmc_vertex_is_valid

@ %def hepmc_vertex_is_valid
@ Add a particle to a vertex, incoming or outgoing.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_vertex_add_particle_in (v_obj, prt_obj) bind(C)
       import
       type(c_ptr), value :: v_obj, prt_obj
     end subroutine gen_vertex_add_particle_in
  end interface
  interface
     subroutine gen_vertex_add_particle_out (v_obj, prt_obj) bind(C)
       import
       type(c_ptr), value :: v_obj, prt_obj
     end subroutine gen_vertex_add_particle_out
  end interface
<<HepMC interface: public>>=
  public :: hepmc_vertex_add_particle_in
  public :: hepmc_vertex_add_particle_out
@ %def gen_vertex_add_particle_in gen_vertex_add_particle_out
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_add_particle_in (v, prt)
    type(hepmc_vertex_t), intent(inout) :: v
    type(hepmc_particle_t), intent(in) :: prt
    call gen_vertex_add_particle_in (v%obj, prt%obj)
  end subroutine hepmc_vertex_add_particle_in

  subroutine hepmc_vertex_add_particle_out (v, prt)
    type(hepmc_vertex_t), intent(inout) :: v
    type(hepmc_particle_t), intent(in) :: prt
    call gen_vertex_add_particle_out (v%obj, prt%obj)
  end subroutine hepmc_vertex_add_particle_out

@ %def hepmc_vertex_add_particle_in hepmc_vertex_add_particle_out
@ Return the number of incoming/outgoing particles.
<<HepMC interface: interfaces>>=
  interface
     function gen_vertex_particles_in_size (v_obj) result (size) bind(C)
       import
       integer(c_int) :: size
       type(c_ptr), value :: v_obj
     end function gen_vertex_particles_in_size
  end interface
  interface
     function gen_vertex_particles_out_size (v_obj) result (size) bind(C)
       import
       integer(c_int) :: size
       type(c_ptr), value :: v_obj
     end function gen_vertex_particles_out_size
  end interface
@ %def gen_vertex_particles_in_size gen_vertex_particles_out_size
<<HepMC interface: public>>=
  public :: hepmc_vertex_get_n_in
  public :: hepmc_vertex_get_n_out
<<HepMC interface: procedures>>=
  function hepmc_vertex_get_n_in (v) result (n_in)
    integer :: n_in
    type(hepmc_vertex_t), intent(in) :: v
    n_in = gen_vertex_particles_in_size (v%obj)
  end function hepmc_vertex_get_n_in

  function hepmc_vertex_get_n_out (v) result (n_out)
    integer :: n_out
    type(hepmc_vertex_t), intent(in) :: v
    n_out = gen_vertex_particles_out_size (v%obj)
  end function hepmc_vertex_get_n_out

@ %def hepmc_vertex_n_in hepmc_vertex_n_out
@ 
\subsection{Vertex-particle-in iterator}
This iterator iterates over all incoming particles in an vertex.  We store a
pointer to the vertex in addition to the iterator.  This allows for
simple end checking.

The iterator is actually a constant iterator; it can only read.
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_t
<<HepMC interface: types>>=
  type :: hepmc_vertex_particle_in_iterator_t
     private
     type(c_ptr) :: obj
     type(c_ptr) :: v_obj
  end type hepmc_vertex_particle_in_iterator_t

@ %def hepmc_vertex_particle_in_iterator_t
@ Constructor.  The iterator is initialized at the first particle in
the vertex.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function &
          new_vertex_particles_in_const_iterator (v_obj) bind(C)
       import
       type(c_ptr), value :: v_obj
     end function new_vertex_particles_in_const_iterator
  end interface
@ %def new_vertex_particles_in_const_iterator
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_init
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_in_iterator_init (it, v)
    type(hepmc_vertex_particle_in_iterator_t), intent(out) :: it
    type(hepmc_vertex_t), intent(in) :: v
    it%obj = new_vertex_particles_in_const_iterator (v%obj)
    it%v_obj = v%obj
  end subroutine hepmc_vertex_particle_in_iterator_init

@ %def hepmc_vertex_particle_in_iterator_init
@ Destructor.  Necessary because the iterator is allocated on the
heap.
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_in_const_iterator_delete (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine vertex_particles_in_const_iterator_delete
  end interface
@ %def vertex_particles_in_const_iterator_delete
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_final
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_in_iterator_final (it)
    type(hepmc_vertex_particle_in_iterator_t), intent(inout) :: it
    call vertex_particles_in_const_iterator_delete (it%obj)
  end subroutine hepmc_vertex_particle_in_iterator_final

@ %def hepmc_vertex_particle_in_iterator_final
@ Increment
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_in_const_iterator_advance (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine vertex_particles_in_const_iterator_advance
  end interface
@ %def vertex_particles_in_const_iterator_advance
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_advance
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_in_iterator_advance (it)
    type(hepmc_vertex_particle_in_iterator_t), intent(inout) :: it
    call vertex_particles_in_const_iterator_advance (it%obj)
  end subroutine hepmc_vertex_particle_in_iterator_advance

@ %def hepmc_vertex_particle_in_iterator_advance
@ Reset to the beginning
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_in_const_iterator_reset &
          (it_obj, v_obj) bind(C)
       import
       type(c_ptr), value :: it_obj, v_obj
     end subroutine vertex_particles_in_const_iterator_reset
  end interface
@ %def vertex_particles_in_const_iterator_reset
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_reset
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_in_iterator_reset (it)
    type(hepmc_vertex_particle_in_iterator_t), intent(inout) :: it
    call vertex_particles_in_const_iterator_reset (it%obj, it%v_obj)
  end subroutine hepmc_vertex_particle_in_iterator_reset

@ %def hepmc_vertex_particle_in_iterator_reset
@ Test: return true as long as we are not past the end.
<<HepMC interface: interfaces>>=
  interface
     function vertex_particles_in_const_iterator_is_valid &
          (it_obj, v_obj) result (flag) bind(C)
       import
       logical(c_bool) :: flag
       type(c_ptr), value :: it_obj, v_obj
     end function vertex_particles_in_const_iterator_is_valid
  end interface
@ %def vertex_particles_in_const_iterator_is_valid
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_is_valid
<<HepMC interface: procedures>>=
  function hepmc_vertex_particle_in_iterator_is_valid (it) result (flag)
    logical :: flag
    type(hepmc_vertex_particle_in_iterator_t), intent(in) :: it
    flag = vertex_particles_in_const_iterator_is_valid (it%obj, it%v_obj)
  end function hepmc_vertex_particle_in_iterator_is_valid

@ %def hepmc_vertex_particle_in_iterator_is_valid
@ Return the particle pointed to by the iterator.  (The particle
object should not be finalized, since it contains merely a pointer to
the particle which is owned by the vertex.)
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function &
          vertex_particles_in_const_iterator_get (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end function vertex_particles_in_const_iterator_get
  end interface
@ %def vertex_particles_in_const_iterator_get
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_in_iterator_get
<<HepMC interface: procedures>>=
  function hepmc_vertex_particle_in_iterator_get (it) result (prt)
    type(hepmc_particle_t) :: prt
    type(hepmc_vertex_particle_in_iterator_t), intent(in) :: it
    prt%obj = vertex_particles_in_const_iterator_get (it%obj)
  end function hepmc_vertex_particle_in_iterator_get

@ %def hepmc_vertex_particle_in_iterator_get
@ 
\subsection{Vertex-particle-out iterator}
This iterator iterates over all incoming particles in an vertex.  We store a
pointer to the vertex in addition to the iterator.  This allows for
simple end checking.

The iterator is actually a constant iterator; it can only read.
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_t
<<HepMC interface: types>>=
  type :: hepmc_vertex_particle_out_iterator_t
     private
     type(c_ptr) :: obj
     type(c_ptr) :: v_obj
  end type hepmc_vertex_particle_out_iterator_t

@ %def hepmc_vertex_particle_out_iterator_t
@ Constructor.  The iterator is initialized at the first particle in
the vertex.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function &
          new_vertex_particles_out_const_iterator (v_obj) bind(C)
       import
       type(c_ptr), value :: v_obj
     end function new_vertex_particles_out_const_iterator
  end interface
@ %def new_vertex_particles_out_const_iterator
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_init
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_out_iterator_init (it, v)
    type(hepmc_vertex_particle_out_iterator_t), intent(out) :: it
    type(hepmc_vertex_t), intent(in) :: v
    it%obj = new_vertex_particles_out_const_iterator (v%obj)
    it%v_obj = v%obj
  end subroutine hepmc_vertex_particle_out_iterator_init

@ %def hepmc_vertex_particle_out_iterator_init
@ Destructor.  Necessary because the iterator is allocated on the
heap.
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_out_const_iterator_delete (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine vertex_particles_out_const_iterator_delete
  end interface
@ %def vertex_particles_out_const_iterator_delete
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_final
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_out_iterator_final (it)
    type(hepmc_vertex_particle_out_iterator_t), intent(inout) :: it
    call vertex_particles_out_const_iterator_delete (it%obj)
  end subroutine hepmc_vertex_particle_out_iterator_final

@ %def hepmc_vertex_particle_out_iterator_final
@ Increment
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_out_const_iterator_advance (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine vertex_particles_out_const_iterator_advance
  end interface
@ %def vertex_particles_out_const_iterator_advance
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_advance
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_out_iterator_advance (it)
    type(hepmc_vertex_particle_out_iterator_t), intent(inout) :: it
    call vertex_particles_out_const_iterator_advance (it%obj)
  end subroutine hepmc_vertex_particle_out_iterator_advance

@ %def hepmc_vertex_particle_out_iterator_advance
@ Reset to the beginning
<<HepMC interface: interfaces>>=
  interface
     subroutine vertex_particles_out_const_iterator_reset &
          (it_obj, v_obj) bind(C)
       import
       type(c_ptr), value :: it_obj, v_obj
     end subroutine vertex_particles_out_const_iterator_reset
  end interface
@ %def vertex_particles_out_const_iterator_reset
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_reset
<<HepMC interface: procedures>>=
  subroutine hepmc_vertex_particle_out_iterator_reset (it)
    type(hepmc_vertex_particle_out_iterator_t), intent(inout) :: it
    call vertex_particles_out_const_iterator_reset (it%obj, it%v_obj)
  end subroutine hepmc_vertex_particle_out_iterator_reset

@ %def hepmc_vertex_particle_out_iterator_reset
@ Test: return true as long as we are not past the end.
<<HepMC interface: interfaces>>=
  interface
     function vertex_particles_out_const_iterator_is_valid &
          (it_obj, v_obj) result (flag) bind(C)
       import
       logical(c_bool) :: flag
       type(c_ptr), value :: it_obj, v_obj
     end function vertex_particles_out_const_iterator_is_valid
  end interface
@ %def vertex_particles_out_const_iterator_is_valid
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_is_valid
<<HepMC interface: procedures>>=
  function hepmc_vertex_particle_out_iterator_is_valid (it) result (flag)
    logical :: flag
    type(hepmc_vertex_particle_out_iterator_t), intent(in) :: it
    flag = vertex_particles_out_const_iterator_is_valid (it%obj, it%v_obj)
  end function hepmc_vertex_particle_out_iterator_is_valid

@ %def hepmc_vertex_particle_out_iterator_is_valid
@ Return the particle pointed to by the iterator.  (The particle
object should not be finalized, since it contains merely a pointer to
the particle which is owned by the vertex.)
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function &
          vertex_particles_out_const_iterator_get (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end function vertex_particles_out_const_iterator_get
  end interface
@ %def vertex_particles_out_const_iterator_get
<<HepMC interface: public>>=
  public :: hepmc_vertex_particle_out_iterator_get
<<HepMC interface: procedures>>=
  function hepmc_vertex_particle_out_iterator_get (it) result (prt)
    type(hepmc_particle_t) :: prt
    type(hepmc_vertex_particle_out_iterator_t), intent(in) :: it
    prt%obj = vertex_particles_out_const_iterator_get (it%obj)
  end function hepmc_vertex_particle_out_iterator_get

@ %def hepmc_vertex_particle_out_iterator_get
@
\subsection{GenEvent}
The main object of HepMC is a GenEvent.  The object is filled by
GenVertex objects, which in turn contain GenParticle objects.
<<HepMC interface: public>>=
  public :: hepmc_event_t
<<HepMC interface: types>>=
  type :: hepmc_event_t
     private
     type(c_ptr) :: obj
  end type hepmc_event_t

@ %def hepmc_event_t
@ Constructor.  Arguments are process ID (integer) and event ID
(integer).

The Fortran version has initializer form.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_gen_event (proc_id, event_id) bind(C)
       import
       integer(c_int), value :: proc_id, event_id
     end function new_gen_event
  end interface
@ %def new_gen_event
<<HepMC interface: public>>=
  public :: hepmc_event_init
<<HepMC interface: procedures>>=
  subroutine hepmc_event_init (evt, proc_id, event_id)
    type(hepmc_event_t), intent(out) :: evt
    integer, intent(in), optional :: proc_id, event_id
    integer(c_int) :: pid, eid
    pid = 0;  if (present (proc_id))  pid = proc_id
    eid = 0;  if (present (event_id)) eid = event_id
    evt%obj = new_gen_event (pid, eid)
  end subroutine hepmc_event_init

@ %def hepmc_event_init
@ Destructor.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_delete (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end subroutine gen_event_delete
  end interface
@ %def gen_event_delete
<<HepMC interface: public>>=
  public :: hepmc_event_final
<<HepMC interface: procedures>>=
  subroutine hepmc_event_final (evt)
    type(hepmc_event_t), intent(inout) :: evt
    call gen_event_delete (evt%obj)
  end subroutine hepmc_event_final

@ %def hepmc_event_final
@ Screen output.  Printing to file is possible in principle (using a
C++ output channel), by allowing an argument.  Printing to an open
Fortran unit is obviously not possible.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_print (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end subroutine gen_event_print
  end interface
@ %def gen_event_print
<<HepMC interface: public>>=
  public :: hepmc_event_print
<<HepMC interface: procedures>>=
  subroutine hepmc_event_print (evt)
    type(hepmc_event_t), intent(in) :: evt
    call gen_event_print (evt%obj)
  end subroutine hepmc_event_print
    
@ %def hepmc_event_print
@ Get the event number.
<<HepMC interface: interfaces>>=
  interface
     integer(c_int) function gen_event_event_number (evt_obj) bind(C)
       use iso_c_binding !NODEP!
       type(c_ptr), value :: evt_obj
     end function gen_event_event_number
  end interface
@ %def gen_event_event_number
<<HepMC interface: public>>=
  public :: hepmc_event_get_event_index
<<HepMC interface: procedures>>=
  function hepmc_event_get_event_index (evt) result (i_proc)
    integer :: i_proc
    type(hepmc_event_t), intent(in) :: evt
    i_proc = gen_event_event_number (evt%obj)
  end function hepmc_event_get_event_index

@ %def hepmc_event_get_event_index
@ Set the numeric signal process ID
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_signal_process_id (evt_obj, proc_id) bind(C)
       import
       type(c_ptr), value :: evt_obj
       integer(c_int), value :: proc_id
     end subroutine gen_event_set_signal_process_id
  end interface
@ %def gen_event_set_signal_process_id
<<HepMC interface: public>>=
  public :: hepmc_event_set_process_id
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_process_id (evt, proc)
    type(hepmc_event_t), intent(in) :: evt
    integer, intent(in) :: proc
    integer(c_int) :: i_proc
    i_proc = proc
    call gen_event_set_signal_process_id (evt%obj, i_proc)
  end subroutine hepmc_event_set_process_id

@ %def hepmc_event_set_process_id
@ Get the numeric signal process ID
<<HepMC interface: interfaces>>=
  interface
     integer(c_int) function gen_event_signal_process_id (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end function gen_event_signal_process_id
  end interface
@ %def gen_event_signal_process_id
<<HepMC interface: public>>=
  public :: hepmc_event_get_process_id
<<HepMC interface: procedures>>=
  function hepmc_event_get_process_id (evt) result (i_proc)
    integer :: i_proc
    type(hepmc_event_t), intent(in) :: evt
    i_proc = gen_event_signal_process_id (evt%obj)
  end function hepmc_event_get_process_id

@ %def hepmc_event_get_process_id
@ Set the event energy scale
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_event_scale (evt_obj, scale) bind(C)
       import
       type(c_ptr), value :: evt_obj
       real(c_double), value :: scale
     end subroutine gen_event_set_event_scale
  end interface
@ %def gen_event_set_event_scale
<<HepMC interface: public>>=
  public :: hepmc_event_set_scale
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_scale (evt, scale)
    type(hepmc_event_t), intent(in) :: evt
    real(default), intent(in) :: scale
    real(c_double) :: cscale
    cscale = scale
    call gen_event_set_event_scale (evt%obj, cscale)
  end subroutine hepmc_event_set_scale

@ %def hepmc_event_set_scale
@ Get the event energy scale
<<HepMC interface: interfaces>>=
  interface
     real(c_double) function gen_event_event_scale (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end function gen_event_event_scale
  end interface
@ %def gen_event_event_scale
<<HepMC interface: public>>=
  public :: hepmc_event_get_scale
<<HepMC interface: procedures>>=
  function hepmc_event_get_scale (evt) result (scale)
    real(default) :: scale
    type(hepmc_event_t), intent(in) :: evt
    scale = gen_event_event_scale (evt%obj)
  end function hepmc_event_get_scale

@ %def hepmc_event_set_scale
@ Set the value of $\alpha_{\rm QCD}$.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_alpha_qcd (evt_obj, a) bind(C)
       import
       type(c_ptr), value :: evt_obj
       real(c_double), value :: a
     end subroutine gen_event_set_alpha_qcd
  end interface
@ %def gen_event_set_alpha_qcd
<<HepMC interface: public>>=
  public :: hepmc_event_set_alpha_qcd
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_alpha_qcd (evt, alpha)
    type(hepmc_event_t), intent(in) :: evt
    real(default), intent(in) :: alpha
    real(c_double) :: a
    a = alpha
    call gen_event_set_alpha_qcd (evt%obj, a)
  end subroutine hepmc_event_set_alpha_qcd

@ %def hepmc_event_set_alpha_qcd
@ Get the value of $\alpha_{\rm QCD}$.
<<HepMC interface: interfaces>>=
  interface
     real(c_double) function gen_event_alpha_qcd (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end function gen_event_alpha_qcd
  end interface
@ %def gen_event_get_alpha_qcd
<<HepMC interface: public>>=
  public :: hepmc_event_get_alpha_qcd
<<HepMC interface: procedures>>=
  function hepmc_event_get_alpha_qcd (evt) result (alpha)
    real(default) :: alpha
    type(hepmc_event_t), intent(in) :: evt
    alpha = gen_event_alpha_qcd (evt%obj)
  end function hepmc_event_get_alpha_qcd

@ %def hepmc_event_get_alpha_qcd
@ Set the value of $\alpha_{\rm QED}$.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_alpha_qed (evt_obj, a) bind(C)
       import
       type(c_ptr), value :: evt_obj
       real(c_double), value :: a
     end subroutine gen_event_set_alpha_qed
  end interface
@ %def gen_event_set_alpha_qed
<<HepMC interface: public>>=
  public :: hepmc_event_set_alpha_qed
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_alpha_qed (evt, alpha)
    type(hepmc_event_t), intent(in) :: evt
    real(default), intent(in) :: alpha
    real(c_double) :: a
    a = alpha
    call gen_event_set_alpha_qed (evt%obj, a)
  end subroutine hepmc_event_set_alpha_qed

@ %def hepmc_event_set_alpha_qed
@ Get the value of $\alpha_{\rm QED}$.
<<HepMC interface: interfaces>>=
  interface
     real(c_double) function gen_event_alpha_qed (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end function gen_event_alpha_qed
  end interface
@ %def gen_event_get_alpha_qed
<<HepMC interface: public>>=
  public :: hepmc_event_get_alpha_qed
<<HepMC interface: procedures>>=
  function hepmc_event_get_alpha_qed (evt) result (alpha)
    real(default) :: alpha
    type(hepmc_event_t), intent(in) :: evt
    alpha = gen_event_alpha_qed (evt%obj)
  end function hepmc_event_get_alpha_qed

@ %def hepmc_event_get_alpha_qed
@ Clear a weight value to the end of the weight container.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_clear_weights (evt_obj) bind(C)
       use iso_c_binding !NODEP!
       type(c_ptr), value :: evt_obj
     end subroutine gen_event_clear_weights
  end interface
@ %def gen_event_set_alpha_qed
<<HepMC interface: public>>=
  public :: hepmc_event_clear_weights
<<HepMC interface: procedures>>=
  subroutine hepmc_event_clear_weights (evt)
    type(hepmc_event_t), intent(in) :: evt
    call gen_event_clear_weights (evt%obj)
  end subroutine hepmc_event_clear_weights

@ %def hepmc_event_clear_weights
@ Add a weight value to the end of the weight container.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_add_weight (evt_obj, w) bind(C)
       use iso_c_binding !NODEP!
       type(c_ptr), value :: evt_obj
       real(c_double), value :: w
     end subroutine gen_event_add_weight
  end interface
@ %def gen_event_set_alpha_qed
<<HepMC interface: public>>=
  public :: hepmc_event_add_weight
<<HepMC interface: procedures>>=
  subroutine hepmc_event_add_weight (evt, weight)
    type(hepmc_event_t), intent(in) :: evt
    real(default), intent(in) :: weight
    real(c_double) :: w
    w = weight
    call gen_event_add_weight (evt%obj, w)
  end subroutine hepmc_event_add_weight

@ %def hepmc_event_add_weight
@ Get the size of the weight container (the number of valid elements).
<<HepMC interface: interfaces>>=
  interface
     integer(c_int) function gen_event_weights_size (evt_obj) bind(C)
       use iso_c_binding !NODEP!
       type(c_ptr), value :: evt_obj
     end function gen_event_weights_size
  end interface
@ %def gen_event_get_weight
<<HepMC interface: public>>=
  public :: hepmc_event_get_weights_size
<<HepMC interface: procedures>>=
  function hepmc_event_get_weights_size (evt) result (n)
    integer :: n
    type(hepmc_event_t), intent(in) :: evt
    n = gen_event_weights_size (evt%obj)
  end function hepmc_event_get_weights_size

@ %def hepmc_event_get_weights_size
@ Get the value of the weight with index [[i]].  (Count from 1, while C counts
from zero.)
<<HepMC interface: interfaces>>=
  interface
     real(c_double) function gen_event_weight (evt_obj, i) bind(C)
       use iso_c_binding !NODEP!
       type(c_ptr), value :: evt_obj
       integer(c_int), value :: i
     end function gen_event_weight
  end interface
@ %def gen_event_get_weight
<<HepMC interface: public>>=
  public :: hepmc_event_get_weight
<<HepMC interface: procedures>>=
  function hepmc_event_get_weight (evt, index) result (weight)
    real(default) :: weight
    type(hepmc_event_t), intent(in) :: evt
    integer, intent(in) :: index
    integer(c_int) :: i
    i = index - 1
    weight = gen_event_weight (evt%obj, i)
  end function hepmc_event_get_weight

@ %def hepmc_event_get_weight
@ Add a vertex to the event container.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_add_vertex (evt_obj, v_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
       type(c_ptr), value :: v_obj
     end subroutine gen_event_add_vertex
  end interface
@ %def gen_event_add_vertex
<<HepMC interface: public>>=
  public :: hepmc_event_add_vertex
<<HepMC interface: procedures>>=
  subroutine hepmc_event_add_vertex (evt, v)
    type(hepmc_event_t), intent(inout) :: evt
    type(hepmc_vertex_t), intent(in) :: v
    call gen_event_add_vertex (evt%obj, v%obj)
  end subroutine hepmc_event_add_vertex

@ %def hepmc_event_add_vertex
@ Mark a particular vertex as the signal process (hard interaction).
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_signal_process_vertex (evt_obj, v_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
       type(c_ptr), value :: v_obj
     end subroutine gen_event_set_signal_process_vertex
  end interface
@ %def gen_event_set_signal_process_vertex
<<HepMC interface: public>>=
  public :: hepmc_event_set_signal_process_vertex
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_signal_process_vertex (evt, v)
    type(hepmc_event_t), intent(inout) :: evt
    type(hepmc_vertex_t), intent(in) :: v
    call gen_event_set_signal_process_vertex (evt%obj, v%obj)
  end subroutine hepmc_event_set_signal_process_vertex

@ %def hepmc_event_set_signal_process_vertex
@ Set the beam particles explicitly.
<<HepMC interface: public>>=
  public :: hepmc_event_set_beam_particles
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_beam_particles (evt, prt1, prt2)
    type(hepmc_event_t), intent(inout) :: evt
    type(hepmc_particle_t), intent(in) :: prt1, prt2
    logical(c_bool) :: flag
    flag = gen_event_set_beam_particles (evt%obj, prt1%obj, prt2%obj)
  end subroutine hepmc_event_set_beam_particles

@ %def hepmc_event_set_beam_particles
@ The C function returns a boolean which we do not use.
<<HepMC interface: interfaces>>=
  interface
     logical(c_bool) function gen_event_set_beam_particles &
          (evt_obj, prt1_obj, prt2_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj, prt1_obj, prt2_obj
     end function gen_event_set_beam_particles
  end interface

@ %def gen_event_set_beam_particles
@ Set the cross section and error explicitly.  Note that HepMC uses
pb, while WHIZARD uses fb.
<<HepMC interface: public>>=
  public :: hepmc_event_set_cross_section
<<HepMC interface: procedures>>=
  subroutine hepmc_event_set_cross_section (evt, xsec, xsec_err)
    type(hepmc_event_t), intent(inout) :: evt
    real(default), intent(in) :: xsec, xsec_err
    call gen_event_set_cross_section &
         (evt%obj, &
         real (xsec * 1e-3_default, c_double), &
         real (xsec_err * 1e-3_default, c_double))
  end subroutine hepmc_event_set_cross_section

@ %def hepmc_event_set_cross_section
@ The C function returns a boolean which we do not use.
<<HepMC interface: interfaces>>=
  interface
     subroutine gen_event_set_cross_section (evt_obj, xs, xs_err) bind(C)
       import
       type(c_ptr), value :: evt_obj
       real(c_double), value :: xs, xs_err
     end subroutine gen_event_set_cross_section
  end interface

@ %def gen_event_set_cross_section
@ 
\subsection{Event-particle iterator}
This iterator iterates over all particles in an event.  We store a
pointer to the event in addition to the iterator.  This allows for
simple end checking.

The iterator is actually a constant iterator; it can only read.
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_t
<<HepMC interface: types>>=
  type :: hepmc_event_particle_iterator_t
     private
     type(c_ptr) :: obj
     type(c_ptr) :: evt_obj
  end type hepmc_event_particle_iterator_t

@ %def hepmc_event_particle_iterator_t
@ Constructor.  The iterator is initialized at the first particle in
the event.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_event_particle_const_iterator (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end function new_event_particle_const_iterator
  end interface
@ %def new_event_particle_const_iterator
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_init
<<HepMC interface: procedures>>=
  subroutine hepmc_event_particle_iterator_init (it, evt)
    type(hepmc_event_particle_iterator_t), intent(out) :: it
    type(hepmc_event_t), intent(in) :: evt
    it%obj = new_event_particle_const_iterator (evt%obj)
    it%evt_obj = evt%obj
  end subroutine hepmc_event_particle_iterator_init

@ %def hepmc_event_particle_iterator_init
@ Destructor.  Necessary because the iterator is allocated on the
heap.
<<HepMC interface: interfaces>>=
  interface
     subroutine event_particle_const_iterator_delete (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine event_particle_const_iterator_delete
  end interface
@ %def event_particle_const_iterator_delete
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_final
<<HepMC interface: procedures>>=
  subroutine hepmc_event_particle_iterator_final (it)
    type(hepmc_event_particle_iterator_t), intent(inout) :: it
    call event_particle_const_iterator_delete (it%obj)
  end subroutine hepmc_event_particle_iterator_final

@ %def hepmc_event_particle_iterator_final
@ Increment
<<HepMC interface: interfaces>>=
  interface
     subroutine event_particle_const_iterator_advance (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end subroutine event_particle_const_iterator_advance
  end interface
@ %def event_particle_const_iterator_advance
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_advance
<<HepMC interface: procedures>>=
  subroutine hepmc_event_particle_iterator_advance (it)
    type(hepmc_event_particle_iterator_t), intent(inout) :: it
    call event_particle_const_iterator_advance (it%obj)
  end subroutine hepmc_event_particle_iterator_advance

@ %def hepmc_event_particle_iterator_advance
@ Reset to the beginning
<<HepMC interface: interfaces>>=
  interface
     subroutine event_particle_const_iterator_reset (it_obj, evt_obj) bind(C)
       import
       type(c_ptr), value :: it_obj, evt_obj
     end subroutine event_particle_const_iterator_reset
  end interface
@ %def event_particle_const_iterator_reset
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_reset
<<HepMC interface: procedures>>=
  subroutine hepmc_event_particle_iterator_reset (it)
    type(hepmc_event_particle_iterator_t), intent(inout) :: it
    call event_particle_const_iterator_reset (it%obj, it%evt_obj)
  end subroutine hepmc_event_particle_iterator_reset

@ %def hepmc_event_particle_iterator_reset
@ Test: return true as long as we are not past the end.
<<HepMC interface: interfaces>>=
  interface
     function event_particle_const_iterator_is_valid &
          (it_obj, evt_obj) result (flag) bind(C)
       import
       logical(c_bool) :: flag
       type(c_ptr), value :: it_obj, evt_obj
     end function event_particle_const_iterator_is_valid
  end interface
@ %def event_particle_const_iterator_is_valid
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_is_valid
<<HepMC interface: procedures>>=
  function hepmc_event_particle_iterator_is_valid (it) result (flag)
    logical :: flag
    type(hepmc_event_particle_iterator_t), intent(in) :: it
    flag = event_particle_const_iterator_is_valid (it%obj, it%evt_obj)
  end function hepmc_event_particle_iterator_is_valid

@ %def hepmc_event_particle_iterator_is_valid
@ Return the particle pointed to by the iterator.  (The particle
object should not be finalized, since it contains merely a pointer to
the particle which is owned by the vertex.)
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function event_particle_const_iterator_get (it_obj) bind(C)
       import
       type(c_ptr), value :: it_obj
     end function event_particle_const_iterator_get
  end interface
@ %def event_particle_const_iterator_get
<<HepMC interface: public>>=
  public :: hepmc_event_particle_iterator_get
<<HepMC interface: procedures>>=
  function hepmc_event_particle_iterator_get (it) result (prt)
    type(hepmc_particle_t) :: prt
    type(hepmc_event_particle_iterator_t), intent(in) :: it
    prt%obj = event_particle_const_iterator_get (it%obj)
  end function hepmc_event_particle_iterator_get

@ %def hepmc_event_particle_iterator_get
@
\subsection{I/O streams}
There is a specific I/O stream type for handling the output of
GenEvent objects (i.e., Monte Carlo event samples) to file.  Opening
the file is done by the constructor, closing by the destructor.
<<HepMC interface: public>>=
  public :: hepmc_iostream_t
<<HepMC interface: types>>=
  type :: hepmc_iostream_t
     private
     type(c_ptr) :: obj
  end type hepmc_iostream_t

@ %def hepmc_iostream_t
@ Constructor for an output stream associated to a file.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_io_gen_event_out (filename) bind(C)
       import
       character(c_char), dimension(*), intent(in) :: filename
     end function new_io_gen_event_out
  end interface
@ %def new_io_gen_event
<<HepMC interface: public>>=
  public :: hepmc_iostream_open_out
<<HepMC interface: procedures>>=
  subroutine hepmc_iostream_open_out (iostream, filename)
    type(hepmc_iostream_t), intent(out) :: iostream
    type(string_t), intent(in) :: filename
    iostream%obj = new_io_gen_event_out (char (filename) // c_null_char)
  end subroutine hepmc_iostream_open_out

@ %def hepmc_iostream_open_out
@ Constructor for an input stream associated to a file.
<<HepMC interface: interfaces>>=
  interface
     type(c_ptr) function new_io_gen_event_in (filename) bind(C)
       import
       character(c_char), dimension(*), intent(in) :: filename
     end function new_io_gen_event_in
  end interface
@ %def new_io_gen_event
<<HepMC interface: public>>=
  public :: hepmc_iostream_open_in
<<HepMC interface: procedures>>=
  subroutine hepmc_iostream_open_in (iostream, filename)
    type(hepmc_iostream_t), intent(out) :: iostream
    type(string_t), intent(in) :: filename
    iostream%obj = new_io_gen_event_in (char (filename) // c_null_char)
  end subroutine hepmc_iostream_open_in

@ %def hepmc_iostream_open_in
@ Destructor:
<<HepMC interface: interfaces>>=
  interface
     subroutine io_gen_event_delete (io_obj) bind(C)
       import
       type(c_ptr), value :: io_obj
     end subroutine io_gen_event_delete
  end interface
@ %def io_gen_event_delete
<<HepMC interface: public>>=
  public :: hepmc_iostream_close
<<HepMC interface: procedures>>=
  subroutine hepmc_iostream_close (iostream)
    type(hepmc_iostream_t), intent(inout) :: iostream
    call io_gen_event_delete (iostream%obj)
  end subroutine hepmc_iostream_close

@ %def hepmc_iostream_close
@ Write a single event to the I/O stream.
<<HepMC interface: interfaces>>=
  interface
     subroutine io_gen_event_write_event (io_obj, evt_obj) bind(C)
       import
       type(c_ptr), value :: io_obj, evt_obj
     end subroutine io_gen_event_write_event
  end interface
@ %def io_gen_event_write_event
<<HepMC interface: public>>=
  public :: hepmc_iostream_write_event
<<HepMC interface: procedures>>=
  subroutine hepmc_iostream_write_event (iostream, evt)
    type(hepmc_iostream_t), intent(inout) :: iostream
    type(hepmc_event_t), intent(in) :: evt
    call io_gen_event_write_event (iostream%obj, evt%obj)
  end subroutine hepmc_iostream_write_event

@ %def hepmc_iostream_write_event
@ Read a single event from the I/O stream.  Return true if successful.
<<HepMC interface: interfaces>>=
  interface
     logical(c_bool) function io_gen_event_read_event (io_obj, evt_obj) bind(C)
       import
       type(c_ptr), value :: io_obj, evt_obj
     end function io_gen_event_read_event
  end interface
@ %def io_gen_event_read_event
<<HepMC interface: public>>=
  public :: hepmc_iostream_read_event
<<HepMC interface: procedures>>=
  subroutine hepmc_iostream_read_event (iostream, evt, ok)
    type(hepmc_iostream_t), intent(inout) :: iostream
    type(hepmc_event_t), intent(inout) :: evt
    logical, intent(out) :: ok
    ok = io_gen_event_read_event (iostream%obj, evt%obj)
  end subroutine hepmc_iostream_read_event

@ %def hepmc_iostream_read_event
@ 
\subsection{Unit tests}
This test example is an abridged version from the build-from-scratch
example in the HepMC distribution.  We create two vertices for $p\to
q$ PDF splitting, then a vertex for a $qq\to W^-g$ hard-interaction
process, and finally a vertex for $W^-\to qq$ decay.  The setup is for
LHC kinematics.

Extending the original example, we set color flow for the incoming
quarks and polarization for the outgoing photon.  For the latter, we
have to define a particle-data object for the photon, so a flavor
object can be correctly initialized.
<<HepMC interface: public>>=
  public :: hepmc_test
<<HepMC interface: procedures>>=
  subroutine hepmc_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<HepMC interface: execute tests>>
  end subroutine hepmc_test
  
@  %def hepmc_test
@ 
<<HepMC interface: execute tests>>=
  call test (hepmc_interface_1, "hepmc_interface_1", &
       "check HepMC interface", &
       u, results)
<<HepMC interface: tests>>=
  subroutine hepmc_interface_1 (u)
    use physics_defs, only: VECTOR
    use model_data, only: field_data_t
    integer, intent(in) :: u
    integer :: u_file, iostat
    type(hepmc_event_t) :: evt
    type(hepmc_vertex_t) :: v1, v2, v3, v4
    type(hepmc_particle_t) :: prt1, prt2, prt3, prt4, prt5, prt6, prt7, prt8
    type(hepmc_iostream_t) :: iostream
    type(flavor_t) :: flv
    type(color_t) :: col
    type(polarization_t) :: pol
    type(field_data_t), target :: photon_data
    character(80) :: buffer    

    write (u, "(A)")  "* Test output: HepMC interface"
    write (u, "(A)")  "*   Purpose: test HepMC interface"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Initialization"
    write (u, "(A)")
    
    ! Initialize a photon flavor object and some polarization
    call photon_data%init (var_str ("PHOTON"), 22)
    call photon_data%set (spin_type=VECTOR)
    call photon_data%freeze ()
    call flavor_init (flv, photon_data)
    call polarization_init_angles &
         (pol, flv, 0.6_default, 1._default, 0.5_default)

    ! Event initialization
    call hepmc_event_init (evt, 20, 1)

    write (u, "(A)")  "* p -> q splitting"
    write (u, "(A)")
            
    ! $p\to q$ splittings
    call hepmc_vertex_init (v1)
    call hepmc_event_add_vertex (evt, v1)
    call hepmc_vertex_init (v2)
    call hepmc_event_add_vertex (evt, v2)
    call particle_init (prt1, &
         0._default, 0._default, 7000._default, 7000._default, &
         2212, 3)
    call hepmc_vertex_add_particle_in (v1, prt1)
    call particle_init (prt2, &
         0._default, 0._default,-7000._default, 7000._default, &
         2212, 3)
    call hepmc_vertex_add_particle_in (v2, prt2)
    call particle_init (prt3, &
         .750_default, -1.569_default, 32.191_default, 32.238_default, &
         1, 3)
    call color_init_from_array (col, [501])
    call hepmc_particle_set_color (prt3, col)
    call hepmc_vertex_add_particle_out (v1, prt3)
    call particle_init (prt4, &
         -3.047_default, -19._default, -54.629_default, 57.920_default, &
         -2, 3)
    call color_init_from_array (col, [-501])
    call hepmc_particle_set_color (prt4, col)
    call hepmc_vertex_add_particle_out (v2, prt4)

    write (u, "(A)")  "* Hard interaction"
    write (u, "(A)")
        
    ! Hard interaction
    call hepmc_vertex_init (v3)
    call hepmc_event_add_vertex (evt, v3)
    call hepmc_vertex_add_particle_in (v3, prt3)
    call hepmc_vertex_add_particle_in (v3, prt4)
    call particle_init (prt6, &
         -3.813_default, 0.113_default, -1.833_default, 4.233_default, &
         22, 1)
    call hepmc_particle_set_polarization (prt6, pol)
    call hepmc_vertex_add_particle_out (v3, prt6)
    call particle_init (prt5, &
         1.517_default, -20.68_default, -20.605_default, 85.925_default, &
         -24, 3)
    call hepmc_vertex_add_particle_out (v3, prt5)
    call hepmc_event_set_signal_process_vertex (evt, v3)
    
    ! $W^-$ decay
    call vertex_init_pos (v4, &
         0.12_default, -0.3_default, 0.05_default, 0.004_default)
    call hepmc_event_add_vertex (evt, v4)
    call hepmc_vertex_add_particle_in (v4, prt5)
    call particle_init (prt7, &
         -2.445_default, 28.816_default, 6.082_default, 29.552_default, &
         1, 1)
    call hepmc_vertex_add_particle_out (v4, prt7)
    call particle_init (prt8, &
         3.962_default, -49.498_default, -26.687_default, 56.373_default, &
         -2, 1)
    call hepmc_vertex_add_particle_out (v4, prt8)
    
    ! Event output
    call hepmc_event_print (evt)
    write (u, "(A)")  "Writing to file 'hepmc_test.hepmc'"
    write (u, "(A)")
    
    call hepmc_iostream_open_out (iostream , var_str ("hepmc_test.hepmc"))
    call hepmc_iostream_write_event (iostream, evt)
    call hepmc_iostream_close (iostream)

    write (u, "(A)")  "Writing completed"
    
    write (u, "(A)")
    write (u, "(A)")  "* File contents:"
    write (u, "(A)")

    u_file = free_unit ()
    open (u_file, file = "hepmc_test.hepmc", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (buffer(1:14) == "HepMC::Version")  buffer = "[...]"
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")
        
    ! Wrapup
    call polarization_final (pol)
    call hepmc_event_final (evt)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: hepmc_interface_1"        
    
  contains

    subroutine vertex_init_pos (v, x, y, z, t)
      type(hepmc_vertex_t), intent(out) :: v
      real(default), intent(in) :: x, y, z, t
      type(vector4_t) :: xx
      xx = vector4_moving (t, vector3_moving ([x, y, z]))
      call hepmc_vertex_init (v, xx)
    end subroutine vertex_init_pos

    subroutine particle_init (prt, px, py, pz, E, pdg, status)
      type(hepmc_particle_t), intent(out) :: prt
      real(default), intent(in) :: px, py, pz, E
      integer, intent(in) :: pdg, status
      type(vector4_t) :: p
      p = vector4_moving (E, vector3_moving ([px, py, pz]))
      call hepmc_particle_init (prt, p, pdg, status)
    end subroutine particle_init

  end subroutine hepmc_interface_1

@ %def hepmc_interface_1
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{LCIO events}
This section provides the interface to the LCIO C++ library for handling
Monte-Carlo events.

Each C++ class of LCIO that we use is mirrored by a Fortran type,
which contains as its only component the C pointer to the C++ object.

Each C++ method of LCIO that we use has a C wrapper function.  This
function takes a pointer to the host object as its first argument.
Further arguments are either C pointers, or in the case of simple
types (integer, real), interoperable C/Fortran objects.

The C wrapper functions have explicit interfaces in the Fortran
module.  They are called by Fortran wrapper procedures.  These are
treated as methods of the corresponding Fortran type.
<<[[lcio_interface.f90]]>>=
<<File header>>

module lcio_interface

  use, intrinsic :: iso_c_binding !NODEP!
  
<<Use kinds>>
<<Use strings>>
  use io_units
!!  use constants
  use lorentz
!!  use unit_tests
!!  use model_data
!!  use flavors
  use colors
!!  use helicities
!!  use quantum_numbers
!!  use polarizations

<<Standard module head>>

<<LCIO interface: public>>

<<LCIO interface: types>>

<<LCIO interface: interfaces>>

contains

<<LCIO interface: procedures>>

<<LCIO interface: tests>>

end module lcio_interface
@ %def lcio_interface
@ 
\subsection{Interface check}
This function can be called in order to verify that we are using the
actual LCIO library, and not the dummy version.
<<LCIO interface: interfaces>>=
  interface
     logical(c_bool) function lcio_available () bind(C)
       import
     end function lcio_available
  end interface
<<LCIO interface: public>>=
  public :: lcio_is_available
<<LCIO interface: procedures>>=
  function lcio_is_available () result (flag)
    logical :: flag
    flag = lcio_available ()
  end function lcio_is_available

@ %def lcio_is_available
@ 
\subsection{LCIO Run Header}
This is a type for the run header of the LCIO file.
<<LCIO interface: public>>=
  public :: lcio_run_header_t
<<LCIO interface: types>>=
  type :: lcio_run_header_t
     private
     type(c_ptr) :: obj
  end type lcio_run_header_t

@ %def lcio_run_header_t 
The Fortran version has initializer form.
<<LCIO interface: interfaces>>=
  interface
     type(c_ptr) function new_lcio_run_header (proc_id) bind(C)
       import
       integer(c_int), value :: proc_id
     end function new_lcio_run_header
  end interface
@ %def new_lcio_run_header
<<LCIO interface: interfaces>>=
  interface
     subroutine run_header_set_simstring &
          (runhdr_obj, simstring) bind(C)
       import
       type(c_ptr), value :: runhdr_obj
       character(c_char), dimension(*), intent(in) :: simstring
     end subroutine run_header_set_simstring
  end interface
@ %def run_header_set_simstring
<<LCIO interface: public>>=
  public :: lcio_run_header_init
<<LCIO interface: procedures>>=
  subroutine lcio_run_header_init (runhdr, proc_id)
    type(lcio_run_header_t), intent(out) :: runhdr
    integer, intent(in), optional :: proc_id
    integer(c_int) :: pid
    pid = 0;  if (present (proc_id))  pid = proc_id
    runhdr%obj = new_lcio_run_header (pid)
    call run_header_set_simstring (runhdr%obj, &
         "WHIZARD version:" // "<<Version>>")
  end subroutine lcio_run_header_init

@ %def lcio_run_header_init
@
<<LCIO interface: interfaces>>=
  interface
     subroutine write_run_header (lcwrt_obj, runhdr_obj) bind(C)
       import
       type(c_ptr), value :: lcwrt_obj
       type(c_ptr), value :: runhdr_obj
     end subroutine write_run_header
  end interface
@ %def write_run_header
<<LCIO interface: public>>=
  public :: lcio_run_header_write
<<LCIO interface: procedures>>=
  subroutine lcio_run_header_write (wrt, hdr)
    type(lcio_writer_t), intent(inout) :: wrt
    type(lcio_run_header_t), intent(inout) :: hdr
    call write_run_header (wrt%obj, hdr%obj)
  end subroutine lcio_run_header_write

@ %def lcio_run_header_write 
@
\subsection{LCIO Event and LC Collection}
The main object of LCIO is a LCEventImpl.  The object is filled by
MCParticle objects, which are set as LCCollection.
<<LCIO interface: public>>=
  public :: lccollection_t
<<LCIO interface: types>>=
  type :: lccollection_t
     private
     type(c_ptr) :: obj
  end type lccollection_t

@ %def lccollection_t
@ Initializer.
<<LCIO interface: interfaces>>=
  interface
     type(c_ptr) function new_lccollection () bind(C)
       import
     end function new_lccollection
  end interface
@ %def new_lccollection
<<LCIO interface: public>>=
  public :: lcio_event_t
<<LCIO interface: types>>=
  type :: lcio_event_t
     private
     type(c_ptr) :: obj
     type(lccollection_t) :: lccoll
  end type lcio_event_t

@ %def lcio_event_t 
@ Constructor.  Arguments are process ID (integer) and event ID
(integer).

The Fortran version has initializer form. 
<<LCIO interface: interfaces>>=
  interface
     type(c_ptr) function new_lcio_event (proc_id, event_id) bind(C)
       import
       integer(c_int), value :: proc_id, event_id
     end function new_lcio_event
  end interface
@ %def new_lcio_event
@ 
<<LCIO interface: public>>=
  public :: lcio_event_init
<<LCIO interface: procedures>>=
  subroutine lcio_event_init (evt, proc_id, event_id)
    type(lcio_event_t), intent(out) :: evt
    integer, intent(in), optional :: proc_id, event_id
    integer(c_int) :: pid, eid
    pid = 0;  if (present (proc_id))  pid = proc_id
    eid = 0;  if (present (event_id)) eid = event_id
    evt%obj = new_lcio_event (pid, eid)
    evt%lccoll%obj = new_lccollection ()
  end subroutine lcio_event_init

@ %def lcio_event_init
@ Destructor.
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_event_delete (evt_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj
     end subroutine lcio_event_delete
  end interface
@ %def lcio_event_delete
<<LCIO interface: public>>=
  public :: lcio_event_final
<<LCIO interface: procedures>>=
  subroutine lcio_event_final (evt)
    type(lcio_event_t), intent(inout) :: evt
    call lcio_event_delete (evt%obj)
  end subroutine lcio_event_final

@ %def lcio_event_final
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_event_add_collection &
          (evt_obj, lccoll_obj) bind(C)
       import
       type(c_ptr), value :: evt_obj, lccoll_obj
     end subroutine lcio_event_add_collection
  end interface
@ %def lcio_event_add_collection
<<LCIO interface: public>>=
  public :: lcio_event_add_coll
<<LCIO interface: procedures>>=
  subroutine lcio_event_add_coll (evt) 
    type(lcio_event_t), intent(inout) :: evt
    call lcio_event_add_collection (evt%obj, &
         evt%lccoll%obj)
  end subroutine lcio_event_add_coll

@ %def lcio_event_add_coll
@
\subsection{LCIO Particle}
Particle objects have the obvious meaning.
<<LCIO interface: public>>=
  public :: lcio_particle_t
<<LCIO interface: types>>=
  type :: lcio_particle_t
     private
     type(c_ptr) :: obj
  end type lcio_particle_t

@ %def lcio_particle_t
@ Constructor. 
<<LCIO interface: interfaces>>=
  interface
     type(c_ptr) function new_lcio_particle &
          (mom, pdg_id, mass, status) bind(C)
       import
       integer(c_int), value :: pdg_id, status
       real(c_double), value :: mass
       real(c_double), dimension(3) :: mom
     end function new_lcio_particle
  end interface
@ %def new_lcio_particle
@
<<LCIO interface: interfaces>>=
  interface
     subroutine add_particle_to_collection &
          (prt_obj, lccoll_obj) bind(C)
       import
       type(c_ptr), value :: prt_obj, lccoll_obj
     end subroutine add_particle_to_collection
  end interface
@ %def add_particle_to_collection
<<LCIO interface: public>>=
  public :: lcio_particle_add_to_evt_coll
<<LCIO interface: procedures>>=
  subroutine lcio_particle_add_to_evt_coll &
       (lprt, evt)
    type(lcio_particle_t), intent(in) :: lprt
    type(lcio_event_t), intent(inout) :: evt
    call add_particle_to_collection (lprt%obj, evt%lccoll%obj)
  end subroutine lcio_particle_add_to_evt_coll

@ %def lcio_particle_to_collection
@
<<LCIO interface: public>>=
  public :: lcio_particle_init
<<LCIO interface: procedures>>=
  subroutine lcio_particle_init (prt, p, pdg, status)
    type(lcio_particle_t), intent(out) :: prt
    type(vector4_t), intent(in) :: p
    real(default) :: mass
    real(default) :: px, py, pz
    integer, intent(in) :: pdg, status
    px = vector4_get_component (p, 1)
    py = vector4_get_component (p, 2)
    pz = vector4_get_component (p, 3)
    mass = p**1
    prt%obj = new_lcio_particle ([real (px, c_double), real (py, c_double), &
         real (pz, c_double)], int (pdg, c_int), &
         real (mass, c_double), int (status, c_int))
  end subroutine lcio_particle_init

@ %def lcio_particle_init
@ Set the particle color flow.
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_set_color_flow (prt_obj, col) bind(C)
       import
       type(c_ptr), intent(inout) :: prt_obj
       integer(c_int), dimension(2), intent(in) :: col
     end subroutine lcio_set_color_flow
  end interface
@ %def lcio_set_color_flow
@ Set the particle color.  Either from a [[color_t]] object or
directly from a pair of integers.
<<LCIO interface: interfaces>>=
  interface lcio_particle_set_color
     module procedure lcio_particle_set_color_col
     module procedure lcio_particle_set_color_int
  end interface lcio_particle_set_color
<<LCIO interface: public>>=
  public :: lcio_particle_set_color
<<LCIO interface: procedures>>=
  subroutine lcio_particle_set_color_col (prt, col)
    type(lcio_particle_t), intent(inout) :: prt
    type(color_t), intent(in) :: col
    integer(c_int), dimension(2) :: c
    c(1) = color_get_col (col)
    c(2) = color_get_acl (col)    
    if (c(1) /= 0 .and. c(2) /= 0)  then
       call lcio_set_color_flow (prt%obj, c)
    end  if
  end subroutine lcio_particle_set_color_col

  subroutine lcio_particle_set_color_int (prt, col)
    type(lcio_particle_t), intent(inout) :: prt
    integer, dimension(2), intent(in) :: col
    integer(c_int), dimension(2) :: c
    c = col
    if (c(1) /= 0 .and. c(2) /= 0) then
       call lcio_set_color_flow (prt%obj, c)
    end if
  end subroutine lcio_particle_set_color_int

@ %def lcio_particle_set_color
@
@ Return the particle color as a two-dimensional array (color, anticolor).
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_particle_get_flow (prt_obj, flow) bind(C)
       import
       type(c_ptr), intent(in), value :: prt_obj
       integer(c_int), dimension(2), intent(out) :: flow
     end subroutine lcio_particle_get_flow
  end interface
@ %def lcio_particle_get_flow
<<LCIO interface: public>>=
  public :: lcio_particle_get_color
<<LCIO interface: procedures>>=
  function lcio_particle_get_color (prt) result (col)
    integer, dimension(2) :: col
    type(lcio_particle_t), intent(in) :: prt
    call lcio_particle_get_flow (prt%obj, col)
  end function lcio_particle_get_color

@ %def lcio_particle_get_color
@
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_particle_add_parent (prt_obj1, prt_obj2) bind(C)
       import
       type(c_ptr), value :: prt_obj1, prt_obj2
     end subroutine lcio_particle_add_parent
  end interface  
@ %def lcio_particle_add_parent
<<LCIO interface: public>>=
  public :: lcio_particle_set_parent
<<LCIO interface: procedures>>=
  subroutine lcio_particle_set_parent (daughter, parent) 
    type(lcio_particle_t), intent(inout) :: daughter, parent
    call lcio_particle_add_parent (daughter%obj, parent%obj)
  end subroutine lcio_particle_set_parent

@ %def lcio_particle_set_parent
@
\subsection{LCIO Writer type}
There is a specific LCIO Writer type for handling the output of
LCEventImpl objects (i.e., Monte Carlo event samples) to file.  Opening
the file is done by the constructor, closing by the destructor.
<<LCIO interface: public>>=
  public :: lcio_writer_t
<<LCIO interface: types>>=
  type :: lcio_writer_t
     private
     type(c_ptr) :: obj
  end type lcio_writer_t

@ %def lcio_writer_t
@ Constructor for an output associated to a file.
<<LCIO interface: interfaces>>=
  interface
     type(c_ptr) function open_lcio_writer_new (filename, complevel) bind(C)
       import
       character(c_char), dimension(*), intent(in) :: filename
       integer(c_int), intent(in) :: complevel
     end function open_lcio_writer_new
  end interface
@ %def open_lcio_writer_now
<<LCIO interface: public>>=
  public :: lcio_writer_open_out
<<LCIO interface: procedures>>=
  subroutine lcio_writer_open_out (lcio_writer, filename)
    type(lcio_writer_t), intent(out) :: lcio_writer
    type(string_t), intent(in) :: filename
    lcio_writer%obj = open_lcio_writer_new (char (filename) // &
         c_null_char, 9_c_int)
  end subroutine lcio_writer_open_out

@ %def lcio_writer_open_out
@ Destructor:
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_writer_delete (io_obj) bind(C)
       import
       type(c_ptr), value :: io_obj
     end subroutine lcio_writer_delete
  end interface
@ %def lcio_writer_delete
<<LCIO interface: public>>=
  public :: lcio_writer_close
<<LCIO interface: procedures>>=
  subroutine lcio_writer_close (lciowriter)
    type(lcio_writer_t), intent(inout) :: lciowriter
    call lcio_writer_delete (lciowriter%obj)
  end subroutine lcio_writer_close

@ %def lcio_writer_close
@ Write a single event to the LCIO writer.
<<LCIO interface: interfaces>>=
  interface
     subroutine lcio_write_event (io_obj, evt_obj) bind(C)
       import
       type(c_ptr), value :: io_obj, evt_obj
     end subroutine lcio_write_event
  end interface
@ %def lcio_write_event
<<LCIO interface: public>>=
  public :: lcio_event_write
<<LCIO interface: procedures>>=
  subroutine lcio_event_write (wrt, evt)
    type(lcio_writer_t), intent(inout) :: wrt
    type(lcio_event_t), intent(in) :: evt
    call lcio_write_event (wrt%obj, evt%obj)
  end subroutine lcio_event_write

@ %def lcio_event_write
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Particles}
This module defines the [[particle_t]] object type, and the methods
and operations that deal with it.
<<[[particles.f90]]>>=
<<File header>>

module particles

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use format_utils, only: pac_fmt
  use format_defs, only: FMT_16, FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use lorentz
  use model_data
  use flavors
  use colors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use hepmc_interface
  use lcio_interface
  use subevents
  use polarizations

<<Standard module head>>

<<Particles: public>>

<<Particles: parameters>>
       
<<Particles: types>>

<<Particles: interfaces>>

contains

<<Particles: procedures>>

<<Particles: tests>>

end module particles
@ %def particles
@
\subsection{The particle type}
\subsubsection{Particle status codes}
The overall status codes (incoming/outgoing etc.) are inherited from
the module [[subevents]].

Polarization status:
<<Particles: parameters>>=
  integer, parameter, public :: PRT_UNPOLARIZED = 0
  integer, parameter, public :: PRT_DEFINITE_HELICITY = 1
  integer, parameter, public :: PRT_GENERIC_POLARIZATION = 2

@ %def PRT_UNPOLARIZED PRT_DEFINITE_HELICITY PRT_GENERIC_POLARIZATION
@
\subsubsection{Definition}
The quantum numbers are flavor (from which invariant particle
properties can be derived), color, and polarization.  The particle may
be unpolarized.  In this case, [[hel]] and [[pol]] are unspecified.
If it has a definite helicity, the [[hel]] component is defined.  If
it has a generic polarization, the [[pol]] component is defined.  For
each particle we store the four-momentum and the invariant mass
squared, i.e., the squared norm of the four-momentum.  There is also
an optional list of parent and child particles, for bookkeeping in
physical events.
<<Particles: public>>=
  public :: particle_t
<<Particles: types>>=
  type :: particle_t
     private
     integer :: status = PRT_UNDEFINED
     integer :: polarization = PRT_UNPOLARIZED
     type(flavor_t) :: flv
     type(color_t) :: col
     type(helicity_t) :: hel
     type(polarization_t) :: pol
     type(vector4_t) :: p = vector4_null
     real(default) :: p2 = 0
     integer, dimension(:), allocatable :: parent
     integer, dimension(:), allocatable :: child
  end type particle_t

@ %def particle_t
@ Particle initializers:
<<Particles: interfaces>>=
  interface particle_init
     module procedure particle_init_particle
     module procedure particle_init_state
     module procedure particle_init_hepmc
  end interface

@ %def particle_init
@ Copy a particle.  (Deep copy)  The excludes the parent-child
relations.
<<Particles: procedures>>=
  subroutine particle_init_particle (prt_out, prt_in)
    type(particle_t), intent(out) :: prt_out
    type(particle_t), intent(in) :: prt_in
    prt_out%status = prt_in%status
    prt_out%polarization = prt_in%polarization
    prt_out%flv = prt_in%flv
    prt_out%col = prt_in%col
    prt_out%hel = prt_in%hel
    prt_out%pol = prt_in%pol
    prt_out%p = prt_in%p
    prt_out%p2 = prt_in%p2
  end subroutine particle_init_particle

@ %def particle_init_particle
@ Initialize a particle using a single-particle state matrix which
determines flavor, color, and polarization.  The state matrix must
have unique flavor and color.  The factorization mode determines
whether the particle is unpolarized, has definite helicity, or generic
polarization.  This mode is translated into the polarization status.
<<Particles: procedures>>=
  subroutine particle_init_state (prt, state, status, mode)
    type(particle_t), intent(out) :: prt
    type(state_matrix_t), intent(in) :: state
    integer, intent(in) :: status, mode
    type(state_iterator_t) :: it
    prt%status = status
    call state_iterator_init (it, state)
    prt%flv = state_iterator_get_flavor (it, 1)
    if (flavor_is_beam_remnant (prt%flv))  prt%status = PRT_BEAM_REMNANT
    prt%col = state_iterator_get_color (it, 1)
    select case (mode)
    case (FM_SELECT_HELICITY)
       prt%hel = state_iterator_get_helicity (it, 1)
       prt%polarization = PRT_DEFINITE_HELICITY
    case (FM_FACTOR_HELICITY)
       call polarization_init_state_matrix (prt%pol, state)
       prt%polarization = PRT_GENERIC_POLARIZATION
    end select
  end subroutine particle_init_state

@ %def particle_init_state
@ Initialize a particle from a HepMC particle object.  The model is
necessary for making a fully qualified flavor component.  We have the
additional flag [[polarized]] which tells whether the polarization
information should be interpreted or ignored, and the lookup array of
barcodes.  Note that the lookup array is searched linearly, a possible
bottleneck for large particle arrays.  If necessary, the barcode array
could be replaced by a hash table.
<<Particles: procedures>>=
  subroutine particle_init_hepmc (prt, hprt, model, polarization, barcode)
    type(particle_t), intent(out) :: prt
    type(hepmc_particle_t), intent(in) :: hprt
    type(model_data_t), intent(in), target :: model
    integer, intent(in) :: polarization
    integer, dimension(:), intent(in) :: barcode
    type(hepmc_polarization_t) :: hpol
    integer :: n_parents, n_children
    integer, dimension(:), allocatable :: parent_barcode, child_barcode
    integer :: i
    select case (hepmc_particle_get_status (hprt))
    case (1);  prt%status = PRT_OUTGOING
    case (2);  prt%status = PRT_RESONANT
    case (3);  prt%status = PRT_VIRTUAL
    end select
    if (hepmc_particle_is_beam (hprt)) prt%status = PRT_BEAM
    call flavor_init (prt%flv, hepmc_particle_get_pdg (hprt), model)
    if (flavor_is_beam_remnant (prt%flv))  prt%status = PRT_BEAM_REMNANT
    call color_init (prt%col, hepmc_particle_get_color (hprt))
    prt%polarization = polarization
    select case (polarization)
    case (PRT_DEFINITE_HELICITY)
       hpol = hepmc_particle_get_polarization (hprt)
       call hepmc_polarization_to_hel (hpol, prt%flv, prt%hel)
       call hepmc_polarization_final (hpol)
    case (PRT_GENERIC_POLARIZATION)
       hpol = hepmc_particle_get_polarization (hprt)
       call hepmc_polarization_to_pol (hpol, prt%flv, prt%pol)
       call hepmc_polarization_final (hpol)
    end select
    prt%p = hepmc_particle_get_momentum (hprt)
    prt%p2 = hepmc_particle_get_mass_squared (hprt)
    n_parents  = hepmc_particle_get_n_parents  (hprt)
    n_children = hepmc_particle_get_n_children (hprt)
    allocate (parent_barcode (n_parents),  prt%parent (n_parents))
    allocate (child_barcode  (n_children), prt%child  (n_children))
    parent_barcode = hepmc_particle_get_parent_barcodes (hprt)
    child_barcode  = hepmc_particle_get_child_barcodes  (hprt)
    do i = 1, size (barcode)
       where (parent_barcode == barcode(i))  prt%parent = i
       where (child_barcode  == barcode(i))  prt%child  = i
    end do
    if (prt%status == PRT_VIRTUAL .and. n_parents == 0) &
         prt%status = PRT_INCOMING
  end subroutine particle_init_hepmc

@ %def particle_init_hepmc
@ Finalizer.  The polarization component has pointers allocated.
<<Particles: procedures>>=
  elemental subroutine particle_final (prt)
    type(particle_t), intent(inout) :: prt
    call polarization_final (prt%pol)
  end subroutine particle_final

@ %def particle_final
@ 
\subsubsection{I/O}
<<Particles: public>>=
  public :: particle_write
<<Particles: procedures>>=
  subroutine particle_write (prt, unit, testflag)
    type(particle_t), intent(in) :: prt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    logical :: pacified
    integer :: u
    real(default) :: pp2
    character(len=7) :: fmt
    pacified = .false.
    if (present (testflag))  pacified = testflag
    call pac_fmt (fmt, FMT_19, FMT_16, testflag)
    u = given_output_unit (unit);  if (u < 0)  return
    select case (prt%status)
    case (PRT_UNDEFINED);    write (u, "(1x, A)", advance="no")  "[-]"
    case (PRT_BEAM);         write (u, "(1x, A)", advance="no")  "[b]"
    case (PRT_INCOMING);     write (u, "(1x, A)", advance="no")  "[i]"
    case (PRT_OUTGOING);     write (u, "(1x, A)", advance="no")  "[o]"
    case (PRT_VIRTUAL);      write (u, "(1x, A)", advance="no")  "[v]"
    case (PRT_RESONANT);     write (u, "(1x, A)", advance="no")  "[r]"
    case (PRT_BEAM_REMNANT); write (u, "(1x, A)", advance="no")  "[x]"
    end select
    write (u, "(1x)", advance="no")
    call flavor_write (prt%flv, unit)
    call color_write (prt%col, unit)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call helicity_write (prt%hel, unit)
       write (u, *)
    case (PRT_GENERIC_POLARIZATION)
       write (u, *)
       call polarization_write (prt%pol, unit)
    case default
       write (u, *)
    end select    
    call vector4_write (prt%p, unit, testflag = testflag)
    pp2 = prt%p2        
    if (pacified)  call pacify (pp2, tolerance = 1E-10_default)	
    write (u, "(1x,A,1x," // fmt // ")")  "T = ", pp2
    if (allocated (prt%parent)) then
       if (size (prt%parent) /= 0) then
          write (u, "(1x,A,40(1x,I0))")  "Parents: ", prt%parent
       end if
    end if
    if (allocated (prt%child)) then
       if (size (prt%child) /= 0) then
          write (u, "(1x,A,40(1x,I0))")  "Children:", prt%child
       end if
    end if
  end subroutine particle_write

@ %def particle_write
@ Binary I/O:
<<Particles: procedures>>=
  subroutine particle_write_raw (prt, u)
    type(particle_t), intent(in) :: prt
    integer, intent(in) :: u
    write (u) prt%status, prt%polarization
    call flavor_write_raw (prt%flv, u)
    call color_write_raw (prt%col, u)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call helicity_write_raw (prt%hel, u)
    case (PRT_GENERIC_POLARIZATION)
       call polarization_write_raw (prt%pol, u)
    end select
    call vector4_write_raw (prt%p, u)
    write (u) prt%p2
    write (u) allocated (prt%parent)
    if (allocated (prt%parent)) then
       write (u) size (prt%parent)
       write (u) prt%parent
    end if
    write (u) allocated (prt%child)
    if (allocated (prt%child)) then
       write (u) size (prt%child)
       write (u) prt%child
    end if
  end subroutine particle_write_raw

  subroutine particle_read_raw (prt, u, iostat)
    type(particle_t), intent(out) :: prt
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    logical :: allocated_parent, allocated_child
    integer :: size_parent, size_child
    read (u, iostat=iostat) prt%status, prt%polarization
    call flavor_read_raw (prt%flv, u, iostat=iostat)
    call color_read_raw (prt%col, u, iostat=iostat)
    select case (prt%polarization)
    case (PRT_DEFINITE_HELICITY)
       call helicity_read_raw (prt%hel, u, iostat=iostat)
    case (PRT_GENERIC_POLARIZATION)
       call polarization_read_raw (prt%pol, u, iostat=iostat)
    end select
    call vector4_read_raw (prt%p, u, iostat=iostat)
    read (u, iostat=iostat) prt%p2
    read (u, iostat=iostat) allocated_parent
    if (allocated_parent) then
       read (u, iostat=iostat) size_parent
       allocate (prt%parent (size_parent))
       read (u, iostat=iostat) prt%parent
    end if
    read (u, iostat=iostat) allocated_child
    if (allocated_child) then
       read (u, iostat=iostat) size_child
       allocate (prt%child (size_child))
       read (u, iostat=iostat) prt%child
    end if
  end subroutine particle_read_raw

@ %def particle_write_raw particle_read_raw
@ 
\subsubsection{Setting contents}
Reset the status code.  Where applicable, set $p^2$ assuming that the
particle is on-shell.
<<Particles: public>>=
  public :: particle_reset_status
<<Particles: procedures>>=
  elemental subroutine particle_reset_status (prt, status)
    type(particle_t), intent(inout) :: prt
    integer, intent(in) :: status
    prt%status = status
    select case (status)
    case (PRT_BEAM, PRT_INCOMING, PRT_OUTGOING)
       prt%p2 = flavor_get_mass (prt%flv) ** 2
    end select
  end subroutine particle_reset_status

@ %def particle_reset_status
@ The color can be given explicitly.
<<Particles: public>>=
  public :: particle_set_color
<<Particles: procedures>>=
  elemental subroutine particle_set_color (prt, col)
    type(particle_t), intent(inout) :: prt
    type(color_t), intent(in) :: col
    prt%col = col
  end subroutine particle_set_color

@ %def particle_set_color
@ The flavor can be given explicitly.
<<Particles: public>>=
  public :: particle_set_flavor
<<Particles: procedures>>=
  subroutine particle_set_flavor (prt, flv)
    type(particle_t), intent(inout) :: prt
    type(flavor_t), intent(in) :: flv
    prt%flv = flv
  end subroutine particle_set_flavor

@ %def particle_set_flavor
@ Manually set the model for the particle flavor.  This is required, e.g., if
the particle has been read from file.
<<Particles: public>>=
  public :: particle_set_model
<<Particles: procedures>>=
  subroutine particle_set_model (prt, model)
    type(particle_t), intent(inout) :: prt
    class(model_data_t), intent(in), target :: model
    call flavor_set_model (prt%flv, model)
  end subroutine particle_set_model
  
@ %def particle_set_model
@ The momentum is set independent of the quantum numbers.
<<Particles: public>>=
  public :: particle_set_momentum
<<Particles: procedures>>=
  elemental subroutine particle_set_momentum (prt, p, p2, on_shell)
    type(particle_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: p
    real(default), intent(in), optional :: p2
    logical, intent(in), optional :: on_shell
    prt%p = p
    if (present (on_shell)) then
       if (on_shell) then
          if (flavor_is_associated (prt%flv)) then
             prt%p2 = flavor_get_mass (prt%flv) ** 2
             return
          end if
       end if
    end if
    if (present (p2)) then
       prt%p2 = p2
    else
       prt%p2 = p ** 2
    end if
  end subroutine particle_set_momentum

@ %def particle_set_momentum
@ Set resonance information.  This should be done after momentum
assignment, because we need to know wheter the particle is spacelike
or timelike.  The resonance flag is defined only for virtual
particles. 
<<Particles: procedures>>=
  elemental subroutine particle_set_resonance_flag (prt, resonant)
    type(particle_t), intent(inout) :: prt
    logical, intent(in) :: resonant
    select case (prt%status)
    case (PRT_VIRTUAL)
       if (resonant)  prt%status = PRT_RESONANT
    end select
  end subroutine particle_set_resonance_flag

@ %def particle_set_resonance_flag
@ Set children and parents information.
<<Particles: public>>=
  public :: particle_set_children
  public :: particle_set_parents
<<Particles: procedures>>=
  subroutine particle_set_children (prt, idx)
    type(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%child))  deallocate (prt%child)
    allocate (prt%child (count (idx /= 0)))
    prt%child = pack (idx, idx /= 0)
  end subroutine particle_set_children

  subroutine particle_set_parents (prt, idx)
    type(particle_t), intent(inout) :: prt
    integer, dimension(:), intent(in) :: idx
    if (allocated (prt%parent))  deallocate (prt%parent) 
    allocate (prt%parent (count (idx /= 0)))
    prt%parent = pack (idx, idx /= 0)
  end subroutine particle_set_parents

@ %def particle_set_children particle_set_parents
@ 
\subsubsection{Accessing contents}
The status code.
<<Particles: public>>=
  public :: particle_get_status
<<Particles: procedures>>=
  elemental function particle_get_status (prt) result (status)
    integer :: status
    type(particle_t), intent(in) :: prt
    status = prt%status
  end function particle_get_status

@ %def particle_get_status
@ Return true if the status is either [[INCOMING]],
[[OUTGOING]] or [[RESONANT]]. [[BEAM]] is kept, if 
[[keep_beams]] is set true.
<<Particles: procedures>>=
  elemental function particle_is_real (prt, keep_beams) result (flag)
    logical :: flag, kb
    type(particle_t), intent(in) :: prt
    logical, intent(in), optional :: keep_beams
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    select case (prt%status)
    case (PRT_INCOMING, PRT_OUTGOING, PRT_RESONANT)
       flag = .true.
    case (PRT_BEAM)
       flag = kb 
    case default
       flag = .false.
    end select
  end function particle_is_real

@ %def particle_is_real
@ Polarization status.
<<Particles: public>>=
  public :: particle_get_polarization_status
<<Particles: procedures>>=
  elemental function particle_get_polarization_status (prt) result (status)
    integer :: status
    type(particle_t), intent(in) :: prt
    status = prt%polarization
  end function particle_get_polarization_status

@ %def particle_get_polarization_status
@ Return the PDG code from the flavor component directly.
<<Particles: public>>=
  public :: particle_get_pdg
<<Particles: procedures>>=
  elemental function particle_get_pdg (prt) result (pdg)
    integer :: pdg
    type(particle_t), intent(in) :: prt
    pdg = flavor_get_pdg (prt%flv)
  end function particle_get_pdg

@ %def particle_get_pdg
@ Return the color and anticolor quantum numbers.
<<Particles: public>>=
  public :: particle_get_color
<<Particles: procedures>>=
  pure function particle_get_color (prt) result (col)
    integer, dimension(2) :: col
    type(particle_t), intent(in) :: prt
    col(1) = color_get_col (prt%col)
    col(2) = color_get_acl (prt%col)
  end function particle_get_color
  
@ %def particle_get_color  
@ Return the polarization density matrix (as a shallow copy).
<<Particles: public>>=
  public :: particle_get_polarization
<<Particles: procedures>>=
  function particle_get_polarization (prt) result (pol)
    type(polarization_t) :: pol
    type(particle_t), intent(in) :: prt
    pol = prt%pol
  end function particle_get_polarization

@ %def particle_get_polarization
@ Return the helicity (if defined and diagonal).
<<Particles: public>>=
  public :: particle_get_helicity
<<Particles: procedures>>=
  elemental function particle_get_helicity (prt) result (hel)
    integer :: hel
    integer, dimension(2) :: hel_arr
    type(particle_t), intent(in) :: prt    
    hel = 0
    if (helicity_is_defined (prt%hel) .and. &
        helicity_is_diagonal (prt%hel)) then
	     hel_arr = helicity_get (prt%hel)
	     hel = hel_arr (1)
    end if
  end function particle_get_helicity  
  
@ %def particle_get_helicity
@ Return the number of children/parents
<<Particles: public>>=
  public :: particle_get_n_parents
  public :: particle_get_n_children
<<Particles: procedures>>=
  elemental function particle_get_n_parents (prt) result (n)
    integer :: n
    type(particle_t), intent(in) :: prt
    if (allocated (prt%parent)) then
       n = size (prt%parent)
    else
       n = 0
    end if
  end function particle_get_n_parents
    
  elemental function particle_get_n_children (prt) result (n)
    integer :: n
    type(particle_t), intent(in) :: prt
    if (allocated (prt%child)) then
       n = size (prt%child)
    else
       n = 0
    end if
  end function particle_get_n_children
    
@ %def particle_get_n_parents particle_get_n_children
@ Return the array of parents/children.
<<Particles: public>>=
  public :: particle_get_parents
  public :: particle_get_children
<<Particles: procedures>>=
  function particle_get_parents (prt) result (parent)
    type(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: parent
    if (allocated (prt%parent)) then
       allocate (parent (size (prt%parent)))
       parent = prt%parent
    else
       allocate (parent (0))
    end if
  end function particle_get_parents

  function particle_get_children (prt) result (child)
    type(particle_t), intent(in) :: prt
    integer, dimension(:), allocatable :: child
    if (allocated (prt%child)) then
       allocate (child (size (prt%child)))
       child = prt%child
    else
       allocate (child (0))
    end if
  end function particle_get_children

@ %def particle_get_children
@ Return momentum and momentum squared.
<<Particles: public>>=
  public :: particle_get_momentum
  public :: particle_get_p2
<<Particles: procedures>>=
  elemental function particle_get_momentum (prt) result (p)
    type(vector4_t) :: p
    type(particle_t), intent(in) :: prt
    p = prt%p
  end function particle_get_momentum

  elemental function particle_get_p2 (prt) result (p2)
    real(default) :: p2
    type(particle_t), intent(in) :: prt
    p2 = prt%p2
  end function particle_get_p2

@ %def particle_get_momentum particle_get_p2
@ 
\subsection{Particle sets}
A particle set is what is usually called an event: an array of
particles.  The individual particle entries carry momentum, quantum
numbers, polarization, and optionally connections.  There is (also
optionally) a correlated state-density matrix that maintains spin
correlations that are lost in the individual particle entries.
<<Particles: public>>=
  public :: particle_set_t
<<Particles: types>>=
  type :: particle_set_t
     ! private
     integer :: n_beam = 0
     integer :: n_in  = 0
     integer :: n_vir = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     type(particle_t), dimension(:), allocatable :: prt
     type(state_matrix_t) :: correlated_state
  end type particle_set_t

@ %def particle_set_t
@ A particle set can be initialized from an interaction or from a
HepMC event record.
<<Particles: public>>=
  public :: particle_set_init
<<Particles: interfaces>>=
  interface particle_set_init
     module procedure particle_set_init_interaction
     module procedure particle_set_init_hepmc
  end interface

@ %def particle_set_init
@ When a particle set is initialized from a given interaction, we have
to determine the branch within the original state matrix that fixes
the particle quantum numbers.  This is done with the appropriate
probabilities, based on a random number [[x]].  The [[mode]]
determines whether the individual particles become unpolarized, or
take a definite (diagonal) helicity, or acquire single-particle
polarization matrices.  The flag [[keep_correlations]] tells whether
the spin-correlation matrix is to be calculated and stored in addition
to the particles.  The flag [[keep_virtual]] tells whether virtual
particles should be dropped.  Note that if virtual particles are
dropped, the spin-correlation matrix makes no sense, and parent-child
relations are not set.

For a correct disentangling of color and flavor (in the presence of
helicity), we consider two interactions.  [[int]] has no color
information, and is used to select a flavor state.  Consequently, we
trace over helicities here.  [[int_flows]] contains color-flow and
potentially helicity information, but is useful only after the flavor
combination has been chosen.  So this interaction is used to select
helicity and color, but restricted to the selected flavor combination.

[[int]] and [[int_flows]] may be identical if there is only a single
(or no) color flow.  If there is just a single flavor combination,
[[x(1)]] can be set to zero.

The current algorithm of evaluator convolution requires that the beam
particles are assumed outgoing (in the beam interaction) and become
virtual in all derived interactions.  In the particle set they should
be re-identified as incoming.  The optional integer [[n_incoming]]
can be used to perform this correction.
    
The flag [[is_valid]] is false if factorization of the state is not
possible, in particular if the squared matrix element is zero.
<<Particles: procedures>>=
  subroutine particle_set_init_interaction &
       (particle_set, is_valid, int, int_flows, mode, x, &
        keep_correlations, keep_virtual, n_incoming)
    type(particle_set_t), intent(out) :: particle_set
    logical, intent(out) :: is_valid
    type(interaction_t), intent(in), target :: int, int_flows
    integer, intent(in) :: mode
    real(default), dimension(2), intent(in) :: x
    logical, intent(in) :: keep_correlations, keep_virtual
    integer, intent(in), optional :: n_incoming
    type(state_matrix_t), dimension(:), allocatable, target :: flavor_state
    type(state_matrix_t), dimension(:), allocatable, target :: single_state
    integer :: n_in, n_vir, n_out, n_tot
    type(quantum_numbers_t), dimension(:,:), allocatable :: qn
    logical :: ok
    integer :: i, j
    if (present (n_incoming)) then
       n_in  = n_incoming
       n_vir = interaction_get_n_vir (int) - n_incoming
    else
       n_in  = interaction_get_n_in  (int)
       n_vir = interaction_get_n_vir (int)
    end if
    n_out = interaction_get_n_out (int)
    n_tot = interaction_get_n_tot (int)
    particle_set%n_in  = n_in
    particle_set%n_out = n_out
    if (keep_virtual) then
       particle_set%n_vir = n_vir
       particle_set%n_tot = n_tot
    else
       particle_set%n_vir = 0
       particle_set%n_tot = n_in + n_out
    end if
    call interaction_factorize &
         (int, FM_IGNORE_HELICITY, x(1), is_valid, flavor_state)
    allocate (qn (n_tot,1))
    do i = 1, n_tot
       qn(i,:) = state_matrix_get_quantum_numbers (flavor_state(i), 1)
    end do
    if (keep_correlations .and. keep_virtual) then
       call interaction_factorize (int_flows, mode, x(2), ok, &
            single_state, particle_set%correlated_state, qn(:,1))
    else
       call interaction_factorize (int_flows, mode, x(2), ok, &
            single_state, qn_in=qn(:,1))
    end if
    is_valid = is_valid .and. ok
    allocate (particle_set%prt (particle_set%n_tot))
    j = 1
    do i = 1, n_tot
       if (i <= n_in) then
          call particle_init &
               (particle_set%prt(j), single_state(i), PRT_INCOMING, mode)
          call particle_set_momentum &
               (particle_set%prt(j), interaction_get_momentum (int, i))
       else if (i <= n_in + n_vir) then
          if (.not. keep_virtual)  cycle
          call particle_init &
               (particle_set%prt(j), single_state(i), PRT_VIRTUAL, mode) 
          call particle_set_momentum &
               (particle_set%prt(j), interaction_get_momentum (int, i))
       else
          call particle_init &
               (particle_set%prt(j), single_state(i), PRT_OUTGOING, mode)
          call particle_set_momentum &
               (particle_set%prt(j), interaction_get_momentum (int, i), &
               on_shell = .true.)
       end if
       if (keep_virtual) then
          call particle_set_children &
               (particle_set%prt(j), interaction_get_children (int, i))
          call particle_set_parents &
               (particle_set%prt(j), interaction_get_parents (int, i))
       end if
       j = j + 1
    end do
    if (keep_virtual) then
       call particle_set_resonance_flag &
            (particle_set%prt, interaction_get_resonance_flags (int))
    end if
    call state_matrix_final (flavor_state)
    call state_matrix_final (single_state)
  end subroutine particle_set_init_interaction

@ %def particle_set_init_interaction
@ If a particle set is initialized from a HepMC event record, we have
to specify the treatment of polarization (unpolarized or density
matrix) which is common to all particles.  Correlated polarization
information is not available.
<<Particles: procedures>>=
  subroutine particle_set_init_hepmc &
       (particle_set, evt, model, fallback_model, polarization)
    type(particle_set_t), intent(inout), target :: particle_set
    type(hepmc_event_t), intent(in) :: evt
    class(model_data_t), intent(in), target :: model, fallback_model
    integer, intent(in) :: polarization
    type(hepmc_event_particle_iterator_t) :: it
    type(hepmc_particle_t) :: prt
    integer, dimension(:), allocatable :: barcode
    integer :: n_tot, i, j
    n_tot = 0
    call hepmc_event_particle_iterator_init (it, evt)
    do while (hepmc_event_particle_iterator_is_valid (it))
       n_tot = n_tot + 1
       call hepmc_event_particle_iterator_advance (it)
    end do
    allocate (barcode (n_tot))
    call hepmc_event_particle_iterator_reset (it)
    do i = 1, n_tot
       barcode(i) = hepmc_particle_get_barcode &
            (hepmc_event_particle_iterator_get (it))
       call hepmc_event_particle_iterator_advance (it)
    end do
    allocate (particle_set%prt (n_tot))
    call hepmc_event_particle_iterator_reset (it)
    do i = 1, n_tot
       prt = hepmc_event_particle_iterator_get (it)
       call particle_init (particle_set%prt(i), &
            prt, model, polarization, barcode)
       call hepmc_event_particle_iterator_advance (it)
    end do
    do i = 1, n_tot
       if (particle_get_status (particle_set%prt(i)) == PRT_VIRTUAL) then
          CHECK_BEAM: do j = 1, size (particle_set%prt(i)%parent)
             if (particle_get_status (particle_set%prt(j)) == PRT_BEAM) &
                  particle_set%prt(i)%status = PRT_INCOMING
             exit CHECK_BEAM
          end do CHECK_BEAM
       end if
    end do
    call hepmc_event_particle_iterator_final (it)
    particle_set%n_tot = n_tot
    particle_set%n_beam  = &
         count (particle_get_status (particle_set%prt) == PRT_BEAM)
    particle_set%n_in  = &
         count (particle_get_status (particle_set%prt) == PRT_INCOMING)
    particle_set%n_out = &
         count (particle_get_status (particle_set%prt) == PRT_OUTGOING)
    particle_set%n_vir = &
         particle_set%n_tot - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_init_hepmc

@ %def particle_set_init_hepmc
@ Manually set the model for the stored particles.
<<Particles: public>>=
  public :: particle_set_set_model
<<Particles: procedures>>=
  subroutine particle_set_set_model (particle_set, model)
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    integer :: i
    do i = 1, particle_set%n_tot
       call particle_set_model (particle_set%prt(i), model)
    end do
  end subroutine particle_set_set_model
    
@ %def particle_set_set_model
@ Pointer components are hidden inside the particle polarization, and
in the correlated state matrix.
<<Particles: public>>=
  public :: particle_set_final
<<Particles: procedures>>=
  subroutine particle_set_final (particle_set)
    type(particle_set_t), intent(inout) :: particle_set
    if (allocated (particle_set%prt)) then
       call particle_final (particle_set%prt)
       deallocate(particle_set%prt)
    end if
    call state_matrix_final (particle_set%correlated_state)
  end subroutine particle_set_final

@ %def particle_set_final
@ Output (default format)
<<Particles: public>>=
  public :: particle_set_write
<<Particles: procedures>>=
  subroutine particle_set_write (particle_set, unit, testflag)
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "Particle set:"
    call write_separator (u)
    if (particle_set%n_tot /= 0) then
       do i = 1, particle_set%n_tot
          write (u, "(1x,A,1x,I0)", advance="no") "Particle", i
          call particle_write (particle_set%prt(i), u, testflag)
       end do
       if (state_matrix_is_defined (particle_set%correlated_state)) then
          call write_separator (u)
          write (u, *) "Correlated state density matrix:"
          call state_matrix_write (particle_set%correlated_state, u)
       end if
    else
       write (u, "(3x,A)") "[empty]"
    end if
  end subroutine particle_set_write

@ %def particle_set_write
@ 
\subsection{I/O formats}
Here, we define input/output of particle sets in various formats.
This is the right place since particle sets contain most of the event
information.

All write/read routines take as first argument the object, as second
argument the I/O unit which in this case is a mandatory argument.
Then follow further event data.

\subsubsection{Internal binary format}
This format is supposed to contain the complete information, so
the particle data set can be fully reconstructed.  The exception is
the model part of the particle flavors; this is unassigned for the
flavor values read from file.

NOTE: The input routine for a nontrivial state matrix is broken
<<Particles: public>>=
  public :: particle_set_write_raw 
  public :: particle_set_read_raw 
<<Particles: procedures>>=
  subroutine particle_set_write_raw (particle_set, u)
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: u
    integer :: i
    write (u) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    write (u) particle_set%n_tot
    do i = 1, particle_set%n_tot
       call particle_write_raw (particle_set%prt(i), u)
    end do
    if (state_matrix_is_defined (particle_set%correlated_state)) then
       call msg_bug ("Write particle set (raw): nontrivial state matrix not supported yet")
    else
       call state_matrix_write_raw (particle_set%correlated_state, u)
    end if
  end subroutine particle_set_write_raw

  subroutine particle_set_read_raw (particle_set, u, iostat)
    type(particle_set_t), intent(out) :: particle_set
    integer, intent(in) :: u
    integer, intent(out) :: iostat
    integer :: i
    read (u, iostat=iostat) &
         particle_set%n_beam, particle_set%n_in, &
         particle_set%n_vir, particle_set%n_out
    read (u, iostat=iostat) particle_set%n_tot
    allocate (particle_set%prt (particle_set%n_tot))
    do i = 1, size (particle_set%prt)
       call particle_read_raw (particle_set%prt(i), u, iostat=iostat)
    end do
    call state_matrix_read_raw (particle_set%correlated_state, u, iostat=iostat)
  end subroutine particle_set_read_raw

@ %def particle_set_write_raw particle_set_read_raw
@ 
\subsubsection{HepMC format}
The master output function fills a HepMC GenEvent object that is
already initialized, but has no vertices in it.

We first set up the vertex lists and enter the vertices into the HepMC
event.  Then, we assign first all incoming particles and then all
outgoing particles to their associated vertices.  Particles which have
neither parent nor children entries (this should not happen) are
dropped.

Finally, we insert the beam particles.  If there are none, use the incoming
particles instead.
@ Transform a particle into a [[hepmc_particle]] object, including
color and polarization.  The HepMC status is equivalent to the HEPEVT
status, in particular: 0 = null entry, 1 = physical particle, 2 =
decayed/fragmented SM hadron, tau or muon, 3 = other unphysical particle 
entry, 4 = incoming particles, 11 = intermediate resonance such as squarks.
The use of 11 for intermediate resonances is as done by HERWIG, see 
http://herwig.hepforge.org/trac/wiki/FaQs.
<<Particles: procedures>>=
  subroutine particle_to_hepmc (prt, hprt)
    type(particle_t), intent(in) :: prt
    type(hepmc_particle_t), intent(out) :: hprt
    integer :: hepmc_status
    select case (particle_get_status (prt))
    case (PRT_UNDEFINED)
       hepmc_status = 0
    case (PRT_OUTGOING)
       hepmc_status = 1
    case (PRT_BEAM)
       hepmc_status = 4
    case (PRT_RESONANT)
       if(abs(particle_get_pdg(prt)) == 13 .or. &
            abs(particle_get_pdg(prt)) == 15) then
          hepmc_status = 2
       else
          hepmc_status = 11
       end if
    case default
       hepmc_status = 3
    end select
    call hepmc_particle_init (hprt, &
         particle_get_momentum (prt), &
         particle_get_pdg (prt), &
         hepmc_status)
    call hepmc_particle_set_color (hprt, &
         particle_get_color (prt))
    select case (particle_get_polarization_status (prt))
    case (PRT_DEFINITE_HELICITY)
       call hepmc_particle_set_polarization (hprt, &
            particle_get_helicity (prt))
    case (PRT_GENERIC_POLARIZATION)
       call hepmc_particle_set_polarization (hprt, &
            particle_get_polarization (prt))
    end select
  end subroutine particle_to_hepmc

@ %def particle_to_hepmc
@
<<Particles: public>>=
  public :: hepmc_event_from_particle_set 
<<Particles: procedures>>=
  subroutine hepmc_event_from_particle_set (evt, particle_set)
    type(hepmc_event_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    type(hepmc_vertex_t), dimension(:), allocatable :: v
    type(hepmc_particle_t), dimension(:), allocatable :: hprt
    type(hepmc_particle_t), dimension(2) :: hbeam
    logical, dimension(:), allocatable :: is_beam
    integer, dimension(:), allocatable :: v_from, v_to
    integer :: n_vertices, n_tot, i
    n_tot = particle_set%n_tot
    allocate (v_from (n_tot), v_to (n_tot))
    call particle_set_assign_vertices (particle_set, v_from, v_to, n_vertices)
    allocate (v (n_vertices))
    do i = 1, n_vertices
       call hepmc_vertex_init (v(i))
       call hepmc_event_add_vertex (evt, v(i))
    end do
    allocate (hprt (n_tot))
    do i = 1, n_tot
       if (v_to(i) /= 0 .or. v_from(i) /= 0) then
          call particle_to_hepmc (particle_set%prt(i), hprt(i))
       end if
    end do
    allocate (is_beam (n_tot))
    is_beam = particle_get_status (particle_set%prt(1:n_tot)) == PRT_BEAM
    if (.not. any (is_beam)) then
       is_beam = particle_get_status (particle_set%prt(1:n_tot)) == PRT_INCOMING
    end if
    if (count (is_beam) == 2) then
       hbeam = pack (hprt, is_beam)
       call hepmc_event_set_beam_particles (evt, hbeam(1), hbeam(2))
    end if
    do i = 1, n_tot
       if (v_to(i) /= 0) then
          call hepmc_vertex_add_particle_in (v(v_to(i)), hprt(i))
       end if
    end do
    do i = 1, n_tot
       if (v_from(i) /= 0) then
          call hepmc_vertex_add_particle_out (v(v_from(i)), hprt(i))
       end if
    end do
  end subroutine hepmc_event_from_particle_set
  
@ %def hepmc_event_from_particle_set
@
\subsubsection{LCIO event format}
The master output function fills a LCIO event object that is
already initialized, but has no particles in it.

In contrast to HepMC in LCIO there are no vertices (except for tracker 
and other detector specifications). So we assign first all incoming 
particles and then all outgoing particles to LCIO particle types.  
Particles which have neither parent nor children entries (this 
should not happen) are dropped. Finally, we insert the beam particles.  
If there are none, use the incoming particles instead.
@ Transform a particle into a [[lcio_particle]] object, including
color and polarization.  The LCIO status is equivalent to the HepMC
status, in particular: 0 = null entry, 1 = physical particle, 2 =
decayed/fragmented SM hadron, tau or muon, 3 = other unphysical particle 
entry, 4 = incoming particles, 11 = intermediate resonance such as squarks.
The use of 11 for intermediate resonances is as done by HERWIG, see 
http://herwig.hepforge.org/trac/wiki/FaQs.
@
<<Particles: procedures>>=
  subroutine particle_to_lcio (prt, lprt)
    type(particle_t), intent(in) :: prt
    type(lcio_particle_t), intent(out) :: lprt
    integer :: lcio_status
    select case (particle_get_status (prt))
    case (PRT_UNDEFINED)
       lcio_status = 0
    case (PRT_OUTGOING)
       lcio_status = 1
    case (PRT_BEAM)
       lcio_status = 4
    case (PRT_RESONANT)
       if(abs(particle_get_pdg(prt)) == 13 .or. &
            abs(particle_get_pdg(prt)) == 15) then
          lcio_status = 2
       else
          lcio_status = 11
       end if
    case default
       lcio_status = 3
    end select
    call lcio_particle_init (lprt, &
         particle_get_momentum (prt), &
         particle_get_pdg (prt), &
         lcio_status)
    call lcio_particle_set_color (lprt, &
         particle_get_color (prt))
    ! select case (particle_get_polarization_status (prt))
    ! case (PRT_DEFINITE_HELICITY)
    !    call hepmc_particle_set_polarization (hprt, &
    !         particle_get_helicity (prt))
    ! case (PRT_GENERIC_POLARIZATION)
    !    call hepmc_particle_set_polarization (hprt, &
    !         particle_get_polarization (prt))
    ! end select
  end subroutine particle_to_lcio

@ %def particle_to_lcio
@ 
<<Particles: public>>=
  public :: lcio_event_from_particle_set 
<<Particles: procedures>>=
  subroutine lcio_event_from_particle_set (evt, particle_set)
    type(lcio_event_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    type(lcio_particle_t), dimension(:), allocatable :: lprt
    type(lcio_particle_t), dimension(2) :: lbeam
    integer, dimension(:), allocatable :: parent, child    
    logical, dimension(:), allocatable :: is_beam
    integer :: n_tot, i, j, n_parents
    n_tot = particle_set%n_tot
    allocate (lprt (n_tot))
    do i = 1, n_tot
       call particle_to_lcio (particle_set%prt(i), lprt(i))
       n_parents = particle_get_n_parents (particle_set%prt(i))
       if (n_parents /= 0) then
          allocate (parent (n_parents))
          parent = particle_get_parents (particle_set%prt(i))
          do j = 1, n_parents
             call lcio_particle_set_parent (lprt(i), lprt(parent(j)))
          end do
          deallocate (parent)
       end if
       call lcio_particle_add_to_evt_coll (lprt(i), evt)
    end do
    call lcio_event_add_coll (evt)
    !! allocate (is_beam (n_tot))
    !! is_beam = particle_get_status (particle_set%prt(1:n_tot)) == PRT_BEAM
    !! if (.not. any (is_beam)) then
    !!     is_beam = particle_get_status (particle_set%prt(1:n_tot)) == PRT_INCOMING
    !! end if    
    !! if (count (is_beam) == 2) then
    !!    hbeam = pack (hprt, is_beam)
    !!    call hepmc_event_set_beam_particles (evt, hbeam(1), hbeam(2))
    !! end if
  end subroutine lcio_event_from_particle_set
  
@ %def lcio_event_from_particle_set
@
\subsubsection{Get contents}
@ Find parents/children of a particular particle recursively; the
search terminates if a parent/child has status [[BEAM]], [[INCOMING]],
[[OUTGOING]] or [[RESONANT]].
<<Particles: procedures>>=
  function particle_set_get_real_parents (pset, i, keep_beams) result (parent)
    integer, dimension(:), allocatable :: parent
    type(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, intent(in), optional :: keep_beams
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_parent, is_real_parent
    logical :: kb
    integer :: j, k
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    is_real = particle_is_real (pset%prt, kb)
    allocate (is_parent (pset%n_tot), is_real_parent (pset%n_tot))
    is_real_parent = .false.
    is_parent = .false.
    is_parent(particle_get_parents(pset%prt(i))) = .true.
    do while (any (is_parent))
       where (is_real .and. is_parent)
          is_real_parent = .true.
          is_parent = .false.
       end where
       mark_next_parent: do j = size (is_parent), 1, -1
          if (is_parent(j)) then
             is_parent(particle_get_parents(pset%prt(j))) = .true.
             is_parent(j) = .false.
             exit mark_next_parent
          end if
       end do mark_next_parent
    end do
    allocate (parent (count (is_real_parent)))
    j = 0
    do k = 1, size (is_parent)
       if (is_real_parent(k)) then
          j = j + 1
          parent(j) = k
       end if
    end do
  end function particle_set_get_real_parents

  function particle_set_get_real_children (pset, i, keep_beams) result (child)
    integer, dimension(:), allocatable :: child
    type(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i
    logical, dimension(:), allocatable :: is_real
    logical, dimension(:), allocatable :: is_child, is_real_child
    logical, intent(in), optional :: keep_beams
    integer :: j, k
    logical :: kb
    kb = .false.
    if (present (keep_beams)) kb = keep_beams
    allocate (is_real (pset%n_tot))
    is_real = particle_is_real (pset%prt, kb)
    allocate (is_child (pset%n_tot), is_real_child (pset%n_tot))
    is_real_child = .false.
    is_child = .false.
    is_child(particle_get_children(pset%prt(i))) = .true.
    do while (any (is_child))
       where (is_real .and. is_child)
          is_real_child = .true.
          is_child = .false.
       end where
       mark_next_child: do j = 1, size (is_child)
          if (is_child(j)) then
             is_child(particle_get_children(pset%prt(j))) = .true.
             is_child(j) = .false.
             exit mark_next_child
          end if
       end do mark_next_child
    end do
    allocate (child (count (is_real_child)))
    j = 0
    do k = 1, size (is_child)
       if (is_real_child(k)) then
          j = j + 1
          child(j) = k
       end if
    end do
  end function particle_set_get_real_children

@ %def particle_set_get_real_parents
@ %def particle_set_get_real_children
@ Get the [[n_tot]], [[n_in]], and [[n_out]] values out of the
particle set.
<<Particles: public>>=
  public :: particle_set_get_n_beam
  public :: particle_set_get_n_in
  public :: particle_set_get_n_vir
  public :: particle_set_get_n_out
  public :: particle_set_get_n_tot
<<Particles: procedures>>=
  function particle_set_get_n_beam (pset) result (n_beam)
     type(particle_set_t), intent(in) :: pset
     integer :: n_beam
     n_beam = pset%n_beam
  end function particle_set_get_n_beam

  function particle_set_get_n_in (pset) result (n_in)
     type(particle_set_t), intent(in) :: pset
     integer :: n_in
     n_in = pset%n_in
  end function particle_set_get_n_in

  function particle_set_get_n_vir (pset) result (n_vir)
     type(particle_set_t), intent(in) :: pset
     integer :: n_vir
     n_vir = pset%n_in
   end function particle_set_get_n_vir

  function particle_set_get_n_out (pset) result (n_out)
     type(particle_set_t), intent(in) :: pset
     integer :: n_out
     n_out = pset%n_out
  end function particle_set_get_n_out
  
  function particle_set_get_n_tot (pset) result (n_tot)
     type(particle_set_t), intent(in) :: pset
     integer :: n_tot
     n_tot = pset%n_tot
  end function particle_set_get_n_tot

@ %def particle_set_get_n_beam
@ %def particle_set_get_n_in
@ %def particle_set_get_n_vir
@ %def particle_set_get_n_out
@ %def particle_set_get_n_tot
@ Return a pointer to the particle corresponding to the number
<<Particles: public>>=
  public :: particle_set_get_particle
<<Particles: procedures>>=
  function particle_set_get_particle(pset, index) result(particle)
    type(particle_set_t), intent(in) :: pset
    integer, intent(in) :: index
    type(particle_t) :: particle

    particle = pset%prt(index)
  end function particle_set_get_particle

@ %def particle_set_get_particle
@
\subsubsection{Tools}
Given a subevent, reset status codes.  If the new status is beam,
incoming, or outgoing, we also make sure that the stored $p^2$ value
is equal to the on-shell mass squared.
<<Particles: public>>=
  public :: particle_set_reset_status
<<Particles: procedures>>=
  subroutine particle_set_reset_status (particle_set, index, status)
    type(particle_set_t), intent(inout) :: particle_set
    integer, dimension(:), intent(in) :: index
    integer, intent(in) :: status
    integer :: i
    if (allocated (particle_set%prt)) then
       do i = 1, size (index)
          call particle_reset_status (particle_set%prt(index(i)), status)
       end do
    end if
    particle_set%n_beam  = &
         count (particle_get_status (particle_set%prt) == PRT_BEAM)
    particle_set%n_in  = &
         count (particle_get_status (particle_set%prt) == PRT_INCOMING)
    particle_set%n_out = &
         count (particle_get_status (particle_set%prt) == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_reset_status

@ %def particle_set_reset_status
@ Reduce a particle set to the essential entries.  The entries kept
are those with status [[INCOMING]], [[OUTGOING]] or
[[RESONANT]]. [[BEAM]] is kept if [[keep_beams]] is true. Other
entries are skipped.   
The correlated state matrix, if any, is also ignored.
<<Particles: public>>=
  public :: particle_set_reduce
<<Particles: procedures>>=
  subroutine particle_set_reduce (pset_in, pset_out, keep_beams)
    type(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams
    integer, dimension(:), allocatable :: status, map
    integer :: i, j
    logical :: kb
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    allocate (status (pset_in%n_tot))    
    status = particle_get_status (pset_in%prt)
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    pset_out%n_vir = count (status == PRT_RESONANT)
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    map = 0
    j = 0
    if (kb) call copy_particles (PRT_BEAM)
    call copy_particles (PRT_INCOMING)
    call copy_particles (PRT_RESONANT)
    call copy_particles (PRT_OUTGOING)
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       !!! !!! triggers nagfor bug!
       !!!  call particle_set_parents (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_parents (pset_in, i)))
       !!!  call particle_set_children (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_children (pset_in, i)))
       !!! !!! workaround:
       call particle_set_parents (pset_out%prt(map(i)), &
            particle_set_get_real_parents (pset_in, i, kb))
       call particle_set_parents (pset_out%prt(map(i)), &
            map (pset_out%prt(map(i))%parent))
       call particle_set_children (pset_out%prt(map(i)), &
            particle_set_get_real_children (pset_in, i, kb))
       call particle_set_children (pset_out%prt(map(i)), &
            map (pset_out%prt(map(i))%child))
    end do
  contains
    subroutine copy_particles (stat)
      integer, intent(in) :: stat
      integer :: i
      do i = 1, pset_in%n_tot
         if (status(i) == stat) then
            j = j + 1
            map(i) = j
            call particle_init (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles
  end subroutine particle_set_reduce

@ %def particles_set_reduce
@ Remove the beam particles and beam remnants from the particle set if the
keep beams flag is false. If keep beams is not given, the beam particles
and the beam remnants are removed.
The correlated state matrix, if any, is also ignored.
<<Particles: public>>=
  public :: particle_set_apply_keep_beams
<<Particles: procedures>>=
  subroutine particle_set_apply_keep_beams (pset_in, pset_out, keep_beams)
    type(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams
    integer, dimension(:), allocatable :: status, map
    integer :: i, j
    logical :: kb
    kb = .false.;  if (present (keep_beams))  kb = keep_beams
    allocate (status (pset_in%n_tot))    
    status = particle_get_status (pset_in%prt)
    if (kb)  pset_out%n_beam  = count (status == PRT_BEAM)
    pset_out%n_in  = count (status == PRT_INCOMING)
    if (kb) then
       pset_out%n_vir = count (status == PRT_VIRTUAL) + count (status == PRT_RESONANT) &
            + count (status == PRT_BEAM_REMNANT)
    else 
       pset_out%n_vir = count (status == PRT_VIRTUAL) + count (status == PRT_RESONANT)
    end if
    pset_out%n_out = count (status == PRT_OUTGOING)
    pset_out%n_tot = &
         pset_out%n_beam + pset_out%n_in + pset_out%n_vir + pset_out%n_out
    allocate (pset_out%prt (pset_out%n_tot))
    allocate (map (pset_in%n_tot))
    map = 0
    j = 0
    if (kb) call copy_particles (PRT_BEAM)
    call copy_particles (PRT_INCOMING)
    if (kb) call copy_particles (PRT_BEAM_REMNANT)
    call copy_particles (PRT_RESONANT)
    call copy_particles (PRT_VIRTUAL)
    call copy_particles (PRT_OUTGOING)
    do i = 1, pset_in%n_tot
       if (map(i) == 0)  cycle
       !!! !!! triggers nagfor bug!
       !!!  call particle_set_parents (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_parents (pset_in, i)))
       !!!  call particle_set_children (pset_out%prt(map(i)), &
       !!!       map (particle_set_get_real_children (pset_in, i)))
       !!! !!! workaround:
       call particle_set_parents (pset_out%prt(map(i)), &
            particle_set_get_real_parents (pset_in, i, kb))
       call particle_set_parents (pset_out%prt(map(i)), &
            map (pset_out%prt(map(i))%parent))
       call particle_set_children (pset_out%prt(map(i)), &
            particle_set_get_real_children (pset_in, i, kb))
       call particle_set_children (pset_out%prt(map(i)), &
            map (pset_out%prt(map(i))%child))
    end do
  contains
    subroutine copy_particles (stat)
      integer, intent(in) :: stat
      integer :: i
      do i = 1, pset_in%n_tot
         if (status(i) == stat) then
            j = j + 1
            map(i) = j
            call particle_init (pset_out%prt(j), pset_in%prt(i))
         end if
      end do
    end subroutine copy_particles
  end subroutine particle_set_apply_keep_beams

@ %def particles_set_apply_keep_beams
@ Transform a particle set into HEPEVT-compatible form.  In this form, for each
particle, the parents and the children are contiguous in the particle array.
Usually, this requires to clone some particles.

We do not know in advance how many particles the canonical form will have.
To be on the safe side, allocate four times the original size.
<<Particles: public>>=
  public :: particle_set_to_hepevt_form
<<Particles: procedures>>=
  subroutine particle_set_to_hepevt_form (pset_in, pset_out, keep_beams)
    type(particle_set_t), intent(in) :: pset_in
    type(particle_set_t), intent(out) :: pset_out
    logical, intent(in), optional :: keep_beams
    type(particle_set_t) :: pset
    type :: particle_entry_t
       integer :: src = 0
       integer :: status = 0
       integer :: orig = 0
       integer :: copy = 0
    end type particle_entry_t
    type(particle_entry_t), dimension(:), allocatable :: prt
    integer, dimension(:), allocatable :: map1, map2
    integer, dimension(:), allocatable :: parent, child
    integer :: n_tot, n_parents, n_children, i, j, c, n

    call particle_set_apply_keep_beams(pset_in, pset, keep_beams)
    n_tot = pset%n_tot
    allocate (prt (4 * n_tot))
    allocate (map1(4 * n_tot))
    allocate (map2(4 * n_tot))
    map1 = 0
    map2 = 0
    allocate (child (n_tot))
    allocate (parent (n_tot))
    n = 0
    do i = 1, n_tot
       if (particle_get_n_parents (pset%prt(i)) == 0) then
          call append (i)
       end if
    end do
    do i = 1, n_tot
       n_children = particle_get_n_children (pset%prt(i))
       if (n_children > 0) then
          child(1:n_children) = particle_get_children (pset%prt(i))
          c = child(1)
          if (map1(c) == 0) then
             n_parents = particle_get_n_parents (pset%prt(c))
             if (n_parents > 1) then
                parent(1:n_parents) = particle_get_parents (pset%prt(c))
		if (i == parent(1) .and. &
                    any( [(map1(i)+j-1, j=1,n_parents)] /= &
                           map1(parent(1:n_parents)))) &
                    then
                   do j = 1, n_parents
                      call append (parent(j))
                   end do
                end if
             else if (map1(i) == 0) then
                call append (i)
             end if
             do j = 1, n_children
                call append (child(j))
             end do
          end if
       else if (map1(i) == 0) then
          call append (i)
       end if
    end do
    do i = n, 1, -1
       if (prt(i)%status /= PRT_OUTGOING) then
          do j = 1, i-1
             if (prt(j)%status == PRT_OUTGOING) then
                call append(prt(j)%src)
             end if
          end do
          exit
       end if
    end do
    pset_out%n_beam = count (prt(1:n)%status == PRT_BEAM)
    pset_out%n_in   = count (prt(1:n)%status == PRT_INCOMING)
    pset_out%n_vir  = count (prt(1:n)%status == PRT_RESONANT)
    pset_out%n_out  = count (prt(1:n)%status == PRT_OUTGOING)
    pset_out%n_tot = n
    allocate (pset_out%prt (n))
    do i = 1, n
       call particle_init (pset_out%prt(i), pset%prt(prt(i)%src))
       call particle_reset_status (pset_out%prt(i), prt(i)%status)
       if (prt(i)%orig == 0) then
          !!! !!! This causes nagfor 5.2 (770) Panic
          !!!  call particle_set_parents &
          !!!       (pset_out%prt(i), &
          !!!        map2 (particle_get_parents (pset%prt(prt(i)%src))))
          !!! !!! Workaround
          n_parents = particle_get_n_parents (pset%prt(prt(i)%src))
          parent(1:n_parents) = particle_get_parents (pset%prt(prt(i)%src))
          call particle_set_parents (pset_out%prt(i), &
                                     map2(parent(1:n_parents)))
       else
          call particle_set_parents (pset_out%prt(i), [ prt(i)%orig ])
       end if
       if (prt(i)%copy == 0) then
          !!! !!! This causes nagfor 5.2 (770) Panic
          !!!  call particle_set_children &
          !!!       (pset_out%prt(i), &
          !!!        map1 (particle_get_children (pset%prt(prt(i)%src))))
          !!! !!! Workaround
          n_children = particle_get_n_children (pset%prt(prt(i)%src))
          child(1:n_children) = particle_get_children (pset%prt(prt(i)%src))
          call particle_set_children (pset_out%prt(i), &
                                      map1(child(1:n_children)))
       else
          call particle_set_children (pset_out%prt(i), [ prt(i)%copy ])
       end if
    end do
  contains
    subroutine append (i)
      integer, intent(in) :: i
      n = n + 1
      if (n > size (prt)) &
           call msg_bug ("Particle set transform to HEPEVT: insufficient space")
      prt(n)%src = i
      prt(n)%status = particle_get_status (pset%prt(i))
      if (map1(i) == 0) then
         map1(i) = n
      else
         prt(map2(i))%status = PRT_VIRTUAL
         prt(map2(i))%copy = n
         prt(n)%orig = map2(i)
      end if
      map2(i) = n
    end subroutine append
  end subroutine particle_set_to_hepevt_form

@ %def particle_set_to_hepevt_form
@ Reconstruct the momenta within an interaction object from a particle
set.  We start from the incoming particles, which should be stored at
the beginning.  (The number of incoming particles is provided
separately, so we do not need to analyze the interaction or particle
set for this.)  We follow their children down the tree until the
interaction is exhausted.

This implies that the particle set may contain a longer tree (e.g.,
decay chains) than the interaction.  The remainder of the tree is
simply ignored.

The detailed ordering of the subsequent sub-interactions may differ
between the interaction and the particle set.  However, within each
sub-interaction, the ordering of particles must match.

It may happen that the particle set lacks beam and remnant particles which are
present in the interaction.  In this case, the beam particles (the first two
entries in the interaction) will not be filled.  However, we can use the
source link of the beam particles to recover their momenta from the actual
beam interaction (which is stored somewhere else), and then recover the
beam-remnant momenta as the difference of the beam and parton momenta.
<<Particles: public>>=
  public :: particle_set_fill_interaction
<<Particles: procedures>>=
  subroutine particle_set_fill_interaction (pset, int, n_in, recover_beams)
    type(particle_set_t), intent(in) :: pset
    type(interaction_t), intent(inout) :: int
    integer, intent(in) :: n_in
    logical, intent(in), optional :: recover_beams
    logical, dimension(:), allocatable :: p_is_set
    logical :: recover
    integer, dimension(:), allocatable :: i_parent, j_parent
    integer :: n_tot, k
    n_tot = interaction_get_n_tot (int)
    recover = .false.;  if (present (recover_beams))  recover = recover_beams
    allocate (p_is_set (n_tot), source = .false.)
    allocate (i_parent (n_in), source = [(k, k = 1, n_in)])
    allocate (j_parent (n_in), source = i_parent)
    do k = 1, n_in
       call fill_subint (i_parent(k), j_parent(k))
    end do
    if (recover) then
       do k = 1, n_in
          call recover_beam_and_remnant (k)
       end do
    end if
    if (.not. all (p_is_set)) then
       call particle_set_write (pset)
       call interaction_write (int)
       call msg_fatal ("Mismatch between particle set and interaction")
    end if
  contains
    recursive subroutine fill_subint (i, j)
      integer, intent(in) :: i, j
      integer, dimension(:), allocatable :: i_child, j_child
      integer :: n_child, n_child_pset, k
      if (p_is_set(i))  return
      call interaction_set_momentum (int, &
           particle_get_momentum (pset%prt(j)), i)
      p_is_set(i) = .true.
      n_child = interaction_get_n_children (int, i)
      n_child_pset = particle_get_n_children (pset%prt(j))
      if (n_child /= 0 .and. n_child == n_child_pset) then
         allocate (i_child (n_child))
         allocate (j_child (n_child))
         i_child = interaction_get_children (int, i)
         j_child = particle_get_children (pset%prt(j))
         do k = 1, n_child
            call fill_subint (i_child(k), j_child(k))
         end do
      end if
    end subroutine fill_subint
    subroutine recover_beam_and_remnant (k)
      integer, intent(in) :: k
      integer :: k_src, k_in, k_rem
      type(interaction_t), pointer :: int_src
      integer, dimension(2) :: i_child
      call interaction_find_source (int, k, int_src, k_src)
      call interaction_set_momentum (int, &
           interaction_get_momentum (int_src, k_src), k)
      i_child = interaction_get_children (int, k)
      if (interaction_get_n_children (int, i_child(1)) > 0) then
         k_in = i_child(1);  k_rem = i_child(2)
      else
         k_in = i_child(2);  k_rem = i_child(1)
      end if
      call interaction_set_momentum (int, &
           interaction_get_momentum (int, k) &
           - interaction_get_momentum (int, k_in), k_rem)
    end subroutine recover_beam_and_remnant
  end subroutine particle_set_fill_interaction
    
@ %def particle_set_fill_interaction
@ This reconstructs the hard interaction from a particle set.  First the
particle set is reduced to the incoming partons, then we add the direct
children of those.  The interaction and particle set should match in their
array sizes.  If we find a permutation of the particle flavors that matches
one of the given flavor states, the assignment of momenta is made
accordingly.
<<Particles: public>>=
  public :: particle_set_extract_interaction
<<Particles: procedures>>=
  subroutine particle_set_extract_interaction (pset, int, flv_state)
    type(particle_set_t), intent(in) :: pset
    type(interaction_t), intent(inout) :: int
    integer, dimension(:,:), intent(in) :: flv_state
    integer :: n_in, n_out, n_tot
    integer, dimension(:), allocatable :: status, incoming, outgoing, index
    integer, dimension(:), allocatable :: pdg, perm
    integer :: i
    logical :: ok
    allocate (status (pset%n_tot))
    status = particle_get_status (pset%prt)
    n_in = count (status == PRT_INCOMING)
    allocate (incoming (n_in))
    incoming = pack ([ (i, i = 1, pset%n_tot) ], status == PRT_INCOMING)
    i = incoming (1)
    n_out = particle_get_n_children (pset%prt(i))
    allocate (outgoing (n_out))
    outgoing = particle_get_children (pset%prt(i))
    n_tot = n_in + n_out
    if (n_in /= interaction_get_n_in (int) &
         .or. n_out /= interaction_get_n_out (int) &
         .or. n_tot /= interaction_get_n_tot (int)) then
       call msg_fatal &
            ("This event does not match the associated process (size)")
       return
    end if
    allocate (index (n_tot), pdg (n_tot), perm (n_tot))
    index(:n_in) = incoming
    index(n_in+1:) = outgoing
    pdg = particle_get_pdg (pset%prt(index))
    call find_flavor_ordering (flv_state, pdg, n_in, perm, ok)
    if (.not. ok) then
       call particle_set_write (pset)
       call msg_fatal &
            ("This event does not match the associated process (flavors)")
       return
    end if
    do i = 1, n_tot
       call interaction_set_momentum (int, &
            particle_get_momentum (pset%prt(i)), perm(i))
    end do
  end subroutine particle_set_extract_interaction

@ %def particle_set_extract_interaction
@ Given a particle set with an arbitrary ordering of particles, we need the
permutation that yields an ordering that is present in the state matrix.  This
can be found by examining the flavor table.  The result is a permutation of
the PDG array that matches a row in the flavor table.  If [[ok]] is returned
false, no match was found.
<<Particles: procedures>>=
  subroutine find_flavor_ordering (flv_state, pdg, n_in, perm, ok)
    integer, dimension(:,:), intent(in) :: flv_state
    integer, dimension(:), intent(in) :: pdg
    integer, intent(in) :: n_in
    integer, dimension(:), intent(out) :: perm
    logical, intent(out) :: ok
    integer :: n_tot, f, i, j, k
    logical, dimension(:), allocatable :: found
    n_tot = size (pdg)
    if (size (flv_state, 1) /= n_tot) then
       ok = .false.
       return
    end if
    do i = 1, n_in
       perm(i) = i
    end do
    allocate (found (n_tot))
    ok = .false.
    do f = 1, size (flv_state, 2)
       call find_ordering_for_this_state (flv_state(:,f))
    end do
  contains
    subroutine find_ordering_for_this_state (pdg_state)    
      integer, dimension(:), intent(in) :: pdg_state
      found = .false.
      if (all (pdg_state(1:n_in) == pdg(1:n_in))) then
         SCAN_INPUT: do j = n_in + 1, n_tot
            SCAN_STATE: do k = n_in + 1, n_tot
              if (found(k))  cycle SCAN_STATE
              if (pdg_state(k) == pdg(j)) then
                 found(k) = .true.
                 perm(j) = k
                 cycle SCAN_INPUT
              end if
            end do SCAN_STATE
            return
         end do SCAN_INPUT
         ok = .true.
      end if
    end subroutine find_ordering_for_this_state
  end subroutine find_flavor_ordering

@ %def find_flavor_ordering
@
This procedure reconstructs an array of vertex indices from the
parent-child information in the particle entries, according to the
HepMC scheme.  For each particle, we determine which vertex it comes
from and which vertex it goes to.  We return the two arrays and the
maximum vertex index.

For each particle in the list, we first check its parents.  If for any
parent the vertex where it goes to is already known, this vertex index
is assigned as the current 'from' vertex.  Otherwise, a new index is
created, assigned as the current 'from' vertex, and as the 'to' vertex
for all parents.

Then, the analogous procedure is done for the children.
<<Particles: public>>=
  public :: particle_set_assign_vertices
<<Particles: procedures>>=
  subroutine particle_set_assign_vertices &
       (particle_set, v_from, v_to, n_vertices)
    type(particle_set_t), intent(in) :: particle_set
    integer, dimension(:), intent(out) :: v_from, v_to
    integer, intent(out) :: n_vertices
    integer, dimension(:), allocatable :: parent, child
    integer :: n_parents, n_children, vf, vt
    integer :: i, j, v
    v_from = 0
    v_to = 0
    vf = 0
    vt = 0
    do i = 1, particle_set%n_tot
       n_parents = particle_get_n_parents (particle_set%prt(i))
       if (n_parents /= 0) then
          allocate (parent (n_parents))
          parent = particle_get_parents (particle_set%prt(i))
          SCAN_PARENTS: do j = 1, size (parent)
             v = v_to(parent(j))
             if (v /= 0) then
                v_from(i) = v;  exit SCAN_PARENTS
             end if
          end do SCAN_PARENTS
          if (v_from(i) == 0) then
             vf = vf + 1;  v_from(i) = vf
             v_to(parent) = vf
          end if
          deallocate (parent)
       end if
       n_children = particle_get_n_children (particle_set%prt(i))
       if (n_children /= 0) then
          allocate (child (n_children))
          child = particle_get_children (particle_set%prt(i))
          SCAN_CHILDREN: do j = 1, size (child)
             v = v_from(child(j))
             if (v /= 0) then
                v_to(i) = v;  exit SCAN_CHILDREN
             end if
          end do SCAN_CHILDREN
          if (v_to(i) == 0) then
             vt = vt + 1;  v_to(i) = vt
             v_from(child) = vt
          end if
          deallocate (child)
       end if
    end do
    n_vertices = max (vf, vt)
  end subroutine particle_set_assign_vertices

@ %def particle_set_make_assign_vertices
@ 
\subsection{Expression interface}
This converts a [[particle_set]] object as defined here to a more
concise [[subevt]] object that can be used as the event root of an
expression.  In particular, the latter lacks virtual particles, spin
correlations and parent-child relations.
<<Particles: public>>=
  public :: particle_set_to_subevt
<<Particles: procedures>>=
  subroutine particle_set_to_subevt (particle_set, subevt)
    type(particle_set_t), intent(in), target :: particle_set
    type(subevt_t), intent(out) :: subevt
    type(particle_t), pointer :: prt
    integer :: i, k
    integer, dimension(2) :: hel
    call subevt_init &
         (subevt, particle_set%n_beam + particle_set%n_in + particle_set%n_out)
    k = 0
    do i = 1, particle_set%n_tot
       prt => particle_set%prt(i)
       select case (particle_get_status (prt))
       case (PRT_BEAM)
          k = k + 1
          call subevt_set_beam (subevt, k, &
               particle_get_pdg (prt), &
               particle_get_momentum (prt), &
               particle_get_p2 (prt))
       case (PRT_INCOMING)
          k = k + 1
          call subevt_set_incoming (subevt, k, &
               particle_get_pdg (prt), &
               particle_get_momentum (prt), &
               particle_get_p2 (prt))
       case (PRT_OUTGOING)
          k = k + 1
          call subevt_set_outgoing (subevt, k, &
               particle_get_pdg (prt), &
               particle_get_momentum (prt), &
               particle_get_p2 (prt))
       end select
       select case (particle_get_status (prt))
       case (PRT_BEAM, PRT_INCOMING, PRT_OUTGOING)
          if (prt%polarization == PRT_DEFINITE_HELICITY) then
             if (helicity_is_diagonal (prt%hel)) then
                hel = helicity_get (prt%hel)
                call subevt_polarize (subevt, k, hel(1))
             end if
          end if
       end select
    end do
  end subroutine particle_set_to_subevt

@ %def particle_set_to_subevt
@ 
This replaces the particle\_set%prt array with a given array of particles
<<Particles: public>>=
  public :: particle_set_replace
<<Particles: procedures>>=
  subroutine particle_set_replace (particle_set, newprt)
    type(particle_set_t), intent(inout) :: particle_set
    type(particle_t), intent(in), dimension(:), allocatable :: newprt
    if (allocated (particle_set%prt))  deallocate (particle_set%prt)
    allocate (particle_set%prt(size (newprt)))
    particle_set%prt = newprt
    particle_set%n_tot = size (newprt)
    particle_set%n_beam = count (particle_get_status (newprt) == PRT_BEAM)
    particle_set%n_in = count (particle_get_status (newprt) == PRT_INCOMING)
    particle_set%n_out = count (particle_get_status (newprt) == PRT_OUTGOING)
    particle_set%n_vir = particle_set%n_tot &
         - particle_set%n_beam - particle_set%n_in - particle_set%n_out
  end subroutine particle_set_replace

@ %def particle_set_replace
@
Eliminate numerical noise
<<Particles: public>>=
  public :: pacify
<<Particles: interfaces>>=
  interface pacify
     module procedure pacify_particle
     module procedure pacify_particle_set
  end interface pacify

<<Particles: procedures>>=
  subroutine pacify_particle (prt)
    class(particle_t), intent(inout) :: prt
    real(default) :: e
    e = epsilon (1._default) * energy (prt%p)
    call pacify (prt%p, 10 * e)
    call pacify (prt%p2, 1e4 * e)
  end subroutine pacify_particle
  
  subroutine pacify_particle_set (pset)
    class(particle_set_t), intent(inout) :: pset
    integer :: i
    do i = 1, pset%n_tot
       call pacify (pset%prt(i))
    end do
  end subroutine pacify_particle_set

@ %def pacify
@ 
\subsection{Unit tests}
Set up a chain of production and decay and factorize the result into
particles.  The process is $d\bar d \to Z \to q\bar q$.
<<Particles: public>>=
  public :: particles_test
<<Particles: procedures>>=
  subroutine particles_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Particles: execute tests>>  
  end subroutine particles_test

@  %def particles_test  
@ Check the basic setup of the [[particle_set_t]] type.
<<Particles: execute tests>>=
  call test (particles_1, "particles_1", &
       "check particle_set routines", &
       u, results)
<<Particles: tests>>=  
  subroutine particles_1 (u)
<<Particles: common test code 1>>

    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: test particle_set routines"
    write (u, "(A)")      
    
<<Particles: common test code 2>>
        
    write (u, "(A)")
    write (u, "(A)")  &
         "* Factorize (complete, polarized, correlated); write and read again"
    write (u, "(A)")
    
    int => evaluator_get_int_ptr (eval)
    call particle_set_init &
         (particle_set3, ok, int, int, FM_FACTOR_HELICITY, &
          [0.7_default, 0.7_default], .true., .true.)
    call particle_set_write (particle_set3, u)

!!! Raw I/O with state matrices currently disabled, cf. #627.
    !!! unit = free_unit ()
    !!! open (unit, action="readwrite", form="unformatted", status="scratch")
    !!! call particle_set_write_raw (particle_set3, unit)
    !!! rewind (unit)
    !!! call particle_set_read_raw (particle_set4, unit, iostat=iostat)
    !!! close (unit)
    !!! 
    !!! write (u, "(A)")
    !!! call particle_set_write (particle_set4, u)
    !!! write (u, "(A)")
    !!! write (u, "(A)")  "* Transform to a subevt object"
    !!! write (u, "(A)")
    !!! 
    !!! call particle_set_to_subevt (particle_set4, subevt)
    !!! call subevt_write (subevt, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call particle_set_final (particle_set1)
    call particle_set_final (particle_set2)
    call particle_set_final (particle_set3)
    call particle_set_final (particle_set4)
    call evaluator_final (eval)
    call interaction_final (int1)
    call interaction_final (int2)

    call model%final ()
       
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_1"        
    
  end subroutine particles_1

@ %def particles_1
@ If [[HepMC]] is available, check the routines via [[HepMC]].
<<Particles: execute tests>>=
  if (hepmc_is_available ()) then
     call test (particles_2, "particles_2", &
          "check particle_set routines via HepMC", &
          u, results)
  end if
<<Particles: tests>>=
  subroutine particles_2 (u)
<<Particles: common test code 1>>

    write (u, "(A)")  "* Test output: Particles"
    write (u, "(A)")  "*   Purpose: test particle_set routines via HepMC"
    write (u, "(A)")      
       
<<Particles: common test code 2>>

    write (u, "(A)")
    write (u, "(A)")  "* Transfer particle_set to HepMC, print, and output to"
    write (u, "(A)")  "        particles_test.hepmc.dat"
    write (u, "(A)")
    
    call hepmc_event_init (hepmc_event, 11, 127)
    call hepmc_event_from_particle_set (hepmc_event, particle_set2)
    call hepmc_event_print (hepmc_event)
    call hepmc_iostream_open_out &
         (iostream , var_str ("particles_test.hepmc.dat"))
    call hepmc_iostream_write_event (iostream, hepmc_event)
    call hepmc_iostream_close (iostream)

    write (u, "(A)")
    write (u, "(A)")  "* Recover from HepMC file"
    write (u, "(A)")
    
    call particle_set_final (particle_set2)
    call hepmc_event_final (hepmc_event)
    call hepmc_event_init (hepmc_event)
    call hepmc_iostream_open_in &
         (iostream , var_str ("particles_test.hepmc.dat"))
    call hepmc_iostream_read_event (iostream, hepmc_event, ok)
    call hepmc_iostream_close (iostream)
    call particle_set_init (particle_set2, &
         hepmc_event, model, model, PRT_DEFINITE_HELICITY)
    call particle_set_write (particle_set2, u)   

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call particle_set_final (particle_set1)
    call particle_set_final (particle_set2)
    call evaluator_final (eval)
    call interaction_final (int1)
    call interaction_final (int2)
    call hepmc_event_final (hepmc_event)            
    call model%final ()
       
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: particles_2"

  end subroutine particles_2
  
@ 
@ %def particles_2
<<Particles: common test code 1>>=
    use os_interface
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(3) :: flv
    type(color_t), dimension(3) :: col
    type(helicity_t), dimension(3) :: hel
    type(quantum_numbers_t), dimension(3) :: qn
    type(vector4_t), dimension(3) :: p
    type(interaction_t), target :: int1, int2
    type(quantum_numbers_mask_t) :: qn_mask_conn, qn_rest
    type(evaluator_t), target :: eval
    type(interaction_t), pointer :: int
    type(particle_set_t) :: particle_set1, particle_set2
    type(particle_set_t) :: particle_set3, particle_set4
    type(subevt_t) :: subevt
    type(hepmc_event_t) :: hepmc_event
    type(hepmc_iostream_t) :: iostream    
    logical :: ok
    integer :: unit, iostat  
@ 
<<Particles: common test code 2>>=
    write (u, "(A)")  "* Reading model file"

    call model%init_sm_test ()

    write (u, "(A)")
    write (u, "(A)")  "* Initializing production process"

    call interaction_init (int1, 2, 0, 1, set_relations=.true.)
    call flavor_init (flv, [1, -1, 23], model)
    call helicity_init (hel(3), 1, 1)
    call quantum_numbers_init (qn, flv, hel)
    call interaction_add_state (int1, qn, value=(0.25_default, 0._default))
    call helicity_init (hel(3), 1,-1)
    call quantum_numbers_init (qn, flv, hel)
    call interaction_add_state (int1, qn, value=(0._default, 0.25_default))
    call helicity_init (hel(3),-1, 1)
    call quantum_numbers_init (qn, flv, hel)
    call interaction_add_state (int1, qn, value=(0._default,-0.25_default))
    call helicity_init (hel(3),-1,-1)
    call quantum_numbers_init (qn, flv, hel)
    call interaction_add_state (int1, qn, value=(0.25_default, 0._default))
    call helicity_init (hel(3), 0, 0)
    call quantum_numbers_init (qn, flv, hel)
    call interaction_add_state (int1, qn, value=(0.5_default, 0._default))
    call interaction_freeze (int1)
    p(1) = vector4_moving (45._default, 45._default, 3)
    p(2) = vector4_moving (45._default,-45._default, 3)
    p(3) = p(1) + p(2)
    call interaction_set_momenta (int1, p)

    write (u, "(A)")
    write (u, "(A)")  "* Setup decay process"

    call interaction_init (int2, 1, 0, 2, set_relations=.true.)
    call flavor_init (flv, [23, 1, -1], model)
    call color_init_col_acl (col, [0, 501, 0], [0, 0, 501])
    call helicity_init (hel, [1, 1, 1], [1, 1, 1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(1._default, 0._default))
    call helicity_init (hel, [1, 1, 1], [-1,-1,-1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(0._default, 0.1_default))
    call helicity_init (hel, [-1,-1,-1], [1, 1, 1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(0._default,-0.1_default))
    call helicity_init (hel, [-1,-1,-1], [-1,-1,-1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(1._default, 0._default))
    call helicity_init (hel, [0, 1,-1], [0, 1,-1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(4._default, 0._default))
    call helicity_init (hel, [0,-1, 1], [0, 1,-1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(2._default, 0._default))
    call helicity_init (hel, [0, 1,-1], [0,-1, 1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(2._default, 0._default))
    call helicity_init (hel, [0,-1, 1], [0,-1, 1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(4._default, 0._default))
    call flavor_init (flv, [23, 2, -2], model)
    call helicity_init (hel, [0, 1,-1], [0, 1,-1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(0.5_default, 0._default))
    call helicity_init (hel, [0,-1, 1], [0,-1, 1])
    call quantum_numbers_init (qn, flv, col, hel)
    call interaction_add_state (int2, qn, value=(0.5_default, 0._default))
    call interaction_freeze (int2)
    p(2) = vector4_moving (45._default, 45._default, 2)
    p(3) = vector4_moving (45._default,-45._default, 2)
    call interaction_set_momenta (int2, p)
    call interaction_set_source_link (int2, 1, int1, 3)
    call interaction_write (int1, u)
    call interaction_write (int2, u)

    write (u, "(A)")
    write (u, "(A)")  "* Concatenate production and decay"

    call evaluator_init_product (eval, int1, int2, qn_mask_conn, &
         connections_are_resonant=.true.)
    call evaluator_receive_momenta (eval)
    call eval%evaluate ()
    call eval%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, polarized)"
    write (u, "(A)")
    
    int => evaluator_get_int_ptr (eval)
    call particle_set_init &
         (particle_set1, ok, int, int, FM_FACTOR_HELICITY, &
          [0.2_default, 0.2_default], .false., .true.)
    call particle_set_write (particle_set1, u)

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (in/out only, selected helicity)"
    write (u, "(A)")
    
    int => evaluator_get_int_ptr (eval)
    call particle_set_init &
         (particle_set2, ok, int, int, FM_SELECT_HELICITY, &
          [0.9_default, 0.9_default], .false., .false.)
    call particle_set_write (particle_set2, u)
    call particle_set_final (particle_set2)

    write (u, "(A)")
    write (u, "(A)")  "* Factorize as subevent (complete, selected helicity)"
    write (u, "(A)") 
    
    int => evaluator_get_int_ptr (eval)
    call particle_set_init &
         (particle_set2, ok, int, int, FM_SELECT_HELICITY, &
          [0.7_default, 0.7_default], .false., .true.)
    call particle_set_write (particle_set2, u)  
@ 

  

