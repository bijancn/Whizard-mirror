% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: matrix elements and process libraries

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{OpenLoops Interface}

The interface to OpenLoops.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_openloops.f90]]>>=
<<File header>>

module prc_openloops

  use, intrinsic :: iso_c_binding !NODEP!

  use kinds
  use io_units
<<Use strings>>
  use system_defs, only: TAB
  use diagnostics
  use physics_defs
  use os_interface
  use lorentz
  use interactions
  use sm_qcd

  use prclib_interfaces
  use prc_core_def
  use prc_core

  use blha_olp_interfaces

<<Standard module head>>

<<prc openloops: public>>

<<prc openloops: types>>

<<prc openloops: interfaces>>

contains

<<prc openloops: procedures>>

end module prc_openloops

@ %def module prc_openloops
@
<<prc openloops: interfaces>>=
  abstract interface
     subroutine omega_update_alpha_s (alpha_s) bind(C)
       import
       real(c_default_float), intent(in) :: alpha_s
     end subroutine omega_update_alpha_s
  end interface

<<prc openloops: types>>=
  type, extends (prc_writer_f_module_t) :: openloops_writer_t
    type(string_t) :: model_name
    type(string_t) :: process_mode
    type(string_t) :: process_string
  contains
  <<prc openloops: openloops writer: TBP>>
  end type openloops_writer_t

@ %def openloops_writer_t
@
<<prc openloops: public>>=
  public :: openloops_def_t
<<prc openloops: types>>=
  type, extends (prc_core_def_t) :: openloops_def_t
    type(string_t) :: basename, suffix
  contains
  <<prc openloops: openloops def: TBP>>
  end type openloops_def_t

@ %def openloops_def_t
@
<<prc openloops: types>>=
  type, extends (prc_core_driver_t) :: openloops_driver_t 
    type(string_t) :: olp_file
    procedure(olp_start), nopass, pointer :: &
      openloops_olp_start => null ()
    procedure(olp_eval2), nopass, pointer :: &
      openloops_olp_eval2 => null ()
    procedure(olp_set_parameter), nopass, pointer :: &
      openloops_olp_set_parameter => null ()
    procedure(olp_print_parameter), nopass, pointer :: &
      openloops_olp_print_parameter => null ()     
    procedure(omega_update_alpha_s), nopass, pointer :: &
      update_alpha_s => null ()
  contains
  <<prc openloops: openloops driver: TBP>>
  end type openloops_driver_t 

@ %def openloops_driver_t
@
<<prc openloops: types>>=
  type, extends (prc_core_state_t) :: openloops_state_t
     real(default) :: alpha_qcd = -1
     logical :: new_kinematics = .true.
  contains
  <<prc openloops: openloops state: TBP>>
  end type openloops_state_t

@ %def openloops_state_t
@
<<prc openloops: public>>=
  public :: prc_openloops_t
<<prc openloops: types>>=
  type, extends (prc_core_t) :: prc_openloops_t
    integer :: n_flv
    type(qcd_t) :: qcd
  contains
  <<prc openloops: prc openloops: TBP>>
  end type prc_openloops_t

@ %def prc_openloops_t
@
<<prc openloops: openloops writer: TBP>>=
  procedure :: init => openloops_writer_init 
<<prc openloops: procedures>>=
  subroutine openloops_writer_init (writer, model_name, prt_in, prt_out)
    class(openloops_writer_t), intent(inout) :: writer
    type(string_t), intent(in) :: model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    
    writer%model_name = model_name
    select case (size (prt_in))
       case(1); writer%process_mode = " -decay"
       case(2); writer%process_mode = " -scatter"
    end select

    associate (s => writer%process_string)
      s = " '" 
      do i = 1, size (prt_in)
         if (i > 1) s = s // " "
         s = s // prt_in(i)
      end do
      s = s // " ->"
      do i = 1, size (prt_out)
         s = s // " " // prt_out(i)
      end do
      s = s // "'"
    end associate
  end subroutine openloops_writer_init

@ %def openloops_writer_init
@
<<prc openloops: openloops writer: TBP>>=
  procedure :: write_interface => openloops_writer_write_interface
<<prc openloops: procedures>>= 
  subroutine openloops_writer_write_interface (writer, unit, id, feature)
    class(openloops_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: feature
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, "(2x,9A)")  "interface"
    select case (char (feature))
    case ("init")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: alpha_s"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(threshold, cutoff) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), intent(in) :: threshold"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: cutoff"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, flag) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "real(c_default_float), dimension(0:3,*), &
            &intent(in) :: p"
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(5x,9A)")  "subroutine ", char (name), " &
            &(flv, hel, col, amp) bind(C)"
       write (unit, "(7x,9A)")  "import"
       write (unit, "(7x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(7x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(5x,9A)")  "end subroutine ", char (name)
    end select
    write (unit, "(2x,9A)")  "end interface"
  end subroutine openloops_writer_write_interface

@
@ %def openloops_writer_write_interface
<<prc openloops: openloops writer: TBP>>=
  procedure :: write_makefile_code => openloops_write_makefile_code
<<prc openloops: procedures>>=
  subroutine openloops_write_makefile_code (writer, unit, id, os_data, testflag)
    class(openloops_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: testflag
    type(string_t) :: omega_binary, omega_path
    omega_binary = "omega_" // writer%model_name // ".opt"
    omega_path = os_data%whizard_omega_binpath // "/" // omega_binary
    write (unit, "(5A)")  "OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".f90:"
    write (unit, "(99A)")  TAB, char (omega_path), &
         " -o ", char (id), ".f90", &
         " -target:whizard", &
         " -target:parameter_module parameters_", char (writer%model_name), &
         " -target:module opr_", char (id), &
         " -target:md5sum '", writer%md5sum, "'", &
         char (writer%process_mode), char (writer%process_string)
    write (unit, "(5A)")  "clean-", char (id), ":"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "rm -f opr_", char (id), ".mod"
    write (unit, "(5A)")  TAB, "rm -f ", char (id), ".lo"
    write (unit, "(5A)")  "CLEAN_SOURCES += ", char (id), ".f90"    
    write (unit, "(5A)")  "CLEAN_OBJECTS += opr_", char (id), ".mod"       
    write (unit, "(5A)")  "CLEAN_OBJECTS += ", char (id), ".lo"
    write (unit, "(5A)")  char (id), ".lo: ", char (id), ".f90"
    write (unit, "(5A)")  TAB, "$(LTFCOMPILE) $<"

  end subroutine openloops_write_makefile_code

@
@ %def openloops_write_makefile_code
<<prc openloops: openloops writer: TBP>>=
  procedure :: write_source_code => openloops_write_source_code
<<prc openloops: procedures>>=
  subroutine openloops_write_source_code (writer, id)
    class(openloops_writer_t), intent(in) :: writer
    type(string_t), intent(in) :: id
  end subroutine openloops_write_source_code

@ 
@ %def openloops_write_source_code
<<prc openloops: openloops writer: TBP>>=
  procedure :: write_wrapper => openloops_write_wrapper
<<prc openloops: procedures>>=
  subroutine openloops_write_wrapper (writer, unit, id, feature)
    class(openloops_writer_t), intent(in) :: writer
    integer, intent(in) :: unit
    type(string_t), intent(in) :: id, feature    
    type(string_t) :: name
    name = writer%get_c_procname (id, feature)
    write (unit, *)
    select case (char (feature))
    case ("init")
       write (unit, "(9A)")  "subroutine ", char (name), " (par) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "real(c_default_float), dimension(*), &
            &intent(in) :: par"
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "call ", char (feature), " (par)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("update_alpha_s")
       write (unit, "(9A)")  "subroutine ", char (name), " (alpha_s) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: alpha_s"
          write (unit, "(2x,9A)")  "call ", char (feature), " (alpha_s)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("reset_helicity_selection")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (threshold, cutoff) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), intent(in) &
               &:: threshold"
          write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: cutoff"
          write (unit, "(2x,9A)")  "call ", char (feature), &
               " (threshold, int (cutoff))"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("is_allowed")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, flag) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "logical(c_bool), intent(out) :: flag"    
       write (unit, "(2x,9A)")  "flag = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("new_event")
       write (unit, "(9A)")  "subroutine ", char (name), " (p) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       if (c_default_float == default) then
          write (unit, "(2x,9A)")  "real(c_default_float), dimension(0:3,*), &
               &intent(in) :: p"
          write (unit, "(2x,9A)")  "call ", char (feature), " (p)"
       end if
       write (unit, "(9A)")  "end subroutine ", char (name)
    case ("get_amplitude")
       write (unit, "(9A)")  "subroutine ", char (name), &
            " (flv, hel, col, amp) bind(C)"
       write (unit, "(2x,9A)")  "use iso_c_binding"
       write (unit, "(2x,9A)")  "use kinds"
       write (unit, "(2x,9A)")  "use opr_", char (id)
       write (unit, "(2x,9A)")  "integer(c_int), intent(in) :: flv, hel, col"
       write (unit, "(2x,9A)")  "complex(c_default_complex), intent(out) &
            &:: amp"    
       write (unit, "(2x,9A)")  "amp = ", char (feature), &
            " (int (flv), int (hel), int (col))"
       write (unit, "(9A)")  "end subroutine ", char (name)
    end select

  end subroutine openloops_write_wrapper

@
@ %def openloops_write_wrapper
<<prc openloops: openloops writer: TBP>>=
  procedure, nopass :: get_module_name => openloops_writer_get_module_name
<<prc openloops: procedures>>=
  function openloops_writer_get_module_name (id) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: id
    name = "opr_" // id
  end function openloops_writer_get_module_name

@ %def openloops_writer_get_module_name
@
<<prc openloops: openloops writer: TBP>>=
  procedure, nopass:: get_procname => openloops_writer_get_procname
<<prc openloops: procedures>>=
  function openloops_writer_get_procname (feature) result (name)
    type(string_t) :: name
    type(string_t), intent(in) :: feature
    select case (char (feature))
    case ("n_in");   name = "number_particles_in"
    case ("n_out");  name = "number_particles_out"
    case ("n_flv");  name = "number_flavor_states"
    case ("n_hel");  name = "number_spin_states"
    case ("n_col");  name = "number_color_flows"
    case ("n_cin");  name = "number_color_indices"
    case ("n_cf");   name = "number_color_factors"
    case ("flv_state");  name = "flavor_states"
    case ("hel_state");  name = "spin_states"
    case ("col_state");  name = "color_flows"
    case default
       name = feature
    end select
  end function openloops_writer_get_procname

@ %def openloops_writer_get_procname
@
<<prc openloops: openloops writer: TBP>>=
  procedure, nopass :: type_name => openloops_writer_type_name
<<prc openloops: procedures>>=
  function openloops_writer_type_name () result (string)
    type(string_t) :: string
    string = "openloops"
  end function openloops_writer_type_name

@
@ %def openloops_writer_type_name
<<prc openloops: openloops def: TBP>>=
  procedure :: init => openloops_def_init
<<prc openloops: procedures>>=
  subroutine openloops_def_init (object, basename, model_name, &
                                 prt_in, prt_out, nlo_type)
    class(openloops_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename, model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer :: nlo_type
    object%basename = basename
    allocate (openloops_writer_t :: object%writer)
    select case (nlo_type)
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    end select
    select type (writer => object%writer)
    type is (openloops_writer_t)
       call writer%init (model_name, prt_in, prt_out)
    end select
  end subroutine openloops_def_init

@ %def openloops_def_init
@
<<prc openloops: openloops def: TBP>>=
  procedure, nopass :: needs_code => openloops_def_needs_code
<<prc openloops: procedures>>=
  function openloops_def_needs_code () result (flag)
    logical :: flag
    flag = .true.
  end function openloops_def_needs_code

@ %def openloops_def_needs_code
@
<<prc openloops: openloops def: TBP>>=
  procedure, nopass :: type_string => openloops_def_type_string
<<prc openloops: procedures>>=
  function openloops_def_type_string () result (string)
    type(string_t) :: string
    string = "openloops"
  end function openloops_def_type_string

@ 
@ %def openloops_def_type_string
<<prc openloops: openloops def: TBP>>=
  procedure :: write => openloops_def_write
<<prc openloops: procedures>>=
  subroutine openloops_def_write (object, unit)
    class(openloops_def_t), intent(in) :: object
    integer, intent(in) :: unit
    !!! Dummy method
  end subroutine openloops_def_write

@ 
@ %def openloops_def_write
<<prc openloops: openloops driver: TBP>>=
  procedure :: load => openloops_driver_load
<<prc openloops: procedures>>=
  subroutine openloops_driver_load (object, os_data, success)
    class(openloops_driver_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical, intent(out) :: success
    integer(c_int) :: ol_register_process
    type(dlaccess_t) :: dlaccess
    type(string_t) :: path
    type(c_funptr) :: c_fptr
    path = '/scratch/OpenLoops/lib/libopenloops.so'
    if (os_file_exist (path)) then
       call dlaccess_init (dlaccess, var_str ("."), path, os_data)
    else
       call msg_fatal ("Link OpenLoops: library not found")
    end if

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_Start"))
    call c_f_procpointer (c_fptr, object%openloops_olp_start)
    if (dlaccess_has_error (dlaccess)) &
       call msg_fatal ("Loading of OLP_Start failed!")

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_EvalSubProcess2"))
    call c_f_procpointer (c_fptr, object%openloops_olp_eval2)
    if (dlaccess_has_error (dlaccess)) &
       call msg_fatal ("Loading of OLP_EvalSubProcess2 failed!")

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_SetParameter"))
    call c_f_procpointer (c_fptr, object%openloops_olp_set_parameter)
    if (dlaccess_has_error (dlaccess)) &
       call msg_fatal ("Loading of OLP_SetParameter failed!")

    c_fptr = dlaccess_get_c_funptr (dlaccess, var_str ("OLP_PrintParameter"))
    call c_f_procpointer (c_fptr, object%openloops_olp_print_parameter)
    if (dlaccess_has_error (dlaccess)) &
       call msg_fatal ("Loading of OLP_PrintParameter failed!")

  end subroutine openloops_driver_load

@ %def openloops_driver_load
@   
<<prc openloops: openloops driver: TBP>>=
  procedure :: set_alpha_s => openloops_driver_set_alpha_s
<<prc openloops: procedures>>=
  subroutine openloops_driver_set_alpha_s (driver, alpha_s)
    class(openloops_driver_t), intent(inout) :: driver
    real(default), intent(in) :: alpha_s
    integer :: ierr
    call driver%openloops_olp_set_parameter &
       (c_char_'alphas'//c_null_char, &
        dble (alpha_s), 0._double, ierr)
  end subroutine openloops_driver_set_alpha_s

@ %def openloops_driver_set_alpha_s
@
<<prc openloops: openloops driver: TBP>>=
  procedure :: set_alpha_qed => openloops_driver_set_alpha_qed
<<prc openloops: procedures>>=
  subroutine openloops_driver_set_alpha_qed (driver, alpha)
    class(openloops_driver_t), intent(inout) :: driver
    real(default), intent(in) :: alpha
    integer :: ierr
    call driver%openloops_olp_set_parameter &
       (c_char_'alpha_qed'//c_null_char, &
        dble (alpha), 0._double, ierr)
  end subroutine openloops_driver_set_alpha_qed

@ %def openloops_driver_set_alpha_qed
@
<<prc openloops: openloops driver: TBP>>=
  procedure, nopass :: type_name => openloops_driver_type_name
<<prc openloops: procedures>>=
  function openloops_driver_type_name () result (type)
    type(string_t) :: type
    type = "OpenLoops"
  end function openloops_driver_type_name

@ %def openloops_driver_type_name
@
<<prc openloops: openloops def: TBP>>=
  procedure :: read => openloops_def_read
<<prc openloops: procedures>>=
  subroutine openloops_def_read (object, unit)
    class(openloops_def_t), intent(out) :: object
    integer, intent(in) :: unit
    call msg_bug ("openloops_def_read: not implemented")
  end subroutine openloops_def_read

@ %def openloops_def_read
@
<<prc openloops: openloops def: TBP>>=
  procedure :: allocate_driver => openloops_def_allocate_driver
<<prc openloops: procedures>>=
  subroutine openloops_def_allocate_driver (object, driver, basename)
    class(openloops_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (openloops_driver_t :: driver)
  end subroutine openloops_def_allocate_driver

@
@ %def openloops_def_allocate_driver
<<prc openloops: openloops def: TBP>>=
  procedure, nopass :: get_features => openloops_def_get_features
<<prc openloops: procedures>>=
  subroutine openloops_def_get_features (features)
    type(string_t), dimension(:), allocatable, intent(out) :: features
    !!! Dummy
    allocate (features (6))
    features = [ &
         var_str ("init"), &
         var_str ("update_alpha_s"), &
         var_str ("reset_helicity_selection"), &
         var_str ("is_allowed"), &
         var_str ("new_event"), &
         var_str ("get_amplitude")]
  end subroutine openloops_def_get_features 

@
@ %def openloops_def_get_features
<<prc openloops: openloops def: TBP>>=
  procedure :: connect => openloops_def_connect
<<prc openloops: procedures>>=
  subroutine openloops_def_connect (def, lib_driver, i, proc_driver)   
    class(openloops_def_t), intent(in) :: def
    class(prclib_driver_t), intent(in) :: lib_driver
    integer, intent(in) :: i
    integer :: pid, fid
    class(prc_core_driver_t), intent(inout) :: proc_driver
    type(c_funptr) :: fptr
    select type (proc_driver)
    type is (openloops_driver_t)       
       pid = i
       fid = 2
       call lib_driver%get_fptr (pid, fid, fptr)
       call c_f_procpointer (fptr, proc_driver%update_alpha_s)
!       fid = 4
!       call lib_driver%get_fptr (pid, fid, fptr)
!       call c_f_procpointer (fptr, proc_driver%is_allowed)
    end select
  end subroutine openloops_def_connect

@ 
@ %def openloops_def_connect
<<prc openloops: openloops state: TBP>>=
  procedure :: write => openloops_state_write
<<prc openloops: procedures>>=
  subroutine openloops_state_write (object, unit)
    class(openloops_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_warning ("openloops_state_write: What to write?")
  end subroutine openloops_state_write

@ %def prc_openloops_state_write
@
<<prc openloops: openloops state: TBP>>=
  procedure :: reset_new_kinematics => openloops_state_reset_new_kinematics
<<prc openloops: procedures>>=
  subroutine openloops_state_reset_new_kinematics (object)
    class(openloops_state_t), intent(inout) :: object
    object%new_kinematics = .true.
  end subroutine openloops_state_reset_new_kinematics

@ 
@ %def openloops_state_reset_new_kinematics
<<prc openloops: prc openloops: TBP>>=
  procedure :: allocate_workspace => prc_openloops_allocate_workspace
<<prc openloops: procedures>>=
  subroutine prc_openloops_allocate_workspace (object, core_state)
    class(prc_openloops_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (openloops_state_t :: core_state)
  end subroutine prc_openloops_allocate_workspace

@ %def prc_openloops_allocate_workspace
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: init_openloops => prc_openloops_init_openloops
<<prc openloops: procedures>>=
  subroutine prc_openloops_init_openloops (object)
    class(prc_openloops_t), intent(inout) :: object
    object%data%n_flv = size (object%data%flv_state, 2)
  end subroutine prc_openloops_init_openloops

@ %def prc_openloops_init_openloops
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: init_driver => prc_openloops_init_driver
<<prc openloops: procedures>>=
  subroutine prc_openloops_init_driver (object, os_data)
    class(prc_openloops_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: olp_file

    select type (def => object%def)
    type is (openloops_def_t)
       olp_file = def%basename // def%suffix // '.olp'
    class default
       call msg_bug ("prc_openloops_init_driver: core_def should be openloops-type")
    end select

    select type (driver => object%driver)
    type is (openloops_driver_t)
       driver%olp_file = olp_file
    end select
  end subroutine prc_openloops_init_driver

@ %def prc_openloops_init_driver
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: set_parameters => prc_openloops_set_parameters
<<prc openloops: procedures>>=
  subroutine prc_openloops_set_parameters (object, qcd, use_color_factors)
    class(prc_openloops_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    logical, intent(in) :: use_color_factors
    object%qcd = qcd
    object%use_color_factors = use_color_factors

  end subroutine prc_openloops_set_parameters

@ %def prc_openloops_set_parameters
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: compute_hard_kinematics => prc_openloops_compute_hard_kinematics
<<prc openloops: procedures>>=
  subroutine prc_openloops_compute_hard_kinematics &
     (object, p_seed, i_term, int_hard, core_state)
    class(prc_openloops_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    
    call interaction_set_momenta (int_hard, p_seed)
!    if (allocated (core_state)) then
!       select type (core_state)
!          type is (openloops_state_t); core_state%new_kinematics = .true.
!        end select       
!    end if
  end subroutine prc_openloops_compute_hard_kinematics

@ %def prc_openloops_compute_hard_kinematics
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: compute_amplitude => prc_openloops_compute_amplitude
<<prc openloops: procedures>>=
  function prc_openloops_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, core_state) &
       result (amp)
    class(prc_openloops_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    select type (core_state)
    type is (openloops_state_t)
      core_state%alpha_qcd = object%qcd%alpha%get (fac_scale)
    end select
    amp = 0.0
  end function prc_openloops_compute_amplitude

@
@ %def prc_openloops_compute_amplitude
<<prc openloops: prc openloops: TBP>>=
  procedure :: compute_eff_kinematics => prc_openloops_compute_eff_kinematics
<<prc openloops: procedures>>=
  subroutine prc_openloops_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(prc_openloops_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine prc_openloops_compute_eff_kinematics

@
@ %def prc_openloops_compute_eff_kinematics
<<prc openloops: prc openloops: TBP>>=
  procedure :: get_n_terms => prc_openloops_get_n_terms
<<prc openloops: procedures>>=
  function prc_openloops_get_n_terms (object) result (n)
    class(prc_openloops_t), intent(in) :: object
    integer :: n
    n = 1
  end function prc_openloops_get_n_terms

@  
@ %def prc_openloops_get_n_terms
<<prc openloops: prc openloops: TBP>>=
  procedure :: get_nflv => prc_openloops_get_nflv
<<prc openloops: procedures>>=
  function prc_openloops_get_nflv (object) result (n_flv)
    class(prc_openloops_t), intent(in) :: object
    integer :: n_flv
    n_flv = 1
  end function prc_openloops_get_nflv

@ %def prc_openloops_get_nflv
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: is_allowed => prc_openloops_is_allowed
<<prc openloops: procedures>>=
  function prc_openloops_is_allowed (object, i_term, f, h, c) result (flag)
    class(prc_openloops_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    !!! Dummy flag, openloops always computes the matrix element
    flag = .true.
  end function prc_openloops_is_allowed

@
@ %def prc_openloops_is_allowed
<<prc openloops: prc openloops: TBP>>=
  procedure :: write => prc_openloops_write
<<prc openloops: procedures>>=
  subroutine prc_openloops_write (object, unit)
    class(prc_openloops_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call msg_message ("OpenLoops")
  end subroutine prc_openloops_write

@
@ %def prc_openloops_write
<<prc openloops: prc openloops: TBP>>=
  procedure :: recover_kinematics => prc_openloops_recover_kinematics
<<prc openloops: procedures>>=
  subroutine prc_openloops_recover_kinematics &
       (object, p_seed, int_hard, int_eff, core_state)
    class(prc_openloops_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard, int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_in
    n_in = interaction_get_n_in (int_eff)
    call interaction_set_momenta (int_eff, p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = interaction_get_momenta (int_eff, outgoing = .true.)
  end subroutine prc_openloops_recover_kinematics

@ 
@ %def prc_openloops_recover_kinematics
<<prc openloops: prc openloops: TBP>>=
  procedure :: needs_mcset => prc_openloops_needs_mcset
<<prc openloops: procedures>>=
  function prc_openloops_needs_mcset (object) result (flag)
    class(prc_openloops_t), intent(in) :: object
    logical :: flag
    !!! Dummy flag
    flag = .true.
  end function prc_openloops_needs_mcset

@
@ %def prc_openloops_needs_mcset
<<prc openloops: prc openloops: TBP>>=
  procedure :: set_alpha_qed => prc_openloops_set_alpha_qed
<<prc openloops: procedures>>=
  subroutine prc_openloops_set_alpha_qed (object, alpha)
    class(prc_openloops_t), intent(inout) :: object
    real(default), intent(in) :: alpha
    select type (driver => object%driver)
    type is (openloops_driver_t)
       call driver%set_alpha_qed (alpha)
    end select
  end subroutine prc_openloops_set_alpha_qed

@ %def prc_openloops_set_alpha_qed
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: update_alpha_s => prc_openloops_update_alpha_s
<<prc openloops: procedures>>=
  subroutine prc_openloops_update_alpha_s (object, core_state, fac_scale) 
    class(prc_openloops_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    real(default), intent(in) :: fac_scale
    real(default) :: alpha_qcd
    if (allocated (object%qcd%alpha)) then
       alpha_qcd = object%qcd%alpha%get (fac_scale)
       select type (driver => object%driver)
       type is (openloops_driver_t)
          call driver%update_alpha_s (alpha_qcd)
       end select 
       if (allocated (core_state)) then
          select type (core_state)
          type is (openloops_state_t)
             core_state%alpha_qcd = alpha_qcd
          end select
       end if
    end if
  end subroutine prc_openloops_update_alpha_s

@ %def prc_openloops_update_alpha_s
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: get_alpha_s => prc_openloops_get_alpha_s
<<prc openloops: procedures>>=
  function prc_openloops_get_alpha_s (object, core_state) result (alpha)
    class(prc_openloops_t), intent(in) :: object
    class(prc_core_state_t), intent(in), allocatable :: core_state
    real(default) :: alpha
    if (allocated (core_state)) then
       select type (core_state)
       type is (openloops_state_t) 
          alpha = core_state%alpha_qcd
       end select
    else
       alpha = 0._default
    end if
  end function prc_openloops_get_alpha_s

@ %def prc_openloops_get_alpha_s
@ 
<<prc openloops: prc openloops: TBP>>=
  procedure :: load_driver => prc_openloops_load_driver
<<prc openloops: procedures>>=
  subroutine prc_openloops_load_driver (object, os_data)
    class(prc_openloops_t), intent(inout) :: object
    type(os_data_t), intent(in) :: os_data
    logical :: success
    select type (driver => object%driver)
    type is (openloops_driver_t)
       call driver%load (os_data, success)
    end select
  end subroutine prc_openloops_load_driver

@ %def prc_openloops_load_driver
@ 
<<prc openloops: prc openloops: TBP>>=
  procedure :: start => prc_openloops_start
<<prc openloops: procedures>>=
  subroutine prc_openloops_start (object)
    class(prc_openloops_t), intent(inout) :: object
    integer :: ierr
    select type (driver => object%driver)
    type is (openloops_driver_t) 
       call driver%openloops_olp_start (char (driver%olp_file)//c_null_char, ierr)
    end select
  end subroutine prc_openloops_start

@ %def prc_openloops_start
@
<<prc openloops: prc openloops: TBP>>=
  procedure :: compute_sqme_virt => prc_openloops_compute_sqme_virt
<<prc openloops: procedures>>=
  subroutine prc_openloops_compute_sqme_virt (object, i_flv, p, ren_scale, alpha_s, &
     sqme, bad_point)
    class(prc_openloops_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), intent(in) :: alpha_s
    logical, intent(out) :: bad_point
    real(default), dimension(4), intent(out) :: sqme
    real(double) :: mu
    real(double), dimension(OLP_MOMENTUM_LIMIT) :: mom
    real(double), dimension(OLP_RESULTS_LIMIT) :: r
    real(double) :: acc_dble
    real(default) :: acc

    mom = create_blha_momentum_array (p)
    if (ren_scale == 0._default) then
       mu = sqrt (2* (p(1)*p(2)))
    else
       mu = ren_scale
    end if
    select type (driver => object%driver)
    type is (openloops_driver_t)
       call driver%set_alpha_s (alpha_s)
       call driver%openloops_olp_eval2 (i_flv, mom, mu, r, acc_dble)
    end select
    acc = acc_dble
    sqme = r(1:4)
    bad_point = .false.
    print *, 'sqme: ', sqme
  end subroutine prc_openloops_compute_sqme_virt

@ %def prc_openloops_compute_sqme_virt
@





