\Module{muli\_remnant}
\section{Allgemeines}
\subsection{Zweck}
\begin{figure}
  \centering{\includegraphics{uml-module-tree-8.mps}}
%  \caption{\label{fig:\ThisModule:Types}Klassendiagramm des Moduls}
\end{figure}
Das Modul muli\_remnant enthält die vollständige Beschreibung der Remnants. Bislang sind die ursprünglichen Hadronen fest auf Protonen implementiert, allerdings sind Verallgemeinerungen auf größere Klassen teilweise vorbereitet.
\subsection{Voraussetzungen}
Nicht in diesem Modul enthalten sind:
\begin{itemize}
\item Die ursprünglichen Strukturfunktionen der ungestörten Hadronen

Diese werden für die Definition der Remnant-PDFs verwendet. Verschiedene PDF-Sets können daher auch zu verschiedene Remnant-PDFs führen. Im Moment werden die LHAPDF-Bibliotheken verwendet. muli\_remnant verlässt sich darauf, dass diese bereits initialisiert sind und initialisiert sie nicht selbst.

In \TbpRef{pp\_remnant\_type}{initialize} werden zwar alle notwendigen LHAPDF Informationen, also Unix-Verzeichnis, Dateiname und Member, entgegengenommen. Diese werden aber nur verwendet, um die passenden integrierten PDFs \CompRef{pp\_remnant\_type}{pdf\_norm} zu deserialisieren.

Es wird das Modul pdf\_builtin eingebunden, aber im aktuellen Status nicht verwendet.

\item muli\_interactions
\end{itemize}
\subsection{Schnittstelle}
Die meisten Typen und Prozeduren in diesem Modul sind nur für interne Zwecke vorgesehen. Der erweiterte Datentyp \TypeRef{muli\_pp\_remnant\_type} wurde eigens implementiert, um als Schnittstelle nach außen zu dienen. Er enthält zwei Instanzen vom Typ \TypeRef{muli\_proton\_remnant\_type} und abstrahiert auf diese Weise die einzelnen Hadron-Remnants. Deshalb sollte es auch ohne Änderung der Schnittstelle möglich sein, andere Hadron-Remnants zu realisieren. \TypeRef{muli\_pp\_remnant\_type} enthält Wrapper-Methoden für alle momentan benötigten Informationen. Von \TypeRef{muli\_type} werden verwendet:
\begin{itemize}
\item \TbpRef{pp\_remnant\_type}{initialize}
\item \TbpRef{pp\_remnant\_type}{finalize}
\item \TbpRef{pp\_remnant\_type}{reset}
\item \TbpRef{pp\_remnant\_type}{replace\_parton}
\item \TbpRef{pp\_remnant\_type}{apply\_interaction}
\item \TbpRef{pp\_remnant\_type}{apply\_initial\_interaction}
\item \TbpRef{pp\_remnant\_type}{momentum\_pdf}
\item \TbpRef{pp\_remnant\_type}{parton\_pdf}
\item \TbpRef{pp\_remnant\_type}{get\_pdf\_int\_weights}
\end{itemize}
Zusammen mit den überladenen Standardmethoden der Klasse \TypeRef{serializable\_class}
\begin{itemize}
\item \TbpRef{pp\_remnant\_type}{write\_to\_marker}
\item \TbpRef{pp\_remnant\_type}{read\_from\_marker}
\item \TbpRef{pp\_remnant\_type}{print\_to\_unit}
\item \TbpRef{pp\_remnant\_type}{get\_type}
\end{itemize}
ergeben diese Methoden eine vollständige Schnittstelle für die Remnants. Konsequenterweise sollten alle Modul-Komponenten, alle Modul-Prozeduren und alle bis auf die erwähnten Type-Bound-Prozeduren als privat deklariert werden. Derzeit sind die Prozeduren nur deshalb public, um das Debugging zu erleichtern.
\subsection{Datentypen}
Alle Datentypen sind Erweiterungen von \TypeRef{serializable\_class}.
\begin{itemize}
  \item \TypeRef{pdfnorm\_type}:
  
  Für die Berechnung der Wichtungsfaktoren $W_k$ für die einzelnen Beiträge $f_k(x,\mu_F)$ zur Remnant-Strukturfunktion ist nicht die volle Information $f_k(x,\mu_F)$ notwendig. Es reicht aus, den Impulsmittelwert $\mean{f_k(\mu_F)}=\int_{x=x_0}^{1}xf_k(x,\mu_F)$ zu kennen. \TypeRef{pdfnorm\_type} liefert eben diesen Impulsmittelwert. Außerdem enthält \TypeRef{pdfnorm\_type} die Summe über alle Impulsmittelwerte. Idealerweise sollte diese Summe geich Eins sein. Damit aber Abweichungen von Eins die Summenregel \eqref{eq:all:rem:sumrule} nicht beeinflussen, werden alle Impulserwartungswerte auf die Summe normiert, daher auch der Name pdfnorm\_type\footnote{hängt stark von den Integrationsparametern ab, bei exakterer Integration scheint der Fehler beliebig klein zu werden, dadurch wird die CPU-Last aber zu groß. Renormierung ist eine deutlich billigere Methode. In den aktuellen Einstellung mit einer gut angepassten Verteilung von $10^7$ Stützstellen ist die Abweichung mit $<10^{-4}$ eigentlich irrelevant, dafür dauert es einige Minuten, bis alle Integrationen fertig sind.}.

\item \TypeRef{parton\_type}:

  Für die Berechnung der Wichtungsfaktoren ist es weiterhin notwendig zu wissen, welche Partonen bereits aus dem Remnant entnommen wurden. \TypeRef{parton\_type} ist eine Liste von eben diesen Partonen. Für Seequarks ist es außerdem wichtig, die Eigenschaften des Splittingpartners aus dem $g\rightarrow q_Sq_Q$ Gluonsplitting zu kennen. \TypeRef{parton\_type} enthält folglich einen Zeiger \CompRef{parton\_type}{twin} auf das jeweils andere Quark eines solchen Splittings

\item \TypeRef{proton\_remnant\_type}:

  Container für alle Eigenschaften eines Proton-Remnants und für spezifische Methoden zur Bestimmung der Wichtungsfaktoren für Proton-Remnants. 

\item \TypeRef{pp\_remnant\_type}:

  Abstrahierung der beiden Remnants und Schnittstelle für das Modul.
\end{itemize}



\section{Abhängigkeiten}
  \useintrinsic{iso\_fortran\_env}
  \usenodep{pdf\_builtin}
  \usenodep{tao\_random\_numbers}
  \use{muli\_basic}
  \use{muli\_interactions}
  \use{muli\_momentum}

\section{Parameter}
\CompRef{muli\_remnant}{nx} und \CompRef{muli\_remnant}{nq} sind Parameter fur die Approximation von $\mean{f_k(\mu)}$. nx ist die Zahl der Stützstellen für $x$ und nq ist die Zahl der Stützstellen für $\mu_F=Q$, bei denen $f_k(x,\mu_F)$ dafür ausgewertet wird. Da über $x$ integriert wird, nehmen die Werte für $x$ keinen Speicher in Anspruch, sondern nur CPU-Zeit. Die Werte für $\mu_F$ werden hingegen gespeichert.

\CompRef{muli\_remnant}{remnant\_weight\_model} und \CompRef{muli\_remnant}{gluon\_exp} sind Modellparameter für die Behandlung der Remnants. remnant\_weight\_model gibt an, wie die Wichtungsfaktoren durch die einzige Bedingung \eqref{eq:all:rem:sumrule} ausgedrückt werden. In Tabelle \ref{tab:all:rem:weight_models} ist eine Übersicht angegeben. In \TbpRef{proton\_remnant\_type}{calculate\_weight} werden die Wichtungsfaktoren bestimmt.

gluon\_exp ist ein Parameter für die Approximation der Quasivalenzquarkbeiträge, siehe \ProcRef{remnant\_gluon\_pdf\_approx}
\begin{Verbatim}
  implicit none
  integer,parameter::\MC{nx}=10000000
  integer,parameter::\MC{nq}=60
  integer,public::\MC{remnant\_weight\_model}=2
  integer::\MC{gluon\_exp}=4
\end{Verbatim}

\section{Derived Types}
\TypeDef{pdfnorm\_type}
pdfnorm\_type approximiert die Impulserwartungswerte $\mean{f_k(\mu)}=\int_{x=x_0}^{1}xf_k(x,\mu)$ aller Beiträge $k$ zur Strukturfunktion. pdfnorm\_type hat nur zwei neue Methoden, scan und get\_norm. scan Wertet $f_k(x,\mu)$ an allen $nx\otimes nq$ Stellen für alle 13 Einträge der LHAPDF-Sets aus und bestimmt daraus die Werte
\begin{equation}
  \text{pdf\_norm}(\mu)=\left[\mean{f_\Sigma(\mu)},\frac{\mean{f_g(\mu)}}{\mean{f_\Sigma(\mu)}},\frac{\mean{f_{s}(\mu)}}{\mean{f_\Sigma(\mu)}},\frac{\mean{f_{d^v}(\mu)}}{\mean{f_\Sigma(\mu)}},\frac{\mean{f_{u^v}(\mu)}}{\mean{f_\Sigma(\mu)}}\right]
\end{equation}
für nq verschiedene Werte von $\mu_F$. $\mean{f_\Sigma(\mu)}$ bezeichnet die Summe über die Impulsmittelwerte aller 13 Einträge der LHAPDF-Sets. pdf\_int$(k,\mu_F)=\mean{f_k(\mu_F)}, k=$LHAPDF-Flavor, ist ein Zwischenschritt und wird eigentlich nicht benötigt, sobald pdf\_norm bestimmt ist. pdf\_int kann also gefahrlos von der Liste der Komponenten entfernt werden. Es wird nur zu Debugging-Zwecken mitgeführt.

\mip{\CompRef{pdfnorm\_type}{qmin}, \CompRef{pdfnorm\_type}{qmax} und \CompRef{pdfnorm\_type}{dq} legen die Abbildung $j=1..nq\rightarrow \mu_j$ fest, wobei $j$ der zweite Index von pdf\_int bzw. pdf\_norm ist. Allerdings tragen sie die etwas unübliche Einheit $\sqrt{GeV}$. Es gilt:
  \begin{equation}
    \mu_j=\big(qmin + j\ dq\big)^2
  \end{equation}}

\begin{Verbatim}
  type,\Extends{serializable\_class}::pdfnorm_type
     real(kind=double)::\TC{qmin},\TC{qmax},\TC{dq}
     real(kind=double),dimension(-6:6,0:nq)::\TC{pdf\_int}
     real(kind=double),dimension(0:4,0:nq)::\TC{pdf\_norm}
   contains
     \OverridesDeclaration{serializable\_class}
     procedure::\TbpDec{write\_to\_marker}{pdfnorm\_write\_to\_marker}
     procedure::\TbpDec{read\_from\_marker}{pdfnorm\_read\_from\_marker}
     procedure::\TbpDec{print\_to\_unit}{pdfnorm\_print\_to\_unit}
     procedure,nopass::\TbpDec{get\_type}{pdfnorm\_get\_type}
     procedure,nopass::\TbpDec{verify\_type}{pdfnorm\_verify\_type}
     \OriginalDeclaration
     procedure::\TbpDec{scan}{pdfnorm\_scan}
     procedure::\TbpDec{get\_norm}{pdfnorm\_get\_norm}
  end type pdfnorm_type
\end{Verbatim}
\TypeDef{parton\_type}
parton\_type ist eine Liste von Partonen. Jedes Parton bekommt eine eindeutige \CompRef{parton\_type}{id}, die mit der id des ISR-Algorithmus übereinstimmt. So können sich ISR und MPI miteinander verständigen, mit welchem Parton etwas geschieht.

\CompRef{parton\_type}{lha\_flavor} ist das Flavor des Partons im LHA-Schema

\mip{Handelt es sich nicht um ein Quasivalenzquark, dann ist \CompRef{parton\_type}{momentum} der Impulsanteil $\xi$, bezogen auf den aktuellen Remnantimpuls, des Partons. Bei einem Quasivalenzquark hingegen ist \CompRef{parton\_type}{momentum} der ungewichtete Impulserwartungswert des Quasivalenzquarks.}

\CompRef{parton\_type}{twin} ist nur von Bedeutung, wenn das Parton ein Seequark oder ein Quasivalenzquark ist. Dann ist twin der Spittingpartner des vorangegangenen Gluonsplittings.

\CompRef{parton\_type}{next} ist das nächste Parton in der Liste.
\begin{Verbatim}
  type,Extends{serializable\_class}::parton_type
     private
     integer::\TC{id}=-1
     integer::\TC{lha\_flavor}
     real(kind=double)::\TC{momentum}=-1D0
     class(\TypeRef{parton\_type}),pointer::\TC{twin}=>null()
     class(\TypeRef{parton\_type}),pointer::\TC{next}=>null()
   contains
     \OverridesDeclaration{serializable\_class}
     procedure::\TbpDec{write\_to\_marker}{parton\_write\_to\_marker}
     procedure::\TbpDec{read\_from\_marker}{parton\_read\_from\_marker}
     procedure::\TbpDec{print\_to\_unit}{parton\_print\_to\_unit}
     procedure,nopass::\TbpDec{get\_type}{parton\_get\_type}
     \OriginalDeclaration
     procedure::\TbpDec{unweighted\_pdf}{twin\_unweighted\_pdf}
     procedure::\TbpDec{deallocate}{twin\_deallocate}
     procedure::\TbpDec{push}{parton\_push}
     procedure::\TbpDec{pop\_by\_id}{parton\_pop\_by\_id}
     procedure::\TbpDec{pop\_by\_association}{parton\_pop\_by\_association}
     generic::\TbpGen{pop}{pop\_by\_id,pop\_by\_association}
  end type parton_type
\end{Verbatim}
\TypeDef{proton\_remnant\_type}
proton\_remnant\_type enthält den aktuellen Status eines Proton-Remnants. Das sind

die Anzahl der jeweiligen Valenzquarks \CompRef{proton\_remnant\_type}{valence\_content},

die Anzahl aller Quasivalenzquarks \CompRef{proton\_remnant\_type}{n\_twins},

die aktuellen Wichtungsfaktoren \CompRef{proton\_remnant\_type}{pdf\_int\_weight} (siehe \eqref{eq:all:rem:sumrule}),

den Remnantimpuls dividiert durch den ursprünglichen Protonimpuls \CompRef{proton\_remnant\_type}{momentum\_fraction}, 

die Summe der ungewichteten Impulsmittelwerte der Quasivalenzquarks \CompRef{proton\_remnant\_type}{twin\_norm},

die Liste der Quasivalenzquarks im Remnant \CompRef{proton\_remnant\_type}{twin\_partons},

die Liste der aktiven Initial State Partonen \CompRef{proton\_remnant\_type}{is\_partons},

die Liste der aktiven Final State Partonen \CompRef{proton\_remnant\_type}{fs\_partons}

sowie eine redundante Referenz auf die integrierten LHAPDFs \CompRef{proton\_remnant\_type}{pdf\_norm}.
Redundant bedeutet, dass mehrere Instanzen einen Zeiger auf dasselbe Ziel haben. Die Allokierung der pdf\_norm wird einer Instanz des Datentyps \TypeRef{pp\_remnant\_type} durchgeführt. Nur diese Instanz sollte auch die Deallokierung durchführen.
\begin{Verbatim}
  type,\Extends{serializable\_class}::proton_remnant_type
     integer,dimension(2)::\TC{valence\_content}=[1,2]
     integer::\TC{n\_twins}=0
     ![gluon,sea quark,valence down,valence up,twin]
     real(kind=drk),dimension(5)::\TC{pdf\_int\_weight}=[1D0,1D0,1D0,1D0,0D0]
     real(kind=drk)::\TC{momentum\_fraction}=1D0
     real(kind=double)::\TC{twin\_norm}=0D0
     type(\TypeRef{parton\_type})::\TC{twin\_partons}
     type(\TypeRef{parton\_type})::\TC{is\_partons}
     type(\TypeRef{parton\_type})::\TC{fs\_partons}
     ! these pointers shall not be allocated, deallocated, serialized or
     ! deserialized explicitly.
     class(\TypeRef{pdfnorm\_type}),pointer::\TC{pdf\_norm}=>null()
   contains
     \OverridesDeclaration{serializable\_class}
     procedure::\TbpDec{write\_to\_marker}{proton\_remnant\_write\_to\_marker}
     procedure::\TbpDec{read\_from\_marker}{proton\_remnant\_read\_from\_marker}
     procedure::\TbpDec{print\_to\_unit}{proton\_remnant\_print\_to\_unit}
     procedure,nopass::\TbpDec{get\_type}{proton\_remnant\_get\_type}
     \OriginalDeclaration
     ! manipulating parton content
     procedure::\TbpDec{remove\_valence\_quark}{proton\_remnant\_remove\_valence\_quark}
     procedure::\TbpDec{remove\_sea\_quark}{proton\_remnant\_remove\_sea\_quark}
     procedure::\TbpDec{remove\_gluon}{proton\_remnant\_remove\_gluon}
     procedure::\TbpDec{remove\_valence\_up\_quark}{proton\_remnant\_remove\_valence\_up\_quark}
     procedure::\TbpDec{remove\_valence\_down\_quark}{proton\_remnant\_remove\_valence\_down\_quark}
     procedure::\TbpDec{remove\_twin}{proton\_remnant\_remove\_twin}
     ! getting pdf
     procedure::\TbpDec{momentum\_twin\_pdf}{proton\_remnant\_momentum\_twin\_pdf}
     procedure::\TbpDec{momentum\_twin\_pdf\_array}{proton\_remnant\_momentum\_twin\_pdf\_array}
     procedure::\TbpDec{momentum\_kind\_pdf}{proton\_remnant\_momentum\_kind\_pdf}
     procedure::\TbpDec{momentum\_flavor\_pdf}{proton\_remnant\_momentum\_flavor\_pdf}
     procedure::\TbpDec{momentum\_kind\_pdf\_array}{proton\_remnant\_momentum\_kind\_pdf\_array}
     procedure::\TbpDec{momentum\_flavor\_pdf\_array}{proton\_remnant\_momentum\_flavor\_pdf\_array}
     procedure::\TbpDec{parton\_twin\_pdf}{proton\_remnant\_parton\_twin\_pdf}
     procedure::\TbpDec{parton\_twin\_pdf\_array}{proton\_remnant\_parton\_twin\_pdf\_array}
     procedure::\TbpDec{parton\_kind\_pdf}{proton\_remnant\_parton\_kind\_pdf}
     procedure::\TbpDec{parton\_flavor\_pdf}{proton\_remnant\_parton\_flavor\_pdf}
     procedure::\TbpDec{parton\_kind\_pdf\_array}{proton\_remnant\_parton\_kind\_pdf\_array}
     procedure::\TbpDec{parton\_flavor\_pdf\_array}{proton\_remnant\_parton\_flavor\_pdf\_array}
     ! getting components
     procedure::\TbpDec{get\_pdf\_int\_weight}{proton\_remnant\_get\_pdf\_int\_weight}
     procedure::\TbpDec{get\_valence\_down\_weight}{proton\_remnant\_get\_valence\_down\_weight}
     procedure::\TbpDec{get\_valence\_up\_weight}{proton\_remnant\_get\_valence\_up\_weight}
     procedure::\TbpDec{get\_valence\_weight}{proton\_remnant\_get\_valence\_weight}
     procedure::\TbpDec{get\_gluon\_weight}{proton\_remnant\_get\_gluon\_weight}
     procedure::\TbpDec{get\_sea\_weight}{proton\_remnant\_get\_sea\_weight}
     procedure::\TbpDec{get\_twin\_weight}{proton\_remnant\_get\_twin\_weight}
     procedure::\TbpDec{get\_valence\_content}{proton\_remnant\_get\_valence\_content}
     procedure::\TbpDec{get\_momentum\_fraction}{proton\_remnant\_get\_momentum\_fraction}
     ! misc
     procedure::\TbpDec{deallocate}{proton\_remnant\_deallocate}
     procedure::\TbpDec{initialize}{proton\_remnant\_initialize}
     procedure::\TbpDec{finalize}{proton\_remnant\_finalize}
     procedure::\TbpDec{apply\_initial\_splitting}{proton\_remnant\_apply\_initial\_splitting}
     procedure::\TbpDec{reset}{proton\_remnant\_reset}
     ! private
     procedure,private::\TbpDec{calculate\_weight}{proton\_remnant\_calculate\_weight}
     procedure,private::\TbpDec{push\_is\_parton}{proton\_remnant\_push\_is\_parton}
     procedure,private::\TbpDec{push\_twin}{proton\_remnant\_push\_twin}
     procedure,private::\TbpDec{calculate\_twin\_norm}{proton\_remnant\_calculate\_twin\_norm}
     procedure,private::\TbpDec{replace\_is\_parton}{proton\_remnant\_replace\_is\_parton}
     ! plots
     procedure::\TbpDec{gnuplot\_momentum\_kind\_pdf\_array}{proton\_remnant\_gnuplot\_momentum\_kind\_pdf\_array}
  end type proton_remnant_type
\end{Verbatim}
\TypeDef{pp\_remnant\_type}
pp\_remnant\_type abstrahiert die einzelnen Hadron-Remnants und dient als Schnittstelle für das komplette Modul. Aus anderen Modulen heraus sollen keine anderen Methoden, als die hier definierten, aufgerufen werden. Deswegen hat pp\_remnant\_type als einziger Datentyp in diesem Modul eine Komponente "`initialized"', so dass eine Warnung ausgegeben werden kann, wenn ein Zugriff auf nichtinitialisierte Komponenten versucht wird.

\wip{\CompRef{pp\_remnant\_type}{gev\_cme\_tot} soll die aktuelle invariante Masse des hadronischen Systems zurückgeben. Dynamische invariante Massen sind aber noch nicht implementiert. \CompRef{pp\_remnant\_type}{X} ist die aktuelle invariante Masse dividiert durch die ursprüngliche invariante Masse des Proton-Proton-Systems, allerdings wird diese Variable (noch) nirgends verwendet.}

\CompRef{pp\_remnant\_type}{proton} sind die beiden Proton-Remnants.

\CompRef{pp\_remnant\_type}{pdfnorm\_type} sind die Impulsmittelwerte der PDFs.
\begin{Verbatim}
  type,Extends{serializable\_class}::pp_remnant_type
     logical::\TC{initialized}=.false.
     real(kind=double),private::\TC{gev\_initial\_cme} = gev_cme_tot
     real(kind=double),private::\TC{X}=1D0
     type(\TypeRef{proton\_remnant\_type}),dimension(2)::\TC{proton}
     class(\TypeRef{pdfnorm\_type}),pointer,private::\TC{pdf\_norm}
   contains
     \OverridesDeclaration{serializable\_class}
     procedure::\TbpDec{write\_to\_marker}{pp\_remnant\_write\_to\_marker}
     procedure::\TbpDec{read\_from\_marker}{pp\_remnant\_read\_from\_marker}
     procedure::\TbpDec{print\_to\_unit}{pp\_remnant\_print\_to\_unit}
     procedure,nopass::\TbpDec{get\_type}{pp\_remnant\_get\_type}
     \OriginalDeclaration
     ! init /final
     procedure::\TbpDec{initialize}{pp\_remnant\_initialize}
     procedure::\TbpDec{finalize}{pp\_remnant\_finalize}
     procedure::\TbpDec{reset}{pp\_remnant\_reset}
     ! manipulating parton content
     procedure::\TbpDec{apply\_initial\_interaction}{pp\_remnant\_apply\_initial\_interaction}
     procedure::\TbpDec{replace\_parton}{pp\_remnant\_replace\_parton}
     procedure::\TbpDec{apply\_interaction}{pp\_remnant\_apply\_interaction}
     ! getting pdfs
     procedure::\TbpDec{momentum\_pdf}{pp\_remnant\_momentum\_pdf}
     procedure::\TbpDec{parton\_pdf}{pp\_remnant\_parton\_pdf}
     procedure::\TbpDec{get\_proton\_remnant\_momentum\_fractions}{pp\_remnant\_get\_proton\_remnant\_momentum\_fractions}
     procedure::\TbpDec{get\_remnant\_parton\_flavor\_pdf\_arrays}{pp\_remnant\_get\_remnant\_parton\_flavor\_pdf\_arrays}     
     ! getting components
     procedure::\TbpDec{get\_pdf\_int\_weights}{pp\_remnant\_get\_pdf\_int\_weights}
     procedure::\TbpDec{get\_pdf\_int\_weight}{pp\_remnant\_get\_pdf\_int\_weight}
     procedure::\TbpDec{set\_pdf\_weight}{pp\_remnant\_set\_pdf\_weight}
     procedure::\TbpDec{get\_gev\_initial\_cme}{pp\_remnant\_get\_gev\_initial\_cme}
     procedure::\TbpDec{get\_gev\_actual\_cme}{pp\_remnant\_get\_gev\_actual\_cme}
     procedure::\TbpDec{get\_cme\_fraction}{pp\_remnant\_get\_cme\_fraction}
     procedure::\TbpDec{get\_proton\_remnants}{pp\_remnant\_get\_proton\_remnants}
  end type pp_remnant_type
\end{Verbatim}
\section{Implementierung der Methoden}
\MethodsFor{pdfnorm\_type}
\TbpImp{pdfnorm\_write\_to\_marker}
\begin{Verbatim}
  subroutine pdfnorm_write_to_marker(this,marker,status)
    class(pdfnorm_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("pdfnorm_type")
    call marker%mark("qmin",this%qmin)
    call marker%mark("qmax",this%qmax)
    call marker%mark("dq",this%dq)
    call marker%mark("pdf_int",this%pdf_int)
    call marker%mark("pdf_norm",this%pdf_norm)
    call marker%mark_end("pdfnorm_type")
  end subroutine pdfnorm_write_to_marker
\end{Verbatim}

\TbpImp{pdfnorm\_read\_from\_marker}
\begin{Verbatim}
  subroutine pdfnorm_read_from_marker(this,marker,status)
    class(pdfnorm_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    character(:),allocatable::name
    call marker%pick_begin("pdfnorm_type",status=status)
    call marker%pick("qmin",this%qmin,status)
    call marker%pick("qmax",this%qmax,status)
    call marker%pick("dq",this%dq,status)
    call marker%pick("pdf_int",this%pdf_int,status)
    call marker%pick("pdf_norm",this%pdf_norm,status)
    call marker%pick_end("pdfnorm_type",status=status)
  end subroutine pdfnorm_read_from_marker
\end{Verbatim}
\TbpImp{pdfnorm\_print\_to\_unit}
\begin{Verbatim}
  recursive subroutine pdfnorm_print_to_unit(this,unit,parents,components,peers)
    class(pdfnorm_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of pdfnorm_type:")')
    write(unit,'("qmin:    ",F7.6)')this%qmin
    write(unit,'("qmax:    ",F7.6)')this%qmax
    write(unit,'("dq:      ",F7.6)')this%dq
    if(components>0)then
       write(unit,'("pdf_int:  ",13(F8.6," "))')this%pdf_int
       write(unit,'("pdf_norm: ",5(F8.6," "))')this%pdf_norm
    else
       write(unit,'("Skipping pdf_int")')
       write(unit,'("Skipping pdf_norm")')
    end if
  end subroutine pdfnorm_print_to_unit
\end{Verbatim}
\TbpImp{pdfnorm\_get\_type}
\begin{Verbatim}
  pure subroutine pdfnorm_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="pdfnorm_type")
  end subroutine pdfnorm_get_type
\end{Verbatim}
\TbpImp{pdfnorm\_verify\_type}
\begin{Verbatim}
  elemental logical function pdfnorm_verify_type(type) result(match)
    character(*),intent(in)::type
    match=type=="pdfnorm_type"
  end function pdfnorm_verify_type
\end{Verbatim}
\TbpImp{pdfnorm\_scan}
Für verschiedene Werte $\mu_j$ von $\mu_F$ integrieren wir über $x$ und bekommen so eine Approximation von $\mean{f_k(\mu)}=\int_{x=x_0}^{1}xf_k(x,\mu)$. In der Komponente this\%pdf\_int[k,j] werden die die Werte $\mean{f_k(\mu_j)}$ gespeichert, mit $k\in [-6:6]=[\overline{t}^S,\overline{b}^S,\overline{c}^S,\overline{s}^S,\overline{u}^S,\overline{d}^S,g,d^V,u^V,s^S,c^S,b^S,t^S]$. In der Komponente this\%pdf\_norm[m,j] werden normierte Summen dieser Integrale gspeichert.
\begin{equation}
  this\%pdf\_norm[m,j]=\frac{\sum_{k\in I_m}\mean{f_k(\mu_j)}}{N}
\end{equation}
mit
\begin{equation}
  N=\sum_{\text{alle } I_m}\mean{f_k(\mu_j)}
\end{equation}
und mit $I=$ [gluon,see,valenz-down,valenz-up], genauer:
\begin{align}
  I_1&=g\\
  I_2&={\overline{t}^S,\overline{b}^S,\overline{c}^S,\overline{s}^S,\overline{u}^S,\overline{d}^S,d^S,u^S,s^S,c^S,b^S,t^S}\\
  I_3&=d^V\\
  I_4&=u^V
\end{align}
Schließlich wird $N$ in this\%pdf\_norm[0,j] gespeichert. Idealerweise sollte $N=1$ sein, das wird auch bei der Berechnung der Wichtungsfaktoren der Remnant-PDFs in \TbpRef{proton\_remnant\_type}{calculate\_weight} explizit angenommen. Da diese Summenregel durch nummerische Fehler aber nicht exakt erfüllt ist, normieren wir die Beiträge auf deren Summe. Dadurch bekommen wir in \TbpRef{proton\_remnant\_type}{calculate\_weight} Wichtungsfaktorn, die kaum von dem nummerischen Fehler der Gleichung $N=1$ abhängen.

Die Integration über $x$ wird mit der Trapezregel durchgeführt. LHAPDF liefert bereits die momentum-pdfs $xf$, deswegen tritt der Faktor $x$ hier nicht mehr auf. Die $x$-Werte sind wie auch die $\mu$-Werte nicht äquidistant, sondern deren Abstand ist $\sim\sqrt{x}$ bzw. $\sim\sqrt{\mu}$. Da $x>0$ und $\mu>0$ treten keine Koordinaten-divergenzen auf. 
\begin{Verbatim}
  subroutine pdfnorm_scan(this)
    class(pdfnorm_type),intent(out)::this
    integer::ix,iq
    real(kind=double)::xmin,xmax,dx
    real(kind=double)::q,q2min,q2max
    real(kind=double),dimension(-6:6)::f
    real(kind=double),dimension(0:2)::x
    call getxmin(0,xmin)
    call getxmax(0,xmax)
    call getq2min(0,q2min)
    call getq2max(0,q2max)
    this%qmin=sqrt(sqrt(q2min))
    this%qmax=sqrt(sqrt(q2max))
    this%dq=(this%qmax-this%qmin)/nq
    xmin=sqrt(xmin)
    xmax=sqrt(xmax)
    dx=(xmax-xmin)/nx
    do iq=0,nq
       print *,"iq=",iq,"/",nq
       q=(this%qmin+iq*this%dq)**2
       x(0)=xmin**2
       x(1)=(xmin+dx)**2
       call evolvePDF(x(0),q,f)
       \IC{Valenzbeiträge}
       f(1)=f(1)-f(-1)
       f(2)=f(2)-f(-2)
       \IC{Trapezregel: linker Rand}
       this%pdf_int(:,iq)=(x(1)-x(0))*f
       do ix=2,nx
          x(2)=(xmin+ix*dx)**2
          call evolvePDF(x(1),q,f)
          f(1)=f(1)-f(-1)
          f(2)=f(2)-f(-2)
          \IC{Trapezregel: Die bekannte Form ergibt sich aus einer Umsummierung dieser Beiträge.}
          this%pdf_int(:,iq)=this%pdf_int(:,iq)+f*(x(2)-x(0))
          \IC{Die x-Werte werden nach links geschoben}
          x(0)=x(1)
          x(1)=x(2)
       end do
       \IC{Trapezregel: rechter Rand}
       call evolvePDF(x(1),q,f)
       f(1)=f(1)-f(-1)
       f(2)=f(2)-f(-2)
       \IC{Hier wird endlich durch 2 dividiert.}
       this%pdf_int(:,iq)=(this%pdf_int(:,iq)+f*(x(1)-x(0)))/2D0
       \IC{\mean{f_{u^v}}}
       this%pdf_norm(4,iq)=this%pdf_int(2,iq)
       \IC{\mean{f_{d^v}}}
       this%pdf_norm(3,iq)=this%pdf_int(1,iq)
       \IC{\mean{f_{u}}}
       this%pdf_int(2,iq)=this%pdf_int(2,iq)+this%pdf_int(-2,iq)
       \IC{\mean{f_{d}}}
       this%pdf_int(1,iq)=this%pdf_int(1,iq)+this%pdf_int(-1,iq)
       \IC{\mean{f_{g}}}
       this%pdf_norm(1,iq)=this%pdf_int(0,iq)
       \IC{\(\sum\mean{f_{q^s}}\)}
       this%pdf_norm(2,iq)=sum(this%pdf_int(-6:-1,iq))+sum(this%pdf_int(-2:-1,iq))+sum(this%pdf_int(3:6,iq))
       \IC{\(\sum_\{alle Partonen\}\mean{f_{k}}\)}
       this%pdf_norm(0,iq)=sum(this%pdf_int(:,iq))
       \IC{Normierung auf pdf_norm(0,iq)}
       this%pdf_norm(1,iq)=this%pdf_norm(1,iq)/this%pdf_norm(0,iq)
       this%pdf_norm(2,iq)=this%pdf_norm(2,iq)/this%pdf_norm(0,iq)
       this%pdf_norm(3,iq)=this%pdf_norm(3,iq)/this%pdf_norm(0,iq)
       this%pdf_norm(4,iq)=this%pdf_norm(4,iq)/this%pdf_norm(0,iq)
    end do
  end subroutine pdfnorm_scan
\end{Verbatim}

\TbpImp{pdfnorm\_get\_norm}
Hier habe ich verschiedene Polynome zur Approximation der $\mu_F$-Abhängigkeit probiert. Dim ist die Ordnung des Polynoms. Wie auch bei der $x$-Integration hat die Trapezregel, also dim=1, die besten Resultate gebracht.
\begin{Verbatim}
  subroutine pdfnorm_get_norm(this,gev_q,dim,kind,norm)
    class(pdfnorm_type),intent(in)::this
    real(kind=double),intent(in)::gev_q
    integer,intent(in)::dim,kind
    real(kind=double),intent(out)::norm
    integer::iq
    real(kind=double)::x,q,z0,z1,z2,z3,z4
    norm=-1D0
    q=sqrt(gev_q)-this%qmin
    iq=floor(q/this%dq)
    x=q/this%dq-iq
    if(iq<0)then
       print *,"pdfnorm_getnorm: q < q_min ",gev_q,this%qmin**2
       norm=this%pdf_norm(kind,0)
    else
       if(iq>=nq)then
          print *,"pdfnorm_getnorm: q >= q_max ",gev_q,this%qmax**2
          norm=this%pdf_norm(kind,nq)
       else
          select case(dim)
          case(0)
             norm=this%pdf_norm(kind,iq)
          case(1)
             norm=this%pdf_norm(kind,iq)*(1D0-x)+this%pdf_norm(kind,iq+1)*x
          case(2)
             x=x+mod(iq,2)
             iq=iq-mod(iq,2)
             z0=this%pdf_norm(kind,iq)
             z1=this%pdf_norm(kind,iq+1)
             z2=this%pdf_norm(kind,iq+2)
             norm=((z0-2D0*z1+z2)*x-(3D0*z0-4D0*z1+z2))*x/2D0+z0
          case(3)
             x=x+mod(iq,3)
             iq=iq-mod(iq,3)
             z0=this%pdf_norm(kind,iq)
             z1=this%pdf_norm(kind,iq+1)
             z2=this%pdf_norm(kind,iq+2)
             z3=this%pdf_norm(kind,iq+3)
             norm=((-(z0-3*z1+3*z2-z3)*x+3*(2*z0-5*z1+4*z2-z3))*x-(11*z0-18*z1+9*z2-2*z3))*x/6D0+z0
          case(4)
             x=x+mod(iq,4)
             iq=iq-mod(iq,4)
             z0=this%pdf_norm(kind,iq)
             z1=this%pdf_norm(kind,iq+1)
             z2=this%pdf_norm(kind,iq+2)
             z3=this%pdf_norm(kind,iq+3)
             z4=this%pdf_norm(kind,iq+4)
             norm=(((((z0-4*z1+6*z2-4*z3+z4)*x&
                  -2*(5*z0-18*z1+24*z2-14*z3+3*z4))*x&
                  +(35*z0-104*z1+114*z2-56*z3+11*z4))*x&
                  -2*(25*z0-48*z1+36*z2-16*z3+3*z4))*x)/24D0&
                  +z0
          case default
             norm=this%pdf_norm(kind,iq)*(1D0-x)+this%pdf_norm(kind,iq+1)*x
          end select
          !          print *,iq,x,norm
       end if
    end if
  end subroutine pdfnorm_get_norm
\end{Verbatim}
\MethodsFor{parton\_type}
\TbpImp{parton\_write\_to\_marker}
\begin{Verbatim}
  subroutine parton_write_to_marker(this,marker,status)
    class(parton_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("parton_type")
    call marker%mark("id",this%id)
    call marker%mark("lha",this%lha_flavor)
    call marker%mark("momentum",this%momentum)
    call marker%mark_end("parton_type")
  end subroutine parton_write_to_marker
\end{Verbatim}
\TbpImp{parton\_read\_from\_marker}
\begin{Verbatim}
  subroutine parton_read_from_marker(this,marker,status)
    class(parton_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    character(:),allocatable::name
    call marker%pick_begin("parton_type",status=status)
    call marker%pick("id",this%id,status)
    call marker%pick("lha",this%lha_flavor,status)
    call marker%pick("momentum",this%momentum,status)
    call marker%pick_end("parton_type",status=status)
  end subroutine parton_read_from_marker
\end{Verbatim}
\TbpImp{parton\_print\_to\_unit}
\begin{Verbatim}
  recursive subroutine parton_print_to_unit(this,unit,parents,components,peers)
    class(parton_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    class(serializable_class),pointer::ser
    write(unit,'("Components of parton_type:")')
    write(unit,'("id:         ",I7)')this%id
    write(unit,'("lha flavor: ",I7)')this%lha_flavor
    write(unit,'("momentum:   ",F7.6)')this%momentum
    ser=>this%next
    call serialize_print_peer_pointer(ser,unit,parents,components,peers-one,"next")
    ser=>this%twin
    call serialize_print_comp_pointer(ser,unit,parents,components,peers-one,"twin")
  end subroutine parton_print_to_unit
\end{Verbatim}
\TbpImp{parton\_get\_type}
\begin{Verbatim}
  pure subroutine parton_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="parton_type")
  end subroutine parton_get_type
\end{Verbatim}
\TbpImp{twin\_unweighted\_pdf}
\begin{Verbatim}
  pure function twin_unweighted_pdf(this,momentum_fraction) result(pdf)
    !parton pdf
    class(parton_type),intent(in)::this
    real(kind=double),intent(in)::momentum_fraction
    real(kind=double)::pdf
    if(momentum_fraction+this%twin%momentum<1D0)then
       pdf=remnant_twin_pdf_p(momentum_fraction,this%twin%momentum,gluon_exp)
    else
       pdf=0D0
    end if
  end function twin_unweighted_pdf
\end{Verbatim}
\TbpImp{twin\_deallocate}
\begin{Verbatim}
  recursive subroutine twin_deallocate(this)
    class(parton_type)::this
    if(associated(this%next))then
       call this%next%deallocate
       deallocate(this%next)
    end if
  end subroutine twin_deallocate
\end{Verbatim}
\TbpImp{parton\_push}
\begin{Verbatim}
  subroutine parton_push(this,parton)
    class(parton_type),intent(inout)::this
    class(parton_type),intent(inout),pointer::parton
    parton%next=>this%next
    this%next=>parton
  end subroutine parton_push
\end{Verbatim}
\TbpImp{parton\_pop\_by\_id}
\begin{Verbatim}
  subroutine parton_pop_by_id(this,id,parton)
    class(parton_type),target,intent(inout)::this
    integer,intent(in)::id
    class(parton_type),intent(out),pointer::parton
    class(parton_type),pointer::tmp_parton    
    tmp_parton=>this
    do while(associated(tmp_parton%next))
       if(tmp_parton%next%id==id)exit
       tmp_parton=>tmp_parton%next
    end do
    \IC{Noch wissen wir nicht, ob die Schleife erfolglos durchgelaufen ist.}
    if(associated(tmp_parton%next))then
       \IC{Erfolg: Das Parton wird aus der Liste entfernt.}
       parton=>tmp_parton%next
       tmp_parton%next=>parton%next
       nullify(parton%next)
    else
       \IC{Kein Erfolg: Das Dummyargument wird deassociiert.}
       nullify(parton)
       print *,"parton_pop ",id,"NULL"
    end if
  end subroutine parton_pop_by_id
\end{Verbatim}
\TbpImp{parton\_pop\_by\_association}
\begin{Verbatim}
  subroutine parton_pop_by_association(this,parton)
    class(parton_type),target,intent(inout)::this
    class(parton_type),intent(inout),target::parton
    class(parton_type),pointer::tmp_parton    
    tmp_parton=>this
    do while(associated(tmp_parton%next))
       if(associated(tmp_parton%next,parton))exit
       tmp_parton=>tmp_parton%next
    end do
    \IC{Noch wissen wir nicht, ob die Schleife erfolglos durchgelaufen ist.}
    if(associated(tmp_parton%next))then
       \IC{Erfolg: Das Parton wird aus der Liste entfernt.}
       tmp_parton%next=>parton%next
       nullify(parton%next)
    else
       \IC{Kein Erfolg}
       print *,"parton_pop NULL"
    end if
  end subroutine parton_pop_by_association
\end{Verbatim}
\MethodsFor{proton\_remnant\_type}
! manipulating parton content 

\TbpImp{proton\_remnant\_remove\_valence\_quark}
\begin{Verbatim}
  subroutine proton_remnant_remove_valence_quark(this,id,GeV_scale,momentum_fraction,lha_flavor)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor  !d=1 u=2
    if(lha_flavor==1.or.lha_flavor==2)then
       \IC{q ist die Anzahl der entsprechenden Valenzquarks.}
       associate(q=>this%valence_content(lha_flavor))
         if(q>0)then
            q=q-1
            \IC{Das Quark ist ab jetzt ein aktiven Shower-Teilchen.}
            call this%push_is_parton(id,lha_flavor,momentum_fraction)
            \IC{Der Remnant-Impuls wird um den Partonimpuls reduziert.}
            this%momentum_fraction=this%momentum_fraction*(1D0-momentum_fraction)
            \IC{Die Wichtugsfaktoren werden neu ausgewertet}
            call this%calculate_weight(GeV_scale)
         else
            print('("proton_remnant_remove_valence_quark: Cannot remove parton ",I2,": &
                 &There are no such partons left.")'),lha_flavor
            call this%print_all()
         end if
       end associate
    else
       print('("proton_remnant_remove_valence_quark: Cannot remove parton ",I2,": &
            &There are no such valence partons.")'),lha_flavor
    end if
  end subroutine proton_remnant_remove_valence_quark
\end{Verbatim}
\TbpImp{proton\_remnant\_remove\_valence\_up\_quark}
q ist die Zahl der Valenz-up-Quarks im Remnant. Wenn keine mehr da sind, dann ist etwas schief gelaufen, sonst wird die Zahl um eins reduziert. Das Parton, das aus dem Remnant entfernt wird, verschwindet natürlich nicht, sondern wird mit \TbpRef{proton\_remnant\_type}{push\_is\_parton} in die perturbative Beschreibung aufgenommen. is\_parton bedeutet Initial-State Parton, genauer gesagt aktives Initial-State Parton.

Selbstverständlich wird der Impuls des Remants aktualisiert und schließlich werden mit\linebreak \TbpRef{proton\_remnant\_type}{calculate\_weight} die neuen Wichtungsfaktoren $W_{\alpha}$ bestimmt.
\begin{Verbatim}
  subroutine proton_remnant_remove_valence_up_quark(this,id,GeV_scale,momentum_fraction)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    associate(q=>this%valence_content(lha_flavor_u))
      if(q>0)then
         q=q-1
         call this%push_is_parton(id,lha_flavor_u,momentum_fraction)
         this%momentum_fraction=this%momentum_fraction*(1D0-momentum_fraction)
         call this%calculate_weight(GeV_scale)
      else
         print('("proton_remnant_remove_valence_up_quark: Cannot remove parton ",I2,": &
              &There are no such partons left.")'),lha_flavor_u
         call this%print_all
      end if
    end associate
  end subroutine proton_remnant_remove_valence_up_quark
\end{Verbatim}
\TbpImp{proton\_remnant\_remove\_valence\_down\_quark}
Siehe \TbpRef{proton\_remnant\_type}{remove\_valence\_up\_quark}
\begin{Verbatim}
  subroutine proton_remnant_remove_valence_down_quark(this,id,GeV_scale,momentum_fraction)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    associate(q=>this%valence_content(lha_flavor_d))
      if(q>0)then
         q=q-1
         call this%push_is_parton(id,lha_flavor_d,momentum_fraction)
         this%momentum_fraction=this%momentum_fraction*(1D0-momentum_fraction)
         call this%calculate_weight(GeV_scale)
      else
         print('("proton_remnant_remove_valence_down_quark: Cannot remove&
              & parton ",I2,": There are no such partons left.")')&
              &,lha_flavor_d
         call this%print_all
      end if
    end associate
  end subroutine proton_remnant_remove_valence_down_quark
\end{Verbatim}
\TbpImp{proton\_remnant\_remove\_sea\_quark}
Es wird ein Seequark aus dem Remnant genommen und ein Quasivalenzquark hinzugefügt. Wir merken uns, welches Quasivalenzquark zu welchem Seequark gehört und nennen das jeweils andere twin. Mit \TbpRef{proton\_remnant\_type}{push\_twin} erzeugen wir sowohl das neue aktive ISR Seequark als auch das neue Quasivalenzquark.
\begin{Verbatim}
  subroutine proton_remnant_remove_sea_quark(this,id,GeV_scale,momentum_fraction&
       &,lha_flavor)
    integer,intent(in)::id
    class(proton_remnant_type),intent(inout)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor
    if(lha_flavor>-6.and.lha_flavor<6.and.(lha_flavor.ne.0))then
       this%momentum_fraction=this%momentum_fraction*(1D0-momentum_fraction)
       call this%push_twin(id,lha_flavor,momentum_fraction,GeV_scale)
    end if
  end subroutine proton_remnant_remove_sea_quark
\end{Verbatim}
\TbpImp{proton\_remnant\_remove\_gluon}
Hier ist am wenigsten zu tun. Es wird nur der Remnant-Impuls aktualisiert und mit\linebreak \TbpRef{proton\_remnant\_type}{push\_is\_parton} ein neues aktives ISR-Gluon erzeugt.
\begin{Verbatim}
  subroutine proton_remnant_remove_gluon(this,id,GeV_scale,momentum_fraction)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    this%momentum_fraction=this%momentum_fraction*(1D0-momentum_fraction)
    call this%push_is_parton(id,lha_flavor_g,momentum_fraction)
  end subroutine proton_remnant_remove_gluon
\end{Verbatim}
\TbpImp{proton\_remnant\_remove\_twin}
Ein Quasivalenzquark wird aus dem Remnant genommen und in die Liste der aktiven Showerteilchen aufgenommen.
\begin{Verbatim}
  subroutine proton_remnant_remove_twin(this,id,GeV_scale)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id
    real(kind=double),intent(in)::GeV_scale
    class(parton_type),pointer::twin
    call this%twin_partons%pop(id,twin)
    call this%fs_partons%push(twin)
    this%twin_norm=this%twin_norm-twin%momentum
    this%n_twins=this%n_twins-1
    call this%calculate_weight(GeV_scale)
  end subroutine proton_remnant_remove_twin
\end{Verbatim}
! getting pdf

\TbpImp{proton\_remnant\_parton\_twin\_pdf}
Die Parton-PDFs aller Quasivalenzbeiträge zu dem angegebenen Flavor werden aufaddiert.
\begin{Verbatim}
  subroutine proton_remnant_parton_twin_pdf(this,lha_flavor,momentum_fraction,pdf)
    class(proton_remnant_type),intent(in)::this
    integer,intent(in)::lha_flavor
    real(kind=double),intent(in)::momentum_fraction
    real(kind=double)::pdf
    class(parton_type),pointer::tmp_twin
    pdf=0D0
    tmp_twin=>this%twin_partons%next
    do while(associated(tmp_twin))
       if(tmp_twin%lha_flavor==lha_flavor)pdf=pdf+tmp_twin%unweighted_pdf(momentum_fraction)
       tmp_twin=>tmp_twin%next
    end do
    pdf=pdf*this%get_twin_weight()
  end subroutine proton_remnant_parton_twin_pdf
\end{Verbatim}
\TbpImp{proton\_remnant\_parton\_twin\_pdf\_array}
Aus der Liste \CompRef{proton\_remnant\_type}{twin\_partons} wird in ein array von Parton-PDFs erzeugt. Jeder Eintrag in dem Dummy-Argument pdf entspricht einem Quasivalenzquark.
\begin{Verbatim}
  subroutine proton_remnant_parton_twin_pdf_array(this,momentum_fraction,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::momentum_fraction
    real(kind=double),dimension(this%n_twins),intent(out)::pdf
    class(parton_type),pointer::tmp_twin
    integer::l
    tmp_twin=>this%twin_partons%next
    l=0
    do while(associated(tmp_twin))
       l=l+1
       pdf(l)=tmp_twin%unweighted_pdf(momentum_fraction)*this%twin_norm
       tmp_twin=>tmp_twin%next
    end do
  end subroutine proton_remnant_parton_twin_pdf_array
\end{Verbatim}
\TbpImp{proton\_remnant\_momentum\_twin\_pdf}
Die Momentum-PDFs aller Quasivalenzbeiträge zu dem angegebenen Flavor werden aufaddiert.
\begin{Verbatim}
  subroutine proton_remnant_momentum_twin_pdf(this,lha_flavor,momentum_fraction,pdf)
    class(proton_remnant_type),intent(in)::this
    integer,intent(in)::lha_flavor
    real(kind=double),intent(in)::momentum_fraction
    real(kind=double),intent(out)::pdf
    call this%parton_twin_pdf(lha_flavor,momentum_fraction,pdf)
    pdf=pdf*momentum_fraction
  end subroutine proton_remnant_momentum_twin_pdf
\end{Verbatim}
\TbpImp{proton\_remnant\_momentum\_twin\_pdf\_array}
Aus der Liste \CompRef{proton\_remnant\_type}{twin\_partons} wird in ein array von Momentum-PDFs erzeugt. Jeder Eintrag in dem Dummy-Argument pdf entspricht einem Quasivalenzquark.
\begin{Verbatim}
  subroutine proton_remnant_momentum_twin_pdf_array(this,momentum_fraction,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::momentum_fraction
    real(kind=double),dimension(this%n_twins),intent(out)::pdf
    call this%parton_twin_pdf_array(momentum_fraction,pdf)
    pdf=pdf*momentum_fraction
  end subroutine proton_remnant_momentum_twin_pdf_array
\end{Verbatim}  
\TbpImp{proton\_remnant\_momentum\_kind\_pdf}
Zu dem angegebenen Flavor wird die Momentum-Strukturfunktion nach See- (einschließlich Gluon-), Valenz-  und Quasivalenzbeitrag aufgeschlüsselt.
\begin{Verbatim}
  subroutine proton_remnant_momentum_kind_pdf(this,GeV_scale,momentum_fraction&
       &,lha_flavor,valence_pdf,sea_pdf,twin_pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor                   !g,u,d,etc.
    real(kind=double),intent(out)::valence_pdf,sea_pdf,twin_pdf
    real(kind=double),dimension(-6:6)::pdf_array
    call evolvePDF(momentum_fraction,GeV_scale,pdf_array)
    select case (lha_flavor)
    case(0) !gluon
       valence_pdf=0D0
       sea_pdf=pdf_array(0)
    case(1) !down
       valence_pdf=this%get_valence_down_weight()*(pdf_array(1)-pdf_array(-1))
       sea_pdf=pdf_array(-1)
    case(2) !up
       valence_pdf=this%get_valence_up_weight()*(pdf_array(2)-pdf_array(-2))
       sea_pdf=pdf_array(-2)
    case default
       valence_pdf=0D0
       sea_pdf=pdf_array(lha_flavor)
    end select
    sea_pdf=sea_pdf*this%get_sea_weight()
    call this%momentum_twin_pdf(lha_flavor,momentum_fraction,twin_pdf)
  end subroutine proton_remnant_momentum_kind_pdf
\end{Verbatim}
\TbpImp{proton\_remnant\_momentum\_flavor\_pdf}
Zu dem angegebenen Flavor wird die Momentum-Strukturfunktion zurückgegeben. (Summe über alle Beiträge mit diesem Flavor.)
\begin{Verbatim}
  subroutine proton_remnant_momentum_flavor_pdf(this,GeV_scale,momentum_fraction&
       &,lha_flavor,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor     !g,u,d,etc.
    real(kind=double),intent(out)::pdf
    real(kind=double)::valence_pdf,sea_pdf,twin_pdf
    call proton_remnant_momentum_kind_pdf(this,GeV_scale,momentum_fraction,lha_flavor&
         &,valence_pdf,sea_pdf,twin_pdf)
    pdf=valence_pdf+sea_pdf+twin_pdf
  end subroutine proton_remnant_momentum_flavor_pdf
\end{Verbatim}  
\TbpImp{proton\_remnant\_momentum\_flavor\_pdf\_array}
Es wird ein array von Momentum-PDFs (Summe über alle Beiträge für jedes Flavor), aufgeschlüsselt nach Partonflavor zurückgegeben.

\wip{Es sind (noch) keine Quasivalenzquarks enthalten. Das ist aber nur eine Fleißübung, es gibt keinen technischen Hinderungsgrund.}
\begin{Verbatim}
  subroutine proton_remnant_momentum_flavor_pdf_array(this,GeV_scale,momentum_fraction&
       &,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    real(kind=double),dimension(-6:6),intent(out)::pdf
    real(kind=double),dimension(2)::valence_pdf
    call this%momentum_kind_pdf_array(GeV_scale,momentum_fraction,valence_pdf,pdf)
    pdf(1:2)=pdf(1:2)+valence_pdf
    ! no twin yet
  end subroutine proton_remnant_momentum_flavor_pdf_array
\end{Verbatim}
\TbpImp{proton\_remnant\_momentum\_kind\_pdf\_array}
Es werden See- (einschließlich Gluon-) und Valenzbeiträge zur Momentum-PDF als separate arrays ausgegeben.
\begin{Verbatim}
  subroutine proton_remnant_momentum_kind_pdf_array(this,GeV_scale,momentum_fraction&
       &,valence_pdf,sea_pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    real(kind=double),dimension(2),intent(out)::valence_pdf
    real(kind=double),dimension(-6:6),intent(out)::sea_pdf
    call evolvePDF(momentum_fraction,GeV_scale,sea_pdf)
    valence_pdf(1)=(sea_pdf(1)-sea_pdf(-1))*this%pdf_int_weight(pdf_int_kind_val_down)
    valence_pdf(2)=(sea_pdf(2)-sea_pdf(-2))*this%pdf_int_weight(pdf_int_kind_val_up)
    sea_pdf(1)=sea_pdf(-1)
    sea_pdf(2)=sea_pdf(-2)
    sea_pdf=sea_pdf*this%get_sea_weight()
    ! no twin yet
  end subroutine proton_remnant_momentum_kind_pdf_array
\end{Verbatim}
\TbpImp{proton\_remnant\_parton\_kind\_pdf}
Zu dem angegebenen Flavor wird die Parton-Strukturfunktion nach See- (einschließlich Gluon-), Valenz-  und Quasivalenzbeitrag aufgeschlüsselt.
\begin{Verbatim}
  subroutine proton_remnant_parton_kind_pdf(this,GeV_scale,momentum_fraction&
       &,lha_flavor,valence_pdf,sea_pdf,twin_pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor                   !g,u,d,etc.
    real(kind=double),intent(out)::valence_pdf,sea_pdf,twin_pdf
    call this%momentum_kind_pdf(GeV_scale,momentum_fraction,lha_flavor,valence_pdf&
         &,sea_pdf,twin_pdf)
    valence_pdf=valence_pdf/momentum_fraction
    sea_pdf=sea_pdf/momentum_fraction
    twin_pdf=twin_pdf/momentum_fraction
  end subroutine proton_remnant_parton_kind_pdf
\end{Verbatim}
\TbpImp{proton\_remnant\_parton\_flavor\_pdf}
Zu dem angegebenen Flavor wird die Parton-Strukturfunktion zurückgegeben (Summe über alle Beiträge mit diesem Flavor).
\begin{Verbatim}
  subroutine proton_remnant_parton_flavor_pdf(this,GeV_scale,momentum_fraction&
       &,lha_flavor,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    integer,intent(in)::lha_flavor     !g,u,d,etc.
    real(kind=double),intent(out)::pdf
    call this%momentum_flavor_pdf(GeV_scale,momentum_fraction,lha_flavor,pdf)
    pdf=pdf/momentum_fraction
  end subroutine proton_remnant_parton_flavor_pdf
\end{Verbatim}  
\TbpImp{proton\_remnant\_parton\_kind\_pdf\_array}
Es wird ein array von Parton-PDFs (Summe über alle Beiträge für jedes Flavor), aufgeschlüsselt nach Partonflavor zurückgegeben.

\wip{Es sind (noch) keine Quasivalenzquarks enthalten. Das ist aber nur eine Fleißübung, es gibt keinen technischen Hinderungsgrund.}
\begin{Verbatim}
  subroutine proton_remnant_parton_kind_pdf_array(this,GeV_scale,momentum_fraction&
       &,valence_pdf,sea_pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    real(kind=double),dimension(2),intent(out)::valence_pdf
    real(kind=double),dimension(-6:6),intent(out)::sea_pdf
    call evolvePDF(momentum_fraction,GeV_scale,sea_pdf)
    sea_pdf=sea_pdf/momentum_fraction
    valence_pdf(1)=(sea_pdf(1)-sea_pdf(-1))*this%valence_content(1)
    valence_pdf(2)=(sea_pdf(2)-sea_pdf(-2))*(this%valence_content(2)/2D0)
    sea_pdf(1)=sea_pdf(-1)
    sea_pdf(2)=sea_pdf(-2)
    valence_pdf=valence_pdf*this%get_valence_weight()
    sea_pdf=sea_pdf*this%get_sea_weight()
    ! no twin yet
  end subroutine proton_remnant_parton_kind_pdf_array
\end{Verbatim}
\TbpImp{proton\_remnant\_parton\_flavor\_pdf\_array}
Es werden See- (einschließlich Gluon-) und Valenzbeiträge zur Parton-PDF als separate arrays ausgegeben.
\begin{Verbatim}
  subroutine proton_remnant_parton_flavor_pdf_array(this,GeV_scale,momentum_fraction&
       &,pdf)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum_fraction
    real(kind=double),dimension(-6:6),intent(out)::pdf
    real(kind=double),dimension(2)::valence_pdf
    real(kind=double),dimension(-6:6)::twin_pdf
    print('("proton_remnant_flavor_pdf_array: Not yet implemented.")')
  end subroutine proton_remnant_parton_flavor_pdf_array
\end{Verbatim}

  ! getting components

\TbpImp{proton\_remnant\_get\_pdf\_int\_weight}
\begin{Verbatim}
  pure function proton_remnant_get_pdf_int_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),dimension(5)::weight
    weight=this%pdf_int_weight
  end function proton_remnant_get_pdf_int_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_valence\_weight}
\begin{Verbatim}
  pure function proton_remnant_get_valence_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double),dimension(2)::weight
    weight=this%pdf_int_weight(3:4)
  end function proton_remnant_get_valence_weight
\end{Verbatim}
  
\TbpImp{proton\_remnant\_get\_valence\_down\_weight}
\begin{Verbatim}
  elemental function proton_remnant_get_valence_down_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::weight
    weight=this%pdf_int_weight(pdf_int_kind_val_down)
  end function proton_remnant_get_valence_down_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_valence\_up\_weight}
\begin{Verbatim}
  elemental function proton_remnant_get_valence_up_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::weight
    weight=this%pdf_int_weight(pdf_int_kind_val_up)
  end function proton_remnant_get_valence_up_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_sea\_weight}
\begin{Verbatim}
  elemental function proton_remnant_get_sea_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::weight
    weight=this%pdf_int_weight(pdf_int_kind_sea)
  end function proton_remnant_get_sea_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_gluon\_weight}
\begin{Verbatim}
  elemental function proton_remnant_get_gluon_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::weight
    weight=this%pdf_int_weight(pdf_int_kind_gluon)
  end function proton_remnant_get_gluon_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_twin\_weight}
\begin{Verbatim}
  elemental function proton_remnant_get_twin_weight(this) result(weight)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::weight
    weight=this%pdf_int_weight(pdf_int_kind_twin)
  end function proton_remnant_get_twin_weight
\end{Verbatim}

\TbpImp{proton\_remnant\_get\_valence\_content}
\begin{Verbatim}
  pure function proton_remnant_get_valence_content(this) result(valence)
    class(proton_remnant_type),intent(in)::this
    integer,dimension(2)::valence
    valence=this%valence_content
  end function proton_remnant_get_valence_content
\end{Verbatim}
  
\TbpImp{proton\_remnant\_get\_momentum\_fraction}
\begin{Verbatim}
  elemental function proton_remnant_get_momentum_fraction(this) result(momentum)
    class(proton_remnant_type),intent(in)::this
    real(kind=double)::momentum
    momentum=this%momentum_fraction
  end function proton_remnant_get_momentum_fraction
\end{Verbatim}

  ! misc

\TbpImp{proton\_remnant\_deallocate}
\begin{Verbatim}
  subroutine proton_remnant_deallocate(this)
    class(proton_remnant_type),intent(inout)::this
    call this%is_partons%deallocate
    call this%fs_partons%deallocate
    call this%twin_partons%deallocate
    this%twin_norm=0D0
    this%n_twins=0
  end subroutine proton_remnant_deallocate
\end{Verbatim}

\TbpImp{proton\_remnant\_initialize}
\begin{Verbatim}
  subroutine proton_remnant_initialize(this,pdf_norm)
    class(proton_remnant_type),intent(out)::this
    class(pdfnorm_type),target,intent(in)::pdf_norm
    this%pdf_norm=>pdf_norm
  end subroutine proton_remnant_initialize
\end{Verbatim}
  
\TbpImp{proton\_remnant\_finalize}
\begin{Verbatim}
  subroutine proton_remnant_finalize(this)
    class(proton_remnant_type),intent(inout)::this
    call this%deallocate()
    nullify(this%pdf_norm)
  end subroutine proton_remnant_finalize
\end{Verbatim}
\TbpImp{proton\_remnant\_apply\_initial\_splitting}
Es wird eine WHIZARD-Interaktion auf den Remnant übertragen. Im Falle eines Gluons im Eingangszustand wird einfach die Methode \TbpRef{proton\_remnant\_type}{remove\_gluon} aufgerufen. Im Falle eines Quarks muss noch entschieden werden, ob es sich um ein See- oder ein Valenzquark handelt.

Mit \TbpRef{proton\_remnant\_type}{parton\_kind\_pdf} bekommen wir die Strukturfunktion nach See-, Valenz- und Quasivalenzanteil ($f_{q^S},f_{q^V},f_{q^Q}$) aufgeschlüsselt. Durch Vergleich des Verhältnisses $\frac{f_{q^V}}{f_{q^V}+f_{q^S}}$ mit der Zufallszahl \emph{rnd} entscheiden wir, ob \TbpRef{proton\_remnant\_type}{remove\_valence\_up\_quark} bzw. \TbpRef{proton\_remnant\_type}{remove\_valence\_down\_quark} oder \TbpRef{proton\_remnant\_type}{remove\_sea\_quark} aufgerufen wird.
\begin{Verbatim}
  subroutine proton_remnant_apply_initial_splitting(this,id,pdg_flavor,x,gev_scale,rnd)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id,pdg_flavor
    real(kind=double),intent(in)::x,gev_scale,rnd
    real(kind=double)::valence_pdf,sea_pdf,twin_pdf
    select case(pdg_flavor)
    case(pdg_flavor_g)
       call this%remove_gluon(id,gev_scale,x)
    case(pdg_flavor_u)
       call this%parton_kind_pdf(gev_scale,x&
            &,pdg_flavor,valence_pdf,sea_pdf,twin_pdf)
       if(valence_pdf/(valence_pdf+sea_pdf)<rnd)then
          call this%remove_sea_quark(id,gev_scale,x,pdg_flavor)
       else
          call this%remove_valence_up_quark(id,gev_scale,x)
       end if
    case(pdg_flavor_d)
       call this%parton_kind_pdf(gev_scale,x&
            &,pdg_flavor,valence_pdf,sea_pdf,twin_pdf)
       if(valence_pdf/(valence_pdf+sea_pdf)<rnd)then
          call this%remove_sea_quark(id,gev_scale,x,pdg_flavor)
       else
          call this%remove_valence_down_quark(id,gev_scale,x)
       end if
    case default
       call this%remove_sea_quark(id,gev_scale,x,pdg_flavor)
    end select
    this%momentum_fraction=(1D0-x)
  end subroutine proton_remnant_apply_initial_splitting
\end{Verbatim}
\TbpImp{proton\_remnant\_reset}
\begin{Verbatim}
  subroutine proton_remnant_reset(this)
    class(proton_remnant_type),intent(inout)::this
    call this%deallocate()
    this%valence_content=[1,2]
    this%pdf_int_weight=[1D0,1D0,1D0,1D0,1D0]
    this%momentum_fraction=1D0
  end subroutine proton_remnant_reset
\end{Verbatim}
  ! private

\TbpImp{proton\_remnant\_push\_is\_parton}
Es wird eine neue Instanz vom Typ \TypeRef{parton\_type} allokiert und mit \TbpRef{parton\_type}{push} auf den Stapel \CompRef{proton\_remnant\_type}{is\_partons} der aktiven ISR-Partonen gelegt.
\begin{Verbatim}
  subroutine proton_remnant_push_is_parton(this,id,lha_flavor,momentum_fraction)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id,lha_flavor
    real(kind=double),intent(in)::momentum_fraction
    class(parton_type),pointer::tmp_parton
    allocate(tmp_parton)
    tmp_parton%id=id
    tmp_parton%lha_flavor=lha_flavor
    tmp_parton%momentum=momentum_fraction
    call this%is_partons%push(tmp_parton)
  end subroutine proton_remnant_push_is_parton
\end{Verbatim}
\TbpImp{proton\_remnant\_push\_twin}
Ein Seequark wird aus dem Remnant entfernt, indem ein neues quark auf den Stapel\linebreak \CompRef{proton\_remnant\_type}{is\_partons} der aktiven ISR-Partonen gelegt und ein Quasivalenzquark(twin) in den Remnant aufgenommen wird. Die Quasivalenzquarks im Remnant werden durch den Stapel \CompRef{proton\_remnant\_type}{twin\_partons} dargestelt. Das Quasivalenzquark bekommt eine negative ID, wodurch es als Quasivalenzquark ausgezeichnet wird. Beide bekommen einen Zeiger \emph{twin}, der auf das jeweils andere zeigt.

\mip{Die Modulfunktion remnant\_twin\_momentum\_4 liefert das Integral über die ungewichtete momentum-PDF des Quasivalenzquarks zurück. new\_twin\%momentum ist also der ungewichtete Impulserwartungswert des Quasivalenzquarks, während new\_is\%momentum der Impulsanteil $\xi$ des Partons ist.}

Mit \TbpRef{parton\_type}{push} werden die neuen Teichen auf die jeweiligen Stapel gelegt und mit\linebreak \TbpRef{proton\_remnant\_type}{calculate\_weight} werden die neuen Wichtungsfaktoren ausgewertet.
\begin{Verbatim}
  subroutine proton_remnant_push_twin(this,id,lha_flavor,momentum_fraction,gev_scale)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::id,lha_flavor !of IS parton
    real(kind=double),intent(in)::momentum_fraction !of IS parton
    real(kind=double),intent(in)::GeV_scale
    class(parton_type),pointer::new_is,new_twin
    real(kind=double)::norm
    !print *,"proton_remnant_push_twin",momentum_fraction
    allocate(new_is)    
    allocate(new_twin)
    !IS initialization
    new_is%id=id
    new_is%lha_flavor=lha_flavor
    new_is%momentum=momentum_fraction
    new_is%twin=>new_twin
    !twin initialization
    new_twin%id=-id
    new_twin%lha_flavor=-lha_flavor
    new_twin%momentum=remnant_twin_momentum_4(momentum_fraction)
    new_twin%twin=>new_is
    !remnant update
    this%n_twins=this%n_twins+1
    this%twin_norm=this%twin_norm+new_twin%momentum
    call this%is_partons%push(new_is)
    call this%twin_partons%push(new_twin)
    call this%calculate_weight(GeV_scale)
  end subroutine proton_remnant_push_twin
\end{Verbatim}
\TbpImp{proton\_remnant\_calculate\_twin\_norm}
Wenn \CompRef{proton\_remnant\_type}{twin\_partons} Partonen enthält, dann wird die Summe der Impulsmittelwerte aller Partonen aus \CompRef{proton\_remnant\_type}{twin\_partons} in der Komponente \linebreak \CompRef{proton\_remnant\_type}{twin\_norm} abgelegt. Sonst wird \CompRef{proton\_remnant\_type}{twin\_norm} auf Null gesetzt.
\begin{Verbatim}
  subroutine proton_remnant_calculate_twin_norm(this)
    class(proton_remnant_type),intent(inout)::this
    class(parton_type),pointer::twin
    integer::n
    if(associated(this%twin_partons%next))then
       this%twin_norm=0D0
       twin=>this%twin_partons%next
       do while(associated(twin))
          this%twin_norm=this%twin_norm+twin%momentum
          twin=>twin%next
       end do
    else
       this%twin_norm=0D0
    end if
  end subroutine proton_remnant_calculate_twin_norm
\end{Verbatim}
\TbpImp{proton\_remnant\_replace\_is\_parton}
Der ISR-Algorithmus hat ein Splitting eines Teilchens mit der id \emph{old\_id} generiert, das zuvor aus dem Remnant entfert wurde. Jetzt wird das alte Remnant-Teilchen wieder in den Remnant zurückgelegt und das neue Teilchen mit der id \emph{new\_id} aus dem Remnant entfernt (siehe Abbildung \ref{fig:all:flow:isr}). In Abschnitt 5.4.3 meiner Dissertation wird noch einiges zu dieser Prozedur erläutert.
\begin{Verbatim}
  subroutine proton_remnant_replace_is_parton&
    (this,&
    old_id,&
    new_id,&
    pdg_f,&
    x_proton,&
    gev_scale)
    class(proton_remnant_type),intent(inout)::this
    integer,intent(in)::old_id,new_id,pdg_f
    real(kind=double),intent(in)::x_proton,gev_scale
    class(parton_type),pointer::old_is_parton
    integer::lha_flavor
    real(kind=double)::momentum_fraction
    momentum_fraction=x_proton/this%momentum_fraction()
    \IC{convert pdg flavor numbers to lha flavor numbers}
    if(pdg_f==pdg_flavor_g)then
       lha_flavor=lha_flavor_g
    else
       lha_flavor=pdg_f
    end if
    \IC{we remove the old initial state parton from initial state stack.}
    call this%is_partons%pop(old_id,old_is_parton)
    \IC{this check has no physical meaning, it's just a check for consistency.}
    if(associated(old_is_parton))then
       \IC{do we emit a gluon?}
       if(lha_flavor==old_is_parton%lha_flavor)then
          \IC{has the old initial state parton been a sea quark?}
          if(associated(old_is_parton%twin))then
             \IC{the connection of the old is parton with it's twin was provisional.}
             \IC{We remove it now}
             call this%twin_partons%pop(old_is_parton%twin)
             call this%fs_partons%push(old_is_parton%twin)
             this%n_twins=this%n_twins-1
             \IC{and generate a new initial state parton - twin pair.}
             call this%push_twin(new_id,lha_flavor,momentum_fraction,gev_scale)
          else
             \IC{there is no twin, so we just insert the new initial state parton.}
             call this%push_is_parton(new_id,lha_flavor,momentum_fraction)
          end if
       else
          \IC{we emit a quark. is this a g->qqbar splitting?}
          if(lha_flavor==lha_flavor_g)then
             \IC{we insert the new initial state gloun.}
             call this%push_is_parton(new_id,lha_flavor,momentum_fraction)
             \IC{has the old initial state quark got a twin?}
             if(associated(old_is_parton%twin))then
                \IC{we assume that this twin is the second splitting particle. so the}
                \IC{twin becomes a final state particle now and must be removed from}
                \IC{the is stack.}
                call this%remove_twin(-old_id,GeV_scale)
             else
                \IC{the old initial state quark has been a valence quark.}
                \IC{what should we do now? is this splitting sensible at all?}
                \IC{we don't know but allow these splittings.}
                \IC{The most trivial treatment is to restore the former valence quark.}
                this%valence_content(old_is_parton%lha_flavor)=&
                     this%valence_content(old_is_parton%lha_flavor)+1
             end if
          else
             \IC{this is a q->qg splitting. the new initial state quark emits the }
             \IC{preceding initial state gluon. yeah, backward evolution is confusing!}
             \IC{the new initial state quark is not part of the proton remnant any longer.}
             \IC{how do we remove a quark from the remnant? we add a conjugated twin}
             \IC{parton and assume, that this twin is created in a not yet resolved}
             \IC{g->qqbar splitting.}
             call this%push_twin(new_id,lha_flavor,momentum_fraction,gev_scale)
          end if
       end if
       \IC{everything is done. what shall we do with the old initial state parton?}
       \IC{we don't need it any more but we store it anyway for future FSR extension.}
       call this%fs_partons%push(old_is_parton)
       \IC{the new initial state parton has taken away momentum, so we update the remnant}
       \IC{momentum fraction.}
       this%momentum_fraction=&
       this%momentum_fraction*(1-momentum_fraction)/(1-old_is_parton%momentum)
    else
       \IC{this indicates a bug.}
       print *,"proton_remnant_replace_is_parton: parton #",old_id,&
       " not found on ISR stack."
       if(associated(this%is_partons%next))then
          print *,"actual content of isr stack:"
          call this%is_partons%next%print_peers()
       else
          print *,"isr stack is not associated."
       end if
       STOP
    end if
  end subroutine proton_remnant_replace_is_parton
\end{Verbatim}
\TbpImp{proton\_remnant\_calculate\_weight}
Die Wichtungsfaktoren $[W_G,W_S,W_{d^V},W_{u^V},W_Q]$ aus \eqref{eq:all:rem:sumrule} werden bestimmt.
\begin{Verbatim}
  subroutine proton_remnant_calculate_weight(this,GeV_scale)
    class(proton_remnant_type),intent(inout)::this
    real(kind=double),intent(in)::GeV_scale
    real(kind=double)::all,gluon,sea,vu,vd,valence,twin,weight
    \IC{Die 1 aus \eqref{eq:all:rem:sumrule}}
    call this%pdf_norm%get_norm(GeV_scale,1,0,all)
    \IC{Die Impulsmittelwerte}
    call this%pdf_norm%get_norm(GeV_scale,1,pdf_int_kind_gluon,gluon)
    call this%pdf_norm%get_norm(GeV_scale,1,pdf_int_kind_sea,sea)
    call this%pdf_norm%get_norm(GeV_scale,1,pdf_int_kind_val_down,vd)
    call this%pdf_norm%get_norm(GeV_scale,1,pdf_int_kind_val_up,vu)
    \IC{Wir multiplizieren die Valenzbeiträge mit dem Valenz-Inhalt-Faktor.}
    valence=&
         vd*this%valence_content(lha_flavor_d)+&
         vu*this%valence_content(lha_flavor_u)/2D0
    \IC{Die Quasivalenzquark-Beiträge werden auf die Summe aller LHAPDF-Mittelwerte normiert.}
    \IC{(siehe \TypeRef{pdfnorm\_type})}
    twin=this%twin_norm/all
    \IC{(siehe Tabelle \ref{tab:all:rem:weight_models} mit w\(\rightarrow\)weight)}
    select case(remnant_weight_model)
    case(0) ! no reweighting
       this%pdf_int_weight=[1D0,1D0,1D0,1D0,1D0]
    case(2) !pythia-like, only sea
       weight=(1D0-valence-twin)&
            &/(sea+gluon)
       this%pdf_int_weight=[weight,weight,1D0,1D0,1D0]
    case(3) !only valence and twin
       weight=(1D0-sea-gluon)&
            &/(valence+twin)
       this%pdf_int_weight=[1D0,1D0,weight,weight,weight]
    case(4) !only sea and twin
       weight=(1D0-valence)&
            &/(sea+gluon+twin)
       this%pdf_int_weight=[1D0,weight,1D0,1D0,weight]
    case default !equal weight
       weight=1D0/(valence+sea+gluon+twin)
       this%pdf_int_weight=[weight,weight,weight,weight,weight]
    end select
    this%pdf_int_weight(pdf_int_kind_val_down)=&
      this%pdf_int_weight(pdf_int_kind_val_down)*this%valence_content(1)
    this%pdf_int_weight(pdf_int_kind_val_up)=&
      this%pdf_int_weight(pdf_int_kind_val_up)*this%valence_content(2)*5D-1
  end subroutine proton_remnant_calculate_weight
\end{Verbatim}
\OverridesSection{serializable\_class}

\TbpImp{proton\_remnant\_write\_to\_marker}
\begin{Verbatim}
  subroutine proton_remnant_write_to_marker(this,marker,status)
    class(proton_remnant_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("proton_remnant_type")
    call marker%mark("valence_content",this%valence_content)
    call marker%mark("momentum_fraction",this%momentum_fraction)
    call marker%mark("pdf_int_weight",this%pdf_int_weight)
    call marker%mark_end("proton_remnant_type")
  end subroutine proton_remnant_write_to_marker
\end{Verbatim}

\TbpImp{proton\_remnant\_read\_from\_marker}
\begin{Verbatim}
  subroutine proton_remnant_read_from_marker(this,marker,status)
    class(proton_remnant_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    character(:),allocatable::name
    call marker%pick_begin("proton_remnant_type",status=status)
    call marker%pick("valence_content",this%valence_content,status)
    call marker%pick("momentum_fraction",this%momentum_fraction,status)
    call marker%pick("pdf_int_weight",this%pdf_int_weight,status)
    call marker%pick_end("proton_remnant_type",status=status)
  end subroutine proton_remnant_read_from_marker
\end{Verbatim}

\TbpImp{proton\_remnant\_print\_to\_unit}
\begin{Verbatim}
  subroutine proton_remnant_print_to_unit(this,unit,parents,components,peers)
    class(proton_remnant_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of proton_remnant_type:")')
    write(unit,'("Valence Content:           ",I1,":",I1)')this&
         &%valence_content
    write(unit,'("N Twins:                   ",I1)')this%n_twins
    write(unit,'("INT weights [g,s,d,u,t]    ",5(F7.3))')this%pdf_int_weight
    write(unit,'("Total Momentum Fraction:   ",F7.3)')this%momentum_fraction
    write(unit,'("Twin Norm:            ",F7.3)')this%twin_norm
  end subroutine proton_remnant_print_to_unit
\end{Verbatim}
  \TbpImp{proton\_remnant\_get\_type}
\begin{Verbatim}
  pure subroutine proton_remnant_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="proton_remnant_type")
  end subroutine proton_remnant_get_type
\end{Verbatim}
\TbpImp{proton\_remnant\_gnuplot\_momentum\_kind\_pdf\_array}
Außerhalb dieser Prozedur müssen zwei Dateien mit formatiertem, sequentiellen Schreibzugriff geöffnet werden und die assoziierten units an momentum\_unit und parton\_unit übergeben werden. Dann wird $[x_j,\sum_k f_k(x_j,\mu),\{f_k(x_j,\mu)\}],j=1..100$ nach parton\_unit und $[x_j,\sum_k x_j f_k(x_j,\mu),x_j \{f_k(x_j,\mu)\}],j=1..100$ nach momentum\_unit geschrieben. $k$ sind alle einzelnen Beiträge zur Strukturfunktion mit $k=[v^d,v^u,\overline{\{q\}},g,\{q\},\{Q\}]$, $\{q\}$ sind alle Flavor und $\{Q\}$ alle Quasivalenzquarks.
\begin{Verbatim}
  subroutine proton_remnant_gnuplot_momentum_kind_pdf_array&
    (this,momentum_unit,parton_unit,GeV_scale)
    class(proton_remnant_type),intent(in)::this
    integer,intent(in)::momentum_unit,parton_unit
    real(kind=double),intent(in)::GeV_scale
    real(kind=double),dimension(2)::valence_pdf
    real(kind=double),dimension(-6:6)::sea_pdf
    real(kind=double),dimension(this%n_twins)::twin_pdf
    integer::x
    real(kind=double)::momentum_fraction
    do x=1,100
       momentum_fraction=x*1D-2
       call this%momentum_kind_pdf_array(GeV_scale,momentum_fraction&
            &,valence_pdf,sea_pdf)
       call this%momentum_twin_pdf_array(momentum_fraction,twin_pdf)
       write(momentum_unit,fmt=*)momentum_fraction,&
            sum(valence_pdf)+sum(sea_pdf)+sum(twin_pdf),&
            valence_pdf,&
            sea_pdf,&
            twin_pdf
       call this%parton_kind_pdf_array(GeV_scale,momentum_fraction&
            &,valence_pdf,sea_pdf)
       call this%parton_twin_pdf_array(momentum_fraction,twin_pdf)
       write(parton_unit,fmt=*)momentum_fraction,&
            sum(valence_pdf)+sum(sea_pdf)+sum(twin_pdf),&
            valence_pdf,&
            sea_pdf,&
            twin_pdf       
    end do
  end subroutine proton_remnant_gnuplot_momentum_kind_pdf_array
\end{Verbatim}
\MethodsFor{pp\_remnant\_type}
\TbpImp{pp\_remnant\_initialize}
Der Hauptzweck dieser Prozedur ist es, die Impulsmittelwerte $\mean{f}(\mu)=\int\!\der\!x\ x f(x,\mu)$
 bereitzustellen. Im Verzeichnis muli\_dir wird nach integrierten PDFs, passend zu dem verwendeten LHAPDF-Set, gesucht. Wenn sie existierten, werden sie deserialisiert, sonst werden sie neu generiert und serialisiert.
\begin{Verbatim}
  subroutine pp_remnant_initialize(&
       this,&
       muli_dir,&
       lhapdf_dir,&
       lhapdf_file,&
       lhapdf_member)
    class(pp_remnant_type),intent(out)::this
    character(*),intent(in)::muli_dir,lhapdf_dir,lhapdf_file
    integer,intent(in)::lhapdf_member
    logical::exist
    allocate(this%pdf_norm)
    print *,"looking for previously generated pdf integrals..."
    inquire(file=muli_dir//"/pdf_norm_"//lhapdf_file//".xml",exist=exist)
    if(exist)then
       print *,"found. Starting deserialization..."
       call this%pdf_norm%deserialize(&
            name="pdf_norm_"//lhapdf_file,&
            file=muli_dir//"/pdf_norm_"//lhapdf_file//".xml")
       print *,"done."
    else
       print *,"No integrals found. Starting generation..."
       call this%pdf_norm%scan()
       print *,"done."
       call this%pdf_norm%serialize(&
            name="pdf_norm_"//lhapdf_file,&
            file=muli_dir//"/pdf_norm_"//lhapdf_file//".xml")
    end if
    call this%proton(1)%initialize(this%pdf_norm)
    call this%proton(2)%initialize(this%pdf_norm)
    this%initialized=.true.
  end subroutine pp_remnant_initialize
\end{Verbatim}
\TbpImp{pp\_remnant\_finalize}
Die Impulsmittelwerte in \CompRef{pp\_remnant\_type}{pdf\_norm} werden deallokiert und Zeiger darauf deassoziiert.
\begin{Verbatim}
  subroutine pp_remnant_finalize(this)
    class(pp_remnant_type),intent(inout)::this
    call this%proton(1)%finalize()
    call this%proton(2)%finalize()
    deallocate(this%pdf_norm)
  end subroutine pp_remnant_finalize
\end{Verbatim}
\TbpImp{pp\_remnant\_apply\_initial\_interaction}
Wrapper für \TbpRef{proton\_remnant\_type}{apply\_initial\_splitting}
\begin{Verbatim}
  subroutine pp_remnant_apply_initial_interaction&
  (this,gev_cme,x1,x2,pdg_f1,pdg_f2,n1,n2,gev_scale,rnd1,rnd2)
    class(pp_remnant_type),intent(inout)::this
    real(kind=double),intent(in)::gev_cme,x1,x2,gev_scale,rnd1,rnd2
    integer,intent(in)::pdg_f1,pdg_f2,n1,n2
    if(this%initialized)then
       call this%proton(1)%apply_initial_splitting(n1,pdg_f1,x1,gev_scale,rnd1)
       call this%proton(2)%apply_initial_splitting(n2,pdg_f2,x2,gev_scale,rnd2)
       this%X=(1D0-x1)*(1D0-x2)
       this%gev_initial_cme=gev_cme
    else
       print *,"pp_remnant_apply_initial_interaction:"
       print *,"Not yet initialized, call pp_remnant_initialize first!"
       stop
    end if
  end subroutine pp_remnant_apply_initial_interaction
\end{Verbatim}
\TbpImp{pp\_remnant\_replace\_parton}
Wrapper für \TbpRef{proton\_remnant\_type}{replace\_is\_parton}
\begin{Verbatim}
  subroutine pp_remnant_replace_parton(this,proton_id,old_id,new_id,pdg_f,x_proton,gev_scale)
    class(pp_remnant_type),intent(inout)::this
    integer,intent(in)::proton_id,old_id,new_id,pdg_f
    real(kind=double),intent(in)::x_proton,gev_scale
    call this%proton(proton_id)%replace_is_parton(old_id,new_id,pdg_f,x_proton,gev_scale)
  end subroutine pp_remnant_replace_parton
\end{Verbatim}
\TbpImp{pp\_remnant\_momentum\_pdf}
\begin{Verbatim}
  subroutine pp_remnant_momentum_pdf(this,x_proton,gev2_scale,n,pdg_f,pdf)
    class(pp_remnant_type),intent(in)::this
    real(kind=double),intent(in)::x_proton,gev2_scale
    integer,intent(in)::n,pdg_f
    real(kind=double),intent(out)::pdf
    \IC{Von welchem Remnant wollen wir die Momentum PDF haben?}
    \IC{Es muss das erste oder das zweite sein.}
    if(n==1.or.n==2)then
       \IC{Der Impulsanteil $x$ ist auf den Impuls des ungestörten Protons bezogen,}
       \IC{deswegen darf es nicht zwischen 0 und 1 sein, sondern nur zwischen 0 und $X$.}
       if(x_proton<=this%proton(n)%momentum_fraction)then
          \IC{momentum\_flavor\_pdf erwartet Flavor im PDG-Schema.}
          \IC{Das Gluon muss entsprechend konvertiert werden.}
          if(pdg_f==pdg_flavor_g)then
             call this%proton(n)%momentum_flavor_pdf(&
                  sqrt(GeV2_scale),&
                  \IC{momentum\_flavor\_pdf erwartet Impulsanteile, die auf die Remnantimpulse}
                  \IC{bezogen sind.}
                  x_proton/this%proton(n)%momentum_fraction,&
                  lha_flavor_g,&
                  pdf&
                  )
          else
             call this%proton(n)%momentum_flavor_pdf(&
                  sqrt(GeV2_scale),x_proton/this%proton(n)%momentum_fraction,pdg_f,pdf&
                  )
          end if
          \IC{Durch die Transformation des Arguments müssen auch die Funktionswerte}
          \IC{angepasst werden.}
          pdf=pdf*this%proton(n)%momentum_fraction
       else
          pdf=0D0
       end if
    else
       print *,"pp_remnant_momentum_pdf: n must be either 1 or 2, but it is ",n
       stop
    end if
  end subroutine pp_remnant_momentum_pdf
\end{Verbatim}
\TbpImp{pp\_remnant\_parton\_pdf}

\begin{Verbatim}
 subroutine pp_remnant_parton_pdf(this,x_proton,gev2_scale,n,pdg_f,pdf)
    class(pp_remnant_type),intent(in)::this
    real(kind=double),intent(in)::x_proton,gev2_scale
    integer,intent(in)::n,pdg_f
    real(kind=double),intent(out)::pdf
    if(n==1.or.n==2)then
       if(x_proton<=this%proton(n)%momentum_fraction)then
          if(pdg_f==pdg_flavor_g)then
             call this%proton(n)%parton_flavor_pdf(&
                  sqrt(GeV2_scale),&
                  x_proton*(1D0-this%proton(n)%momentum_fraction),&
                  lha_flavor_g,&
                  pdf&
                  )
          else
             call this%proton(n)%parton_flavor_pdf(&
                  sqrt(GeV2_scale),&
                  x_proton*(1D0-this%proton(n)%momentum_fraction),&
                  pdg_f,&
                  pdf&
                  )
          end if
          pdf=pdf/(1D0-this%proton(n)%momentum_fraction)
       else
          pdf=0D0
       end if
    else
       print *,"pp_remnant_parton_pdf: n must be either 1 or 2, but it is ",n
       stop
    end if
  end subroutine pp_remnant_parton_pdf
\end{Verbatim}
\TbpImp{pp\_remnant\_apply\_interaction}
Den Remnants wird mitgeteilt, dass eine Wechselwirkung stattgefunden hat. Alle Informationen über diese Wechselwirkung liegen in einer Instanz vom Typ \TypeRef{muli\_type}. Um sie zu erreichen, wird ein Dummyargument der Klasse \TypeRef{qcd\_2\_2\_type}, die von \TypeRef{muli\_type} erweitert wird, deklariert. 

Hier geschieht nichts, außer dass das Stratum $\{\alpha,\beta\}$ explizit als Ganzzahlen-Doublet in \emph{int\_k} abgelegt wird und für beide Remnants this\%proton(1) und this\%proton(2) die entsprechende Methoden aus der Menge $\{$\TbpRef{proton\_remnant\_type}{remove\_valence\_down\_quark}, \TbpRef{proton\_remnant\_type}{remove\_valence\_up\_quark}, \TbpRef{proton\_remnant\_type}{remove\_sea\_quark}, \TbpRef{proton\_remnant\_type}{remove\_gluon}$\}$ aufgerufen wird.
\begin{Verbatim}
  subroutine pp_remnant_apply_interaction(this,qcd_2_2)
    class(pp_remnant_type),intent(inout)::this
    class(qcd_2_2_class),intent(in)::qcd_2_2
    integer,dimension(4)::lha_f
    integer,dimension(2)::int_k
    real(kind=double)::gev_pt
    real(kind=double),dimension(2)::mom_f
    integer::n
    mom_f=qcd_2_2%get_remnant_momentum_fractions()
    lha_f=qcd_2_2%get_lha_flavors()
    int_k=qcd_2_2%get_pdf_int_kinds()
    gev_pt=qcd_2_2%get_gev_scale()
    do n=1,2
       select case (int_k(n))
       case(pdf_int_kind_val_down)
          call this%proton(n)%remove_valence_down_quark(&
            qcd_2_2%get_parton_id(n),&
            gev_pt,&
            mom_f(n))
       case(pdf_int_kind_val_up)
          call this%proton(n)%remove_valence_up_quark(&
            qcd_2_2%get_parton_id(n),&
            gev_pt,&
            mom_f(n))
       case(pdf_int_kind_sea)
          call this%proton(n)%remove_sea_quark(&
          qcd_2_2%get_parton_id(n),&
          gev_pt,&
          mom_f(n),&
          lha_f(n))
       case(pdf_int_kind_gluon)
          call this%proton(n)%remove_gluon(&
          qcd_2_2%get_parton_id(n),&
          gev_pt,&
          mom_f(n))
       end select
    end do
    this%X=this%proton(1)%momentum_fraction*this%proton(2)%momentum_fraction
  end subroutine pp_remnant_apply_interaction
\end{Verbatim}

\TbpImp{pp\_remnant\_reset}
\begin{Verbatim}
  subroutine pp_remnant_reset(this)
    class(pp_remnant_type),intent(inout)::this
    call this%proton(1)%reset()
    call this%proton(2)%reset()
    this%X=1D0
  end subroutine pp_remnant_reset
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_pdf\_int\_weights}
\begin{Verbatim}
  pure function pp_remnant_get_pdf_int_weights(this,pdf_int_kinds) result(weight)
    class(pp_remnant_type),intent(in)::this
    real(kind=double)::weight
    integer,dimension(2),intent(in)::pdf_int_kinds ! pdf_int_kind
    weight=this%proton(1)%pdf_int_weight(pdf_int_kinds(1))&
          *this%proton(2)%pdf_int_weight(pdf_int_kinds(2))
  end function pp_remnant_get_pdf_int_weights
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_pdf\_int\_weight}
\begin{Verbatim}
  elemental function pp_remnant_get_pdf_int_weight(this,kind1,kind2) result(weight)
    class(pp_remnant_type),intent(in)::this
    real(kind=double)::weight
    integer,intent(in)::kind1,kind2 ! pdf_int_kind
    weight=this%proton(1)%pdf_int_weight(kind1)&
          *this%proton(2)%pdf_int_weight(kind2)
  end function pp_remnant_get_pdf_int_weight
\end{Verbatim}

\TbpImp{pp\_remnant\_set\_pdf\_weight}
\begin{Verbatim}
  subroutine pp_remnant_set_pdf_weight(this,weights)
    class(pp_remnant_type),intent(inout)::this
    real(kind=double),dimension(10),intent(in)::weights
    this%proton(1)%pdf_int_weight=weights(1:5)
    this%proton(2)%pdf_int_weight=weights(6:10)
  end subroutine pp_remnant_set_pdf_weight
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_gev\_initial\_cme}
\begin{Verbatim}
  elemental function pp_remnant_get_gev_initial_cme(this) result(cme)
    class(pp_remnant_type),intent(in)::this
    real(kind=double)::cme
    cme=this%gev_initial_cme
  end function pp_remnant_get_gev_initial_cme
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_gev\_actual\_cme}
\begin{Verbatim}
  elemental function pp_remnant_get_gev_actual_cme(this) result(cme)
    class(pp_remnant_type),intent(in)::this
    real(kind=double)::cme
    cme=this%gev_initial_cme*this%X
  end function pp_remnant_get_gev_actual_cme
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_cme\_fraction}
\begin{Verbatim}
  elemental function pp_remnant_get_cme_fraction(this) result(cme)
    class(pp_remnant_type),intent(in)::this
    real(kind=double)::cme
    cme=this%X
  end function pp_remnant_get_cme_fraction
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_proton\_remnant\_momentum\_fractions}
\begin{Verbatim}
  pure function pp_remnant_get_proton_remnant_momentum_fractions(this) result(fractions)
    class(pp_remnant_type),intent(in)::this
    real(kind=double),dimension(2)::fractions
    fractions=[&
      this%proton(1)%get_momentum_fraction(),&
      this%proton(2)%get_momentum_fraction()]
  end function pp_remnant_get_proton_remnant_momentum_fractions
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_proton\_remnants}
\begin{Verbatim}
  subroutine pp_remnant_get_proton_remnants(this,proton1,proton2)
    class(pp_remnant_type),target,intent(in)::this
    class(proton_remnant_type),intent(out),pointer::proton1,proton2
    proton1=>this%proton(1)
    proton2=>this%proton(2)
  end subroutine pp_remnant_get_proton_remnants
\end{Verbatim}

\TbpImp{pp\_remnant\_get\_remnant\_parton\_flavor\_pdf\_arrays}
\begin{Verbatim}
  subroutine pp_remnant_get_remnant_parton_flavor_pdf_arrays&
    (this,GeV_scale,momentum1,momentum2,pdf1,pdf2)
    class(pp_remnant_type),intent(in)::this
    real(kind=double),intent(in)::GeV_scale,momentum1,momentum2
    real(kind=double),dimension(-6:6),intent(out)::pdf1,pdf2
    call this%proton(1)%parton_flavor_pdf_array(GeV_scale,momentum1,pdf1)
    call this%proton(2)%parton_flavor_pdf_array(GeV_scale,momentum2,pdf2)
  end subroutine pp_remnant_get_remnant_parton_flavor_pdf_arrays
\end{Verbatim}

  !overridden procedures

\TbpImp{pp\_remnant\_write\_to\_marker}
\begin{Verbatim}
  subroutine pp_remnant_write_to_marker(this,marker,status)
    class(pp_remnant_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("pp_remnant_type")
    call marker%mark("gev_initial_cme",this%gev_initial_cme)
    call marker%mark("X",this%X)
    call this%proton(1)%write_to_marker(marker,status)
    call this%proton(2)%write_to_marker(marker,status)
    call marker%mark_end("pp_remnant_type")
  end subroutine pp_remnant_write_to_marker
\end{Verbatim}

\TbpImp{pp\_remnant\_read\_from\_marker}
\begin{Verbatim}
  subroutine pp_remnant_read_from_marker(this,marker,status)
    class(pp_remnant_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    character(:),allocatable::name
    call marker%pick_begin("pp_remnant_type",status=status)
    call marker%pick("gev_initial_cme",this%gev_initial_cme,status)
    call marker%pick("X",this%X,status)
    call this%proton(1)%read_from_marker(marker,status)
    call this%proton(2)%read_from_marker(marker,status)
    call marker%pick_end("pp_remnant_type",status=status)
  end subroutine pp_remnant_read_from_marker
\end{Verbatim}

\TbpImp{pp\_remnant\_print\_to\_unit}
\begin{Verbatim}
  subroutine pp_remnant_print_to_unit(this,unit,parents,components,peers)
    class(pp_remnant_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of pp_remnant_type:")')
    write(unit,'("Initial center of mass energy: ",F10.3)')this%gev_initial_cme
    write(unit,'("Actual center of mass energy:  ",F10.3)')this%get_gev_actual_cme()
    write(unit,'("Total Momentum Fraction is:    ",F10.3)')this%X
    if(components>0)then
       write(unit,'("Proton 1:")')
       call this%proton(1)%print_to_unit(unit,parents,components-1,peers)
       write(unit,'("Proton 2:")')
       call this%proton(2)%print_to_unit(unit,parents,components-1,peers)
    end if
  end subroutine pp_remnant_print_to_unit
\end{Verbatim}
\TbpImp{pp\_remnant\_get\_type}
\begin{Verbatim}
  pure subroutine pp_remnant_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="pp_remnant_type")
  end subroutine pp_remnant_get_type
\end{Verbatim}
\MethodsNTB
\ProcImp{remnant\_dglap\_splitting\_gqq}
Der DGLAP-Splitting Kernel für ein $g\rightarrow q \overline{q}$ Splitting.
\begin{Verbatim}
  pure function remnant_dglap_splitting_gqq(z) result(p)
    real(kind=double)::p
    real(kind=double),intent(in)::z
    p=(z**2+(1-z)**2)/2D0
  end function remnant_dglap_splitting_gqq
\end{Verbatim}  
\ProcImp{remnant\_gluon\_pdf\_approx}
Die Approximation der Gluon-Momentum-PDF. p ist Parameter der Approximation, üblicherweise wird er auf 4 gesetzt. Die Wahl von p wird in \CompRef{muli\_remnant}{gluon\_exp} festgelegt.
\begin{Verbatim}
  pure function remnant_gluon_pdf_approx(x,p) result(g)
    real(kind=double)::g
    integer,intent(in)::p
    real(kind=double),intent(in)::x
    g=((1-x)**p)/x
  end function remnant_gluon_pdf_approx
\end{Verbatim}

\ProcImp{remnant\_norm\_0}
Der reziproke Normierungsfaktor der Quasivalenzverteilung für p=0. xs ist der Impulsanteil des Seequarks.
\begin{Verbatim}
  pure function remnant_norm_0(xs) result(c0)
    real(kind=double)::c0
    real(kind=double),intent(in)::xs
    c0=6*xs/(2-xs*(3-3*xs+2*xs**2))
  end function remnant_norm_0
\end{Verbatim}

\ProcImp{remnant\_norm\_1}
Der reziproke Normierungsfaktor der Quasivalenzverteilung für p=1. xs ist der Impulsanteil des Seequarks.
\begin{Verbatim}
  pure function remnant_norm_1(xs) result(c1)
    real(kind=double)::c1
    real(kind=double),intent(in)::xs
    c1=3*xs/(2-xs**2*(3-xs)+3*xs*log(xs))
  end function remnant_norm_1
\end{Verbatim}

\ProcImp{remnant\_norm\_4}
Der reziproke Normierungsfaktor der Quasivalenzverteilung für p=4. xs ist der Impulsanteil des Seequarks.
\begin{Verbatim}
  pure function remnant_norm_4(xs) result(c4)
    real(kind=double)::c4
    real(kind=double),intent(in)::xs
    real(kind=double)::y
    if((1D0-xs)>1D-3)then
       c4=3*xs/&
       (1 + 11*xs + 6*xs*log(xs) + 12*xs**3*log(xs) + 18*xs**2*log(xs)&
          + 9*xs**2 - 19*xs**3 - 2*xs**4)
    else
       y=1D0/(1D0-xs)
       c4=&
            &1130D0/11907D0&
            & -10D0 *y**5&
            & -40D0 *y**4/3D0&
            & -160D0*y**3/63D0&
            & +50D0 *y**2/189D0&
            & -565D0*y   /3969D0&
            & -186170D0*(1D0-xs)/2750517D0
    end if
  end function remnant_norm_4
\end{Verbatim}

\ProcImp{remnant\_norm}
Der reziproke Normierungsfaktor der Quasivalenzverteilung für p. xs ist der Impulsanteil des Seequarks.
\begin{Verbatim}
  pure function remnant_norm(xs,p) result(c)
    real(kind=double)::c
    real(kind=double),intent(in)::xs
    integer,intent(in)::p
    select case (p)
    case(0)
       c=remnant_norm_0(xs)
    case(1)
       c=remnant_norm_1(xs)
    case default
       c=remnant_norm_4(xs)
    end select
  end function remnant_norm
\end{Verbatim}

\ProcImp{remnant\_twin\_pdf\_p}
Der normierte, aber ungewichtete Quasivalenzbeitrag $f_{q^Q}(x,\overline{x})$ mit $xs\ =\overline{x}$.
\begin{Verbatim}
  pure function remnant_twin_pdf_p(x,xs,p) result(qc)
    real(kind=double)::qc
    real(kind=double),intent(in)::x,xs
    integer,intent(in)::p
    qc=remnant_norm(xs,p)*&
      remnant_gluon_pdf_approx(xs+x,p)*&
      remnant_dglap_splitting_gqq(xs/(xs+x))/(xs+x)
  end function remnant_twin_pdf_p
\end{Verbatim}
  
\ProcImp{remnant\_twin\_momentum\_4}
Der Impulsmittelwert des normierten, aber ungewichteten Quasivalenzbeitrags $\mean{f_{q^Q}}(\overline{x})=\int\!\der\!x\ x f_{q^Q}(x,\overline{x})$ mit $xs\ =\overline{x}$.
\begin{Verbatim}
  elemental function remnant_twin_momentum_4(xs) result(p)
    real(kind=double)::p
    real(kind=double),intent(in)::xs
    if(xs<0.99D0)then
       p=(-9*(-1+xs)*xs*(1+xs)*(5+xs*(24+xs))+12*xs*(1+2*xs)*(1+2*xs*(5+2*xs))*Log(xs))/&
            (8*(1+2*xs)*((-1+xs)*(1+xs*(10+xs))-6*xs*(1+xs)*Log(xs)))
    else
       p=(1-xs)/6-(5*(-1+xs)**2)/63+(5*(-1+xs)**3)/216
    end if
  end function remnant_twin_momentum_4
\end{Verbatim}

\ProcImp{gnuplot\_integrated\_pdf}
Zu Debuggingzwecken können die integrierten PDFs geplottet werden.
\begin{Verbatim}
  subroutine gnuplot_integrated_pdf(this,momentum_unit,parton_unit)
    class(proton_remnant_type),intent(in)::this
    integer,intent(in)::momentum_unit,parton_unit
    integer,parameter::x_grid=1000000
    integer,parameter::q_grid=100
    integer::n,m,mem
    real(kind=double)::x,q,dx,dq,overall_sum,xmin,xmax,q2min,q2max,qmin,qmax
    real(kind=double),dimension(-6:6)::sea_pdf,sea_momentum_pdf_sum,sea_parton_pdf_sum
    real(kind=double),dimension(2)::valence_pdf,valence_momentum_pdf_sum,valence_parton_pdf_sum
    real(kind=double),allocatable,dimension(:)::twin_momentum_pdf_sum
    class(parton_type),pointer::tmp_twin
    mem=1
    call GetXmin(mem,xmin)
    call GetXmax(mem,xmax)
    call GetQ2max(mem,q2max)
    call GetQ2min(mem,q2min)
    qmin=sqrt(q2min)
    qmax=sqrt(q2max)
    print *,"qmin=",qmin,"GeV"
    print *,"qmax=",qmax,"GeV"
    dx=(xmax-xmin)/x_grid
    dq=(qmax-qmin)/q_grid
    q=qmin+dq/2D0
    tmp_twin=>this%twin_partons%next
    n=0
    if(this%n_twins>0)then
       allocate(twin_momentum_pdf_sum(this%n_twins))
       do while(associated(tmp_twin))
          n=n+1
          twin_momentum_pdf_sum(n)=tmp_twin%momentum
          tmp_twin=>tmp_twin%next
       end do
    end if
    do m=1,q_grid
       valence_momentum_pdf_sum=[0D0,0D0]
       valence_parton_pdf_sum=[0D0,0D0]
       sea_momentum_pdf_sum=[0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0]    
       sea_parton_pdf_sum=[0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0,0D0]    
       x=xmin+dx/2D0
       do n=1,x_grid
          call this%parton_kind_pdf_array(Q,x,valence_pdf,sea_pdf)
          valence_parton_pdf_sum=valence_parton_pdf_sum+valence_pdf
          sea_parton_pdf_sum=sea_parton_pdf_sum+sea_pdf
          call this%momentum_kind_pdf_array(Q,x,valence_pdf,sea_pdf)
          valence_momentum_pdf_sum=valence_momentum_pdf_sum+valence_pdf
          sea_momentum_pdf_sum=sea_momentum_pdf_sum+sea_pdf
          x=x+dx
       end do
       valence_parton_pdf_sum=valence_parton_pdf_sum*dx
       sea_parton_pdf_sum=sea_parton_pdf_sum*dx
       valence_momentum_pdf_sum=valence_momentum_pdf_sum*dx
       sea_momentum_pdf_sum=sea_momentum_pdf_sum*dx
       if(this%n_twins>0)then
          write(momentum_unit,fmt=*)q,&
               sum(valence_momentum_pdf_sum)&
                +sum(sea_momentum_pdf_sum)&
                +sum(twin_momentum_pdf_sum),&
               valence_momentum_pdf_sum,&
               sea_momentum_pdf_sum,&
               twin_momentum_pdf_sum
       else
          write(momentum_unit,fmt=*)q,&
               sum(valence_momentum_pdf_sum)+sum(sea_momentum_pdf_sum),&
               valence_momentum_pdf_sum,&
               sea_momentum_pdf_sum
       end if
       write(parton_unit,fmt=*)q,&
            sum(valence_parton_pdf_sum)+sum(sea_parton_pdf_sum),&
            valence_parton_pdf_sum,&
            sea_parton_pdf_sum
       q=q+dq
    end do
  end subroutine gnuplot_integrated_pdf
\end{Verbatim}

