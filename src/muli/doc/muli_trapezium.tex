\Module{muli\_trapezium}
%\begin{figure}
%  \centering{\includegraphics{uml-module-tree-5.mps}}
%  \caption{\label{fig:\ThisModule:Types}Klassendiagramm des Moduls \ThisModule}
%\end{figure}
In dem Modul muli\_trapezium wird ein Datentyp muli\_trapezium\_type definiert, der eine affin-lineare Approximation von $\overline{S}_{\alpha\beta}(\pperp;s)$, $\mathcal{S}_{\alpha\beta}(\pperp;s)$, $exp[-\mathcal{S}_{\alpha\beta}(\pperp;s)]$ und einen Integrationsfehler für $\mathcal{S}_{\alpha\beta}(\pperp;s)$ für alle 16 Kombinationen von $\{\alpha,\beta\}$ für $\alpha,\beta\in \{g,s,v_d,v_u\}$ bereitstellt.

Weiterhin dir ein abstrakter Datentyp muli\_trapezium\_node\_class definiert, der mehrere Segmente vom Typ muli\_trapezium\_type zusammenfasst und somit eine Approximation der Wirkungsquerschnitte entsprechend der Trapezregel bereitstellt. Daher kommt auch der name des Moduls und der Datentypen.

Für die Auswertung dieser Approximation wird ein Datentyp muli\_trapezium\_tree\_type definiert, der Instanzen der Klasse muli\_trapezium\_node\_class zu einem Binärbaum zusammenstellt. Die Blätter dieses Binärbaums sind jeweils mit ihren linken und rechten Nachbarblättern verbunden, sodass man wahlweise in logarithmischer Zeit ein Blatt von der Wurzel her suchen kann oder die Blätter, sortiert nach $\pperp$ durchlaufen kann.

Für die Verbindungen unter den Blättern wird der Datentyp muli\_trapezium\_list\_type definiert, der auch ohne Binärbaum als Liste verwendet wird. Jedes Blatt eines Baums ist eine Instanz vom Typ muli\_trapezium\_list\_type.

Die Entscheidung für eine affin-lineare Approximation liegt an der Tatsache, dass höhere Polynome transzendente Funktionen im schlimmsten Fall so deutlich unterschätzen können, dass negative approximierte Funktionswerte bei positiven Funktionen auftreten können. In Abbildung \ref{fig:tra:parabel} ist das illustriert.
\begin{figure}
  \includegraphics{plots-1.mps}
  \caption{\label{fig:tra:parabel}Illustration einer quadratischen Approximation von exp(-x)/x. Die Parabel (blau) wird negativ, obwohl die Funktion (rot) streng positiv ist. Mit der Trapezregel kann das nicht passieren.}
\end{figure}
\section{Abhängigkeiten}
\use{muli\_basic}
\section{Parameter}
Für jedes Intervall $[x_l,x_r]$ der approximierten Funktionen $g(x)$ wird deren Funktionswert am rechten Rand r\_value=$f(x_r)$ und die Differenz der Funktionswerte d\_value=$f(x_r)-f(x_l)$ gespeichert. Entsprechend werden die Werte für die negative Stammfunktion (integral) und die daraus berechnete Wahscheinlichkeistfunktion (propability) gespeichert. Schließlich wird ein Integrationsfehler für die Stammfunktion gespeichert. In der Summe macht das value\_dimension=7 Werte, die pro Intervall gespeichert werden müssen. Es wird ein array mit value\_dimension Stellen allokiert, wobei die verschiedenen Werte an der Position *\_index abgelegt werden.
\begin{Verbatim}
  implicit none
  integer,private,parameter::\MC{value\_dimension}=7
  integer,private,parameter::\MC{r\_value\_index}=1
  integer,private,parameter::\MC{d\_value\_index=}2
  integer,private,parameter::\MC{r\_integral\_index}=3
  integer,private,parameter::\MC{d\_integral\_index}=4
  integer,private,parameter::\MC{r\_propability\_index}=5
  integer,private,parameter::\MC{d\_propability\_index}=6
  integer,private,parameter::\MC{error\_index}=7
\end{Verbatim}
\section{Derived Types}
\TypeDef{muli\_trapezium\_type}
\begin{Verbatim}
  type,\Extends{measurable\_class} :: muli_trapezium_type
\end{Verbatim}

dim ist die Dimension des Bildraums, also
$\overline{S}:\mathbb{R}\to\mathbb{R}^{\dim}$. dim ergibt sich aus der Zahl der Strati (=16) plus eins für die Summe über alle Strati. Die Summe wird in der Null-ten Komponente des Funktionswerte-Arrays gespeichert, damit die Strati nach der üblichen Konvention $[1..n]$ indiziert werden.

r\_position ist der obere Grenze des $\pperp$-Intervalls, d\_position ist die Intervallänge.

measure\_comp ist eine Maßzahl für jedes Intervall, nach der sie in dem Binärbaum sortiert werden. Die Blätter des Baumes sind dann eine geordnete Liste mit aufsteigendem measure\_comp. measure\_comp wird auf r\_position gesetzt.

values ist schließlich die Matrix der Funktionswerte für die verschiedenen Funktionen. Der erste, schnelle Index läuft über die Strati $\{0 .. \dim-1\}$, der zweite, langsame Index läuft über die Menge der Funktionen $\{$r\_value,d\_value,r\_integral,d\_integral,r\_propability,d\_propability,error$\}$
\begin{Verbatim}
     private
     integer::dim=0
     real(kind=double)::\TC{r\_position}=0D0
     real(kind=double)::\TC{d\_position}=0D0
     real(kind=double)::\TC{measure\_comp}=0D0
     real(kind=double),dimension(:,:),allocatable::\TC{values}
   contains
     \OverridesDeclaration{serializable\_class}
     procedure ::\TbpDec{write\_to\_marker}{muli\_trapezium\_write\_to\_marker}
     procedure ::\TbpDec{read\_from\_marker}{muli\_trapezium\_read\_from\_marker}
     procedure ::\TbpDec{print\_to\_unit}{muli\_trapezium\_print\_to\_unit}
     procedure,nopass ::\TbpDec{get\_type}{muli\_trapezium\_get\_type}
     procedure,nopass ::\TbpDec{verify\_type}{muli\_trapezium\_verify\_type}
     \OverridesDeclaration{measurable\_class}
     procedure::\TbpDec{measure}{muli\_trapezium\_measure}
     \OriginalDeclaration
     ! init/deinit
     procedure::\TbpDec{initialize}{muli\_trapezium\_initialize}
     ! components    
     procedure,public::\TbpDec{get\_dimension}{muli\_trapezium\_get\_dimension}
     procedure,public::\TbpDec{get\_l\_position}{muli\_trapezium\_get\_l\_position}
     procedure,public::\TbpDec{get\_r\_position}{muli\_trapezium\_get\_r\_position}
     procedure,public::\TbpDec{get\_d\_position}{muli\_trapezium\_get\_d\_position}
     procedure,public::\TbpDec{get\_l\_value\_array}{muli\_trapezium\_get\_l\_value\_array}
     procedure,public::\TbpDec{get\_l\_value\_element}{muli\_trapezium\_get\_l\_value\_element}
     procedure,public::\TbpDec{get\_r\_value\_array}{muli\_trapezium\_get\_r\_value\_array}
     procedure,public::\TbpDec{get\_r\_value\_element}{muli\_trapezium\_get\_r\_value\_element}
     procedure,public::\TbpDec{get\_d\_value\_array}{muli\_trapezium\_get\_d\_value\_array}
     procedure,public::\TbpDec{get\_d\_value\_element}{muli\_trapezium\_get\_d\_value\_element}
     procedure,public::\TbpDec{get\_l\_integral\_array}{muli\_trapezium\_get\_l\_integral\_array}
     procedure,public::\TbpDec{get\_l\_integral\_element}{muli\_trapezium\_get\_l\_integral\_element}
     procedure,public::\TbpDec{get\_r\_integral\_array}{muli\_trapezium\_get\_r\_integral\_array}
     procedure,public::\TbpDec{get\_r\_integral\_element}{muli\_trapezium\_get\_r\_integral\_element}
     procedure,public::\TbpDec{get\_d\_integral\_array}{muli\_trapezium\_get\_d\_integral\_array}
     procedure,public::\TbpDec{get\_d\_integral\_element}{muli\_trapezium\_get\_d\_integral\_element}
     procedure,public::\TbpDec{get\_l\_propability\_element}{muli\_trapezium\_get\_l\_propability\_element}
     procedure,public::\TbpDec{get\_l\_propability\_array}{muli\_trapezium\_get\_l\_propability\_array}
     procedure,public::\TbpDec{get\_r\_propability\_element}{muli\_trapezium\_get\_r\_propability\_element}
     procedure,public::\TbpDec{get\_r\_propability\_array}{muli\_trapezium\_get\_r\_propability\_array}
     procedure,public::\TbpDec{get\_d\_propability\_element}{muli\_trapezium\_get\_d\_propability\_element}
     procedure,public::\TbpDec{get\_d\_propability\_array}{muli\_trapezium\_get\_d\_propability\_array}
     procedure,public::\TbpDec{get\_error}{muli\_trapezium\_get\_error}
     procedure,public::\TbpDec{get\_error\_sum}{muli\_trapezium\_get\_error\_sum}
     procedure,public::\TbpDec{get\_integral\_sum}{muli\_trapezium\_get\_integral\_sum}
     generic,public::\TbpGen{get\_l\_value}{get\_l\_value\_array,get\_l\_value\_element}
     generic,public::\TbpGen{get\_r\_value}{get\_r\_value\_array,get\_r\_value\_element}
     generic,public::\TbpGen{get\_d\_value}{get\_d\_value\_array,get\_d\_value\_element}
     generic,public::\TbpGen{get\_l\_integral}{get\_l\_integral\_array,get\_l\_integral\_element}
     generic,public::\TbpGen{get\_r\_integral}{get\_r\_integral\_array,get\_r\_integral\_element}
     generic,public::\TbpGen{get\_d\_integral}{get\_d\_integral\_array,get\_d\_integral\_element}
     generic,public::\TbpGen{get\_l\_propability}{get\_l\_propability\_array,get\_l\_propability\_element}
     generic,public::\TbpGen{get\_r\_propability}{get\_r\_propability\_array,get\_r\_propability\_element}
     generic,public::\TbpGen{get\_d\_propability}{get\_d\_propability\_array,get\_d\_propability\_element}
     ! interpolations
     procedure,public::\TbpDec{get\_value\_at\_position}{muli\_trapezium\_get\_value\_at\_position}
     procedure::\TbpDec{set\_r\_value}{muli\_trapezium\_set\_r\_value}
     procedure::\TbpDec{set\_d\_value}{muli\_trapezium\_set\_d\_value}
     procedure::\TbpDec{set\_r\_integral}{muli\_trapezium\_set\_r\_integral}
     procedure::\TbpDec{set\_d\_integral}{muli\_trapezium\_set\_d\_integral}
     procedure::\TbpDec{set\_r\_propability}{muli\_trapezium\_set\_r\_propability}
     procedure::\TbpDec{set\_d\_propability}{muli\_trapezium\_set\_d\_propability}
     procedure::\TbpDec{set\_error}{muli\_trapezium\_set\_error}
     ! tests
     procedure,public::\TbpDec{is\_left\_of}{muli\_trapezium\_is\_left\_of}
     procedure,public::\TbpDec{includes}{muli\_trapezium\_includes}
     ! convert
     procedure ::\TbpDec{to\_node}{muli\_trapezium\_to\_node}
     procedure ::\TbpDec{sum\_up}{muli\_trapezium\_sum\_up}
     ! approximation
     procedure ::\TbpDec{approx\_value}{muli\_trapezium\_approx\_value}
     procedure ::\TbpDec{approx\_value\_n}{muli\_trapezium\_approx\_value\_n}
     procedure ::\TbpDec{approx\_integral}{muli\_trapezium\_approx\_integral}
     procedure ::\TbpDec{approx\_integral\_n}{muli\_trapezium\_approx\_integral\_n}
     procedure ::\TbpDec{approx\_propability}{muli\_trapezium\_approx\_propability}
     procedure ::\TbpDec{approx\_propability\_n}{muli\_trapezium\_approx\_propability\_n}
     procedure ::\TbpDec{approx\_position\_by\_integral}{muli\_trapezium\_approx\_position\_by\_integral}
     procedure ::\TbpDec{split}{muli\_trapezium\_split}
     procedure ::\TbpDec{update}{muli\_trapezium\_update}
  end type muli_trapezium_type
\end{Verbatim}
\TypeDef{muli\_trapezium\_node\_class}
muli\_trapezium\_node\_class ist eine abstake Klasse, die durch die Komonenten left und right wahlweise ein Binärbaum oder eine doppelt-verknüpften Liste sein kann. Welche dieser Ausprägungen vorliegt, hängt von dem Datentyp ab. Jede Instanz der Klasse muli\_trapezium\_node\_class ist entweder vom Typ \TypeRef{muli\_trapezium\_tree\_type} oder vom Typ \TypeRef{muli\_trapezium\_list\_type}. Hier werden alle Methoden definiert, die eine Liste, und ein Baum gemein haben.
\begin{Verbatim}
  type,Extends{muli\_trapezium\_type},abstract :: muli_trapezium_node_class
\end{Verbatim}
\paragraph{Komponenten}
\begin{Verbatim}
     private
     class(muli_trapezium_node_class), pointer :: \TC{left} => null()
     class(muli_trapezium_node_class), pointer :: \TC{right} => null()
\end{Verbatim}
\paragraph{Methoden}
\begin{Verbatim}
   contains
!     private
     \OverridesDeclaration{measurable\_class}
     procedure,public ::\TbpDec{deserialize\_from\_marker}{muli\_trapezium\_node\_deserialize\_from\_marker}
     \OriginalDeclaration
     procedure(muli_trapezium_append_interface),deferred,public::append
     procedure(muli_trapezium_final_interface),deferred,public :: finalize
     procedure,public ::\TbpDec{nullify}{muli\_trapezium\_node\_nullify}
     procedure,public ::\TbpDec{get\_left}{muli\_trapezium\_node\_get\_left}
     procedure,public ::\TbpDec{get\_right}{muli\_trapezium\_node\_get\_right}
     procedure,public ::\TbpDec{get\_leftmost}{muli\_trapezium\_node\_get\_leftmost}
     procedure,public ::\TbpDec{get\_rightmost}{muli\_trapezium\_node\_get\_rightmost}
     procedure,public ::\TbpDec{decide\_by\_value}{muli\_trapezium\_node\_decide\_by\_value}
     procedure,public ::\TbpDec{decide\_by\_position}{muli\_trapezium\_node\_decide\_by\_position}
     procedure,public ::\TbpDec{decide\_decreasing}{muli\_trapezium\_node\_decide\_decreasing}
     procedure,public :: muli_trapezium_node_to_tree
     procedure,private::\TbpDec{untangle}{muli\_trapezium\_node\_untangle}
     procedure,public ::\TbpDec{apply}{muli\_trapezium\_node\_apply}
     generic,public::\TbpGen{decide}{decide\_by\_value,decide\_by\_position}
  end type muli_trapezium_node_class
\end{Verbatim}
\TypeDef{muli\_trapezium\_tree\_type}
muli\_trapezium\_node\_class in der Ausprägung "Binärbaum".
\begin{Verbatim}
  type,extends(muli_trapezium_node_class) :: muli_trapezium_tree_type
\end{Verbatim}
\paragraph{Komponenten}

down ist ein Zeiger auf das rechteste Blatt von dem linken Nachfolger. Da das Maß eines Blatts gleich r\_position des Blatt ist, gibt down\%measure() die obere Grenze des Intervalls des linken Unterbaums wieder. Bei einer Suche nach dem Blatt, das $\pperp$ enthält, wird also per $\pperp\overset{?}{<}$ down\%measure() entschieden, ob wir nach links oder nach rechts absteigen.
\begin{Verbatim}
     class(muli_trapezium_node_class), pointer :: \TC{down} => null()
\end{Verbatim}
\paragraph{Methoden}
\begin{Verbatim}
   contains
     \OverridesDeclaration{measurable\_class}
     procedure ::\TbpDec{write\_to\_marker}{muli\_trapezium\_tree\_write\_to\_marker}
     procedure ::\TbpDec{read\_from\_marker}{muli\_trapezium\_tree\_read\_from\_marker}
     procedure ::\TbpDec{print\_to\_unit}{muli\_trapezium\_tree\_print\_to\_unit}
     procedure,nopass ::\TbpDec{get\_type}{muli\_trapezium\_tree\_get\_type}
     procedure,nopass ::\TbpDec{verify\_type}{muli\_trapezium\_tree\_verify\_type}
     \OverridesDeclaration{muli\_trapezium\_node\_class}
     procedure,public ::\TbpDec{nullify}{muli\_trapezium\_tree\_nullify}
     procedure,public ::\TbpDec{finalize}{muli\_trapezium\_tree\_finalize}
     procedure,public ::\TbpDec{decide\_by\_value}{muli\_trapezium\_tree\_decide\_by\_value}
     procedure,public ::\TbpDec{decide\_by\_position}{muli\_trapezium\_tree\_decide\_by\_position}
     procedure,public ::\TbpDec{decide\_decreasing}{muli\_trapezium\_tree\_decide\_decreasing}
     \OriginalDeclaration
     procedure,public ::\TbpDec{get\_left\_list}{muli\_trapezium\_tree\_get\_left\_list}
     procedure,public ::\TbpDec{get\_right\_list}{muli\_trapezium\_tree\_get\_right\_list}
     procedure,public ::\TbpDec{find\_by\_value}{muli\_trapezium\_tree\_find\_by\_value}
     procedure,public ::\TbpDec{find\_by\_position}{muli\_trapezium\_tree\_find\_by\_position}
     procedure,public ::\TbpDec{find\_decreasing}{muli\_trapezium\_tree\_find\_decreasing}
     procedure,public ::\TbpDec{approx\_by\_integral}{muli\_trapezium\_tree\_approx\_by\_integral}
     procedure,public ::\TbpDec{approx\_by\_propability}{muli\_trapezium\_tree\_approx\_by\_propability}
     procedure,public ::\TbpDec{to\_tree}{muli\_trapezium\_tree\_to\_tree}
     generic,public::\TbpGen{find}{find\_by\_value,find\_by\_position}
     procedure::\TbpDec{append}{muli\_trapezium\_tree\_append}
     procedure::\TbpDec{gnuplot}{muli\_trapezium\_tree\_gnuplot}
  end type muli_trapezium_tree_type
\end{Verbatim}
\TypeDef{muli\_trapezium\_list\_type}
muli\_trapezium\_node\_class in der Ausprägung "Liste".
\begin{Verbatim}
  type,extends(muli_trapezium_node_class) :: muli_trapezium_list_type
\end{Verbatim}
\paragraph{Methoden}
\begin{Verbatim}
   contains
     \OverridesDeclaration{measurable\_class}
     procedure ::\TbpDec{write\_to\_marker}{muli\_trapezium\_list\_write\_to\_marker}
     procedure ::\TbpDec{read\_from\_marker}{muli\_trapezium\_list\_read\_from\_marker}
     procedure ::\TbpDec{read\_target\_from\_marker}{muli\_trapezium\_list\_read\_target\_from\_marker}
     procedure ::\TbpDec{print\_to\_unit}{muli\_trapezium\_list\_print\_to\_unit}
     procedure,nopass ::\TbpDec{get\_type}{muli\_trapezium\_list\_get\_type}
     procedure,nopass ::\TbpDec{verify\_type}{muli\_trapezium\_list\_verify\_type}
     \OriginalDeclaration
     procedure,public ::\TbpDec{finalize}{muli\_trapezium\_list\_finalize}
     procedure,public ::\TbpDec{insert\_right\_a}{muli\_trapezium\_list\_insert\_right\_a}
     generic,public ::\TbpGen{insert\_right}{insert\_right\_a!,insert\_right\_b}
     procedure,public ::\TbpDec{insert\_left\_a}{muli\_trapezium\_list\_insert\_left\_a}
     generic,public ::\TbpGen{insert\_left}{insert\_left\_a!,insert\_left\_b}
     procedure::\TbpDec{append}{muli\_trapezium\_list\_append}
     procedure,public ::\TbpDec{to\_tree}{muli\_trapezium\_list\_to\_tree}
     procedure,public ::\TbpDec{gnuplot}{muli\_trapezium\_list\_gnuplot}
     procedure,public ::\TbpDec{integrate}{muli\_trapezium\_list\_integrate}
     procedure,public ::\TbpDec{check}{muli\_trapezium\_list\_check}
     procedure,public ::\TbpDec{apply}{muli\_trapezium\_list\_apply}
  end type muli_trapezium_list_type
\end{Verbatim}
\section{Schnittstellen}
\begin{Verbatim}
  abstract interface
     subroutine muli_trapezium_append_interface(this,right)
       import muli_trapezium_node_class
       class(muli_trapezium_node_class),intent(inout),target :: this,right
     end subroutine muli_trapezium_append_interface
     subroutine muli_trapezium_final_interface(this)
       import muli_trapezium_node_class
       class(muli_trapezium_node_class),intent(inout) :: this
     end subroutine muli_trapezium_final_interface
     end interface
   \end{Verbatim}
   \Methods
   \MethodsFor{qcd\_2\_2\_type}
   \OverridesSection{serializable\_class}
   \TbpImp{muli\_trapezium\_write\_to\_marker}
   \begin{Verbatim}
  subroutine muli_trapezium_write_to_marker (this,marker,status)
    class(muli_trapezium_type), intent(in) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    ! local variables
    integer::dim
    call marker%mark_begin("muli_trapezium_type")
    call marker%mark("dim",this%dim)
    call marker%mark("r_position",this%r_position)
    call marker%mark("d_position",this%d_position)
    if(allocated(this%values))then
       call marker%mark("values",this%values)
    else
       call marker%mark_null("values")
    end if
    call marker%mark_end("muli_trapezium_type")
  end subroutine muli_trapezium_write_to_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_read\_from\_marker}
\begin{Verbatim}
  subroutine muli_trapezium_read_from_marker (this,marker,status)
    class(muli_trapezium_type), intent(out) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    ! local variables
    integer::dim
    call marker%pick_begin("muli_trapezium_type",status=status)
    call marker%pick("dim",this%dim,status)
    call marker%pick("r_position",this%r_position,status)
    call marker%pick("d_position",this%d_position,status)
    if(allocated(this%values))deallocate(this%values)
    call marker%verify_nothing("values",status)
    if(status==serialize_ok)then
       allocate(this%values(0:this%dim-1,7))
       call marker%pick("values",this%values,status)
    end if
    call marker%pick_end("muli_trapezium_type",status)
  end subroutine muli_trapezium_read_from_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_print\_to\_unit}
\begin{Verbatim}
  subroutine muli_trapezium_print_to_unit(this,unit,parents,components,peers)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of muli_trapezium_type:")')
    write(unit,fmt=*)"Dimension:        ",this%dim
    write(unit,fmt=*)"Right position:   ",this%r_position
    write(unit,fmt=*)"Position step:    ",this%d_position
    if(allocated(this%values))then    
       if(components>0)then          
          write(unit,fmt=*)"Right values:     ",muli_trapezium_get_r_value_array(this)
          write(unit,fmt=*)"Value step:       ",this%get_d_value()
          write(unit,fmt=*)"Right integrals:  ",this%get_r_integral()
          write(unit,fmt=*)"Integral step:    ",this%get_d_integral()
          write(unit,fmt=*)"Right propabilities:",this%get_r_propability()
          write(unit,fmt=*)"Propability step: ",this%get_d_propability()
          write(unit,fmt=*)"Errors:           ",this%get_error()
       else
          write(unit,fmt=*)"Values are allocated."
       end if
    else
       write(unit,fmt=*)"Values are not allocated."
    end if
  end subroutine muli_trapezium_print_to_unit
\end{Verbatim}
\TbpImp{muli\_trapezium\_get\_type}
\begin{Verbatim}
  pure subroutine muli_trapezium_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="muli_trapezium_type")
  end subroutine muli_trapezium_get_type
\end{Verbatim}
\TbpImp{muli\_trapezium\_verify\_type}
\begin{Verbatim}
  elemental logical function muli_trapezium_verify_type(type) result(match)
    character(*),intent(in)::type
    match=type=="muli_trapezium_type"
  end function muli_trapezium_verify_type
\end{Verbatim}
\OverridesSection{measurable\_type}
\TbpImp{muli\_trapezium\_measure}
\begin{Verbatim}
  elemental function muli_trapezium_measure(this)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::muli_trapezium_measure
    muli_trapezium_measure=this%measure_comp
  end function muli_trapezium_measure
\end{Verbatim}
\OriginalSection{muli\_trapezium\_type}
\TbpImp{muli\_trapezium\_initialize}
\begin{Verbatim}
  subroutine muli_trapezium_initialize(this,dim,r_position,d_position)
    class(muli_trapezium_type),intent(inout)::this
    integer,intent(in)::dim
    real(kind=double),intent(in)::r_position,d_position
    integer::dim1,dim2
    this%dim=dim
    this%r_position=r_position
    this%d_position=d_position
    if(allocated(this%values))deallocate(this%values)
    allocate(this%values(0:dim-1,value_dimension))
    do dim2=1,value_dimension-1
       do dim1=0,dim-1
          this%values(dim1,dim2)=0D0
       end do       
    end do
    do dim1=0,dim-1
       this%values(dim1,value_dimension)=huge(1D0)
    end do
    this%measure_comp=huge(1D0)
  end subroutine muli_trapezium_initialize
\end{Verbatim}

!!! components !!!

\TbpImp{muli\_trapezium\_get\_dimension}
\begin{Verbatim}
  elemental function muli_trapezium_get_dimension(this) result(dim)
    class(muli_trapezium_type),intent(in)::this
    integer::dim
    dim=this%dim
  end function muli_trapezium_get_dimension
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_position}
\begin{Verbatim}
  pure function muli_trapezium_get_l_position(this) result(pos)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::pos
    pos=this%r_position-this%d_position
  end function muli_trapezium_get_l_position
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_position}
\begin{Verbatim}
  pure function muli_trapezium_get_r_position(this) result(pos)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::pos
    pos=this%r_position
  end function muli_trapezium_get_r_position
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_position}
\begin{Verbatim}
  pure function muli_trapezium_get_d_position(this) result(pos)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::pos
    pos=this%d_position
  end function muli_trapezium_get_d_position
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_error\_sum}
\begin{Verbatim}
  pure function muli_trapezium_get_error_sum(this) result(error)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::error
    error=sum(this%values(0:this%dim-1,error_index))
  end function muli_trapezium_get_error_sum
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_integral\_sum}
\begin{Verbatim}
  pure function muli_trapezium_get_integral_sum(this) result(error)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double)::error
    error=sum(this%values(0:this%dim-1,d_integral_index))
  end function muli_trapezium_get_integral_sum
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_value\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_l_value_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_value_index)-this%values(set,d_value_index)
  end function muli_trapezium_get_l_value_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_value\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_l_value_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,r_value_index)-this%values(0:this%dim-1,d_value_index)
  end function muli_trapezium_get_l_value_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_value\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_r_value_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_value_index)
  end function muli_trapezium_get_r_value_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_value\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_r_value_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,r_value_index)
  end function muli_trapezium_get_r_value_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_value\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_d_value_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,d_value_index)
  end function muli_trapezium_get_d_value_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_value\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_d_value_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,d_value_index)
  end function muli_trapezium_get_d_value_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_integral\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_l_integral_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_integral_index)-this%values(set,d_integral_index)
  end function muli_trapezium_get_l_integral_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_integral\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_l_integral_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,r_integral_index)-this%values(0:this%dim-1,d_integral_index)
  end function muli_trapezium_get_l_integral_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_integral\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_r_integral_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_integral_index)
  end function muli_trapezium_get_r_integral_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_integral\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_r_integral_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,r_integral_index)
  end function muli_trapezium_get_r_integral_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_integral\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_d_integral_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,d_integral_index)
  end function muli_trapezium_get_d_integral_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_integral\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_d_integral_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,d_integral_index)
  end function muli_trapezium_get_d_integral_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_propability\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_l_propability_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_propability_index)-this%values(set,d_propability_index)
  end function muli_trapezium_get_l_propability_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_l\_propability\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_l_propability_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=&
      this%values(0:this%dim-1,r_propability_index)&
     -this%values(0:this%dim-1,d_propability_index)
  end function muli_trapezium_get_l_propability_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_propability\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_r_propability_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,r_propability_index)
  end function muli_trapezium_get_r_propability_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_r\_propability\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_r_propability_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,r_propability_index)
  end function muli_trapezium_get_r_propability_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_propability\_array}
\begin{Verbatim}
  pure function muli_trapezium_get_d_propability_array(this) result(subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::subarray
    subarray=this%values(0:this%dim-1,d_propability_index)
  end function muli_trapezium_get_d_propability_array
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_d\_propability\_element}
\begin{Verbatim}
  pure function muli_trapezium_get_d_propability_element(this,set) result(element)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::set
    real(kind=double)::element
    element=this%values(set,d_propability_index)
  end function muli_trapezium_get_d_propability_element
\end{Verbatim}

\TbpImp{muli\_trapezium\_get\_error}
\begin{Verbatim}
  pure function muli_trapezium_get_error(this) result(error)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),dimension(this%dim)::error
    error=this%values(0:this%dim-1,error_index)
  end function muli_trapezium_get_error
\end{Verbatim}

  ! interpolation
  
\TbpImp{muli\_trapezium\_get\_value\_at\_position}
\begin{Verbatim}
  subroutine muli_trapezium_get_value_at_position(this,pos,subarray)
    class(muli_trapezium_type),intent(in)::this
    real(kind=double),intent(in)::pos
    real(kind=double),dimension(this%dim),intent(out)::subarray
    subarray=this%get_r_value_array()-this%get_d_value()*this%d_position/(this%r_position-pos)
  end subroutine muli_trapezium_get_value_at_position
\end{Verbatim}

  ! write access

\TbpImp{muli\_trapezium\_set\_r\_value}
\begin{Verbatim}
  subroutine muli_trapezium_set_r_value(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,r_value_index)=subarray
  end subroutine muli_trapezium_set_r_value
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_d\_value}
\begin{Verbatim}
  subroutine muli_trapezium_set_d_value(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,d_value_index)=subarray
  end subroutine muli_trapezium_set_d_value
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_r\_integral}
\begin{Verbatim}
  subroutine muli_trapezium_set_r_integral(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,r_integral_index)=subarray
  end subroutine muli_trapezium_set_r_integral
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_d\_integral}
\begin{Verbatim}
  subroutine muli_trapezium_set_d_integral(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,d_integral_index)=subarray
  end subroutine muli_trapezium_set_d_integral
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_r\_propability}
\begin{Verbatim}
  subroutine muli_trapezium_set_r_propability(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,r_propability_index)=subarray
  end subroutine muli_trapezium_set_r_propability
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_d\_propability}
\begin{Verbatim}
  subroutine muli_trapezium_set_d_propability(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,d_propability_index)=subarray
  end subroutine muli_trapezium_set_d_propability
\end{Verbatim}

\TbpImp{muli\_trapezium\_set\_error}
\begin{Verbatim}
  subroutine muli_trapezium_set_error(this,subarray)
    class(muli_trapezium_type),intent(inout)::this
    real(kind=double),intent(in),dimension(0:this%dim-1)::subarray
    this%values(0:this%dim-1,error_index)=subarray
    this%measure_comp=sum(subarray)
  end subroutine muli_trapezium_set_error
\end{Verbatim}

  ! tests

\TbpImp{muli\_trapezium\_is\_left\_of}
\begin{Verbatim}
  pure function muli_trapezium_is_left_of(this,that) result(is_left)
    logical::is_left
    class(muli_trapezium_type),intent(in)::this,that
    is_left=this%r_position<=that%r_position!-that%d_position
  end function muli_trapezium_is_left_of
\end{Verbatim}

\TbpImp{muli\_trapezium\_includes}
\begin{Verbatim}
  elemental logical function muli_trapezium_includes&
    (this,dim,position,value,integral,propability) result(includes)
    class(muli_trapezium_type),intent(in)::this
    integer,intent(in)::dim
    real(kind=double),intent(in),optional::position,value,integral,propability
    includes=.true.
    if(present(position))then
       if(this%get_l_position()>position.or.position>=this%get_r_position())&
         includes=.false.
    end if
    if(present(value))then
       if(this%get_l_value(dim)>value.or.value>=this%get_r_value(dim))&
         includes=.false.
    end if
    if(present(integral))then
       if(this%get_l_integral(dim)>integral.or.integral>=this%get_r_integral(dim))&
         includes=.false.
    end if
    if(present(propability))then
       if(this%get_l_propability(dim)>propability.or.propability>=this%get_r_propability(dim))&
         includes=.false.
    end if    
  end function muli_trapezium_includes
\end{Verbatim}

\TbpImp{muli\_trapezium\_update}
\begin{Verbatim}
  subroutine muli_trapezium_update(this)
    class(muli_trapezium_type),intent(inout) :: this
    real(kind=double),dimension(:),allocatable :: int
    allocate(int(0:this%dim-1),source=this%get_d_integral())
    call this%set_d_integral(-this%d_position*(this%get_r_value_array()-this%get_d_value()/2D0))
    call this%set_error(abs(this%get_d_integral()-int))
!    print('(11(D20.10))'),this%get_d_integral()
  end subroutine muli_trapezium_update
\end{Verbatim}

\TbpImp{muli\_trapezium\_split}
\begin{Verbatim}
  subroutine muli_trapezium_split(this,c_value,c_position,new_node)
    class(muli_trapezium_type),intent(inout) :: this
    real(kind=double),intent(in) :: c_position
    real(kind=double),intent(in),dimension(this%dim) :: c_value
    class(muli_trapezium_type),intent(out),pointer :: new_node
    real(kind=double) :: ndpr,ndpl
    real(kind=double),dimension(:),allocatable::ov,edv
    ndpr=this%r_position-c_position
    ndpl=this%d_position-ndpr
    allocate(ov(0:this%dim-1),&
      source=this%get_r_value_array()-ndpr*this%get_d_value()/this%d_position)
    allocate(edv(0:this%dim-1),source=c_value-ov)
    allocate(new_node)
    call new_node%initialize(dim=this%dim,&
         &r_position=c_position,&
         &d_position=ndpl)
    call new_node%set_r_value(c_value)
    call new_node%set_d_value(this%get_d_value()+c_value-this%get_r_value_array())
    call new_node%set_d_integral(ndpl*(this%get_d_value()-this%get_r_value_array()-c_value)/2D0)
    call new_node%set_error(abs((edv*ndpl)/2D0))
    !new_node%measure_comp=sum(abs((edv*ndpl)/2D0))
    this%d_position=ndpr
    call this%set_d_value(this%get_r_value_array()-c_value)
    call this%set_d_integral(-(ndpr*(this%get_r_value_array()+c_value)/2D0))
    call this%set_error(abs(edv*ndpr/2D0))
    !this%measure_comp=sum(abs(edv*ndpr/2D0))
!    print ('("muli_trapezium_split: new errors:")')
!    print ('(E14.7)'),this%get_error()
!    print ('(E14.7)'),new_node%get_error()
!    print('(11(D20.10))'),new_node%get_d_integral()
!    print('(11(D20.10))'),this%get_d_integral()
  end subroutine muli_trapezium_split
\end{Verbatim}

\TbpImp{muli\_trapezium\_approx\_value}
\begin{Verbatim}
  pure function muli_trapezium_approx_value(this,x) result(val)
    ! returns the values at x
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double),dimension(this%dim) :: val
    real(kind=double), intent(in) :: x
    val = this%get_r_value_array()&
          +(x-this%r_position)*this%get_d_value()/this%d_position
  end function muli_trapezium_approx_value
\end{Verbatim}
\TbpImp{muli\_trapezium\_approx\_value\_n}
\begin{Verbatim}
  elemental function muli_trapezium_approx_value_n(this,x,n) result(val)
    ! returns the value at x
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double)::val
    real(kind=double), intent(in) :: x
    integer,intent(in)::n
    val = this%get_r_value_element(n)&
          +(x-this%r_position)*this%get_d_value_element(n)/this%d_position
  end function muli_trapezium_approx_value_n
\end{Verbatim}
\TbpImp{muli\_trapezium\_approx\_integral}
\begin{Verbatim}
  pure function muli_trapezium_approx_integral(this,x)
    ! returns the integral from x to r_position
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double),dimension(this%dim) :: muli_trapezium_approx_integral
    real(kind=double), intent(in) :: x
    muli_trapezium_approx_integral = &
         &this%get_r_integral()+&
         &((this%r_position-x)*&
         &(-this%get_d_value()*(this%r_position-x)&
           +2*this%d_position*this%get_r_value_array()))/&
         &(2*this%d_position)
  end function muli_trapezium_approx_integral
\end{Verbatim}

\TbpImp{muli\_trapezium\_approx\_integral\_n}
\begin{Verbatim}
  elemental function muli_trapezium_approx_integral_n(this,x,n) result(val)
    ! returns the integral from x to r_position
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double)::val
    real(kind=double), intent(in) :: x
    integer,intent(in)::n
    val = &
         &this%get_r_integral_element(n)+&
         &((this%r_position-x)*&
         &(-this%get_d_value_element(n)*(this%r_position-x)&
           +2*this%d_position*this%get_r_value_element(n)))/&
         &(2*this%d_position)
  end function muli_trapezium_approx_integral_n
\end{Verbatim}

\TbpImp{muli\_trapezium\_approx\_propability}
\begin{Verbatim}
   pure function muli_trapezium_approx_propability(this,x) result(prop)
    ! returns the vlaues at x
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double),dimension(this%dim) :: prop
    real(kind=double), intent(in) :: x
    prop=exp(-this%approx_integral(x))
  end function muli_trapezium_approx_propability
\end{Verbatim}

\TbpImp{muli\_trapezium\_approx\_propability\_n}
\begin{Verbatim}
  elemental function muli_trapezium_approx_propability_n(this,x,n) result(val)
    ! returns the integral from x to r_position
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double)::val
    real(kind=double), intent(in) :: x
    integer,intent(in)::n
    val = exp(-this%approx_integral_n(x,n))
  end function muli_trapezium_approx_propability_n
\end{Verbatim}
\TbpImp{muli\_trapezium\_approx\_position\_by\_integral}  
\begin{Verbatim}
  elemental function muli_trapezium_approx_position_by_integral(this,dim,int) result(val)
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double)::val
    integer,intent(in)::dim
    real(kind=double),intent(in)::int
    real(kind=double)::dpdv    
    dpdv=(this%d_position/this%values(dim,d_value_index))
    val=this%r_position-dpdv*&
         (this%values(dim,r_value_index)-&
           sqrt(((this%values(dim,r_integral_index)-int)*2D0/dpdv)&
                  +this%values(dim,r_value_index)**2))
  end function muli_trapezium_approx_position_by_integral
\end{Verbatim}

\TbpImp{muli\_trapezium\_to\_node}
\begin{Verbatim}
  subroutine muli_trapezium_to_node(this,value,list,tree)
    class(muli_trapezium_type),intent(in) :: this
    real(kind=double),intent(in) :: value  
    class(muli_trapezium_list_type),optional,pointer,intent(out) :: list
    class(muli_trapezium_tree_type),optional,pointer,intent(out) :: tree
    if(present(list))then
       allocate(list)
       list%dim=this%dim
       list%r_position=this%r_position
       list%d_position=this%d_position
       allocate(list%values(0:this%dim-1,value_dimension),source=this%values)
    end if
    if(present(tree))then
       allocate(tree)
       tree%dim=this%dim
       tree%r_position=this%r_position
       tree%d_position=this%d_position
       allocate(tree%values(0:this%dim-1,value_dimension),source=this%values)
    end if    
  end subroutine muli_trapezium_to_node
\end{Verbatim}

\TbpImp{muli\_trapezium\_sum\_up}
\begin{Verbatim}
  subroutine muli_trapezium_sum_up(this)
    class(muli_trapezium_type),intent(inout) :: this
    integer::i
    if(allocated(this%values))then
       do i=1,7
          this%values(0,i)=sum(this%values(1:this%dim-1,i))
       end do
    end if
  end subroutine muli_trapezium_sum_up
\end{Verbatim}
\MethodsFor{muli\_trapezium\_node\_class}
\TbpImp{muli\_trapezium\_node\_deserialize\_from\_marker}
\begin{Verbatim}
  subroutine muli_trapezium_node_deserialize_from_marker(this,name,marker)
    class(muli_trapezium_node_class), intent(out) :: this
    character(*),intent(in)::name
    class(marker_type),intent(inout)::marker
    integer(kind=dik)::status
    class(serializable_class),pointer::ser
    allocate(muli_trapezium_tree_type::ser)
    call marker%push_reference(ser)
    allocate(muli_trapezium_list_type::ser)
    call marker%push_reference(ser)
    call serializable_deserialize_from_marker(this,name,marker)
    call marker%pop_reference(ser)
    deallocate(ser)
    call marker%pop_reference(ser)
    deallocate(ser)
  end subroutine muli_trapezium_node_deserialize_from_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_nullify}
\begin{Verbatim}
  subroutine muli_trapezium_node_nullify(this)
    class(muli_trapezium_node_class),intent(out) :: this
    nullify(this%left)
    nullify(this%right)
  end subroutine muli_trapezium_node_nullify
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_get\_left}
\begin{Verbatim}
  subroutine muli_trapezium_node_get_left(this,left)
    class(muli_trapezium_node_class),intent(in) :: this
    class(muli_trapezium_node_class),pointer,intent(out) :: left
    left=>this%left
  end subroutine muli_trapezium_node_get_left
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_get\_right}
\begin{Verbatim}
  subroutine muli_trapezium_node_get_right(this,right)
    class(muli_trapezium_node_class),intent(in) :: this
    class(muli_trapezium_node_class),pointer,intent(out) :: right
    right=>this%right
  end subroutine muli_trapezium_node_get_right
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_get\_leftmost}
\begin{Verbatim}
  subroutine muli_trapezium_node_get_leftmost(this,node)
    class(muli_trapezium_node_class),intent(in) :: this
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if (associated(this%left)) then
       node=>this%left
       do while (associated(node%left))
          node=>node%left
       end do
    else
       nullify(node)
    end if
  end subroutine muli_trapezium_node_get_leftmost
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_get\_rightmost}
\begin{Verbatim}
  subroutine muli_trapezium_node_get_rightmost(this,right)
    class(muli_trapezium_node_class),intent(in) :: this
    class(muli_trapezium_node_class),pointer,intent(out) :: right
    if (associated(this%right)) then
       right=>this%right
       do while (associated(right%right))
          right=>right%right
       end do
    else
       nullify(right)
    end if
  end subroutine muli_trapezium_node_get_rightmost
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_decide\_by\_value}
\begin{Verbatim}
  subroutine muli_trapezium_node_decide_by_value(this,value,dim,record,node)
    class(muli_trapezium_node_class),intent(in) :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::record,dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%values(dim,record)>value)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_node_decide_by_value
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_decide\_by\_position}
\begin{Verbatim}
  subroutine muli_trapezium_node_decide_by_position(this,position,node)
    class(muli_trapezium_node_class),intent(in) :: this
    real(kind=double),intent(in)::position
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%r_position>position)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_node_decide_by_position
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_decide\_decreasing}
\begin{Verbatim}
  subroutine muli_trapezium_node_decide_decreasing(this,value,dim,record,node)
    class(muli_trapezium_node_class),intent(in) :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::record,dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%values(dim,record)<=value)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_node_decide_decreasing
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_untangle}
\begin{Verbatim}
  subroutine muli_trapezium_node_untangle(this)
    class(muli_trapezium_node_class),intent(inout),target :: this
    if(associated(this%left))then
       if(associated(this%left%right,this))then
          nullify(this%left%right)
          nullify(this%left)
       end if
    end if    
  end subroutine muli_trapezium_node_untangle
\end{Verbatim}

\TbpImp{muli\_trapezium\_node\_apply}
\begin{Verbatim}
  recursive subroutine muli_trapezium_node_apply(this,proc)
    class(muli_trapezium_node_class),intent(inout) :: this
    interface
       subroutine proc(this)
         import muli_trapezium_node_class
         class(muli_trapezium_node_class),intent(inout) :: this
       end subroutine proc
    end interface
    if(associated(this%right))call proc(this%right)
    if(associated(this%left))call proc(this%left)
    call proc(this)
  end subroutine muli_trapezium_node_apply
\end{Verbatim}
\MethodsFor{muli\_trapezium\_list\_type}
\TbpImp{muli\_trapezium\_list\_write\_to\_marker}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_write_to_marker (this,marker,status)
    class(muli_trapezium_list_type), intent(in) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status 
    ! local variables
    class(serializable_class),pointer::ser
    call marker%mark_begin("muli_trapezium_list_type")
    call muli_trapezium_write_to_marker(this,marker,status)   
    ser=>this%right
    call marker%mark_pointer("right",ser)
    call marker%mark_end("muli_trapezium_list_type")
  end subroutine muli_trapezium_list_write_to_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_read\_from\_marker}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_read_from_marker (this,marker,status)
    class(muli_trapezium_list_type), intent(out) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    print *,"muli_trapezium_list_read_from_marker:"
    print *,"You cannot deserialize a list with this subroutine."
    print *,"Use muli_trapezium_list_read_target_from_marker instead."    
  end subroutine muli_trapezium_list_read_from_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_read\_target\_from\_marker}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_read_target_from_marker (this,marker,status)
    class(muli_trapezium_list_type),target,intent(out) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    ! local variables
    class(serializable_class),pointer::ser
    call marker%pick_begin("muli_trapezium_list_type",status=status)
    call muli_trapezium_read_from_marker(this,marker,status)
    call marker%pick_pointer("right",ser)
    if(associated(ser))then
       select type(ser)
       class is (muli_trapezium_list_type)
          this%right=>ser
          ser%left=>this
       class default
          nullify(this%right)
          print *,"muli_trapezium_list_read_target_from_marker:"
          print *,"Unexpected type for right component."
       end select
    else
       nullify(this%right)
    end if
    call marker%pick_end("muli_trapezium_list_type",status)
  end subroutine muli_trapezium_list_read_target_from_marker
\end{Verbatim}
  
\TbpImp{muli\_trapezium\_list\_print\_to\_unit}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_print_to_unit&
    (this,unit,parents,components,peers)
    class(muli_trapezium_list_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    class(serializable_class),pointer::ser
    if(parents>0)call muli_trapezium_print_to_unit(this,unit,parents-1,components,peers)
    ser=>this%left
    call serialize_print_peer_pointer(ser,unit,-one,-one,-one,"LEFT")
    ser=>this%right
    call serialize_print_peer_pointer(ser,unit,parents,components,peers,"RIGHT")
  end subroutine muli_trapezium_list_print_to_unit
\end{Verbatim}
\TbpImp{muli\_trapezium\_list\_get\_type}
\begin{Verbatim}
  pure subroutine muli_trapezium_list_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="muli_trapezium_list_type")
  end subroutine muli_trapezium_list_get_type
\end{Verbatim}
\TbpImp{muli\_trapezium\_list\_verify\_type}
\begin{Verbatim}
  elemental logical function muli_trapezium_list_verify_type(type) result(match)
    character(*),intent(in)::type
    match=type=="muli_trapezium_list_type"
  end function muli_trapezium_list_verify_type
\end{Verbatim}
\TbpImp{muli\_trapezium\_list\_finalize}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_finalize(this)
    class(muli_trapezium_list_type),intent(inout)::this
    if (associated(this%right)) then
       call this%right%finalize()
       deallocate(this%right)
    end if
    this%dim=0
  end subroutine muli_trapezium_list_finalize
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_insert\_left\_a}
\begin{Verbatim}
  subroutine muli_trapezium_list_insert_left_a(this,value,content,new_node)
    class(muli_trapezium_list_type),intent(inout),target :: this
    real(kind=double),intent(in) :: value
    class(muli_trapezium_type),intent(in) :: content
    class(muli_trapezium_list_type),pointer,intent(out) :: new_node
    call content%to_node(value,list=new_node)
    new_node%right=>this
    if(associated(this%left))then
       new_node%left=>this%left
       this%left%right=>new_node
    else
       nullify(new_node%left)
    end if
    this%left=>new_node
  end subroutine muli_trapezium_list_insert_left_a
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_insert\_right\_a}
\begin{Verbatim}
  subroutine muli_trapezium_list_insert_right_a(this,value,content,new_node)
    class(muli_trapezium_list_type),intent(inout),target :: this
    real(kind=double),intent(in) :: value
    class(muli_trapezium_type),intent(in) :: content
    class(muli_trapezium_list_type),pointer,intent(out) :: new_node
    class(muli_trapezium_list_type),pointer :: tmp_list
    call content%to_node(value,list=tmp_list)
    if(associated(this%right))then
       this%right%left=>tmp_list
       tmp_list%right=>this%right
    else
       nullify(tmp_list%right)
    end if
    this%right=>tmp_list
    tmp_list%left=>this
    new_node=>tmp_list
  end subroutine muli_trapezium_list_insert_right_a
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_append}
\begin{Verbatim}
  subroutine muli_trapezium_list_append(this,right)
    class(muli_trapezium_list_type),intent(inout),target :: this
    class(muli_trapezium_node_class),intent(inout),target :: right
    this%right=>right
    right%left=>this
  end subroutine muli_trapezium_list_append
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_to\_tree}
\begin{Verbatim}
  subroutine muli_trapezium_list_to_tree(this,out_tree)
    class(muli_trapezium_list_type),target,intent(in) :: this
    class(muli_trapezium_tree_type),intent(out) :: out_tree
    type(muli_trapezium_tree_type),target :: do_list
    class(muli_trapezium_node_class),pointer :: this_entry,do_list_entry,node
    class(muli_trapezium_tree_type),pointer :: tree1,tree2
    integer :: ite,log,n_deep,n_leaves
    n_leaves=0
    this_entry => this
    count: do while(associated(this_entry))
       n_leaves=n_leaves+1
       this_entry=>this_entry%right
    end do count
    call ilog2(n_leaves,log,n_deep)
    this_entry => this
    do_list_entry => do_list
    deep: do ite=0,n_deep-1
       allocate(tree1)
       tree1%down=>this_entry%right
       allocate(tree2)
       tree2%down=>this_entry
       tree2%left=>this_entry
       tree2%right=>this_entry%right
       tree1%left=>tree2
       this_entry => this_entry%right%right
       do_list_entry%right=>tree1
       do_list_entry=>tree1
    end do deep
    rest: do while(associated(this_entry))
       allocate(tree1)
       tree1%down=>this_entry
       tree1%left=>this_entry
       do_list_entry%right => tree1
       do_list_entry => tree1
       this_entry => this_entry%right
       ite=ite+1
    end do rest
    tree: do while(ite>2)
       do_list_entry => do_list%right
       node=>do_list
       level: do while(associated(do_list_entry))
          node%right=>do_list_entry%right
          node=>do_list_entry%right
          do_list_entry%right=>node%left
          node%left=>do_list_entry
          do_list_entry=>node%right
          ite=ite-1
       end do level
    end do tree
    node=>do_list%right
    select type(node)
    type is (muli_trapezium_tree_type)
       call node%to_tree(out_tree)
    class default
       print *,"muli_trapezium_list_to_tree"
       print *,"unexpeted type for do_list%right"
    end select
    out_tree%right=>out_tree%right%left
    if(allocated(out_tree%values))then
       deallocate(out_tree%values)
    end if
    deallocate(do_list%right%right)
    deallocate(do_list%right)
  end subroutine muli_trapezium_list_to_tree
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_gnuplot}
\begin{Verbatim}
  subroutine muli_trapezium_list_gnuplot(this,dir)
    class(muli_trapezium_list_type),intent(in),target :: this
    character(len=*),intent(in)::dir
    character(len=*),parameter::val_file="/value.plot"
    character(len=*),parameter::int_file="/integral.plot"
    character(len=*),parameter::err_file="/integral_error.plot"
    character(len=*),parameter::pro_file="/propability.plot"
    character(len=*),parameter::den_file="/density.plot"
    character(len=*),parameter::fmt='(E20.10)'
    class(muli_trapezium_node_class),pointer::list
    integer::val_unit,err_unit,int_unit,pro_unit,den_unit
    list=>this
    call generate_unit(val_unit,100,1000)
    open(val_unit,file=dir//val_file)
    call generate_unit(int_unit,100,1000)
    open(int_unit,file=dir//int_file)
    call generate_unit(err_unit,100,1000)
    open(err_unit,file=dir//err_file)
    call generate_unit(pro_unit,100,1000)
    open(pro_unit,file=dir//pro_file)
    call generate_unit(den_unit,100,1000)
    open(den_unit,file=dir//den_file)
    do while (associated(list))
!       print *,list%r_position,list%get_r_value()
       write(val_unit,fmt,advance='NO')list%r_position
       call write_array(val_unit,list%get_r_value_array(),fmt)
       write(int_unit,fmt,advance='NO')list%r_position
       call write_array(int_unit,list%get_r_integral(),fmt)
       write(err_unit,fmt,advance='NO')list%r_position
       call write_array(err_unit,list%get_error(),fmt)
       write(pro_unit,fmt,advance='NO')list%r_position
       call write_array(pro_unit,list%get_r_propability(),fmt)
       write(den_unit,fmt,advance='NO')list%r_position
       call write_array(den_unit,list%get_r_propability()*list%get_r_value_array(),fmt)
       list=>list%right
    end do
    close(val_unit)
    close(int_unit)
    close(err_unit)
    close(pro_unit)
    close(den_unit)
    contains
      subroutine write_array(unit,array,form)
        integer,intent(in)::unit
        real(kind=double),dimension(:),intent(in)::array
        character(len=*),intent(in)::form
        integer::n
        do n=1,size(array)
           write(unit,form,ADVANCE='NO')array(n)
           flush(unit)
        end do
        write(unit,'("")')
      end subroutine write_array
  end subroutine muli_trapezium_list_gnuplot
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_integrate}
\begin{Verbatim}
  subroutine muli_trapezium_list_integrate(this,integral_sum,error_sum)
    class(muli_trapezium_list_type),intent(in),target :: this
    real(kind=double),intent(out)::error_sum,integral_sum
    real(kind=double),dimension(:),allocatable::integral
    class(muli_trapezium_node_class),pointer :: node
    allocate(integral(0:this%dim-1))
    call this%get_rightmost(node)
    integral=0D0
    integral_sum=0D0
    error_sum=0D0
    integrate: do while(associated(node))
       node%values(1,r_value_index)=sum(node%values(1:this%dim-1,r_value_index))
       node%values(1,d_value_index)=sum(node%values(1:this%dim-1,d_value_index))
       node%values(1,error_index)=sum(node%values(1:this%dim-1,error_index))
       error_sum=error_sum+node%values(1,error_index)
       call node%set_d_integral(&
         node%get_d_position()*(node%get_d_value()/2D0-node%get_r_value_array()))
       call node%set_r_propability(exp(-integral))
       call node%set_r_integral(integral)
       integral=integral-node%get_d_integral()
       call node%set_d_propability(node%get_r_propability()-exp(-integral))
       call node%get_left(node)
    end do integrate
    integral_sum=integral(1)
  end subroutine muli_trapezium_list_integrate
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_check}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_check(this)
    class(muli_trapezium_list_type),intent(in),target :: this
    class(muli_trapezium_node_class),pointer::tn,next
    real(kind=double),parameter::eps=1d-10
    logical::test
    if(associated(this%right))then
       next=>this%right
       test=(this%r_position.le.this%right%get_l_position()+eps)
       print *,"position check:  ",test
       if(.not.test)then
          call this%print_parents()
          call next%print_parents()
       end if
       select type (next)
       class is (muli_trapezium_list_type)
          tn=>this
          print *,"structure check: ",associated(tn,next%left)
          print *,"class check:    T"
          call next%check()
       class default
          print *,"class check:    F"
       end select
    else
       print *,"end of list at ",this%r_position
    end if
  end subroutine muli_trapezium_list_check
\end{Verbatim}

\TbpImp{muli\_trapezium\_list\_apply}
\begin{Verbatim}
  recursive subroutine muli_trapezium_list_apply(this,proc)
    class(muli_trapezium_list_type),intent(inout) :: this
    interface
       subroutine proc(this)
         import muli_trapezium_node_class
         class(muli_trapezium_node_class),intent(inout) :: this
       end subroutine proc
    end interface
    if(associated(this%right))call this%right%apply(proc)
    call proc(this)
  end subroutine muli_trapezium_list_apply
\end{Verbatim}
\MethodsFor{muli\_trapezium\_tree\_type}
\TbpImp{muli\_trapezium\_tree\_write\_to\_marker}
\begin{Verbatim}
  subroutine muli_trapezium_tree_write_to_marker (this,marker,status)
    class(muli_trapezium_tree_type), intent(in) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    ! local variables
    class(muli_trapezium_list_type),pointer::list
    class(serializable_class),pointer::ser
    call marker%mark_begin("muli_trapezium_tree_type")
    call this%get_left_list(list)
    ser=>list
    call marker%mark_pointer("list",ser)
    call marker%mark_end("muli_trapezium_tree_type")
  end subroutine muli_trapezium_tree_write_to_marker
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_read\_from\_marker}
\begin{Verbatim}
  subroutine muli_trapezium_tree_read_from_marker (this,marker,status)
    class(muli_trapezium_tree_type), intent(out) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    ! local variables
    class(serializable_class),pointer::ser
    call marker%pick_begin("muli_trapezium_tree_type",status=status)
    call marker%pick_pointer("list",ser)
    if(associated(ser))then
       select type(ser)
       class is (muli_trapezium_list_type)
          call ser%to_tree(this)
       class default
          nullify(this%left)
          nullify(this%right)
          nullify(this%down)
       end select
    else
       nullify(this%left)
       nullify(this%right)
       nullify(this%down)
    end if
    call marker%pick_end("muli_trapezium_tree_type",status)
  end subroutine muli_trapezium_tree_read_from_marker
\end{Verbatim}
  
\TbpImp{muli\_trapezium\_tree\_print\_to\_unit}
\begin{Verbatim}
  recursive subroutine muli_trapezium_tree_print_to_unit(this,unit,parents,components,peers)
    class(muli_trapezium_tree_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    class(serializable_class),pointer::ser
    if(parents>0)call muli_trapezium_print_to_unit(this,unit,parents-1,components,peers)
    ser=>this%down
    call serialize_print_peer_pointer(ser,unit,one,zero,one,"DOWN")
    if(associated(this%left))then
       select type(sertmp=>this%left)
       class is(muli_trapezium_list_type)
          ser=>sertmp
          call serialize_print_peer_pointer(ser,unit,parents,components,zero,"LEFT")
       class default
          call serialize_print_peer_pointer(ser,unit,parents,components,peers,"LEFT")
       end select
    else
       write(unit,fmt=*)"Left is not associated."
    end if
    if(associated(this%right))then
       select type(sertmp=>this%right)
       class is(muli_trapezium_list_type)
          ser=>sertmp
          call serialize_print_peer_pointer(ser,unit,parents,components,zero,"RIGHT")
       class default
          call serialize_print_peer_pointer(ser,unit,parents,components,peers,"RIGHT")
       end select
    else
       write(unit,fmt=*)"Right is not associated."
    end if
  end subroutine muli_trapezium_tree_print_to_unit
\end{Verbatim}
\TbpImp{muli\_trapezium\_tree\_get\_type}
\begin{Verbatim}
  pure subroutine muli_trapezium_tree_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="muli_trapezium_tree_type")
  end subroutine muli_trapezium_tree_get_type
\end{Verbatim}
\TbpImp{muli\_trapezium\_tree\_verify\_type}
\begin{Verbatim}
  elemental logical function muli_trapezium_tree_verify_type(type) result(match)
    character(*),intent(in)::type
    match=type=="muli_trapezium_tree_type"
  end function muli_trapezium_tree_verify_type
\end{Verbatim}
\OverridesSection{muli\_trapezium\_node\_class}
\TbpImp{muli\_trapezium\_tree\_nullify}
\begin{Verbatim}
  subroutine muli_trapezium_tree_nullify(this)
    class(muli_trapezium_tree_type),intent(out) :: this
    call muli_trapezium_node_nullify(this)
    nullify(this%down)
  end subroutine muli_trapezium_tree_nullify
\end{Verbatim}
  
\TbpImp{muli\_trapezium\_tree\_get\_left\_list}
\begin{Verbatim}
  subroutine muli_trapezium_tree_get_left_list(this,list)
    class(muli_trapezium_tree_type),intent(in) :: this
    class(muli_trapezium_list_type),pointer,intent(out) :: list
    class(muli_trapezium_node_class),pointer::node
    call this%get_leftmost(node)
    if(associated(node))then
       select type(node)
       class is (muli_trapezium_list_type)
          list=>node
       class default
          nullify(list)
       end select
    else
       nullify(list)
    end if
  end subroutine muli_trapezium_tree_get_left_list
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_get\_right\_list}
\begin{Verbatim}
  subroutine muli_trapezium_tree_get_right_list(this,list)
    class(muli_trapezium_tree_type),intent(in) :: this
    class(muli_trapezium_list_type),pointer,intent(out) :: list
    class(muli_trapezium_node_class),pointer::node
    call this%get_rightmost(node)
    if(associated(node))then
       select type(node)
       class is (muli_trapezium_list_type)
          list=>node
       class default
          nullify(list)
       end select
    else
       nullify(list) 
    end if
  end subroutine muli_trapezium_tree_get_right_list
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_finalize}
\begin{Verbatim}
  recursive subroutine muli_trapezium_tree_finalize(this)
    class(muli_trapezium_tree_type),intent(inout) :: this
    if (associated(this%right)) then
       call this%right%untangle()
       call this%right%finalize()
       deallocate(this%right)
    end if
    if (associated(this%left)) then
       call this%left%untangle()
       call this%left%finalize()
       deallocate(this%left)
    end if
    this%dim=0
  end subroutine muli_trapezium_tree_finalize
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_decide\_by\_value}
\begin{Verbatim}
  subroutine muli_trapezium_tree_decide_by_value(this,value,dim,record,node)
    class(muli_trapezium_tree_type),intent(in) :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::record,dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%down%values(dim,record)>value)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_tree_decide_by_value
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_decide\_by\_position}
\begin{Verbatim}
  subroutine muli_trapezium_tree_decide_by_position(this,position,node)
    class(muli_trapezium_tree_type),intent(in) :: this
    real(kind=double),intent(in)::position
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%down%r_position>position)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_tree_decide_by_position
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_decide\_decreasing}
\begin{Verbatim}
  subroutine muli_trapezium_tree_decide_decreasing(this,value,dim,record,node)
    class(muli_trapezium_tree_type),intent(in) :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::record,dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    if(this%down%values(dim,record)<=value)then
       node=>this%left
    else
       node=>this%right
    end if
  end subroutine muli_trapezium_tree_decide_decreasing
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_find\_by\_value}
\begin{Verbatim}
  subroutine muli_trapezium_tree_find_by_value(this,value,dim,record,node)
    class(muli_trapezium_tree_type),intent(in),target :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::record,dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    node=>this
    do while(.not.allocated(node%values))
       call node%decide(value,dim,record,node)
    end do
  end subroutine muli_trapezium_tree_find_by_value
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_find\_by\_position}
\begin{Verbatim}
  subroutine muli_trapezium_tree_find_by_position(this,position,node)
    class(muli_trapezium_tree_type),intent(in),target :: this
    real(kind=double),intent(in)::position
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    node=>this
    do while(.not.allocated(node%values))
       call node%decide(position,node)
    end do
  end subroutine muli_trapezium_tree_find_by_position
\end{Verbatim}
\TbpImp{muli\_trapezium\_tree\_find\_decreasing}
\begin{Verbatim}
  subroutine muli_trapezium_tree_find_decreasing(this,value,dim,node)
    class(muli_trapezium_tree_type),intent(in),target :: this
    real(kind=double),intent(in)::value
    integer,intent(in)::dim
    class(muli_trapezium_node_class),pointer,intent(out) :: node
    node=>this
    do while(.not.allocated(node%values))
       call node%decide_decreasing(value,dim,r_integral_index,node)
    end do
  end subroutine muli_trapezium_tree_find_decreasing
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_approx\_by\_integral}
\begin{Verbatim}
  subroutine muli_trapezium_tree_approx_by_integral&
    (this,int,dim,in_range,position,value,integral,content)
    class(muli_trapezium_tree_type),intent(in),target :: this
    real(kind=double),intent(in) :: int
    integer,intent(in)::dim
    logical,intent(out) :: in_range
    class(muli_trapezium_node_class),pointer,intent(out),optional :: content
    real(kind=double),intent(out),optional :: position,value,integral
    integer::i
    real(kind=double) :: DINT!,l_prop,r_prop,d_prop
    real(kind=double)::RP,DP,RV,DV,RI!FC = gfortran
    class(muli_trapezium_node_class),pointer :: node
    node=>this
    do while(.not.allocated(node%values))
       call node%decide_decreasing(INT,dim,r_integral_index,node)
    end do
    if(   int<=node%values(dim,r_integral_index)-node%values(dim,d_integral_index)&
         &.and.&
         &int>=node%values(dim,r_integral_index))then
       in_range=.true.
         RP=node%r_position!FC = gfortran
         DP=node%d_position!FC = gfortran
         RV=node%values(dim,r_value_index)!FC = gfortran
         DV=node%values(dim,d_value_index)!FC = gfortran
         RI=node%values(dim,r_integral_index)!FC = gfortran
         if (present(position)) then
            DINT=(ri-int)*2D0*dv/dp
            position=rp-(dp/dv)*(rv-sqrt(dint+rv**2))
         end if
         if (present(value)) then
            value=Sqrt(dp*(-2*dv*int + 2*dv*ri + dp*rv**2))/dp
         end if
         if (present(integral)) then
            integral=int
         end if
         if (present(content)) then
            content=>node
         end if
    else
       in_range=.false.
    end if
  end subroutine muli_trapezium_tree_approx_by_integral
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_approx\_by\_propability}
\begin{Verbatim}
  subroutine muli_trapezium_tree_approx_by_propability&
    (this,prop,dim,in_range,position,value,integral,content)
    class(muli_trapezium_tree_type),intent(in),target :: this
    real(kind=double),intent(in) :: prop
    integer,intent(in)::dim
    logical,intent(out) :: in_range
    class(muli_trapezium_node_class),pointer,intent(out),optional :: content
    real(kind=double),intent(out),optional :: position,value,integral
    integer::i
    real(kind=double) :: INT,DINT,l_prop,r_prop,d_prop
    class(muli_trapezium_node_class),pointer :: node
    if(0D0<prop.and.prop<1D0)then
       node=>this
       INT=-log(prop)
       call muli_trapezium_tree_approx_by_integral&
         (this,int,dim,in_range,position,value,integral,content)
    else
       in_range=.false.
    end if
  end subroutine muli_trapezium_tree_approx_by_propability
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_to\_tree}
\begin{Verbatim}
  subroutine muli_trapezium_tree_to_tree(this,out_tree)
    class(muli_trapezium_tree_type),intent(in) :: this
    class(muli_trapezium_tree_type),intent(out) :: out_tree
    out_tree%left=>this%left
    out_tree%right=>this%right
    out_tree%down=>this%down
  end subroutine muli_trapezium_tree_to_tree
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_append}
\begin{Verbatim}
  subroutine muli_trapezium_tree_append(this,right)
    class(muli_trapezium_tree_type),intent(inout),target :: this
    class(muli_trapezium_node_class),intent(inout),target :: right
    print ('("muli_trapezium_tree_append: Not yet implemented.")')
  end subroutine muli_trapezium_tree_append
\end{Verbatim}

\TbpImp{muli\_trapezium\_tree\_gnuplot}
\begin{Verbatim}
  subroutine muli_trapezium_tree_gnuplot(this,dir)
    class(muli_trapezium_tree_type),intent(in) :: this
    character(len=*),intent(in)::dir
    class(muli_trapezium_list_type),pointer::list
    call this%get_left_list(list)
    call list%gnuplot(dir)
  end subroutine muli_trapezium_tree_gnuplot
\end{Verbatim}

