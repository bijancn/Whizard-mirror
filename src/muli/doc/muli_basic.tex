\Module{muli\_basic}
\section{AbhÃ¤ngigkeiten}
\useintrinsic{iso\_fortran\_env}
\usenodep{kinds}
\usenodep{iso\_varying\_string, string\_t=>varying\_string}
\section{Parameter}
\begin{Verbatim}
  ! bitmodel parameters
  integer,public,parameter::\MC{drk}=double
  integer,public,parameter::\MC{dik}=i64
  integer(kind=dik),public,parameter::\MC{one}=int(1,kind=dik)
  integer(kind=dik),public,parameter::\MC{zero}=int(0,kind=dik)
  ! serialization parameters
  integer(kind=dik),public,parameter::\MC{serialize\_page\_size}=1024
  integer(kind=dik),public,parameter::\MC{serialize\_ok}=0000
  integer(kind=dik),public,parameter::\MC{serialize\_syntax\_error}=1001
  integer(kind=dik),public,parameter::\MC{serialize\_wrong\_tag}=1002
  integer(kind=dik),public,parameter::\MC{serialize\_wrong\_id}=1003
  integer(kind=dik),public,parameter::\MC{serialize\_wrong\_type}=1004
  integer(kind=dik),public,parameter::\MC{serialize\_wrong\_name}=1005
  integer(kind=dik),public,parameter::\MC{serialize\_no\_target}=1006
  integer(kind=dik),public,parameter::\MC{serialize\_no\_pointer}=1007
  integer(kind=dik),public,parameter::\MC{serialize\_wrong\_action}=1008
  integer(kind=dik),public,parameter::\MC{serialize\_unexpected\_content}=1009
  integer(kind=dik),public,parameter::\MC{serialize\_null}=1010
  integer(kind=dik),public,parameter::\MC{serialize\_nothing}=1011
  logical,public,parameter::\MC{serialize\_default\_indent}=.true.
  logical,public,parameter::\MC{serialize\_default\_line\_break}=.true.
  logical,public,parameter::\MC{serialize\_default\_asynchronous}=.false.
  ! private components
  integer(kind=dik),private::\MC{last\_id}=0
  character(len=*),private,parameter::\MC{serialize\_integer\_characters}="-0123456789"
\end{Verbatim}
\section{Derived Types}
\TypeDef{serializable\_class}
\begin{Verbatim}
  type,public,abstract::serializable_class
   contains
     procedure(ser_write_if),deferred::write_to_marker
     procedure(ser_read_if),deferred::read_from_marker
     procedure(ser_unit),deferred::print_to_unit
     procedure(ser_type),nopass,deferred::get_type
     procedure,nopass::\TbpDec{verify\_type}{serializable\_verify\_type}
     procedure::\TbpDec{read\_target\_from\_marker}{serializable\_read\_target\_from\_marker}
     procedure::\TbpDec{write\_type}{serializable\_write\_type}
     procedure::\TbpDec{print}{serializable\_print}
     procedure::\TbpDec{print\_error}{serializable\_print\_error}
     procedure::\TbpDec{print\_all}{serializable\_print\_all}
     procedure::\TbpDec{print\_little}{serializable\_print\_little}
     procedure::\TbpDec{print\_parents}{serializable\_print\_parents}
     procedure::\TbpDec{print\_components}{serializable\_print\_components}
     procedure::\TbpDec{print\_peers}{serializable\_print\_peers}
     procedure::\TbpDec{serialize\_to\_file}{serializable\_serialize\_to\_file}
     procedure::\TbpDec{serialize\_to\_unit}{serializable\_serialize\_to\_unit}
     procedure::\TbpDec{serialize\_to\_marker}{serializable\_serialize\_to\_marker}
     procedure::\TbpDec{deserialize\_from\_file}{serializable\_deserialize\_from\_file}
     procedure::\TbpDec{deserialize\_from\_unit}{serializable\_deserialize\_from\_unit}
     procedure::\TbpDec{deserialize\_from\_marker}{serializable\_deserialize\_from\_marker}
     generic::\TbpGen{serialize}{serialize\_to\_file,serialize\_to\_unit,serialize\_to\_marker}
     generic::\TbpGen{deserialize}{deserialize\_from\_file,deserialize\_from\_unit,deserialize\_from\_marker}
  end type serializable_class
\end{Verbatim}
\TypeDef{measurable\_class}
\begin{Verbatim}
  type,public,abstract,extends(serializable_class)::measurable_class
   contains
     procedure(measure_int),public,deferred::measure
  end type measurable_class
\end{Verbatim}
\TypeDef{identified\_type}
\begin{Verbatim}
  type,public,\Extends{serializable\_class}::identified_type 
     private
     integer(kind=dik)::\TC{id}
     type(string_t)::\TC{name}
   contains
     ! overridden serializable_class procedures
     procedure,public::\TbpDec{write\_to\_marker}{identified\_write\_to\_marker}
     procedure,public::\TbpDec{read\_from\_marker}{identified\_read\_from\_marker}
     procedure,public::\TbpDec{print\_to\_unit}{identified\_print\_to\_unit}
     procedure,public,nopass::\TbpDec{get\_type}{identified\_get\_type}
     procedure,nopass::\TbpDec{verify\_type}{identified\_verify\_type}
     ! new procedures
     procedure,public::\TbpDecS{identified\_initialize}
     procedure,public::\TbpDec{get\_id}{identified\_get\_id}
     procedure,public::\TbpDec{get\_name}{identified\_get\_name}
     generic,public::\TbpGen{initialize}{identified\_initialize}
  end type identified_type
\end{Verbatim}
\TypeDef{unique\_type}
\begin{Verbatim}
  type,public,\Extends{identified\_type}::unique_type
     private
     integer(kind=dik)::\TC{unique\_id}
   contains
     ! overridden serializable_class procedures
     procedure,public,nopass::\TbpDec{get\_type}{unique\_get\_type}
     procedure,nopass::\TbpDec{verify\_type}{unique\_verify\_type}
     procedure,public::\TbpDec{write\_to\_marker}{unique\_write\_to\_marker}
     procedure,public::\TbpDec{read\_from\_marker}{unique\_read\_from\_marker}
     procedure,public::\TbpDec{print\_to\_unit}{unique\_print\_to\_unit}
     ! overridden identified_type procedures
     procedure,public::\TbpDec{identified\_initialize}{unique\_initialize}
     ! new procedures
     procedure,public::\TbpDec{get\_unique\_id}{unique\_get\_unique\_id}
  end type unique_type
\end{Verbatim}
\TypeDef{serializable\_ref\_type}
\begin{Verbatim}
  type,private::serializable_ref_type
     private
     integer(kind=dik)::\TC{id}
     class(\TypeRef{serializable\_class}),pointer::\TC{ref}=>null()
     class(\TypeRef{serializable\_ref\_type}),pointer::\TC{next}=>null()
   contains
     procedure,public::\TbpDec{finalize}{serializable\_ref\_finalize}
  end type serializable_ref_type
\end{Verbatim}
\TypeDef{position\_stack\_type}
\begin{Verbatim}
  type::position_stack_type
     private
     integer(kind=dik),dimension(2)::\TC{position}
     class(\TypeRef{position\_stack\_type}),pointer::\TC{next}=>null()
   contains
     procedure,public::\TbpDec{push\_head}{position\_stack\_push\_head}
     procedure,public::\TbpDec{push\_given}{position\_stack\_push\_given}
     procedure,public::\TbpDecS{position\_stack\_pop}
     procedure,public::\TbpDecS{position\_stack\_drop}
     procedure,public::\TbpDec{nth\_position}{position\_stack\_nth\_position}
     procedure,public::\TbpDec{first}{position\_stack\_first}
     procedure,public::\TbpDec{last}{position\_stack\_last}
     procedure,public::\TbpDec{range}{position\_stack\_range}
     generic,public::\TbpGen{push}{push\_head}
     generic,public::\TbpGen{push}{push\_given}
     generic,public::\TbpGen{pop}{position\_stack\_pop}
     generic,public::\TbpGen{push}{position\_stack\_drop}
  end type position_stack_type
\end{Verbatim}
\TypeDef{page\_ring\_type}
\begin{Verbatim}
  type,public::page_ring_type
     private
     logical::\TC{asynchronous}=serialize_default_asynchronous
     logical::\TC{eof\_reached}=.false.
     integer::\TC{unit}=-1
     integer(kind=dik)::\TC{ring\_size}=2
     integer(kind=dik)::\TC{action}=0
     integer(kind=dik)::\TC{eof\_int}=-1
     integer(kind=dik)::\TC{out\_unit}=output_unit
     integer(kind=dik)::\TC{err\_unit}=error_unit
     integer(kind=dik),dimension(2)::\TC{active\_pages}=[0,-1]
     integer(kind=dik),dimension(2)::\TC{eof\_pos}=[-1,-1]
     type(string_t)::\TC{eof\_string}
     type(\TypeRef{position\_stack\_type})::\TC{position\_stack}
     character(serialize_page_size),dimension(:),allocatable::\TC{ring}
   contains
     ! read access only procedures:
     procedure,public::\TbpDec{open\_for\_read\_access}{page\_ring\_open\_for\_read\_access}
     procedure,public::\TbpDec{read\_page}{page\_ring\_read\_page}
     ! write access only procedures:
     procedure,public::\TbpDec{open\_for\_write\_access}{page\_ring\_open\_for\_write\_access}
     procedure,public::\TbpDec{flush}{page\_ring\_flush}
     procedure,public::\TbpDec{break}{page\_ring\_break}
     ! comparing
     procedure,public::\TbpDec{str\_equal}{page\_ring\_str\_equal}
     ! searching:
     procedure,public::\TbpDec{find\_pure}{page\_ring\_find\_pure}
     generic,  public::\TbpGen{find}{page\_ring\_find,page\_ring\_find\_default}
     ! positioning:
     procedure,public::\TbpDec{set\_position}{page\_ring\_set\_position}
     procedure,public::\TbpDec{turn\_page}{page\_ring\_turn\_page}
     procedure,public::\TbpDec{proceed}{page\_ring\_proceed}
     generic,  public::\TbpGen{push\_position}{push\_actual\_position,push\_given\_position}
     generic,  public::\TbpGen{pop\_position}{pop\_actual\_position,pop\_given\_position}
     generic,  public::\TbpGen{get\_position}{page\_ring\_get\_position1,page\_ring\_get\_position2}
     ! printing:
     procedure,public::\TbpDec{print\_to\_unit}{page\_ring\_print\_to\_unit}
     procedure,public::\TbpDec{print\_ring}{page\_ring\_print\_ring}
     procedure,public::\TbpDec{print\_position}{page\_ring\_print\_position}
     ! writing:
     procedure,public::\TbpDec{put}{page\_ring\_put}
     generic,  public::\TbpGen{push}{push_string,push_integer,push_integer_dik,push_double,push_integer_array,push_integer_array_dik,push_double_array}
     ! reading:
     procedure,public::\TbpDec{get\_character}{page\_ring\_get\_character}
     procedure,public::\TbpDec{allocate\_substring}{page\_ring\_allocate\_substring}
     procedure,public::\TbpDec{pop\_character}{page\_ring\_pop\_character}
     procedure,public::\TbpDec{pop\_by\_keys}{page\_ring\_pop\_by\_keys}
     generic,  public::\TbpGen{substring}{page\_ring\_substring1,page\_ring\_substring2}
     generic,  public::\TbpGen{substring\_by\_keys}{page\_ring\_character\_by\_keys,page\_ring\_positions\_by\_keys}
     generic,  public::\TbpGen{pop}{pop_string,pop_integer,pop_integer_dik,pop_double,pop_logical,pop_integer_array,pop_integer_array_dik,pop_double_array}
     ! misc:
     procedure,public::\TbpDec{close}{page\_ring\_close}
     procedure,public::\TbpDec{ring\_index}{page\_ring\_ring\_index}
     ! private:
     procedure,private::\TbpDec{activate\_next\_page}{page\_ring\_activate\_next\_page}
     procedure,private::\TbpDec{enlarge}{page\_ring\_enlarge}
     ! specific names for generic procedures:
     procedure,private::\TbpDecS{page\_ring\_substring1}
     procedure,private::\TbpDecS{page\_ring\_substring2}
     procedure,private::\TbpDecS{page\_ring\_character\_by\_keys}
     procedure,private::\TbpDecS{page\_ring\_positions\_by\_keys}
     procedure,private::\TbpDec{push\_string}{page\_ring\_push\_string}
     procedure,private::\TbpDec{push\_integer}{page\_ring\_push\_integer}
     procedure,private::\TbpDec{push\_integer\_dik}{page\_ring\_push\_integer\_dik}
     procedure,private::\TbpDec{push\_integer\_array}{page\_ring\_push\_integer\_array}
     procedure,private::\TbpDec{push\_integer\_array\_dik}{page\_ring\_push\_integer\_array\_dik}
     procedure,private::\TbpDec{push\_double}{page\_ring\_push\_double}
     procedure,private::\TbpDec{push\_double\_array}{page\_ring\_push\_double\_array}
     procedure,private::\TbpDec{pop\_string}{page\_ring\_pop\_string}
     procedure,private::\TbpDec{pop\_integer}{page\_ring\_pop\_integer}
     procedure,private::\TbpDec{pop\_integer\_dik}{page\_ring\_pop\_integer\_dik}
     procedure,private::\TbpDec{pop\_logical}{page\_ring\_pop\_logical}
     procedure,private::\TbpDec{pop\_integer\_array}{page\_ring\_pop\_integer\_array}
     procedure,private::\TbpDec{pop\_integer\_array\_dik}{page\_ring\_pop\_integer\_array\_dik}
     procedure,private::\TbpDec{pop\_double}{page\_ring\_pop\_double}
     procedure,private::\TbpDec{pop\_double\_array}{page\_ring\_pop\_double\_array}
     procedure,private::\TbpDecS{page\_ring\_find}
     procedure,private::\TbpDecS{page\_ring\_find\_default}

     procedure,private::\TbpDec{actual\_index}{page\_ring\_actual\_index}
     procedure,private::\TbpDec{actual\_page}{page\_ring\_actual\_page}
     procedure,private::\TbpDec{actual\_offset}{page\_ring\_actual\_offset}
     procedure,private::\TbpDec{actual\_position}{page\_ring\_actual\_position}
     procedure,private::\TbpDec{first\_index}{page\_ring\_first\_index}
     procedure,private::\TbpDec{first\_page}{page\_ring\_first\_page}
     procedure,private::\TbpDec{last\_index}{page\_ring\_last\_index}
     procedure,private::\TbpDec{last\_page}{page\_ring\_last\_page}
     procedure,private::\TbpDec{push\_actual\_position}{page\_ring\_ring\_push\_actual\_position}
     procedure,private::\TbpDec{push\_given\_position}{page\_ring\_ring\_push\_given\_position}
     procedure,private::\TbpDec{pop\_actual\_position}{page\_ring\_ring\_pop\_actual\_position}
     procedure,private::\TbpDec{pop\_given\_position}{page\_ring\_ring\_pop\_given\_position}
     procedure,private::\TbpDecS{page\_ring\_get\_position1}
     procedure,private::\TbpDecS{page\_ring\_get\_position2}
  end type page_ring_type
\end{Verbatim}
\TypeDef{marker\_type}
\begin{Verbatim}
  type,public,extends(page_ring_type)::marker_type
     private
     integer(kind=dik)::\TC{indentation}=0
     integer(kind=dik)::\TC{n\_instances}=0
     logical::\TC{do\_break}=.true.
     logical::\TC{do\_indent}=.false.
     class(\TypeRef{serializable\_ref\_type}),pointer::\TC{heap}=>null()
     class(\TypeRef{serializable\_ref\_type}),pointer::\TC{references}=>null()
   contains
     procedure::\TbpDec{mark\_begin}{marker\_mark\_begin}
     procedure::\TbpDec{mark\_instance\_begin}{marker\_mark\_instance\_begin}
     procedure::\TbpDec{mark\_end}{marker\_mark\_end}
     procedure::\TbpDec{mark\_instance\_end}{marker\_mark\_instance\_end}
     procedure::\TbpDec{mark\_logical}{marker\_mark\_logical}
     procedure::\TbpDec{mark\_integer}{marker\_mark\_integer}
     procedure::\TbpDec{mark\_integer\_array}{marker\_mark\_integer\_array}
     procedure::\TbpDec{mark\_integer\_matrix}{marker\_mark\_integer\_matrix}
     procedure::\TbpDec{mark\_integer\_dik}{marker\_mark\_integer\_dik}
     procedure::\TbpDec{mark\_integer\_array\_dik}{marker\_mark\_integer\_array\_dik}
     procedure::\TbpDec{mark\_integer\_matrix\_dik}{marker\_mark\_integer\_matrix\_dik}
     procedure::\TbpDec{mark\_double}{marker\_mark\_double}
     procedure::\TbpDec{mark\_double\_array}{marker\_mark\_double\_array}
     procedure::\TbpDec{mark\_double\_matrix}{marker\_mark\_double\_matrix}
     procedure::\TbpDec{mark\_string}{marker\_mark\_string}
     procedure::\TbpDec{mark\_instance}{marker\_mark\_instance}
     procedure::\TbpDec{mark\_target}{marker\_mark\_target}
     procedure::\TbpDec{mark\_allocatable}{marker\_mark\_allocatable}
     procedure::\TbpDec{mark\_pointer}{marker\_mark\_pointer}
     procedure::\TbpDec{mark\_null}{marker\_mark\_null}
     procedure::\TbpDec{mark\_nothing}{marker\_mark\_nothing}
     procedure::\TbpDec{mark\_empty}{marker\_mark\_empty}
     procedure::\TbpDec{pick\_begin}{marker\_pick\_begin}
     procedure::\TbpDec{query\_instance\_begin}{marker\_query\_instance\_begin}
     procedure::\TbpDec{pick\_instance\_begin}{marker\_pick\_instance\_begin}
     procedure::\TbpDec{pick\_end}{marker\_pick\_end}
     procedure::\TbpDec{pick\_instance\_end}{marker\_pick\_instance\_end}
     procedure::\TbpDec{pick\_instance}{marker\_pick\_instance}
     procedure::\TbpDec{pick\_target}{marker\_pick\_target}
     procedure::\TbpDec{pick\_allocatable}{marker\_pick\_allocatable}
     procedure::\TbpDec{pick\_pointer}{marker\_pick\_pointer}
     procedure::\TbpDec{pick\_logical}{marker\_pick\_logical}
     procedure::\TbpDec{pick\_integer}{marker\_pick\_integer}
     procedure::\TbpDec{pick\_integer\_array}{marker\_pick\_integer\_array}
     procedure::\TbpDec{pick\_integer\_matrix}{marker\_pick\_integer\_matrix}
     procedure::\TbpDec{pick\_integer\_dik}{marker\_pick\_integer\_dik}
     procedure::\TbpDec{pick\_integer\_array\_dik}{marker\_pick\_integer\_array\_dik}
     procedure::\TbpDec{pick\_integer\_matrix\_dik}{marker\_pick\_integer\_matrix\_dik}
     procedure::\TbpDec{pick\_double}{marker\_pick\_double}
     procedure::\TbpDec{pick\_double\_array}{marker\_pick\_double\_array}
     procedure::\TbpDec{pick\_double\_matrix}{marker\_pick\_double\_matrix}
     procedure::\TbpDec{pick\_string}{marker\_pick\_string}
     generic,public::mark=>mark_logical,&
          mark_integer,mark_integer_array,mark_integer_matrix,&
          mark_integer_dik,mark_integer_array_dik,mark_integer_matrix_dik,&
          mark_double,mark_double_array,mark_double_matrix,mark_string
     generic,public::pick=>pick_logical,&
          pick_integer,pick_integer_array,pick_integer_matrix,&
          pick_integer_dik,pick_integer_array_dik,pick_integer_matrix_dik,&
          pick_double,pick_double_array,pick_double_matrix,pick_string
     procedure::\TbpDec{verify\_nothing}{marker\_verify\_nothing}
     procedure::\TbpDec{indent}{marker\_indent}
     procedure::\TbpDec{push\_heap}{marker\_push\_heap}
     procedure::\TbpDec{pop\_heap}{marker\_pop\_heap}
     procedure::\TbpDec{search\_heap\_by\_id}{marker\_search\_heap\_by\_id}
     procedure::\TbpDec{search\_heap\_by\_ref}{marker\_search\_heap\_by\_ref}
     procedure::\TbpDec{push\_reference}{marker\_push\_reference}
     procedure::\TbpDec{pop\_reference}{marker\_pop\_reference}
     procedure::\TbpDec{reset\_references}{marker\_reset\_references}
     procedure::\TbpDec{search\_reference}{marker\_search\_reference}
     procedure::\TbpDec{reset\_heap}{marker\_reset\_heap}
     procedure::\TbpDec{finalize}{marker\_finalize}
     generic::\TbpGen{search\_heap}{search\_heap\_by\_id}
     generic::\TbpGen{search\_heap}{search\_heap\_by\_ref}
  end type marker_type
\end{Verbatim}
\section{Interfaces}
\begin{Verbatim}
  abstract interface
     elemental function measure_int(this)
       import measurable_class
       import drk
       class(measurable_class),intent(in)::this
       real(kind=drk)::measure_int
     end function measure_int
  end interface
  interface operator(<)
     module procedure measurable_less_measurable
     module procedure measurable_less_double
  end interface
  interface operator(<=)
     module procedure measurable_less_or_equal_measurable
     module procedure measurable_less_or_equal_double
  end interface
  interface operator(==)
     module procedure measurable_equal_measurable
     module procedure measurable_equal_double
  end interface
  interface operator(>=)
     module procedure measurable_equal_or_greater_measurable
     module procedure measurable_equal_or_greater_double
  end interface
  interface operator(>)
     module procedure measurable_greater_measurable
     module procedure measurable_greater_double
  end interface
  abstract interface
     subroutine ser_write_if(this,marker,status)
       import serializable_class
       import marker_type
       import dik
       class(serializable_class),intent(in)::this
       class(marker_type),intent(inout)::marker
       integer(kind=dik),intent(out)::status
     end subroutine ser_write_if
  end interface
  abstract interface
     subroutine ser_read_if(this,marker,status)
       import serializable_class
       import marker_type
       import dik
       class(serializable_class),intent(out)::this
       class(marker_type),intent(inout)::marker
       integer(kind=dik),intent(out)::status
     end subroutine ser_read_if
  end interface
  abstract interface
     subroutine ser_unit(this,unit,parents,components,peers)
       import serializable_class
       import dik
       class(serializable_class),intent(in)::this
       integer,intent(in)::unit
       integer(kind=dik),intent(in)::parents,components,peers
     end subroutine ser_unit
  end interface
  abstract interface
     pure subroutine ser_type(type)
       character(:),allocatable,intent(out)::type
     end subroutine ser_type
  end interface
  interface page_ring_position_is_before
     module procedure &
          page_ring_position_is_before_int_pos,&
          page_ring_position_is_before_pos_pos,&
          page_ring_position_is_before_pos_int
  end interface
\end{Verbatim}
\section{Operators}
\begin{Verbatim}
  public operator(<),operator(<=),operator(>=),operator(>)
  public serialize_print_comp_pointer,serialize_print_peer_pointer&
       &,serialize_print_allocatable
  public identified_initialize,identified_print_to_unit&
       &,identified_read_from_marker,identified_write_to_marker

  public serializable_deserialize_from_marker
  public ilog2,generate_unit,integer_with_leading_zeros
\end{Verbatim}
\Methods
\MethodsFor{serializable\_class}

\TbpImp{serializable\_verify\_type}
\begin{Verbatim}
  elemental logical function serializable_verify_type(type) result(match)
    character(*),intent(in)::type
    match=type=="serializable_class"
  end function serializable_verify_type
\end{Verbatim}

\TbpImp{serializable\_read\_target\_from\_marker}
\begin{Verbatim}
  subroutine serializable_read_target_from_marker(this,marker,status)
    ! This is a dummy procedure. Usually, you dont't need to deserialize targets,
    ! so by implementing this dummy we don"t force all descendants to override this
    ! procedure. Then again this is the only way to read targets from markers.
    class(serializable_class),target,intent(out) :: this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    print *,"serializable_read_target_from_marker:"
    print *,"This is a dummy procedure. Usually, this message indicates a missing overridden &
         &read_target_from_marker TPB for "
    call this%write_type(output_unit)
    print *,""
    call this%read_from_marker(marker,status)
  end subroutine serializable_read_target_from_marker
\end{Verbatim}

\TbpImp{serializable\_write\_type}
\begin{Verbatim}
  subroutine serializable_write_type(this,unit)
    class(serializable_class),intent(in)::this
    integer,intent(in)::unit
    character(:),allocatable::this_type
    call this%get_type(this_type)
    write(unit,fmt='(a)',advance="no")this_type
  end subroutine serializable_write_type
\end{Verbatim}

\TbpImp{serializable\_print}
\begin{Verbatim}
  recursive subroutine serializable_print(this,parents,components,peers,unit)
    class(serializable_class),intent(in)::this
    integer(kind=dik),intent(in)::parents,components,peers
    integer,optional::unit
    if(present(unit))then
       write(unit,'("")')
       write(unit,'("Instance of type: ")',advance="no")
       call this%write_type(unit)
       write(unit,fmt='("")')
       call this%print_to_unit(unit,parents,components,peers)
    else
       write(output_unit,'("")')
       write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
       call this%print_to_unit(output_unit,parents,components,peers)
    end if
  end subroutine serializable_print
\end{Verbatim}

\TbpImp{serializable\_print\_all}
\begin{Verbatim}
  recursive subroutine serializable_print_all(this,unit)
    class(serializable_class),intent(in)::this
    integer,optional::unit
    if(present(unit))then
       write(unit,'("")')
       write(unit,'("Instance of type: ")',advance="no")
       call this%write_type(unit)
       write(unit,fmt='("")')
       call this%print_to_unit(unit,huge(one),huge(one),huge(one))
    else
       write(output_unit,'("")')
       write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
       call this%print_to_unit(output_unit,huge(one),huge(one),huge(one))
    end if
  end subroutine serializable_print_all
\end{Verbatim}

\TbpImp{serializable\_print\_little}
\begin{Verbatim}
  recursive subroutine serializable_print_little(this,unit)
    class(serializable_class),intent(in)::this
    integer,optional::unit
    if(present(unit))then
       write(unit,'("")')
       write(unit,'("Instance of type: ")',advance="no")
       call this%write_type(unit)
       write(unit,fmt='("")')
       call this%print_to_unit(unit,zero,zero,zero)
    else
       write(output_unit,'("")')
       write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
       call this%print_to_unit(output_unit,zero,zero,zero)
    end if
  end subroutine serializable_print_little
\end{Verbatim}

\TbpImp{serializable\_print\_parents}
\begin{Verbatim}
  recursive subroutine serializable_print_parents(this)
    class(serializable_class),intent(in)::this
    write(output_unit,'("")')
    write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
    call this%print_to_unit(output_unit,huge(one),zero,zero)
  end subroutine serializable_print_parents
\end{Verbatim}

\TbpImp{serializable\_print\_components}
\begin{Verbatim}
  recursive subroutine serializable_print_components(this)
    class(serializable_class),intent(in)::this
    write(output_unit,'("")')
    write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
    call this%print_to_unit(output_unit,zero,huge(one),zero)
  end subroutine serializable_print_components
\end{Verbatim}

\TbpImp{serializable\_print\_peers}
\begin{Verbatim}
  recursive subroutine serializable_print_peers(this)
    class(serializable_class),intent(in)::this
    write(output_unit,'("")')
    write(output_unit,'("Instance of type: ")',advance="no")
       call this%write_type(output_unit)
       write(output_unit,fmt='("")')
    call this%print_to_unit(output_unit,zero,zero,huge(one))
  end subroutine serializable_print_peers
\end{Verbatim}

\TbpImp{serializable\_print\_error}
\begin{Verbatim}
  recursive subroutine serializable_print_error(this)
    class(serializable_class),intent(in)::this
    call this%print_to_unit(error_unit,zero,zero,zero)
  end subroutine serializable_print_error
\end{Verbatim}

\TbpImp{serializable\_serialize\_to\_unit}
\begin{Verbatim}
  subroutine serializable_serialize_to_unit(this,unit,name)
    class(serializable_class),intent(in)::this
    integer, intent(in) :: unit
    character (len=*), intent(in) :: name
    logical::opened
    character(32)::file
    !    gfortran bug
    !    character::stream
    character::write
    type(marker_type)::marker
    !    inquire(unit=unit,opened=opened,stream=stream,write=write)
    inquire(unit=unit,opened=opened,write=write)
    if(opened)then
!       if(stream=="Y")then
          if(write=="Y")then
             print *,"dummy: serializable_serialize_to_unit"
             stop
          else
             print *,"serializable_serialize_to_unit: cannot write to read-only unit."
          end if
!       else
!          print *,"serializable_serialize_to_unit: access kind of unit is not 'stream'."
!       end if
    else
       print *,"serializable_serialize_to_unit: file is not opened."
    end if
  end subroutine serializable_serialize_to_unit
\end{Verbatim}

\TbpImp{serializable\_serialize\_to\_file}
\begin{Verbatim}
  subroutine serializable_serialize_to_file(this,name,file)
    class(serializable_class),intent(in)::this
    character (len=*), intent(in) :: file,name
    type(marker_type)::marker
    call marker%open_for_write_access(file)
    print *,"serializable_serialize_to_file: writing xml preamble to ",file
    call marker%activate_next_page()
    call marker%push('<?xml version="1.0"?>')
    call marker%mark_begin(tag="file",name=file)
    flush(marker%unit)
    call this%serialize_to_marker(marker,name)
    call marker%mark_end("file")
    call marker%close()
    call marker%finalize()
  end subroutine serializable_serialize_to_file
\end{Verbatim}

\TbpImp{serializable\_serialize\_to\_marker}
\begin{Verbatim}
  recursive subroutine serializable_serialize_to_marker(this,marker,name)
    class(serializable_class),intent(in)::this
    class(marker_type),intent(inout)::marker
    character (len=*), intent(in) :: name
    if(marker%action==1)then
       call marker%mark_instance(this,name)
    else       
       print *,"serializable_serialize_to_marker: Marker is not ready for write access. STOP."
       stop
    end if
  end subroutine serializable_serialize_to_marker
\end{Verbatim}

\TbpImp{serializable\_deserialize\_from\_unit}
\begin{Verbatim}
 subroutine serializable_deserialize_from_unit(this,unit,name)
    class(serializable_class),intent(inout)::this
    integer, intent(in) :: unit
    character (len=*), intent(in) :: name
    logical::opened
    !    gfortran bug
    !    character::stream
    character::read
    type(marker_type)::marker
    !    inquire(unit=unit,opened=opened,stream=stream,read=read)
    inquire(unit=unit,opened=opened,read=read)
    if(opened)then
!       if(stream=="Y")then
          if(read=="Y")then
             print *,"dummy: serializable_serialize_from_unit"
             stop
          else
             print *,"serializable_serialize_from_unit: cannot write from read-only unit."
          end if
!       else
!          print *,"serializable_serialize_from_unit: access kind of unit is not 'stream'."
!       end if
    else
       print *,"serializable_serialize_from_unit: file is not opened."
    end if
  end subroutine serializable_deserialize_from_unit
\end{Verbatim}

\TbpImp{serializable\_deserialize\_from\_marker}
\begin{Verbatim}
  subroutine serializable_deserialize_from_marker(this,name,marker)
    class(serializable_class),intent(out)::this
    character(*),intent(in)::name
    class(marker_type),intent(inout)::marker
    integer(kind=dik)::status
    if(marker%action==2)then
       call marker%pick_instance(name,this,status)
    else       
       print *,"serializable_deserialize_from_ring: Ring is not ready for read access. STOP."
       stop
    end if
  end subroutine serializable_deserialize_from_marker
\end{Verbatim}

\TbpImp{serializable\_deserialize\_from\_file}
\begin{Verbatim}
  subroutine serializable_deserialize_from_file(this,name,file)
    class(serializable_class),intent(out)::this
    character(*),intent(in)::name,file
    type(marker_type)::marker
    integer(kind=dik),dimension(2)::p1,p2
    call marker%open_for_read_access(file,"</file>")
    marker%eof_int=huge(one)
    marker%eof_pos=page_ring_position(marker%eof_int)
    call marker%read_page()
    call marker%find('<?',skip=2,proceed=.true.,pos=p1)
    call marker%find('?>',skip=3,proceed=.false.,pos=p2)
    if((p1(2)<=0).or.(p2(2)<=0))then
       print *,"no version substring found."
    end if
    call marker%set_position(p2)
    call marker%find('<file ',skip=4,proceed=.true.,pos=p1)
    call marker%find('>',skip=1,proceed=.false.,pos=p2)
    if((p1(2)>0).and.(p2(2)>0))then
       call marker%push_position(p2)
       call marker%find('name="',skip=4,proceed=.true.,pos=p1)
       call marker%find('"',skip=1,proceed=.false.,pos=p2)
       call marker%pop_position()
    else
       print *,"no file header found. STOP."
       STOP
    end if
    call this%deserialize_from_marker(name,marker)
    call marker%close()
    call marker%finalize()
  end subroutine serializable_deserialize_from_file
\end{Verbatim}
\MethodsFor{identified\_type}
\OverridesSection{serializable\_class}
\TbpImp{identified\_write\_to\_marker}
\begin{Verbatim}
  subroutine identified_write_to_marker(this,marker,status)
    class(identified_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("identified_type")
    call marker%mark("name",this%get_name())
    call marker%mark("id",this%get_id())
    call marker%mark_end("identified_type")
  end subroutine identified_write_to_marker
\end{Verbatim}

\TbpImp{identified\_read\_from\_marker}
\begin{Verbatim}
  subroutine identified_read_from_marker(this,marker,status)
    class(identified_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    character(:),allocatable::name
    call marker%pick_begin("identified_type",status=status)
    call marker%pick("name",name,status)
    call marker%pick("id",this%id,status)
    call marker%pick_end("identified_type",status=status)
    this%name=name
  end subroutine identified_read_from_marker
\end{Verbatim}

\TbpImp{identified\_print\_to\_unit}
\begin{Verbatim}
  subroutine identified_print_to_unit(this,unit,parents,components,peers)
    class(identified_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of identified_type:")')
    write(unit,'("Name:             ",a)')this%get_name()
    write(unit,'("ID:               ",I10)')this%get_id()
  end subroutine identified_print_to_unit
\end{Verbatim}
  
\TbpImp{identified\_get\_type}
\begin{Verbatim}
  pure subroutine identified_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="identified_type")
  end subroutine identified_get_type
\end{Verbatim}

\TbpImp{identified\_verify\_type}
\begin{Verbatim}
  elemental logical function identified_verify_type(string)
    character(len=*),intent(in)::string
    identified_verify_type=(string=="identified_type")
  end function identified_verify_type
\end{Verbatim}
\OriginalSection{identified\_type}
\TbpImp{identified\_initialize}
\begin{Verbatim}
  subroutine identified_initialize(this,id,name)
    class(identified_type),intent(out)::this
    integer(kind=dik),intent(in)::id
    character(len=*),intent(in)::name
    this%name=name
    this%id=id
  end subroutine identified_initialize
\end{Verbatim}

\TbpImp{identified\_get\_id}
\begin{Verbatim}
  elemental function identified_get_id(this) result(id)
    class(identified_type),intent(in)::this
    integer(kind=dik)::id
    id=this%id
  end function identified_get_id
\end{Verbatim}

\TbpImp{identified\_get\_name}
\begin{Verbatim}
  pure function identified_get_name(this)
    class(identified_type),intent(in)::this
    character(len(this%name))::identified_get_name
    identified_get_name=char(this%name)
  end function identified_get_name
\end{Verbatim}

\MethodsFor{unique\_type}
\OverridesSection{serializable\_class}
\TbpImp{unique\_print\_to\_unit}
\begin{Verbatim}
  subroutine unique_print_to_unit(this,unit,parents,components,peers)
    class(unique_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    if(parents>0)call identified_print_to_unit(this,unit,parents-1,components&
         &,peers)
    write(unit,'("Unique ID:        ",I10)')this%get_unique_id()
  end subroutine unique_print_to_unit
\end{Verbatim}

\ProcImp{unique\_get\_type}
\begin{Verbatim}
  pure subroutine unique_get_type(type)
    character(:),allocatable,intent(out)::type
    allocate(type,source="unique_type")
  end subroutine unique_get_type
\end{Verbatim}

\ProcImp{unique\_verify\_type}
\begin{Verbatim}
  elemental logical function unique_verify_type(string)
    character(len=*),intent(in)::string
    unique_verify_type=(string=="unique_type")
  end function unique_verify_type
\end{Verbatim}

\TbpImp{unique\_write\_to\_marker}
\begin{Verbatim}
  subroutine unique_write_to_marker(this,marker,status)
    class(unique_type),intent(in)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%mark_begin("unique_type")
    call identified_write_to_marker(this,marker,status)
    call marker%mark("unique_id",this%get_unique_id())
    call marker%mark_end("unique_type")
  end subroutine unique_write_to_marker
\end{Verbatim}

\TbpImp{unique\_read\_from\_marker}
\begin{Verbatim}
  subroutine unique_read_from_marker(this,marker,status)
    class(unique_type),intent(out)::this
    class(marker_type),intent(inout)::marker
    integer(kind=dik),intent(out)::status
    call marker%pick_begin("unique_type",status=status)    
    call identified_read_from_marker(this,marker,status)
    call marker%pick("unique_id",this%unique_id,status)
    call marker%pick_end("unique_type",status)
  end subroutine unique_read_from_marker
\end{Verbatim}
\OriginalSection{unique\_type}

\TbpImp{unique\_initialize}
\begin{Verbatim}
  subroutine unique_initialize(this,id,name)
    class(unique_type),intent(out)::this
    integer(kind=dik),intent(in)::id
    character(len=*),intent(in)::name
    call identified_initialize(this,id,name)
    last_id=last_id+1
    this%unique_id=last_id
  end subroutine unique_initialize
\end{Verbatim}

\TbpImp{unique\_get\_unique\_id}
\begin{Verbatim}
  elemental function unique_get_unique_id(this)
    class(unique_type),intent(in)::this
    integer(kind=dik)::unique_get_unique_id
    unique_get_unique_id=this%unique_id
  end function unique_get_unique_id
\end{Verbatim}
\MethodsFor{serializable\_ref\_type}
\TbpImp{serializable\_ref\_finalize}
\begin{Verbatim}
  subroutine serializable_ref_finalize(this)
    class(serializable_ref_type),intent(inout)::this
    class(serializable_ref_type),pointer::next
    do while (associated(this%next))
       next=>this%next
       this%next=>next%next
       nullify(next%ref)
       deallocate(next)
    end do
    if(associated(this%ref))nullify(this%ref)
  end subroutine serializable_ref_finalize
\end{Verbatim}
\MethodsFor{position\_stack\_type}
\TbpImp{position\_stack\_push\_head}
\begin{Verbatim}
  subroutine position_stack_push_head(this)
    class(position_stack_type)::this
    class(position_stack_type),pointer::new
    allocate(new)
    new%next=>this%next
    new%position=this%position
    this%next=>new
  end subroutine position_stack_push_head
\end{Verbatim}

\TbpImp{position\_stack\_push\_given}
\begin{Verbatim}
  subroutine position_stack_push_given(this,position)
    class(position_stack_type)::this
    integer(kind=dik),dimension(2),intent(in)::position
    class(position_stack_type),pointer::new
    allocate(new)
    new%next=>this%next
    new%position=position
    this%next=>new
  end subroutine position_stack_push_given
\end{Verbatim}

\TbpImp{position\_stack\_pop}
\begin{Verbatim}
  subroutine position_stack_pop(this)
    class(position_stack_type)::this
    class(position_stack_type),pointer::old
    if(associated(this%next))then
       old=>this%next
       this%next=>old%next
       this%position=old%position
       deallocate(old)
    end if
  end subroutine position_stack_pop
\end{Verbatim}

\TbpImp{position\_stack\_drop}
\begin{Verbatim}
  subroutine position_stack_drop(this,position)
    class(position_stack_type)::this
    integer(kind=dik),dimension(2),intent(out)::position
    class(position_stack_type),pointer::old
    if(associated(this%next))then
       old=>this%next
       this%next=>old%next
       position=old%position
       deallocate(old)
    else
       position=[0,0]
    end if
  end subroutine position_stack_drop
\end{Verbatim}

\TbpImp{position\_stack\_nth\_position}
\begin{Verbatim}
  function position_stack_nth_position(this,n) result(position)
    class(position_stack_type),intent(in)::this
    integer(kind=dik),intent(in)::n
    integer(kind=dik),dimension(2)::position
    class(position_stack_type),pointer::tmp
    integer(kind=dik)::pos
    tmp=>this%next
    pos=n
    do while(associated(tmp).and.pos>0)
       tmp=>tmp%next
       pos=pos-1
    end do
    if(associated(tmp))then
       position=tmp%position
    else
       position=[0,0]
    end if
  end function position_stack_nth_position
\end{Verbatim}
  
\TbpImp{position\_stack\_first}
\begin{Verbatim}
  function position_stack_first(this) result(position)
    class(position_stack_type),intent(in)::this
    integer(kind=dik),dimension(2)::position,tmp_position
    class(position_stack_type),pointer::tmp_stack
    tmp_position=this%position
    tmp_stack=>this%next
    do while(associated(tmp_stack))
       if(page_ring_position_is_before(tmp_stack%position,tmp_position))then
          tmp_position=tmp_stack%position
       end if
       tmp_stack=>tmp_stack%next
    end do
  end function position_stack_first
\end{Verbatim}
  
\TbpImp{position\_stack\_last}
\begin{Verbatim}
  function position_stack_last(this) result(position)
    class(position_stack_type),intent(in)::this
    integer(kind=dik),dimension(2)::position,tmp_position
    class(position_stack_type),pointer::tmp_stack
    tmp_position=this%position
    tmp_stack=>this%next
    do while(associated(tmp_stack))
       if(page_ring_position_is_before(tmp_position,tmp_stack%position))then
          tmp_position=tmp_stack%position
       end if
       tmp_stack=>tmp_stack%next
    end do
  end function position_stack_last
\end{Verbatim}
  
\TbpImp{position\_stack\_range}
\begin{Verbatim}
  pure function position_stack_range(this) result(position)
    class(position_stack_type),intent(in)::this
    integer(kind=dik),dimension(2)::position
    class(position_stack_type),pointer::tmp
  end function position_stack_range
\end{Verbatim}
\MethodsFor{page\_ring\_type}
\TbpImp{page\_ring\_open\_for\_read\_access}
\begin{Verbatim}
  subroutine page_ring_open_for_read_access(this,file,eof_string,asynchronous)
    class(page_ring_type),intent(inout)::this
    character(*),intent(in)::file,eof_string
    logical,intent(in),optional::asynchronous
    logical::exist
    this%eof_string=eof_string
    inquire(file=file,exist=exist)
    if(exist)then
       this%action=2
    else
       print *,"page_ring_open: File ",file," is opened for read access but &
       &does not exist. STOP."
       STOP
    end if

    if(present(asynchronous))this%asynchronous=asynchronous
    if(this%unit<0)call generate_unit(this%unit,100,1000)
    if(this%unit<0)then
       print *,"page_ring_open: No free unit found. STOP."
       STOP
    end if
    this%ring_size=2
    call this%set_position([zero,one])
    this%active_pages=[zero,-one]
    if(allocated(this%ring))deallocate(this%ring)
    allocate(this%ring(zero:this%ring_size-one))
    if(this%asynchronous)then
       open(this%unit,&
            file=file,&
            access="stream",&
            action="read",&
            asynchronous="yes",&
            status="old")
    else
       open(this%unit,&
            file=file,&
            access="stream",&
            action="read",&
            asynchronous="no",&
            status="old")
    end if
    call this%read_page()
  end subroutine page_ring_open_for_read_access
\end{Verbatim}

\TbpImp{page\_ring\_open\_for\_write\_access}
\begin{Verbatim}
  subroutine page_ring_open_for_write_access(this,file,asynchronous)
    class(page_ring_type),intent(inout)::this
    character(*),intent(in)::file
    logical,intent(in),optional::asynchronous
    this%action=1

    if(present(asynchronous))this%asynchronous=asynchronous
    if(this%unit<0)call generate_unit(this%unit,100,1000)
    if(this%unit<0)then
       print *,"page_ring_open: No free unit found. STOP."
       STOP
    end if
    this%ring_size=2
    call this%set_position([zero,one])
    this%active_pages=[zero,-one]
    if(allocated(this%ring))deallocate(this%ring)
    allocate(this%ring(zero:this%ring_size-one))

    if(this%asynchronous)then
       open(this%unit,&
            file=file,&
            access="stream",&
            action="write",&
            asynchronous="yes",&
            status="replace")
    else
       open(this%unit,&
            file=file,&
            access="stream",&
            action="write",&
            asynchronous="no",&
            status="replace")
    end if
  end subroutine page_ring_open_for_write_access
\end{Verbatim}

\TbpImp{page\_ring\_close}
\begin{Verbatim}
  subroutine page_ring_close(this)
    class(page_ring_type),intent(inout)::this
    if(this%action==1)then
       call this%flush()
       !call this%print_position()
       if(this%asynchronous)then
          write(this%unit,asynchronous="yes")&
               &this%ring(this%actual_index())(:this%actual_offset()-1)
       else
          write(this%unit,asynchronous="no")&
               &this%ring(this%actual_index())(:this%actual_offset()-1)
       end if
    end if
    close(this%unit)
  end subroutine page_ring_close
\end{Verbatim}

\TbpImp{page\_ring\_read\_page}
\begin{Verbatim}
  subroutine page_ring_read_page(this)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik)::iostat
    character(8)::iomsg
    if(.not.this%eof_reached)then
       call page_ring_activate_next_page(this)
       read(this%unit,iostat=iostat)this%ring(this%last_index())
       if(iostat==iostat_end)then
          this%eof_reached=.true.
          this%eof_pos(1)=this%last_page()
          this%eof_pos(2)=index(this%ring(this%last_index()),char(this%eof_string))
          this%eof_pos(2)=this%eof_pos(2)+len(this%eof_string)-1
          this%eof_int=page_ring_ordinal(this%eof_pos)
       end if
    end if
  end subroutine page_ring_read_page
\end{Verbatim}

\TbpImp{page\_ring\_enlarge}
\begin{Verbatim}
  subroutine page_ring_enlarge(this)
    class(page_ring_type),intent(inout)::this
    character(serialize_page_size),dimension(:),allocatable::tmp_ring
    integer(kind=dik)::n
    call move_alloc(this%ring,tmp_ring)
    allocate(this%ring(0:this%ring_size*2-1))
    do n=this%active_pages(1),this%active_pages(2)
       this%ring(mod(n,this%ring_size*2))=tmp_ring(mod(n,this%ring_size))
    end do
    this%ring_size=this%ring_size*2
  end subroutine page_ring_enlarge
\end{Verbatim}
  
\TbpImp{page\_ring\_print\_to\_unit}
\begin{Verbatim}
  subroutine page_ring_print_to_unit(this,unit,parents,components,peers)
    class(page_ring_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    write(unit,'("Components of page_ring_type:")')
    print *,"asynchronous: ",this%asynchronous
    print *,"eof reached:  ",this%eof_reached
    print *,"ring_size:    ",this%ring_size
    print *,"unit:         ",this%unit
    print *,"action:       ",this%action
    print *,"position:     ",this%position_stack%position
    print *,"active_pages: ",this%active_pages
    print *,"file size:    ",this%eof_int
    print *,"eof position: ",this%eof_pos
    print *,"eof string:   ",char(this%eof_string)
    if(allocated(this%ring))then
       print *,"Ring is allocated."
       if(components>0)call this%print_ring(unit)
    else
       print *,"Ring is not allocated."
    end if
  end subroutine page_ring_print_to_unit
\end{Verbatim}
  
\TbpImp{page\_ring\_print\_ring}
\begin{Verbatim}
  subroutine page_ring_print_ring(this,unit)
    class(page_ring_type),intent(in)::this
    integer,intent(in)::unit
    integer(kind=dik)::n
    write(unit,fmt=*)"Begin of page ring"
    do n=this%active_pages(1),this%active_pages(2)
       write(unit=unit,fmt="('(',I0,')',a)")n,this%ring(mod(n,this%ring_size))
    end do
    write(unit,fmt=*)"End of page ring"
  end subroutine page_ring_print_ring
\end{Verbatim}
  
\TbpImp{page\_ring\_push\_string}
\begin{Verbatim}
  recursive subroutine page_ring_push_string(this,string)
    class(page_ring_type),intent(inout)::this
    character(*),intent(in)::string
    integer(kind=dik)::cut,l
    l=len(string)
    if(l<=serialize_page_size-this%actual_offset()+1)then
       this%ring(this%actual_index())(this%actual_offset():this%actual_offset()+l-1)=string
       if(l==serialize_page_size-this%actual_offset()+1)then
          call this%break()
          call this%flush()
       else
          call this%proceed(l)
       end if       
    else
       cut=serialize_page_size-this%actual_offset()+1
       call this%push_string(string(:cut))
       call this%push_string(string(cut+1:))
    end if
  end subroutine page_ring_push_string
\end{Verbatim}

\TbpImp{page\_ring\_push\_integer\_dik}
\begin{Verbatim}
  recursive subroutine page_ring_push_integer_dik(this,int)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),intent(in)::int
    integer(kind=dik)::int1
    if(int<0)then
       call this%push("-")
       call page_ring_push_integer_dik(this,-int)
    else
       if(int>9)call this%push(int/10)
       int1=mod(int,10*one)
       select case (int1)
       case (0)
          call this%push("0")
       case (1)
          call this%push("1")
       case (2)
          call this%push("2")
       case (3)
          call this%push("3")
       case (4)
          call this%push("4")
       case (5)
          call this%push("5")
       case (6)
          call this%push("6")
       case (7)
          call this%push("7")
       case (8)
          call this%push("8")
       case (9)
          call this%push("9")
       end select
    end if
  end subroutine page_ring_push_integer_dik
\end{Verbatim}

\TbpImp{page\_ring\_push\_integer}
\begin{Verbatim}
  subroutine page_ring_push_integer(this,in)
    class(page_ring_type),intent(inout)::this
    integer,intent(in)::in
    call page_ring_push_integer_dik(this,int(in,kind=dik))
  end subroutine page_ring_push_integer
\end{Verbatim}

\TbpImp{page\_ring\_pop\_integer}
\begin{Verbatim}
  subroutine page_ring_pop_integer(this,in)
    class(page_ring_type),intent(inout)::this
    integer,intent(out)::in
    integer(kind=dik)::in_dik
    call page_ring_pop_integer_dik(this,in_dik)
    in=int(in_dik)
  end subroutine page_ring_pop_integer
\end{Verbatim}

\TbpImp{page\_ring\_pop\_integer\_dik}
\begin{Verbatim}
  subroutine page_ring_pop_integer_dik(this,int)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),intent(out)::int
    integer(kind=dik)::int1
    integer(kind=dik)::sign
    character::c
    int=0
    sign=1
    c=" "
    do while(scan(c,serialize_integer_characters)==0)
       call this%pop_character(c)
    end do
    if(c=="-")then
       sign=-1
       call this%pop_character(c)
    end if
    do while(scan(c,serialize_integer_characters)>0)
       int=int*10
       select case (c)
       case ("1")
          int=int+1
       case ("2")
          int=int+2
       case ("3")
          int=int+3
       case ("4")
          int=int+4
       case ("5")
          int=int+5
       case ("6")
          int=int+6
       case ("7")
          int=int+7
       case ("8")
          int=int+8
       case ("9")
          int=int+9
       end select
       call this%pop_character(c)
    end do
    int=int*sign
    if(c=="<")call this%proceed(-one)
  end subroutine page_ring_pop_integer_dik
\end{Verbatim}

\TbpImp{page\_ring\_pop\_logical}
\begin{Verbatim}
  subroutine page_ring_pop_logical(this,l)
    class(page_ring_type),intent(inout)::this
    logical,intent(out)::l
    character(1)::lc
    call this%pop(lc)
    do while(scan(lc,"tTfF")==0)
       call this%pop(lc)
    end do
    read(lc,fmt="(l1)")l
  end subroutine page_ring_pop_logical
\end{Verbatim}

\TbpImp{page\_ring\_push\_integer\_array\_dik}
\begin{Verbatim}
  subroutine page_ring_push_integer_array_dik(this,int)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(:),intent(in)::int
    integer(kind=dik)::n
    do n=1,size(int)
       call this%push(int(n))
       call this%push(" ")
    end do
  end subroutine page_ring_push_integer_array_dik
\end{Verbatim}
  
\TbpImp{page\_ring\_push\_integer\_array}
\begin{Verbatim}
  subroutine page_ring_push_integer_array(this,int)
    class(page_ring_type),intent(inout)::this
    integer,dimension(:),intent(in)::int
    integer::n
    do n=1,size(int)
       call this%push(int(n))
       call this%push(" ")
    end do
  end subroutine page_ring_push_integer_array
\end{Verbatim}
  
\TbpImp{page\_ring\_pop\_integer\_array}
\begin{Verbatim}
  subroutine page_ring_pop_integer_array(this,int)
    class(page_ring_type),intent(inout)::this
    integer,dimension(:),intent(out)::int
    integer::n
    do n=1,size(int)
       call this%pop(int(n))
    end do
  end subroutine page_ring_pop_integer_array
\end{Verbatim}

\TbpImp{page\_ring\_pop\_integer\_array\_dik}
\begin{Verbatim}
   subroutine page_ring_pop_integer_array_dik(this,int)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(:),intent(out)::int
    integer(kind=dik)::n
    do n=1,size(int)
       call this%pop(int(n))
    end do
  end subroutine page_ring_pop_integer_array_dik
\end{Verbatim}

\TbpImp{page\_ring\_push\_double}
\begin{Verbatim}
  subroutine page_ring_push_double(this,dou)
    class(page_ring_type),intent(inout)::this
    real(kind=drk),intent(in)::dou
    integer(kind=dik)::f
!    print *,"page_ring_push_double: ",dou
    if(dou==0D0)then
       call this%push("0")
    else
       f=int(scale(fraction(dou),digits(dou)),kind=dik)
       call this%push(digits(dou))
       call this%push(":")    
       call this%push(f)
       call this%push(":")
       call this%push(exponent(dou))
    end if
    call this%push(" ")
  end subroutine page_ring_push_double
\end{Verbatim}

\TbpImp{page\_ring\_push\_double\_array}
\begin{Verbatim}
  subroutine page_ring_push_double_array(this,dou)
    class(page_ring_type),intent(inout)::this
    real(kind=drk),dimension(:),intent(in)::dou
    integer(kind=dik)::n
    do n=1,size(dou)
       call this%push(dou(n))
    end do
  end subroutine page_ring_push_double_array
\end{Verbatim}

\TbpImp{page\_ring\_pop\_double}
\begin{Verbatim}
  subroutine page_ring_pop_double(this,dou,skip)
    class(page_ring_type),intent(inout)::this
    real(kind=drk),intent(out)::dou
    logical,optional,intent(in)::skip
    integer(kind=dik)::d,f,e
    call this%pop(d)
    if(d==zero)then
       dou=0D0
    else
       call this%pop(f)
       call this%pop(e)
       dou=set_exponent(scale(real(f,kind=double),-d),e)
    end if
    if(present(skip))then
       if(.not.skip)call this%proceed(-one)
    end if
  end subroutine page_ring_pop_double
\end{Verbatim}

\TbpImp{page\_ring\_pop\_double\_array}
\begin{Verbatim}
  subroutine page_ring_pop_double_array(this,dou,skip)
    class(page_ring_type),intent(inout)::this
    real(kind=drk),dimension(:),intent(out)::dou
    logical,optional,intent(in)::skip
    integer(kind=dik)::n    
    call this%pop_double(dou(1))
    do n=2,size(dou)
       call this%pop_double(dou(n))
    end do
    if(present(skip))then
       if(.not.skip)call this%proceed(-one)
    end if
  end subroutine page_ring_pop_double_array
\end{Verbatim}

\TbpImp{page\_ring\_pop\_character}
\begin{Verbatim}
  subroutine page_ring_pop_character(this,c)
    class(page_ring_type),intent(inout)::this
    character,intent(out)::c
    c=this%ring(this%actual_index())(this%actual_offset():this%actual_offset())
    if(this%actual_offset()==serialize_page_size)call this%read_page
    call this%proceed(one)
  end subroutine page_ring_pop_character
\end{Verbatim}

\TbpImp{page\_ring\_pop\_string}
\begin{Verbatim}
  recursive subroutine page_ring_pop_string(this,res)
    class(page_ring_type),intent(inout)::this
    character(len=*),intent(out)::res
    integer(kind=dik)::n,cut
    n=len(res)
    cut=serialize_page_size-this%actual_offset()+1
    if(n<=cut)then
       res=this%ring(this%actual_index())(this%actual_offset():this%actual_offset()+n)
       if(n==cut)then
          call this%read_page
       end if
       call this%proceed(n)
    else
       call page_ring_pop_string(this,res(:cut))
       call page_ring_pop_string(this,res(cut+1:))
    end if
  end subroutine page_ring_pop_string
\end{Verbatim}

\TbpImp{page\_ring\_substring2}
\begin{Verbatim}
  pure function page_ring_substring2(this,i1,i2) result(res)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2),intent(in)::i1,i2
    character(ring_position_metric2(i1,i2))::res
    integer(kind=dik)::page,pos
    if(i1(1)==i2(1))then
       res=this%ring(mod(i1(1),this%ring_size))(i1(2):i2(2))
    else
       pos=serialize_page_size-i1(2)
       res(1:pos+1)=this%ring(mod(i1(1),this%ring_size))(i1(2):)
       do page=i1(1)+1,i2(1)-1
          res(pos+2:pos+2+serialize_page_size)=this%ring(mod(page,this%ring_size))
          pos=pos+serialize_page_size
       end do
       res(pos+2:pos+1+i2(2))=this%ring(mod(page,this%ring_size))(1:i2(2))
    end if
  end function page_ring_substring2
\end{Verbatim}

\TbpImp{page\_ring\_substring1}
\begin{Verbatim}
  pure function page_ring_substring1(this,i) result(res)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2,2),intent(in)::i
    character(ring_position_metric1(i))::res
    integer(kind=dik)::page,pos
    if(i(1,1)==i(1,2))then
       res=this%ring(mod(i(1,1),this%ring_size))(i(2,1):i(2,2))
    else
       pos=serialize_page_size-i(2,1)
       res(1:pos+1)=this%ring(mod(i(1,1),this%ring_size))(i(2,1):)
       do page=i(1,1)+1,i(1,1)-1
          res(pos+2:pos+2+serialize_page_size)=this%ring(mod(page,this%ring_size))
          pos=pos+serialize_page_size
       end do
       res(pos+2:pos+1+i(2,2))=this%ring(mod(page,this%ring_size))(1:i(2,2))
    end if
  end function page_ring_substring1
\end{Verbatim}

\TbpImp{page\_ring\_allocate\_substring}
\begin{Verbatim}
  subroutine page_ring_allocate_substring(this,p1,p2,string)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2),intent(in)::p1,p2
    character(:),allocatable,intent(out)::string
    string=page_ring_substring2(this,p1,p2)
  end subroutine page_ring_allocate_substring
\end{Verbatim}

\TbpImp{page\_ring\_find\_default}
\begin{Verbatim}
  subroutine page_ring_find_default(this,exp,skip,proceed,pos)
    class(page_ring_type),intent(inout)::this
    character(*),optional,intent(in)::exp
    integer,intent(in)::skip
    logical,intent(in)::proceed
    integer(kind=dik),dimension(2),intent(out)::pos
    call page_ring_find(this,exp,this%position_stack%position,this%eof_pos,skip,proceed,pos)
  end subroutine page_ring_find_default
\end{Verbatim}

\TbpImp{page\_ring\_find}
\begin{Verbatim}
  recursive subroutine page_ring_find(this,exp,start,limit,skip,proceed,pos)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(2),intent(in)::start
    integer(kind=dik),dimension(2),intent(in)::limit
    character(*),intent(in)::exp
    integer,intent(in)::skip
    logical,intent(in)::proceed
    integer(kind=dik),dimension(2),intent(out)::pos
    integer(kind=dik)::page,page2,ind
    page=this%ring_index(start(1))
    if(limit(1)==start(1))then
       ind=index(this%ring(page)(start(2):limit(2)),exp)
       if(ind>0)then
          select case (skip)
          case(1)
             pos=[start(1),start(2)+ind-2]
             if(pos(2)==0)then
                pos(1)=pos(1)-1
                pos(2)=serialize_page_size
             end if
          case(2)
             pos=[start(1),start(2)+ind-1]
          case(3)
             pos=[start(1),start(2)+ind+len(exp)-2]
          case(4)
             pos=[start(1),start(2)+ind+len(exp)-1]
             if(pos(1)==this%last_page())call this%read_page()
             if(pos(2)>serialize_page_size)then
                pos(1)=pos(1)+1
                pos(2)=pos(2)-serialize_page_size
             end if
          end select
          if(proceed)call this%set_position(pos)
       else
          print *,"page_ring_find: limit reached."
          pos=[-1,-1]
       end if
    else
       ind=index(this%ring(page)(start(2):),exp)
       if(ind>0)then
          select case (skip)
          case(1)
             pos=[start(1),start(2)+ind-2]
             if(pos(2)==0)then
                pos(1)=pos(1)-1
                pos(2)=serialize_page_size
             end if
          case(2)
             pos=[start(1),start(2)+ind-1]
          case(3)
             pos=[start(1),start(2)+ind+len(exp)-2]
          case(4)
             pos=[start(1),start(2)+ind+len(exp)-1]
             if(pos(1)==this%last_page())call this%read_page()
             if(pos(2)>serialize_page_size)then
                pos(1)=pos(1)+1
                pos(2)=one
             end if
          end select
          if(proceed)call this%set_position(pos)
       else
          if(start(1)+1>this%active_pages(2))then
             call this%read_page()
             page=this%ring_index(start(1))
          end if
          page2=this%ring_index(start(1)+1)
          ind=index(this%ring(page)(serialize_page_size-len(exp)+1:)&
                    //this%ring(page2)(:len(exp)),exp)
          if(ind>0)then
             select case (skip)
             case(1)
                pos=[start(1),serialize_page_size-len(exp)+ind-1]
             case(2)
                pos=[start(1),serialize_page_size-len(exp)+ind]
             case(3)
                pos=[start(1)+1,ind-1]
             case(4)
                pos=[start(1)+1,ind]
             end select
             if(pos(2)>serialize_page_size)then
                pos(1)=pos(1)+1
                pos(2)=pos(2)-serialize_page_size
             else
                if(pos(2)<0)then
                   pos(1)=pos(1)-1
                   pos(2)=pos(2)+serialize_page_size
                end if
             end if
             if(proceed)call this%set_position(pos)
          else
             if(proceed)this%active_pages(1)=this%active_pages(2)
             call page_ring_find(this,exp,[start(1)+one,one],limit,skip,proceed,pos)
          end if
       end if
    end if
  end subroutine page_ring_find
\end{Verbatim}

\TbpImp{page\_ring\_str\_equal}
\begin{Verbatim}
  pure logical function page_ring_str_equal(this,string,pos)
    class(page_ring_type),intent(in)::this
    character(*),intent(in)::string
    integer(kind=dik),dimension(2,2),intent(in)::pos
    page_ring_str_equal=string==this%substring(pos)
  end function page_ring_str_equal
\end{Verbatim}

\TbpImp{page\_ring\_find\_pure}
\begin{Verbatim}
  pure recursive function page_ring_find_pure(this,exp,start,limit,skip) result(pos)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2),intent(in)::start
    integer(kind=dik),dimension(2),intent(in)::limit
    character(*),intent(in)::exp
    integer,optional,intent(in)::skip
    integer(kind=dik),dimension(2)::pos
    integer(kind=dik)::page,page2,ind,actual_skip
    ! Is the starting point before limit?
    if(start(1)<=limit(1))then
       ! Default skip is what you expect from the build-in index function
       if(present(skip))then
          actual_skip=skip
       else
          actual_skip=2
       end if
       page=mod(start(1),this%ring_size)
       ! Does the scanning region end on the page?
       if(start(1)==limit(1))then
          ind=index(this%ring(page)(start(2):limit(2)),exp)
       else
          ind=index(this%ring(page)(start(2):),exp)
       end if
       if(ind>0)then
          ! substring found on first page
          select case (actual_skip)
          case(1)
             pos=[start(1),start(2)+ind-2]
             if(pos(2)==0)then
                pos(1)=pos(1)-1
                pos(2)=serialize_page_size
             end if
          case(2)
             pos=[start(1),start(2)+ind-1]
          case(3)
             pos=[start(1),start(2)+ind+len(exp)-2]
          case(4)
             pos=[start(1),start(2)+ind+len(exp)-1]
             if(pos(2)>serialize_page_size)then
                pos(1)=pos(1)+1
                pos(2)=pos(2)-serialize_page_size
             end if
          end select
       else
          ! Substring not found on first page. Is the next page already read?
          if((start(1)>=limit(1)).or.(start(1)+1>this%active_pages(2)))then
             ! Either the limit is reached or the next page is not ready.
             pos=[0,0]
          else
             ! The next page is available.
             page2=mod(start(1)+1,this%ring_size)
             ! We concatenate the edges. When l is the length of exp, then we want to concat
             ! the l-1 last characters of page one and the first l characters of page two.
             ind=index(this%ring(page)(serialize_page_size-len(exp)+2:)&
                       //this%ring(page2)(:len(exp)),exp)
             if(ind>0)then
                select case (actual_skip)
                case(1)
                   pos=[start(1),serialize_page_size-len(exp)+ind]
                case(2)
                   pos=[start(1),serialize_page_size-len(exp)+ind+1]
                case(3)
                   pos=[start(1)+1,ind]
                case(4)
                   pos=[start(1)+1,ind+1]
                end select
             else
                ! EXP is not found in the overlap region. We recursively search the next pages.
                pos=page_ring_find_pure(this,exp,[start(one)+one,one],limit,skip)
             end if
          end if
       end if
    else
       ! limit is before start
       pos=[0,0]
    end if
  end function page_ring_find_pure
\end{Verbatim}

\TbpImp{page\_ring\_positions\_by\_keys}
\begin{Verbatim}
  pure recursive subroutine page_ring_positions_by_keys&
    (this,exp1,exp2,start,limit,inclusive,length,pos)
    class(page_ring_type),intent(in)::this
    character(*),intent(in)::exp1,exp2
    integer(kind=dik),dimension(2),intent(in)::start,limit
    logical,optional,intent(in)::inclusive
    integer(kind=dik),intent(out),optional::length
    integer(kind=dik),dimension(2,2),intent(out)::pos
    if(inclusive)then
       pos(1:2,1)=this%find_pure(exp1,start,limit,2)
    else
       pos(1:2,1)=this%find_pure(exp1,start,limit,4)
    end if
    !print *,pos1
    if(present(length))then
       length=0
    end if
    if(pos(2,1)>0)then
       if(inclusive)then
          pos(1:2,2)=this%find_pure(exp2,pos(1:2,1),limit,3)
       else
          pos(1:2,2)=this%find_pure(exp2,pos(1:2,1),limit,1)
       end if
       !print *,pos2
       if(pos(2,2)>0)then
          if(present(length))then
             length=ring_position_metric1(pos)
          end if
       end if
    end if
  end subroutine page_ring_positions_by_keys
\end{Verbatim}

\TbpImp{page\_ring\_character\_by\_keys}
\begin{Verbatim}
  pure recursive subroutine page_ring_character_by_keys&
    (this,exp1,exp2,start,limit,inclusive,length,string)
    class(page_ring_type),intent(in)::this
    character(*),intent(in)::exp1,exp2
    integer(kind=dik),dimension(2),intent(in)::start,limit
    logical,optional,intent(in)::inclusive
    integer(kind=dik),intent(out),optional::length
    character(:),allocatable,intent(out)::string
    integer(kind=dik),dimension(2,2)::pos
    call this%substring_by_keys(exp1,exp2,start,limit,inclusive,length,pos)
    string=this%substring(pos(:,1),pos(:,2))
  end subroutine page_ring_character_by_keys
\end{Verbatim}

\TbpImp{page\_ring\_pop\_by\_keys}
\begin{Verbatim}
  subroutine page_ring_pop_by_keys(this,start,stop,inclusive,res)
    class(page_ring_type),intent(inout)::this
    character(*),intent(in),optional::start
    character(*),intent(in)::stop
    logical,optional,intent(in)::inclusive
    character(len=*),intent(out)::res
    integer(kind=dik),dimension(2)::i1,i2
    if(inclusive)then
       call this%find(start,2,.true.,i1)
       call this%find(stop,3,.false.,i2)
    else
       call this%find(start,4,.true.,i1)
       call this%find(stop,1,.false.,i2)
    end if
    res=this%substring(i1,i2)
    call this%set_position(i2)
  end subroutine page_ring_pop_by_keys
\end{Verbatim}

\TbpImp{page\_ring\_get\_character}
\begin{Verbatim}
  elemental function  page_ring_get_character(this)
    class(page_ring_type),intent(in)::this
    character::page_ring_get_character
    page_ring_get_character=&
     this%ring(this%actual_index())(this%actual_offset():this%actual_offset())
  end function page_ring_get_character
\end{Verbatim}

\TbpImp{page\_ring\_break}
\begin{Verbatim}
  subroutine page_ring_break(this)
    class(page_ring_type),intent(inout)::this
    if(this%actual_page()>=this%active_pages(2))call this%activate_next_page()
    call this%turn_page()
  end subroutine page_ring_break
\end{Verbatim}

\TbpImp{page\_ring\_turn\_page}
\begin{Verbatim}
  subroutine page_ring_turn_page(this)
    class(page_ring_type),intent(inout)::this
    this%position_stack%position(1)=this%position_stack%position(1)+1
    this%position_stack%position(2)=1
  end subroutine page_ring_turn_page
\end{Verbatim}

\TbpImp{page\_ring\_flush}
\begin{Verbatim}
  subroutine page_ring_flush(this)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik)::page
    do while(this%active_pages(1)<this%actual_page())
       if(this%asynchronous)then
          write(this%unit,asynchronous="yes")this%ring(mod(this%active_pages(1),this%ring_size))
       else
          write(this%unit,asynchronous="no")this%ring(mod(this%active_pages(1),this%ring_size))
       end if
       this%active_pages(1)=this%active_pages(1)+1
    end do
  end subroutine page_ring_flush
\end{Verbatim}

\TbpImp{page\_ring\_activate\_next\_page}
\begin{Verbatim}
  subroutine page_ring_activate_next_page(this)
    class(page_ring_type),intent(inout)::this
    if(this%active_pages(2)-this%active_pages(1)+1>=this%ring_size)call this%enlarge
    this%active_pages(2)=this%active_pages(2)+1
  end subroutine page_ring_activate_next_page
\end{Verbatim}

\TbpImp{page\_ring\_set\_position}
\begin{Verbatim}
  subroutine page_ring_set_position(this,pos)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(2),intent(in)::pos
    this%position_stack%position=pos
  end subroutine page_ring_set_position
\end{Verbatim}

\TbpImp{page\_ring\_put}
\begin{Verbatim}
  subroutine page_ring_put(this)
    class(page_ring_type),intent(inout)::this
  end subroutine page_ring_put
\end{Verbatim}

\TbpImp{page\_ring\_proceed}
\begin{Verbatim}
  subroutine page_ring_proceed(this,n,deactivate)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),intent(in)::n
    logical,intent(in),optional::deactivate
    integer(kind=dik)::offset
    offset=this%position_stack%position(2)+n
    do while (offset>serialize_page_size)
       if(this%position_stack%position(1)&
          >=this%active_pages(2))call this%activate_next_page()
       this%position_stack%position(1)=this%position_stack%position(1)+1
       offset=offset-serialize_page_size
    end do
    this%position_stack%position(2)=offset
    if(present(deactivate))then
       if(deactivate)this%active_pages(1)=this%actual_page()
    end if
  end subroutine page_ring_proceed
\end{Verbatim}

\TbpImp{page\_ring\_print\_position}
\begin{Verbatim}
  subroutine page_ring_print_position(this)
    class(page_ring_type),intent(inout)::this
    print *,&
         this%actual_position(),&
         this%ring(this%actual_index())(:this%actual_offset()-1),&
         "|",&
         this%ring(this%actual_index())(this%actual_offset():)
  end subroutine page_ring_print_position
\end{Verbatim}
  
\TbpImp{page\_ring\_ring\_index}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_ring_index(this,n)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),intent(in)::n
    page_ring_ring_index=mod(n,this%ring_size)
  end function page_ring_ring_index
\end{Verbatim}

\TbpImp{page\_ring\_ring\_push\_given\_position}
\begin{Verbatim}
  subroutine page_ring_ring_push_given_position(this,pos)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(2),intent(in)::pos
    call this%position_stack%push(pos)
  end subroutine page_ring_ring_push_given_position
\end{Verbatim}

\TbpImp{page\_ring\_ring\_pop\_actual\_position}
\begin{Verbatim}
  subroutine page_ring_ring_pop_actual_position(this)
    class(page_ring_type),intent(inout)::this
    call this%position_stack%pop()
  end subroutine page_ring_ring_pop_actual_position
\end{Verbatim}

\TbpImp{page\_ring\_ring\_push\_actual\_position}
\begin{Verbatim}
  subroutine page_ring_ring_push_actual_position(this)
    class(page_ring_type),intent(inout)::this
    call this%position_stack%push()
  end subroutine page_ring_ring_push_actual_position
\end{Verbatim}

\TbpImp{page\_ring\_ring\_pop\_given\_position}
\begin{Verbatim}
  subroutine page_ring_ring_pop_given_position(this,pos)
    class(page_ring_type),intent(inout)::this
    integer(kind=dik),dimension(2),intent(out)::pos
    call this%position_stack%pop(pos)
  end subroutine page_ring_ring_pop_given_position
\end{Verbatim}

\TbpImp{page\_ring\_get\_position1}
\begin{Verbatim}
  pure subroutine page_ring_get_position1(this,pos)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),intent(out)::pos
    pos=page_ring_ordinal(this%position_stack%position)
  end subroutine page_ring_get_position1
\end{Verbatim}

\TbpImp{page\_ring\_get\_position2}
\begin{Verbatim}
  pure subroutine page_ring_get_position2(this,pos)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2),intent(out)::pos
    pos=this%position_stack%position
  end subroutine page_ring_get_position2
\end{Verbatim}

\TbpImp{page\_ring\_actual\_index}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_actual_index(this)
    class(page_ring_type),intent(in)::this
    page_ring_actual_index=mod(this%position_stack%position(1),this%ring_size)
  end function page_ring_actual_index
\end{Verbatim}

\TbpImp{page\_ring\_actual\_page}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_actual_page(this)
    class(page_ring_type),intent(in)::this
    page_ring_actual_page=this%position_stack%position(1)
  end function page_ring_actual_page
\end{Verbatim}

\TbpImp{page\_ring\_actual\_offset}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_actual_offset(this)
    class(page_ring_type),intent(in)::this
    page_ring_actual_offset=this%position_stack%position(2)
  end function page_ring_actual_offset
\end{Verbatim}

\TbpImp{page\_ring\_actual\_position}
\begin{Verbatim}
  pure function page_ring_actual_position(this)
    class(page_ring_type),intent(in)::this
    integer(kind=dik),dimension(2)::page_ring_actual_position
    page_ring_actual_position=this%position_stack%position
  end function page_ring_actual_position
\end{Verbatim}
 
\TbpImp{page\_ring\_first\_index}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_first_index(this)
    class(page_ring_type),intent(in)::this
    page_ring_first_index=mod(this%active_pages(1),this%ring_size)
  end function page_ring_first_index
\end{Verbatim}

\TbpImp{page\_ring\_first\_page}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_first_page(this)
    class(page_ring_type),intent(in)::this
    page_ring_first_page=this%active_pages(1)
  end function page_ring_first_page
\end{Verbatim}

\TbpImp{page\_ring\_last\_index}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_last_index(this)
    class(page_ring_type),intent(in)::this
    page_ring_last_index=mod(this%active_pages(2),this%ring_size)
  end function page_ring_last_index
\end{Verbatim}

\TbpImp{page\_ring\_last\_page}
\begin{Verbatim}
  elemental integer(kind=dik) function page_ring_last_page(this)
    class(page_ring_type),intent(in)::this
    page_ring_last_page=this%active_pages(2)
  end function page_ring_last_page
\end{Verbatim}
\MethodsFor{marker\_type}

\TbpImp{marker\_mark\_begin}
\begin{Verbatim}
  subroutine marker_mark_begin(this,tag,type,name,target,pointer,shape)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::tag
    character(*),intent(in),optional::type,name
    integer(kind=dik),intent(in),optional::target,pointer
    integer,intent(in),dimension(:),optional::shape
    call this%indent()
    call this%push("<")
    call this%push(tag)
    if(present(type))call this%push(' type="'//type//'"')
    if(present(name))call this%push(' name="'//name//'"')
    if(present(target))then
       call this%push(' target="')
       call this%push(target)
       call this%push('"')
    end if
    if(present(pointer))then
       call this%push(' pointer="')
       call this%push(pointer)
       call this%push('"')
    end if
    if(present(shape))then
       call this%push(' shape="')
       call this%push(shape)
       call this%push('"')
    end if
    call this%push(">")
    this%indentation=this%indentation+1
  end subroutine marker_mark_begin
\end{Verbatim}

\TbpImp{marker\_mark\_instance\_begin}
\begin{Verbatim}
  subroutine marker_mark_instance_begin(this,ser,name,target,pointer,shape)
    class(marker_type),intent(inout)::this
    class(serializable_class),intent(in)::ser
    character(*),intent(in)::name
    integer(kind=dik),intent(in),optional::target,pointer
    integer,intent(in),dimension(:),optional::shape
    character(:),allocatable::this_type
    call ser%get_type(this_type)
    call this%mark_begin("ser",this_type,name,target,pointer,shape)
  end subroutine marker_mark_instance_begin
\end{Verbatim}

\TbpImp{marker\_mark\_end}
\begin{Verbatim}
  subroutine marker_mark_end(this,tag)
    class(marker_type),intent(inout)::this
    character(*),intent(in),optional::tag
    this%indentation=this%indentation-1
    call this%indent()
    if(present(tag))then
       call this%push("</"//tag//">")
    else
       call this%push("</ser>")
    end if
  end subroutine marker_mark_end
\end{Verbatim}

\TbpImp{marker\_mark\_instance\_end}
\begin{Verbatim}
  subroutine marker_mark_instance_end(this)
    class(marker_type),intent(inout)::this
    call this%mark_end("ser")
  end subroutine marker_mark_instance_end
\end{Verbatim}

\TbpImp{marker\_mark\_logical}
\begin{Verbatim}
  subroutine marker_mark_logical(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    logical,intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    if(content)then
       call this%push("T")
    else
       call this%push("F")
    end if
    call this%push("</"//name//">")
  end subroutine marker_mark_logical
\end{Verbatim}

\TbpImp{marker\_mark\_integer}
\begin{Verbatim}
  subroutine marker_mark_integer(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_integer
\end{Verbatim}

\TbpImp{marker\_mark\_integer\_array}
\begin{Verbatim}
  subroutine marker_mark_integer_array(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,dimension(:),intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_integer_array
\end{Verbatim}

\TbpImp{marker\_mark\_integer\_matrix}
\begin{Verbatim}
  subroutine marker_mark_integer_matrix(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,dimension(:,:),intent(in)::content
    integer::n
    integer,dimension(2)::s
    s=shape(content)
    call this%indent()
    call this%push("<"//name//">")
    do n=1,s(2)
       call this%push(content(:,n))
       call this%push(" ")
    end do
    call this%push("</"//name//">")
  end subroutine marker_mark_integer_matrix
\end{Verbatim}

\TbpImp{marker\_mark\_integer\_dik}
\begin{Verbatim}
  subroutine marker_mark_integer_dik(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_integer_dik
\end{Verbatim}

\TbpImp{marker\_mark\_integer\_array\_dik}
\begin{Verbatim}
  subroutine marker_mark_integer_array_dik(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),dimension(:),intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_integer_array_dik
\end{Verbatim}

\TbpImp{marker\_mark\_integer\_matrix\_dik}
\begin{Verbatim}
  subroutine marker_mark_integer_matrix_dik(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),dimension(:,:),intent(in)::content
    integer::n
    integer,dimension(2)::s
    call this%indent()
    call this%push("<"//name//">")
    do n=1,s(2)
       call this%push(content(:,n))
       call this%push(" ")
    end do
    call this%push("</"//name//">")
  end subroutine marker_mark_integer_matrix_dik
\end{Verbatim}

\TbpImp{marker\_mark\_double}
\begin{Verbatim}
  subroutine marker_mark_double(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_double
\end{Verbatim}

\TbpImp{marker\_mark\_double\_array}
\begin{Verbatim}
  subroutine marker_mark_double_array(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),dimension(:),intent(in)::content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_double_array
\end{Verbatim}

\TbpImp{marker\_mark\_double\_matrix}
\begin{Verbatim}
  subroutine marker_mark_double_matrix(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),dimension(:,:),intent(in)::content
    integer::n
    integer,dimension(2)::s
    s=shape(content)
    call this%indent()
    call this%push("<"//name//">")
    do n=1,s(2)
       call this%push(content(:,n))
       call this%push(" ")
    end do
    call this%push("</"//name//">")
  end subroutine marker_mark_double_matrix
\end{Verbatim}

\TbpImp{marker\_mark\_string}
\begin{Verbatim}
  subroutine marker_mark_string(this,name,content)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name,content
    call this%indent()
    call this%push("<"//name//">")
    call this%push(content)
    call this%push("</"//name//">")
  end subroutine marker_mark_string
\end{Verbatim}

\TbpImp{marker\_mark\_instance}
\begin{Verbatim}
  recursive subroutine marker_mark_instance(this,ser,name,target,pointer)
    class(marker_type),intent(inout)::this
    class(serializable_class),intent(in)::ser
    character (len=*), intent(in)::name
    integer(kind=dik),intent(in),optional::target,pointer
    integer(kind=dik)::status
    call this%mark_instance_begin(ser,name,target,pointer)
    call ser%write_to_marker(this,status)
    call this%mark_end("ser")
  end subroutine marker_mark_instance
\end{Verbatim}

\TbpImp{marker\_mark\_target}
\begin{Verbatim}
  recursive subroutine marker_mark_target(this,name,ser)
    class(marker_type),intent(inout)::this
    class(serializable_class),target,intent(in)::ser
    character (len=*), intent(in)::name
    this%n_instances=this%n_instances+1
    call this%push_heap(ser,this%n_instances)
    call this%mark_instance(ser,name,target=this%n_instances)
  end subroutine marker_mark_target
\end{Verbatim}

\TbpImp{marker\_mark\_allocatable}
\begin{Verbatim}
  subroutine marker_mark_allocatable(this,name,ser)
    class(marker_type),intent(inout)::this
    class(serializable_class),allocatable,intent(in)::ser
    character (len=*), intent(in)::name
    if(allocated(ser))then
       call this%mark_instance(ser,name)
    else
       call this%mark_null(name)
    end if
  end subroutine marker_mark_allocatable
\end{Verbatim}

\TbpImp{marker\_mark\_pointer}
\begin{Verbatim}
  recursive subroutine marker_mark_pointer(this,name,ser)
    class(marker_type),intent(inout)::this
    class(serializable_class),pointer,intent(in)::ser
    character(len=*),intent(in)::name
    character(:),allocatable::type
    integer(kind=dik)::p
    if(associated(ser))then
       call this%search_heap(ser,p)
       if(p>0)then
          call ser%get_type(type)
          call this%push('<ser type="')
          call this%push(type)
          call this%push('" name="')
          call this%push(name)
          call this%push('" pointer="')
          call this%push(p)
          call this%push('"/>')
       else
          call this%mark_target(name,ser)
       end if
    else
       call this%mark_null(name)
    end if
  end subroutine marker_mark_pointer
\end{Verbatim}

\TbpImp{marker\_mark\_null}
\begin{Verbatim}
  subroutine marker_mark_null(this,name)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    call this%indent()
    call this%push('<ser type="null" name="')
    call this%push(name)
    call this%push('"/>')
  end subroutine marker_mark_null
\end{Verbatim}

\TbpImp{marker\_mark\_nothing}
\begin{Verbatim}
  subroutine marker_mark_nothing(this,name)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    call this%indent()
    call this%push('<')
    call this%push(name)
    call this%push('/>')
  end subroutine marker_mark_nothing
\end{Verbatim}

\TbpImp{marker\_mark\_empty}
\begin{Verbatim}
  subroutine marker_mark_empty(this,tag,type,name,target,pointer,shape)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::tag
    character(*),intent(in),optional::type,name
    integer(kind=dik),intent(in),optional::target,pointer
    integer,intent(in),dimension(:),optional::shape
    call this%push("<")
    call this%push(tag)
    if(present(type))call this%push(' type="'//type//'"')
    if(present(name))call this%push(' name="'//name//'"')
    if(present(target))then
       call this%push(' target="')
       call this%push(target)
       call this%push('"')
    end if
    if(present(pointer))then
       call this%push(' pointer="')
       call this%push(pointer)
       call this%push('"')
    end if
    if(present(shape))then
       call this%push(' shape="')
       call this%push(shape)
       call this%push('"')
    end if
    call this%push("/>")
  end subroutine marker_mark_empty
\end{Verbatim}

\TbpImp{marker\_pick\_begin}
\begin{Verbatim}
  subroutine marker_pick_begin(this,tag,type,name,target,pointer,shape,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::tag
    integer(kind=dik),dimension(2,2),intent(out),optional::type,name
    integer(kind=dik),intent(out),optional::target,pointer
    integer,dimension(:),allocatable,optional,intent(out)::shape
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2)::p1,p2,p3
    integer(kind=dik)::l
    call this%find("<",skip=4,proceed=.true.,pos=p1)
    call this%find(">",skip=1,proceed=.false.,pos=p2)
    p3=this%find_pure(" ",p1,p2,skip=1)
    if(p3(2)>0)then
       if(this%substring(p1,p3)==tag)then
          status=serialize_ok
          if(present(type))then
             call this%substring_by_keys('type="','"',p3,p2,.false.,l,type)
             if(l<=0)then
                print *,"marker_pick_begin: No type found"
                status=serialize_wrong_type
             end if
          end if
          if(present(name))then
             call this%substring_by_keys('name="','"',p3,p2,.false.,l,name)
             if(l<=0)then
                print *,"marker_pick_begin: No name found"
                status=serialize_wrong_name
                call this%print_position()
                stop
             end if
          end if
          if(present(target))then
             p1=this%find_pure('target="',p3,p2,4)
             if(p1(2)>0)then
                call this%set_position(p1)
                call this%pop(target)
             else
                target=-1
                status=serialize_ok
             end if
          end if
          if(present(pointer))then
             p1=this%find_pure('pointer="',p3,p2,4)
             if(p1(2)>0)then
                call this%set_position(p1)
                call this%pop(pointer)
             else
                pointer=-1
                status=serialize_ok
             end if
          end if
          if(present(shape))then
             p1=this%find_pure('shape="',p3,p2,4)
             if(p1(2)>0)then
                call this%set_position(p1)
                call this%pop(shape)
             else
                status=serialize_ok
             end if
          end if
       else
          print *,"marker_pick_begin: Wrong tag. Expected: "&
          ,tag," Found: ",this%substring(p1,p3)
          status=serialize_wrong_tag
          call this%print_position()
       end if
    else
       if(this%substring(p1,p2)==tag)then
          status=serialize_ok
       else
          print *,"marker_pick_begin: Wrong tag. Expected: "&
          ,tag," Found: ",this%substring(p1,p2)
          status=serialize_wrong_tag
       end if
    end if
    call this%set_position(p2)
    call this%proceed(one*2,.true.)
  end subroutine marker_pick_begin
\end{Verbatim}

\TbpImp{marker\_query\_instance\_begin}
\begin{Verbatim}
  subroutine marker_query_instance_begin(this,type,name,target,pointer,shape,status)
    class(marker_type),intent(inout)::this
    integer(kind=dik),dimension(2,2),intent(out),optional::type,name
    integer(kind=dik),intent(out),optional::target,pointer
    integer,dimension(:),allocatable,optional,intent(out)::shape
    integer(kind=dik),intent(out)::status
    call this%pick_begin("ser",type,name,target,pointer,shape,status)
  end subroutine marker_query_instance_begin
\end{Verbatim}

\TbpImp{marker\_pick\_instance\_begin}
\begin{Verbatim}
  subroutine marker_pick_instance_begin(this,name,type,target,pointer,shape,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),dimension(2,2),intent(out),optional::type
    integer(kind=dik),intent(out),optional::target,pointer
    integer,dimension(:),allocatable,optional,intent(out)::shape
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2,2)::read_name
    call this%query_instance_begin(type,read_name,target,pointer,shape,status)
    if(status==serialize_ok)then
       if(.not.this%str_equal(name,read_name))status=serialize_wrong_name
    end if
  end subroutine marker_pick_instance_begin
\end{Verbatim}

\TbpImp{marker\_pick\_end}
\begin{Verbatim}
  subroutine marker_pick_end(this,tag,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::tag
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2)::p1,p2
    call this%find("</",skip=4,proceed=.true.,pos=p1)
    call this%find(">",skip=1,proceed=.false.,pos=p2)
    if(tag==this%substring(p1,p2))then
       status=serialize_ok
    else
       print *,"marker_pick_end: Wrong tag. Expected: ",tag," Found: ",this%substring(p1,p2)
       print *,"p1=",p1,"p2=",p2
       call this%print_position()
    end if
    call this%set_position(p2)
    call this%proceed(one*2,.true.)
  end subroutine marker_pick_end
\end{Verbatim}

\TbpImp{marker\_pick\_instance\_end}
\begin{Verbatim}
  subroutine marker_pick_instance_end(this,status)
    class(marker_type),intent(inout)::this
    integer(kind=dik),intent(out)::status
    call this%pick_end("ser",status)
  end subroutine marker_pick_instance_end
\end{Verbatim}

\TbpImp{marker\_pick\_instance}
\begin{Verbatim}
  subroutine marker_pick_instance(this,name,ser,status)
    class(marker_type),intent(inout)::this
    class(serializable_class),intent(out)::ser
    character(*),intent(in)::name
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2,2)::type,r_name
    call this%pick_begin("ser",type,r_name,status=status)
    if(status==serialize_ok)then
       if(ser%verify_type(this%substring(type)))then
          if(this%str_equal(name,r_name))then
             call ser%read_from_marker(this,status)
             call this%pick_end("ser",status)
          else
             print *,"marker_pick_instance: Name mismatch: Expected: "&
             ,name," Found: ",r_name
             status=serialize_wrong_name
             call this%print_position
          end if
       else
          print *,"marker_pick_instance: Type mismatch: ",type
          call ser%write_type(output_unit)
          print *,""
          status=serialize_wrong_type
          call this%print_position
       end if
    end if
  end subroutine marker_pick_instance
\end{Verbatim}

\TbpImp{marker\_pick\_target}
\begin{Verbatim}
  subroutine marker_pick_target(this,name,ser,status)
    class(marker_type),intent(inout)::this
    class(serializable_class),target,intent(out)::ser
    character(*),intent(in)::name
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2,2)::type,r_name
    integer(kind=dik)::target
    call this%pick_begin("ser",type,r_name,target,status=status)
    if(status==serialize_ok)then
       if(ser%verify_type(this%substring(type)))then
          if(this%str_equal(name,r_name))then
             call ser%read_target_from_marker(this,status)
             if(target>0)call this%push_heap(ser,target)
          else
             print *,"marker_pick_instance: Name mismatch: Expected: "&
             ,name," Found: ",r_name
             status=serialize_wrong_name
          end if
       else
          print *,"marker_pick_instance: Type mismatch: ",type
          status=serialize_wrong_type
       end if
    end if
    call this%pick_end("ser",status)
  end subroutine marker_pick_target
\end{Verbatim}

\TbpImp{marker\_pick\_allocatable}
\begin{Verbatim}
  subroutine marker_pick_allocatable(this,name,ser)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    class(serializable_class),allocatable,intent(out)::ser
    class(serializable_class),pointer::ref
    integer(kind=dik),dimension(2,2)::type,r_name
    integer(kind=dik)::status
    call this%pick_begin("ser",type,r_name,status=status)
    if(status==serialize_ok)then
       if(ser%verify_type(this%substring(type)))then
          if(this%str_equal(name,r_name))then
             call this%search_reference(type,ref)
             if(associated(ref))then
                allocate(ser,source=ref)
                call ser%read_from_marker(this,status)
             else
                print *,"marker_pick_allocatable:&
                     & Type ",type," not found on reference stack."
             end if
          else
             print *,"marker_pick_instance: Name mismatch: Expected: ",&
             name," Found: ",r_name
             status=serialize_wrong_name
          end if
       else
          print *,"marker_pick_instance: Type mismatch: ",type
          status=serialize_wrong_type
       end if
    end if
    call this%pick_end("ser",status)
  end subroutine marker_pick_allocatable
\end{Verbatim}

\TbpImp{marker\_pick\_pointer}
\begin{Verbatim}
  recursive subroutine marker_pick_pointer(this,name,ser)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    class(serializable_class),pointer,intent(out)::ser
    class(serializable_class),pointer::ref
    integer(kind=dik),dimension(2,2)::type,r_name
    integer(kind=dik)::status,t,p
    nullify(ser)
    call this%pick_begin("ser",type,r_name,target=t,pointer=p,status=status)
    if(status==serialize_ok)then
       if(.not.this%str_equal("null",type))then
          if(p>0)then
             call this%search_heap(p,ser)
          else
             call this%search_reference(type,ref)
             if(associated(ref))then
                allocate(ser,source=ref)
                call ser%read_target_from_marker(this,status)
                call this%pick_end("ser",status)
                if(t>0)call this%push_heap(ser,t)
             else
                print *,"marker_pick_pointer:&
                     & Type ",type," not found on reference stack."
             end if
          end if
       end if
    end if
  end subroutine marker_pick_pointer
\end{Verbatim}

\TbpImp{marker\_pick\_logical}
\begin{Verbatim}
  subroutine marker_pick_logical(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    logical,intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_logical
\end{Verbatim}

\TbpImp{marker\_pick\_integer}
\begin{Verbatim}
  subroutine marker_pick_integer(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer
\end{Verbatim}

\TbpImp{marker\_pick\_integer\_array}
\begin{Verbatim}
  subroutine marker_pick_integer_array(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,dimension(:),intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer_array
\end{Verbatim}

\TbpImp{marker\_pick\_integer\_matrix}
\begin{Verbatim}
  subroutine marker_pick_integer_matrix(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer,dimension(:,:),intent(out)::content
    integer(kind=dik),intent(out)::status
    integer::n
    integer,dimension(2)::s
    s=shape(content)
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       do n=1,s(2)
          call this%pop(content(:,n))
       end do
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer_matrix
\end{Verbatim}

\TbpImp{marker\_pick\_integer\_dik}
\begin{Verbatim}
  subroutine marker_pick_integer_dik(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer_dik
\end{Verbatim}

\TbpImp{marker\_pick\_integer\_array\_dik}
\begin{Verbatim}
  subroutine marker_pick_integer_array_dik(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),dimension(:),intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer_array_dik
\end{Verbatim}

\TbpImp{marker\_pick\_integer\_matrix\_dik}
\begin{Verbatim}
  subroutine marker_pick_integer_matrix_dik(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),dimension(:,:),intent(out)::content
    integer(kind=dik),intent(out)::status
    integer::n
    integer,dimension(2)::s
    s=shape(content)
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       do n=1,s(2)
          call this%pop(content(:,n))
       end do
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_integer_matrix_dik
\end{Verbatim}

\TbpImp{marker\_pick\_double}
\begin{Verbatim}
  subroutine marker_pick_double(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_double
\end{Verbatim}

\TbpImp{marker\_pick\_double\_array}
\begin{Verbatim}
  subroutine marker_pick_double_array(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),dimension(:),intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_double_array
\end{Verbatim}

\TbpImp{marker\_pick\_double\_matrix}
\begin{Verbatim}
  subroutine marker_pick_double_matrix(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    real(kind=drk),dimension(:,:),intent(out)::content
    integer(kind=dik),intent(out)::status
    integer::n
    integer,dimension(2)::s
    s=shape(content)
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       do n=1,s(2)
          call this%pop(content(:,n))
       end do
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_double_matrix
\end{Verbatim}

\TbpImp{marker\_pick\_string}
\begin{Verbatim}
  subroutine marker_pick_string(this,name,content,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    character(:),allocatable,intent(out)::content
    integer(kind=dik),intent(out)::status
    call this%pick_begin(name,status=status)
    if(status==serialize_ok)then
       call this%pop(content)
       call this%pick_end(name,status)
    end if
  end subroutine marker_pick_string
\end{Verbatim}
  
\TbpImp{marker\_verify\_nothing}
\begin{Verbatim}
  subroutine marker_verify_nothing(this,name,status)
    class(marker_type),intent(inout)::this
    character(*),intent(in)::name
    integer(kind=dik),intent(out)::status
    integer(kind=dik),dimension(2)::p1,p2
    call this%find("<",skip=4,proceed=.false.,pos=p1)
    call this%find(">",1,.false.,p2)
    if(name//"/"==this%substring(p1,p2))then
       status=serialize_nothing
       call this%set_position(p2)
       call this%proceed(one*3,.true.)
    else
       if(name==this%substring(p1,p2))then
          status=serialize_ok
       else
          status=serialize_wrong_tag
       end if
    end if
  end subroutine marker_verify_nothing
\end{Verbatim}

\TbpImp{marker\_indent}
\begin{Verbatim}
  subroutine marker_indent(this,step)
    class(marker_type),intent(inout)::this
    integer(kind=dik),optional::step
    if(this%do_break)call this%push(new_line(" "))
    if(this%do_indent)then
       if(present(step))this%indentation=this%indentation+step
       call this%push(repeat(" ",this%indentation))
    end if
    this%active_pages(1)=this%actual_page()
  end subroutine marker_indent
\end{Verbatim}

\TbpImp{marker\_push\_heap}
\begin{Verbatim}
  subroutine marker_push_heap(this,ser,id)
    class(marker_type),intent(inout)::this
    class(serializable_class),target,intent(in)::ser
    integer(kind=dik),intent(in)::id
    class(serializable_ref_type),pointer::new_ref
    allocate(new_ref)
    new_ref%next=>this%heap
    new_ref%ref=>ser
    new_ref%id=id
    this%heap=>new_ref
  end subroutine marker_push_heap
\end{Verbatim}
  
\TbpImp{marker\_pop\_heap}
\begin{Verbatim}
  subroutine marker_pop_heap(this,ser)
    class(marker_type),intent(inout)::this
    class(serializable_class),pointer,intent(out)::ser
    class(serializable_ref_type),pointer::old_ref
    if(associated(this%heap))then
       old_ref=>this%heap
       ser=>old_ref%ref
       this%heap=>this%heap%next
       deallocate(old_ref)
    else
       print('("marker_pop_heap: heap_stack is not associated.")')
    end if
  end subroutine marker_pop_heap
\end{Verbatim}

\TbpImp{marker\_search\_heap\_by\_id}
\begin{Verbatim}
  subroutine marker_search_heap_by_id(this,id,ser)
    class(marker_type),intent(in)::this
    integer(kind=dik),intent(in)::id
    class(serializable_class),pointer,intent(out)::ser
    class(serializable_ref_type),pointer::ref
    ref=>this%heap
    do while(associated(ref))
       if(id==ref%id)then
          ser=>ref%ref
          exit
       end if
       ref=>ref%next
    end do
  end subroutine marker_search_heap_by_id
\end{Verbatim}

\TbpImp{marker\_search\_heap\_by\_ref}
\begin{Verbatim}
  subroutine marker_search_heap_by_ref(this,ref,id)
    class(marker_type),intent(in)::this
    class(serializable_class),pointer,intent(in)::ref
    integer(kind=dik),intent(out)::id
    class(serializable_ref_type),pointer::ref_p
    ref_p=>this%heap
    id=0
    do while(associated(ref_p))
       if(associated(ref,ref_p%ref))then
          id=ref_p%id
          exit
       end if
       ref_p=>ref_p%next
    end do
  end subroutine marker_search_heap_by_ref
\end{Verbatim}

\TbpImp{marker\_push\_reference}
\begin{Verbatim}
  subroutine marker_push_reference(this,ser,id)
    class(marker_type),intent(inout)::this
    class(serializable_class),target,intent(in)::ser
    integer(kind=dik),intent(in),optional::id
    class(serializable_ref_type),pointer::new_ref
    allocate(new_ref)
    new_ref%next=>this%references
    new_ref%ref=>ser
    if(present(id))then
       new_ref%id=id
    else
       new_ref%id=-1
    end if
    this%references=>new_ref
  end subroutine marker_push_reference
\end{Verbatim}
  
\TbpImp{marker\_pop\_reference}
\begin{Verbatim}
  subroutine marker_pop_reference(this,ser)
    class(marker_type),intent(inout)::this
    class(serializable_class),pointer,intent(out)::ser
    class(serializable_ref_type),pointer::old_ref
    if(associated(this%references))then
       old_ref=>this%references
       ser=>old_ref%ref
       this%references=>this%references%next
       deallocate(old_ref)
    else
       print('("marker_pop_reference: reference_stack is not associated.")')
    end if
  end subroutine marker_pop_reference
\end{Verbatim}

\TbpImp{marker\_search\_reference}
\begin{Verbatim}
  subroutine marker_search_reference(this,type,ser)
    class(marker_type),intent(in)::this
    integer(kind=dik),dimension(2,2),intent(in)::type
    class(serializable_class),pointer,intent(out)::ser
    class(serializable_class),pointer::tmp_ser!nag bug workaround
    class(serializable_ref_type),pointer::ref
    ref=>this%references
    nullify(ser)
    do while(associated(ref))
       tmp_ser=>ref%ref
       if(tmp_ser%verify_type(this%substring(type)))then
          ser=>tmp_ser
          exit
       end if
       ref=>ref%next
    end do
  end subroutine marker_search_reference
\end{Verbatim}

\TbpImp{marker\_reset\_heap}
\begin{Verbatim}
  subroutine marker_reset_heap(this)
    class(marker_type),intent(inout)::this
    if(associated(this%heap))then
       call this%heap%finalize()
       deallocate(this%heap)
    end if
  end subroutine marker_reset_heap
\end{Verbatim}

\TbpImp{marker\_reset\_references}
\begin{Verbatim}
  subroutine marker_reset_references(this)
    class(marker_type),intent(inout)::this
    if(associated(this%references))then
       call this%references%finalize()
       deallocate(this%references)
    end if
  end subroutine marker_reset_references
\end{Verbatim}

\TbpImp{marker\_finalize}
\begin{Verbatim}
  subroutine marker_finalize(this)
    class(marker_type),intent(inout)::this
    call this%reset_heap()
    call this%reset_references()
  end subroutine marker_finalize
\end{Verbatim}
\MethodsNTB
\ProcImp{serialize\_print\_comp\_pointer}
\begin{Verbatim}
  recursive subroutine serialize_print_comp_pointer(ser,unit,parents,components,peers,name)
    class(serializable_class),pointer,intent(in)::ser
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    character(len=*),intent(in)::name
    if(associated(ser))then
       write(unit,fmt=*)name," is associated."
       if(components>0)then
          write(unit,fmt=*)"Printing components of ",name
          call ser%print_to_unit(unit,parents,components-one,peers)
       else
          write(unit,fmt=*)"Skipping components of ",name
       end if
    else
       write(unit,fmt=*)name," is not associated."
    end if
  end subroutine serialize_print_comp_pointer
\end{Verbatim}

\ProcImp{serialize\_print\_peer\_pointer}
\begin{Verbatim}
  recursive subroutine serialize_print_peer_pointer(ser,unit,parents,components,peers,name)
    class(serializable_class),pointer,intent(in)::ser
    integer,intent(in)::unit
    integer(kind=dik)::parents,components,peers
    character(len=*),intent(in)::name
    if(associated(ser))then
       write(unit,fmt=*)name," is associated."
       if(peers>0)then
          write(unit,fmt=*)"Printing components of ",name
          call ser%print_to_unit(unit,parents,components,peers-one)
       else
          write(unit,fmt=*)"Skipping components of ",name
       end if
    else
       write(unit,fmt=*)name," is not associated."
    end if
  end subroutine serialize_print_peer_pointer
\end{Verbatim}

\ProcImp{serialize\_print\_allocatable}
\begin{Verbatim}
  subroutine serialize_print_allocatable(ser,unit,parents,components,peers,name)
    class(serializable_class),allocatable,intent(in)::ser
    integer,intent(in)::unit
    integer(kind=dik),intent(in)::parents,components,peers
    character(len=*),intent(in)::name
    if(allocated(ser))then
       write(unit,fmt=*)name," is allocated."
       if(components>0)then
          write(unit,fmt=*)"Printing components of ",name
          call ser%print_to_unit(unit,parents,components-1,peers)
       else
          write(unit,fmt=*)"Skipping components of ",name
       end if
    else
       write(unit,fmt=*)name," is not allocated."
    end if
  end subroutine serialize_print_allocatable
\end{Verbatim}

\ProcImp{measurable\_less\_measurable}
\begin{Verbatim}
  elemental function measurable_less_measurable(mea1,mea2)
    class(measurable_class),intent(in)::mea1,mea2
    logical::measurable_less_measurable
    measurable_less_measurable=mea1%measure()<mea2%measure()
  end function measurable_less_measurable
\end{Verbatim}
  
\ProcImp{measurable\_less\_double}
\begin{Verbatim}
  elemental function measurable_less_double(mea1,dou)
    class(measurable_class),intent(in)::mea1
    real(kind=drk),intent(in)::dou
    logical::measurable_less_double
    measurable_less_double=mea1%measure()<dou
  end function measurable_less_double
\end{Verbatim}
  
\ProcImp{measurable\_less\_or\_equal\_measurable}
\begin{Verbatim}
  elemental function measurable_less_or_equal_measurable(mea1,mea2)
    class(measurable_class),intent(in)::mea1,mea2
    logical::measurable_less_or_equal_measurable
    measurable_less_or_equal_measurable=mea1%measure()<=mea2%measure()
  end function measurable_less_or_equal_measurable
\end{Verbatim}

\ProcImp{measurable\_less\_or\_equal\_double}
\begin{Verbatim}
   elemental function measurable_less_or_equal_double(mea1,dou)
    class(measurable_class),intent(in)::mea1
    real(kind=drk),intent(in)::dou
    logical::measurable_less_or_equal_double
    measurable_less_or_equal_double=mea1%measure()<=dou
  end function measurable_less_or_equal_double
\end{Verbatim}

\ProcImp{measurable\_equal\_measurable}
\begin{Verbatim}
 elemental function measurable_equal_measurable(mea1,mea2)
    class(measurable_class),intent(in)::mea1,mea2
    logical::measurable_equal_measurable
    measurable_equal_measurable=mea1%measure()==mea2%measure()
  end function measurable_equal_measurable
\end{Verbatim}

\ProcImp{measurable\_equal\_double}
\begin{Verbatim}
  elemental function measurable_equal_double(mea1,dou)
    class(measurable_class),intent(in)::mea1
    real(kind=drk),intent(in)::dou
    logical::measurable_equal_double
    measurable_equal_double=mea1%measure()==dou
  end function measurable_equal_double
\end{Verbatim}

\ProcImp{measurable\_equal\_or\_greater\_measurable}
\begin{Verbatim}
  elemental function measurable_equal_or_greater_measurable(mea1,mea2)
    class(measurable_class),intent(in)::mea1,mea2
    logical::measurable_equal_or_greater_measurable
    measurable_equal_or_greater_measurable=mea1%measure()>=mea2%measure()
  end function measurable_equal_or_greater_measurable
\end{Verbatim}

\ProcImp{measurable\_equal\_or\_greater\_double}
\begin{Verbatim}
  elemental function measurable_equal_or_greater_double(mea1,dou)
    class(measurable_class),intent(in)::mea1
    real(kind=drk),intent(in)::dou
    logical::measurable_equal_or_greater_double
    measurable_equal_or_greater_double=mea1%measure()>=dou
  end function measurable_equal_or_greater_double
\end{Verbatim}
  
\ProcImp{measurable\_greater\_measurable}
\begin{Verbatim}
  elemental function measurable_greater_measurable(mea1,mea2)
    class(measurable_class),intent(in)::mea1,mea2
    logical::measurable_greater_measurable
    measurable_greater_measurable=mea1%measure()>mea2%measure()
  end function measurable_greater_measurable
\end{Verbatim}

\ProcImp{measurable\_greater\_double}
\begin{Verbatim}
  elemental function measurable_greater_double(mea1,dou)
    class(measurable_class),intent(in)::mea1
    real(kind=drk),intent(in)::dou
    logical::measurable_greater_double
    measurable_greater_double=mea1%measure()>dou
  end function measurable_greater_double
\end{Verbatim}

\ProcImp{page\_ring\_position}
\begin{Verbatim}
  pure function page_ring_position(n)
    integer(kind=dik),intent(in)::n
    integer(kind=dik),dimension(2)::page_ring_position
    page_ring_position(2)=mod(n,serialize_page_size)
    page_ring_position(1)=(n-page_ring_position(2))/serialize_page_size
  end function page_ring_position
\end{Verbatim}

\ProcImp{page\_ring\_ordinal}
\begin{Verbatim}
  pure integer(kind=dik) function page_ring_ordinal(pos)
    integer(kind=dik),dimension(2),intent(in)::pos
    page_ring_ordinal=pos(1)*serialize_page_size+pos(2)
  end function page_ring_ordinal
\end{Verbatim}

\ProcImp{page\_ring\_position\_is\_before\_int\_pos}
\begin{Verbatim}
  pure logical function page_ring_position_is_before_int_pos(m,n)
    integer(kind=dik),intent(in)::m
    integer(kind=dik),dimension(2),intent(in)::n
    if(m<page_ring_ordinal(n))then
       page_ring_position_is_before_int_pos=.true.
    else
       page_ring_position_is_before_int_pos=.false.
    end if
  end function page_ring_position_is_before_int_pos
\end{Verbatim}

\ProcImp{page\_ring\_position\_is\_before\_pos\_int}
\begin{Verbatim}
  pure logical function page_ring_position_is_before_pos_int(m,n)
    integer(kind=dik),dimension(2),intent(in)::m
    integer(kind=dik),intent(in)::n
    if(page_ring_ordinal(m)<n)then
       page_ring_position_is_before_pos_int=.true.
    else
       page_ring_position_is_before_pos_int=.false.
    end if
  end function page_ring_position_is_before_pos_int
\end{Verbatim}

\ProcImp{page\_ring\_position\_is\_before\_pos\_pos}
\begin{Verbatim}
  pure logical function page_ring_position_is_before_pos_pos(m,n)
    integer(kind=dik),dimension(2),intent(in)::m,n
    if(m(1)<n(1))then
       page_ring_position_is_before_pos_pos=.true.
    else
       if(m(1)>n(1))then
          page_ring_position_is_before_pos_pos=.false.
       else
          if(m(2)<n(2))then
             page_ring_position_is_before_pos_pos=.true.
          else
             page_ring_position_is_before_pos_pos=.false.
          end if
       end if
    end if
  end function page_ring_position_is_before_pos_pos
\end{Verbatim}

\ProcImp{ring\_position\_increase}
\begin{Verbatim}
  subroutine ring_position_increase(pos,n)
    integer(kind=dik),dimension(2),intent(inout)::pos
    integer(kind=dik),intent(in)::n
    pos=page_ring_position(page_ring_ordinal(pos)+n)
  end subroutine ring_position_increase
\end{Verbatim}

\ProcImp{ring\_position\_metric2}
\begin{Verbatim}
  pure integer(kind=dik) function ring_position_metric2(p1,p2)
    integer(kind=dik),dimension(2),intent(in)::p1,p2
    ring_position_metric2=(p2(1)-p1(1))*serialize_page_size+p2(2)-p1(2)+1
  end function ring_position_metric2
\end{Verbatim}

\ProcImp{ring\_position\_metric1}
\begin{Verbatim}
  pure integer(kind=dik) function ring_position_metric1(p)
    integer(kind=dik),dimension(2,2),intent(in)::p
    ring_position_metric1=(p(1,2)-p(1,1))*serialize_page_size+p(2,2)-p(2,1)+1
  end function ring_position_metric1
\end{Verbatim}

\ProcImp{generate\_unit}
\begin{Verbatim}
  subroutine generate_unit(unit,min,max)
    integer,intent(out) :: unit
    integer,intent(in),optional :: min,max
    integer :: min_u,max_u
    logical :: is_open
    !print *,"generate_unit"
    unit = -1
    if(present(min))then
       min_u=min
    else
       min_u=10
    end if
    if(present(max))then
       max_u=max
    else
       max_u=huge(max_u)
    end if
    do unit=min_u,max_u
       !print *,"testing ",unit
       inquire(unit,opened=is_open)
       if (.not. is_open) then
          exit
       end if
    end do
  end subroutine generate_unit
\end{Verbatim}
  
\ProcImp{ilog2}
\begin{Verbatim}
  subroutine ilog2(int,exp,rem)
    integer,intent(in) :: int
    integer,intent(out) :: exp,rem
    integer :: count
    count = 2
    exp = 1
    do while (count<int)
       exp=exp+1
       count = ishft(count,1)
    end do
    if (count>int) then
       rem=(int-ishft(count,-1))
    else
       rem=0
    end if    
  end subroutine ilog2
\end{Verbatim}

\ProcImp{character\_is\_in}
\begin{Verbatim}
  pure logical function character_is_in(c,array)
    character,intent(in)::c
    character,dimension(:),intent(in)::array
    integer(kind=dik)::n
    character_is_in=.false.
    do n=1,size(array)
       if(c==array(n))then
          character_is_in=.true.
          exit
       end if
    end do
  end function character_is_in
\end{Verbatim}

\ProcImp{integer\_with\_leading\_zeros}
\begin{Verbatim}
  subroutine integer_with_leading_zeros(number,length,string)
    integer,intent(in) :: number,length
    character(len=*),intent(out) :: string
    integer :: zeros
    character::sign
    if(number==0)then
       string = repeat("0",length)
    else
       if(number>0)then
          zeros=length-floor(log10(real(number)))-1
          if(zeros<0)then
             string=repeat("*",length)
          else
             write(string,fmt='(a,I0)') repeat("0",zeros),number
          end if
       else
          zeros=length-floor(log10(real(-number)))-2
          if(zeros<0)then
             string=repeat("*",length)
          else
             write(string,fmt='(a,a,I0)') "-",repeat("0",zeros),abs(number)
          end if
       end if
    end if
  end subroutine integer_with_leading_zeros
\end{Verbatim}
