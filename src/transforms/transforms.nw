% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD event transforms and event API

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Event Implementation}

With a process object and the associated methods at hand, we can
generate events for elementary processes and, by subsequent
transformation, for complete physical processes.

We have the following modules:
\begin{description}
\item[event\_transforms]
  Abstract base type for transforming a physical process with process
  instance and included evaluators, etc., into a new
  object.  The following modules extend this base type.
\item[decays]
  Combine the elementary process with elementary decay processes and
  thus transform the elementary event into a decayed event, still at
  the parton level.
\item[showers]
  Create QED/QCD showers out of the partons that are emitted by
  elementary processes.  This should be interleaved with showering of
  radiated particles (structure functions) and multiple interactions.
\item[hadrons]
  (not implemented yet) Apply hadronization to the partonic events,
  interleaved with hadron decays.  (The current setup relies on
  hadronizing partonic events externally.)
\item[tau\_decays]
  (not implemented yet) Let $\tau$ leptons decay taking full spin
  correlations into account. 
\item[events]
  Combine all pieces to generate full events.
\item[eio\_raw]
  Raw I/O for complete events.
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Event Transforms}
<<[[event_transforms.f90]]>>=
<<File header>>

module event_transforms

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use model_data
  use state_matrices
  use interactions
  use particles
  use subevents
  use process_libraries
  use prc_core
  use prc_test
  use rng_base
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use processes
  use process_stacks
  
<<Standard module head>>

<<Event transforms: public>>

<<Event transforms: types>>

<<Event transforms: interfaces>>

contains

<<Event transforms: procedures>>

<<Event transforms: tests>>

end module event_transforms

@ %def event_transforms
@
\subsection{Abstract base type}
Essentially, all methods are abstract, but some get minimal base
versions.  We know that there will be a random-number generator at top
level, and that we will relate to an elementary process.

The model is stored separately.  It may contain modified setting that differ
from the model instance stored in the process object.

Each event transform contains a particle set that it can fill for
further use.  There is a flag that indicates this.

We will collect event transforms in a list, therefore we include
[[previous]] and [[next]] pointers.
<<Event transforms: public>>=
  public :: evt_t
<<Event transforms: types>>=
  type, abstract :: evt_t
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: process_instance => null ()
     class(model_data_t), pointer :: model => null ()
     class(rng_t), allocatable :: rng
     integer :: rejection_count = 0
     logical :: particle_set_exists = .false.
     type(particle_set_t) :: particle_set
     class(evt_t), pointer :: previous => null ()
     class(evt_t), pointer :: next => null ()
     real(default) :: weight = 0._default
     logical :: only_weighted_events = .false.
   contains
   <<Event transforms: evt: TBP>>
  end type evt_t
  
@ %def evt_t
@ Finalizer.  In any case, we finalize the r.n.g.  The process
instance is a pointer and should not be finalized here.
<<Event transforms: evt: TBP>>=
  procedure :: final => evt_final
  procedure :: base_final => evt_final
<<Event transforms: procedures>>=
  subroutine evt_final (evt)
    class(evt_t), intent(inout) :: evt
    if (allocated (evt%rng))  call evt%rng%final ()
    if (evt%particle_set_exists) &
         call evt%particle_set%final ()
  end subroutine evt_final
  
@ %def evt_final
<<Event transforms: evt: TBP>>=
  procedure (evt_write), deferred :: write
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_write (evt, unit, verbose, more_verbose, testflag)
       import
       class(evt_t), intent(in) :: evt
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: verbose, more_verbose, testflag
     end subroutine evt_write
  end interface

@ %def evt_write
@ Output.  We can print r.n.g. info.
<<Event transforms: evt: TBP>>=
  procedure :: base_write => evt_base_write
<<Event transforms: procedures>>=
  subroutine evt_base_write (evt, unit, testflag, show_set)
    class(evt_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag, show_set
    integer :: u
    logical :: show
    u = given_output_unit (unit)
    show = .true.;  if (present (show_set))  show = show_set
    if (associated (evt%process)) then
       write (u, "(3x,A,A,A)")   "Associated process: '", &
            char (evt%process%get_id ()), "'"
    end if
    if (allocated (evt%rng)) then
       call evt%rng%write (u, 1)
       write (u, "(3x,A,I0)")  "Number of tries = ", evt%rejection_count
    end if
    if (show) then
       if (evt%particle_set_exists) then
          call write_separator (u)
          call evt%particle_set%write (u, testflag = testflag)
       end if
    end if
  end subroutine evt_base_write
  
@ %def evt_base_write
@ Connect the transform with a process instance (and thus with the
associated process).  Use this to allocate the master random-number
generator.

This is not an initializer; we may initialize the transform by
implementation-specific methods.
<<Event transforms: evt: TBP>>=
  procedure :: connect => evt_connect
  procedure :: base_connect => evt_connect
<<Event transforms: procedures>>=
  subroutine evt_connect (evt, process_instance, model, process_stack)
    class(evt_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    evt%process => process_instance%process
    evt%process_instance => process_instance
    evt%model => model
    call evt%process%make_rng (evt%rng)
  end subroutine evt_connect
  
@ %def evt_connect
@ Reset internal state.
<<Event transforms: evt: TBP>>=
  procedure :: reset => evt_reset
  procedure :: base_reset => evt_reset
<<Event transforms: procedures>>=
  subroutine evt_reset (evt)
    class(evt_t), intent(inout) :: evt
    evt%rejection_count = 0
    evt%particle_set_exists = .false.
  end subroutine evt_reset
  
@ %def evt_reset
@ Prepare for a new event: reset internal state, if necessary.  We
provide MCI and term index of the parent process.
<<Event transforms: evt: TBP>>=
  procedure (evt_prepare_new_event), deferred :: prepare_new_event
<<Event transforms: interfaces>>=
  interface
     subroutine evt_prepare_new_event (evt, i_mci, i_term)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: i_mci, i_term
     end subroutine evt_prepare_new_event
  end interface
       
@ %def evt_prepare_new_event
@ Generate a weighted event, using a valid initiator event in the
process instance, and the random-number generator.  The returned event
probability should be a number between zero and one that we can use for
rejection.
<<Event transforms: evt: TBP>>=
  procedure (evt_generate_weighted), deferred :: generate_weighted
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_generate_weighted (evt, probability)
       import
       class(evt_t), intent(inout) :: evt
       real(default), intent(inout) :: probability
     end subroutine evt_generate_weighted
  end interface
  
@ %def evt_generate_weighted
@ The unweighted event generation routine is actually implemented.  It
uses the random-number generator for simple rejection.  Of course, the
implementation may override this and implement a different way of
generating an unweighted event.
<<Event transforms: evt: TBP>>=
  procedure :: generate_unweighted => evt_generate_unweighted
  procedure :: base_generate_unweighted => evt_generate_unweighted
<<Event transforms: procedures>>=
  subroutine evt_generate_unweighted (evt)
    class(evt_t), intent(inout) :: evt
    real(default) :: p, x
    evt%rejection_count = 0
    REJECTION: do
       evt%rejection_count = evt%rejection_count + 1
       call evt%generate_weighted (p)
       if (signal_is_pending ())  return
       call evt%rng%generate (x)
       if (x < p)  exit REJECTION
    end do REJECTION
  end subroutine evt_generate_unweighted
    
@ %def evt_generate_unweighted
@ Make a particle set.  This should take the most recent evaluator (or
whatever stores the event), factorize the density matrix if necessary,
and store as a particle set.

If applicable, the factorization should make use of the
[[factorization_mode]] and [[keep_correlations]] settings.

The values [[r]], if set, should control the factorization in more
detail, e.g., bypassing the random-number generator.
<<Event transforms: evt: TBP>>=
  procedure (evt_make_particle_set), deferred :: make_particle_set
<<Event transforms: interfaces>>=
  interface
     subroutine evt_make_particle_set &
          (evt, factorization_mode, keep_correlations, r)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: factorization_mode
       logical, intent(in) :: keep_correlations
       real(default), dimension(:), intent(in), optional :: r
     end subroutine evt_make_particle_set
  end interface
       
@ %def evt_make_particle_set
@ Copy an existing particle set into the event record.  This bypasses
all methods to evaluate the internal state, but may be sufficient for
further processing.
<<Event transforms: evt: TBP>>=
  procedure :: set_particle_set => evt_set_particle_set
<<Event transforms: procedures>>=
  subroutine evt_set_particle_set (evt, particle_set, i_mci, i_term)
    class(evt_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: i_term, i_mci
    call evt%prepare_new_event (i_mci, i_term)
    evt%particle_set = particle_set
    evt%particle_set_exists = .true.
  end subroutine evt_set_particle_set
    
@ %def evt_set_particle_set
@ This procedure can help in the previous task, if the particles are
available in the form of an interaction object.  (We need two
interactions, one with color summed over, and one with the probability
distributed among flows.)

We use the two values from the random number generator for factorizing
the state.  For testing purposes, we can provide those numbers explicitly.
<<Event transforms: evt: TBP>>=
  procedure :: factorize_interactions => evt_factorize_interactions
<<Event transforms: procedures>>=
  subroutine evt_factorize_interactions &
       (evt, int_matrix, int_flows, factorization_mode, keep_correlations, r)
    class(evt_t), intent(inout) :: evt
    type(interaction_t), intent(in), target :: int_matrix, int_flows
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    real(default), dimension(2) :: x
    if (present (r)) then
       if (size (r) == 2) then
          x = r
       else
          call msg_bug ("event factorization: size of r array must be 2")
       end if
    else
       call evt%rng%generate (x)
    end if
    call evt%particle_set%init (evt%particle_set_exists, &
         int_matrix, int_flows, factorization_mode, x, &
         keep_correlations, keep_virtual=.true.)
    evt%particle_set_exists = .true.
  end subroutine evt_factorize_interactions
  
@ %def evt_factorize_interactions
@ Mark the incoming particles as incoming in the particle set.  This
is necessary because in the interaction objects they are usually
marked as virtual.

In the inquiry functions we set the term index to one; the indices of
beams and incoming particles should be identical for all process
terms.

We use the initial elementary process for obtaining the indices.
Thus, we implicitly assume that the beam and incoming indices stay the
same across event transforms.  If this is not true for a transform
(say, MPI), it should override this method.
<<Event transforms: evt: TBP>>=
  procedure :: tag_incoming => evt_tag_incoming
<<Event transforms: procedures>>=
  subroutine evt_tag_incoming (evt)
    class(evt_t), intent(inout) :: evt
    integer :: i_term, n_in
    integer, dimension(:), allocatable :: beam_index, in_index
    n_in = evt%process%get_n_in ()
    i_term = 1
    allocate (beam_index (n_in))
    call evt%process_instance%get_beam_index (i_term, beam_index)
    call evt%particle_set%reset_status (beam_index, PRT_BEAM)
    allocate (in_index (n_in))
    call evt%process_instance%get_in_index (i_term, in_index)
    call evt%particle_set%reset_status (in_index, PRT_INCOMING)
  end subroutine evt_tag_incoming

@ %def evt_tag_incoming
@
\subsection{Implementation: Trivial transform}
This transform contains just a pointer to process and process
instance.  The [[generate]] methods do nothing.
<<Event transforms: public>>=
  public :: evt_trivial_t
<<Event transforms: types>>=
  type, extends (evt_t) :: evt_trivial_t
   contains
   <<Event transforms: evt trivial: TBP>>
  end type evt_trivial_t

@ %def evt_trivial_t
@ The finalizer is trivial.  Some output:
<<Event transforms: evt trivial: TBP>>=
  procedure :: write => evt_trivial_write
<<Event transforms: procedures>>=
  subroutine evt_trivial_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_trivial_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: trivial (hard process)"
    call write_separator (u)
    call evt%base_write (u, testflag = testflag)
  end subroutine evt_trivial_write
  
@ %def evt_trivial_write
@ Nothing to do here:
<<Event transforms: evt trivial: TBP>>=
  procedure :: prepare_new_event => evt_trivial_prepare_new_event
<<Event transforms: procedures>>=
  subroutine evt_trivial_prepare_new_event (evt, i_mci, i_term)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_trivial_prepare_new_event
  
@ %def evt_trivial_prepare_new_event
@ The weighted generator is, surprisingly, trivial.
<<Event transforms: evt trivial: TBP>>=
  procedure :: generate_weighted => evt_trivial_generate_weighted
<<Event transforms: procedures>>=
  subroutine evt_trivial_generate_weighted (evt, probability)
    class(evt_trivial_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    probability = 1
  end subroutine evt_trivial_generate_weighted
    
@ %def evt_trivial_generate_weighted
@ This routine makes a particle set, using the associated process
instance as-is.
<<Event transforms: evt trivial: TBP>>=
  procedure :: make_particle_set => evt_trivial_make_particle_set
<<Event transforms: procedures>>=
  subroutine evt_trivial_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    integer :: i_term
    type(interaction_t), pointer :: int_matrix, int_flows
    if (evt%process_instance%is_complete_event ()) then
       call evt%process_instance%select_i_term (i_term)
       int_matrix => evt%process_instance%get_matrix_int_ptr (i_term)
       int_flows  => evt%process_instance%get_flows_int_ptr (i_term)
       call evt%factorize_interactions (int_matrix, int_flows, &
            factorization_mode, keep_correlations, r)
       call evt%tag_incoming ()
    else
       call msg_bug ("Event factorization: event is incomplete")
    end if
  end subroutine evt_trivial_make_particle_set
    
@ %def event_trivial_make_particle_set
@
\subsection{Unit tests}
<<Event transforms: public>>=
  public :: event_transforms_test
<<Event transforms: tests>>=
  subroutine event_transforms_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event transforms: execute tests>>
  end subroutine event_transforms_test
  
@ %def event_transforms_test
@
\subsubsection{Test trivial event transform}
The trivial transform, as an instance of the abstract transform, does
nothing but to trigger event generation for an elementary process.
<<Event transforms: execute tests>>=
  call test (event_transforms_1, "event_transforms_1", &
       "trivial event transform", &
       u, results)
<<Event transforms: tests>>=
  subroutine event_transforms_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: libname, procname1, run_id
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(evt_t), allocatable :: evt
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: event_transforms_1"
    write (u, "(A)")  "*   Purpose: handle trivial transform"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)

    libname = "event_transforms_1_lib"
    procname1 = "event_transforms_1_p"
    run_id = "event_transforms_1"

    call prc_test_create_library (libname, lib, &
         scattering = .true., procname1 = procname1)
    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init &
         (procname1, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()

    allocate (process_instance)
    call process_instance%init (process)
    call process%integrate (process_instance, 1, n_it=1, n_calls=100)
    call process%final_integration (1)
    call process_instance%final ()
    deallocate (process_instance)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")  "* Initialize trivial event transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt)
    model => process%get_model_ptr ()
    call evt%connect (process_instance, model)
    
    write (u, "(A)")  "* Generate event and subsequent transform"
    write (u, "(A)")
    
    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()
    
    call evt%prepare_new_event (1, 1)
    call evt%generate_unweighted ()

    call write_separator (u, 2)
    call evt%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Obtain particle set"
    write (u, "(A)")
    
    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    
    call evt%make_particle_set (factorization_mode, keep_correlations)

    call write_separator (u, 2)
    call evt%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_transforms_1"
    
  end subroutine event_transforms_1
  
@ %def event_transforms_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hadronization interface}
<<[[hadrons.f90]]>>=
<<File header>>

module hadrons

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use sm_qcd
  use particles
  use model_data
  use models
  use hep_common
  use event_transforms
  use shower_base
  use shower_pythia6

<<Standard module head>>

<<Hadrons: public>>

<<Hadrons: types>>

<<Hadrons: interfaces>>

<<Hadrons: parameters>>

contains

<<Hadrons: procedures>>

end module hadrons
@ %def hadrons
@
\subsection{Hadronization implementations}
<<Hadrons: public>>=
  public :: HADRONS_PYTHIA6, HADRONS_PYTHIA8, HADRONS_UNDEFINED
<<Hadrons: parameters>>=
  integer, parameter :: HADRONS_PYTHIA6 = 1
  integer, parameter :: HADRONS_PYTHIA8 = 2
  integer, parameter :: HADRONS_UNDEFINED = 17
@ %def HADRONS_PYTHIA6 HADRONS_PYTHIA8 HADRONS_UNDEFINED
@ A dictionary
<<Shower base: public>>=
  public :: hadrons_method
<<Shower base: interfaces>>=
  interface hadrons_method
     module procedure hadrons_method_of_string
     module procedure hadrons_method_to_string
  end interface
<<Hadrons: procedures>>=
  elemental function hadrons_method_of_string (string) result (i)
    integer :: i
    type(string_t), intent(in) :: string
    select case (char(string))
    case ("PYTHIA6")
       i = HADRONS_PYTHIA6
    case ("PYTHIA8")
       i = HADRONS_PYTHIA8
    case default
       i = HADRONS_UNDEFINED
    end select
  end function hadrons_method_of_string

  elemental function hadrons_method_to_string (i) result (string)
    type(string_t) :: string
    integer, intent(in) :: i
    select case (i)
    case (HADRONS_PYTHIA6)
       string = "PYTHIA6"
    case (HADRONS_PYTHIA8)
       string = "PYTHIA8"
    case default
       string = "UNDEFINED"
    end select
  end function hadrons_method_to_string

@ %def hadrons_method
@
\subsection{Abstract Hadronization Type}
The [[model]] is the fallback model including all hadrons
<<Hadrons: types>>=
  type, abstract :: hadrons_t
   type(shower_settings_t), pointer :: settings
   type(model_t), pointer :: model => null()
   contains
   <<Hadrons: hadrons: TBP>>
  end type hadrons_t

@ %def hadrons_t
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_init), deferred :: init
<<Hadrons: interfaces>>=
  abstract interface
    subroutine hadrons_init (hadrons, settings, model_hadrons)
      import
      class(hadrons_t), intent(out) :: hadrons
      type(shower_settings_t), target, intent(in) :: settings
      type(model_t), target, intent(in) :: model_hadrons
    end subroutine hadrons_init
   end interface

@ %def hadrons_init
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_hadronize), deferred :: hadronize
<<Hadrons: interfaces>>=
  abstract interface
     subroutine hadrons_hadronize (hadrons, particle_set, valid)
       import
       class(hadrons_t), intent(inout) :: hadrons
       type(particle_set_t), intent(in) :: particle_set
       logical, intent(out) :: valid
     end subroutine hadrons_hadronize
  end interface
@ %def hadrons_hadronize
@
<<Hadrons: hadrons: TBP>>=
  procedure (hadrons_make_particle_set), deferred :: make_particle_set
<<Hadrons: interfaces>>=
  abstract interface
     subroutine hadrons_make_particle_set (hadrons, particle_set, &
          model, valid)
       import
       class(hadrons_t), intent(in) :: hadrons
       type(particle_set_t), intent(inout) :: particle_set
       class(model_data_t), intent(in), target :: model
       logical, intent(out) :: valid
     end subroutine hadrons_make_particle_set
  end interface

@ %def hadrons_make_particle_set
@
\subsection{[[PYTHIA6]] Hadronization Type}
Hadronization via [[PYTHIA6]] is at the moment the only option for
hadronization within \whizard.
<<Hadrons: types>>=
  type, extends (hadrons_t) :: hadrons_pythia6_t
   contains
   <<Hadrons: hadrons pythia6: TBP>>
  end type hadrons_pythia6_t

@ %def hadrons_pythia6_t
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: init => hadrons_pythia6_init
<<Hadrons: procedures>>=
  subroutine hadrons_pythia6_init (hadrons, settings, model_hadrons)
    class(hadrons_pythia6_t), intent(out) :: hadrons
    type(shower_settings_t), target, intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    logical :: pygive_not_set_by_shower
    hadrons%model => model_hadrons
    hadrons%settings => settings
    pygive_not_set_by_shower = .not. (settings%method == PS_PYTHIA6 &
         .and. (settings%isr_active .or. settings%fsr_active))
    if (pygive_not_set_by_shower) then
       call pythia6_set_verbose (settings%verbose)
       call pythia6_set_config (settings%pythia6_pygive)
    end if
    call msg_message &
         ("Hadronization: Using PYTHIA6 interface for hadronization and decays")
  end subroutine hadrons_pythia6_init

@ %def hadrons_pythia6_init
@ Assume that the event record is still in the PYTHIA COMMON BLOCKS
transferred there by the WHIZARD or PYTHIA6 shower routines.
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: hadronize => hadrons_pythia6_hadronize
<<Hadrons: procedures>>=
  subroutine hadrons_pythia6_hadronize (hadrons, particle_set, valid)
    class(hadrons_pythia6_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    logical, intent(out) :: valid
    if (signal_is_pending ()) return
    call pygive ("MSTP(111)=1")    !!! Switch on hadronization and decays
    call pygive ("MSTJ(1)=1")      !!! String fragmentation
    call pygive ("MSTJ(21)=2")     !!! String fragmentation keeping resonance momentum
    call pyexec ()
    valid = .true.
  end subroutine hadrons_pythia6_hadronize

@ %def hadrons_pythia6_hadronize
@
<<Hadrons: hadrons pythia6: TBP>>=
  procedure :: make_particle_set => hadrons_pythia6_make_particle_set
<<Hadrons: procedures>>=
  subroutine hadrons_pythia6_make_particle_set &
         (hadrons, particle_set, model, valid)
    class(hadrons_pythia6_t), intent(in) :: hadrons
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: valid
    if (signal_is_pending ()) return
    valid = pythia6_handle_errors ()
    if (valid) then
       call pythia6_combine_with_particle_set &
            (particle_set, model, hadrons%model)
    end if
  end subroutine hadrons_pythia6_make_particle_set

@ %def hadrons_pythia6_make_particle_set
@
\subsection{[[Pythia8]] Hadronization Type}
<<Hadrons: public>>=
  public :: hadrons_pythia8_t
<<Hadrons: types>>=
  type,extends (hadrons_t) :: hadrons_pythia8_t
  contains
   <<Hadrons: hadrons pythia8: TBP>>
  end type hadrons_pythia8_t

@ %def hadrons_pythia8_t
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: init => hadrons_pythia8_init
<<Hadrons: procedures>>=
  subroutine hadrons_pythia8_init (hadrons, settings, model_hadrons)
    class(hadrons_pythia8_t), intent(out) :: hadrons
    type(shower_settings_t), target, intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    logical :: options_not_set_by_shower
    options_not_set_by_shower = .not. (settings%method == PS_PYTHIA8 &
         .and. (settings%isr_active .or. settings%fsr_active))
    if (options_not_set_by_shower) then
       !call pythia8_set_verbose (settings%verbose)
       !call pythia8_set_config (settings%pythia8_config)
       !call pythia8_set_config_file (settings%pythia8_config_file)
    end if
    call msg_message &
         ("Using Pythia8 interface for hadronization and decays")
  end subroutine hadrons_pythia8_init

@ %def hadrons_pythia8_init
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: hadronize => hadrons_pythia8_hadronize
<<Hadrons: procedures>>=
  subroutine hadrons_pythia8_hadronize (hadrons, particle_set, valid)
    class(hadrons_pythia8_t), intent(inout) :: hadrons
    type(particle_set_t), intent(in) :: particle_set
    logical, intent(out) :: valid
    ! call pythia8_hadronize
  end subroutine hadrons_pythia8_hadronize

@ %def hadrons_pythia8_hadronize
@
<<Hadrons: hadrons pythia8: TBP>>=
  procedure :: make_particle_set => hadrons_pythia8_make_particle_set
<<Hadrons: procedures>>=
  pure subroutine hadrons_pythia8_make_particle_set &
         (hadrons, particle_set, model, valid)
    class(hadrons_pythia8_t), intent(in) :: hadrons
    type(particle_set_t), intent(inout) :: particle_set
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: valid
    ! call pythia8_combine_particle_set
  end subroutine hadrons_pythia8_make_particle_set

@ %def hadrons_pythia8_make_particle_set
@
\subsection{Hadronization Event Transform}
This is the type for the hadronization event transform.  It does not
depend on the specific hadronization implementation of
[[hadrons_t]].
<<Hadrons: public>>=
  public :: evt_hadrons_t
<<Hadrons: types>>=
  type, extends (evt_t) :: evt_hadrons_t
     class(hadrons_t), allocatable :: hadrons
     type(shower_settings_t) :: settings
     type(model_t), pointer :: model_hadrons => null()
     type(qcd_t), pointer :: qcd_t => null()
   contains
   <<Hadrons: evt hadrons: TBP>>
  end type evt_hadrons_t

@ %def evt_hadrons_t
@ Initialize the parameters.  The [[model_hadrons]] is supposed to be
the SM variant that contains all hadrons that may be generated in the
shower.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: init => evt_hadrons_init
<<Hadrons: procedures>>=
  subroutine evt_hadrons_init (evt, settings, model_hadrons, method)
    class(evt_hadrons_t), intent(out) :: evt
    type(shower_settings_t), target, intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    type(string_t), intent(in) :: method
    evt%settings = settings
    evt%model_hadrons => model_hadrons
    !!! TODO: (bcn 2015-03-27) method should be part of hadronization settings
    select case (char (method))
    case ("PYTHIA6")
       allocate (hadrons_pythia6_t :: evt%hadrons)
    case ("PYTHIA8")
       allocate (hadrons_pythia8_t :: evt%hadrons)
    case default
       call msg_fatal ("Hadronization method " // char (method) // &
            " not implemented.")
    end select
    call evt%hadrons%init (evt%settings, model_hadrons)
  end subroutine evt_hadrons_init

@ %def evt_hadrons_init
@ Output.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: write => evt_hadrons_write
<<Hadrons: procedures>>=
  subroutine evt_hadrons_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_hadrons_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: hadronization"
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  &
         call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
    call evt%settings%write (u)
  end subroutine evt_hadrons_write

@ %def evt_hadrons_write
@ Here we take the particle set from the previous event transform and
apply the hadronization.  The result is stored in the [[evt%hadrons]]
object.  We always return a probability of unity as we don't have the
analytic weight of the hadronization.  Invalid events have to be
discarded by the caller which is why we mark the particle set as
invalid.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: generate_weighted => evt_hadrons_generate_weighted
<<Hadrons: procedures>>=
  subroutine evt_hadrons_generate_weighted (evt, probability)
    class(evt_hadrons_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid
    evt%particle_set = evt%previous%particle_set
    call evt%hadrons%hadronize (evt%particle_set, valid)
    probability = 1
    evt%particle_set_exists = valid
  end subroutine evt_hadrons_generate_weighted

@ %def evt_hadrons_generate_weighted
@ The factorization parameters are irrelevant.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: make_particle_set => evt_hadrons_make_particle_set
<<Hadrons: procedures>>=
  subroutine evt_hadrons_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    logical :: valid
    call evt%hadrons%make_particle_set (evt%particle_set, evt%model, valid)
    evt%particle_set_exists = evt%particle_set_exists .and. valid
  end subroutine evt_hadrons_make_particle_set

@ %def event_hadrons_make_particle_set
@
<<Hadrons: evt hadrons: TBP>>=
  procedure :: prepare_new_event => evt_hadrons_prepare_new_event
<<Hadrons: procedures>>=
  subroutine evt_hadrons_prepare_new_event (evt, i_mci, i_term)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_hadrons_prepare_new_event

@ %def evt_hadrons_prepare_new_event
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tau decays}
<<[[tau_decays.f90]]>>=
<<File header>>

module tau_decays

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator  
  use sm_qcd
  use model_data
  use models
  use event_transforms

<<Standard module head>>

<<Tau decays: public>>

<<Tau decays: types>>

<<Tau decays: interfaces>>

contains
  
<<Tau decays: procedures>>

<<Tau decays: tests>>

end module tau_decays
@ %def tau_decays
\subsection{Tau Decays Event Transform}
This is the type for the tau decay event transform. 
<<Tau decays: public>>=
  public :: evt_tau_decays_t
<<Tau decays: types>>=
  type, extends (evt_t) :: evt_tau_decays_t
     type(model_t), pointer :: model_hadrons => null()
     type(qcd_t), pointer :: qcd_t => null()
   contains
   <<Tau decays: evt tau decays: TBP>>
  end type evt_tau_decays_t

@ %def evt_tau_decays_t
@ Output.
<<Tau decays: evt tau decays: TBP>>=
  procedure :: write => evt_tau_decays_write
<<Tau decays: procedures>>=
  subroutine evt_tau_decays_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_tau_decays_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: tau decays"
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  &
         call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
  end subroutine evt_tau_decays_write

@ %def evt_tau_decays_write
@ Here we take the particle set from the previous event transform and
apply the tau decays. What probability should be given back, the
product of branching ratios of the corresponding tau decays?
<<Tau decays: evt tau decays: TBP>>=
  procedure :: generate_weighted => evt_tau_decays_generate_weighted
<<Tau decays: procedures>>=
  subroutine evt_tau_decays_generate_weighted (evt, probability)
    class(evt_tau_decays_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid
    evt%particle_set = evt%previous%particle_set
    probability = 1
    evt%particle_set_exists = valid
  end subroutine evt_tau_decays_generate_weighted

@ %def evt_tau_decays_generate_weighted
@ The factorization parameters are irrelevant.
<<Tau decays: evt tau decays: TBP>>=
  procedure :: make_particle_set => evt_tau_decays_make_particle_set
<<Tau decays: procedures>>=
  subroutine evt_tau_decays_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_tau_decays_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    logical :: valid
    !!! to be filled in
    evt%particle_set_exists = evt%particle_set_exists .and. valid
  end subroutine evt_tau_decays_make_particle_set

@ %def event_tau_decays_make_particle_set
@
<<Tau decays: evt tau decays: TBP>>=
  procedure :: prepare_new_event => evt_tau_decays_prepare_new_event
<<Tau decays: procedures>>=
  subroutine evt_tau_decays_prepare_new_event (evt, i_mci, i_term)
    class(evt_tau_decays_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_tau_decays_prepare_new_event

@ %def evt_tau_decays_prepare_new_event
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Decays}
<<[[decays.f90]]>>=
<<File header>>

module decays

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_indent, write_separator
  use format_defs, only: FMT_15
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use variables
  use model_data
  use rng_base
  use selectors
  use prc_core
  use prc_test
  use process_libraries
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use parton_states
  use processes
  use process_stacks
  use event_transforms
  
<<Standard module head>>

<<Decays: public>>

<<Decays: types>>

<<Decays: interfaces>>

contains

<<Decays: procedures>>

<<Decays: tests>>

end module decays

@ %def decays
@
\subsection{Final-State Particle Configuration}
A final-state particle may be either stable or unstable.  Here is an
empty abstract type as the parent of both, with holds just the flavor
information.
<<Decays: types>>=
  type, abstract :: any_config_t
   contains
   <<Decays: any config: TBP>>
  end type any_config_t

@ %def any_config_t
@ Finalizer, depends on the implementation.
<<Decays: any config: TBP>>=
  procedure (any_config_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_config_final (object)
       import
       class(any_config_t), intent(inout) :: object
     end subroutine any_config_final
  end interface
  
@ %def any_config_final
@ The output is also deferred:
<<Decays: any config: TBP>>=
  procedure (any_config_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_config_write (object, unit, indent, verbose)
       import
       class(any_config_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
       logical, intent(in), optional :: verbose
     end subroutine any_config_write
  end interface

@ %def any_config_write
@ This is a container for a stable or unstable particle configurator.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_config_t
     class(any_config_t), allocatable :: c
  end type particle_config_t
  
@ %def particle_config_t
@
\subsection{Final-State Particle}
In theory, for the particle instance we only need to consider the
unstable case.  However, it is more straightforward to treat
configuration and instance on the same footing, and to introduce a
wrapper for particle objects as above.  This also works
around a compiler bug in gfortran.
<<Decays: types>>=
  type, abstract :: any_t
   contains
   <<Decays: any: TBP>>
  end type any_t
  
@ %def any_t
@ Finalizer, depends on the implementation.
<<Decays: any: TBP>>=
  procedure (any_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_final (object)
       import
       class(any_t), intent(inout) :: object
     end subroutine any_final
  end interface
  
@ %def any_final
@ The output is also deferred:
<<Decays: any: TBP>>=
  procedure (any_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_write (object, unit, indent)
       import
       class(any_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
     end subroutine any_write
  end interface

@ %def any_write
@ This is a container for a stable or unstable outgoing particle.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_out_t
     class(any_t), allocatable :: c
  end type particle_out_t
  
@ %def particle_config_t
@ 
\subsection{Decay Term Configuration}
A decay term is a distinct final state, corresponding to a process
term.  Each decay process may give rise to several terms with,
possibly, differing flavor content.
<<Decays: types>>=
  type :: decay_term_config_t
     type(particle_config_t), dimension(:), allocatable :: prt
   contains
   <<Decays: decay term config: TBP>>
  end type decay_term_config_t
  
@ %def decay_term_config_t
@ Finalizer, recursive.
<<Decays: decay term config: TBP>>=
  procedure :: final => decay_term_config_final
<<Decays: procedures>>=
  recursive subroutine decay_term_config_final (object)
    class(decay_term_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%prt)) then
       do i = 1, size (object%prt)
          if (allocated (object%prt(i)%c))  call object%prt(i)%c%final ()
       end do
    end if
  end subroutine decay_term_config_final
  
@ %def decay_term_config_final
@ Output, with optional indentation
<<Decays: decay term config: TBP>>=
  procedure :: write => decay_term_config_write
<<Decays: procedures>>=
  recursive subroutine decay_term_config_write (object, unit, indent, verbose)
    class(decay_term_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, j, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,A)", advance="no")  "Final state:"
    do i = 1, size (object%prt)
       select type (prt_config => object%prt(i)%c)
       type is (stable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv(1)%get_name ())
          do j = 2, size (prt_config%flv)
             write (u, "(':',A)", advance="no") &
                  char (prt_config%flv(j)%get_name ())
          end do
       type is (unstable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv%get_name ())
       end select
    end do
    write (u, *)
    if (verb) then
       do i = 1, size (object%prt)
          call object%prt(i)%c%write (u, ind)
       end do
    end if
  end subroutine decay_term_config_write

@ %def decay_term_config_write
@ Initialize, given a set of flavors.  For each flavor, we must indicate
whether the particle is stable.  The second index of the flavor array runs
over alternatives for each decay product; alternatives are allowed only if the
decay product is itself stable.
<<Decays: decay term config: TBP>>=
  procedure :: init => decay_term_config_init
<<Decays: procedures>>=
  recursive subroutine decay_term_config_init &
       (term, flv, stable, model, process_stack)
    class(decay_term_config_t), intent(out) :: term
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t), dimension(:), allocatable :: decay
    integer :: i
    allocate (term%prt (size (flv, 1)))
    do i = 1, size (flv, 1)
       associate (prt => term%prt(i))
         if (stable(i)) then
            allocate (stable_config_t :: prt%c)
         else
            allocate (unstable_config_t :: prt%c)
         end if
         select type (prt_config => prt%c)
         type is (stable_config_t)
            call prt_config%init (flv(i,:))
         type is (unstable_config_t)
            if (all (flv(i,:) == flv(i,1))) then
               call prt_config%init (flv(i,1))
               call flv(i,1)%get_decays (decay)
               call prt_config%init_decays (decay, model, process_stack)
            else
               call prt_config%write ()
               call msg_fatal ("Decay configuration: &
                    &unstable product must be unique")
            end if
         end select
       end associate
    end do
  end subroutine decay_term_config_init
  
@ %def decay_term_config_init
@ Recursively compute widths and branching ratios for all unstable particles.
<<Decays: decay term config: TBP>>=
  procedure :: compute => decay_term_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_term_config_compute (term)
    class(decay_term_config_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%prt)
       select type (unstable_config => term%prt(i)%c)
       type is (unstable_config_t)
          call unstable_config%compute ()
       end select
    end do
  end subroutine decay_term_config_compute
  
@ %def decay_term_config_compute
@
\subsection{Decay Term}
A decay term instance is selected when we generate an event for the associated
process instance.  When evaluated, it triggers further decays down the chain.

Only unstable products are allocated as child particles.
<<Decays: types>>=
  type :: decay_term_t
     type(decay_term_config_t), pointer :: config => null ()
     type(particle_out_t), dimension(:), allocatable :: particle_out
   contains
   <<Decays: decay term: TBP>>
  end type decay_term_t

@ %def decay_term_t
@ Finalizer.
<<Decays: decay term: TBP>>=
  procedure :: final => decay_term_final
<<Decays: procedures>>=
  recursive subroutine decay_term_final (object)
    class(decay_term_t), intent(inout) :: object
    integer :: i
    if (allocated (object%particle_out)) then
       do i = 1, size (object%particle_out)
          call object%particle_out(i)%c%final ()
       end do
    end if
  end subroutine decay_term_final
  
@ %def decay_term_final
@ Output.
<<Decays: decay term: TBP>>=
  procedure :: write => decay_term_write
<<Decays: procedures>>=
  recursive subroutine decay_term_write (object, unit, indent)
    class(decay_term_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: i, u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose = .false.)
    do i = 1, size (object%particle_out)
       call object%particle_out(i)%c%write (u, ind)
    end do
  end subroutine decay_term_write

@ %def decay_term_write
@ Recursively write the embedded process instances.
<<Decays: decay term: TBP>>=
  procedure :: write_process_instances => decay_term_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_term_write_process_instances (term, unit, verbose)
    class(decay_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%write_process_instances (unit, verbose)
       end select
    end do
  end subroutine decay_term_write_process_instances
  
@ %def decay_term_write_process_instances
@ Initialization, using the configuration object.  We allocate
particle objects in parallel to the particle configuration objects
which we use to initialize them, one at a time.
<<Decays: decay term: TBP>>=
  procedure :: init => decay_term_init
<<Decays: procedures>>=
  recursive subroutine decay_term_init (term, config)
    class(decay_term_t), intent(out) :: term
    type(decay_term_config_t), intent(in), target :: config
    integer :: i
    term%config => config
    allocate (term%particle_out (size (config%prt)))
    do i = 1, size (config%prt)
       select type (prt_config => config%prt(i)%c)
       type is (stable_config_t)
          allocate (stable_t :: term%particle_out(i)%c)
          select type (stable => term%particle_out(i)%c)
          type is (stable_t)
             call stable%init (prt_config)
          end select
       type is (unstable_config_t)
          allocate (unstable_t :: term%particle_out(i)%c)
          select type (unstable => term%particle_out(i)%c)
          type is (unstable_t)
             call unstable%init (prt_config)
          end select
       end select
    end do
  end subroutine decay_term_init

@ %def decay_term_init
@ Implement a RNG instance, spawned by the process object.
<<Decays: decay term: TBP>>=
  procedure :: make_rng => decay_term_make_rng
<<Decays: procedures>>=
  subroutine decay_term_make_rng (term, process)
    class(decay_term_t), intent(inout) :: term
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call process%make_rng (rng)
          call unstable%import_rng (rng)
       end select
    end do
  end subroutine decay_term_make_rng
    
@ %def decay_term_make_rng
@ Link the interactions for unstable decay products to the
interaction of the parent process.
<<Decays: decay term: TBP>>=
  procedure :: link_interactions => decay_term_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_term_link_interactions (term, trace)
    class(decay_term_t), intent(inout) :: term
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%link_interactions (i, trace)
       end select
    end do
  end subroutine decay_term_link_interactions
  
@ %def decay_term_link_interactions
@ Recursively generate a decay chain, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: select_chain => decay_term_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_term_select_chain (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%select_chain ()
       end select
    end do
  end subroutine decay_term_select_chain

@ %def decay_term_select_chain
@ Recursively generate a decay event, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: generate => decay_term_generate
<<Decays: procedures>>=
  recursive subroutine decay_term_generate (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%generate ()
       end select
    end do
  end subroutine decay_term_generate

@ %def decay_term_generate
@
\subsection{Decay Root Configuration}
At the root of a decay chain, there is a parent process.  The decay root
stores a pointer to the parent process and the set of decay configurations.
<<Decays: types>>=
  type :: decay_root_config_t
     type(string_t) :: process_id
     type(process_t), pointer :: process => null ()
     class(model_data_t), pointer :: model => null ()
     type(decay_term_config_t), dimension(:), allocatable :: term_config
   contains
   <<Decays: decay root config: TBP>>
  end type decay_root_config_t
  
@ %def decay_root_config_t
@ The finalizer is recursive since there may be cascade decays.
<<Decays: decay root config: TBP>>=
  procedure :: final => decay_root_config_final
<<Decays: procedures>>=
  recursive subroutine decay_root_config_final (object)
    class(decay_root_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%final ()
       end do
    end if
  end subroutine decay_root_config_final
  
@ %def decay_root_config_final
@ The output routine is also recursive, and it contains an adjustable
indentation.
<<Decays: decay root config: TBP>>=
  procedure :: write => decay_root_config_write
  procedure :: write_header => decay_root_config_write_header
  procedure :: write_terms => decay_root_config_write_terms
<<Decays: procedures>>=
  recursive subroutine decay_root_config_write (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Final-state decay tree:"
    call object%write_header (unit, indent)
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_root_config_write

  subroutine decay_root_config_write_header (object, unit, indent)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    if (associated (object%process)) then
       write (u, 3)  "process ID      =", char (object%process_id), "*"
    else
       write (u, 3)  "process ID      =", char (object%process_id)
    end if
3   format (3x,A,2(1x,A))
  end subroutine decay_root_config_write_header
    
  recursive subroutine decay_root_config_write_terms &
       (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb .and. allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine decay_root_config_write_terms
    
@ %def decay_root_config_write
@ Initialize for a named process and (optionally) a pre-determined
number of terms.
<<Decays: decay root config: TBP>>=
  procedure :: init => decay_root_config_init
<<Decays: procedures>>=
  subroutine decay_root_config_init (decay, model, process_id, n_terms)
    class(decay_root_config_t), intent(out) :: decay
    class(model_data_t), intent(in), target :: model
    type(string_t), intent(in) :: process_id
    integer, intent(in), optional :: n_terms
    decay%model => model
    decay%process_id = process_id
    if (present (n_terms)) then
       allocate (decay%term_config (n_terms))
    end if
  end subroutine decay_root_config_init
       
@ %def decay_root_config_init
@ Declare a decay term, given an array of flavors.
<<Decays: decay root config: TBP>>=
  procedure :: init_term => decay_root_config_init_term
<<Decays: procedures>>=
  recursive subroutine decay_root_config_init_term &
       (decay, i, flv, stable, model, process_stack)
    class(decay_root_config_t), intent(inout) :: decay
    integer, intent(in) :: i
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call decay%term_config(i)%init (flv, stable, model, process_stack)
  end subroutine decay_root_config_init_term
  
@ %def decay_root_config_init_term
@ Connect the decay root configuration with a process object (which should
represent the parent process).  This includes initialization, therefore
intent(out).

The flavor state is retrieved from the process term object.  However, we have
to be careful: the flavor object points to the model instance that is stored
in the process object.  This model instance may not contain the current
setting for unstable particles and decay.  Therefore, we assign the model
directly.

If the [[process_instance]] argument is provided, we use this for the
flavor state.  This applies to the decay root only, where the process
can be entangled with a beam setup, and the latter contains beam
remnants as further outgoing particles.  These must be included in the
set of outgoing flavors, since the decay application is also done on
the connected state.

Infer stability from the particle properties, using the first row in the set
of flavor states.  For unstable particles, we look for decays,
recursively, available from the process stack (if present).

For the unstable particles, we have to check whether their masses
match between the production and the decay.  Fortunately, both
versions are available for comparison.
<<Decays: decay root config: TBP>>=
  procedure :: connect => decay_root_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_root_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_root_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    type(connected_state_t), pointer :: connected_state
    type(interaction_t), pointer :: int
    type(flavor_t), dimension(:,:), allocatable :: flv
    logical, dimension(:), allocatable :: stable
    real(default), dimension(:), allocatable :: m_prod, m_dec
    integer :: i
    call decay%init (model, process%get_id (), process%get_n_terms ())
    do i = 1, size (decay%term_config)
       if (present (process_instance)) then
          connected_state => process_instance%get_connected_state_ptr (i)
          int => connected_state%get_matrix_int_ptr ()
          call interaction_get_flv_out (int, flv)
       else
          call process%get_term_flv_out (i, flv)
       end if
       m_prod = flv(:,1)%get_mass ()
       call flv%set_model (model)
       m_dec = flv(:,1)%get_mass ()
       allocate (stable (size (flv, 1)))
       stable = flv(:,1)%is_stable ()
       call check_masses ()
       call decay%init_term (i, flv, stable, model, process_stack)
       deallocate (flv, stable)
    end do
    decay%process => process
  contains
    subroutine check_masses ()
      integer :: i
      logical :: ok
      ok = .true.
      do i = 1, size (m_prod)
         if (.not. stable(i)) then
            if (.not. nearly_equal (m_prod(i), m_dec(i))) then
               write (msg_buffer, "(A,A,A)")  "particle '", &
                    char (flv(i,1)%get_name ()), "':"
               call msg_message
               write (msg_buffer, &
                    "(2x,A,1x," // FMT_15 // ",3x,A,1x," // FMT_15 // ")") &
                    "m_prod =", m_prod(i), "m_dec =", m_dec(i)
               call msg_message
               ok = .false.
            end if
         end if
      end do
      if (.not. ok)  call msg_fatal &
           ("Particle mass mismatch between production and decay")
    end subroutine check_masses
  end subroutine decay_root_config_connect

@ %def decay_root_config_connect
@ Recursively compute widths, errors, and branching ratios.
<<Decays: decay root config: TBP>>=
  procedure :: compute => decay_root_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_root_config_compute (decay)
    class(decay_root_config_t), intent(inout) :: decay
    integer :: i
    do i = 1, size (decay%term_config)
       call decay%term_config(i)%compute ()
    end do
  end subroutine decay_root_config_compute
  
@ %def decay_root_config_compute
@
\subsection{Decay Root Instance}
This is the common parent type for decay and decay root.  The process instance
points to the parent process.  The model pointer is separate because particle
settings may be updated w.r.t.\ the parent process object.
<<Decays: types>>=
  type, abstract :: decay_gen_t
     type(decay_term_t), dimension(:), allocatable :: term
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
   contains
   <<Decays: decay gen: TBP>>
  end type decay_gen_t
  
@ %def decay_gen_t
@
The decay root represents the parent process.  When an event is generated, the
generator selects the term to which the decay chain applies (if possible).

The process instance is just a pointer.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_root_t
     type(decay_root_config_t), pointer :: config => null ()
   contains
   <<Decays: decay root: TBP>>
  end type decay_root_t
  
@ %def decay_root_t
@ The finalizer has to recursively finalize the terms, but we can skip the
process instance which is not explicitly allocated.
<<Decays: decay gen: TBP>>=
  procedure :: base_final => decay_gen_final
<<Decays: procedures>>=
  recursive subroutine decay_gen_final (object)
    class(decay_gen_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term)) then
       do i = 1, size (object%term)
          call object%term(i)%final ()
       end do
    end if
  end subroutine decay_gen_final    
  
@ %def decay_gen_final
@ No extra finalization for the decay root.
<<Decays: decay root: TBP>>=
  procedure :: final => decay_root_final
<<Decays: procedures>>=
  subroutine decay_root_final (object)
    class(decay_root_t), intent(inout) :: object
    call object%base_final ()
  end subroutine decay_root_final    
  
@ %def decay_gen_final
@ Output.
<<Decays: decay root: TBP>>=
  procedure :: write => decay_root_write
<<Decays: procedures>>=
  subroutine decay_root_write (object, unit)
    class(decay_root_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%config)) then
       call object%config%write (unit, verbose = .false.)
    else
       write (u, "(1x,A)")  "Final-state decay tree: [not configured]"
    end if
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_root_write

@ %def decay_root_write
@ Write the process instances, recursively.
<<Decays: decay gen: TBP>>=
  procedure :: write_process_instances => decay_gen_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_gen_write_process_instances (decay, unit, verbose)
    class(decay_gen_t), intent(in) :: decay
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (associated (decay%process_instance)) then
       if (verb) then
          call decay%process_instance%write (unit)
       else
          call decay%process_instance%write_header (unit)
       end if
    end if
    if (decay%selected_term > 0) then
       call decay%term(decay%selected_term)%write_process_instances (unit, verb)
    end if
  end subroutine decay_gen_write_process_instances
    
@ %def decay_gen_write_process_instances
@ Generic initializer.  All can be done recursively.
<<Decays: decay gen: TBP>>=
  procedure :: base_init => decay_gen_init
<<Decays: procedures>>=
  recursive subroutine decay_gen_init (decay, term_config)
    class(decay_gen_t), intent(out) :: decay
    type(decay_term_config_t), dimension(:), intent(in), target :: term_config
    integer :: i
    allocate (decay%term (size (term_config)))
    do i = 1, size (decay%term)
       call decay%term(i)%init (term_config(i))
    end do
  end subroutine decay_gen_init

@ %def decay_gen_init
@ Specific initializer.  We assign the configuration object, which should
correspond to a completely initialized decay configuration tree.  We
also connect to an existing process instance.  Then, we recursively
link the child interactions to the parent process.
<<Decays: decay root: TBP>>=
  procedure :: init => decay_root_init
<<Decays: procedures>>=
  subroutine decay_root_init (decay_root, config, process_instance)
    class(decay_root_t), intent(out) :: decay_root
    type(decay_root_config_t), intent(in), target :: config
    type(process_instance_t), intent(in), target :: process_instance
    call decay_root%base_init (config%term_config)
    decay_root%config => config
    decay_root%process_instance => process_instance
    call decay_root%make_term_rng (config%process)
    call decay_root%link_term_interactions ()
  end subroutine decay_root_init

@ %def decay_root_init
@ Implement random-number generators for unstable decay selection in
all terms.  This is not recursive.

We also make use of the fact that [[process]] is a pointer; the (state
of the RNG factory inside the) target process will be modified by the
rng-spawning method, but not the pointer.
<<Decays: decay gen: TBP>>=
  procedure :: make_term_rng => decay_gen_make_term_rng
<<Decays: procedures>>=
  subroutine decay_gen_make_term_rng (decay, process)
    class(decay_gen_t), intent(inout) :: decay
    type(process_t), intent(in), pointer :: process
    integer :: i
    do i = 1, size (decay%term)
       call decay%term(i)%make_rng (process)
    end do
  end subroutine decay_gen_make_term_rng
    
@ %def decay_gen_make_term_rng
@ Recursively link interactions of the enclosed decay terms to the
corresponding terms in the current process instance.

Note: A bug in nagfor requires the extra [[i_term]] variable.
<<Decays: decay gen: TBP>>=
  procedure :: link_term_interactions => decay_gen_link_term_interactions
<<Decays: procedures>>=
  recursive subroutine decay_gen_link_term_interactions (decay)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i, i_term
    type(interaction_t), pointer :: trace
    associate (instance => decay%process_instance)
      do i = 1, size (decay%term)
         i_term = i
         trace => instance%get_trace_int_ptr (i_term)
         call decay%term(i_term)%link_interactions (trace)
      end do
    end associate
  end subroutine decay_gen_link_term_interactions

@ %def decay_gen_link_term_interactions
@ Select a decay chain: decay modes and process components.
<<Decays: decay root: TBP>>=
  procedure :: select_chain => decay_root_select_chain
<<Decays: procedures>>=
  subroutine decay_root_select_chain (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    if (decay_root%selected_term > 0) then
       call decay_root%term(decay_root%selected_term)%select_chain ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_select_chain

@ %def decay_root_select_chain
@ Generate a decay tree, i.e., for the selected term in the parent
process, recursively generate a decay event for all unstable
particles.

Factor out the trace of the connected state of the parent process.
This trace should not be taken into account for unweighting the decay
chain, since it was already used for unweighting the parent event, or
it determines the overall event weight.
<<Decays: decay root: TBP>>=
  procedure :: generate => decay_root_generate
<<Decays: procedures>>=
  subroutine decay_root_generate (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    type(connected_state_t), pointer :: connected_state
    if (decay_root%selected_term > 0) then
       connected_state => decay_root%process_instance%get_connected_state_ptr &
            (decay_root%selected_term)
       call connected_state%normalize_matrix_by_trace ()
       call decay_root%term(decay_root%selected_term)%generate ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_generate

@ %def decay_root_generate
@
\subsection{Decay Configuration}
A decay configuration describes a distinct decay mode of a particle.  Each
decay mode may include several terms, which correspond to the terms in the
associated process.  In addition to the base type, the decay configuration
object contains the integral of the parent process and the selector for the
MCI group inside this process.

The flavor component should be identical to the flavor component of the parent
particle ([[unstable]] object).
<<Decays: types>>=
  type, extends (decay_root_config_t) :: decay_config_t
     type(flavor_t) :: flv
     real(default) :: weight = 0
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: mci_selector
   contains
   <<Decays: decay config: TBP>>
  end type decay_config_t
  
@ %def decay_config_t
@ The output routine extends the decay-root writer by listing numerical
component values.
<<Decays: decay config: TBP>>=
  procedure :: write => decay_config_write
<<Decays: procedures>>=
  recursive subroutine decay_config_write (object, unit, indent, verbose)
    class(decay_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Decay:"
    call object%write_header (unit, indent)
    call write_indent (u, ind)
    write (u, 2)  "branching ratio =", object%weight * 100
    call write_indent (u, ind)
    write (u, 1)  "partial width   =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs)     =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel)     =", object%rel_error
1   format (3x,A,ES19.12)
2   format (3x,A,F11.6,1x,'%')
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_config_write
    
@ %def decay_config_write
@ Connect a decay configuration with a process object (which should
represent the decay).  This includes initialization, therefore
intent(out).  We first connect the process itself, then do initializations
that are specific for this decay.

Infer stability from the particle properties, using the first row in the set
of flavor states.  Once we can deal with predetermined decay chains, they
should be used instead.
<<Decays: decay config: TBP>>=
  procedure :: connect => decay_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    real(default), dimension(:), allocatable :: integral_mci
    integer :: i, n_mci
    call decay%decay_root_config_t%connect (process, model, process_stack)
    decay%integral = process%get_integral ()
    decay%abs_error = process%get_error ()
    if (process%cm_frame ()) then
       call msg_fatal ("Decay process " // char (process%get_id ()) &
            // ": unusable because rest frame is fixed.")
    end if
    n_mci = process%get_n_mci ()
    allocate (integral_mci (n_mci))
    do i = 1, n_mci
       integral_mci(i) = process%get_integral_mci (i)
    end do
    call decay%mci_selector%init (integral_mci)
  end subroutine decay_config_connect

@ %def decay_config_connect
@ Set the flavor entry, which repeats the flavor of the parent unstable
particle.
<<Decays: decay config: TBP>>=
  procedure :: set_flv => decay_config_set_flv
<<Decays: procedures>>=
  subroutine decay_config_set_flv (decay, flv)
    class(decay_config_t), intent(inout) :: decay
    type(flavor_t), intent(in) :: flv
    decay%flv = flv
  end subroutine decay_config_set_flv
  
@ %def decay_config_set_flv
@ Compute embedded branchings and the relative error.  This method does not
apply to the decay root.
<<Decays: decay config: TBP>>=
  procedure :: compute => decay_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_config_compute (decay)
    class(decay_config_t), intent(inout) :: decay
    call decay%decay_root_config_t%compute ()
    if (.not. vanishes (decay%integral)) then
       decay%rel_error = decay%abs_error / decay%integral
    else
       decay%rel_error = 0
    end if
  end subroutine decay_config_compute
  
@ %def decay_config_compute
@
\subsection{Decay Instance}
The decay contains a collection of terms.  One of them is selected when the
decay is evaluated.  This is similar to the decay root, but we implement it
independently.

The process instance object is allocated via a pointer, so it automatically
behaves as a target.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_t
     type(decay_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
   contains
   <<Decays: decay: TBP>>
  end type decay_t
     
@ %def decay_t
@ The finalizer is recursive.
<<Decays: decay: TBP>>=
  procedure :: final => decay_final
<<Decays: procedures>>=
  recursive subroutine decay_final (object)
    class(decay_t), intent(inout) :: object
    integer :: i
    call object%base_final ()
    do i = 1, object%config%process%get_n_mci ()
       call object%process_instance%final_simulation (i)
    end do
    call object%process_instance%final ()
    deallocate (object%process_instance)
  end subroutine decay_final
  
@ %def decay_final
@ Output.
<<Decays: decay: TBP>>=
  procedure :: write => decay_write
<<Decays: procedures>>=
  recursive subroutine decay_write (object, unit, indent, recursive)
    class(decay_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent, recursive
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (unit, indent, verbose = .false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 1)
    end if
    call write_indent (u, ind)
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    call write_indent (u, ind)
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, ind + 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_write

@ %def decay_write
@ Initializer.  Base initialization is done recursively.  Then, we
prepare the current process instance and allocate a random-number
generator for term selection.  For all unstable particles, we also
allocate a r.n.g. as spawned by the current process.
<<Decays: decay: TBP>>=
  procedure :: init => decay_init
<<Decays: procedures>>=
  recursive subroutine decay_init (decay, config)
    class(decay_t), intent(out) :: decay
    type(decay_config_t), intent(in), target :: config
    integer :: i
    call decay%base_init (config%term_config)
    decay%config => config
    allocate (decay%process_instance)
    call decay%process_instance%init (decay%config%process)
    call decay%process_instance%setup_event_data (decay%config%model)
    do i = 1, decay%config%process%get_n_mci ()
       call decay%process_instance%init_simulation (i)
    end do
    call decay%config%process%make_rng (decay%rng)
    call decay%make_term_rng (decay%config%process)
  end subroutine decay_init

@ %def decay_init
@ Link interactions to the parent process.  [[i_prt]] is the index of
the current outgoing particle in the parent interaction, for which we
take the trace evaluator.  We link it to the beam particle in the beam
interaction of the decay process instance.  Then, repeat the procedure
for the outgoing particles.
<<Decays: decay: TBP>>=
  procedure :: link_interactions => decay_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_link_interactions (decay, i_prt, trace)
    class(decay_t), intent(inout) :: decay
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    type(interaction_t), pointer :: beam_int
    integer :: n_in, n_vir
    beam_int => decay%process_instance%get_beam_int_ptr ()
    n_in = trace%get_n_in ()
    n_vir = trace%get_n_vir ()
    call beam_int%set_source_link (1, trace, &
         n_in + n_vir + i_prt)
    call decay%link_term_interactions ()
  end subroutine decay_link_interactions
    
@ %def decay_link_interactions
@ Determine a decay chain.  For each unstable particle we select one
of the possible decay modes, and for each decay process we select one
of the possible decay MCI components, calling the random-number
generators.  We do not generate momenta, yet.
<<Decays: decay: TBP>>=
  procedure :: select_chain => decay_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_select_chain (decay)
    class(decay_t), intent(inout) :: decay
    real(default) :: x
    integer :: i
    call decay%rng%generate (x)
    decay%selected_mci = decay%config%mci_selector%select (x)
    call decay%process_instance%choose_mci (decay%selected_mci)
    call decay%process_instance%select_i_term (decay%selected_term)
    do i = 1, size (decay%term)
       call decay%term(i)%select_chain ()
    end do
  end subroutine decay_select_chain
  
@ %def decay_select_chain
@ Generate a decay.  We first receive the beam momenta from the parent
process (assuming that this is properly linked), then call the
associated process object for a new event.

Factor out the trace of the helicity density matrix of the isolated
state (the one that will be used for the decay chain).  The trace is
taken into account for unweighting the individual decay event and
should therefore be ignored for unweighting the correlated decay
chain afterwards.
<<Decays: decay: TBP>>=
  procedure :: generate => decay_generate
<<Decays: procedures>>=
  recursive subroutine decay_generate (decay)
    class(decay_t), intent(inout) :: decay
    type(isolated_state_t), pointer :: isolated_state
    integer :: i
    call decay%process_instance%receive_beam_momenta ()
    call decay%config%process%generate_unweighted_event &
         (decay%process_instance, decay%selected_mci)
    if (signal_is_pending ())  return
    call decay%process_instance%evaluate_event_data ()
    isolated_state => &
         decay%process_instance%get_isolated_state_ptr (decay%selected_term)
    call isolated_state%normalize_matrix_by_trace ()
    do i = 1, size (decay%term)
       call decay%term(i)%generate ()
       if (signal_is_pending ())  return
    end do
  end subroutine decay_generate
    
@ %def decay_generate
@
\subsection{Stable Particles}
This is a stable particle.  The flavor can be ambiguous (e.g., partons).
<<Decays: types>>=
  type, extends (any_config_t) :: stable_config_t
     type(flavor_t), dimension(:), allocatable :: flv
   contains
   <<Decays: stable config: TBP>>
  end type stable_config_t

@ %def stable_config_t
@ The finalizer is empty:
<<Decays: stable config: TBP>>=
  procedure :: final => stable_config_final
<<Decays: procedures>>=
  subroutine stable_config_final (object)
    class(stable_config_t), intent(inout) :: object
  end subroutine stable_config_final
  
@ %def stable_config_final
@ Output.
<<Decays: stable config: TBP>>=
  procedure :: write => stable_config_write
<<Decays: procedures>>=
  recursive subroutine stable_config_write (object, unit, indent, verbose)
    class(stable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A)", advance = "no")  "Stable:"
    write (u, "(1x,A)", advance = "no")  char (object%flv(1)%get_name ())
    do i = 2, size (object%flv)
       write (u, "(':',A)", advance = "no") &
            char (object%flv(i)%get_name ())
    end do
    write (u, *)
  end subroutine stable_config_write
  
@ %def stable_config_write
@ Initializer.  We are presented with an array of flavors, but there may be
double entries which we remove, so we store only the distinct flavors.
<<Decays: stable config: TBP>>=
  procedure :: init => stable_config_init
<<Decays: procedures>>=
  subroutine stable_config_init (config, flv)
    class(stable_config_t), intent(out) :: config
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, dimension (size (flv)) :: pdg
    logical, dimension (size (flv)) :: mask
    integer :: i
    pdg = flv%get_pdg ()
    mask(1) = .true.
    forall (i = 2 : size (pdg))
       mask(i) = all (pdg(i) /= pdg(1:i-1))
    end forall
    allocate (config%flv (count (mask)))
    config%flv = pack (flv, mask)
  end subroutine stable_config_init
  
@ %def stable_config_init
@ Here is the corresponding object instance.  Except for the pointer
to the configuration, there is no content.
<<Decays: types>>=
  type, extends (any_t) :: stable_t
     type(stable_config_t), pointer :: config => null ()
   contains
   <<Decays: stable: TBP>>
  end type stable_t

@ %def stable_t
@ The finalizer does nothing.
<<Decays: stable: TBP>>=
  procedure :: final => stable_final
<<Decays: procedures>>=
  subroutine stable_final (object)
    class(stable_t), intent(inout) :: object
  end subroutine stable_final

@ %def stable_final
@ We can delegate output to the configuration object.
<<Decays: stable: TBP>>=
  procedure :: write => stable_write
<<Decays: procedures>>=
  subroutine stable_write (object, unit, indent)
    class(stable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%config%write (unit, indent)
  end subroutine stable_write
  
@ %def stable_write
@ Initializer: just assign the configuration.
<<Decays: stable: TBP>>=
  procedure :: init => stable_init
<<Decays: procedures>>=
  subroutine stable_init (stable, config)
    class(stable_t), intent(out) :: stable
    type(stable_config_t), intent(in), target :: config
    stable%config => config
  end subroutine stable_init
  
@ %def stable_init
@
\subsection{Unstable Particles}
A branching configuration enables us to select among distinct decay
modes of a particle.  We store the particle flavor (with its implicit
link to a model), an array of decay configurations, and a selector object.

The total width, absolute and relative error are stored as
[[integral]], [[abs_error]], and [[rel_error]], respectively.

The flavor must be unique in this case.
<<Decays: types>>=
  type, extends (any_config_t) :: unstable_config_t
     type(flavor_t) :: flv
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: selector
     type(decay_config_t), dimension(:), allocatable :: decay_config
   contains
   <<Decays: unstable config: TBP>>
  end type unstable_config_t
  
@ %def unstable_config_t
@ Finalizer.  The branching configuration can be a recursive structure.
<<Decays: unstable config: TBP>>=
  procedure :: final => unstable_config_final
<<Decays: procedures>>=
  recursive subroutine unstable_config_final (object)
    class(unstable_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%final ()
       end do
    end if
  end subroutine unstable_config_final

@ %def unstable_config_final
@ Output.  Since this may be recursive, we include indentation.
<<Decays: unstable config: TBP>>=
  procedure :: write => unstable_config_write
<<Decays: procedures>>=
  recursive subroutine unstable_config_write (object, unit, indent, verbose)
    class(unstable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A,1x,A)")  "Unstable:", &
         char (object%flv%get_name ())
    call write_indent (u, ind)
    write (u, 1)  "total width =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs) =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel) =", object%rel_error
1   format (5x,A,ES19.12)
    if (verb .and. allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine unstable_config_write
  
@ %def unstable_config_write
@ Initializer.  For the unstable particle, the flavor is unique.
<<Decays: unstable config: TBP>>=
  procedure :: init => unstable_config_init
<<Decays: procedures>>=
  subroutine unstable_config_init (config, flv)
    class(unstable_config_t), intent(out) :: config
    type(flavor_t), intent(in) :: flv
    config%flv = flv
  end subroutine unstable_config_init
  
@ %def unstable_config_init
@ Further initialization: determine the number of decay modes.  We can assume
that the flavor of the particle has been set already.

If the process stack is given, we can delve recursively into actually
assigning decay processes.  Otherwise, we just initialize with decay
process names.
<<Decays: unstable config: TBP>>=
  procedure :: init_decays => unstable_config_init_decays
<<Decays: procedures>>=
  recursive subroutine unstable_config_init_decays &
       (unstable, decay_id, model, process_stack)
    class(unstable_config_t), intent(inout) :: unstable
    type(string_t), dimension(:), intent(in) :: decay_id
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    integer :: i
    allocate (unstable%decay_config (size (decay_id)))
    do i = 1, size (decay_id)
       associate (decay => unstable%decay_config(i))
         if (present (process_stack)) then
            call decay%connect (process_stack%get_process_ptr (decay_id(i)), &
                 model, process_stack)
         else
            call decay%init (model, decay_id(i))
         end if
         call decay%set_flv (unstable%flv)
       end associate
    end do
  end subroutine unstable_config_init_decays
  
@ %def unstable_config_init
@ Compute the total width and branching ratios, initializing the decay
selector.
<<Decays: unstable config: TBP>>=
  procedure :: compute => unstable_config_compute
<<Decays: procedures>>=
  recursive subroutine unstable_config_compute (unstable)
    class(unstable_config_t), intent(inout) :: unstable
    integer :: i
    do i = 1, size (unstable%decay_config)
       call unstable%decay_config(i)%compute ()
    end do
    unstable%integral = sum (unstable%decay_config%integral)
    if (unstable%integral <= 0) then
       call unstable%write ()
       call msg_fatal ("Decay configuration: computed total width is zero")
    end if
    unstable%abs_error = sqrt (sum (unstable%decay_config%abs_error ** 2))
    unstable%rel_error = unstable%abs_error / unstable%integral
    call unstable%selector%init (unstable%decay_config%integral)
    do i = 1, size (unstable%decay_config)
       unstable%decay_config(i)%weight &
            = unstable%selector%get_weight (i)
    end do
  end subroutine unstable_config_compute
    
@ %def unstable_config_compute
@
Now we define the instance of an unstable particle.
<<Decays: types>>=
  type, extends (any_t) :: unstable_t
     type(unstable_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_decay = 0
     type(decay_t), dimension(:), allocatable :: decay
   contains
   <<Decays: unstable: TBP>>
  end type unstable_t
  
@ %def unstable_t
@ Recursive finalizer.
<<Decays: unstable: TBP>>=
  procedure :: final => unstable_final
<<Decays: procedures>>=
  recursive subroutine unstable_final (object)
    class(unstable_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay)) then
       do i = 1, size (object%decay)
          call object%decay(i)%final ()
       end do
    end if
  end subroutine unstable_final
  
@ %def unstable_final
@ Output.
<<Decays: unstable: TBP>>=
  procedure :: write => unstable_write
<<Decays: procedures>>=
  recursive subroutine unstable_write (object, unit, indent)
    class(unstable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose=.false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 2)
    end if
    call write_indent (u, ind)
    if (object%selected_decay > 0) then
       write (u, "(5x,A,I0)") "Sel. decay  = ", object%selected_decay
       call object%decay(object%selected_decay)%write (u, ind + 1)
    else
       write (u, "(5x,A)")  "Sel. decay  = [undefined]"
    end if
  end subroutine unstable_write
    
@ %def unstable_write
@ Write the embedded process instances.
<<Decays: unstable: TBP>>=
  procedure :: write_process_instances => unstable_write_process_instances
<<Decays: procedures>>=
  recursive subroutine unstable_write_process_instances &
       (unstable, unit, verbose)
    class(unstable_t), intent(in) :: unstable
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    if (unstable%selected_decay > 0) then
       call unstable%decay(unstable%selected_decay)% &
            write_process_instances (unit, verbose)
    end if
  end subroutine unstable_write_process_instances
  
@ %def unstable_write_process_instances
@ Initialization, using the configuration object.
<<Decays: unstable: TBP>>=
  procedure :: init => unstable_init
<<Decays: procedures>>=
  recursive subroutine unstable_init (unstable, config)
    class(unstable_t), intent(out) :: unstable
    type(unstable_config_t), intent(in), target :: config
    integer :: i
    unstable%config => config
    allocate (unstable%decay (size (config%decay_config)))
    do i = 1, size (config%decay_config)
       call unstable%decay(i)%init (config%decay_config(i))
    end do
  end subroutine unstable_init
  
@ %def unstable_init
@ Recursively link interactions to the parent process.  [[i_prt]] is
the index of the current outgoing particle in the parent interaction.
<<Decays: unstable: TBP>>=
  procedure :: link_interactions => unstable_link_interactions
<<Decays: procedures>>=
  recursive subroutine unstable_link_interactions (unstable, i_prt, trace)
    class(unstable_t), intent(inout) :: unstable
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (unstable%decay)
       call unstable%decay(i)%link_interactions (i_prt, trace)
    end do
  end subroutine unstable_link_interactions
    
@ %def unstable_link_interactions
@ Import the random-number generator state.
<<Decays: unstable: TBP>>=
  procedure :: import_rng => unstable_import_rng
<<Decays: procedures>>=
  subroutine unstable_import_rng (unstable, rng)
    class(unstable_t), intent(inout) :: unstable
    class(rng_t), intent(inout), allocatable :: rng
    call move_alloc (from = rng, to = unstable%rng)
  end subroutine unstable_import_rng
  
@ %def unstable_import_rng
@ Generate a decay chain.  First select a decay mode, then call the
[[select_chain]] method of the selected mode.
<<Decays: unstable: TBP>>=
  procedure :: select_chain => unstable_select_chain
<<Decays: procedures>>=
  recursive subroutine unstable_select_chain (unstable)
    class(unstable_t), intent(inout) :: unstable
    real(default) :: x
    call unstable%rng%generate (x)
    unstable%selected_decay = unstable%config%selector%select (x)
    call unstable%decay(unstable%selected_decay)%select_chain ()
  end subroutine unstable_select_chain
    
@ %def unstable_select_chain
@ Generate a decay event.
<<Decays: unstable: TBP>>=
  procedure :: generate => unstable_generate
<<Decays: procedures>>=
  recursive subroutine unstable_generate (unstable)
    class(unstable_t), intent(inout) :: unstable
    call unstable%decay(unstable%selected_decay)%generate ()
  end subroutine unstable_generate
    
@ %def unstable_generate
@
\subsection{Decay Chain}
While the decay configuration tree and the decay tree are static
entities (during a simulation run), the decay chain is dynamically
generated for each event.  The reason is that with the possibility of
several decay modes for each particle, and several terms for each
process, the total number of distinct decay chains is not under control.

Each entry in the decay chain is a connected parton state.  The origin
of the chain is a connected state in the parent process (not part of
the chain itself).  For each decay, mode and term chosen, we convolute
this with the isolated (!) state of the current decay, to generate a
new connected state.  We accumulate this chain by recursively
traversing the allocated decay tree.  Whenever a particle decays, it
becomes virtual and is replaced by its decay product, while all other
particles stay in the parton state as spectators.

Technically, we implement the decay chain as a stack structure and
include information from the associated decay object for easier
debugging.  This is a decay chain entry:
<<Decays: types>>=
  type, extends (connected_state_t) :: decay_chain_entry_t
     integer :: index = 0
     type(decay_config_t), pointer :: config => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
     type(decay_chain_entry_t), pointer :: previous => null ()
  end type decay_chain_entry_t
     
@ %def decay_chain_entry_t
@ This is the complete chain; we need just a pointer to the last
entry.  We also include a pointer to the master process instance,
which serves as the seed for the decay chain.  

The evaluator [[correlated_trace]] traces over all quantum numbers
for the final spin-correlated (but color-summed) evaluator of the
decay chain.  This allows us to compute the probability for a momentum
configuration, given that all individual density matrices (of the
initial process and the subsequent decays) have been normalized to one.

Note: This trace is summed over color, so color is treated exactly
when computing spin correlations.  However, we do not keep
non-diagonal color correlations.  When an event is accepted, we
compute probabilities for all color states and can choose one of them.
<<Decays: types>>=
  type :: decay_chain_t
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_term = 0
     type(evaluator_t) :: correlated_trace
     type(decay_chain_entry_t), pointer :: last => null ()
   contains
   <<Decays: decay chain: TBP>>
  end type decay_chain_t
  
@ %def decay_chain_t
@ The finalizer recursively deletes and deallocates the entries.
<<Decays: decay chain: TBP>>=
  procedure :: final => decay_chain_final
<<Decays: procedures>>=
  subroutine decay_chain_final (object)
    class(decay_chain_t), intent(inout) :: object
    type(decay_chain_entry_t), pointer :: entry
    do while (associated (object%last))
       entry => object%last
       object%last => entry%previous
       call entry%final ()
       deallocate (entry)
    end do
    call object%correlated_trace%final ()
  end subroutine decay_chain_final
  
@ %def decay_chain_final
@ Doing output recursively allows us to display the chain in
chronological order.
<<Decays: decay chain: TBP>>=
  procedure :: write => decay_chain_write
<<Decays: procedures>>=
  subroutine decay_chain_write (object, unit)
    class(decay_chain_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Decay chain:"
    call write_entries (object%last)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Evaluator (correlated trace of the decay chain):"
    call write_separator (u)
    call object%correlated_trace%write (u)
    call write_separator (u, 2)
  contains
    recursive subroutine write_entries (entry)
      type(decay_chain_entry_t), intent(in), pointer :: entry
      if (associated (entry)) then
         call write_entries (entry%previous)
         call write_separator (u, 2)
         write (u, "(1x,A,I0)")  "Decay #", entry%index
         call entry%config%write_header (u)
         write (u, "(3x,A,I0)")  "Selected MCI    = ", entry%selected_mci
         write (u, "(3x,A,I0)")  "Selected term   = ", entry%selected_term
         call entry%config%term_config(entry%selected_term)%write (u, indent=1)
         call entry%write (u)
      end if
    end subroutine write_entries
  end subroutine decay_chain_write
    
@ %def decay_chain_write
@
Build a decay chain, recursively following the selected decays and
terms in a decay tree.  Before start, we finalize the chain, deleting
any previous contents.
<<Decays: decay chain: TBP>>=
  procedure :: build => decay_chain_build
<<Decays: procedures>>=
  subroutine decay_chain_build (chain, decay_root)
    class(decay_chain_t), intent(inout), target :: chain
    type(decay_root_t), intent(in) :: decay_root
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(interaction_t), pointer :: int_last_decay
    call chain%final ()
    if (decay_root%selected_term > 0) then
       chain%process_instance => decay_root%process_instance
       chain%selected_term = decay_root%selected_term
       call chain%build_term_entries (decay_root%term(decay_root%selected_term))
    end if
    int_last_decay => chain%last%get_matrix_int_ptr ()
    allocate (qn_mask (int_last_decay%get_n_tot ()))
    call qn_mask%init (mask_f = .true., mask_c = .true., mask_h = .true.)
    call chain%correlated_trace%init_qn_sum (int_last_decay, qn_mask)
  end subroutine decay_chain_build
    
@ %def decay_chain_build
@ Build the entries that correspond to a decay term.  We have to scan
all unstable particles.
<<Decays: decay chain: TBP>>=
  procedure :: build_term_entries => decay_chain_build_term_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_term_entries (chain, term)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_term_t), intent(in) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          if (unstable%selected_decay > 0) then
             call chain%build_decay_entries &
                  (unstable%decay(unstable%selected_decay))
          end if
       end select
    end do
  end subroutine decay_chain_build_term_entries
  
@ %def decay_chain_build_term_entries
@ Build the entries that correspond to a specific decay.  The
decay term should have been determined, so we allocate a decay chain
entry and fill it, then proceed to child decays.

For the first entry, we convolute the connected state of the parent process
instance with the isolated state of the current
decay (which does not contain an extra beam entry for the parent).
For subsequent entries, we take the previous entry as first factor.

In principle, each chain entry (as a parton state) is capable of
holding a subevent object and associated expressions.  We currently do
not make use of that feature.

Before generating the decays, factor out the trace of the helicity
density matrix of the parent parton state.  This trace has
been used for unweighting the original event (unweighted case) or it
determines the overall weight, so it should not be taken into account
in the decay chain generation.
<<Decays: decay chain: TBP>>=
  procedure :: build_decay_entries => decay_chain_build_decay_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_decay_entries (chain, decay)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_t), intent(in) :: decay
    type(decay_chain_entry_t), pointer :: entry
    type(connected_state_t), pointer :: previous_state
    type(isolated_state_t), pointer :: current_decay
    type(helicity_t) :: hel
    type(quantum_numbers_t) :: qn_filter_conn
    allocate (entry)
    if (associated (chain%last)) then
       entry%previous => chain%last
       entry%index = entry%previous%index + 1
       previous_state => entry%previous%connected_state_t
    else
       entry%index = 1
       previous_state => &
            chain%process_instance%get_connected_state_ptr (chain%selected_term)
    end if
    entry%config => decay%config
    entry%selected_mci = decay%selected_mci
    entry%selected_term = decay%selected_term
    current_decay => decay%process_instance%get_isolated_state_ptr &
         (decay%selected_term)
    call entry%setup_connected_trace &
         (current_decay, previous_state%get_trace_int_ptr (), resonant=.true.)
    if (entry%config%flv%has_decay_helicity ()) then
       call hel%init (entry%config%flv%get_decay_helicity ())
       call qn_filter_conn%init (hel)
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
    else
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true.)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true.)
    end if
    chain%last => entry
    call chain%build_term_entries (decay%term(decay%selected_term))
  end subroutine decay_chain_build_decay_entries
    
@ %def decay_chain_build_decay_entries
@ Recursively fill the decay chain with momenta and evaluate the
matrix elements.  Since all evaluators should have correct source
entries at this point, momenta are automatically retrieved from the
appropriate process instance.


Like we did above for the parent process, factor out the trace for
each subsequent decay (the helicity density matrix in the isolated
state, which is taken for the convolution).
<<Decays: decay chain: TBP>>=
  procedure :: evaluate => decay_chain_evaluate
<<Decays: procedures>>=
  subroutine decay_chain_evaluate (chain)
    class(decay_chain_t), intent(inout) :: chain
    call evaluate (chain%last)
    call chain%correlated_trace%receive_momenta ()
    call chain%correlated_trace%evaluate ()
  contains
    recursive subroutine evaluate (entry)
      type(decay_chain_entry_t), intent(inout), pointer :: entry
      if (associated (entry)) then
         call evaluate (entry%previous)
         call entry%receive_kinematics ()
         call entry%evaluate_trace ()
         call entry%evaluate_event_data ()
      end if
    end subroutine evaluate
  end subroutine decay_chain_evaluate
  
@ %def decay_chain_evaluate
@ Return the probability of a decay chain.  This is given as the trace
of the density matrix with intermediate helicity correlations,
normalized by the product of the uncorrelated density matrix traces.  This
works only if an event has been evaluated and the [[correlated_trace]]
evaluator is filled.  By definition, this evaluator has only one
matrix element, and this must be real.
<<Decays: decay chain: TBP>>=
  procedure :: get_probability => decay_chain_get_probability
<<Decays: procedures>>=
  function decay_chain_get_probability (chain) result (x)
    class(decay_chain_t), intent(in) :: chain
    real(default) :: x
    x = real (chain%correlated_trace%get_matrix_element (1))
  end function decay_chain_get_probability
  
@ %def decay_chain_get_probability
@
\subsection{Decay as Event Transform}
The [[evt_decay]] object combines decay configuration, decay tree, and
chain in a single object, as an implementation of the [[evt]] (event
transform) abstract type.
<<Decays: public>>=
  public :: evt_decay_t
<<Decays: types>>=
  type, extends (evt_t) :: evt_decay_t
     type(decay_root_config_t) :: decay_root_config
     type(decay_root_t) :: decay_root
     type(decay_chain_t) :: decay_chain
   contains
   <<Decays: evt decay: TBP>>
  end type evt_decay_t
  
@ %def evt_decay_t
@ Output.  We display the currently selected decay tree, which
includes configuration data, and the decay chain, i.e., the evaluators.
<<Decays: evt decay: TBP>>=
  procedure :: write => evt_decay_write
<<Decays: procedures>>=
  subroutine evt_decay_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_decay_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    logical :: verb, verb2
    integer :: u
    u = given_output_unit (unit)
    verb = .true.;  if (present (verbose))  verb = verbose
    verb2 = .false.;  if (present (more_verbose))  verb2 = more_verbose
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: partonic decays"
    call write_separator (u, 2)
    call evt%base_write (u, testflag = testflag)
    if (verb) then
       call write_separator (u)
       call evt%decay_root%write (u)
       if (verb2) then
          call evt%decay_chain%write (u)
          call evt%decay_root%write_process_instances (u, verb)
       end if
    else
       call write_separator (u, 2)
    end if
  end subroutine evt_decay_write
    
@ %def evt_decay_write
@ Connect with a process instance and process.  This initializes the
decay configuration.  The process stack is used to look for process
objects that implement daughter decays.

When all processes are assigned, configure the decay tree instance, using the
decay tree configuration.  First obtain the branching ratios, then allocate
the decay tree.  This is done once for all events.
<<Decays: evt decay: TBP>>=
  procedure :: connect => evt_decay_connect
<<Decays: procedures>>=
  subroutine evt_decay_connect (evt, process_instance, model, process_stack)
    class(evt_decay_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model)
    call evt%decay_root_config%connect (process_instance%process, &
         model, process_stack, process_instance)
    call evt%decay_root_config%compute ()
    call evt%decay_root%init (evt%decay_root_config, evt%process_instance)
  end subroutine evt_decay_connect
  
@ %def evt_decay_connect
@ Prepare a new event: Select a decay chain and build the corresponding chain
object.
<<Decays: evt decay: TBP>>=
  procedure :: prepare_new_event => evt_decay_prepare_new_event
<<Decays: procedures>>=
  subroutine evt_decay_prepare_new_event (evt, i_mci, i_term)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    evt%decay_root%selected_mci = i_mci
    evt%decay_root%selected_term = i_term
    call evt%decay_root%select_chain ()
    call evt%decay_chain%build (evt%decay_root)
  end subroutine evt_decay_prepare_new_event
  
@ %def evt_decay_prepare_new_event
@ Generate a weighted event and assign the resulting weight
(probability).  We use a chain initialized by the preceding
subroutine, fill it with momenta and evaluate.
<<Decays: evt decay: TBP>>=
  procedure :: generate_weighted => evt_decay_generate_weighted
<<Decays: procedures>>=
  subroutine evt_decay_generate_weighted (evt, probability)
    class(evt_decay_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    call evt%decay_root%generate ()
    if (signal_is_pending ())  return
    call evt%decay_chain%evaluate ()
    probability = evt%decay_chain%get_probability ()
  end subroutine evt_decay_generate_weighted
  
@ %def evt_decay_generate_weighted
@ To create a usable event, we have to transform the interaction into a
particle set; this requires factorization for the correlated density matrix,
according to the factorization mode.
<<Decays: evt decay: TBP>>=
  procedure :: make_particle_set => evt_decay_make_particle_set
<<Decays: procedures>>=
  subroutine evt_decay_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(interaction_t), pointer :: int_matrix, int_flows
    type(decay_chain_entry_t), pointer :: last_entry
    last_entry => evt%decay_chain%last
    int_matrix => last_entry%get_matrix_int_ptr ()
    int_flows  => last_entry%get_flows_int_ptr ()
    call evt%factorize_interactions (int_matrix, int_flows, &
         factorization_mode, keep_correlations, r)
    call evt%tag_incoming ()
  end subroutine evt_decay_make_particle_set
    
@ %def event_decay_make_particle_set
@
Eliminate numerical noise for the associated process instances.
<<Decays: public>>=
  public :: pacify
<<Decays: interfaces>>=
  interface pacify
     module procedure pacify_decay
  end interface pacify
<<Decays: procedures>>=
  subroutine pacify_decay (evt)
    class(evt_decay_t), intent(inout) :: evt
    call pacify_decay_gen (evt%decay_root)
  contains
    recursive subroutine pacify_decay_gen (decay)
      class(decay_gen_t), intent(inout) :: decay
      if (associated (decay%process_instance)) then
         call pacify (decay%process_instance)
      end if
      if (decay%selected_term > 0) then
         call pacify_term (decay%term(decay%selected_term))
      end if
    end subroutine pacify_decay_gen
    recursive subroutine pacify_term (term)
      class(decay_term_t), intent(inout) :: term
      integer :: i
      do i = 1, size (term%particle_out)
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t);  call pacify_unstable (unstable)
         end select
      end do
    end subroutine pacify_term
    recursive subroutine pacify_unstable (unstable)
      class(unstable_t), intent(inout) :: unstable
      if (unstable%selected_decay > 0) then
         call pacify_decay_gen (unstable%decay(unstable%selected_decay))
      end if
    end subroutine pacify_unstable
  end subroutine pacify_decay
  
@ %def pacify
@
\subsection{Unit tests}
<<Decays: public>>=
  public :: decays_test
<<Decays: tests>>=
  subroutine decays_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Decays: execute tests>>
  end subroutine decays_test
  
@ %def decays_test
@
\subsubsection{Testbed}
As a variation of the [[prepare_test_process]] routine used elsewhere, we
define here a routine that creates two processes (scattering $ss\to ss$ and
decay $s\to f\bar f$), compiles and integrates them and prepares for event
generation. 
<<Decays: public>>=
  public :: prepare_testbed
<<Decays: tests>>=
  subroutine prepare_testbed &
       (lib, process_stack, prefix, os_data, &
        scattering, decay, decay_rest_frame)
    type(process_library_t), intent(out), target :: lib
    type(process_stack_t), intent(out) :: process_stack
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: scattering, decay
    logical, intent(in), optional :: decay_rest_frame

    type(model_data_t), target :: model
    class(model_data_t), pointer :: model_copy
    type(string_t) :: libname, procname1, procname2, run_id
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(process_entry_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(field_data_t), pointer :: field_data
    real(default) :: sqrts

    libname = prefix // "_lib"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    run_id = prefix

    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    if (scattering .and. decay) then
       field_data => model%get_field_ptr (25)
       call field_data%set (p_is_stable = .false.)
    end if
    
    call prc_test_create_library (libname, lib, &
         scattering = .true., decay = .true., &
         procname1 = procname1, procname2 = procname2)

    call reset_interaction_counter ()

    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    if (scattering) then

       allocate (rng_test_factory_t :: rng_factory)
       allocate (model_copy)
       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname1, &
            run_id, lib, os_data, qcd, rng_factory, model_copy)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       sqrts = 1000
       call process%setup_beams_sqrts (sqrts)
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
    if (decay) then
       allocate (rng_test_factory_t :: rng_factory)
       allocate (model_copy)
       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname2, &
            run_id, lib, os_data, qcd, rng_factory, model_copy)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       if (present (decay_rest_frame)) then
          call process%setup_beams_decay (rest_frame = decay_rest_frame)
       else
          call process%setup_beams_decay (rest_frame = .not. scattering)
       end if
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
    call model%final ()

  end subroutine prepare_testbed

@ %def prepare_testbed
@
\subsubsection{Simple decay configuration}
We define a branching configuration with two decay modes.  We set the
integral values by hand, so we do not need to evaluate processes, yet.
<<Decays: execute tests>>=
  call test (decays_1, "decays_1", &
       "branching and decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
!    type(model_t), pointer :: model
!    type(model_list_t) :: model_list
    type(flavor_t) :: flv_h
    type(flavor_t), dimension(2,1) :: flv_hbb, flv_hgg
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_1"
    write (u, "(A)")  "*   Purpose: Set up branching and decay configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_sm_test ()
!    call model_list%read_model (var_str ("SM"), &
!         var_str ("SM.mdl"), os_data, model)

    call flv_h%init (25, model)
    call flv_hbb(:,1)%init ([5, -5], model)
    call flv_hgg(:,1)%init ([22, 22], model)

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call unstable%init_decays ([var_str ("h_bb"), var_str ("h_gg")], model)
    
    associate (decay => unstable%decay_config(1))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hbb, stable = [.true., .true.], model=model)
      decay%integral = 1.234e-3_default
      decay%abs_error = decay%integral * .02_default
    end associate
    
    associate (decay => unstable%decay_config(2))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hgg, stable = [.true., .true.], model=model)
      decay%integral = 3.085e-4_default
      decay%abs_error = decay%integral * .08_default
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_1"
    
  end subroutine decays_1
  
@ %def decays_1
@
\subsubsection{Cascade decay configuration}
We define a branching configuration with one decay, which is followed
by another branching.
<<Decays: execute tests>>=
  call test (decays_2, "decays_2", &
       "cascade decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
!    type(model_t), pointer :: model
!    type(model_list_t) :: model_list
    type(model_data_t), target :: model
    type(flavor_t) :: flv_h, flv_wp, flv_wm
    type(flavor_t), dimension(2,1) :: flv_hww, flv_wud, flv_wen
    type(unstable_config_t), allocatable :: unstable
    type(string_t), dimension(:), allocatable :: decay

    write (u, "(A)")  "* Test output: decays_2"
    write (u, "(A)")  "*   Purpose: Set up cascade branching"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

!    call syntax_model_file_init ()
    call os_data_init (os_data)
!    call model_list%read_model (var_str ("SM"), &
!         var_str ("SM.mdl"), os_data, model)
    call model%init_sm_test ()

    call model%set_unstable (25, [var_str ("h_ww")])
    call model%set_unstable (24, [var_str ("w_ud"), var_str ("w_en")])

    call flv_h%init (25, model)
    call flv_hww(:,1)%init ([24, -24], model)
    call flv_wp%init (24, model)
    call flv_wm%init (-24, model)
    call flv_wud(:,1)%init ([2, -1], model)
    call flv_wen(:,1)%init ([-11, 12], model)
    

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call unstable%flv%get_decays (decay)
    call unstable%init_decays (decay, model)
    
    associate (decay => unstable%decay_config(1))

      decay%integral = 1.e-3_default
      decay%abs_error = decay%integral * .01_default

      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hww, stable = [.false., .true.], model=model)

      select type (w => decay%term_config(1)%prt(1)%c)
      type is (unstable_config_t)

         associate (w_decay => w%decay_config(1))
           w_decay%integral = 2._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wud, stable = [.true., .true.], &
                model=model)
         end associate
         associate (w_decay => w%decay_config(2))
           w_decay%integral = 1._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wen, stable = [.true., .true.], &
                model=model)
         end associate
         call w%compute ()

      end select
      
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()
!    call model_list%final ()
!    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_2"
    
  end subroutine decays_2
  
@ %def decays_2
@
\subsubsection{Decay and Process Object}
We define a branching configuration with one decay and connect this
with an actual process object.
<<Decays: execute tests>>=
  call test (decays_3, "decays_3", &
       "associate process", &
       u, results)
<<Decays: tests>>=
  subroutine decays_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix
    type(string_t) :: procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_3"
    write (u, "(A)")  "*   Purpose: Connect a decay configuration &
         &with a process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and integrate process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_3"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame=.false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    call unstable%flv%init (25, model)
    call unstable%init_decays ([procname2], model)
    
    write (u, "(A)")  "* Connect decay with process object"
    write (u, "(A)")

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_3"
    
  end subroutine decays_3

@ %def decays_3
@
\subsubsection{Decay and Process Object}
Building upon the previous test, we set up a decay instance and generate a
decay event.
<<Decays: execute tests>>=
  call test (decays_4, "decays_4", &
       "decay instance", &
       u, results)
<<Decays: tests>>=
  subroutine decays_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname2
    class(rng_t), allocatable :: rng
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable, target :: unstable
    type(unstable_t), allocatable :: instance

    write (u, "(A)")  "* Test output: decays_4"
    write (u, "(A)")  "*   Purpose: Create a decay process and evaluate &
         &an instance"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment, process, &
         &and decay configuration"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_4"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame = .false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()

    allocate (unstable)
    call unstable%flv%init (25, model)
    call unstable%init_decays ([procname2], model)
    
    call model%set_unstable (25, [procname2])

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()

    allocate (rng_test_t :: rng)

    allocate (instance)
    call instance%init (unstable)
    call instance%import_rng (rng)

    call instance%select_chain ()
    call instance%generate ()
    call instance%write (u)

    write (u, *)
    call instance%write_process_instances (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call instance%final ()
    call process_stack%final ()
    call unstable%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_4"
    
  end subroutine decays_4

@ %def decays_4
@
\subsubsection{Decay with Parent Process}
We define a scattering process $ss\to ss$ and subsequent decays $s\to f\bar
f$.
<<Decays: execute tests>>=
  call test (decays_5, "decays_5", &
       "parent process and decay", &
       u, results)
<<Decays: tests>>=
  subroutine decays_5 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(decay_root_config_t), target :: decay_root_config
    type(decay_root_t) :: decay_root
    type(decay_chain_t) :: decay_chain
    integer :: i

    write (u, "(A)")  "* Test output: decays_5"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_5"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize decay tree configuration"
    write (u, "(A)")

    call decay_root_config%connect (process, model, process_stack)
    call decay_root_config%compute ()
    call decay_root_config%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay tree"

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    call decay_root%init (decay_root_config, process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain"
    write (u, "(A)")

    decay_root%selected_mci = 1
    !!! Not yet implemented; there is only one term anyway:
    ! call process_instance%select_i_term (decay_root%selected_term)
    decay_root%selected_term = 1
    call decay_root%select_chain ()

    call decay_chain%build (decay_root)
    
    call decay_root%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call process%generate_unweighted_event (process_instance, &
         decay_root%selected_mci)
    call process_instance%evaluate_event_data ()
    
    call decay_root%generate ()
    
    associate (term => decay_root%term(1))
      do i = 1, 2
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t)
            associate (decay => unstable%decay(1))
              call pacify (decay%process_instance)
            end associate
         end select
      end do
    end associate
    
    write (u, "(A)")  "* Process instances"
    write (u, "(A)")
    
    call decay_root%write_process_instances (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay chain"
    write (u, "(A)")
    
    call decay_chain%evaluate ()
    call decay_chain%write (u)

    write (u, *)
    write (u, "(A,ES19.12)")  "chain probability =", &
         decay_chain%get_probability ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call decay_chain%final ()
    call decay_root%final ()
    call decay_root_config%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_5"
    
  end subroutine decays_5

@ %def decays_5
@
\subsubsection{Decay as Event Transform}
Again, we define a scattering process $ss\to ss$ and subsequent decays
$s\to f\bar f$.
<<Decays: execute tests>>=
  call test (decays_6, "decays_6", &
       "evt_decay object", &
       u, results)
<<Decays: tests>>=
  subroutine decays_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(evt_decay_t), target :: evt_decay
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: decays_6"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay object"

    call evt_decay%connect (process_instance, model, process_stack)

    write (u, "(A)")
    write (u, "(A)")  "* Generate scattering event"

    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain and generate event"
    write (u, "(A)")

    call evt_decay%prepare_new_event (1, 1)
    call evt_decay%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_decay%make_particle_set (factorization_mode, keep_correlations)

    call evt_decay%write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_decay%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_6"
    
  end subroutine decays_6

@ %def decays_6
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shower}
We might use matrix elements of LO and NLO to increase the accuracy of
the shower in the sense of matching as well as merging.
<<[[shower.f90]]>>=
<<File header>>

module shower

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use constants, only: pi, twopi, zero
  use format_utils, only: write_separator
  use string_utils
  use unit_tests
  use system_defs, only: LF
  use os_interface
  use diagnostics
  use lorentz
  use pdf
  use subevents
  
  use shower_base
  use matching_base
  
  use sm_qcd
  use particles
  use state_matrices, only: FM_IGNORE_HELICITY
  use model_data
  use variables
  use beam_structures
  use process_libraries
  use rng_base
  use mci_base
  use phs_base

  use event_transforms
  use models
  use hep_common
  use processes
  use process_stacks
  use rng_tao
  use mci_midpoint
  use phs_single
  use prc_core
  use prc_omega

  ! For integration tests
  use shower_core

<<Standard module head>>

<<Shower: public>>

<<Shower: parameters>>

<<Shower: types>>

contains

<<Shower: procedures>>

<<Shower: tests>>

end module shower
@ %def shower
@
\subsection{Configuration Parameters}
[[POWHEG_TESTING]] allows to disable the parton shower for validation
and testing of the POWHEG procedure.
<<Shower: parameters>>=
  logical, parameter :: POWHEG_TESTING = .false.

@ %def POWHEG_TESTING
@
\subsection{Event Transform}
The event transforms can do more than mere showering.  Especially, it
may reweight showered events to fixed-order matrix elements.  The
[[model_hadrons]] is supposed to be the SM variant that contains all
hadrons that can be generated in the shower.
<<Shower: public>>=
  public :: evt_shower_t
<<Shower: types>>=
  type, extends (evt_t) :: evt_shower_t
     type(shower_settings_t) :: settings
     class(shower_base_t), allocatable :: shower
     class(matching_t), allocatable :: matching
     type(model_t), pointer :: model_hadrons => null ()
     type(qcd_t), pointer :: qcd => null()
     type(pdf_data_t) :: pdf_data     
     type(os_data_t) :: os_data     
     logical :: is_first_event
   contains
   <<Shower: evt shower: TBP>>
  end type evt_shower_t
  
@ %def evt_shower_t
@ Output.
<<Shower: evt shower: TBP>>=
  procedure :: write => evt_shower_write
<<Shower: procedures>>=
  subroutine evt_shower_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_shower_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: shower"
    call write_separator (u)
    call evt%base_write (u, testflag = testflag, show_set = .false.)
    if (evt%particle_set_exists)  call evt%particle_set%write &
         (u, summary = .true., compressed = .true., testflag = testflag)
    call write_separator (u)
    call evt%settings%write (u)
  end subroutine evt_shower_write
    
@ %def evt_shower_write
<<Shower: evt shower: TBP>>=
  procedure :: connect => evt_shower_connect
<<Shower: procedures>>=
  subroutine evt_shower_connect &
       (evt, process_instance, model, process_stack)
    class(evt_shower_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model, process_stack)
    call evt%make_rng (evt%process)
    if (allocated (evt%matching)) then
       call evt%matching%connect (process_instance, model, evt%shower)
    end if
  end subroutine evt_shower_connect

@ %def evt_shower_connect
@ Initialize the event transformation.  This will be executed once
during dispatching.  The [[model_hadrons]] is supposed to be the SM
variant that contains all hadrons that may be generated in the
shower. 
<<Shower: evt shower: TBP>>=
  procedure :: init => evt_shower_init
<<Shower: procedures>>=
  subroutine evt_shower_init &
       (evt, settings, model_hadrons, os_data)
    class(evt_shower_t), intent(out) :: evt
    type(shower_settings_t), intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    type(os_data_t), intent(in) :: os_data    
    evt%settings = settings
    evt%os_data = os_data
    evt%model_hadrons => model_hadrons
    evt%is_first_event = .true.
  end subroutine evt_shower_init
  
@ %def evt_shower_init
@ Create RNG instances, spawned by the process object.
<<Shower: evt shower: TBP>>=
  procedure :: make_rng => evt_shower_make_rng
<<Shower: procedures>>=
  subroutine evt_shower_make_rng (evt, process)
    class(evt_shower_t), intent(inout) :: evt
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    call process%make_rng (rng)
    call evt%shower%import_rng (rng)
    if (allocated (evt%matching)) then
       call process%make_rng (rng)
       call evt%matching%import_rng (rng)
    end if
  end subroutine evt_shower_make_rng

@ %def evt_shower_make_rng
@ Things we want to do for a new event before the whole event
transformation chain is evaluated.
<<Shower: evt shower: TBP>>=
  procedure :: prepare_new_event => evt_shower_prepare_new_event
<<Shower: procedures>>=
  subroutine evt_shower_prepare_new_event (evt, i_mci, i_term)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    call evt%shower%prepare_new_event ()
  end subroutine evt_shower_prepare_new_event

@ %def evt_shower_prepare_new_event
@
<<Shower: evt shower: TBP>>=
  procedure :: first_event => evt_shower_first_event
<<Shower: procedures>>=
  subroutine evt_shower_first_event (evt)
    class(evt_shower_t), intent(inout) :: evt
    real(default) :: pdftest
    logical :: hadron_collision
    ! TODO: (bcn 2015-04-24) also set info for combine_with_particle_set
    call msg_debug (D_TRANSFORMS, "evt_shower_first_event")
    hadron_collision = .false.
    if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () <= 18)) then
       hadron_collision = .false.
    else if (all (evt%particle_set%prt(1:2)%flv%get_pdg_abs () >= 1000)) then
       hadron_collision = .true.
    else 
       call msg_fatal ("evt_shower didn't recognize beams setup")
    end if
    call msg_debug (D_TRANSFORMS, "hadron_collision", hadron_collision)
    if (allocated (evt%matching)) then
       evt%matching%is_hadron_collision = hadron_collision
       call evt%matching%first_event ()
    end if
    if (.not. hadron_collision .and. evt%settings%isr_active) then
       call msg_fatal ("?ps_isr_active is only intended for hadron-collisions")
    end if
    if (evt%pdf_data%type == STRF_LHAPDF5) then
       if (evt%settings%isr_active .and. hadron_collision) then
          call GetQ2max (0, pdftest)
          if (pdftest < epsilon (pdftest)) then
             call msg_bug ("ISR QCD shower enabled, but LHAPDF not" // &
                  "initialized," // LF // "     aborting simulation")
             return
          end if
       end if
    else if (evt%pdf_data%type == STRF_PDF_BUILTIN .and. &
             evt%settings%method == PS_PYTHIA6) then
       call msg_fatal ("Builtin PDFs cannot be used for PYTHIA showers," &
            // LF // "     aborting simulation")
       return
    end if
    !if (evt%settings%method == PS_PYTHIA6 .and. any (abs (IDBMUP) <= 8)) then
    !   call msg_fatal ("PYTHIA doesn't support quarks as beam particles")
    !end if
  end subroutine evt_shower_first_event

@ %def evt_shower_first_event
@ Here we take the particle set from the previous event transform
(assuming that there is always one) and apply the shower algorithm.  The
result is stored in the event transform of the current object.  We
always return a probability of unity as we don't have the analytic
weight of the combination of shower, MLM matching and hadronization.  A
subdivision into multiple event transformations is under construction.
Invalid or vetoed events have to be discarded by the caller which is why
we mark the particle set as invalid. This procedure directly takes the 
(MLM) matching into account.
<<Shower: evt shower: TBP>>=
  procedure :: generate_weighted => evt_shower_generate_weighted
<<Shower: procedures>>=
  subroutine evt_shower_generate_weighted (evt, probability)
    class(evt_shower_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    logical :: valid, vetoed
    call msg_debug (D_TRANSFORMS, "evt_shower_generate_weighted")
    evt%particle_set = evt%previous%particle_set
    valid = .true.;  vetoed = .false.
    if (evt%is_first_event) then
       call evt%first_event ()
       evt%is_first_event = .false.
    end if
    call evt%shower%import_particle_set (evt%particle_set, evt%os_data)
    if (allocated (evt%matching)) then
       call evt%matching%before_shower (evt%particle_set, vetoed)
       if (msg_level(D_TRANSFORMS) >= DEBUG) then
          call msg_debug (D_TRANSFORMS, "Matching before generate emissions")
          call evt%matching%write ()
       end if
    end if
    if (.not. (vetoed .or. POWHEG_TESTING)) then
       if (evt%settings%method == PS_PYTHIA6 .or. &
           evt%settings%hadronization_active) then
          call assure_heprup (evt%particle_set)
       end if
       call evt%shower%generate_emissions (valid)
    end if
    probability = 1
    evt%particle_set_exists = valid .and. .not. vetoed
  end subroutine evt_shower_generate_weighted

@ %def evt_shower_generate_weighted
@ Here, we fill the particle set with the partons from the shower.
The factorization parameters are irrelevant.  
We make a sanity check that the initial energy lands either in the
outgoing particles or add to the beam remnant.
<<Shower: evt shower: TBP>>=
  procedure :: make_particle_set => evt_shower_make_particle_set
<<Shower: procedures>>=
  subroutine evt_shower_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(vector4_t) :: sum_vec_in, sum_vec_out, sum_vec_beamrem, &
         sum_vec_beamrem_before
    logical :: vetoed, sane
    if (evt%particle_set_exists) then
       vetoed = .false.
       sum_vec_beamrem_before = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_BEAM_REMNANT)
       call evt%shower%make_particle_set (evt%particle_set, &
            evt%model, evt%model_hadrons)
       if (allocated (evt%matching)) then
          call evt%matching%after_shower (evt%particle_set, vetoed)
       end if
       if (debug_active (D_TRANSFORMS)) then
          call msg_debug (D_TRANSFORMS, &
               "Shower: obtained particle set after shower + matching")
          call evt%particle_set%write (summary = .true., compressed = .true.)
       end if
       sum_vec_in = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_INCOMING)
       sum_vec_out = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_OUTGOING)
       sum_vec_beamrem = sum (evt%particle_set%prt%p, &
            mask=evt%particle_set%prt%get_status () == PRT_BEAM_REMNANT)
       sum_vec_beamrem = sum_vec_beamrem - sum_vec_beamrem_before
       sane = abs(sum_vec_out%p(0) - sum_vec_in%p(0)) < &
            sum_vec_in%p(0) / 10 .or. &
            abs((sum_vec_out%p(0) + sum_vec_beamrem%p(0)) - sum_vec_in%p(0)) < &
            sum_vec_in%p(0) / 10
       evt%particle_set_exists = .not. vetoed .and. sane
    end if
  end subroutine evt_shower_make_particle_set

@ %def event_shower_make_particle_set
@
<<Shower: evt shower: TBP>>=
  procedure :: final => evt_shower_final
<<Shower: procedures>>=
  subroutine evt_shower_final (evt)
    class(evt_shower_t), intent(inout) :: evt
    call evt%base_final ()
    if (allocated (evt%matching))  call evt%matching%final ()
  end subroutine evt_shower_final

@ %def evt_shower_final
@
\subsection{Unit Tests}
<<Shower: public>>=
  public :: shower_test
<<Shower: tests>>=
  subroutine shower_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Shower: execute tests>>
  end subroutine shower_test
  
@ %def shower_test
@
\subsubsection{Testbed}
This sequence sets up a two-jet process, ready for generating events.
<<Shower: tests>>=
<<setup testbed>>
@
<<setup testbed>>=
  subroutine setup_testbed &
       (prefix, os_data, lib, model_list, process, process_instance)
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(out) :: os_data
    type(process_library_t), intent(out), target :: lib
    type(model_list_t), intent(out) :: model_list
    class(model_data_t), pointer :: model
    type(model_t), pointer :: model_tmp
    type(process_t), target, intent(out) :: process
    type(process_instance_t), target, intent(out) :: process_instance
    type(var_list_t), pointer :: model_vars
    type(string_t) :: model_name, libname, procname, run_id
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts

    model_name = "SM"
    libname = prefix // "_lib"
    procname = prefix // "p"
    run_id = "1"
    
    call os_data_init (os_data)
    allocate (rng_tao_factory_t :: rng_factory)
    allocate (model_tmp)
    call model_list%read_model (model_name, model_name // ".mdl", &
         os_data, model_tmp)
    model_vars => model_tmp%get_var_list_ptr ()
    call var_list_set_real (model_vars, var_str ("me"), 0._default, &
         is_known = .true.)
    model => model_tmp

    call lib%init (libname)

    allocate (prt_in (2), source = [var_str ("e-"), var_str ("e+")])
    allocate (prt_out (2), source = [var_str ("d"), var_str ("dbar")])

    allocate (entry)
    call entry%init (procname, model, n_in = 2, n_components = 1)
    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call lib%append (entry)

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    call process%init (procname, run_id, lib, os_data, &
         qcd, rng_factory, model)
    
    allocate (prc_omega_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    model => process%get_model_ptr ()

    select type (core_template)
    type is (prc_omega_t)
       call core_template%set_parameters (model = model)
    end select
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()
    
    call process_instance%init (process)
    call process%integrate (process_instance, 1, 1, 1000)
    call process%final_integration (1)

    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    call process%generate_weighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

  end subroutine setup_testbed

@ %def setup_testbed
@
\subsubsection{Trivial Test}
We generate a two-jet event and shower it using default settings, i.e.
in disabled mode.
<<Shower: execute tests>>=
  call test (shower_1, "shower_1", &
       "disabled shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    class(model_data_t), pointer :: model
    type(model_t), pointer :: model_hadrons
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    type(pdf_data_t) :: pdf_data
    integer :: factorization_mode
    logical :: keep_correlations
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_1"
    write (u, "(A)")  "*   Purpose: Two-jet event with disabled shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_1"), &
         os_data, lib, model_list, process, process_instance)

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    model => process%get_model_ptr ()
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (evt_shower%settings, pdf_data)
       call evt_shower%connect (process_instance, model)
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_1"
    
  end subroutine shower_1
  
@ %def shower_1
@
\subsubsection{FSR Shower}
We generate a two-jet event and shower it with the Whizard FSR shower.
<<Shower: execute tests>>=
  call test (shower_2, "shower_2", &
       "final-state shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    type(model_t), pointer :: model_hadrons
    class(model_data_t), pointer :: model
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    integer :: factorization_mode
    logical :: keep_correlations
    type(pdf_data_t) :: pdf_data
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_2"
    write (u, "(A)")  "*   Purpose: Two-jet event with FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_2"), &
         os_data, lib, model_list, process, process_instance)
    model => process%get_model_ptr ()
    
    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    settings%fsr_active = .true.

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (evt_shower%settings, pdf_data)
       call evt_shower%connect (process_instance, model)       
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u, testflag = .true.)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_2"
    
  end subroutine shower_2
  
@ %def shower_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Fixed Order NLO Events}

<<[[evt_nlo.f90]]>>=
<<File header>>

module evt_nlo

<<Use kinds>>
<<Use strings>>
  use constants
  use lorentz
  use diagnostics
  use sm_qcd
  use model_data
  use particles
  use processes
  use process_stacks
  use event_transforms
  use phs_fks

<<Standard module head>>

<<Evt Nlo: public>>

<<Evt Nlo: parameters>>

<<Evt Nlo: types>>

contains

<<Evt Nlo: procedures>>

end module evt_nlo

@ %def evt_nlo
@
<<Evt Nlo: parameters>>=
  integer, parameter :: ALPHAS_FROM_SQRTS = 1
  integer, parameter :: ALPHAS_FROM_PT = 2

@ %def evt_nlo parameters
@
<<Evt Nlo: public>>=
  public :: evt_nlo_t
<<Evt Nlo: types>>=
  type, extends (evt_t) :: evt_nlo_t
    type(phs_fks_generator_t) :: phs_fks_generator
    real(default) :: sqme_rad
    integer :: i_evaluation
    integer, dimension(:), allocatable :: emitters
    type(particle_set_t), dimension(:), allocatable :: particle_set_radiated
    type(qcd_t), pointer :: qcd => null ()
    integer :: alphas_mode = ALPHAS_FROM_SQRTS
  contains
  <<Evt Nlo: evt nlo: TBP>>
  end type evt_nlo_t
  
@ %def evt_nlo_t
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: write => evt_nlo_write
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_write (evt, unit, verbose, more_verbose, testflag)
    class(evt_nlo_t), intent(in) :: evt
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, more_verbose, testflag
  end subroutine evt_nlo_write

@ %def evt_nlo_write
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: connect => evt_nlo_connect
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_connect (evt, process_instance, model, process_stack)
    class(evt_nlo_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    integer :: n_in, n_out_born, n_emitters
    real(default) :: sqrts
    call evt%base_connect (process_instance, model, process_stack)
    associate (generator => evt%phs_fks_generator, &
               nlo_controller => process_instance%nlo_controller)
       n_in = nlo_controller%particle_data%n_in
       n_out_born = nlo_controller%particle_data%n_out_born
       sqrts = process_instance%get_sqrts ()
       call nlo_controller%setup_generator (generator, sqrts)
       generator%real_kinematics => nlo_controller%real_kinematics
       call generator%set_emitters (nlo_controller%reg_data%emitters)
       call generator%setup_masses (n_in + n_out_born)
       generator%is_massive = nlo_controller%get_mass_info(1)
    end associate
  end subroutine evt_nlo_connect

@ %def evt_nlo_connect
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: prepare_new_event => evt_nlo_prepare_new_event
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_prepare_new_event (evt, i_mci, i_term)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
  end subroutine evt_nlo_prepare_new_event

@ %def evt_nlo_prepare_new_event
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: generate_weighted => evt_nlo_generate_weighted
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_generate_weighted (evt, probability)
    class(evt_nlo_t), intent(inout) :: evt
    real(default), intent(inout) :: probability
    real(default) :: weight
    integer :: emitter
    evt%particle_set = evt%previous%particle_set
    if (evt%i_evaluation == 0) then
       weight = evt%compute_subtraction_weights ()
       probability = probability + weight
    else
       emitter = evt%emitters (evt%i_evaluation)
       call evt%generate_emission (emitter)
       probability = evt%sqme_rad
    end if
    evt%particle_set_exists = .true.
  end subroutine evt_nlo_generate_weighted

@ %def evt_nlo_generate_weighted
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: make_particle_set => evt_nlo_make_particle_set
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
  end subroutine evt_nlo_make_particle_set

@ %def evt_nlo_make_particle_set
@
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: build_radiated_particle_set => evt_nlo_build_radiated_particle_set
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_build_radiated_particle_set (evt, i_event)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: i_event
    real(default) :: r_col
    type(vector4_t), dimension(:), allocatable :: p_new
    integer, dimension(:), allocatable :: flv_radiated
    integer :: emitter
    evt%particle_set_radiated(i_event) = evt%particle_set
    if (evt%i_evaluation /= 0) then
       flv_radiated = evt%process_instance%nlo_controller%get_flv_state_real (1)
       call evt%rng%generate (r_col)
       emitter = evt%emitters (evt%i_evaluation)
       p_new = evt%process_instance%nlo_controller%get_momenta (born_phsp = .false.)
       call evt%particle_set_radiated(i_event)%build_radiation (p_new, emitter, flv_radiated, &
            evt%process_instance%process%get_model_ptr (), r_col) 
    end if
    evt%i_evaluation = evt%i_evaluation + 1
  end subroutine evt_nlo_build_radiated_particle_set

@ %def evt_nlo_build_radiated_particle_set
@ 
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: compute_subtraction_weights => evt_nlo_compute_subtraction_weights
<<Evt Nlo: procedures>>=
  function evt_nlo_compute_subtraction_weights (evt) result (weight)
    class(evt_nlo_t), intent(inout) :: evt
    real(default) :: weight
    type(vector4_t), dimension(:), allocatable :: p_born, p_real
    integer, dimension(:), allocatable :: emitters
    real(default), dimension(3) :: x_rad
    integer :: i, emitter
    real(default) :: alpha_s
    weight = zero
    associate (instance => evt%process_instance)
       emitters = instance%nlo_controller%get_emitter_list ()
       x_rad = instance%nlo_controller%real_kinematics%x_rad
       p_born = evt%particle_set%get_momenta ()
       call evt%phs_fks_generator%set_beam_energy (p_born(1)%p(0))
       call evt%phs_fks_generator%generate_radiation_variables (x_rad, p_born)
       do i = 1, size (emitters)
          emitter = emitters(i)
          if (emitter <= 2) then
             call msg_fatal ("NLO Events only for lepton collisions so far")
          else
             p_real = evt%phs_fks_generator%generate_fsr_from_x &
                  (x_rad, emitter, p_born)
          end if
          associate (nlo_controller => instance%nlo_controller)
             call nlo_controller%set_momenta (p_born, born_phsp = .true.)
             call nlo_controller%set_momenta (p_born, born_phsp = .true., cms = .true.)
             call nlo_controller%set_momenta (p_real, born_phsp = .false.)
             call nlo_controller%set_momenta (p_real, born_phsp = .false., cms = .true.)
             select case (evt%alphas_mode)
             case (ALPHAS_FROM_SQRTS) 
                alpha_s = evt%qcd%alpha%get (sqrt (nlo_controller%real_kinematics%cms_energy2))
             case (ALPHAS_FROM_PT)
                call msg_warning ("Transverse momentum as scale might yield problematic values")
                alpha_s = evt%qcd%alpha%get &
                   (transverse_part (p_real(emitter), p_real(nlo_controller%get_n_particles_real())))
             case default
                call msg_fatal ("evt_nlo: Undefined strong coupling type")
             end select
          end associate
          call instance%compute_sqme_real_sub (emitter, p_born, p_real, alpha_s)
          weight = weight + instance%sqme_collector%sqme_real_per_emitter (emitter)
       end do
    end associate
  end function evt_nlo_compute_subtraction_weights

@ %def evt_nlo_compute_subtraction_weights
@      
<<Evt Nlo: evt nlo: TBP>>=
  procedure :: generate_emission => evt_nlo_generate_emission
<<Evt Nlo: procedures>>=
  subroutine evt_nlo_generate_emission (evt, emitter)
    class(evt_nlo_t), intent(inout) :: evt
    integer, intent(in) :: emitter
    type(vector4_t), dimension(:), allocatable :: p_born, p_real
    integer :: n_born, n_real
    integer :: i
    real(default), dimension(3) :: x_rad
    real(default) :: alpha_s
    p_born = evt%particle_set%get_momenta ()
    associate (instance => evt%process_instance)
       x_rad = instance%nlo_controller%real_kinematics%x_rad
       call evt%phs_fks_generator%generate_radiation_variables (x_rad, p_born)
       if (emitter <= 2) then
          call msg_fatal ("NLO Events only for lepton collisions so far")
       else
          p_real = evt%phs_fks_generator%generate_fsr_from_x &
              (x_rad, emitter, p_born)
       end if
       associate (nlo_controller => instance%nlo_controller)
          call nlo_controller%set_momenta (p_born, born_phsp = .true.)
          call nlo_controller%set_momenta (p_born, born_phsp = .true., cms = .true.)
          call nlo_controller%set_momenta (p_real, born_phsp = .false.)
          call nlo_controller%set_momenta (p_real, born_phsp = .false., cms = .true.)
          select case (evt%alphas_mode)
          case (ALPHAS_FROM_SQRTS) 
             alpha_s = evt%qcd%alpha%get (sqrt (nlo_controller%real_kinematics%cms_energy2))
          case (ALPHAS_FROM_PT)
             call msg_warning ("Transverse momentum as scale might yield problematic values")
             alpha_s = evt%qcd%alpha%get &
                (transverse_part (p_real(emitter), p_real(nlo_controller%get_n_particles_real())))
          case default
             call msg_fatal ("evt_nlo: Undefined strong coupling type")
          end select
       end associate
       call instance%compute_sqme_real_rad (emitter, p_born, p_real, alpha_s)
       evt%sqme_rad = instance%sqme_collector%sqme_real_per_emitter (emitter)
    end associate
  end subroutine evt_nlo_generate_emission

@ %def evt_nlo_generate_emission
@
\section{Complete Events}

This module combines hard processes with decay chains, shower, and
hadronization (not implemented yet) to complete events.  It also
manages the input and output of event records in various formats.
<<[[events.f90]]>>=
<<File header>>

module events
  
<<Use kinds>>
<<Use strings>>
  use constants, only: one
  use io_units
  use format_utils, only: pac_fmt, write_separator
  use format_defs, only: FMT_12, FMT_14, FMT_19
  use unit_tests
  use diagnostics
  use os_interface
  use subevents
  use variables
  use expr_base
  use model_data
  use state_matrices
  use particles
  use interactions
  use subevt_expr
  use rng_base
  use process_libraries
  use processes
  use process_stacks
  use event_base
  use event_transforms
  use decays
  use evt_nlo

<<Standard module head>>

<<Events: public>>

<<Events: types>>

<<Events: interfaces>>

contains
  
<<Events: procedures>>

<<Events: tests>>

end module events
@ %def events
@
\subsection{Event configuration}
The parameters govern the transformation of an event to a particle set.

The [[safety_factor]] reduces the acceptance probability for
unweighting.  If greater than one, excess events become less likely,
but the reweighting efficiency also drops.

The [[sigma]] and [[n]] values, if nontrivial, allow for reweighting
the events according to the requested [[norm_mode]].

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions that apply to the current event.  The
workspaces for evaluating those expressions are set up in the
[[event_expr_t]] objects.  Note that these are really pointers,
so the actual nodes are not stored inside the event object.
<<Events: types>>=
  type :: event_config_t
     logical :: unweighted = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: factorization_mode = FM_IGNORE_HELICITY
     logical :: keep_correlations = .false.
     real(default) :: sigma = 1
     integer :: n = 1
     real(default) :: safety_factor = 1
     class(expr_factory_t), allocatable :: ef_selection
     class(expr_factory_t), allocatable :: ef_reweight
     class(expr_factory_t), allocatable :: ef_analysis
   contains
   <<Events: event config: TBP>>
  end type event_config_t

@ %def event_config_t
@ Output.
<<Events: event config: TBP>>=
  procedure :: write => event_config_write
<<Events: procedures>>=
  subroutine event_config_write (object, unit, show_expressions)
    class(event_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_expressions
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Unweighted         = ", object%unweighted
    write (u, "(3x,A,A)")   "Normalization      = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A)", advance="no")  "Helicity handling  = "
    select case (object%factorization_mode)
    case (FM_IGNORE_HELICITY)
       write (u, "(A)")  "drop"
    case (FM_SELECT_HELICITY)
       write (u, "(A)")  "select"
    case (FM_FACTOR_HELICITY)
       write (u, "(A)")  "factorize"
    end select
    write (u, "(3x,A,L1)")  "Keep correlations  = ", object%keep_correlations
    if (.not. nearly_equal (object%safety_factor, one)) then
       write (u, "(3x,A," // FMT_12 // ")")  &
            "Safety factor      = ", object%safety_factor
    end if
    if (present (show_expressions)) then
       if (show_expressions) then
          if (allocated (object%ef_selection)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event selection expression:"
             call object%ef_selection%write (u)
          end if
          if (allocated (object%ef_reweight)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event reweighting expression:"
             call object%ef_reweight%write (u)
          end if
          if (allocated (object%ef_analysis)) then
             call write_separator (u)
             write (u, "(3x,A)") "Analysis expression:"
             call object%ef_analysis%write (u)
          end if
       end if
    end if
  end subroutine event_config_write
  
@ %def event_config_write
@
\subsection{The event type}
This is the concrete implementation of the [[generic_event_t]] core
that is defined above in the [[event_base]] module.  The core manages
the main (dressed) particle set pointer and the current values for
weights and sqme.  The implementation adds configuration data,
expressions, process references, and event transforms.

Each event refers to a single elementary process.  This process may be
dressed by a shower, a decay chain etc.  We maintain pointers to a
process instance.

A list of event transforms (class [[evt_t]]) transform the connected
interactions of the process instance into the final particle set.  In
this list, the first transform is always the trivial one, which just
factorizes the process instance.  Subsequent transforms may apply
decays, etc.  The [[particle_set]] pointer identifies the particle set
that we want to be analyzed and returned by the event, usually the
last one.

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.

The [[sqme]] and [[weight]] values mirror corresponding values in the
[[expr]] subobject.  The idea is that when generating or reading
events, the event record is filled first, then the [[expr]] object
acquires copies.  These copies are used for writing events and as targets
for pointer variables in the analysis expression.

All data that involve user-provided expressions (selection, reweighting,
analysis) are handled by the [[expr]] subobject.  In particular, evaluating
the event-selection expression sets the [[passed]] flag.  Furthermore,
the [[expr]] subobject collects data that can be used in the analysis
and should be written to file, including copies of [[sqme]] and [[weight]].
<<Events: public>>=
  public :: event_t
<<Events: types>>=
  type, extends (generic_event_t) :: event_t
     type(event_config_t) :: config
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: instance => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_i_mci = 0
     integer :: selected_i_term = 0
     integer :: selected_channel = 0
     logical :: is_complete = .false.
     class(evt_t), pointer :: transform_first => null ()
     class(evt_t), pointer :: transform_last => null ()
     type(event_expr_t) :: expr
     logical :: selection_evaluated = .false.
     logical :: passed = .false.
     real(default), allocatable :: alpha_qcd_forced
     real(default), allocatable :: scale_forced
     real(default) :: reweight = 1
     logical :: analysis_flag = .false.
     integer :: i_event = 0
   contains
   <<Events: event: TBP>>
  end type event_t

@ %def event_t
@ Finalizer: the list of event transforms is deleted iteratively.
<<Events: event: TBP>>=
  procedure :: final => event_final
<<Events: procedures>>=
  subroutine event_final (object)
    class(event_t), intent(inout) :: object
    class(evt_t), pointer :: evt
    if (allocated (object%rng))  call object%rng%final ()
    call object%expr%final ()
    do while (associated (object%transform_first))
       evt => object%transform_first
       object%transform_first => evt%next
       call evt%final ()
       deallocate (evt)
    end do
  end subroutine event_final
    
@ %def event_final
@ Output.

Particle set: this is a pointer to one of the event transforms, so it
should suffice to print the latter.
<<Events: event: TBP>>=
  procedure :: write => event_write
<<Events: procedures>>=
  subroutine event_write (object, unit, show_process, show_transforms, &
       show_decay, verbose, testflag)
    class(event_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    logical :: prc, trans, dec, verb
    class(evt_t), pointer :: evt
    character(len=7) :: fmt   
    integer :: u, i
    call pac_fmt (fmt, FMT_19, FMT_14, testflag)
    u = given_output_unit (unit)
    prc = .true.;  if (present (show_process))  prc = show_process
    trans = .true.;  if (present (show_transforms))  trans = show_transforms
    dec = .true.;  if (present (show_decay))  dec = show_decay
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    if (object%is_complete) then
       write (u, "(1x,A)")  "Event"
    else
       write (u, "(1x,A)")  "Event [incomplete]"
    end if
    call write_separator (u)
    call object%config%write (u)
    if (object%sqme_ref_is_known () .or. object%weight_ref_is_known ()) then
       call write_separator (u)
    end if
    if (object%sqme_ref_is_known ()) then
       write (u, "(3x,A," // fmt // ")") &
            "Squared matrix el. = ", object%get_sqme_ref ()
       if (object%sqme_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A," // fmt // ",1x,I0)")  &
                  "alternate sqme   = ", object%get_sqme_alt(i), i
          end do
       end if
    end if
    if (object%weight_ref_is_known ()) then
       write (u, "(3x,A," // fmt // ")") &
            "Event weight       = ", object%get_weight_ref ()
       if (object%weight_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A," // fmt // ",1x,I0)")  &
                  "alternate weight = ", object%get_weight_alt(i), i
          end do
       end if
    end if
    if (object%selected_i_mci /= 0) then
       call write_separator (u)
       write (u, "(3x,A,I0)")  "Selected MCI group = ", object%selected_i_mci
       write (u, "(3x,A,I0)")  "Selected term      = ", object%selected_i_term
       write (u, "(3x,A,I0)")  "Selected channel   = ", object%selected_channel
    end if
    if (object%selection_evaluated) then
       call write_separator (u)
       write (u, "(3x,A,L1)")  "Passed selection   = ", object%passed
       if (object%passed) then
          write (u, "(3x,A," // fmt // ")") &
               "Reweighting factor = ", object%reweight
          write (u, "(3x,A,L1)") &
               "Analysis flag      = ", object%analysis_flag
       end if
    end if
    if (associated (object%instance)) then
       if (prc) then
          if (verb) then
             call object%instance%write (u, testflag)
          else
             call object%instance%write_header (u)
          end if
       end if
       if (trans) then
          evt => object%transform_first
          do while (associated (evt))
             select type (evt)
             type is (evt_decay_t)
                call evt%write (u, verbose = dec, more_verbose = verb, &
                     testflag = testflag)
             class default
                call evt%write (u, verbose = verb, testflag = testflag)
             end select
             call write_separator (u, 2)
             evt => evt%next
          end do
       else
          call write_separator (u, 2)
       end if
       if (object%expr%subevt_filled) then
          call object%expr%write (u, pacified = testflag)
          call write_separator (u, 2)
       end if
    else
       call write_separator (u, 2)
       write (u, "(1x,A)")  "Process instance: [undefined]"
       call write_separator (u, 2)
    end if
  end subroutine event_write

@ %def event_write
@
\subsection{Initialization}
Initialize: set configuration parameters, using a variable list.  We
do not call this [[init]], because this method name will be used by a type
extension.

The default normalization is [[NORM_SIGMA]], since the default
generation mode is weighted.

For unweighted events, we may want to a apply a safety factor to event
rejection.  (By default, this factor is unity and can be ignored.)

We also allocate the trivial event transform, which is always the
first one.
<<Events: event: TBP>>=
  procedure :: basic_init => event_init
<<Events: procedures>>=
  subroutine event_init (event, var_list, n_alt)
    class(event_t), intent(out) :: event
    type(var_list_t), intent(in), optional :: var_list
    integer, intent(in), optional :: n_alt
    type(string_t) :: norm_string
    logical :: polarized_events
    if (present (n_alt)) then
       call event%base_init (n_alt)
       call event%expr%init (n_alt)
    else
       call event%base_init (0)
    end if
    if (present (var_list)) then
       event%config%unweighted = var_list%get_lval (&
            var_str ("?unweighted"))
       norm_string = var_list%get_sval (&
            var_str ("$sample_normalization"))
       event%config%norm_mode = &
            event_normalization_mode (norm_string, event%config%unweighted)
       polarized_events = &
            var_list%get_lval (var_str ("?polarized_events"))
       if (polarized_events) then
          event%config%factorization_mode = FM_SELECT_HELICITY
       else
          event%config%factorization_mode = FM_IGNORE_HELICITY
       end if
       if (event%config%unweighted) then
          event%config%safety_factor = var_list%get_rval (&
               var_str ("safety_factor"))
       end if
    else
       event%config%norm_mode = NORM_SIGMA
    end if
    allocate (evt_trivial_t :: event%transform_first)
    event%transform_last => event%transform_first
  end subroutine event_init
    
@ %def event_init
@ Set the [[sigma]] and [[n]] values in the configuration record that
determine non-standard event normalizations.  If these numbers are not
set explicitly, the default value for both is unity, and event
renormalization has no effect.
<<Events: event: TBP>>=
  procedure :: set_sigma => event_set_sigma
  procedure :: set_n => event_set_n
<<Events: procedures>>=
  elemental subroutine event_set_sigma (event, sigma)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: sigma
    event%config%sigma = sigma
  end subroutine event_set_sigma

  elemental subroutine event_set_n (event, n)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: n
    event%config%n = n
  end subroutine event_set_n
  
@ %def event_set_n
@ Append an event transform (decays, etc.).  The transform is not yet
connected to a process.  The transform is then considered to belong to
the event object, and will be finalized together with it.  The
original pointer is removed.

We can assume that the trivial transform is already present in the
event object, at least.
<<Events: event: TBP>>=
  procedure :: import_transform => event_import_transform
<<Events: procedures>>=
  subroutine event_import_transform (event, evt)
    class(event_t), intent(inout) :: event
    class(evt_t), intent(inout), pointer :: evt
    event%transform_last%next => evt
    evt%previous => event%transform_last
    event%transform_last => evt
    evt => null ()
  end subroutine event_import_transform
    
@ %def event_import_transform
@
We link the event to an existing process instance.  This
includes the variable list, which is linked to the process variable
list.  Note that this is not necessarily identical to the variable
list used for event initialization.

The variable list will contain pointers to [[event]] subobjects, therefore the
[[target]] attribute.

Once we have a process connected, we can use it to obtain an event
generator instance.

The model and process stack may be needed by event transforms.  The
current model setting may be different from the model in the process
(regarding unstable particles, etc.).  The process stack can be used
for assigning extra processes that we need for the event transforms.
<<Events: event: TBP>>=
  procedure :: connect => event_connect
<<Events: procedures>>=
  subroutine event_connect (event, process_instance, model, process_stack)
    class(event_t), intent(inout), target :: event
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t) :: id
    integer :: num_id
    class(evt_t), pointer :: evt
    event%process => process_instance%process
    event%instance => process_instance
    id = event%process%get_id ()
    if (id /= "")  call event%expr%set_process_id (id)
    num_id = event%process%get_num_id ()
    if (num_id /= 0)  call event%expr%set_process_num_id (num_id)
    call event%expr%setup_vars (event%process%get_sqrts ())
    call event%expr%link_var_list (event%process%get_var_list_ptr ())
    call event%process%make_rng (event%rng)
    evt => event%transform_first
    do while (associated (evt))
       call evt%connect (process_instance, model, process_stack)
       evt => evt%next
    end do
  end subroutine event_connect

@ %def event_connect
@ Set the parse nodes for the associated expressions, individually.  The
parse-node pointers may be null.
<<Events: event: TBP>>=
  procedure :: set_selection => event_set_selection
  procedure :: set_reweight => event_set_reweight
  procedure :: set_analysis => event_set_analysis
<<Events: procedures>>=
  subroutine event_set_selection (event, ef_selection)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_selection
    allocate (event%config%ef_selection, source = ef_selection)
  end subroutine event_set_selection

  subroutine event_set_reweight (event, ef_reweight)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_reweight
    allocate (event%config%ef_reweight, source = ef_reweight)
  end subroutine event_set_reweight

  subroutine event_set_analysis (event, ef_analysis)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_analysis
    allocate (event%config%ef_analysis, source = ef_analysis)
  end subroutine event_set_analysis
  
@ %def event_set_selection
@ %def event_set_reweight
@ %def event_set_analysis
@ Create evaluation trees from the parse trees.  The [[target]] attribute is
required because the expressions contain pointers to event subobjects.
<<Events: event: TBP>>=
  procedure :: setup_expressions => event_setup_expressions
<<Events: procedures>>=
  subroutine event_setup_expressions (event)
    class(event_t), intent(inout), target :: event
    call event%expr%setup_selection (event%config%ef_selection)
    call event%expr%setup_analysis (event%config%ef_analysis)
    call event%expr%setup_reweight (event%config%ef_reweight)
  end subroutine event_setup_expressions
  
@ %def event_setup_expressions
@
\subsection{Evaluation}
To fill the [[particle_set]], i.e., the event record proper, we have
to apply all event transforms in order.  The last transform should
fill its associated particle set, factorizing the state matrix
according to the current settings.  There are several parameters
in the event configuration that control this.

We always fill the particle set for the first transform (the hard
process) and the last transform, if different from the first (the
fully dressed process).

Each event transform is an event generator of its own.  We choose to
generate an \emph{unweighted} event for each of them, even if the master
event is assumed to be weighted.  Thus, the overall event weight is
the one of the hard process only.  (There may be more options in future
extensions.)

We can generate the two random numbers that the factorization needs.
For testing purpose, we allow for providing them explicitly, as an option.
<<Events: event: TBP>>=
  procedure :: evaluate_transforms => event_evaluate_transforms
<<Events: procedures>>=
  subroutine event_evaluate_transforms (event, r)
    class(event_t), intent(inout) :: event
    real(default), dimension(:), intent(in), optional :: r
    class(evt_t), pointer :: evt
    integer :: i_term
    call event%discard_particle_set ()
    call event%check ()
    if (event%instance%is_complete_event ()) then
       call event%instance%select_i_term (i_term)
       event%selected_i_term = i_term
       evt => event%transform_first
       do while (associated (evt))
          call evt%prepare_new_event &
               (event%selected_i_mci, event%selected_i_term)
          evt => evt%next
       end do
       evt => event%transform_first
       do while (associated (evt))
          if (evt%only_weighted_events) then
!             call evt%generate_weighted (event%weight_prc)
             call evt%generate_weighted (event%sqme_prc)
          else
             call evt%generate_unweighted ()
          end if
          if (signal_is_pending ())  return
          call evt%make_particle_set (event%config%factorization_mode, &
               event%config%keep_correlations)
          if (signal_is_pending ())  return
          if (.not. evt%particle_set_exists) exit
          evt => evt%next
       end do
       evt => event%transform_last
       if (associated (evt) .and. evt%particle_set_exists) then
          if (event%nlo_event) then
             select type (evt)
             type is (evt_nlo_t)
                call evt%build_radiated_particle_set (event%i_event+1)
                call event%link_particle_set &
                   (evt%particle_set_radiated(event%i_event+1))
             end select
          else
             call event%link_particle_set (evt%particle_set)
          end if
       end if
    end if
  end subroutine event_evaluate_transforms
    
@ %def event_evaluate_transforms
@
Evaluate the event-related expressions, given a valid
[[particle_set]].  If [[update_sqme]] is set, we use the process
instance for the [[sqme_prc]] value.  The [[sqme_ref]] value is
always taken from the event record.

Note: without the explicit [[particle_set]] pointer, some gfortran 4.8
version corrupts its memory.
<<Events: event: TBP>>=
  procedure :: evaluate_expressions => event_evaluate_expressions
<<Events: procedures>>=
  subroutine event_evaluate_expressions (event)
    class(event_t), intent(inout) :: event
    type(particle_set_t), pointer :: particle_set
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call event%expr%fill_subevt (particle_set)
    end if
    if (event%weight_ref_is_known ()) then
       call event%expr%set (weight_ref = event%get_weight_ref ())
    end if
    if (event%weight_prc_is_known ()) then
       call event%expr%set (weight_prc = event%get_weight_prc ())
    end if
    if (event%excess_prc_is_known ()) then
       call event%expr%set (excess_prc = event%get_excess_prc ())
    end if
    if (event%sqme_ref_is_known ()) then
       call event%expr%set (sqme_ref = event%get_sqme_ref ())
    end if
    if (event%sqme_prc_is_known ()) then
       call event%expr%set (sqme_prc = event%get_sqme_prc ())
    end if
    if (event%has_valid_particle_set ()) then
       call event%expr%evaluate &
            (event%passed, event%reweight, event%analysis_flag)
       event%selection_evaluated = .true.
    end if
  end subroutine event_evaluate_expressions
  
@ %def event_evaluate_expressions
@ Report the result of the [[selection]] evaluation.
<<Events: event: TBP>>=
  procedure :: passed_selection => event_passed_selection
<<Events: procedures>>=
  function event_passed_selection (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    flag = event%passed
  end function event_passed_selection
  
@ %def event_passed_selection
@ Set alternate sqme and weight arrays.  This should be merged with
the previous routine, if the expressions are allowed to refer to these
values.
<<Events: event: TBP>>=
  procedure :: store_alt_values => event_store_alt_values
<<Events: procedures>>=
  subroutine event_store_alt_values (event)
    class(event_t), intent(inout) :: event
    if (event%weight_alt_is_known ()) then
       call event%expr%set (weight_alt = event%get_weight_alt ())
    end if
    if (event%sqme_alt_is_known ()) then
       call event%expr%set (sqme_alt = event%get_sqme_alt ())
    end if
  end subroutine event_store_alt_values
  
@ %def event_store_alt_values
@
\subsection{Reset to empty state}
Applying this, current event contents are marked as incomplete but
are not deleted.  In particular, the initialization is kept.
<<Events: event: TBP>>=
  procedure :: reset => event_reset
<<Events: procedures>>=
  subroutine event_reset (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%base_reset ()
    event%selected_i_mci = 0
    event%selected_i_term = 0
    event%selected_channel = 0
    event%is_complete = .false.
    call event%expr%reset ()
    event%selection_evaluated = .false.
    event%passed = .false.
    event%analysis_flag = .false.
    if (associated (event%instance)) then
       call event%instance%reset (reset_mci = .true.)
    end if
    if (allocated (event%alpha_qcd_forced))  deallocate (event%alpha_qcd_forced)
    if (allocated (event%scale_forced))  deallocate (event%scale_forced)
    evt => event%transform_first
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_reset
  
@ %def event_reset
@
\subsection{Squared Matrix Element and Weight}
Transfer the result of the process instance calculation to the
event record header.
<<Events: event: TBP>>=
  procedure :: import_instance_results => event_import_instance_results
<<Events: procedures>>=
  subroutine event_import_instance_results (event)
    class(event_t), intent(inout) :: event
    if (associated (event%instance)) then
       if (event%instance%has_evaluated_trace ()) then
          call event%set ( &
               sqme_prc = event%instance%get_sqme (), &
               weight_prc = event%instance%get_weight (), &
               excess_prc = event%instance%get_excess () &
               )
       end if
    end if
  end subroutine event_import_instance_results
  
@ %def event_import_instance_results
@ Duplicate the instance result / the reference result in the event
record.
<<Events: event: TBP>>=
  procedure :: accept_sqme_ref => event_accept_sqme_ref
  procedure :: accept_sqme_prc => event_accept_sqme_prc
  procedure :: accept_weight_ref => event_accept_weight_ref
  procedure :: accept_weight_prc => event_accept_weight_prc
<<Events: procedures>>=
  subroutine event_accept_sqme_ref (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_ref_is_known ()) then
       call event%set (sqme_prc = event%get_sqme_ref ())
    end if
  end subroutine event_accept_sqme_ref
  
  subroutine event_accept_sqme_prc (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_prc_is_known ()) then
       call event%set (sqme_ref = event%get_sqme_prc ())
    end if
  end subroutine event_accept_sqme_prc
  
  subroutine event_accept_weight_ref (event)
    class(event_t), intent(inout) :: event
    if (event%weight_ref_is_known ()) then
       call event%set (weight_prc = event%get_weight_ref ())
    end if
  end subroutine event_accept_weight_ref
  
  subroutine event_accept_weight_prc (event)
    class(event_t), intent(inout) :: event
    if (event%weight_prc_is_known ()) then
       call event%set (weight_ref = event%get_weight_prc ())
    end if
  end subroutine event_accept_weight_prc
  
@ %def event_accept_sqme_ref
@ %def event_accept_sqme_prc
@ %def event_accept_weight_ref
@ %def event_accept_weight_prc
@ Update the weight normalization, just after generation.  Unweighted
and weighted events are generated with a different default
normalization.  The intended normalization is stored in the
configuration record.
<<Events: event: TBP>>=
  procedure :: update_normalization => event_update_normalization
<<Events: procedures>>=
  subroutine event_update_normalization (event, mode_ref)
    class(event_t), intent(inout) :: event
    integer, intent(in), optional :: mode_ref
    integer :: mode_old
    real(default) :: weight, excess
    if (present (mode_ref)) then
       mode_old = mode_ref
    else if (event%config%unweighted) then
       mode_old = NORM_UNIT
    else
       mode_old = NORM_SIGMA
    end if
    weight = event%get_weight_prc ()
    call event_normalization_update (weight, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_weight_prc (weight)
    excess = event%get_excess_prc ()
    call event_normalization_update (excess, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_excess_prc (excess)
  end subroutine event_update_normalization
  
@ %def event_update_normalization
@
The event is complete if it has a particle set plus valid entries for
the sqme and weight values.
<<Events: event: TBP>>=
  procedure :: check => event_check
<<Events: procedures>>=
  subroutine event_check (event)
    class(event_t), intent(inout) :: event
    event%is_complete = event%has_valid_particle_set () &
         .and. event%sqme_ref_is_known () &
         .and. event%sqme_prc_is_known () &
         .and. event%weight_ref_is_known () &
         .and. event%weight_prc_is_known ()
    if (event%get_n_alt () /= 0) then
       event%is_complete = event%is_complete &
            .and. event%sqme_alt_is_known () &
            .and. event%weight_alt_is_known ()
    end if
  end subroutine event_check
  
@ %def event_check
@ 
@
\subsection{Generation}
Assuming that we have a valid process associated to the event, we
generate an event.  We complete the event data, then factorize the
spin density matrix and transfer it to the particle set.

When done, we retrieve squared matrix element and weight.  In case of
explicit generation, the reference values coincide with the process
values, so we [[accept]] the latter.

The explicit random number argument [[r]] should be generated by a
random-number generator.  It is taken for the factorization algorithm,
bypassing the event-specific random-number generator.  This is useful
for deterministic testing.
<<Events: event: TBP>>=
  procedure :: generate => event_generate
<<Events: procedures>>=
  subroutine event_generate (event, i_mci, r, i_nlo)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci
    real(default), dimension(:), intent(in), optional :: r
    integer, intent(in), optional :: i_nlo
    logical :: generate_new = .true.
    if (present (i_nlo)) generate_new = (i_nlo == 1)
    if (generate_new) call event%reset ()
    event%selected_i_mci = i_mci
    if (event%config%unweighted) then
       call event%process%generate_unweighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
       call event%instance%normalize_weight ()
    else
       if (event%nlo_event) &
          call event%process%deactivate_real_component ()
       if (generate_new) call event%process%generate_weighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
    end if
    event%selected_channel = event%instance%get_channel ()
    call event%import_instance_results ()
    call event%accept_sqme_prc ()
    call event%update_normalization ()
    call event%accept_weight_prc ()
    call event%evaluate_transforms (r)
    if (signal_is_pending ())  return
    call event%check ()
  end subroutine event_generate
  
@ %def event_generate
@ Get a copy of the particle set belonging to the hard process.
<<Events: event: TBP>>=
  procedure :: get_hard_particle_set => event_get_hard_particle_set
<<Events: procedures>>=
  subroutine event_get_hard_particle_set (event, pset)
    class(event_t), intent(in) :: event
    type(particle_set_t), intent(out) :: pset
    class(evt_t), pointer :: evt
    evt => event%transform_first
    pset = evt%particle_set
  end subroutine event_get_hard_particle_set
    
@ %def event_get_hard_particle_set
@
\subsection{Recovering an event}
Select MC group, term, and integration channel.
<<Events: event: TBP>>=
  procedure :: select => event_select
<<Events: procedures>>=
  subroutine event_select (event, i_mci, i_term, channel)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci, i_term, channel
    if (associated (event%instance)) then
       event%selected_i_mci = i_mci
       event%selected_i_term = i_term
       event%selected_channel = channel
    else
       call msg_bug ("Event: select term: process instance undefined")
    end if
  end subroutine event_select

@ %def event_select
@ 
Copy a particle set into the event record.

We deliberately use the first (the trivial) transform for this, i.e.,
the hard process.  The event reader may either read in the transformed
event separately, or apply all event
transforms to the hard particle set to (re)generate a fully dressed
event.

Since this makes all subsequent event transforms invalid, we call
[[reset]] on them.
<<Events: event: TBP>>=
  procedure :: set_hard_particle_set => event_set_hard_particle_set
<<Events: procedures>>=
  subroutine event_set_hard_particle_set (event, particle_set)
    class(event_t), intent(inout) :: event
    type(particle_set_t), intent(in) :: particle_set
    class(evt_t), pointer :: evt
    evt => event%transform_first
    call evt%set_particle_set (particle_set, &
         event%selected_i_mci, event%selected_i_term)
    call event%link_particle_set (evt%particle_set)
    evt => evt%next
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_set_hard_particle_set

@ %def event_set_hard_particle_set
@
Set the $\alpha_s$ value that should be used in a recalculation.  This should
be called only if we explicitly want to override the QCD setting of the
process core.
<<Events: event: TBP>>=
  procedure :: set_alpha_qcd_forced => event_set_alpha_qcd_forced
<<Events: procedures>>=
  subroutine event_set_alpha_qcd_forced (event, alpha_qcd)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: alpha_qcd
    if (allocated (event%alpha_qcd_forced)) then
       event%alpha_qcd_forced = alpha_qcd
    else
       allocate (event%alpha_qcd_forced, source = alpha_qcd)
    end if
  end subroutine event_set_alpha_qcd_forced
  
@ %def event_set_alpha_qcd_forced
@
Analogously, for the common scale.  This forces also renormalization and
factorization scale.
<<Events: event: TBP>>=
  procedure :: set_scale_forced => event_set_scale_forced
<<Events: procedures>>=
  subroutine event_set_scale_forced (event, scale)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: scale
    if (allocated (event%scale_forced)) then
       event%scale_forced = scale
    else
       allocate (event%scale_forced, source = scale)
    end if
  end subroutine event_set_scale_forced
  
@ %def event_set_scale_forced
@
Here we try to recover an event from the [[particle_set]] subobject
and recalculate the structure functions and matrix elements.  We
have the appropriate [[process]] object and an initialized
[[process_instance]] at hand, so beam and configuration data are
known.  From the [[particle_set]], we get the momenta.

The quantum-number information may be incomplete, e.g., helicity
information may be partial or absent.  We recover the event just from
the momentum configuration.

We do not transfer the matrix element from the process instance to the
event record, as we do when generating an event.  The event record may
contain the matrix element as read from file, and the current
calculation may use different parameters.  We thus can compare old and
new values.

The event [[weight]] may also be known already.  If yes, we pass it to the
[[evaluate_event_data]] procedure.  It should already be normalized.  If we
have an [[weight_factor]] value, we obtain the event weight by multiplying the
computed [[sqme]] by this factor.  Otherwise, we make use of the MCI setup
(which should be valid then) to compute the event weight, and we should
normalize the result just as when generating events.

Evaluating event expressions must also be done separately.
<<Events: event: TBP>>=
  procedure :: recalculate => event_recalculate
<<Events: procedures>>=
  subroutine event_recalculate &
       (event, update_sqme, weight_factor, recover_beams)
    class(event_t), intent(inout) :: event
    logical, intent(in) :: update_sqme
    real(default), intent(in), optional :: weight_factor
    logical, intent(in), optional :: recover_beams
    type(particle_set_t), pointer :: particle_set
    integer :: i_mci, i_term, channel
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       i_mci = event%selected_i_mci
       i_term = event%selected_i_term
       channel = event%selected_channel
       if (i_mci == 0 .or. i_term == 0 .or. channel == 0) then
          call msg_bug ("Event: recalculate: undefined selection parameters")
       end if
       call event%instance%choose_mci (i_mci)
       call event%instance%set_trace (particle_set, i_term, recover_beams)
       if (allocated (event%alpha_qcd_forced)) then
          call event%instance%set_alpha_qcd_forced &
               (i_term, event%alpha_qcd_forced)
       end if
       call event%instance%recover (channel, i_term, update_sqme, &
            event%scale_forced) 
       if (signal_is_pending ())  return
       if (update_sqme .and. present (weight_factor)) then
          call event%instance%evaluate_event_data &
               (weight = event%instance%get_sqme () * weight_factor)
       else if (event%weight_ref_is_known ()) then
          call event%instance%evaluate_event_data &
               (weight = event%get_weight_ref ())
       else
          call event%process%recover_event (event%instance, i_term)
          if (signal_is_pending ())  return
          call event%instance%evaluate_event_data ()
          if (event%config%unweighted) then
             call event%instance%normalize_weight ()
          end if
       end if
       if (signal_is_pending ())  return
       if (update_sqme) then
          call event%import_instance_results ()
       else
          call event%accept_sqme_ref ()
          call event%accept_weight_ref ()
       end if
    else
       call msg_bug ("Event: can't recalculate, particle set is undefined")
    end if
  end subroutine event_recalculate
  
@ %def event_recalculate
@
\subsection{Access content}
Pointer to the associated process object (the associated model).
<<Events: event: TBP>>=
  procedure :: get_process_ptr => event_get_process_ptr
  procedure :: get_process_instance_ptr => event_get_process_instance_ptr
  procedure :: get_model_ptr => event_get_model_ptr
<<Events: procedures>>=
  function event_get_process_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_t), pointer :: ptr
    ptr => event%process
  end function event_get_process_ptr

  function event_get_process_instance_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_instance_t), pointer :: ptr
    ptr => event%instance
  end function event_get_process_instance_ptr

  function event_get_model_ptr (event) result (model)
    class(event_t), intent(in) :: event
    class(model_data_t), pointer :: model
    model => event%process%get_model_ptr ()
  end function event_get_model_ptr

@ %def event_get_process_ptr
@ %def event_get_process_instance_ptr
@ %def event_get_model_ptr
@ Return the current values of indices: the MCI group of components, the term
index (different terms corresponding, potentially, to different effective
kinematics), and the MC integration channel.  The [[i_mci]] call is delegated
to the current process instance.
<<Events: event: TBP>>=
  procedure :: get_i_mci => event_get_i_mci
  procedure :: get_i_term => event_get_i_term
  procedure :: get_channel => event_get_channel
<<Events: procedures>>=
  function event_get_i_mci (event) result (i_mci)
    class(event_t), intent(in) :: event
    integer :: i_mci
    i_mci = event%selected_i_mci
  end function event_get_i_mci
  
  function event_get_i_term (event) result (i_term)
    class(event_t), intent(in) :: event
    integer :: i_term
    i_term = event%selected_i_term
  end function event_get_i_term
  
  function event_get_channel (event) result (channel)
    class(event_t), intent(in) :: event
    integer :: channel
    channel = event%selected_channel
  end function event_get_channel
  
@ %def event_get_i_mci
@ %def event_get_i_term
@ %def event_get_channel
@ This flag tells us whether the event consists just of a hard process
(i.e., holds at most the first, trivial transform), or is a dressed
events with additional transforms.
<<Events: event: TBP>>=
  procedure :: has_transform => event_has_transform
<<Events: procedures>>=
  function event_has_transform (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    if (associated (event%transform_first)) then
       flag = associated (event%transform_first%next)
    else
       flag = .false.
    end if
  end function event_has_transform
  
@ %def event_has_transform
@ Return the currently selected normalization mode, or alternate
normalization mode.
<<Events: event: TBP>>=
  procedure :: get_norm_mode => event_get_norm_mode
<<Events: procedures>>=
  elemental function event_get_norm_mode (event) result (norm_mode)
    class(event_t), intent(in) :: event
    integer :: norm_mode
    norm_mode = event%config%norm_mode
  end function event_get_norm_mode
  
@ %def event_get_norm_mode
@ Return the kinematical weight, defined as the ratio of event weight
and squared matrix element.
<<Events: event: TBP>>=
  procedure :: get_kinematical_weight => event_get_kinematical_weight
<<Events: procedures>>=
  function event_get_kinematical_weight (event) result (f)
    class(event_t), intent(in) :: event
    real(default) :: f
    if (event%sqme_ref_is_known () .and. event%weight_ref_is_known () &
         .and. abs (event%get_sqme_ref ()) > 0) then
       f = event%get_weight_ref () / event%get_sqme_ref ()
    else
       f = 0
    end if
  end function event_get_kinematical_weight
    
@ %def event_get_kinematical_weight
@ Return data used by external event formats.
<<Events: event: TBP>>=
  procedure :: get_index => event_get_index
  procedure :: get_fac_scale => event_get_fac_scale
  procedure :: get_alpha_s => event_get_alpha_s
<<Events: procedures>>=
  function event_get_index (event) result (index)
    class(event_t), intent(in) :: event
    integer :: index
    index = event%expr%index
  end function event_get_index
    
  function event_get_fac_scale (event) result (fac_scale)
    class(event_t), intent(in) :: event
    real(default) :: fac_scale
    fac_scale = event%instance%get_fac_scale (event%selected_i_term)
  end function event_get_fac_scale
    
  function event_get_alpha_s (event) result (alpha_s)
    class(event_t), intent(in) :: event
    real(default) :: alpha_s
    alpha_s = event%instance%get_alpha_s (event%selected_i_term)
  end function event_get_alpha_s
    
@ %def event_get_index
@ %def event_get_fac_scale
@ %def event_get_alpha_s
@
Eliminate numerical noise in the [[subevt]] expression and in the event
transforms (which includes associated process instances).
<<Events: public>>=
  public :: pacify
<<Events: interfaces>>=
  interface pacify
     module procedure pacify_event
  end interface pacify
<<Events: procedures>>=
  subroutine pacify_event (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%pacify_particle_set ()
    if (event%expr%subevt_filled)  call pacify (event%expr)
    evt => event%transform_first
    do while (associated (evt))
       select type (evt)
       type is (evt_decay_t);  call pacify (evt)
       end select
       evt => evt%next
    end do
  end subroutine pacify_event
  
@ %def pacify
@
\subsection{Unit tests}
<<Events: public>>=
  public :: events_test
<<Events: tests>>=
  subroutine events_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Events: execute tests>>
  end subroutine events_test
  
@ %def events_test
@
\subsubsection{Empty event record}
<<Events: execute tests>>=
  call test (events_1, "events_1", &
       "empty event record", &
       u, results)
<<Events: tests>>=
  subroutine events_1 (u)
    integer, intent(in) :: u
    type(event_t), target :: event

    write (u, "(A)")  "* Test output: events_1"
    write (u, "(A)")  "*   Purpose: display an empty event object"
    write (u, "(A)")

    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_1"
    
  end subroutine events_1
  
@ %def events_1
@
\subsubsection{Simple event}
<<Events: execute tests>>=
  call test (events_2, "events_2", &
       "generate event", &
       u, results)
<<Events: tests>>=
  subroutine events_2 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_2"
    write (u, "(A)")  "*   Purpose: generate and display an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process%generate_weighted_event (process_instance, 1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_2"
    
  end subroutine events_2
  
@ %def events_2
@
\subsubsection{Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event from that.

Note: The extra [[particle_set_ptr]] auxiliary is a workaround for
memory corruption in gfortran 4.7.
<<Events: execute tests>>=
  call test (events_4, "events_4", &
       "recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_4 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    type(particle_set_t), pointer :: particle_set_ptr
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_4"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set_ptr => event%get_particle_set_ptr ()
    particle_set = particle_set_ptr

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .true.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transfer sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%accept_sqme_prc ()
    call event%accept_weight_prc ()
    call event%check ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset contents"
    write (u, "(A)")

    call event%reset ()
    event%transform_first%particle_set_exists = .false.
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_4"
    
  end subroutine events_4
  
@ %def events_4
@
\subsubsection{Partially Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event as far as possible
without recomputing the squared matrix element.
<<Events: execute tests>>=
  call test (events_5, "events_5", &
       "partially recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_5 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    type(particle_set_t), pointer :: particle_set_ptr
    real(default) :: sqme, weight
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_5"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set_ptr => event%get_particle_set_ptr ()
    particle_set = particle_set_ptr
    sqme = event%get_sqme_ref ()
    weight = event%get_weight_ref ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .false.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Manually set sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%set (sqme_ref = sqme, weight_ref = weight)
    call event%accept_sqme_ref ()
    call event%accept_weight_ref ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_5"
    
  end subroutine events_5
  
@ %def events_5
@
\subsubsection{Decays}
Generate an event with subsequent decays.
<<Events: execute tests>>=
  call test (events_6, "events_6", &
       "decays", &
       u, results)
<<Events: tests>>=
  subroutine events_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname1, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    class(evt_t), pointer :: evt_decay
    type(event_t), allocatable, target :: event
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_6"
    write (u, "(A)")  "*   Purpose: generate an event with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process and decay"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "events_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event transform: decay"

    allocate (evt_decay_t :: evt_decay)
    call evt_decay%connect (process_instance, model, process_stack)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"
    write (u, "(A)")

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, model)
    call event%import_transform (evt_decay)
    
    call event%write (u, show_decay = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_6"
    
  end subroutine events_6
  
@ %def events_6
@
\subsubsection{Decays}
Generate a decay event with varying options.
<<Events: execute tests>>=
  call test (events_7, "events_7", &
       "decay options", &
       u, results)
<<Events: tests>>=
  subroutine events_7 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_7"
    write (u, "(A)")  "*   Purpose: check decay options"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare test process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "events_7"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true.)

    write (u, "(A)")  "* Generate decay event, default options"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, helicity-diagonal decay"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], diagonal = .true.)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, isotropic decay, &
         &polarized final state"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], isotropic = .true.)
    call model%set_polarized (6)
    call model%set_polarized (-6)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_7"
    
  end subroutine events_7
  
@ %def events_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Raw Event I/O}
The raw format is for internal use only.  All data are stored
unformatted, so they can be efficiently be re-read on the same
machine, but not necessarily on another machine.

This module explicitly depends on the [[events]] module which provides the
concrete implementation of [[event_base]].  The other I/O formats
access only the methods that are defined in [[event_base]].
<<[[eio_raw.f90]]>>=
<<File header>>

module eio_raw
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use variables
  use model_data
  use particles
  use event_base
  use eio_data
  use eio_base
  use events

<<Standard module head>>

<<EIO raw: public>>

<<EIO raw: parameters>>

<<EIO raw: types>>

contains
  
<<EIO raw: procedures>>

<<EIO raw: tests>>

end module eio_raw
@ %def eio_raw
@
\subsection{File Format Version}
This is the current default file version. 
<<EIO raw: parameters>>=
  integer, parameter :: CURRENT_FILE_VERSION = 2

@ %def CURRENT_FILE_VERSION
@ The user may change this number; this should force some
compatibility mode for reading and writing.  In any case, the file
version stored in a event file that we read has to match the expected
file version.

History of version numbers:
\begin{enumerate}
\item
  Format for WHIZARD 2.2.0 to 2.2.3.  No version number stored in the raw file.
\item
  Format from 2.2.4 on.  File contains version number.  The file
  contains the transformed particle set (if applicable) after the
  hard-process particle set.
\end{enumerate}
@
\subsection{Type}
Note the file version number.  The default may be reset during
initialization, which should enforce some compatibility mode.
<<EIO raw: public>>=
  public :: eio_raw_t
<<EIO raw: types>>=
  type, extends (eio_t) :: eio_raw_t
     logical :: reading = .false.
     logical :: writing = .false.
     integer :: unit = 0
     integer :: norm_mode = NORM_UNDEFINED
     real(default) :: sigma = 1
     integer :: n = 1
     integer :: n_alt = 0
     logical :: check = .false.
     integer :: file_version = CURRENT_FILE_VERSION
   contains
   <<EIO raw: eio raw: TBP>>
  end type eio_raw_t
  
@ %def eio_raw_t
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO raw: eio raw: TBP>>=
  procedure :: write => eio_raw_write
<<EIO raw: procedures>>=
  subroutine eio_raw_write (object, unit)
    class(eio_raw_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Raw event stream:"
    write (u, "(3x,A,L1)")  "Check MD5 sum     = ", object%check
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alternate weights = ", object%n_alt
    end if
    if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_raw_write
  
@ %def eio_raw_write
@ Finalizer: close any open file.
<<EIO raw: eio raw: TBP>>=
  procedure :: final => eio_raw_final
<<EIO raw: procedures>>=
  subroutine eio_raw_final (object)
    class(eio_raw_t), intent(inout) :: object
    if (object%reading .or. object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing raw file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%reading = .false.
       object%writing = .false.
    end if
  end subroutine eio_raw_final
  
@ %def eio_raw_final
@ Set the [[check]] flag which determines whether we compare checksums on input.
<<EIO raw: eio raw: TBP>>=
  procedure :: set_parameters => eio_raw_set_parameters
<<EIO raw: procedures>>=
  subroutine eio_raw_set_parameters (eio, check, version_string, extension)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(in), optional :: check
    type(string_t), intent(in), optional :: version_string
    type(string_t), intent(in), optional :: extension 
    if (present (check))  eio%check = check
    if (present (version_string)) then
       select case (char (version_string))
       case ("", "2.2.4")
          eio%file_version = CURRENT_FILE_VERSION
       case ("2.2")
          eio%file_version = 1
       case default
          call msg_fatal ("Raw event I/O: unsupported version '" &
               // char (version_string) // "'")
          eio%file_version = 0
       end select
    end if
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
  end subroutine eio_raw_set_parameters
    
@ %def eio_raw_set_parameters
@ Initialize event writing.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_out => eio_raw_init_out
<<EIO raw: procedures>>=
  subroutine eio_raw_init_out (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i
    if (present (extension)) then
       eio%extension  = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    if (present (data)) then
       md5sum_prc = data%md5sum_prc
       md5sum_cfg = data%md5sum_cfg
       eio%norm_mode = data%norm_mode
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
       eio%n_alt = data%n_alt
       if (eio%n_alt > 0) then
          !!! !!! !!! Workaround for gfortran 5.0 ICE
          allocate (md5sum_alt (data%n_alt))
          md5sum_alt = data%md5sum_alt
          !!! allocate (md5sum_alt (data%n_alt), source = data%md5sum_alt) 
       end if
    else
       md5sum_prc = ""
       md5sum_cfg = ""
    end if
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", status = "replace")
    select case (eio%file_version)
    case (2:);  write (eio%unit)  eio%file_version
    end select
    write (eio%unit)  md5sum_prc
    write (eio%unit)  md5sum_cfg
    write (eio%unit)  eio%norm_mode
    write (eio%unit)  eio%n_alt
    do i = 1, eio%n_alt
       write (eio%unit)  md5sum_alt(i)
    end do
    if (present (success))  success = .true.
  end subroutine eio_raw_init_out
    
@ %def eio_raw_init_out
@ Initialize event reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_in => eio_raw_init_in
<<EIO raw: procedures>>=
  subroutine eio_raw_init_in (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i, file_version
    if (present (success))  success = .true.
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    if (present (data)) then
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
    end if
    write (msg_buffer, "(A,A,A)")  "Events: reading from raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%reading = .true.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "read", status = "old")
    select case (eio%file_version)
    case (2:);  read (eio%unit)  file_version
    case default;  file_version = 1
    end select
    if (file_version /= eio%file_version) then
       call msg_error ("Reading event file: raw-file version mismatch.")
       if (present (success))  success = .false.
       return
    else if (file_version /= CURRENT_FILE_VERSION) then
       call msg_warning ("Reading event file: compatibility mode.")
    end if
    read (eio%unit)  md5sum_prc
    read (eio%unit)  md5sum_cfg
    read (eio%unit)  eio%norm_mode
    read (eio%unit)  eio%n_alt
    if (present (data)) then
       if (eio%n_alt /= data%n_alt) then
          if (present (success))  success = .false. !
          return
       end if
    end if
    allocate (md5sum_alt (eio%n_alt))
    do i = 1, eio%n_alt
       read (eio%unit)  md5sum_alt(i)
    end do
    if (present (success)) then
       if (present (data)) then
          if (eio%check) then
             if (data%md5sum_prc /= "") then
                success = success .and. md5sum_prc == data%md5sum_prc
             end if
             if (data%md5sum_cfg /= "") then
                success = success .and. md5sum_cfg == data%md5sum_cfg
             end if
             do i = 1, eio%n_alt
                if (data%md5sum_alt(i) /= "") then
                   success = success .and. md5sum_alt(i) == data%md5sum_alt(i)
                end if
             end do
          else
             call msg_warning ("Reading event file: MD5 sum check disabled")
          end if
       end if
    end if
  end subroutine eio_raw_init_in
    
@ %def eio_raw_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: switch_inout => eio_raw_switch_inout
<<EIO raw: procedures>>=
  subroutine eio_raw_switch_inout (eio, success)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    write (msg_buffer, "(A,A,A)")  "Events: appending to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    close (eio%unit, status = "keep")
    eio%reading = .false.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", position = "append", status = "old")
    eio%writing = .true.
    if (present (success))  success = .true.
  end subroutine eio_raw_switch_inout
  
@ %def eio_raw_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.

We always write the particle set of the hard process.  (Note: this
should be reconsidered.)  We do make a physical copy.

On output, we write the [[prc]] values for weight and sqme, since
these are the values just computed.  On input, we store the values as
[[ref]] values.  The caller can then decide whether to recompute
values and thus obtain distinct [[prc]] values, or just accept them.

The [[passed]] flag is not written.  This allow us to apply different
selection criteria upon rereading.
<<EIO raw: eio raw: TBP>>=
  procedure :: output => eio_raw_output
<<EIO raw: procedures>>=
  subroutine eio_raw_output (eio, event, i_prc, reading, passed, pacify)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    logical, intent(in), optional :: reading, passed, pacify
    integer, intent(in) :: i_prc
    type(particle_set_t), pointer :: pset
    integer :: i
    if (eio%writing) then
       if (event%has_valid_particle_set ()) then
          select type (event)
          type is (event_t)
             write (eio%unit)  i_prc
             write (eio%unit)  event%get_i_mci ()
             write (eio%unit)  event%get_i_term ()
             write (eio%unit)  event%get_channel ()
             write (eio%unit)  event%expr%weight_prc
             write (eio%unit)  event%expr%excess_prc
             write (eio%unit)  event%expr%sqme_prc
             do i = 1, eio%n_alt
                write (eio%unit)  event%expr%weight_alt(i)
                write (eio%unit)  event%expr%sqme_alt(i)
             end do
             allocate (pset)
             call event%get_hard_particle_set (pset)
             call pset%write_raw (eio%unit)
             call pset%final ()
             deallocate (pset)
             select case (eio%file_version)
             case (2:)
                if (event%has_transform ()) then
                   write (eio%unit)  .true.
                   pset => event%get_particle_set_ptr ()
                   call pset%write_raw (eio%unit)
                else
                   write (eio%unit)  .false.
                end if
             end select
          class default
             call msg_bug ("Event: write raw: defined only for full event_t")
          end select
       else
          call msg_bug ("Event: write raw: particle set is undefined")
       end if
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for writing")
    end if
  end subroutine eio_raw_output

@ %def eio_raw_output
@ Input an event.

Note: the particle set is physically copied.  If there is a
performance issue, we might choose to pointer-assign it instead, with
a different version of [[event%set_hard_particle_set]].
<<EIO raw: eio raw: TBP>>=
  procedure :: input_i_prc => eio_raw_input_i_prc
  procedure :: input_event => eio_raw_input_event
<<EIO raw: procedures>>=
  subroutine eio_raw_input_i_prc (eio, i_prc, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)  i_prc
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_i_prc

  subroutine eio_raw_input_event (eio, event, iostat)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    integer :: i_mci, i_term, channel, i
    real(default) :: weight, excess, sqme
    real(default), dimension(:), allocatable :: weight_alt, sqme_alt
    logical :: has_transform
    type(particle_set_t), pointer :: pset
    class(model_data_t), pointer :: model
    if (eio%reading) then
       select type (event)
       type is (event_t)
          read (eio%unit, iostat = iostat)  i_mci
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  i_term
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  channel
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  weight
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  excess
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  sqme
          if (iostat /= 0)  return
          call event%reset ()
          call event%select (i_mci, i_term, channel)
          if (eio%norm_mode /= NORM_UNDEFINED) then
             call event_normalization_update (weight, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
             call event_normalization_update (excess, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
          end if
          call event%set (sqme_ref = sqme, weight_ref = weight, &
               excess_prc = excess)
          if (eio%n_alt /= 0) then
             allocate (sqme_alt (eio%n_alt), weight_alt (eio%n_alt))
             do i = 1, eio%n_alt
                read (eio%unit, iostat = iostat)  weight_alt(i)
                if (iostat /= 0)  return
                read (eio%unit, iostat = iostat)  sqme_alt(i)
                if (iostat /= 0)  return
             end do
             call event%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
          end if
          model => null ()
          if (associated (event%process)) then
             model => event%process%get_model_ptr ()
          end if
          allocate (pset)
          call pset%read_raw (eio%unit, iostat)
          if (iostat /= 0)  return
          if (associated (model))  call pset%set_model (model)
          call event%set_hard_particle_set (pset)
          call pset%final ()
          deallocate (pset)
          select case (eio%file_version)
          case (2:)
             read (eio%unit, iostat = iostat)  has_transform
             if (iostat /= 0)  return
             if (has_transform) then
                allocate (pset)
                call pset%read_raw (eio%unit, iostat)
                if (iostat /= 0)  return
                if (associated (model)) &
                     call pset%set_model (model)
                call event%link_particle_set (pset)
             end if
          end select
       class default
          call msg_bug ("Event: read raw: defined only for full event_t")
       end select
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_event

@ %def eio_raw_input_i_prc
@ %def eio_raw_input_event
@
<<EIO raw: eio raw: TBP>>=
  procedure :: skip => eio_raw_skip
<<EIO raw: procedures>>=
  subroutine eio_raw_skip (eio, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_skip

@ %def eio_raw_skip
@
\subsection{Unit tests}
<<EIO raw: public>>=
  public :: eio_raw_test
<<EIO raw: tests>>=
  subroutine eio_raw_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO raw: execute tests>>
  end subroutine eio_raw_test
  
@ %def eio_raw_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_1, "eio_raw_1", &
       "read and write event contents", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_1 (u)
    use processes
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call model%init_test ()

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_1"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")
    
    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 5)
    call eio%write (u)
    call eio%final ()
    
    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")
    
    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/1):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/1):", iostat
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/2):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/2):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_1"
    
  end subroutine eio_raw_1
  
@ %def eio_raw_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_2, "eio_raw_2", &
       "handle multiple weights", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_2 (u)
    use processes
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(var_list_t) :: var_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_2"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")  "*            with multiple weights"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()
 
    call data%init (n_proc = 1, n_alt = 2)

    call var_list_append_log (var_list, var_str ("?unweighted"), .false., &
         intrinsic = .true.)
    call var_list_append_string (var_list, var_str ("$sample_normalization"), &
         var_str ("auto"), intrinsic = .true.)
    call var_list_append_real (var_list, var_str ("safety_factor"), &
         1._default, intrinsic = .true.)

    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_2"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = &
         [2 * event%get_weight_ref (), 3 * event%get_weight_ref ()])
    call event%store_alt_values ()
    call event%check ()

    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample, data)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_2"
    
  end subroutine eio_raw_2
  
@ %def eio_raw_2
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
