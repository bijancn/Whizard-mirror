%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: beams and beam structure
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Beams}

These modules implement beam configuration and beam structure, the
latter in abstract terms.
\begin{description}
\item[beam\_structures]
  The [[beam_structure_t]] type is a messenger type that communicates
  the user settings to the \whizard\ core.
\item[beams]
  Beam configuration.
\item[sf\_aux]
  Tools for handling structure functions and splitting
\item[sf\_mappings]
  Mapping functions, useful for structure function implementation
\item[sf\_base]
  The abstract structure-function interaction and structure-function
  chain types.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Beam structure}

This module stores the beam structure definition as it is declared in
the SINDARIN script.  The structure definition is not analyzed, just
recorded for later use.

We do not capture any numerical parameters, just names of particles and
structure functions.
<<[[beam_structures.f90]]>>=
<<File header>>

module beam_structures
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use lorentz
  use polarizations

<<Standard module head>>

<<Beam structures: public>>

<<Beam structures: types>>

<<Beam structures: interfaces>>

contains
  
<<Beam structures: procedures>>

<<Beam structures: tests>>

end module beam_structures
@ %def beam_structures
@
\subsection{Beam structure elements}
An entry in a beam-structure record consists of a string
that denotes a type of structure function.
<<Beam structures: types>>=
  type :: beam_structure_entry_t
     logical :: is_valid = .false.
     type(string_t) :: name
   contains
   <<Beam structures: beam structure entry: TBP>>
  end type beam_structure_entry_t
  
@ %def beam_structure_entry_t
@ Output.
<<Beam structures: beam structure entry: TBP>>=
  procedure :: to_string => beam_structure_entry_to_string
<<Beam structures: procedures>>=
  function beam_structure_entry_to_string (object) result (string)
    class(beam_structure_entry_t), intent(in) :: object
    type(string_t) :: string
    if (object%is_valid) then
       string = object%name
    else
       string = "none"
    end if
  end function beam_structure_entry_to_string

@ %def beam_structure_entry_to_string
@
A record in the beam-structure sequence denotes either a
structure-function entry, a pair of such entries, or a pair spectrum.
<<Beam structures: types>>=
  type :: beam_structure_record_t
     type(beam_structure_entry_t), dimension(:), allocatable :: entry
  end type beam_structure_record_t

@ %def beam_structure_record_t
@
\subsection{Beam structure type}
The beam-structure object contains the beam particle(s) as simple strings.
The sequence of records indicates the structure functions by name.  No
numerical parameters are stored.
<<Beam structures: public>>=
  public :: beam_structure_t
<<Beam structures: types>>=
  type :: beam_structure_t
     private
     integer :: n_beam = 0
     type(string_t), dimension(:), allocatable :: prt
     type(beam_structure_record_t), dimension(:), allocatable :: record
     type(smatrix_t), dimension(:), allocatable :: smatrix
     real(default), dimension(:), allocatable :: pol_f
     real(default), dimension(:), allocatable :: p
     real(default), dimension(:), allocatable :: theta
     real(default), dimension(:), allocatable :: phi
   contains
   <<Beam structures: beam structure: TBP>>
  end type beam_structure_t
  
@ %def beam_structure_t
@ The finalizer deletes all contents explicitly, so we can continue
with an empty beam record.  (It is not needed for deallocation.)  We
have distinct finalizers for the independent parts of the beam structure.
<<Beam structures: beam structure: TBP>>=
  procedure :: final_sf => beam_structure_final_sf
<<Beam structures: procedures>>=
  subroutine beam_structure_final_sf (object)
    class(beam_structure_t), intent(inout) :: object
    if (allocated (object%prt))  deallocate (object%prt)
    if (allocated (object%record))  deallocate (object%record)
    object%n_beam = 0
  end subroutine beam_structure_final_sf
  
@ %def beam_structure_final_sf
@ Output.  The actual information fits in a single line, therefore we can
provide a [[to_string]] method.  The [[show]] method also lists the
current values of relevant global variables.
<<Beam structures: beam structure: TBP>>=
  procedure :: write => beam_structure_write
  procedure :: to_string => beam_structure_to_string
<<Beam structures: procedures>>=
  subroutine beam_structure_write (object, unit)
    class(beam_structure_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A,A)")  "Beam structure: ", char (object%to_string ())
    if (allocated (object%smatrix)) then
       do i = 1, size (object%smatrix)
          write (u, "(3x,A,I0,A)") "polarization (beam ", i, "):"
          call object%smatrix(i)%write (u, indent=2)
       end do
    end if
    if (allocated (object%pol_f)) then
       write (u, "(3x,A,F10.7,:,',',F10.7)")  "polarization degree =", &
            object%pol_f
    end if
    if (allocated (object%p)) then
       write (u, "(3x,A," // FMT_19 // ",:,','," // FMT_19 // &
            ")")  "momentum =", object%p
    end if
    if (allocated (object%theta)) then
       write (u, "(3x,A," // FMT_19 // ",:,','," // FMT_19 // &
            ")")  "angle th =", object%theta
    end if
    if (allocated (object%phi)) then
       write (u, "(3x,A," // FMT_19 // ",:,','," // FMT_19 // &
            ")")  "angle ph =", object%phi
    end if
  end subroutine beam_structure_write
  
  function beam_structure_to_string (object, sf_only) result (string)
    class(beam_structure_t), intent(in) :: object
    logical, intent(in), optional :: sf_only
    type(string_t) :: string
    integer :: i, j
    logical :: with_beams
    with_beams = .true.;  if (present (sf_only))  with_beams = .not. sf_only
    select case (object%n_beam)
    case (1)
       if (with_beams) then
          string = object%prt(1)
       else
          string = ""
       end if
    case (2)
       if (with_beams) then
          string = object%prt(1) // ", " // object%prt(2)
       else
          string = ""
       end if
       if (allocated (object%record)) then
          if (size (object%record) > 0) then
             if (with_beams)  string = string // " => "
             do i = 1, size (object%record)
                if (i > 1)  string = string // " => "
                do j = 1, size (object%record(i)%entry)
                   if (j > 1)  string = string // ", "
                   string = string // object%record(i)%entry(j)%to_string ()
                end do
             end do
          end if
       end if
    case default
       string = "[any particles]"
    end select
  end function beam_structure_to_string
    
@ %def beam_structure_write beam_structure_to_string
@ Initializer: dimension the beam structure record.  Each array
element denotes the number of entries for a record within the
beam-structure sequence.  The number of entries is either one or two,
while the number of records is unlimited.
<<Beam structures: beam structure: TBP>>=
  procedure :: init_sf => beam_structure_init_sf
<<Beam structures: procedures>>=
  subroutine beam_structure_init_sf (beam_structure, prt, dim_array)
    class(beam_structure_t), intent(inout) :: beam_structure
    type(string_t), dimension(:), intent(in) :: prt
    integer, dimension(:), intent(in), optional :: dim_array
    integer :: i
    call beam_structure%final_sf ()
    beam_structure%n_beam = size (prt)
    allocate (beam_structure%prt (size (prt)))
    beam_structure%prt = prt
    if (present (dim_array)) then
       allocate (beam_structure%record (size (dim_array)))
       do i = 1, size (dim_array)
          allocate (beam_structure%record(i)%entry (dim_array(i)))
       end do
    else
       allocate (beam_structure%record (0))
    end if
  end subroutine beam_structure_init_sf
    
@ %def beam_structure_init_sf
@ Set an entry, specified by record number and entry number.
<<Beam structures: beam structure: TBP>>=
  procedure :: set_sf => beam_structure_set_sf
<<Beam structures: procedures>>=
  subroutine beam_structure_set_sf (beam_structure, i, j, name)
    class(beam_structure_t), intent(inout) :: beam_structure
    integer, intent(in) :: i, j
    type(string_t), intent(in) :: name
    associate (entry => beam_structure%record(i)%entry(j))
      entry%name = name
      entry%is_valid = .true.
    end associate
  end subroutine beam_structure_set_sf

@ %def beam_structure_set_sf
@ Expand the beam-structure object.  (i) For a pair spectrum, keep the
entry.  (ii) For a single-particle structure function written as a
single entry, replace this by a record with two entries.
(ii) For a record with two nontrivial entries, separate this into two
records with one trivial entry each.

To achieve this, we need a function that tells us whether an entry is
a spectrum or a structure function.  It returns 0 for a trivial entry,
1 for a single-particle structure function, and 2 for a two-particle
spectrum.
<<Beam structures: interfaces>>=
  abstract interface
     function strfun_mode_fun (name) result (n)
       import
       type(string_t), intent(in) :: name
       integer :: n
     end function strfun_mode_fun
  end interface
  
@ %def is_spectrum_t
@ Algorithm: (1) Mark entries as invalid where necessary.  (2) Count
the number of entries that we will need.  (3) Expand and copy
entries to a new record array.  (4) Replace the old array by the new one.
<<Beam structures: beam structure: TBP>>=
  procedure :: expand => beam_structure_expand
<<Beam structures: procedures>>=
  subroutine beam_structure_expand (beam_structure, strfun_mode)
    class(beam_structure_t), intent(inout) :: beam_structure
    procedure(strfun_mode_fun) :: strfun_mode
    type(beam_structure_record_t), dimension(:), allocatable :: new
    integer :: n_record, i, j
    if (.not. allocated (beam_structure%record))  return
    do i = 1, size (beam_structure%record)
       associate (entry => beam_structure%record(i)%entry)
         do j = 1, size (entry)
            select case (strfun_mode (entry(j)%name))
            case (0);  entry(j)%is_valid = .false.
            end select
         end do
       end associate
    end do
    n_record = 0
    do i = 1, size (beam_structure%record)
       associate (entry => beam_structure%record(i)%entry)
         select case (size (entry))
         case (1)
            if (entry(1)%is_valid) then
               select case (strfun_mode (entry(1)%name))
               case (1);  n_record = n_record + 2
               case (2);  n_record = n_record + 1
               end select
            end if
         case (2)
            do j = 1, 2
               if (entry(j)%is_valid) then
                  select case (strfun_mode (entry(j)%name))
                  case (1);  n_record = n_record + 1
                  case (2)
                     call beam_structure%write ()
                     call msg_fatal ("Pair spectrum used as &
                          &single-particle structure function")
                  end select
               end if
            end do
         end select
       end associate
    end do
    allocate (new (n_record))
    n_record = 0
    do i = 1, size (beam_structure%record)
       associate (entry => beam_structure%record(i)%entry)
         select case (size (entry))
         case (1)
            if (entry(1)%is_valid) then
               select case (strfun_mode (entry(1)%name))
               case (1)
                  n_record = n_record + 1
                  allocate (new(n_record)%entry (2))
                  new(n_record)%entry(1) = entry(1)
                  n_record = n_record + 1
                  allocate (new(n_record)%entry (2))
                  new(n_record)%entry(2) = entry(1)
               case (2)
                  n_record = n_record + 1
                  allocate (new(n_record)%entry (1))
                  new(n_record)%entry(1) = entry(1)
               end select
            end if
         case (2)
            do j = 1, 2
               if (entry(j)%is_valid) then
                  n_record = n_record + 1
                  allocate (new(n_record)%entry (2))
                  new(n_record)%entry(j) = entry(j)
               end if
            end do
         end select
       end associate
    end do
    call move_alloc (from = new, to = beam_structure%record)
  end subroutine beam_structure_expand
    
@ %def beam_structure_expand
@
\subsection{Polarization}
To record polarization, we provide an allocatable array of [[smatrix]]
objects, sparse matrices.  The polarization structure is independent of the
structure-function setup, they are combined only when an actual beam object is
constructed.
<<Beam structures: beam structure: TBP>>=
  procedure :: final_pol => beam_structure_final_pol
  procedure :: init_pol => beam_structure_init_pol
<<Beam structures: procedures>>=
  subroutine beam_structure_final_pol (beam_structure)
    class(beam_structure_t), intent(inout) :: beam_structure
    if (allocated (beam_structure%smatrix))  deallocate (beam_structure%smatrix)
    if (allocated (beam_structure%pol_f))  deallocate (beam_structure%pol_f)
  end subroutine beam_structure_final_pol
    
  subroutine beam_structure_init_pol (beam_structure, n)
    class(beam_structure_t), intent(inout) :: beam_structure
    integer, intent(in) :: n
    if (allocated (beam_structure%smatrix))  deallocate (beam_structure%smatrix)
    allocate (beam_structure%smatrix (n))
    if (.not. allocated (beam_structure%pol_f)) &
         allocate (beam_structure%pol_f (n), source = 1._default)
  end subroutine beam_structure_init_pol
    
@ %def beam_structure_final_pol
@ %def beam_structure_init_pol
@ Directly copy the spin density matrices.
<<Beam structures: beam structure: TBP>>=
  procedure :: set_smatrix => beam_structure_set_smatrix
<<Beam structures: procedures>>=
  subroutine beam_structure_set_smatrix (beam_structure, i, smatrix)
    class(beam_structure_t), intent(inout) :: beam_structure
    integer, intent(in) :: i
    type(smatrix_t), intent(in) :: smatrix
    beam_structure%smatrix(i) = smatrix
  end subroutine beam_structure_set_smatrix
  
@ %def beam_structure_set_smatrix
@ Initialize one of the spin density matrices manually.
<<Beam structures: beam structure: TBP>>=
  procedure :: init_smatrix => beam_structure_init_smatrix
<<Beam structures: procedures>>=
  subroutine beam_structure_init_smatrix (beam_structure, i, n_entry)
    class(beam_structure_t), intent(inout) :: beam_structure
    integer, intent(in) :: i
    integer, intent(in) :: n_entry
    call beam_structure%smatrix(i)%init (2, n_entry)
  end subroutine beam_structure_init_smatrix
  
@ %def beam_structure_init_smatrix
@ Set a polarization entry.
<<Beam structures: beam structure: TBP>>=
  procedure :: set_sentry => beam_structure_set_sentry
<<Beam structures: procedures>>=
  subroutine beam_structure_set_sentry &
       (beam_structure, i, i_entry, index, value)
    class(beam_structure_t), intent(inout) :: beam_structure
    integer, intent(in) :: i
    integer, intent(in) :: i_entry
    integer, dimension(:), intent(in) :: index
    complex(default), intent(in) :: value
    call beam_structure%smatrix(i)%set_entry (i_entry, index, value)
  end subroutine beam_structure_set_sentry
  
@ %def beam_structure_set_sentry
@ Set the array of polarization fractions.
<<Beam structures: beam structure: TBP>>=
  procedure :: set_pol_f => beam_structure_set_pol_f
<<Beam structures: procedures>>=
  subroutine beam_structure_set_pol_f (beam_structure, f)
    class(beam_structure_t), intent(inout) :: beam_structure
    real(default), dimension(:), intent(in) :: f
    if (allocated (beam_structure%pol_f))  deallocate (beam_structure%pol_f)
    allocate (beam_structure%pol_f (size (f)), source = f)
  end subroutine beam_structure_set_pol_f
    
@ %def beam_structure_set_pol_f
@
\subsection{Beam momenta}
By default, beam momenta are deduced from the [[sqrts]] value or from
the mass of the decaying particle, assuming a c.m.\ setup.  Here we
set them explicitly.
<<Beam structures: beam structure: TBP>>=
  procedure :: final_mom => beam_structure_final_mom
<<Beam structures: procedures>>=
  subroutine beam_structure_final_mom (beam_structure)
    class(beam_structure_t), intent(inout) :: beam_structure
    if (allocated (beam_structure%p))  deallocate (beam_structure%p)
    if (allocated (beam_structure%theta))  deallocate (beam_structure%theta)
    if (allocated (beam_structure%phi))  deallocate (beam_structure%phi)
  end subroutine beam_structure_final_mom

@ %def beam_structure_final_mom
<<Beam structures: beam structure: TBP>>=
  procedure :: set_momentum => beam_structure_set_momentum
  procedure :: set_theta => beam_structure_set_theta
  procedure :: set_phi => beam_structure_set_phi
<<Beam structures: procedures>>=
  subroutine beam_structure_set_momentum (beam_structure, p)
    class(beam_structure_t), intent(inout) :: beam_structure
    real(default), dimension(:), intent(in) :: p
    if (allocated (beam_structure%p))  deallocate (beam_structure%p)
    allocate (beam_structure%p (size (p)), source = p)
  end subroutine beam_structure_set_momentum
    
  subroutine beam_structure_set_theta (beam_structure, theta)
    class(beam_structure_t), intent(inout) :: beam_structure
    real(default), dimension(:), intent(in) :: theta
    if (allocated (beam_structure%theta))  deallocate (beam_structure%theta)
    allocate (beam_structure%theta (size (theta)), source = theta)
  end subroutine beam_structure_set_theta
    
  subroutine beam_structure_set_phi (beam_structure, phi)
    class(beam_structure_t), intent(inout) :: beam_structure
    real(default), dimension(:), intent(in) :: phi
    if (allocated (beam_structure%phi))  deallocate (beam_structure%phi)
    allocate (beam_structure%phi (size (phi)), source = phi)
  end subroutine beam_structure_set_phi
    
@ %def beam_structure_set_momentum
@ %def beam_structure_set_theta
@ %def beam_structure_set_phi
@
\subsection{Get contents}
Look at the incoming particles.  We may also have the case that beam
particles are not specified, but polarization.
<<Beam structures: beam structure: TBP>>=
  procedure :: is_set => beam_structure_is_set
  procedure :: get_n_beam => beam_structure_get_n_beam
  procedure :: get_prt => beam_structure_get_prt
<<Beam structures: procedures>>=
  function beam_structure_is_set (beam_structure) result (flag)
    class(beam_structure_t), intent(in) :: beam_structure
    logical :: flag
    flag = beam_structure%n_beam > 0 .or. beam_structure%asymmetric ()
  end function beam_structure_is_set

  function beam_structure_get_n_beam (beam_structure) result (n)
    class(beam_structure_t), intent(in) :: beam_structure
    integer :: n
    n = beam_structure%n_beam
  end function beam_structure_get_n_beam

  function beam_structure_get_prt (beam_structure) result (prt)
    class(beam_structure_t), intent(in) :: beam_structure
    type(string_t), dimension(:), allocatable :: prt
    allocate (prt (size (beam_structure%prt)))
    prt = beam_structure%prt
  end function beam_structure_get_prt

@ %def beam_structure_is_set
@ %def beam_structure_get_n_beam
@ %def beam_structure_get_prt
@ 
Return the number of records.
<<Beam structures: beam structure: TBP>>=
  procedure :: get_n_record => beam_structure_get_n_record
<<Beam structures: procedures>>=
  function beam_structure_get_n_record (beam_structure) result (n)
    class(beam_structure_t), intent(in) :: beam_structure
    integer :: n
    if (allocated (beam_structure%record)) then
       n = size (beam_structure%record)
    else
       n = 0
    end if
  end function beam_structure_get_n_record
  
@ %def beam_structure_get_n_record
@ Return an array consisting of the beam indices affected by the valid
entries within a record.  After expansion, there should be exactly one
valid entry per record.
<<Beam structures: beam structure: TBP>>=
  procedure :: get_i_entry => beam_structure_get_i_entry
<<Beam structures: procedures>>=
  function beam_structure_get_i_entry (beam_structure, i) result (i_entry)
    class(beam_structure_t), intent(in) :: beam_structure
    integer, intent(in) :: i
    integer, dimension(:), allocatable :: i_entry
    associate (record => beam_structure%record(i))
      select case (size (record%entry))
      case (1)
         if (record%entry(1)%is_valid) then
            allocate (i_entry (2), source = [1, 2])
         else
            allocate (i_entry (0))
         end if
      case (2)
         if (all (record%entry%is_valid)) then
            allocate (i_entry (2), source = [1, 2])
         else if (record%entry(1)%is_valid) then
            allocate (i_entry (1), source = [1])
         else if (record%entry(2)%is_valid) then
            allocate (i_entry (1), source = [2])
         else
            allocate (i_entry (0))
         end if
      end select
    end associate
  end function beam_structure_get_i_entry
  
@ %def beam_structure_get_i_entry
@ Return the name of the first valid entry within a record.  After
expansion, there should be exactly one valid entry per record.
<<Beam structures: beam structure: TBP>>=
  procedure :: get_name => beam_structure_get_name
<<Beam structures: procedures>>=
  function beam_structure_get_name (beam_structure, i) result (name)
    class(beam_structure_t), intent(in) :: beam_structure
    integer, intent(in) :: i
    type(string_t) :: name
    associate (record => beam_structure%record(i))
      if (record%entry(1)%is_valid) then
         name = record%entry(1)%name
      else if (size (record%entry) == 2) then
         name = record%entry(2)%name
      end if
    end associate
  end function beam_structure_get_name
  
@ %def beam_structure_get_name
@ Return true if the beam structure contains a particular structure
function identifier (such as [[lhapdf]], [[isr]], etc.)
<<Beam structures: beam structure: TBP>>=
  procedure :: contains => beam_structure_contains
<<Beam structures: procedures>>=
  function beam_structure_contains (beam_structure, name) result (flag)
    class(beam_structure_t), intent(in) :: beam_structure
    character(*), intent(in) :: name
    logical :: flag
    integer :: i, j
    flag = .false.
    if (allocated (beam_structure%record)) then
       do i = 1, size (beam_structure%record)
          do j = 1, size (beam_structure%record(i)%entry)
             flag = beam_structure%record(i)%entry(j)%name == name
             if (flag)  return
          end do
       end do
    end if
  end function beam_structure_contains

@ %def beam_structure_contains
@ Return polarization data.
<<Beam structures: beam structure: TBP>>=
  procedure :: polarized => beam_structure_polarized
  procedure :: get_smatrix => beam_structure_get_smatrix
  procedure :: get_pol_f => beam_structure_get_pol_f
  procedure :: asymmetric => beam_structure_asymmetric
<<Beam structures: procedures>>=
  function beam_structure_polarized (beam_structure) result (flag)
    class(beam_structure_t), intent(in) :: beam_structure
    logical :: flag
    flag = allocated (beam_structure%smatrix)
  end function beam_structure_polarized
  
  function beam_structure_get_smatrix (beam_structure) result (smatrix)
    class(beam_structure_t), intent(in) :: beam_structure
    type(smatrix_t), dimension(:), allocatable :: smatrix
    allocate (smatrix (size (beam_structure%smatrix)), &
         source = beam_structure%smatrix)
  end function beam_structure_get_smatrix
  
  function beam_structure_get_pol_f (beam_structure) result (pol_f)
    class(beam_structure_t), intent(in) :: beam_structure
    real(default), dimension(:), allocatable :: pol_f
    allocate (pol_f (size (beam_structure%pol_f)), &
         source = beam_structure%pol_f)
  end function beam_structure_get_pol_f
  
  function beam_structure_asymmetric (beam_structure) result (flag)
    class(beam_structure_t), intent(in) :: beam_structure
    logical :: flag
    flag = allocated (beam_structure%p) &
         .or. allocated (beam_structure%theta) &
         .or. allocated (beam_structure%phi)
  end function beam_structure_asymmetric
  
@ %def beam_structure_polarized
@ %def beam_structure_get_smatrix
@ %def beam_structure_get_pol_f
@ %def beam_structure_asymmetric
@ Return the beam momenta (the space part, i.e., three-momenta).  This
is meaningful only if momenta and, optionally, angles have been set.
<<Beam structures: beam structure: TBP>>=
  procedure :: get_momenta => beam_structure_get_momenta
<<Beam structures: procedures>>=
  function beam_structure_get_momenta (beam_structure) result (p)
    class(beam_structure_t), intent(in) :: beam_structure
    type(vector3_t), dimension(:), allocatable :: p
    real(default), dimension(:), allocatable :: theta, phi
    integer :: n, i
    if (allocated (beam_structure%p)) then
       n = size (beam_structure%p)
       if (allocated (beam_structure%theta)) then
          if (size (beam_structure%theta) == n) then
             allocate (theta (n), source = beam_structure%theta)
          else
             call msg_fatal ("Beam structure: mismatch in momentum vs. &
                  &angle theta specification")
          end if
       else
          allocate (theta (n), source = 0._default)
       end if
       if (allocated (beam_structure%phi)) then
          if (size (beam_structure%phi) == n) then
             allocate (phi (n), source = beam_structure%phi)
          else
             call msg_fatal ("Beam structure: mismatch in momentum vs. &
                  &angle phi specification")
          end if
       else
          allocate (phi (n), source = 0._default)
       end if
       allocate (p (n))
       do i = 1, n
          p(i) = beam_structure%p(i) * vector3_moving ([ &
               sin (theta(i)) * cos (phi(i)), &
               sin (theta(i)) * sin (phi(i)), &
               cos (theta(i))])
       end do
       if (n == 2)  p(2) = - p(2)
    else
       call msg_fatal ("Beam structure: angle theta/phi specified but &
            &momentum/a p undefined")
    end if
  end function beam_structure_get_momenta
    
@ %def beam_structure_get_momenta
@ 
\subsection{Unit Tests}
<<Beam structures: public>>=
  public :: beam_structures_test
<<Beam structures: tests>>=
  subroutine beam_structures_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Beam structures: execute tests>>
end subroutine beam_structures_test
  
@ %def beam_structures_tests
@ 
\subsubsection{Empty structure}
<<Beam structures: execute tests>>=
  call test (beam_structures_1, "beam_structures_1", &
       "empty beam structure record", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_1 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    
    write (u, "(A)")  "* Test output: beam_structures_1"
    write (u, "(A)")  "*   Purpose: display empty beam structure record"
    write (u, "(A)")

    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_1"
    
  end subroutine beam_structures_1
  
@ %def beam_structures_1
@ 
\subsubsection{Nontrivial configurations}
<<Beam structures: execute tests>>=
  call test (beam_structures_2, "beam_structures_2", &
       "beam structure records", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_2 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    integer, dimension(0) :: empty_array
    type(string_t) :: s
    
    write (u, "(A)")  "* Test output: beam_structures_2"
    write (u, "(A)")  "*   Purpose: setup beam structure records"
    write (u, "(A)")

    s = "s"

    call beam_structure%init_sf ([s], empty_array)
    call beam_structure%write (u)
    
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [1])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%write (u)
    
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [2])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%set_sf (1, 2, var_str ("b"))
    call beam_structure%write (u)
    
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [2, 1])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%set_sf (1, 2, var_str ("b"))
    call beam_structure%set_sf (2, 1, var_str ("c"))
    call beam_structure%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_2"
    
  end subroutine beam_structures_2
  
@ %def beam_structures_2
@ 
\subsubsection{Expansion}
Provide a function that tells, for the dummy structure function names
used here, whether they are considered a two-particle spectrum or a
single-particle structure function:
<<Beam structures: tests>>=
  function test_strfun_mode (name) result (n)
    type(string_t), intent(in) :: name
    integer :: n
    select case (char (name))
    case ("a");  n = 2
    case ("b");  n = 1
    case default;  n = 0
    end select
  end function test_strfun_mode

@ %def test_ist_pair_spectrum
@ 
<<Beam structures: execute tests>>=
  call test (beam_structures_3, "beam_structures_3", &
       "beam structure expansion", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_3 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    type(string_t) :: s
    
    write (u, "(A)")  "* Test output: beam_structures_3"
    write (u, "(A)")  "*   Purpose: expand beam structure records"
    write (u, "(A)")

    s = "s"

    write (u, "(A)")  "* Pair spectrum (keep as-is)"
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [1])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%write (u)

    write (u, "(A)")

    call beam_structure%expand (test_strfun_mode)
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure function pair (expand)"
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [2])
    call beam_structure%set_sf (1, 1, var_str ("b"))
    call beam_structure%set_sf (1, 2, var_str ("b"))
    call beam_structure%write (u)

    write (u, "(A)")

    call beam_structure%expand (test_strfun_mode)
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Structure function (separate and expand)"
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [1])
    call beam_structure%set_sf (1, 1, var_str ("b"))
    call beam_structure%write (u)

    write (u, "(A)")

    call beam_structure%expand (test_strfun_mode)
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Combination"
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [1, 1])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%set_sf (2, 1, var_str ("b"))
    call beam_structure%write (u)

    write (u, "(A)")

    call beam_structure%expand (test_strfun_mode)
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_3"
    
  end subroutine beam_structures_3
  
@ %def beam_structures_3
@
\subsubsection{Public methods}
Check the methods that can be called to get the beam-structure
contents.
<<Beam structures: execute tests>>=
  call test (beam_structures_4, "beam_structures_4", &
       "beam structure contents", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_4 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    type(string_t) :: s
    type(string_t), dimension(2) :: prt
    integer :: i
    
    write (u, "(A)")  "* Test output: beam_structures_4"
    write (u, "(A)")  "*   Purpose: check the API"
    write (u, "(A)")

    s = "s"

    write (u, "(A)")  "* Structure-function combination"
    write (u, "(A)")

    call beam_structure%init_sf ([s, s], [1, 2, 2])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%set_sf (2, 1, var_str ("b"))
    call beam_structure%set_sf (3, 2, var_str ("c"))
    call beam_structure%write (u)

    write (u, *)
    write (u, "(1x,A,I0)")  "n_beam = ", beam_structure%get_n_beam ()
    prt = beam_structure%get_prt ()
    write (u, "(1x,A,2(1x,A))")  "prt =", char (prt(1)), char (prt(2))
    
    write (u, *)
    write (u, "(1x,A,I0)")  "n_record = ", beam_structure%get_n_record ()

    do i = 1, 3
       write (u, "(A)")
       write (u, "(1x,A,I0,A,A)")  "name(", i, ") = ", &
            char (beam_structure%get_name (i))
       write (u, "(1x,A,I0,A,2(1x,I0))")  "i_entry(", i, ") =", &
            beam_structure%get_i_entry (i)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_4"
    
  end subroutine beam_structures_4
  
@ %def beam_structures_4
@
\subsubsection{Polarization}
The polarization properties are independent from the structure-function setup.
<<Beam structures: execute tests>>=
  call test (beam_structures_5, "beam_structures_5", &
       "polarization", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_5 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    integer, dimension(0) :: empty_array
    type(string_t) :: s
    
    write (u, "(A)")  "* Test output: beam_structures_5"
    write (u, "(A)")  "*   Purpose: setup polarization in beam structure records"
    write (u, "(A)")

    s = "s"

    call beam_structure%init_sf ([s], empty_array)
    call beam_structure%init_pol (1)
    call beam_structure%init_smatrix (1, 1)
    call beam_structure%set_sentry (1, 1, [0,0], (1._default, 0._default))
    call beam_structure%set_pol_f ([0.5_default])
    call beam_structure%write (u)
    
    
    write (u, "(A)")
    call beam_structure%final_sf ()
    call beam_structure%final_pol ()

    call beam_structure%init_sf ([s, s], [1])
    call beam_structure%set_sf (1, 1, var_str ("a"))
    call beam_structure%init_pol (2)
    call beam_structure%init_smatrix (1, 2)
    call beam_structure%set_sentry (1, 1, [-1,1], (0.5_default,-0.5_default))
    call beam_structure%set_sentry (1, 2, [ 1,1], (1._default, 0._default))
    call beam_structure%init_smatrix (2, 0)
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_5"
    
  end subroutine beam_structures_5
  
@ %def beam_structures_5
@
\subsubsection{Momenta}
The momenta are independent from the structure-function setup.
<<Beam structures: execute tests>>=
  call test (beam_structures_6, "beam_structures_6", &
       "momenta", &
       u, results)
<<Beam structures: tests>>=
  subroutine beam_structures_6 (u)
    integer, intent(in) :: u
    type(beam_structure_t) :: beam_structure
    integer, dimension(0) :: empty_array
    type(string_t) :: s
    
    write (u, "(A)")  "* Test output: beam_structures_6"
    write (u, "(A)")  "*   Purpose: setup momenta in beam structure records"
    write (u, "(A)")

    s = "s"

    call beam_structure%init_sf ([s], empty_array)
    call beam_structure%set_momentum ([500._default])
    call beam_structure%write (u)
    
    
    write (u, "(A)")
    call beam_structure%final_sf ()
    call beam_structure%final_mom ()

    call beam_structure%init_sf ([s, s], [1])
    call beam_structure%set_momentum ([500._default, 700._default])
    call beam_structure%set_theta ([0._default, 0.1_default])
    call beam_structure%set_phi ([0._default, 1.51_default])
    call beam_structure%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_structures_6"
    
  end subroutine beam_structures_6
  
@ %def beam_structures_6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Beams for collisions and decays}

<<[[beams.f90]]>>=
<<File header>>

module beams

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use md5
  use lorentz
  use model_data
  use flavors
  use colors
  use quantum_numbers
  use state_matrices
  use interactions
  use polarizations
  use beam_structures

<<Standard module head>>

<<Beams: public>>

<<Beams: types>>

<<Beams: interfaces>>

contains

<<Beams: procedures>>

<<Beams: tests>>

end module beams
@ %def beams
@
\subsection{Beam data}
The beam data type contains beam data for one or two beams, depending
on whether we are dealing with beam collisions or particle decay.  In
addition, it holds the c.m.\ energy [[sqrts]], the Lorentz
transformation [[L]] that transforms the c.m.\ system into the lab
system, and the pair of c.m.\ momenta.
<<Beams: public>>=
  public :: beam_data_t
<<Beams: types>>=
  type :: beam_data_t
     logical :: initialized = .false.
     integer :: n = 0
     type(flavor_t), dimension(:), allocatable :: flv
     real(default), dimension(:), allocatable :: mass
     type(pmatrix_t), dimension(:), allocatable :: pmatrix
     logical :: lab_is_cm_frame = .true.
     type(vector4_t), dimension(:), allocatable :: p_cm
     type(vector4_t), dimension(:), allocatable :: p
     type(lorentz_transformation_t), allocatable  :: L_cm_to_lab
     real(default) :: sqrts = 0
     character(32) :: md5sum = ""
   contains
   <<Beams: beam data: TBP>>
  end type beam_data_t

@ %def beam_data_t
@ Generic initializer.  This is called by the specific initializers
below.  Initialize either for decay or for collision.
<<Beams: procedures>>=
  subroutine beam_data_init (beam_data, n)
    type(beam_data_t), intent(out) :: beam_data
    integer, intent(in) :: n
    beam_data%n = n
    allocate (beam_data%flv (n))
    allocate (beam_data%mass (n))
    allocate (beam_data%pmatrix (n))
    allocate (beam_data%p_cm (n))
    allocate (beam_data%p (n))
    beam_data%initialized = .true.
  end subroutine beam_data_init

@ %def beam_data_init
@ Finalizer: needed for the polarization components of the beams.
<<Beams: public>>=
  public :: beam_data_final
<<Beams: procedures>>=
  subroutine beam_data_final (beam_data)
    type(beam_data_t), intent(inout) :: beam_data
    beam_data%initialized = .false.
  end subroutine beam_data_final

@ %def beam_data_final
@ The verbose (default) version is for debugging.  The short version
is for screen output in the UI.
<<Beams: public>>=
  public :: beam_data_write
<<Beams: beam data: TBP>>=
  procedure :: write => beam_data_write
<<Beams: procedures>>=
  subroutine beam_data_write (beam_data, unit, verbose, write_md5sum)
    class(beam_data_t), intent(in) :: beam_data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, write_md5sum
    integer :: prt_name_len
    logical :: verb, write_md5
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    verb = .false.;  if (present (verbose))  verb = verbose
    write_md5 = verb;  if (present (write_md5sum)) write_md5 = write_md5sum
    if (.not. beam_data%initialized) then
       write (u, "(1x,A)") "Beam data: [undefined]"
       return
    end if
    prt_name_len = maxval (len (flavor_get_name (beam_data%flv)))
    select case (beam_data%n)
    case (1)
       write (u, "(1x,A)") "Beam data (decay):"
       if (verb) then
          call write_prt (1)
          call beam_data%pmatrix(1)%write (u)          
          write (u, *) "R.f. momentum:"
          call vector4_write (beam_data%p_cm(1), u)
          write (u, *) "Lab momentum:"
          call vector4_write (beam_data%p(1), u)
       else
          call write_prt (1)
       end if
    case (2)
       write (u, "(1x,A)") "Beam data (collision):"
       if (verb) then
          call write_prt (1)
          call beam_data%pmatrix(1)%write (u)          
          call write_prt (2)
          call beam_data%pmatrix(2)%write (u)
          call write_sqrts
          write (u, *) "C.m. momenta:"
          call vector4_write (beam_data%p_cm(1), u)
          call vector4_write (beam_data%p_cm(2), u)
          write (u, *) "Lab momenta:"
          call vector4_write (beam_data%p(1), u)
          call vector4_write (beam_data%p(2), u)
       else
          call write_prt (1)
          call write_prt (2)
          call write_sqrts
       end if
    end select
    if (allocated (beam_data%L_cm_to_lab)) then
       if (verb) then
          call lorentz_transformation_write (beam_data%L_cm_to_lab, u)
       else
          write (u, "(1x,A)")  "Beam structure: lab and c.m. frame differ"
       end if
    end if
    if (write_md5) then
       write (u, *) "MD5 sum: ", beam_data%md5sum
    end if
  contains
    subroutine write_sqrts
      character(80) :: sqrts_str
      write (sqrts_str, "(" // FMT_19 // ")")  beam_data%sqrts
      write (u, "(3x,A)")  "sqrts = " // trim (adjustl (sqrts_str)) // " GeV"
    end subroutine write_sqrts
    subroutine write_prt (i)
      integer, intent(in) :: i
      character(80) :: name_str, mass_str
      write (name_str, "(A)")  char (flavor_get_name (beam_data%flv(i)))
      write (mass_str, "(ES13.7)")  beam_data%mass(i)
      write (u, "(3x,A)", advance="no") &
           name_str(:prt_name_len) // "  (mass = " &
           // trim (adjustl (mass_str)) // " GeV)"
      if (beam_data%pmatrix(i)%is_polarized ()) then
         write (u, "(2x,A)")  "polarized"
      else
         write (u, *)
      end if
    end subroutine write_prt
  end subroutine beam_data_write

@ %def beam_data_write
@ Return initialization status:
<<Beams: public>>=
  public :: beam_data_are_valid
<<Beams: procedures>>=
  function beam_data_are_valid (beam_data) result (flag)
    logical :: flag
    type(beam_data_t), intent(in) :: beam_data
    flag = beam_data%initialized
  end function beam_data_are_valid

@ %def beam_data_are_valid
@ Check whether beam data agree with the current values of relevant
parameters.
<<Beams: public>>=
  public :: beam_data_check_scattering
<<Beams: procedures>>=
  subroutine beam_data_check_scattering (beam_data, sqrts)
    type(beam_data_t), intent(in) :: beam_data
    real(default), intent(in), optional :: sqrts
    if (beam_data_are_valid (beam_data)) then
       if (present (sqrts)) then
          if (sqrts /= beam_data%sqrts) then
             call msg_error ("Current setting of sqrts is inconsistent " &
                  // "with beam setup (ignored).")
          end if
       end if
    else
       call msg_bug ("Beam setup: invalid beam data")
    end if
  end subroutine beam_data_check_scattering

@ %def beam_data_check_scattering
@ Return the number of beams (1 for decays, 2 for collisions).
<<Beams: public>>=
  public :: beam_data_get_n_in
<<Beams: procedures>>=
  function beam_data_get_n_in (beam_data) result (n_in)
    integer :: n_in
    type(beam_data_t), intent(in) :: beam_data
    n_in = beam_data%n
  end function beam_data_get_n_in

@ %def beam_data_get_n_in
@ Return the beam flavor
<<Beams: public>>=
  public :: beam_data_get_flavor
<<Beams: procedures>>=
  function beam_data_get_flavor (beam_data) result (flv)
    type(flavor_t), dimension(:), allocatable :: flv
    type(beam_data_t), intent(in) :: beam_data
    allocate (flv (beam_data%n))
    flv = beam_data%flv
  end function beam_data_get_flavor

@ %def beam_data_get_flavor
@ Return the beam energies
<<Beams: public>>=
  public :: beam_data_get_energy
<<Beams: procedures>>=
  function beam_data_get_energy (beam_data) result (e)
    real(default), dimension(:), allocatable :: e
    type(beam_data_t), intent(in) :: beam_data
    allocate (e (beam_data%n))
    if (beam_data%initialized) then
       e = energy (beam_data%p)
    else
       e = 0
    end if
  end function beam_data_get_energy

@ %def beam_data_get_energy
@ Return the c.m.\ energy.
<<Beams: public>>=
  public :: beam_data_get_sqrts
<<Beams: procedures>>=
  function beam_data_get_sqrts (beam_data) result (sqrts)
    real(default) :: sqrts
    type(beam_data_t), intent(in) :: beam_data
    sqrts = beam_data%sqrts
  end function beam_data_get_sqrts
  
@ %def beam_data_get_sqrts
@ Return true if the lab and c.m.\ frame are specified as identical.
<<Beams: public>>=
  public :: beam_data_cm_frame
<<Beams: procedures>>=
  function beam_data_cm_frame (beam_data) result (flag)
    type(beam_data_t), intent(in) :: beam_data
    logical :: flag
    flag = beam_data%lab_is_cm_frame
  end function beam_data_cm_frame
  
@ %def beam_data_cm_frame
@ Return a MD5 checksum for beam data.  If no checksum is present
(because beams have not been initialized), compute the checksum of the
sqrts value.
<<Beams: public>>=
  public :: beam_data_get_md5sum
<<Beams: procedures>>=
  function beam_data_get_md5sum (beam_data, sqrts) result (md5sum_beams)
    type(beam_data_t), intent(in) :: beam_data
    real(default), intent(in) :: sqrts
    character(32) :: md5sum_beams
    character(80) :: buffer
    if (beam_data%md5sum /= "") then
       md5sum_beams = beam_data%md5sum
    else
       write (buffer, *)  sqrts
       md5sum_beams = md5sum (buffer)
    end if
  end function beam_data_get_md5sum

@ %def beam_data_get_md5sum
@
\subsection{Initializers: beam structure}
Initialize the beam data object from a beam structure object, given energy and
model.
<<Beams: public>>=
  public :: beam_data_init_structure
<<Beams: procedures>>=
  subroutine beam_data_init_structure &
       (beam_data, structure, sqrts, model, decay_rest_frame)
    type(beam_data_t), intent(out) :: beam_data
    type(beam_structure_t), intent(in) :: structure
    integer :: n_beam
    real(default), intent(in) :: sqrts
    class(model_data_t), intent(in), target :: model
    logical, intent(in), optional :: decay_rest_frame
    type(flavor_t), dimension(:), allocatable :: flv
    n_beam = structure%get_n_beam ()
    allocate (flv (n_beam))
    call flavor_init (flv, structure%get_prt (), model)
    if (structure%asymmetric ()) then
       if (structure%polarized ()) then
          call beam_data_init_momenta (beam_data, &
               structure%get_momenta (), flv, &
               structure%get_smatrix (), structure%get_pol_f ())
       else
          call beam_data_init_momenta (beam_data, &
               structure%get_momenta (), flv)
       end if
    else
       select case (n_beam)
       case (1)
          if (structure%polarized ()) then
             call beam_data_init_decay (beam_data, flv, &
                  structure%get_smatrix (), structure%get_pol_f (), &
                  rest_frame = decay_rest_frame)
          else
             call beam_data_init_decay (beam_data, flv, &
                  rest_frame = decay_rest_frame)
          end if
       case (2)
          if (structure%polarized ()) then
             call beam_data_init_sqrts (beam_data, sqrts, flv, &
                  structure%get_smatrix (), structure%get_pol_f ())
          else
             call beam_data_init_sqrts (beam_data, sqrts, flv)
          end if
       case default
          call msg_bug ("Beam data: invalid beam structure object")
       end select
    end if
  end subroutine beam_data_init_structure
    
@ %def beam_data_init_structure
@
\subsection{Initializers: collisions}
This is the simplest one: just the two flavors, c.m.\ energy,
polarization.  Color is inferred from flavor.  Beam momenta and c.m.\
momenta coincide.
<<Beams: public>>=
  public :: beam_data_init_sqrts
<<Beams: procedures>>=
  subroutine beam_data_init_sqrts (beam_data, sqrts, flv, smatrix, pol_f)
    type(beam_data_t), intent(out) :: beam_data
    real(default), intent(in) :: sqrts
    type(flavor_t), dimension(:), intent(in) :: flv
    type(smatrix_t), dimension(:), intent(in), optional :: smatrix
    real(default), dimension(:), intent(in), optional :: pol_f
    real(default), dimension(size(flv)) :: E, p
    call beam_data_init (beam_data, size (flv))
    beam_data%sqrts = sqrts
    beam_data%lab_is_cm_frame = .true.
    select case (beam_data%n)
    case (1)
       E = sqrts;  p = 0
       beam_data%p_cm = vector4_moving (E, p, 3)
       beam_data%p = beam_data%p_cm
    case (2)
       beam_data%p_cm = colliding_momenta (sqrts, flavor_get_mass (flv))
       beam_data%p = colliding_momenta (sqrts, flavor_get_mass (flv))
    end select
    call beam_data_finish_initialization (beam_data, flv, smatrix, pol_f)
  end subroutine beam_data_init_sqrts

@ %def beam_data_init_sqrts
@ This version sets beam momenta directly, assuming that they are
asymmetric, i.e., lab frame and c.m.\ frame do not coincide.
Polarization info is deferred to a common initializer.

The Lorentz transformation that we compute here is not actually used
in the calculation; instead, it will be recomputed for each event in
the subroutine [[phs_set_incoming_momenta]].  We compute it here for
the nominal beam setup nevertheless, so we can print it and, in
particular, include it in the MD5 sum.
<<Beams: public>>=
  public :: beam_data_init_momenta
<<Beams: procedures>>=
  subroutine beam_data_init_momenta (beam_data, p3, flv, smatrix, pol_f)
    type(beam_data_t), intent(out) :: beam_data
    type(vector3_t), dimension(:), intent(in) :: p3
    type(flavor_t), dimension(:), intent(in) :: flv
    type(smatrix_t), dimension(:), intent(in), optional :: smatrix
    real(default), dimension(:), intent(in), optional :: pol_f
    type(vector4_t) :: p0
    type(vector4_t), dimension(:), allocatable :: p, p_cm_rot
    real(default), dimension(size(p3)) :: e
    real(default), dimension(size(flv)) :: m
    type(lorentz_transformation_t) :: L_boost, L_rot
    call beam_data_init (beam_data, size (flv))
    m = flavor_get_mass (flv)
    e = sqrt (p3 ** 2 + m ** 2)
    allocate (p (beam_data%n))
    p = vector4_moving (e, p3)
    p0 = sum (p)
    beam_data%p = p
    beam_data%lab_is_cm_frame = .false.
    beam_data%sqrts = p0 ** 1
    L_boost = boost (p0, beam_data%sqrts)
    allocate (p_cm_rot (beam_data%n))
    p_cm_rot = inverse (L_boost) * p
    allocate (beam_data%L_cm_to_lab)
    select case (beam_data%n)
    case (1)
       beam_data%L_cm_to_lab = L_boost
       beam_data%p_cm = vector4_at_rest (beam_data%sqrts)
    case (2)
       L_rot = rotation_to_2nd (3, space_part (p_cm_rot(1)))
       beam_data%L_cm_to_lab = L_boost * L_rot
       beam_data%p_cm = &
            colliding_momenta (beam_data%sqrts, flavor_get_mass (flv))
    end select
    call beam_data_finish_initialization (beam_data, flv, smatrix, pol_f)
  end subroutine beam_data_init_momenta
    
@ %def beam_data_init_momenta
@ 
Final steps:
If requested, rotate the beams in the lab frame, and set
the beam-data components.
<<Beams: procedures>>=
  subroutine beam_data_finish_initialization (beam_data, flv, smatrix, pol_f)
    type(beam_data_t), intent(inout) :: beam_data
    type(flavor_t), dimension(:), intent(in) :: flv
    type(smatrix_t), dimension(:), intent(in), optional :: smatrix
    real(default), dimension(:), intent(in), optional :: pol_f
    integer :: i
    do i = 1, beam_data%n
       beam_data%flv(i) = flv(i)
       beam_data%mass(i) = flavor_get_mass (flv(i))
       if (present (smatrix)) then
          if (size (smatrix) /= beam_data%n) &
               call msg_fatal ("Beam data: &
               &polarization density array has wrong dimension")
          beam_data%pmatrix(i) = smatrix(i)
          if (present (pol_f)) then
             if (size (pol_f) /= size (smatrix)) &
                  call msg_fatal ("Beam data: &
                  &polarization fraction array has wrong dimension")
             call beam_data%pmatrix(i)%normalize (flv(i), pol_f(i))
          else
             call beam_data%pmatrix(i)%normalize (flv(i), 1._default)
          end if
       else
          call beam_data%pmatrix(i)%init (2, 0)
          call beam_data%pmatrix(i)%normalize (flv(i), 0._default)
       end if
    end do
    call beam_data_compute_md5sum (beam_data)
  end subroutine beam_data_finish_initialization

@ %def beam_data_finish_initialization
@
The MD5 sum is stored within the beam-data record, so it can be
checked for integrity in subsequent runs. 
<<Beams: procedures>>=
  subroutine beam_data_compute_md5sum (beam_data)
    type(beam_data_t), intent(inout) :: beam_data
    integer :: unit
    unit = free_unit ()
    open (unit = unit, status = "scratch", action = "readwrite")
    call beam_data_write (beam_data, unit, write_md5sum = .false., &
       verbose = .true.)
    rewind (unit)
    beam_data%md5sum = md5sum (unit)
    close (unit)
  end subroutine beam_data_compute_md5sum

@ %def beam_data_compute_md5sum
@
\subsection{Initializers: decays}
This is the simplest one: decay in rest frame.  We need just flavor
and polarization.  Color is inferred from flavor.  Beam momentum and
c.m.\ momentum coincide.
<<Beams: public>>=
  public :: beam_data_init_decay
<<Beams: procedures>>=
  subroutine beam_data_init_decay (beam_data, flv, smatrix, pol_f, rest_frame)
    type(beam_data_t), intent(out) :: beam_data
    type(flavor_t), dimension(1), intent(in) :: flv
    type(smatrix_t), dimension(1), intent(in), optional :: smatrix
    real(default), dimension(:), intent(in), optional :: pol_f
    logical, intent(in), optional :: rest_frame
    real(default), dimension(1) :: m
    m = flavor_get_mass (flv)
    if (present (smatrix)) then
       call beam_data_init_sqrts (beam_data, m(1), flv, smatrix, pol_f)
    else
       call beam_data_init_sqrts (beam_data, m(1), flv, smatrix, pol_f)
    end if
    if (present (rest_frame))  beam_data%lab_is_cm_frame = rest_frame
  end subroutine beam_data_init_decay

@ %def beam_data_init_decay
@
\subsection{Sanity check}
After the beams have been set, the initial-particle masses may have
been modified.  This can be checked here.
<<Beams: public>>=
  public :: beam_data_masses_are_consistent
<<Beams: procedures>>=
  function beam_data_masses_are_consistent (beam_data) result (flag)
    logical :: flag
    type(beam_data_t), intent(in) :: beam_data
    flag = all (beam_data%mass == flavor_get_mass (beam_data%flv))
  end function beam_data_masses_are_consistent

@ %def beam_data_masses_are_consistent
@
\subsection{The beams type}
Beam objects are interaction objects that contain the actual beam
data including polarization and density matrix.  For collisions, the
beam object actually contains two beams.
<<Beams: public>>=
  public :: beam_t
<<Beams: types>>=
  type :: beam_t
     private
     type(interaction_t) :: int
  end type beam_t

@ %def beam_t
@ The constructor contains code that converts beam data into the
(entangled) particle-pair quantum state.  First, we set the number of
particles and polarization mask.  (The polarization mask is handed
over to all later interactions, so if helicity is diagonal or absent, this fact
is used when constructing the hard-interaction events.)  Then, we
construct the entangled state that combines helicity, flavor and color
of the two particles (where flavor and color are unique, while several
helicity states are possible).  Then, we transfer this state together
with the associated values from the spin density matrix into the
[[interaction_t]] object.
<<Beams: public>>=
  public :: beam_init
<<Beams: procedures>>=
  subroutine beam_init (beam, beam_data)
    type(beam_t), intent(out) :: beam
    type(beam_data_t), intent(in), target :: beam_data
    type(quantum_numbers_mask_t), dimension(beam_data%n) :: mask
    type(state_matrix_t), target :: state_hel, state_fc, state_tmp
    type(state_iterator_t) :: it_hel, it_tmp
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    type(polarization_t), dimension(:), allocatable :: pol
    integer :: i
    mask = new_quantum_numbers_mask (.false., .false., &
         .not. beam_data%pmatrix%is_polarized (), &
         mask_hd = beam_data%pmatrix%is_diagonal ())
    call interaction_init &
         (beam%int, 0, 0, beam_data%n, mask=mask, store_values=.true.)
    allocate (pol (beam_data%n))
    do i = 1, size (pol)
       call polarization_init_pmatrix (pol(i), beam_data%pmatrix(i))
    end do
    call combine_polarization_states (pol, state_hel)
    do i = 1, size (pol)
       call polarization_final (pol(i))
    end do
    allocate (qn (beam_data%n))
    call quantum_numbers_init &
         (qn, beam_data%flv, color_from_flavor (beam_data%flv, 1))
    call state_matrix_init (state_fc)
    call state_matrix_add_state (state_fc, qn)
    call merge_state_matrices (state_hel, state_fc, state_tmp)
    call state_iterator_init (it_hel, state_hel)
    call state_iterator_init (it_tmp, state_tmp)
    do while (state_iterator_is_valid (it_hel))
       call interaction_add_state (beam%int, &
            state_iterator_get_quantum_numbers (it_tmp), &
            value=state_iterator_get_matrix_element (it_hel))
       call state_iterator_advance (it_hel)
       call state_iterator_advance (it_tmp)
    end do
    call interaction_freeze (beam%int)
    call interaction_set_momenta &
         (beam%int, beam_data%p, outgoing = .true.)
    call state_matrix_final (state_hel)
    call state_matrix_final (state_fc)
    call state_matrix_final (state_tmp)
  end subroutine beam_init

@ %def beam_init
@ Finalizer:
<<Beams: public>>=
  public :: beam_final
<<Beams: procedures>>=
  elemental subroutine beam_final (beam)
    type(beam_t), intent(inout) :: beam
    call interaction_final (beam%int)
  end subroutine beam_final

@ %def beam_final
@ I/O:
<<Beams: public>>=
  public :: beam_write
<<Beams: procedures>>=
  subroutine beam_write (beam, unit, verbose, show_momentum_sum, show_mass)
    type(beam_t), intent(in) :: beam
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, show_momentum_sum, show_mass
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    select case (interaction_get_n_out (beam%int))
    case (1);  write (u, *) "Decaying particle:"
    case (2);  write (u, *) "Colliding beams:"
    end select
    call interaction_write &
         (beam%int, unit, verbose = verbose, show_momentum_sum = &
            show_momentum_sum, show_mass = show_mass)
  end subroutine beam_write

@ %def beam_write
@ Defined assignment: deep copy
<<Beams: public>>=
  public :: assignment(=)
<<Beams: interfaces>>=
  interface assignment(=)
     module procedure beam_assign
  end interface

<<Beams: procedures>>=
  subroutine beam_assign (beam_out, beam_in)
    type(beam_t), intent(out) :: beam_out
    type(beam_t), intent(in) :: beam_in
    beam_out%int = beam_in%int
  end subroutine beam_assign

@ %def beam_assign
@ 
\subsection{Inherited procedures}
<<Beams: public>>=
  public :: interaction_set_source_link
<<Beams: interfaces>>=
  interface interaction_set_source_link
     module procedure interaction_set_source_link_beam
  end interface
<<Beams: procedures>>=
  subroutine interaction_set_source_link_beam (int, i, beam1, i1)
    type(interaction_t), intent(inout) :: int
    type(beam_t), intent(in), target :: beam1
    integer, intent(in) :: i, i1
    call interaction_set_source_link (int, i, beam1%int, i1)
  end subroutine interaction_set_source_link_beam

@ %def interaction_set_source_link_beam
@
\subsection{Accessing contents}
Return the interaction component -- as a pointer, to avoid any copying.
<<Beams: public>>=
  public :: beam_get_int_ptr
<<Beams: procedures>>=
  function beam_get_int_ptr (beam) result (int)
    type(interaction_t), pointer :: int
    type(beam_t), intent(in), target :: beam
    int => beam%int
  end function beam_get_int_ptr

@ %def beam_get_int_ptr
@ Set beam momenta directly.  (Used for cascade decays.)
<<Beams: public>>=
  public :: beam_set_momenta
<<Beams: procedures>>=
  subroutine beam_set_momenta (beam, p)
    type(beam_t), intent(inout) :: beam
    type(vector4_t), dimension(:), intent(in) :: p
    call interaction_set_momenta (beam%int, p)
  end subroutine beam_set_momenta

@ %def beam_set_momenta
\subsection{Unit tests}
<<Beams: public>>=
  public :: beam_test
<<Beams: procedures>>=
  subroutine beam_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Beams: execute tests>>
  end subroutine beam_test

@  %def beam_test
@ Test the basic beam setup.
<<Beams: execute tests>>=
  call test (beam_1, "beam_1", &
       "check basic beam setup", &
       u, results)
<<Beams: tests>>=
  subroutine beam_1 (u)
    integer, intent(in) :: u
    type(beam_data_t), target :: beam_data
    type(beam_t) :: beam
    real(default) :: sqrts
    type(flavor_t), dimension(2) :: flv
    type(smatrix_t), dimension(2) :: smatrix
    real(default), dimension(2) :: pol_f
    type(model_data_t), target :: model
    
    write (u, "(A)")  "* Test output: beam_1"
    write (u, "(A)")  "*   Purpose: test basic beam setup"
    write (u, "(A)")      
        
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 

    call reset_interaction_counter ()

    call model%init_sm_test ()

    write (u, "(A)")  "* 1: Scattering process"
    write (u, "(A)")
    
    sqrts = 500
    call flavor_init (flv, [1,-1], model)

    call smatrix(1)%init (2, 1)
    call smatrix(1)%set_entry (1, [1,1], (1._default, 0._default))
    pol_f(1) = 0.5_default

    !!! 2.1 version:
    ! call polarization_init_circular (pol(1), flv(1), 0.5_default)

    call smatrix(2)%init (2, 3)
    call smatrix(2)%set_entry (1, [1,1], (1._default, 0._default))
    call smatrix(2)%set_entry (2, [-1,-1], (1._default, 0._default))
    call smatrix(2)%set_entry (3, [-1,1], (1._default, 0._default))
    pol_f(2) = 1._default

    !!! 2.1 version:
    ! call polarization_init_transversal (pol(2), flv(2), 0._default, 1._default)
    call beam_data_init_sqrts (beam_data, sqrts, flv, smatrix, pol_f)
    call beam_data_write (beam_data, u)
    write (u, "(A)")
    call beam_init (beam, beam_data)
    call beam_write (beam, u)
    call beam_final (beam)
    call beam_data_final (beam_data)
    
    write (u, "(A)")
    write (u, "(A)")  "* 2: Decay"
    write (u, "(A)")
    call flavor_init (flv(1), 23, model)
    call smatrix(1)%init (2, 1)
    call smatrix(1)%set_entry (1, [0,0], (1._default, 0._default))
    pol_f(1) = 0.4_default

    !!! 2.1 version:
    ! call polarization_init_longitudinal (pol(1), flv(1), 0.4_default)
    call beam_data_init_decay (beam_data, flv(1:1), smatrix(1:1), pol_f(1:1))
    call beam_data_write (beam_data, u)
    write (u, "(A)")
    call beam_init (beam, beam_data)
    call beam_write (beam, u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"            
       
    call beam_final (beam)
    call beam_data_final (beam_data)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_1"        
    
  end subroutine beam_1

@ %def beam_1
@ Test advanced beam setup.
<<Beams: execute tests>>=
  call test (beam_2, "beam_2", &
       "beam initialization", &
       u, results)
<<Beams: tests>>=
  subroutine beam_2 (u)
    integer, intent(in) :: u
    type(beam_data_t), target :: beam_data
    type(beam_t) :: beam
    real(default) :: sqrts
    type(flavor_t), dimension(2) :: flv
    integer, dimension(0) :: no_records
    type(beam_structure_t) :: beam_structure
    type(model_data_t), target :: model
    
    write (u, "(A)")  "* Test output: beam_2"
    write (u, "(A)")  "*   Purpose: transfer beam polarization using &
         &beam structure"
    write (u, "(A)")      
        
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 

    call reset_interaction_counter ()

    call model%init_sm_test ()

    write (u, "(A)")  "* 1: Scattering process"
    write (u, "(A)")
    
    sqrts = 500
    call flavor_init (flv, [1,-1], model)
    call beam_structure%init_sf (flavor_get_name (flv), no_records)

    call beam_structure%init_pol (2)

    call beam_structure%init_smatrix (1, 1)
    call beam_structure%set_sentry (1, 1, [1,1], (1._default, 0._default))

    call beam_structure%init_smatrix (2, 3)
    call beam_structure%set_sentry (2, 1, [1,1], (1._default, 0._default))
    call beam_structure%set_sentry (2, 2, [-1,-1], (1._default, 0._default))
    call beam_structure%set_sentry (2, 3, [-1,1], (1._default, 0._default))

    call beam_structure%set_pol_f ([0.5_default, 1._default])
    call beam_structure%write (u)
    write (u, *)
    
    call beam_data_init_structure (beam_data, beam_structure, sqrts, model)
    call beam_data_write (beam_data, u)
    write (u, *)
 
    call beam_init (beam, beam_data)
    call beam_write (beam, u)

    call beam_final (beam)
    call beam_data_final (beam_data)
    call beam_structure%final_pol ()
    call beam_structure%final_sf ()
    
    write (u, "(A)")
    write (u, "(A)")  "* 2: Decay"
    write (u, "(A)")

    call flavor_init (flv(1), 23, model)
    call beam_structure%init_sf ([flavor_get_name (flv(1))], no_records)

    call beam_structure%init_pol (1)

    call beam_structure%init_smatrix (1, 1)
    call beam_structure%set_sentry (1, 1, [0,0], (1._default, 0._default))
    call beam_structure%set_pol_f ([0.4_default])
    call beam_structure%write (u)
    write (u, *)
    
    call beam_data_init_structure (beam_data, beam_structure, sqrts, model)
    call beam_data_write (beam_data, u)
    write (u, "(A)")
    call beam_init (beam, beam_data)
    call beam_write (beam, u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"            
       
    call beam_final (beam)
    call beam_data_final (beam_data)

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_2"        
    
  end subroutine beam_2

@ %def beam_2
@ Test advanced beam setup, completely arbitrary momenta.
<<Beams: execute tests>>=
  call test (beam_3, "beam_3", &
       "generic beam momenta", &
       u, results)
<<Beams: tests>>=
  subroutine beam_3 (u)
    integer, intent(in) :: u
    type(beam_data_t), target :: beam_data
    type(beam_t) :: beam
    type(flavor_t), dimension(2) :: flv
    integer, dimension(0) :: no_records
    type(model_data_t), target :: model
    type(beam_structure_t) :: beam_structure
    type(vector3_t), dimension(2) :: p3
    type(vector4_t), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: beam_3"
    write (u, "(A)")  "*   Purpose: set up beams with generic momenta"
    write (u, "(A)")      
        
    write (u, "(A)")  "* Reading model file"
    write (u, "(A)") 

    call reset_interaction_counter ()

    call model%init_sm_test ()

    write (u, "(A)")  "* 1: Scattering process"
    write (u, "(A)")
    
    call flavor_init (flv, [2212,2212], model)

    p3(1) = vector3_moving ([5._default, 0._default, 10._default])
    p3(2) = -vector3_moving ([1._default, 1._default, -10._default])

    call beam_structure%init_sf (flavor_get_name (flv), no_records)
    call beam_structure%set_momentum (p3 ** 1)
    call beam_structure%set_theta (polar_angle (p3))
    call beam_structure%set_phi (azimuthal_angle (p3))
    call beam_structure%write (u)
    write (u, *)

    call beam_data_init_structure (beam_data, beam_structure, 0._default, model)
    call beam_data_write (beam_data, u, verbose = .true.)
    write (u, *)
 
    write (u, "(1x,A)")  "Beam momenta reconstructed from LT:"
    p = beam_data%L_cm_to_lab * beam_data%p_cm
    call pacify (p, 1e-12_default)
    call vector4_write (p(1), u)
    call vector4_write (p(2), u)
    write (u, "(A)")

    call beam_init (beam, beam_data)
    call beam_write (beam, u)

    call beam_final (beam)
    call beam_data_final (beam_data)
    call beam_structure%final_sf ()
    call beam_structure%final_mom ()
    
    write (u, "(A)")
    write (u, "(A)")  "* 2: Decay"
    write (u, "(A)")

    call flavor_init (flv(1), 23, model)
    p3(1) = vector3_moving ([10._default, 5._default, 50._default])
    
    call beam_structure%init_sf ([flavor_get_name (flv(1))], no_records)
    call beam_structure%set_momentum ([p3(1) ** 1])
    call beam_structure%set_theta ([polar_angle (p3(1))])
    call beam_structure%set_phi ([azimuthal_angle (p3(1))])
    call beam_structure%write (u)
    write (u, *)

    call beam_data_init_structure (beam_data, beam_structure, 0._default, model)
    call beam_data_write (beam_data, u, verbose = .true.)
    write (u, "(A)")

    write (u, "(1x,A)")  "Beam momentum reconstructed from LT:"
    p(1) = beam_data%L_cm_to_lab * beam_data%p_cm(1)
    call pacify (p(1), 1e-12_default)
    call vector4_write (p(1), u)
    write (u, "(A)")

    call beam_init (beam, beam_data)
    call beam_write (beam, u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"            
       
    call beam_final (beam)
    call beam_data_final (beam_data)
    call beam_structure%final_sf ()
    call beam_structure%final_mom ()

    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: beam_3"        
    
  end subroutine beam_3

@ %def beam_3
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tools}

This module contains auxiliary procedures that can be accessed by the
structure function code.

<<[[sf_aux.f90]]>>=
<<File header>>

module sf_aux

<<Use kinds>>
  use io_units
  use constants, only: twopi
  use unit_tests

  use lorentz

<<Standard module head>>

<<SF aux: public>>

<<SF aux: parameters>>

<<SF aux: types>>

contains

<<SF aux: procedures>>

<<SF aux: tests>>

end module sf_aux

@ %def sf_aux
@
\subsection{Momentum splitting}
Let us consider first an incoming parton with momentum $k$ and
invariant mass squared $s=k^2$ that splits into two partons with
momenta $q,p$ and invariant masses $t=q^2$ and $u=p^2$.  (This is an
abuse of the Mandelstam notation.  $t$ is actually the momentum
transfer, assuming that $p$ is radiated and $q$ initiates the hard
process.) The energy is split among the partons such that if $E=k^0$,
we have $q^0 = xE$ and $p^0=\bar x E$, where $\bar x\equiv 1-x$.

We define the angle $\theta$ as the polar angle of $p$ w.r.t.\ the
momentum axis of the incoming momentum $k$.  Ignoring azimuthal angle,
we can write the four-momenta in the basis $(E,p_T,p_L)$ as
\begin{equation}
  k = 
  \begin{pmatrix}
    E \\ 0 \\ p
  \end{pmatrix},
  \qquad
  p =
  \begin{pmatrix}
    \bar x E \\ \bar x\bar p\sin\theta \\ \bar x\bar p\cos\theta
  \end{pmatrix},
  \qquad
  q =
  \begin{pmatrix}
    x E \\ -\bar x\bar p\sin\theta \\ p - \bar x\bar p\cos\theta
  \end{pmatrix},
\end{equation}
where the first two mass-shell conditions are
\begin{equation}
  p^2 = E^2 - s,
  \qquad
  \bar p^2 = E^2 - \frac{u}{\bar x^2}.
\end{equation}
The second condition implies that, for positive $u$, $\bar x^2 >
u/E^2$, or equivalently
\begin{equation}
  x < 1 - \sqrt{u} / E.
\end{equation}

We are interested in the third mass-shell conditions: $s$ and $u$ are
fixed, so we need $t$ as a function of $\cos\theta$:
\begin{equation}
  t = -2\bar x \left(E^2 - p\bar p\cos\theta\right) + s + u.
\end{equation}
Solving for $\cos\theta$, we get
\begin{equation}
  \cos\theta = \frac{2\bar x E^2 + t - s - u}{2\bar x p\bar p}.
\end{equation}
We can compute $\sin\theta$ numerically as
$\sin^2\theta=1-\cos^2\theta$, but it is important to reexpress this
in view of numerical stability.  To this end, we first determine the
bounds for $t$.  The cosine must be between $-1$ and $1$, so the
bounds are
\begin{align}
  t_0 &= -2\bar x\left(E^2 + p\bar p\right) + s + u,
\\
  t_1 &= -2\bar x\left(E^2 - p\bar p\right) + s + u.
\end{align}
Computing $\sin^2\theta$ from $\cos\theta$ above, we observe that the
numerator is a quadratic polynomial in $t$ which has the zeros $t_0$
and $t_1$, while the common denominator is given by $(2\bar x p\bar
p)^2$.  Hence, we can write
\begin{equation}
  \sin^2\theta = -\frac{(t - t_0)(t - t_1)}{(2\bar x p\bar p)^2}
  \qquad\text{and}\qquad
  \cos\theta = \frac{(t-t_0) + (t-t_1)}{4\bar x p\bar p},
\end{equation}
which is free of large cancellations near $t=t_0$ or $t=t_1$.

If all is massless, i.e., $s=u=0$, this simplifies to
\begin{align}
  t_0 &= -4\bar x E^2, 
&
  t_1 &= 0,
\\
  \sin^2\theta &= -\frac{t}{\bar x E^2}
                   \left(1 + \frac{t}{4\bar x E^2}\right),
&
  \cos\theta &= 1 + \frac{t}{2\bar x E^2}.
\end{align}

Here is the implementation.  First, we define a container for the
kinematical integration limits and some further data.
<<SF aux: public>>=
  public :: splitting_data_t
<<SF aux: types>>=
  type :: splitting_data_t
     private
     logical :: collinear = .false.
     real(default) :: x0 = 0
     real(default) :: x1
     real(default) :: t0
     real(default) :: t1
     real(default) :: phi0 = 0
     real(default) :: phi1 = twopi
     real(default) :: E, p, s, u, m2
     real(default) :: x, xb, pb
     real(default) :: t = 0
     real(default) :: phi = 0
   contains
   <<SF aux: splitting data: TBP>>
  end type splitting_data_t

@ %def splitting_data_t
@ I/O for debugging:
<<SF aux: splitting data: TBP>>=
  procedure :: write => splitting_data_write
<<SF aux: procedures>>=
  subroutine splitting_data_write (d, unit)
    class(splitting_data_t), intent(in) :: d
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A)") "Splitting data:"
    write (u, "(2x,A,L1)")  "collinear = ", d%collinear
1   format (2x,A,1x,ES15.8)
    write (u, 1) "x0   =", d%x0
    write (u, 1) "x    =", d%x
    write (u, 1) "xb   =", d%xb
    write (u, 1) "x1   =", d%x1
    write (u, 1) "t0   =", d%t0
    write (u, 1) "t    =", d%t
    write (u, 1) "t1   =", d%t1
    write (u, 1) "phi0 =", d%phi0
    write (u, 1) "phi  =", d%phi
    write (u, 1) "phi1 =", d%phi1
    write (u, 1) "E    =", d%E
    write (u, 1) "p    =", d%p
    write (u, 1) "pb   =", d%pb
    write (u, 1) "s    =", d%s
    write (u, 1) "u    =", d%u
    write (u, 1) "m2   =", d%m2
  end subroutine splitting_data_write

@ %def splitting_data_write
@ 
\subsection{Constant data}
This is the initializer for the data.  The input consists of the
incoming momentum, its invariant mass squared, and the invariant mass
squared of the radiated particle.  $m2$ is the \emph{physical} mass
squared of the outgoing particle.  The $t$ bounds depend on the chosen $x$
value and cannot be determined yet.
<<SF aux: splitting data: TBP>>=
  procedure :: init => splitting_data_init
<<SF aux: procedures>>=
  subroutine splitting_data_init (d, k, mk2, mr2, mo2, collinear)
    class(splitting_data_t), intent(out) :: d
    type(vector4_t), intent(in) :: k
    real(default), intent(in) :: mk2, mr2, mo2
    logical, intent(in), optional :: collinear
    if (present (collinear))  d%collinear = collinear
    d%E = energy (k)
    d%x1 = 1 - sqrt (max (mr2, 0._default)) / d%E
    d%p = sqrt (d%E**2 - mk2)
    d%s = mk2
    d%u = mr2
    d%m2 = mo2
  end subroutine splitting_data_init

@ %def splitting_data_init
@ Retrieve the $x$ bounds, if needed for $x$ sampling.  Generating an
$x$ value is done by the caller, since this is the part that depends
on the nature of the structure function.
<<SF aux: splitting data: TBP>>=
  procedure :: get_x_bounds => splitting_get_x_bounds
<<SF aux: procedures>>=
  function splitting_get_x_bounds (d) result (x)
    class(splitting_data_t), intent(in) :: d
    real(default), dimension(2) :: x
    x = [ d%x0, d%x1 ]
  end function splitting_get_x_bounds

@ %def splitting_get_x_bounds
@ Now set the momentum fraction and compute $t_0$ and $t_1$.

[The calculation of $t_1$ is subject to numerical problems.  The exact
formula is ($s=m_i^2$, $u=m_r^2$)
\begin{equation}
  t_1 = -2\bar x E^2 + m_i^2 + m_r^2 
  + 2\bar x \sqrt{E^2-m_i^2}\,\sqrt{E^2 - m_r^2/\bar x^2}.
\end{equation}
The structure-function paradigm is useful only if $E\gg m_i,m_r$.  In
a Taylor expansion for large $E$, the leading term cancels.  The
expansion of the square roots (to subleading order) yields
\begin{equation}
  t_1 = xm_i^2 - \frac{x}{\bar x}m_r^2.
\end{equation}
There are two cases of interest: $m_i=m_o$ and $m_r=0$,
\begin{equation}
  t_1 = xm_o^2
\end{equation}
and $m_i=m_r$ and $m_o=0$,
\begin{equation}
  t_1 = -\frac{x^2}{\bar x}m_i^2.
\end{equation}
In both cases, $t_1\leq m_o^2$.]

That said, it turns out that taking the $t_1$ evaluation at face value
leads to less problems than the approximation.  We express the angles
in terms of $t-t_0$ and $t-t_1$.  Numerical noise in $t_1$ can then be
tolerated.
<<SF aux: splitting data: TBP>>=
  procedure :: set_t_bounds => splitting_set_t_bounds
<<SF aux: procedures>>=
  elemental subroutine splitting_set_t_bounds (d, x, xb)
    class(splitting_data_t), intent(inout) :: d
    real(default), intent(in), optional :: x, xb
    real(default) :: tp, tm
    if (present (x))  d%x = x
    if (present (xb)) d%xb = xb
    if (d%xb /= 0) then
       d%pb = sqrt (max (d%E**2 - d%u / d%xb**2, 0._default))
    else
       d%pb = 0
    end if
    tp = -2 * d%xb * d%E**2 + d%s + d%u
    tm = -2 * d%xb * d%p * d%pb
    d%t0 = tp + tm
    d%t1 = tp - tm
    d%t = d%t1
  end subroutine splitting_set_t_bounds

@ %def splitting_set_t_bounds
@ 
\subsection{Sampling recoil}
Compute a value for the momentum transfer $t$, using a random number
$r$.  We assume a logarithmic distribution for $t-m^2$, corresponding
to the propagator $1/(t-m^2)$ with the physical mass $m$ for the
outgoing particle.  Optionally, we can narrow the kinematical bounds.

If all three masses in the splitting vanish, the upper limit for $t$
is zero.  In that case, the $t$ value is set to zero and the splitting
will be collinear.
<<SF aux: splitting data: TBP>>=
  procedure :: sample_t => splitting_sample_t
<<SF aux: procedures>>=
  subroutine splitting_sample_t (d, r, t0, t1)
    class(splitting_data_t), intent(inout) :: d
    real(default), intent(in) :: r
    real(default), intent(in), optional :: t0, t1
    real(default) :: tt0, tt1, tt0m, tt1m
    if (d%collinear) then
       d%t = d%t1
    else
       tt0 = d%t0;  if (present (t0))  tt0 = max (t0, tt0)
       tt1 = d%t1;  if (present (t1))  tt1 = min (t1, tt1)
       tt0m = tt0 - d%m2
       tt1m = tt1 - d%m2
       if (tt0m < 0 .and. tt1m < 0 .and. abs(tt0m) > &
            epsilon(tt0m) .and. abs(tt1m) > epsilon(tt0m)) then
          d%t = d%m2 + tt0m * exp (r * log (tt1m / tt0m))
       else
          d%t = tt1
       end if
    end if
  end subroutine splitting_sample_t

@ %def splitting_sample_t
@ The inverse operation: Given $t$, we recover the value of $r$ that
would have produced this value.
<<SF aux: splitting data: TBP>>=
  procedure :: inverse_t => splitting_inverse_t
<<SF aux: procedures>>=
  subroutine splitting_inverse_t (d, r, t0, t1)
    class(splitting_data_t), intent(in) :: d
    real(default), intent(out) :: r
    real(default), intent(in), optional :: t0, t1
    real(default) :: tt0, tt1, tt0m, tt1m
    if (d%collinear) then
       r = 0
    else
       tt0 = d%t0;  if (present (t0))  tt0 = max (t0, tt0)
       tt1 = d%t1;  if (present (t1))  tt1 = min (t1, tt1)
       tt0m = tt0 - d%m2
       tt1m = tt1 - d%m2
       if (tt0m < 0 .and. tt1m < 0) then
          r = log ((d%t - d%m2) / tt0m) / log (tt1m / tt0m)
       else
          r = 0
       end if
    end if
  end subroutine splitting_inverse_t
    
@ %def splitting_inverse_t
@ This is trivial, but provided for convenience:
<<SF aux: splitting data: TBP>>=
  procedure :: sample_phi => splitting_sample_phi
<<SF aux: procedures>>=
  subroutine splitting_sample_phi (d, r)
    class(splitting_data_t), intent(inout) :: d
    real(default), intent(in) :: r
    if (d%collinear) then
       d%phi = 0
    else
       d%phi = (1-r) * d%phi0 + r * d%phi1
    end if
  end subroutine splitting_sample_phi

@ %def splitting_sample_phi
@ Inverse:
<<SF aux: splitting data: TBP>>=
  procedure :: inverse_phi => splitting_inverse_phi
<<SF aux: procedures>>=
  subroutine splitting_inverse_phi (d, r)
    class(splitting_data_t), intent(in) :: d
    real(default), intent(out) :: r
    if (d%collinear) then
       r = 0
    else
       r = (d%phi - d%phi0) / (d%phi1 - d%phi0)
    end if
  end subroutine splitting_inverse_phi

@ %def splitting_inverse_phi
@ 
\subsection{Splitting}
In this function, we actually perform the splitting.  The incoming momentum
$k$ is split into (if no recoil) $q_1=(1-x)k$ and $q_2=xk$.

Apart from the splitting data, we need the incoming momentum $k$, the momentum
transfer $t$, and the azimuthal angle $\phi$.  The momentum fraction $x$ is
already known here.

Alternatively, we can split without recoil.  The azimuthal angle is
irrelevant, and the momentum transfer is always equal to the upper
limit $t_1$, so the polar angle is zero.  Obviously, if there are
nonzero masses it is not possible to keep both energy-momentum
conservation and at the same time all particles on shell.  We choose
for dropping the on-shell condition here.
<<SF aux: splitting data: TBP>>=
  procedure :: split_momentum => splitting_split_momentum
<<SF aux: procedures>>=
  function splitting_split_momentum (d, k) result (q)
    class(splitting_data_t), intent(in) :: d
    type(vector4_t), dimension(2) :: q
    type(vector4_t), intent(in) :: k
    real(default) :: st2, ct2, st, ct, cp, sp
    type(lorentz_transformation_t) :: rot
    real(default) :: tt0, tt1, den
    type(vector3_t) :: kk, q1, q2
    if (d%collinear) then
       if (d%s == 0 .and. d%u == 0) then
          q(1) = d%xb * k
          q(2) = d%x * k
       else
          kk = space_part (k)
          q1 = d%xb * (d%pb / d%p) * kk
          q2 = kk - q1
          q(1) = vector4_moving (d%xb * d%E, q1)
          q(2) = vector4_moving (d%x * d%E, q2)
       end if
    else       
       den = 2 * d%xb * d%p * d%pb       
       tt0 = max (d%t - d%t0, 0._default)
       tt1 = min (d%t - d%t1, 0._default)
       if (den**2 <= epsilon(den)) then
          st2 = 1
       else
          st2 = - (tt0 * tt1) / den ** 2
       end if
       if (st2 > 1) then 
          st2 = 1
       end if
       ct2 = 1 - st2
       st = sqrt (max (st2, 0._default))
       ct = sqrt (max (ct2, 0._default))
       sp = sin (d%phi)
       cp = cos (d%phi)
       rot = rotation_to_2nd (3, space_part (k))
       q1 = vector3_moving (d%xb * d%pb * [st * cp, st * sp, ct])
       q2 = vector3_moving (d%p, 3) - q1
       q(1) = rot * vector4_moving (d%xb * d%E, q1)
       q(2) = rot * vector4_moving (d%x * d%E, q2)
    end if
  end function splitting_split_momentum
    
@ %def splitting_split_momentum
@ 
Momenta generated by splitting will in general be off-shell.  They are
on-shell only if they are collinear and massless.  This subroutine
puts them on shell by brute force, violating either momentum or energy
conservation.  The direction of three-momentum is always retained.

If the energy is below mass shell, we return a zero momentum.
<<SF aux: parameters>>=
  integer, parameter, public :: KEEP_ENERGY = 0, KEEP_MOMENTUM = 1
@ %def KEEP_ENERGY KEEP_MOMENTUM
<<SF aux: public>>=    
  public :: on_shell
<<SF aux: procedures>>=
  elemental subroutine on_shell (p, m2, keep)
    type(vector4_t), intent(inout) :: p
    real(default), intent(in) :: m2
    integer, intent(in) :: keep
    real(default) :: E, E2, pn
    select case (keep)
    case (KEEP_ENERGY)
       E = energy (p)
       E2 = E ** 2
       if (E2 >= m2) then
          pn = sqrt (E2 - m2)
          p = vector4_moving (E, pn * direction (space_part (p)))
       else
          p = vector4_null
       end if
    case (KEEP_MOMENTUM)
       E = sqrt (space_part (p) ** 2 + m2)
       p = vector4_moving (E, space_part (p))
    end select
  end subroutine on_shell

@ %def on_shell
@
\subsection{Recovering the splitting}
This is the inverse problem.  We have on-shell momenta and want to
deduce the splitting parameters $x$, $t$, and $\phi$.
<<SF aux: splitting data: TBP>>=
  procedure :: recover => splitting_recover
<<SF aux: procedures>>=
  subroutine splitting_recover (d, k, q, keep)
    class(splitting_data_t), intent(inout) :: d
    type(vector4_t), intent(in) :: k, q
    integer, intent(in) :: keep
    type(lorentz_transformation_t) :: rot
    type(vector4_t) :: q0, k0
    real(default) :: p1, p2, p3, pt2, pp2, pl
    real(default) :: aux, den, norm
    real(default) :: st2, ct2, ct
    rot = inverse (rotation_to_2nd (3, space_part (k)))
    q0 = rot * q
    p1 = vector4_get_component (q0, 1)
    p2 = vector4_get_component (q0, 2)
    p3 = vector4_get_component (q0, 3)
    pt2 = p1 ** 2 + p2 ** 2
    pp2 = p1 ** 2 + p2 ** 2 + p3 ** 2
    pl = abs (p3)
    k0 = vector4_moving (d%E, d%p, 3)
    select case (keep)
    case (KEEP_ENERGY)
       d%x = energy (q0) / d%E
       d%xb = 1 - d%x
       call d%set_t_bounds ()
       if (.not. d%collinear) then
          aux = (d%xb * d%pb) ** 2 * pp2 - d%p ** 2 * pt2
          den = d%p ** 2 - (d%xb * d%pb) ** 2
          if (aux >= 0 .and. den > 0) then
             norm = (d%p * pl + sqrt (aux)) / den
          else
             norm = 1
          end if
       end if
    case (KEEP_MOMENTUM)
       d%xb = sqrt (space_part (k0 - q0) ** 2 + d%u) / d%E
       d%x = 1 - d%xb
       call d%set_t_bounds ()
       norm = 1
    end select
    if (d%collinear) then
       d%t = d%t1
       d%phi = 0
    else
       if ((d%xb * d%pb * norm)**2 < epsilon(d%xb)) then
          st2 = 1
       else
          st2 = pt2 / (d%xb * d%pb * norm ) ** 2
       end if
       if (st2 > 1) then
          st2 = 1
       end if
       ct2 = 1 - st2
       ct = sqrt (max (ct2, 0._default))
       if (ct /= -1) then
          d%t = d%t1 - 2 * d%xb * d%p * d%pb * st2 / (1 + ct)
       else
          d%t = d%t0
       end if
       if (p1 /= 0 .or. p2 /= 0) then
          d%phi = atan2 (-p2, -p1)
       else
          d%phi = 0
       end if
    end if
  end subroutine splitting_recover
       
@ %def splitting_recover
@
\subsection{Extract data}
<<SF aux: splitting data: TBP>>=
  procedure :: get_x => splitting_get_x
<<SF aux: procedures>>=
  function splitting_get_x (sd) result (x)
    class(splitting_data_t), intent(in) :: sd
    real(default) :: x
    x = sd%x
  end function splitting_get_x

@ %def splitting_get_x
@
\subsection{Unit tests}
<<SF aux: public>>=
  public :: sf_aux_test
<<SF aux: tests>>=
  subroutine sf_aux_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF aux: execute tests>>
  end subroutine sf_aux_test
  
@ %def sf_aux_test
@ 
\subsubsection{Momentum splitting: massless radiation}
Compute momentum splitting for generic kinematics.  It turns out that
for $x=0.5$, where $t-m^2$ is the geometric mean between its upper and
lower bounds (this can be directly seen from the logarithmic
distribution in the function [[sample_t]] for $r \equiv x = 1 - x =
0.5$), we arrive at an exact number $t=-0.15$ for the given 
input values.
<<SF aux: execute tests>>=
  call test (sf_aux_1, "sf_aux_1", &
       "massless radiation", &
       u, results)
<<SF aux: tests>>=
  subroutine sf_aux_1 (u)
    integer, intent(in) :: u
    type(splitting_data_t) :: sd
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q, q0
    real(default) :: E, mk, mp, mq
    real(default) :: x, r1, r2, r1o, r2o
    real(default) :: k2, q0_2, q1_2, q2_2
    
    write (u, "(A)")  "* Test output: sf_aux_1"
    write (u, "(A)")  "*   Purpose: compute momentum splitting"
    write (u, "(A)")  "             (massless radiated particle)"
    write (u, "(A)")

    E = 1
    mk = 0.3_default
    mp = 0
    mq = mk

    k = vector4_moving (E, sqrt (E**2 - mk**2), 3)
    k2 = k ** 2;  call pacify (k2, 1e-10_default)

    x = 0.6_default
    r1 = 0.5_default
    r2 = 0.125_default
    
    write (u, "(A)")  "* (1) Non-collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%sample_t (r1)
    call sd%sample_phi (r2)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q0_2 = q0(2) ** 2;  call pacify (q0_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q0_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t
    

    call sd%inverse_t (r1o)
    
    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)
    
    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q0_2 = q0(2) ** 2;  call pacify (q0_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q0_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    call sd%inverse_t (r1o)

    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)

    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* (2) Collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2, collinear = .true.)
    call sd%set_t_bounds (x, 1 - x)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q0_2 = q0(2) ** 2;  call pacify (q0_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q0_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q0_2 = q0(2) ** 2;  call pacify (q0_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q0_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_aux_1"

  end subroutine sf_aux_1
  
@ %def sf_aux_1
@ 
\subsubsection{Momentum splitting: massless parton}
Compute momentum splitting for generic kinematics.  It turns out that
for $x=0.5$, where $t-m^2$ is the geometric mean between its upper and
lower bounds, we arrive at an exact number $t=-0.36$ for the given
input values.
<<SF aux: execute tests>>=
  call test (sf_aux_2, "sf_aux_2", &
       "massless parton", &
       u, results)
<<SF aux: tests>>=
  subroutine sf_aux_2 (u)
    integer, intent(in) :: u
    type(splitting_data_t) :: sd
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q, q0
    real(default) :: E, mk, mp, mq
    real(default) :: x, r1, r2, r1o, r2o
    real(default) :: k2, q02_2, q1_2, q2_2
    
    write (u, "(A)")  "* Test output: sf_aux_2"
    write (u, "(A)")  "*   Purpose: compute momentum splitting"
    write (u, "(A)")  "             (massless outgoing particle)"
    write (u, "(A)")

    E = 1
    mk = 0.3_default
    mp = mk
    mq = 0

    k = vector4_moving (E, sqrt (E**2 - mk**2), 3)
    k2 = k ** 2;  call pacify (k2, 1e-10_default)

    x = 0.6_default
    r1 = 0.5_default
    r2 = 0.125_default
    
    write (u, "(A)")  "* (1) Non-collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%sample_t (r1)
    call sd%sample_phi (r2)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t
    

    call sd%inverse_t (r1o)
    
    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)
    
    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    call sd%inverse_t (r1o)

    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)

    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* (2) Collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2, collinear = .true.)
    call sd%set_t_bounds (x, 1 - x)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_aux_2"

  end subroutine sf_aux_2
  
@ %def sf_aux_2
@ 
\subsubsection{Momentum splitting: all massless}
Compute momentum splitting for massless kinematics.  In the non-collinear
case, we need a lower cutoff for $|t|$, otherwise a logarithmic distribution
is not possible.
<<SF aux: execute tests>>=
  call test (sf_aux_3, "sf_aux_3", &
       "massless parton", &
       u, results)
<<SF aux: tests>>=
  subroutine sf_aux_3 (u)
    integer, intent(in) :: u
    type(splitting_data_t) :: sd
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q, q0
    real(default) :: E, mk, mp, mq, qmin, qmax
    real(default) :: x, r1, r2, r1o, r2o
    real(default) :: k2, q02_2, q1_2, q2_2
    
    write (u, "(A)")  "* Test output: sf_aux_3"
    write (u, "(A)")  "*   Purpose: compute momentum splitting"
    write (u, "(A)")  "             (all massless, q cuts)"
    write (u, "(A)")

    E = 1
    mk = 0
    mp = 0
    mq = 0
    qmin = 1e-2_default
    qmax = 1e0_default

    k = vector4_moving (E, sqrt (E**2 - mk**2), 3)
    k2 = k ** 2;  call pacify (k2, 1e-10_default)

    x = 0.6_default
    r1 = 0.5_default
    r2 = 0.125_default
    
    write (u, "(A)")  "* (1) Non-collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%sample_t (r1, t1 = - qmin ** 2, t0 = - qmax **2)
    call sd%sample_phi (r2)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t
    

    call sd%inverse_t (r1o, t1 = - qmin ** 2, t0 = - qmax **2)
    
    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)
    
    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    call sd%inverse_t (r1o, t1 = - qmin ** 2, t0 = - qmax **2)

    write (u, "(A)")  "Compare: r1"
    write (u, "(2(1x,F11.8))")  r1, r1o

    call sd%inverse_phi (r2o)

    write (u, "(A)")  "Compare: r2"
    write (u, "(2(1x,F11.8))")  r2, r2o

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* (2) Collinear setup"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2, collinear = .true.)
    call sd%set_t_bounds (x, 1 - x)

    call sd%write (u)
    
    q = sd%split_momentum (k)
    q1_2 = q(1) ** 2;  call pacify (q1_2, 1e-10_default)
    q2_2 = q(2) ** 2;  call pacify (q2_2, 1e-10_default)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: s"
    write (u, "(2(1x,F11.8))")  sd%s, k2
    
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  sd%t, q2_2
    
    write (u, "(A)")  "Compare: u"
    write (u, "(2(1x,F11.8))")  sd%u, q1_2
    
    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  sd%x, energy (q(2)) / energy (k)
    
    write (u, "(A)")  "Compare: 1-x"
    write (u, "(2(1x,F11.8))")  sd%xb, energy (q(1)) / energy (k)
    
    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep energy)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_ENERGY)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_ENERGY)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Project on-shell (keep momentum)"

    q0 = q
    call on_shell (q0, [mp**2, mq**2], KEEP_MOMENTUM)

    write (u, "(A)")
    write (u, "(A)")  "Incoming momentum k ="
    call vector4_write (k, u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum sum p + q ="
    call vector4_write (sum (q0), u)
    write (u, "(A)")
    write (u, "(A)")  "Radiated momentum p ="
    call vector4_write (q0(1), u)
    write (u, "(A)")
    write (u, "(A)")  "Outgoing momentum q ="
    call vector4_write (q0(2), u)
    write (u, "(A)")

    write (u, "(A)")  "Compare: mo^2"
    q02_2 = q0(2) ** 2;  call pacify (q02_2, 1e-10_default)
    write (u, "(2(1x,F11.8))")  sd%m2, q02_2
    write (u, "(A)")
    
    write (u, "(A)")  "* Recover parameters from outgoing momentum"
    write (u, "(A)")

    call sd%init (k, mk**2, mp**2, mq**2)
    call sd%set_t_bounds (x, 1 - x)
    call sd%recover (k, q0(2), KEEP_MOMENTUM)

    write (u, "(A)")  "Compare: x"
    write (u, "(2(1x,F11.8))")  x, sd%x
    write (u, "(A)")  "Compare: t"
    write (u, "(2(1x,F11.8))")  q2_2, sd%t

    write (u, "(A)")
    call sd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_aux_3"

  end subroutine sf_aux_3
  
@ %def sf_aux_3
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Mappings for structure functions}
In this module, we provide a wrapper for useful mappings of the unit
(hyper-)square that we can apply to a set of structure functions.

In some cases it is useful, or even mandatory, to map the MC input
parameters nontrivially onto a set of structure functions for the two
beams.  In all cases considered here, instead of $x_1,x_2,\ldots$ as
parameters for the beams, we generate one parameter that is equal, or
related to, the product $x_1x_2\cdots$ (so it directly corresponds to
$\sqrt{s}$).  The other parameters describe the distribution of energy
(loss) between beams and radiations.
<<[[sf_mappings.f90]]>>=
<<File header>>

module sf_mappings

<<Use kinds>>
  use kinds, only: double
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_12, FMT_13, FMT_14, FMT_15, FMT_16
  use unit_tests
  use diagnostics

<<Standard module head>>

<<SF mappings: public>>

<<SF mappings: parameters>>

<<SF mappings: types>>

<<SF mappings: interfaces>>

contains

<<SF mappings: procedures>>

<<SF mappings: tests>>

end module sf_mappings
@ %def sf_mappings
@ 
\subsection{Base type}
First, we define an abstract base type for the mapping.  In all cases
we need to store the indices of the parameters on which the mapping
applies.   Additional parameters can be stored in the extensions of
this type.
<<SF mappings: public>>=
  public :: sf_mapping_t
<<SF mappings: types>>=
  type, abstract :: sf_mapping_t
     integer, dimension(:), allocatable :: i
   contains
   <<SF mappings: sf mapping: TBP>>
  end type sf_mapping_t
     
@ %def sf_mapping_t
@ The output routine is deferred:
<<SF mappings: sf mapping: TBP>>=
  procedure (sf_mapping_write), deferred :: write
<<SF mappings: interfaces>>=
  abstract interface
     subroutine sf_mapping_write (object, unit)
       import
       class(sf_mapping_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine sf_mapping_write
  end interface

@ %def sf_mapping_write
@ Initializer for the base type.  The array of parameter indices is
allocated but initialized to zero.
<<SF mappings: sf mapping: TBP>>=
  procedure :: base_init => sf_mapping_base_init
<<SF mappings: procedures>>=
  subroutine sf_mapping_base_init (mapping, n_par)
    class(sf_mapping_t), intent(out) :: mapping
    integer, intent(in) :: n_par
    allocate (mapping%i (n_par))
    mapping%i = 0
  end subroutine sf_mapping_base_init
    
@ %def sf_mapping_base_init
@ Set an index value.
<<SF mappings: sf mapping: TBP>>=
  procedure :: set_index => sf_mapping_set_index
<<SF mappings: procedures>>=
  subroutine sf_mapping_set_index (mapping, j, i)
    class(sf_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: j, i
    mapping%i(j) = i
  end subroutine sf_mapping_set_index
    
@ %def sf_mapping_set_index
@ Return the dimensionality, i.e., the number of parameters.
<<SF mappings: sf mapping: TBP>>=
  procedure :: get_n_dim => sf_mapping_get_n_dim
<<SF mappings: procedures>>=
  function sf_mapping_get_n_dim (mapping) result (n)
    class(sf_mapping_t), intent(in) :: mapping
    integer :: n
    n = size (mapping%i)
  end function sf_mapping_get_n_dim
  
@ %def sf_mapping_get_n_dim
@ Computation: the values [[p]] are the input parameters, the values
[[r]] are the output parameters.  The values [[rb]] are defined as
$\bar r = 1 - r$, but provided explicitly.  They allow us to avoid
numerical problems near $r=1$.  

The extra parameter [[x_free]]
indicates that the total energy has already been renormalized by this
factor.  We have to take such a factor into account in a resonance or
on-shell mapping.

The Jacobian is [[f]].  We modify only
the two parameters indicated by the indices [[i]].
<<SF mappings: sf mapping: TBP>>=
  procedure (sf_mapping_compute), deferred :: compute
<<SF mappings: interfaces>>=
  abstract interface
     subroutine sf_mapping_compute (mapping, r, rb, f, p, pb, x_free)
       import
       class(sf_mapping_t), intent(inout) :: mapping
       real(default), dimension(:), intent(out) :: r, rb
       real(default), intent(out) :: f
       real(default), dimension(:), intent(in) :: p, pb
       real(default), intent(inout), optional :: x_free
     end subroutine sf_mapping_compute
  end interface
  
@ %def sf_mapping_compute
@ The inverse mapping.  Use [[r]] and/or [[rb]] to reconstruct [[p]]
and also compute [[f]].
<<SF mappings: sf mapping: TBP>>=
  procedure (sf_mapping_inverse), deferred :: inverse
<<SF mappings: interfaces>>=
  abstract interface
     subroutine sf_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
       import
       class(sf_mapping_t), intent(inout) :: mapping
       real(default), dimension(:), intent(in) :: r, rb
       real(default), intent(out) :: f
       real(default), dimension(:), intent(out) :: p, pb
       real(default), intent(inout), optional :: x_free
     end subroutine sf_mapping_inverse
  end interface
  
@ %def sf_mapping_inverse
@
\subsection{Methods for self-tests}
This is a shorthand for: inject parameters, compute the mapping,
display results, compute the inverse, display again.  We provide an
output format for the parameters and, optionally, a different output
format for the Jacobians.
<<SF mappings: sf mapping: TBP>>=
  procedure :: check => sf_mapping_check
<<SF mappings: procedures>>=
  subroutine sf_mapping_check (mapping, u, p_in, pb_in, fmt_p, fmt_f)
    class(sf_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: u
    real(default), dimension(:), intent(in) :: p_in, pb_in
    character(*), intent(in) :: fmt_p
    character(*), intent(in), optional :: fmt_f
    real(default), dimension(size(p_in)) :: p, pb, r, rb
    real(default) :: f, tolerance
    tolerance = 1.5E-17
    p = p_in
    pb= pb_in
    call mapping%compute (r, rb, f, p, pb)
    call pacify (p, tolerance)	
    call pacify (pb, tolerance)	
    call pacify (r, tolerance)	
    call pacify (rb, tolerance)	
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "p =", p
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "pb=", pb
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "r =", r
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "rb=", rb
    if (present (fmt_f)) then
       write (u, "(3x,A,9(1x," // fmt_f // "))")  "f =", f
    else
       write (u, "(3x,A,9(1x," // fmt_p // "))")  "f =", f
    end if
    write (u, *)
    call mapping%inverse (r, rb, f, p, pb)
    call pacify (p, tolerance)	
    call pacify (pb, tolerance)	
    call pacify (r, tolerance)	
    call pacify (rb, tolerance)	
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "p =", p
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "pb=", pb
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "r =", r
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "rb=", rb
    if (present (fmt_f)) then
       write (u, "(3x,A,9(1x," // fmt_f // "))")  "f =", f
    else
       write (u, "(3x,A,9(1x," // fmt_p // "))")  "f =", f
    end if
    write (u, *)
    write (u, "(3x,A,9(1x," // fmt_p // "))")  "*r=", product (r)
  end subroutine sf_mapping_check
    
@ %def sf_mapping_check
@ This is a consistency check for the self-tests: the integral over the unit
square should be unity.  We estimate this by a simple binning and adding up
the values; this should be sufficient for a self-test.

The argument is the requested number of sampling points.  We take the square
root for binning in both dimensions, so the precise number might be
different.
<<SF mappings: sf mapping: TBP>>=
  procedure :: integral => sf_mapping_integral
<<SF mappings: procedures>>=
  function sf_mapping_integral (mapping, n_calls) result (integral)
    class(sf_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: n_calls
    real(default) :: integral
    integer :: n_dim, n_bin, k
    real(default), dimension(:), allocatable :: p, pb, r, rb
    integer, dimension(:), allocatable :: ii
    real(default) :: dx, f, s

    n_dim = mapping%get_n_dim ()
    allocate (p (n_dim))
    allocate (pb(n_dim))
    allocate (r (n_dim))
    allocate (rb(n_dim))
    allocate (ii(n_dim))
    n_bin = nint (real (n_calls, default) ** (1._default / n_dim))
    dx = 1._default / n_bin
    s = 0
    ii = 1

    SAMPLE: do
       do k = 1, n_dim
          p(k)  = ii(k) * dx - dx/2
          pb(k) = (n_bin - ii(k)) * dx + dx/2
       end do
       call mapping%compute (r, rb, f, p, pb)
       s = s + f
       INCR: do k = 1, n_dim
          ii(k) = ii(k) + 1
          if (ii(k) <= n_bin) then
             exit INCR
          else if (k < n_dim) then
             ii(k) = 1
          else
             exit SAMPLE
          end if
       end do INCR
    end do SAMPLE

    integral = s / real (n_bin, default) ** n_dim

  end function sf_mapping_integral

@ %def sf_mapping_integral
@
\subsection{Implementation: standard mapping}
This maps the unit square ($r_1,r_2$) such that $p_1$ is the product $r_1r_2$,
while $p_2$ is related to the ratio.
<<SF mappings: public>>=
  public :: sf_s_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_s_mapping_t
     logical :: power_set = .false.
     real(default) :: power = 1
   contains
   <<SF mappings: sf standard mapping: TBP>>
  end type sf_s_mapping_t
  
@ %def sf_s_mapping_t
@ Output.
<<SF mappings: sf standard mapping: TBP>>=
  procedure :: write => sf_s_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_s_mapping_write (object, unit)
    class(sf_s_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A)")  ": standard (", object%power, ")"
  end subroutine sf_s_mapping_write
  
@ %def sf_s_mapping_write
@ Initialize: index pair and power parameter.
<<SF mappings: sf standard mapping: TBP>>=
  procedure :: init => sf_s_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_s_mapping_init (mapping, power)
    class(sf_s_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: power
    call mapping%base_init (2)
    if (present (power)) then
       mapping%power_set = .true.
       mapping%power = power
    end if
  end subroutine sf_s_mapping_init
    
@ %def sf_s_mapping_init
@ Apply mapping.
<<SF mappings: sf standard mapping: TBP>>=
  procedure :: compute => sf_s_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_s_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_s_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2
    integer :: j
    if (mapping%power_set) then
       call map_unit_square (r2, f, p(mapping%i), mapping%power)
    else
       call map_unit_square (r2, f, p(mapping%i))
    end if
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_s_mapping_compute

@ %def sf_s_mapping_compute
@ Apply inverse.
<<SF mappings: sf standard mapping: TBP>>=
  procedure :: inverse => sf_s_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_s_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_s_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: p2
    integer :: j
    if (mapping%power_set) then
       call map_unit_square_inverse (r(mapping%i), f, p2, mapping%power)
    else
       call map_unit_square_inverse (r(mapping%i), f, p2)
    end if
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = 1 - p2(j)
    end do
  end subroutine sf_s_mapping_inverse

@ %def sf_s_mapping_inverse
@
\subsection{Implementation: resonance pair mapping}
This maps the unit square ($r_1,r_2$) such that $p_1$ is the product $r_1r_2$,
while $p_2$ is related to the ratio, then it maps $p_1$ to itself
according to a Breit-Wigner shape, i.e., a flat prior distribution in $p_1$
results in a Breit-Wigner distribution.  Mass and width of the BW are
rescaled by the energy, thus dimensionless fractions.
<<SF mappings: public>>=
  public :: sf_res_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_res_mapping_t
     real(default) :: m = 0
     real(default) :: w = 0
   contains
   <<SF mappings: sf resonance mapping: TBP>>
  end type sf_res_mapping_t
  
@ %def sf_res_mapping_t
@ Output.
<<SF mappings: sf resonance mapping: TBP>>=
  procedure :: write => sf_res_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_res_mapping_write (object, unit)
    class(sf_res_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,', ',F7.5,A)")  ": resonance (", object%m, object%w, ")"
  end subroutine sf_res_mapping_write
  
@ %def sf_res_mapping_write
@ Initialize: index pair and dimensionless mass and width parameters.
<<SF mappings: sf resonance mapping: TBP>>=
  procedure :: init => sf_res_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_res_mapping_init (mapping, m, w)
    class(sf_res_mapping_t), intent(out) :: mapping
    real(default), intent(in) :: m, w
    call mapping%base_init (2)
    mapping%m = m
    mapping%w = w
  end subroutine sf_res_mapping_init
    
@ %def sf_res_mapping_init
@ Apply mapping.
<<SF mappings: sf resonance mapping: TBP>>=
  procedure :: compute => sf_res_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_res_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_res_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, p2
    real(default) :: fbw, f2, p1m
    integer :: j
    p2 = p(mapping%i)
    call map_breit_wigner &
         (p1m, fbw, p2(1), mapping%m, mapping%w, x_free)
    call map_unit_square (r2, f2, [p1m, p2(2)])
    f = fbw * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_res_mapping_compute

@ %def sf_res_mapping_compute
@ Apply inverse.
<<SF mappings: sf resonance mapping: TBP>>=
  procedure :: inverse => sf_res_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_res_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_res_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: p2
    real(default) :: fbw, f2, p1m
    call map_unit_square_inverse (r(mapping%i), f2, p2)
    call map_breit_wigner_inverse &
         (p2(1), fbw, p1m, mapping%m, mapping%w, x_free)
    p = r
    pb= rb
    p (mapping%i(1)) = p1m
    pb(mapping%i(1)) = 1 - p1m
    p (mapping%i(2)) = p2(2)
    pb(mapping%i(2)) = 1 - p2(2)
    f = fbw * f2
  end subroutine sf_res_mapping_inverse

@ %def sf_res_mapping_inverse
@
\subsection{Implementation: on-shell mapping}
This is a degenerate version of the unit-square mapping where the
product $r_1r_2$ is constant.  This product is given by the rescaled
squared mass.  We introduce an artificial first parameter $p_1$ to
keep the counting, but nothing depends on it.  The second parameter is
the same $p_2$ as for the standard unit-square mapping for $\alpha=1$,
it parameterizes the ratio of $r_1$ and $r_2$.
<<SF mappings: public>>=
  public :: sf_os_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_os_mapping_t
     real(default) :: m = 0
     real(default) :: lm2 = 0
   contains
   <<SF mappings: sf on-shell mapping: TBP>>
  end type sf_os_mapping_t
  
@ %def sf_os_mapping_t
@ Output.
<<SF mappings: sf on-shell mapping: TBP>>=
  procedure :: write => sf_os_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_os_mapping_write (object, unit)
    class(sf_os_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A)")  ": on-shell (", object%m, ")"
  end subroutine sf_os_mapping_write
  
@ %def sf_os_mapping_write
@ Initialize: index pair and dimensionless mass parameter.
<<SF mappings: sf on-shell mapping: TBP>>=
  procedure :: init => sf_os_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_os_mapping_init (mapping, m)
    class(sf_os_mapping_t), intent(out) :: mapping
    real(default), intent(in) :: m
    call mapping%base_init (2)
    mapping%m = m
    mapping%lm2 = abs (2 * log (mapping%m))
  end subroutine sf_os_mapping_init
    
@ %def sf_os_mapping_init
@ Apply mapping.  The [[x_free]] parameter rescales the total energy,
which must be accounted for in the enclosed mapping.
<<SF mappings: sf on-shell mapping: TBP>>=
  procedure :: compute => sf_os_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_os_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_os_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, p2
    integer :: j
    p2 = p(mapping%i)
    call map_on_shell (r2, f, p2, mapping%lm2, x_free)
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_os_mapping_compute

@ %def sf_os_mapping_compute
@ Apply inverse.  The irrelevant parameter $p_1$ is always set zero.
<<SF mappings: sf on-shell mapping: TBP>>=
  procedure :: inverse => sf_os_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_os_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_os_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: p2, r2
    r2 = r(mapping%i)
    call map_on_shell_inverse (r2, f, p2, mapping%lm2, x_free)
    p = r
    pb= rb
    p (mapping%i(1)) = p2(1)
    pb(mapping%i(1)) = 1 - p2(1)
    p (mapping%i(2)) = p2(2)
    pb(mapping%i(2)) = 1 - p2(2)
  end subroutine sf_os_mapping_inverse

@ %def sf_os_mapping_inverse
@
\subsection{Implementation: endpoint mapping}
This maps the unit square ($r_1,r_2$) such that $p_1$ is the product $r_1r_2$,
while $p_2$ is related to the ratio.  Furthermore, we enhance the
region at $r_1=1$ and $r_2=1$, which translates into $p_1=1$ and
$p_2=0,1$.  The enhancement is such that any power-like singularity is
caught.  This is useful for beamstrahlung spectra.

In addition, we allow for a delta-function singularity in $r_1$ and/or
$r_2$.  The singularity is smeared to an interval of width
$\epsilon$.  If nonzero, we distinguish the kinematical momentum
fractions $r_i$ from effective values $x_i$, which should go into the
structure-function evaluation.  A bin of width $\epsilon$ in $r$ is
mapped to $x=1$ exactly, while the interval $(0,1-\epsilon)$ is mapped
to $(0,1)$ in $x$.  The Jacobian reflects this distinction, and the
logical [[in_peak]] allows for an unambiguous distinction.

The delta-peak fraction is used only for the integration self-test.
<<SF mappings: public>>=
  public :: sf_ep_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_ep_mapping_t
     real(default) :: a = 1
   contains
   <<SF mappings: sf endpoint mapping: TBP>>
  end type sf_ep_mapping_t
  
@ %def sf_ep_mapping_t
@ Output.
<<SF mappings: sf endpoint mapping: TBP>>=
  procedure :: write => sf_ep_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_ep_mapping_write (object, unit)
    class(sf_ep_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,ES12.5,A)")  ": endpoint (a =", object%a, ")"
  end subroutine sf_ep_mapping_write
  
@ %def sf_ep_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf endpoint mapping: TBP>>=
  procedure :: init => sf_ep_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_ep_mapping_init (mapping, a)
    class(sf_ep_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: a
    call mapping%base_init (2)
    if (present (a))  mapping%a = a
  end subroutine sf_ep_mapping_init
    
@ %def sf_ep_mapping_init
@ Apply mapping.
<<SF mappings: sf endpoint mapping: TBP>>=
  procedure :: compute => sf_ep_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_ep_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_ep_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, r2
    real(default) :: f1, f2
    integer :: j
    call map_endpoint_1 (px(1), f1, p(mapping%i(1)), mapping%a)
    call map_endpoint_01 (px(2), f2, p(mapping%i(2)), mapping%a)
    call map_unit_square (r2, f, px)
    f = f * f1 * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_ep_mapping_compute

@ %def sf_ep_mapping_compute
@ Apply inverse.
<<SF mappings: sf endpoint mapping: TBP>>=
  procedure :: inverse => sf_ep_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_ep_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_ep_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, px, p2
    real(default) :: f1, f2
    integer :: j
    do j = 1, 2
       r2(j) = r(mapping%i(j))
    end do
    call map_unit_square_inverse (r2, f, px)
    call map_endpoint_inverse_1 (px(1), f1, p2(1), mapping%a)
    call map_endpoint_inverse_01 (px(2), f2, p2(2), mapping%a)
    f = f * f1 * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = 1 - p2(j)
    end do
  end subroutine sf_ep_mapping_inverse

@ %def sf_ep_mapping_inverse
@
\subsection{Implementation: endpoint mapping with resonance}
Like the endpoint mapping for $p_2$, but replace the endpoint mapping
by a Breit-Wigner mapping for $p_1$.  This covers resonance production
in the presence of beamstrahlung.

If the flag [[resonance]] is unset, we skip the resonance mapping, so
the parameter $p_1$ remains equal to $r_1r_2$, as in the standard
s-channel mapping.
<<SF mappings: public>>=
  public :: sf_epr_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_epr_mapping_t
     real(default) :: a = 1
     real(default) :: m = 0
     real(default) :: w = 0
     logical :: resonance = .true.
   contains
   <<SF mappings: sf endpoint/res mapping: TBP>>
  end type sf_epr_mapping_t
  
@ %def sf_epr_mapping_t
@ Output.
<<SF mappings: sf endpoint/res mapping: TBP>>=
  procedure :: write => sf_epr_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_epr_mapping_write (object, unit)
    class(sf_epr_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    if (object%resonance) then
       write (u, "(A,F7.5,A,F7.5,', ',F7.5,A)")  ": ep/res (a = ", object%a, &
            " | ", object%m, object%w, ")"
    else
       write (u, "(A,F7.5,A)")  ": ep/nores (a = ", object%a, ")"
    end if
  end subroutine sf_epr_mapping_write
  
@ %def sf_epr_mapping_write
@ Initialize: if mass and width are not given, we initialize a
non-resonant version of the mapping.
<<SF mappings: sf endpoint/res mapping: TBP>>=
  procedure :: init => sf_epr_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_epr_mapping_init (mapping, a, m, w)
    class(sf_epr_mapping_t), intent(out) :: mapping
    real(default), intent(in) :: a
    real(default), intent(in), optional :: m, w
    call mapping%base_init (2)
    mapping%a = a
    if (present (m) .and. present (w)) then
       mapping%m = m
       mapping%w = w
    else
       mapping%resonance = .false.
    end if
  end subroutine sf_epr_mapping_init
    
@ %def sf_epr_mapping_init
@ Apply mapping.
<<SF mappings: sf endpoint/res mapping: TBP>>=
  procedure :: compute => sf_epr_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_epr_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_epr_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, r2
    real(default) :: f1, f2
    integer :: j
    if (mapping%resonance) then
       call map_breit_wigner &
            (px(1), f1, p(mapping%i(1)), mapping%m, mapping%w, x_free)
    else
       px(1) = p(mapping%i(1))
       f1 = 1
    end if
    call map_endpoint_01 (px(2), f2, p(mapping%i(2)), mapping%a)
    call map_unit_square (r2, f, px)
    f = f * f1 * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_epr_mapping_compute

@ %def sf_epr_mapping_compute
@ Apply inverse.
<<SF mappings: sf endpoint/res mapping: TBP>>=
  procedure :: inverse => sf_epr_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_epr_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_epr_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, p2
    real(default) :: f1, f2
    integer :: j
    call map_unit_square_inverse (r(mapping%i), f, px)
    if (mapping%resonance) then
       call map_breit_wigner_inverse &
            (px(1), f1, p2(1), mapping%m, mapping%w, x_free)
    else
       p2(1) = px(1)
       f1 = 1
    end if
    call map_endpoint_inverse_01 (px(2), f2, p2(2), mapping%a)
    f = f * f1 * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = 1 - p2(j)
    end do
  end subroutine sf_epr_mapping_inverse

@ %def sf_epr_mapping_inverse
@
\subsection{Implementation: endpoint mapping for on-shell particle}
Analogous to the resonance mapping, but the $p_1$ input is ignored
altogether.  This covers on-shell particle production
in the presence of beamstrahlung.
<<SF mappings: public>>=
  public :: sf_epo_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_epo_mapping_t
     real(default) :: a = 1
     real(default) :: m = 0
     real(default) :: lm2 = 0
   contains
   <<SF mappings: sf endpoint/os mapping: TBP>>
  end type sf_epo_mapping_t
  
@ %def sf_epo_mapping_t
@ Output.
<<SF mappings: sf endpoint/os mapping: TBP>>=
  procedure :: write => sf_epo_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_epo_mapping_write (object, unit)
    class(sf_epo_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A,F7.5,A)")  ": ep/on-shell (a = ", object%a, &
         " | ", object%m, ")"
  end subroutine sf_epo_mapping_write
  
@ %def sf_epo_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf endpoint/os mapping: TBP>>=
  procedure :: init => sf_epo_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_epo_mapping_init (mapping, a, m)
    class(sf_epo_mapping_t), intent(out) :: mapping
    real(default), intent(in) :: a, m
    call mapping%base_init (2)
    mapping%a = a
    mapping%m = m
    mapping%lm2 = abs (2 * log (mapping%m))
  end subroutine sf_epo_mapping_init
    
@ %def sf_epo_mapping_init
@ Apply mapping.
<<SF mappings: sf endpoint/os mapping: TBP>>=
  procedure :: compute => sf_epo_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_epo_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_epo_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, r2
    real(default) :: f2
    integer :: j
    px(1) = 0
    call map_endpoint_01 (px(2), f2, p(mapping%i(2)), mapping%a)
    call map_on_shell (r2, f, px, mapping%lm2)
    f = f * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2(j)
       rb(mapping%i(j)) = 1 - r2(j)
    end do
  end subroutine sf_epo_mapping_compute

@ %def sf_epo_mapping_compute
@ Apply inverse.
<<SF mappings: sf endpoint/os mapping: TBP>>=
  procedure :: inverse => sf_epo_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_epo_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_epo_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, p2
    real(default) :: f2
    integer :: j
    call map_on_shell_inverse (r(mapping%i), f, px, mapping%lm2)
    p2(1) = 0
    call map_endpoint_inverse_01 (px(2), f2, p2(2), mapping%a)
    f = f * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = 1 - p2(j)
    end do
  end subroutine sf_epo_mapping_inverse

@ %def sf_epo_mapping_inverse
@
\subsection{Implementation: ISR endpoint mapping}
Similar to the endpoint mapping above: This maps the unit square
($r_1,r_2$) such that $p_1$ is the product $r_1r_2$, while $p_2$ is
related to the ratio.  Furthermore, we enhance the region at $r_1=1$
and $r_2=1$, which translates into $p_1=1$ and $p_2=0,1$.  

The enhancement is such that ISR singularity $(1-x)^{-1+\epsilon}$ is
flattened.  This would be easy in one dimension, but becomes
nontrivial in two dimensions.
<<SF mappings: public>>=
  public :: sf_ip_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_ip_mapping_t
     real(default) :: eps = 0
   contains
   <<SF mappings: sf power mapping: TBP>>
  end type sf_ip_mapping_t
  
@ %def sf_ip_mapping_t
@ Output.
<<SF mappings: sf power mapping: TBP>>=
  procedure :: write => sf_ip_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_ip_mapping_write (object, unit)
    class(sf_ip_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,ES12.5,A)")  ": isr (eps =", object%eps, ")"
  end subroutine sf_ip_mapping_write
  
@ %def sf_ip_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf power mapping: TBP>>=
  procedure :: init => sf_ip_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_ip_mapping_init (mapping, eps)
    class(sf_ip_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: eps
    call mapping%base_init (2)
    if (present (eps))  mapping%eps = eps
    if (mapping%eps <= 0) &
         call msg_fatal ("ISR mapping: regulator epsilon must not be zero")
  end subroutine sf_ip_mapping_init
    
@ %def sf_ip_mapping_init
@ Apply mapping.
<<SF mappings: sf power mapping: TBP>>=
  procedure :: compute => sf_ip_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_ip_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_ip_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, pxb, r2, r2b
    real(default) :: f1, f2, xb, y, yb
    integer :: j
    call map_power_1 (xb, f1, pb(mapping%i(1)), 2 * mapping%eps)
    call map_power_01 (y, yb, f2, pb(mapping%i(2)), mapping%eps)
    px(1)  = 1 - xb
    pxb(1) = xb
    px(2)  = y
    pxb(2) = yb
    call map_unit_square_prec (r2, r2b, f, px, pxb)
    f = f * f1 * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2 (j)
       rb(mapping%i(j)) = r2b(j)
    end do
  end subroutine sf_ip_mapping_compute

@ %def sf_ip_mapping_compute
@ Apply inverse.
<<SF mappings: sf power mapping: TBP>>=
  procedure :: inverse => sf_ip_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_ip_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_ip_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, r2b, px, pxb, p2, p2b
    real(default) :: f1, f2, xb, y, yb
    integer :: j
    do j = 1, 2
       r2 (j) = r (mapping%i(j))
       r2b(j) = rb(mapping%i(j))
    end do
    call map_unit_square_inverse_prec (r2, r2b, f, px, pxb)
    xb = pxb(1)
    if (px(1) > 0) then
       y  = px(2)
       yb = pxb(2)
    else
       y  = 0.5_default
       yb = 0.5_default
    end if
    call map_power_inverse_1 (xb, f1, p2b(1), 2 * mapping%eps)
    call map_power_inverse_01 (y, yb, f2, p2b(2), mapping%eps)
    p2 = 1 - p2b
    f = f * f1 * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = p2b(j)
    end do
  end subroutine sf_ip_mapping_inverse

@ %def sf_ip_mapping_inverse
@
\subsection{Implementation: ISR endpoint mapping, resonant}
Similar to the endpoint mapping above: This maps the unit square
($r_1,r_2$) such that $p_1$ is the product $r_1r_2$, while $p_2$ is
related to the ratio.  Furthermore, we enhance the region at $r_1=1$
and $r_2=1$, which translates into $p_1=1$ and $p_2=0,1$.  

The enhancement is such that ISR singularity $(1-x)^{-1+\epsilon}$ is
flattened.  This would be easy in one dimension, but becomes
nontrivial in two dimensions.

The resonance can be turned off by the flag [[resonance]].
<<SF mappings: public>>=
  public :: sf_ipr_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_ipr_mapping_t
     real(default) :: eps = 0
     real(default) :: m = 0
     real(default) :: w = 0
     logical :: resonance = .true.
   contains
   <<SF mappings: sf power/res mapping: TBP>>
  end type sf_ipr_mapping_t
  
@ %def sf_ipr_mapping_t
@ Output.
<<SF mappings: sf power/res mapping: TBP>>=
  procedure :: write => sf_ipr_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_ipr_mapping_write (object, unit)
    class(sf_ipr_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    if (object%resonance) then
       write (u, "(A,F7.5,A,F7.5,', ',F7.5,A)")  ": isr/res (eps = ", &
            object%eps, " | ", object%m, object%w, ")"
    else
       write (u, "(A,F7.5,A)")  ": isr/res (eps = ", object%eps, ")"
    end if
  end subroutine sf_ipr_mapping_write
  
@ %def sf_ipr_mapping_write
@ Initialize:
<<SF mappings: sf power/res mapping: TBP>>=
  procedure :: init => sf_ipr_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_ipr_mapping_init (mapping, eps, m, w)
    class(sf_ipr_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: eps, m, w
    call mapping%base_init (2)
    if (present (eps))  mapping%eps = eps
    if (mapping%eps <= 0) &
         call msg_fatal ("ISR mapping: regulator epsilon must not be zero")
    if (present (m) .and. present (w)) then
       mapping%m = m
       mapping%w = w
    else
       mapping%resonance = .false.
    end if
  end subroutine sf_ipr_mapping_init
    
@ %def sf_ipr_mapping_init
@ Apply mapping.
<<SF mappings: sf power/res mapping: TBP>>=
  procedure :: compute => sf_ipr_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_ipr_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_ipr_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, pxb, r2, r2b
    real(default) :: f1, f2, y, yb
    integer :: j
    if (mapping%resonance) then
       call map_breit_wigner &
            (px(1), f1, p(mapping%i(1)), mapping%m, mapping%w, x_free)
    else
       px(1) = p(mapping%i(1))
       f1 = 1
    end if
    call map_power_01 (y, yb, f2, pb(mapping%i(2)), mapping%eps)
    pxb(1) = 1 - px(1)
    px(2)  = y
    pxb(2) = yb
    call map_unit_square_prec (r2, r2b, f, px, pxb)
    f = f * f1 * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2 (j)
       rb(mapping%i(j)) = r2b(j)
    end do
  end subroutine sf_ipr_mapping_compute

@ %def sf_ipr_mapping_compute
@ Apply inverse.
<<SF mappings: sf power/res mapping: TBP>>=
  procedure :: inverse => sf_ipr_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_ipr_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_ipr_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, r2b, px, pxb, p2, p2b
    real(default) :: f1, f2, y, yb
    integer :: j
    do j = 1, 2
       r2 (j) = r (mapping%i(j))
       r2b(j) = rb(mapping%i(j))
    end do
    call map_unit_square_inverse_prec (r2, r2b, f, px, pxb)
    if (px(1) > 0) then
       y  = px(2)
       yb = pxb(2)
    else
       y  = 0.5_default
       yb = 0.5_default
    end if
    if (mapping%resonance) then
       call map_breit_wigner_inverse &
            (px(1), f1, p2(1), mapping%m, mapping%w, x_free)
    else
       p2(1) = px(1)
       f1 = 1
    end if
    call map_power_inverse_01 (y, yb, f2, p2b(2), mapping%eps)
    p2b(1) = 1 - p2(1)
    p2 (2) = 1 - p2b(2)
    f = f * f1 * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = p2b(j)
    end do
  end subroutine sf_ipr_mapping_inverse

@ %def sf_ipr_mapping_inverse
@
\subsection{Implementation: ISR on-shell mapping}
Similar to the endpoint mapping above: This maps the unit square
($r_1,r_2$) such that $p_1$ is ignored while the product $r_1r_2$ is
constant.  $p_2$ is related to the ratio.  Furthermore, we enhance the
region at $r_1=1$ and $r_2=1$, which translates into $p_1=1$ and
$p_2=0,1$.

The enhancement is such that ISR singularity $(1-x)^{-1+\epsilon}$ is
flattened.  This would be easy in one dimension, but becomes
nontrivial in two dimensions.
<<SF mappings: public>>=
  public :: sf_ipo_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_ipo_mapping_t
     real(default) :: eps = 0
     real(default) :: m = 0
   contains
   <<SF mappings: sf power/os mapping: TBP>>
  end type sf_ipo_mapping_t
  
@ %def sf_ipo_mapping_t
@ Output.
<<SF mappings: sf power/os mapping: TBP>>=
  procedure :: write => sf_ipo_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_ipo_mapping_write (object, unit)
    class(sf_ipo_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,',',I0,')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A,F7.5,A)")  ": isr/os (eps = ", object%eps, &
         " | ", object%m, ")"
  end subroutine sf_ipo_mapping_write
  
@ %def sf_ipo_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf power/os mapping: TBP>>=
  procedure :: init => sf_ipo_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_ipo_mapping_init (mapping, eps, m)
    class(sf_ipo_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: eps, m
    call mapping%base_init (2)
    if (present (eps))  mapping%eps = eps
    if (mapping%eps <= 0) &
         call msg_fatal ("ISR mapping: regulator epsilon must not be zero")
    mapping%m = m
  end subroutine sf_ipo_mapping_init
    
@ %def sf_ipo_mapping_init
@ Apply mapping.
<<SF mappings: sf power/os mapping: TBP>>=
  procedure :: compute => sf_ipo_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_ipo_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_ipo_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: px, pxb, r2, r2b
    real(default) :: f1, f2, y, yb
    integer :: j
    call map_power_01 (y, yb, f2, pb(mapping%i(2)), mapping%eps)
    px(1)  = mapping%m ** 2
    if (present (x_free))  px(1) = px(1) / x_free
    pxb(1) = 1 - px(1)
    px(2)  = y
    pxb(2) = yb
    call map_unit_square_prec (r2, r2b, f1, px, pxb)
    f = f1 * f2
    r = p
    rb= pb
    do j = 1, 2
       r (mapping%i(j)) = r2 (j)
       rb(mapping%i(j)) = r2b(j)
    end do
  end subroutine sf_ipo_mapping_compute

@ %def sf_ipo_mapping_compute
@ Apply inverse.
<<SF mappings: sf power/os mapping: TBP>>=
  procedure :: inverse => sf_ipo_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_ipo_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_ipo_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(2) :: r2, r2b, px, pxb, p2, p2b
    real(default) :: f1, f2, y, yb
    integer :: j
    do j = 1, 2
       r2 (j) = r (mapping%i(j))
       r2b(j) = rb(mapping%i(j))
    end do
    call map_unit_square_inverse_prec (r2, r2b, f1, px, pxb)
    y  = px(2)
    yb = pxb(2)
    call map_power_inverse_01 (y, yb, f2, p2b(2), mapping%eps)
    p2(1) = 0
    p2b(1)= 1
    p2(2) = 1 - p2b(2)
    f = f1 * f2
    p = r
    pb= rb
    do j = 1, 2
       p (mapping%i(j)) = p2(j)
       pb(mapping%i(j)) = p2b(j)
    end do
  end subroutine sf_ipo_mapping_inverse

@ %def sf_ipo_mapping_inverse
@
\subsection{Implementation: Endpoint + ISR power mapping}
This is a combination of endpoint (i.e., beamstrahlung) and ISR power
mapping.  The first two parameters apply to the beamstrahlung
spectrum, the last two to the ISR function for the first and second
beam, respectively.
<<SF mappings: public>>=
  public :: sf_ei_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_ei_mapping_t
     type(sf_ep_mapping_t) :: ep
     type(sf_ip_mapping_t) :: ip
   contains
   <<SF mappings: sf ep-ip mapping: TBP>>
  end type sf_ei_mapping_t
  
@ %def sf_ei_mapping_t
@ Output.
<<SF mappings: sf ep-ip mapping: TBP>>=
  procedure :: write => sf_ei_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_ei_mapping_write (object, unit)
    class(sf_ei_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,3(',',I0),')')", advance="no")  object%i
    end if
    write (u, "(A,ES12.5,A,ES12.5,A)")  ": ep/isr (a =", object%ep%a, &
         ", eps =", object%ip%eps, ")"
  end subroutine sf_ei_mapping_write
  
@ %def sf_ei_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf ep-ip mapping: TBP>>=
  procedure :: init => sf_ei_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_ei_mapping_init (mapping, a, eps)
    class(sf_ei_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: a, eps
    call mapping%base_init (4)
    call mapping%ep%init (a)
    call mapping%ip%init (eps)
  end subroutine sf_ei_mapping_init
    
@ %def sf_ei_mapping_init
@ Set an index value.  We should communicate the appropriate indices to the
enclosed sub-mappings, therefore override the method.
<<SF mappings: sf ep-ip mapping: TBP>>=
  procedure :: set_index => sf_ei_mapping_set_index
<<SF mappings: procedures>>=
  subroutine sf_ei_mapping_set_index (mapping, j, i)
    class(sf_ei_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: j, i
    mapping%i(j) = i
    select case (j)
    case (1:2);  call mapping%ep%set_index (j, i)
    case (3:4);  call mapping%ip%set_index (j-2, i)
    end select
  end subroutine sf_ei_mapping_set_index
    
@ %def sf_mapping_set_index
@ Apply mapping.  Now, the beamstrahlung and ISR mappings are
independent of each other.  The parameter subsets that are actually
used should not overlap.  The Jacobians are multiplied.
<<SF mappings: sf ep-ip mapping: TBP>>=
  procedure :: compute => sf_ei_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_ei_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_ei_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: q, qb
    real(default) :: f1, f2
    call mapping%ep%compute (q, qb, f1, p, pb, x_free)
    call mapping%ip%compute (r, rb, f2, q, qb, x_free)
    f = f1 * f2
  end subroutine sf_ei_mapping_compute

@ %def sf_ei_mapping_compute
@ Apply inverse.
<<SF mappings: sf ep-ip mapping: TBP>>=
  procedure :: inverse => sf_ei_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_ei_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_ei_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: q, qb
    real(default) :: f1, f2
    call mapping%ip%inverse (r, rb, f2, q, qb, x_free)
    call mapping%ep%inverse (q, qb, f1, p, pb, x_free)
    f = f1 * f2
  end subroutine sf_ei_mapping_inverse

@ %def sf_ei_mapping_inverse
@
\subsection{Implementation: Endpoint + ISR + resonance}
This is a combination of endpoint (i.e., beamstrahlung) and ISR power
mapping, adapted for an s-channel resonance.  The first two internal
parameters apply to the beamstrahlung spectrum, the last two to the
ISR function for the first and second beam, respectively.  The first
and third parameters are the result of an overall resonance mapping,
so on the outside, the first parameter is the total momentum fraction,
the third one describes the distribution between beamstrahlung and ISR.
<<SF mappings: public>>=
  public :: sf_eir_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_eir_mapping_t
     type(sf_res_mapping_t) :: res
     type(sf_epr_mapping_t) :: ep
     type(sf_ipr_mapping_t) :: ip
   contains
   <<SF mappings: sf ep-ip-res mapping: TBP>>
  end type sf_eir_mapping_t
  
@ %def sf_eir_mapping_t
@ Output.
<<SF mappings: sf ep-ip-res mapping: TBP>>=
  procedure :: write => sf_eir_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_eir_mapping_write (object, unit)
    class(sf_eir_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,3(',',I0),')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A,F7.5,A,F7.5,', ',F7.5,A)")  &
         ": ep/isr/res (a =", object%ep%a, &
         ", eps =", object%ip%eps, " | ", object%res%m, object%res%w, ")"
  end subroutine sf_eir_mapping_write
  
@ %def sf_eir_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf ep-ip-res mapping: TBP>>=
  procedure :: init => sf_eir_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_eir_mapping_init (mapping, a, eps, m, w)
    class(sf_eir_mapping_t), intent(out) :: mapping
    real(default), intent(in) :: a, eps, m, w
    call mapping%base_init (4)
    call mapping%res%init (m, w)
    call mapping%ep%init (a)
    call mapping%ip%init (eps)
  end subroutine sf_eir_mapping_init
    
@ %def sf_eir_mapping_init
@ Set an index value.  We should communicate the appropriate indices to the
enclosed sub-mappings, therefore override the method.
<<SF mappings: sf ep-ip-res mapping: TBP>>=
  procedure :: set_index => sf_eir_mapping_set_index
<<SF mappings: procedures>>=
  subroutine sf_eir_mapping_set_index (mapping, j, i)
    class(sf_eir_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: j, i
    mapping%i(j) = i
    select case (j)
    case (1);  call mapping%res%set_index (1, i)
    case (3);  call mapping%res%set_index (2, i)
    end select
    select case (j)
    case (1:2);  call mapping%ep%set_index (j, i)
    case (3:4);  call mapping%ip%set_index (j-2, i)
    end select
  end subroutine sf_eir_mapping_set_index
    
@ %def sf_mapping_set_index
@ Apply mapping.  Now, the beamstrahlung and ISR mappings are
independent of each other.  The parameter subsets that are actually
used should not overlap.  The Jacobians are multiplied.
<<SF mappings: sf ep-ip-res mapping: TBP>>=
  procedure :: compute => sf_eir_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_eir_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_eir_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: px, pxb, q, qb
    real(default) :: f0, f1, f2
    call mapping%res%compute (px, pxb, f0, p, pb, x_free)
    call mapping%ep%compute (q, qb, f1, px, pxb, x_free)
    call mapping%ip%compute (r, rb, f2, q, qb, x_free)
    f = f0 * f1 * f2
  end subroutine sf_eir_mapping_compute

@ %def sf_eir_mapping_compute
@ Apply inverse.
<<SF mappings: sf ep-ip-res mapping: TBP>>=
  procedure :: inverse => sf_eir_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_eir_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_eir_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: px, pxb, q, qb
    real(default) :: f0, f1, f2
    call mapping%ip%inverse (r, rb, f2, q, qb, x_free)
    call mapping%ep%inverse (q, qb, f1, px, pxb, x_free)
    call mapping%res%inverse (px, pxb, f0, p, pb, x_free)
    f = f0 * f1 * f2
  end subroutine sf_eir_mapping_inverse

@ %def sf_eir_mapping_inverse
@
\subsection{Implementation: Endpoint + ISR power mapping, on-shell}
This is a combination of endpoint (i.e., beamstrahlung) and ISR power
mapping.  The first two parameters apply to the beamstrahlung
spectrum, the last two to the ISR function for the first and second
beam, respectively.  On top of that, we map the first and third parameter
such that the product is constant.  From the outside, the first
parameter is irrelevant while the third parameter describes the
distribution of energy (loss) among beamstrahlung and ISR.
<<SF mappings: public>>=
  public :: sf_eio_mapping_t
<<SF mappings: types>>=
  type, extends (sf_mapping_t) :: sf_eio_mapping_t
     type(sf_os_mapping_t) :: os
     type(sf_epr_mapping_t) :: ep
     type(sf_ipr_mapping_t) :: ip
   contains
   <<SF mappings: sf ep-ip-os mapping: TBP>>
  end type sf_eio_mapping_t
  
@ %def sf_eio_mapping_t
@ Output.
<<SF mappings: sf ep-ip-os mapping: TBP>>=
  procedure :: write => sf_eio_mapping_write
<<SF mappings: procedures>>=
  subroutine sf_eio_mapping_write (object, unit)
    class(sf_eio_mapping_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "map"
    if (any (object%i /= 0)) then
       write (u, "('(',I0,3(',',I0),')')", advance="no")  object%i
    end if
    write (u, "(A,F7.5,A,F7.5,A,F7.5,A)")  ": ep/isr/os (a =", object%ep%a, &
         ", eps =", object%ip%eps, " | ", object%os%m, ")"
  end subroutine sf_eio_mapping_write
  
@ %def sf_eio_mapping_write
@ Initialize: no extra parameters.
<<SF mappings: sf ep-ip-os mapping: TBP>>=
  procedure :: init => sf_eio_mapping_init
<<SF mappings: procedures>>=
  subroutine sf_eio_mapping_init (mapping, a, eps, m)
    class(sf_eio_mapping_t), intent(out) :: mapping
    real(default), intent(in), optional :: a, eps, m
    call mapping%base_init (4)
    call mapping%os%init (m)
    call mapping%ep%init (a)
    call mapping%ip%init (eps)
  end subroutine sf_eio_mapping_init
    
@ %def sf_eio_mapping_init
@ Set an index value.  We should communicate the appropriate indices to the
enclosed sub-mappings, therefore override the method.
<<SF mappings: sf ep-ip-os mapping: TBP>>=
  procedure :: set_index => sf_eio_mapping_set_index
<<SF mappings: procedures>>=
  subroutine sf_eio_mapping_set_index (mapping, j, i)
    class(sf_eio_mapping_t), intent(inout) :: mapping
    integer, intent(in) :: j, i
    mapping%i(j) = i
    select case (j)
    case (1);  call mapping%os%set_index (1, i)
    case (3);  call mapping%os%set_index (2, i)
    end select
    select case (j)
    case (1:2);  call mapping%ep%set_index (j, i)
    case (3:4);  call mapping%ip%set_index (j-2, i)
    end select
  end subroutine sf_eio_mapping_set_index
    
@ %def sf_mapping_set_index
@ Apply mapping.  Now, the beamstrahlung and ISR mappings are
independent of each other.  The parameter subsets that are actually
used should not overlap.  The Jacobians are multiplied.
<<SF mappings: sf ep-ip-os mapping: TBP>>=
  procedure :: compute => sf_eio_mapping_compute
<<SF mappings: procedures>>=
  subroutine sf_eio_mapping_compute (mapping, r, rb, f, p, pb, x_free)
    class(sf_eio_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: px, pxb, q, qb
    real(default) :: f0, f1, f2
    call mapping%os%compute (px, pxb, f0, p, pb, x_free)
    call mapping%ep%compute (q, qb, f1, px, pxb, x_free)
    call mapping%ip%compute (r, rb, f2, q, qb, x_free)
    f = f0 * f1 * f2
  end subroutine sf_eio_mapping_compute

@ %def sf_eio_mapping_compute
@ Apply inverse.
<<SF mappings: sf ep-ip-os mapping: TBP>>=
  procedure :: inverse => sf_eio_mapping_inverse
<<SF mappings: procedures>>=
  subroutine sf_eio_mapping_inverse (mapping, r, rb, f, p, pb, x_free)
    class(sf_eio_mapping_t), intent(inout) :: mapping
    real(default), dimension(:), intent(in) :: r, rb
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: p, pb
    real(default), intent(inout), optional :: x_free
    real(default), dimension(size(p)) :: px, pxb, q, qb
    real(default) :: f0, f1, f2
    call mapping%ip%inverse (r, rb, f2, q, qb, x_free)
    call mapping%ep%inverse (q, qb, f1, px, pxb, x_free)
    call mapping%os%inverse (px, pxb, f0, p, pb, x_free)
    f = f0 * f1 * f2
  end subroutine sf_eio_mapping_inverse

@ %def sf_eio_mapping_inverse
@
\subsection{Basic formulas}
\subsubsection{Standard mapping of the unit square}
This mapping of the unit square is appropriate in particular for
structure functions which are concentrated at the lower end.  Instead
of a rectangular grid, one set of grid lines corresponds to constant
parton c.m. energy.  The other set is chosen such that the jacobian is
only mildly singular ($\ln x$ which is zero at $x=1$), corresponding
to an initial concentration of sampling points at the maximum energy.
If [[power]] is greater than one (the default), points are also
concentrated at the lower end.

The formula is ([[power]]=$\alpha$):
\begin{align}
  r_1 &= (p_1 ^ {p_2})^\alpha \\
  r_2 &= (p_1 ^ {1 - p_2})^\alpha\\
  f   &= \alpha^2 p_1 ^ {\alpha - 1} |\log p_1|
\end{align}
and for the default case $\alpha=1$:
\begin{align}
  r_1 &= p_1 ^ {p_2} \\
  r_2 &= p_1 ^ {1 - p_2} \\
  f   &= |\log p_1|
\end{align}
<<SF mappings: procedures>>=
  subroutine map_unit_square (r, factor, p, power)
    real(default), dimension(2), intent(out) :: r
    real(default), intent(out) :: factor
    real(default), dimension(2), intent(in) :: p
    real(default), intent(in), optional :: power
    real(default) :: xx, yy
    factor = 1
    xx = p(1)
    yy = p(2)
    if (present(power)) then
       if (p(1) > 0 .and. power > 1) then
          xx = p(1)**power
          factor = factor * power * xx / p(1)
       end if
    end if
    if (xx /= 0) then
       r(1) = xx ** yy
       r(2) = xx / r(1)
       factor = factor * abs (log (xx))
    else
       r = 0
    end if
  end subroutine map_unit_square

@ %def map_unit_square
@ This is the inverse mapping.
<<SF mappings: procedures>>=
  subroutine map_unit_square_inverse (r, factor, p, power)
    real(kind=default), dimension(2), intent(in) :: r
    real(kind=default), intent(out) :: factor
    real(kind=default), dimension(2), intent(out) :: p
    real(kind=default), intent(in), optional :: power
    real(kind=default) :: lg, xx, yy
    factor = 1
    xx = r(1) * r(2)
    if (xx /= 0) then
       lg = log (xx)
       if (lg /= 0) then
          yy = log (r(1)) / lg
       else
          yy = 0
       end if
       p(2) = yy
       factor = factor * abs (lg)
       if (present(power)) then
          p(1) = xx**(1._default/power)
          factor = factor * power * xx / p(1)
       else
          p(1) = xx
       end if
    else
       p = 0
    end if
  end subroutine map_unit_square_inverse

@ %def map_unit_square_inverse
@ 
\subsubsection{Precise mapping of the unit square}
A more precise version (with unit power parameter).  This version
should be numerically stable near $x=1$ and $y=0,1$.  The formulas are again
\begin{equation}
  r_1 = p_1^{p_2}, \qquad
  r_2 = p_1^{\bar p_2}, \qquad
  f = - \log p_1
\end{equation}
but we compute both $r_i$ and $\bar r_i$ simultaneously and make
direct use of both $p_i$ and $\bar p_i$ as appropriate.
<<SF mappings: procedures>>=
  subroutine map_unit_square_prec (r, rb, factor, p, pb)
    real(default), dimension(2), intent(out) :: r
    real(default), dimension(2), intent(out) :: rb
    real(default), intent(out) :: factor
    real(default), dimension(2), intent(in) :: p
    real(default), dimension(2), intent(in) :: pb
    if (p(1) > 0.5_default) then
       call compute_prec_xy_1 (r(1), rb(1), p(1), pb(1), p (2))
       call compute_prec_xy_1 (r(2), rb(2), p(1), pb(1), pb(2))
       factor = - log_prec (p(1), pb(1))
    else if (p(1) > 0) then
       call compute_prec_xy_0 (r(1), rb(1), p(1), pb(1), p (2))
       call compute_prec_xy_0 (r(2), rb(2), p(1), pb(1), pb(2))
       factor = - log_prec (p(1), pb(1))
    else
       r  = 0
       rb = 1
       factor = 0
    end if
  end subroutine map_unit_square_prec

@ %def map_unit_square_prec
@ This is the inverse mapping.
<<SF mappings: procedures>>=
  subroutine map_unit_square_inverse_prec (r, rb, factor, p, pb)
    real(default), dimension(2), intent(in) :: r
    real(default), dimension(2), intent(in) :: rb
    real(default), intent(out) :: factor
    real(default), dimension(2), intent(out) :: p
    real(default), dimension(2), intent(out) :: pb
    call inverse_prec_x (r, rb, p(1), pb(1))
    if (all (r > 0)) then
       if (rb(1) < rb(2)) then
          call inverse_prec_y (r, rb, p(2), pb(2))
       else
          call inverse_prec_y ([r(2),r(1)], [rb(2),rb(1)], pb(2), p(2))
       end if
       factor = - log_prec (p(1), pb(1))
    else
       p(1)  = 0
       pb(1) = 1
       p(2)  = 0.5_default
       pb(2) = 0.5_default
       factor = 0
    end if
  end subroutine map_unit_square_inverse_prec

@ %def map_unit_square_prec_inverse
@ This is an auxiliary function: evaluate the expression $\bar z = 1 -
x^y$ in a numerically stable way.  Instabilities occur for $y=0$ and
$x=1$.  The idea is to replace the bracket by the first terms of its
Taylor expansion around $x=1$ (read $\bar x\equiv 1 -x$)
\begin{equation}
  1 - x^y = y\bar x\left(1 + \frac12(1-y)\bar x +
    \frac16(2-y)(1-y)\bar x^2\right)
\end{equation}
whenever this is the better approximation.  Actually, the relative
numerical error of the exact formula is about $\eta/(y\bar x)$ where
$\eta$ is given by [[epsilon(KIND)]] in Fortran.  The relative error
of the approximation is better than the last included term divided by
$(y\bar x)$.

The first subroutine computes $z$ and $\bar z$ near $x=1$ where $\log
x$ should be expanded, the second one near $x=0$ where $\log x$ can be
kept.
<<SF mappings: procedures>>=
  subroutine compute_prec_xy_1 (z, zb, x, xb, y)
    real(default), intent(out) :: z, zb
    real(default), intent(in) :: x, xb, y
    real(default) :: a1, a2, a3
    a1 = y * xb
    a2 = a1 * (1 - y) * xb / 2
    a3 = a2 * (2 - y) * xb / 3
    if (abs (a3) < epsilon (a3)) then
       zb = a1 + a2 + a3
       z = 1 - zb
    else
       z = x ** y
       zb = 1 - z
    end if
  end subroutine compute_prec_xy_1
   
  subroutine compute_prec_xy_0 (z, zb, x, xb, y)
    real(default), intent(out) :: z, zb
    real(default), intent(in) :: x, xb, y
    real(default) :: a1, a2, a3, lx
    lx = -log (x)
    a1 = y * lx
    a2 = a1 * y * lx / 2
    a3 = a2 * y * lx / 3
    if (abs (a3) < epsilon (a3)) then
       zb = a1 + a2 + a3
       z = 1 - zb
    else
       z = x ** y
       zb = 1 - z
    end if
  end subroutine compute_prec_xy_0
   
@ %def compute_prec_xy_1
@ %def compute_prec_xy_0
@ For the inverse calculation, we evaluate $x=r_1r_2$ in a stable way.
Since it is just a polynomial, the expansion near $x=1$ is
analytically exact, and we don't need to choose based on precision.
<<SF mappings: procedures>>=
  subroutine inverse_prec_x (r, rb, x, xb)
    real(default), dimension(2), intent(in) :: r, rb
    real(default), intent(out) :: x, xb
    real(default) :: a0, a1
    a0 = rb(1) + rb(2)
    a1 = rb(1) * rb(2)
    if (a0 > 0.5_default) then
       xb = a0 - a1
       x = 1 - xb
    else
       x = r(1) * r(2)
       xb = 1 - x
    end if
  end subroutine inverse_prec_x
    
@ %def inverse_prec_x
@ The inverse calculation for the relative momentum fraction
\begin{equation}
  y = \frac{1}{1 + \frac{\log{r_2}}{\log{r_1}}}
\end{equation}
is slightly more complicated.  We should take the precise form of the
logarithm, so we are safe near $r_i=1$.  A series expansion is
required if $r_1\ll r_2$, since then $y$ becomes small.  (We assume
$r_1<r_2$ here; for the opposite case, the arguments can be
exchanged.)
<<SF mappings: procedures>>=
  subroutine inverse_prec_y (r, rb, y, yb)
    real(default), dimension(2), intent(in) :: r, rb
    real(default), intent(out) :: y, yb
    real(default) :: log1, log2, a1, a2, a3
    log1 = log_prec (r(1), rb(1))
    log2 = log_prec (r(2), rb(2))
    a1 = - rb(1) / log2
    a2 = - rb(1) ** 2 * (1 / log2**2 + 1 / (2 * log2))
    a3 = - rb(1) ** 3 * (1 / log2**3 + 1 / log2**2 + 1 / (3 * log2))
    if (abs (a3) < epsilon (a3)) then
       y  = a1 + a2 + a3
       yb = 1 - y
    else
       y  = 1 / (1 + log2/log1)
       yb = 1 / (1 + log1/log2)
    end if
  end subroutine inverse_prec_y
  
@ %def inverse_prec_y
@ We also need an evaluation of $\log x$ which is stable near $x=1$.
<<SF mappings: public>>=
  public :: log_prec
<<SF mappings: procedures>>=
  function log_prec (x, xb) result (lx)
    real(default), intent(in) :: x, xb
    real(default) :: a1, a2, a3, lx
    a1 = xb
    a2 = a1 * xb / 2
    a3 = a2 * xb * 2 / 3
    if (abs (a3) < epsilon (a3)) then
       lx = - a1 - a2 - a3
    else
       lx = log (x)
    end if
  end function log_prec
  
@ %def log_prec
@ 
\subsubsection{Mapping for on-shell s-channel}
The limiting case, if the product $r_1r_2$ is fixed for on-shell
production.  The parameter $p_1$ is ignored.  In the inverse mapping,
it is returned zero.

The parameter [[x_free]], if present, rescales the total energy.  If
it is less than one, the rescaled mass parameter $m^2$ should be increased
accordingly.
<<SF mappings: procedures>>=
  subroutine map_on_shell (r, factor, p, lm2, x_free)
    real(default), dimension(2), intent(out) :: r
    real(default), intent(out) :: factor
    real(default), dimension(2), intent(in) :: p
    real(default), intent(in) :: lm2
    real(default), intent(in), optional :: x_free
    real(default) :: lx
    lx = lm2;  if (present (x_free))  lx = lx + log (x_free)
    r(1) = exp (- p(2) * lx)
    r(2) = exp (- (1 - p(2)) * lx)
    factor = lx
  end subroutine map_on_shell

  subroutine map_on_shell_inverse (r, factor, p, lm2, x_free)
    real(default), dimension(2), intent(in) :: r
    real(default), intent(out) :: factor
    real(default), dimension(2), intent(out) :: p
    real(default), intent(in) :: lm2
    real(default), intent(in), optional :: x_free
    real(default) :: lx
    lx = lm2;  if (present (x_free))  lx = lx + log (x_free)
    p(1) = 0
    p(2) = abs (log (r(1))) / lx
    factor = lx
  end subroutine map_on_shell_inverse
    
@ %def map_on_shell
@ %def map_on_shell_inverse
@ This is the standard Breit-Wigner mapping.  We apply it to a single
variable, independently of or in addition to a unit-square mapping.  We
assume here that the limits for the variable are 0 and 1, and that the
mass $m$ and width $w$ are rescaled appropriately, so they are
dimensionless and usually between 0 and 1.

If [[x_free]] is set, it rescales the total energy and thus mass and
width, since these are defined with respect to the total energy.
<<SF mappings: procedures>>=
  subroutine map_breit_wigner (r, factor, p, m, w, x_free)
    real(default), intent(out) :: r
    real(default), intent(out) :: factor
    real(default), intent(in) :: p
    real(default), intent(in) :: m
    real(default), intent(in) :: w
    real(default), intent(in), optional :: x_free
    real(default) :: m2, mw, a1, a2, a3, z, tmp
    m2 = m ** 2
    mw = m * w
    if (present (x_free)) then
       m2 = m2 / x_free
       mw = mw / x_free
    end if
    a1 = atan (- m2 / mw)
    a2 = atan ((1 - m2) / mw)
    a3 = (a2 - a1) * mw
    z = (1-p) * a1 + p * a2
    if (-pi/2 < z .and. z < pi/2) then
       tmp = tan (z)
       r = max (m2 + mw * tmp, 0._default)
       factor = a3 * (1 + tmp ** 2) 
    else
       r = 0
       factor = 0
    end if
  end subroutine map_breit_wigner
    
  subroutine map_breit_wigner_inverse (r, factor, p, m, w, x_free)
    real(default), intent(in) :: r
    real(default), intent(out) :: factor
    real(default), intent(out) :: p
    real(default), intent(in) :: m
    real(default), intent(in) :: w
    real(default) :: m2, mw, a1, a2, a3, tmp
    real(default), intent(in), optional :: x_free
    m2 = m ** 2
    mw = m * w
    if (present (x_free)) then
       m2 = m2 / x_free
       mw = mw / x_free
    end if
    a1 = atan (- m2 / mw)
    a2 = atan ((1 - m2) / mw)
    a3 = (a2 - a1) * mw
    tmp = (r - m2) / mw
    p = (atan (tmp) - a1) / (a2 - a1)
    factor = a3 * (1 + tmp ** 2)
  end subroutine map_breit_wigner_inverse

@ %def map_breit_wigner
@ %def map_breit_wigner_inverse
@ 
\subsubsection{Mapping with endpoint enhancement}
This is a mapping which is close to the unit mapping, except that at
the endpoint(s), the output values are exponentially enhanced.
\begin{equation}
  y = \tanh (a \tan (\frac{\pi}{2}x))
\end{equation}
We have two variants: one covers endpoints at $0$ and $1$
symmetrically, while the other one (which essentially maps one-half of
the range), covers only the endpoint at $1$.
<<SF mappings: procedures>>=
  subroutine map_endpoint_1 (x3, factor, x1, a)
    real(default), intent(out) :: x3, factor
    real(default), intent(in) :: x1
    real(default), intent(in) :: a
    real(default) :: x2
    if (abs (x1) < 1) then
       x2 = tan (x1 * pi / 2)
       x3 = tanh (a * x2)
       factor = a * pi/2 * (1 + x2 ** 2) * (1 - x3 ** 2)
    else
       x3 = x1
       factor = 0
    end if
  end subroutine map_endpoint_1

  subroutine map_endpoint_inverse_1 (x3, factor, x1, a)
    real(default), intent(in) :: x3
    real(default), intent(out) :: x1, factor
    real(default), intent(in) :: a
    real(default) :: x2
    if (abs (x3) < 1) then
       x2 = atanh (x3) / a
       x1 = 2 / pi * atan (x2)
       factor = a * pi/2 * (1 + x2 ** 2) * (1 - x3 ** 2)
    else
       x1 = x3
       factor = 0
    end if
  end subroutine map_endpoint_inverse_1

  subroutine map_endpoint_01 (x4, factor, x0, a)
    real(default), intent(out) :: x4, factor
    real(default), intent(in) :: x0
    real(default), intent(in) :: a
    real(default) :: x1, x3
    x1 = 2 * x0 - 1
    call map_endpoint_1 (x3, factor, x1, a)
    x4 = (x3 + 1) / 2
  end subroutine map_endpoint_01

  subroutine map_endpoint_inverse_01 (x4, factor, x0, a)
    real(default), intent(in) :: x4
    real(default), intent(out) :: x0, factor
    real(default), intent(in) :: a
    real(default) :: x1, x3
    x3 = 2 * x4 - 1
    call map_endpoint_inverse_1 (x3, factor, x1, a)
    x0 = (x1 + 1) / 2
  end subroutine map_endpoint_inverse_01

@ %def map_endpoint_1
@ %def map_endpoint_inverse_1
@ %def map_endpoint_01
@ %def map_endpoint_inverse_01
@ 
\subsubsection{Mapping with endpoint enhancement (ISR)}
This is another endpoint mapping.  It is designed to flatten the ISR
singularity which is of power type at $x=1$, i.e., if
\begin{equation}
  \sigma = \int_0^1 dx\,f(x)\,G(x)
  = \int_0^1 dx\,\epsilon(1-x)^{-1+\epsilon} G(x),
\end{equation}
we replace this by
\begin{equation}
  r = x^\epsilon \quad\Longrightarrow\quad
  \sigma = \int_0^1 dr\,G(1- (1-r)^{1/\epsilon}).
\end{equation}
We expect that $\epsilon$ is small.

The actual mapping is $r\to x$ (so $x$ emerges closer to $1$).  The
Jacobian that we return is thus $1/f(x)$.  We compute the mapping in
terms of $\bar x\equiv 1 - x$, so we can achieve the required precision.
Because some compilers show quite wild numeric fluctuations, we
internally convert numeric types to explicit [[double]] precision.
<<SF mappings: public>>=
  public :: map_power_1
  public :: map_power_inverse_1
<<SF mappings: procedures>>=
  subroutine map_power_1 (xb, factor, rb, eps)
    real(default), intent(out) :: xb, factor
    real(default), intent(in) :: rb
    real(double) :: rb_db, factor_db, eps_db, xb_db
    real(default), intent(in) :: eps
    rb_db = real (rb, kind=double)
    eps_db = real (eps, kind=double)
    xb_db = rb_db ** (1 / eps_db)
    if (rb_db > 0) then
       factor_db = xb_db / rb_db / eps_db
       factor = real (factor_db, kind=default)
    else
       factor = 0
    end if
    xb = real (xb_db, kind=default)
  end subroutine map_power_1
    
  subroutine map_power_inverse_1 (xb, factor, rb, eps)
    real(default), intent(in) :: xb
    real(default), intent(out) :: rb, factor
    real(double) :: xb_db, factor_db, eps_db, rb_db
    real(default), intent(in) :: eps
    xb_db = real (xb, kind=double)
    eps_db = real (eps, kind=double)
    rb_db = xb_db ** eps_db
    if (xb_db > 0) then
       factor_db = xb_db / rb_db / eps_db
       factor = real (factor_db, kind=default)
    else
       factor = 0
    end if
    rb = real (rb_db, kind=default)
  end subroutine map_power_inverse_1
    
@ %def map_power_1
@ %def map_power_inverse_1
@ Here we apply a power mapping to both endpoints.  We divide the
interval in two equal halves and apply the power mapping for the
nearest endpoint, either $0$ or $1$.
<<SF mappings: procedures>>=
  subroutine map_power_01 (y, yb, factor, r, eps)
    real(default), intent(out) :: y, yb, factor
    real(default), intent(in) :: r
    real(default), intent(in) :: eps
    real(default) :: u, ub, zp, zm
    u = 2 * r - 1
    if (u > 0) then
       ub = 2 * (1 - r)
       call map_power_1 (zm, factor, ub, eps)
       zp = 2 - zm
    else if (u < 0) then
       ub = 2 * r
       call map_power_1 (zp, factor, ub, eps)
       zm = 2 - zp
    else
       factor = 1 / eps
       zp = 1
       zm = 1
    end if
    y  = zp / 2
    yb = zm / 2
  end subroutine map_power_01
    
  subroutine map_power_inverse_01 (y, yb, factor, r, eps)
    real(default), intent(in) :: y, yb
    real(default), intent(out) :: r, factor
    real(default), intent(in) :: eps
    real(default) :: ub, zp, zm
    zp = 2 * y
    zm = 2 * yb
    if (zm < zp) then
       call map_power_inverse_1 (zm, factor, ub, eps)
       r = 1 - ub / 2
    else if (zp < zm) then
       call map_power_inverse_1 (zp, factor, ub, eps)
       r = ub / 2
    else
       factor = 1 / eps
       ub = 1
       r = ub / 2
    end if
  end subroutine map_power_inverse_01
    
@ %def map_power_01
@ %def map_power_inverse_01
@ 
\subsubsection{Structure-function channels}
A structure-function chain parameterization (channel) may contain a
mapping that applies to multiple structure functions.  This is
described by an extension of the [[sf_mapping_t]] type.  In addition,
it may contain mappings that apply to (other) individual structure
functions.  The details of these mappings are implementation-specific.

The [[sf_channel_t]] type combines this information.  It contains an
array of map codes, one for each structure-function entry.  The code
values are:
\begin{description}
\item[none] MC input parameters $r$ directly become energy fractions $x$
\item[single] default mapping for a single structure-function entry
\item[multi/s] map $r\to x$ such that one MC input parameter is $\hat s/s$
\item[multi/resonance] as before, adapted to s-channel resonance
\item[multi/on-shell] as before, adapted to an on-shell particle in
  the s channel
\item[multi/endpoint] like multi/s, but enhance the region near $r_i=1$
\item[multi/endpoint/res] endpoint mapping with resonance
\item[multi/endpoint/os] endpoint mapping for on-shell
\item[multi/power/os] like multi/endpoint, regulating a power singularity
\end{description}
<<SF mappings: parameters>>=
  integer, parameter :: SFMAP_NONE = 0
  integer, parameter :: SFMAP_SINGLE = 1
  integer, parameter :: SFMAP_MULTI_S = 2
  integer, parameter :: SFMAP_MULTI_RES = 3
  integer, parameter :: SFMAP_MULTI_ONS = 4
  integer, parameter :: SFMAP_MULTI_EP = 5
  integer, parameter :: SFMAP_MULTI_EPR = 6
  integer, parameter :: SFMAP_MULTI_EPO = 7
  integer, parameter :: SFMAP_MULTI_IP = 8
  integer, parameter :: SFMAP_MULTI_IPR = 9
  integer, parameter :: SFMAP_MULTI_IPO = 10
  integer, parameter :: SFMAP_MULTI_EI = 11

@ %def SFMAP_NONE SFMAP_SINGLE
@ %def SFMAP_MULTI_S SFMAP_MULTI_RES SFMAP_MULTI_ONS
@ %def SFMAP_MULTI_EP SFMAP_MULTI_EPR SFMAP_MULTI_EPO
@ %def SFMAP_MULTI_IP SFMAP_MULTI_IPR SFMAP_MULTI_IPO
@ %def SFMAP_MULTI_EI
@ Then, it contains an allocatable entry for the multi mapping.  This
entry holds the MC-parameter indices on which the mapping applies
(there may be more than one MC parameter per structure-function entry)
and any parameters associated with the mapping.

There can be only one multi-mapping per channel.
<<SF mappings: public>>=
  public :: sf_channel_t
<<SF mappings: types>>=
  type :: sf_channel_t
     integer, dimension(:), allocatable :: map_code
     class(sf_mapping_t), allocatable :: multi_mapping
   contains
   <<SF mappings: sf channel: TBP>>
  end type sf_channel_t
  
@ %def sf_channel_t
@ The output format prints a single character for each
structure-function entry and, if applicable, an account of the mapping
parameters.
<<SF mappings: sf channel: TBP>>=
  procedure :: write => sf_channel_write
<<SF mappings: procedures>>=
  subroutine sf_channel_write (object, unit)
    class(sf_channel_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    if (allocated (object%map_code)) then
       do i = 1, size (object%map_code)
          select case (object%map_code (i))
          case (SFMAP_NONE)
             write (u, "(1x,A)", advance="no") "-"
          case (SFMAP_SINGLE)
             write (u, "(1x,A)", advance="no") "+"
          case (SFMAP_MULTI_S)
             write (u, "(1x,A)", advance="no") "s"
          case (SFMAP_MULTI_RES)
             write (u, "(1x,A)", advance="no") "r"
          case (SFMAP_MULTI_ONS)
             write (u, "(1x,A)", advance="no") "o"
          case (SFMAP_MULTI_EP)
             write (u, "(1x,A)", advance="no") "e"
          case (SFMAP_MULTI_EPR)
             write (u, "(1x,A)", advance="no") "p"
          case (SFMAP_MULTI_EPO)
             write (u, "(1x,A)", advance="no") "q"
          case (SFMAP_MULTI_IP)
             write (u, "(1x,A)", advance="no") "i"
          case (SFMAP_MULTI_IPR)
             write (u, "(1x,A)", advance="no") "i"
          case (SFMAP_MULTI_IPO)
             write (u, "(1x,A)", advance="no") "i"
          case (SFMAP_MULTI_EI)
             write (u, "(1x,A)", advance="no") "i"
          end select
       end do
    else
       write (u, "(1x,A)", advance="no") "-"
    end if
    if (allocated (object%multi_mapping)) then
       write (u, "(1x,'/')", advance="no")
       call object%multi_mapping%write (u)
    else
       write (u, *)
    end if
  end subroutine sf_channel_write
       
@ %def sf_channel_write
@ Initializer for a single [[sf_channel]] object.
<<SF mappings: sf channel: TBP>>=
  procedure :: init => sf_channel_init
<<SF mappings: procedures>>=
  subroutine sf_channel_init (channel, n_strfun)
    class(sf_channel_t), intent(out) :: channel
    integer, intent(in) :: n_strfun
    allocate (channel%map_code (n_strfun))
    channel%map_code = SFMAP_NONE
  end subroutine sf_channel_init
    
@ %def sf_channel_init
@ Assignment.  This merely copies intrinsic assignment, but apparently
the latter is bugged in gfortran 4.6.3, causing memory corruption.
<<SF mappings: sf channel: TBP>>=
  generic :: assignment (=) => sf_channel_assign
  procedure :: sf_channel_assign
<<SF mappings: procedures>>=
  subroutine sf_channel_assign (copy, original)
    class(sf_channel_t), intent(out) :: copy
    type(sf_channel_t), intent(in) :: original
    allocate (copy%map_code (size (original%map_code)))
    copy%map_code = original%map_code
    if (allocated (original%multi_mapping)) then
       allocate (copy%multi_mapping, source = original%multi_mapping)
    end if
  end subroutine sf_channel_assign
  
@ %def sf_channel_assign
@ This initializer allocates an array of channels with common number of
structure-function entries, therefore it is not a type-bound procedure.
<<SF mappings: public>>=
  public :: allocate_sf_channels
<<SF mappings: procedures>>=
  subroutine allocate_sf_channels (channel, n_channel, n_strfun)
    type(sf_channel_t), dimension(:), intent(out), allocatable :: channel
    integer, intent(in) :: n_channel
    integer, intent(in) :: n_strfun
    integer :: c
    allocate (channel (n_channel))
    do c = 1, n_channel
       call channel(c)%init (n_strfun)
    end do
  end subroutine allocate_sf_channels

@ %def allocate_sf_channels
@ This marks a given subset of indices as single-mapping.
<<SF mappings: sf channel: TBP>>=
  procedure :: activate_mapping => sf_channel_activate_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_activate_mapping (channel, i_sf)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    channel%map_code(i_sf) = SFMAP_SINGLE
  end subroutine sf_channel_activate_mapping
  
@ %def sf_channel_activate_mapping
@ This sets an s-channel multichannel mapping.  The length of the
[[i_sf]] array must be 2.  The parameter indices are not yet set.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_s_mapping => sf_channel_set_s_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_s_mapping (channel, i_sf, power)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: power
    channel%map_code(i_sf) = SFMAP_MULTI_S
    allocate (sf_s_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_s_mapping_t)
       call mapping%init (power)
    end select
  end subroutine sf_channel_set_s_mapping

@ %def sf_channel_set_s_mapping
@ This sets an s-channel resonance multichannel mapping.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_res_mapping => sf_channel_set_res_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_res_mapping (channel, i_sf, m, w)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in) :: m, w
    channel%map_code(i_sf) = SFMAP_MULTI_RES
    allocate (sf_res_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_res_mapping_t)
       call mapping%init (m, w)
    end select
  end subroutine sf_channel_set_res_mapping

@ %def sf_channel_set_res_mapping
@ This sets an s-channel on-shell multichannel mapping.  The length of the
[[i_sf]] array must be 2.  (The first parameter actually becomes an
irrelevant dummy.)
<<SF mappings: sf channel: TBP>>=
  procedure :: set_os_mapping => sf_channel_set_os_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_os_mapping (channel, i_sf, m)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in) :: m
    channel%map_code(i_sf) = SFMAP_MULTI_ONS
    allocate (sf_os_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_os_mapping_t)
       call mapping%init (m)
    end select
  end subroutine sf_channel_set_os_mapping

@ %def sf_channel_set_os_mapping
@ This sets an s-channel endpoint mapping.  The parameter $a$ is the
slope parameter (default 1); increasing it moves the endpoint region
(at $x=1$ to lower values in the input parameter.
region even more.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_ep_mapping => sf_channel_set_ep_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_ep_mapping (channel, i_sf, a)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: a
    channel%map_code(i_sf) = SFMAP_MULTI_EP
    allocate (sf_ep_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_ep_mapping_t)
       call mapping%init (a = a)
    end select
  end subroutine sf_channel_set_ep_mapping

@ %def sf_channel_set_ep_mapping
@ This sets a resonant endpoint mapping.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_epr_mapping => sf_channel_set_epr_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_epr_mapping (channel, i_sf, a, m, w)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in) :: a, m, w
    channel%map_code(i_sf) = SFMAP_MULTI_EPR
    allocate (sf_epr_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_epr_mapping_t)
       call mapping%init (a, m, w)
    end select
  end subroutine sf_channel_set_epr_mapping

@ %def sf_channel_set_epr_mapping
@ This sets an on-shell endpoint mapping.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_epo_mapping => sf_channel_set_epo_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_epo_mapping (channel, i_sf, a, m)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in) :: a, m
    channel%map_code(i_sf) = SFMAP_MULTI_EPO
    allocate (sf_epo_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_epo_mapping_t)
       call mapping%init (a, m)
    end select
  end subroutine sf_channel_set_epo_mapping

@ %def sf_channel_set_epo_mapping
@ This sets an s-channel power mapping, regulating a singularity of
type $(1-x)^{-1+\epsilon}$.  The parameter $\epsilon$ depends on the
structure function.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_ip_mapping => sf_channel_set_ip_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_ip_mapping (channel, i_sf, eps)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: eps
    channel%map_code(i_sf) = SFMAP_MULTI_IP
    allocate (sf_ip_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_ip_mapping_t)
       call mapping%init (eps)
    end select
  end subroutine sf_channel_set_ip_mapping

@ %def sf_channel_set_ip_mapping
@ This sets an s-channel resonant power mapping, regulating a
singularity of type $(1-x)^{-1+\epsilon}$ in the presence of an
s-channel resonance.  The parameter $\epsilon$ depends on the
structure function.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_ipr_mapping => sf_channel_set_ipr_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_ipr_mapping (channel, i_sf, eps, m, w)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: eps, m, w
    channel%map_code(i_sf) = SFMAP_MULTI_IPR
    allocate (sf_ipr_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_ipr_mapping_t)
       call mapping%init (eps, m, w)
    end select
  end subroutine sf_channel_set_ipr_mapping

@ %def sf_channel_set_ipr_mapping
@ This sets an on-shell power mapping, regulating a
singularity of type $(1-x)^{-1+\epsilon}$ for the production of a
single on-shell particle..  The parameter $\epsilon$ depends on the
structure function.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_ipo_mapping => sf_channel_set_ipo_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_ipo_mapping (channel, i_sf, eps, m)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: eps, m
    channel%map_code(i_sf) = SFMAP_MULTI_IPO
    allocate (sf_ipo_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_ipo_mapping_t)
       call mapping%init (eps, m)
    end select
  end subroutine sf_channel_set_ipo_mapping

@ %def sf_channel_set_ipo_mapping
@ This sets a combined endpoint/ISR mapping.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_ei_mapping => sf_channel_set_ei_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_ei_mapping (channel, i_sf, a, eps)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: a, eps
    channel%map_code(i_sf) = SFMAP_MULTI_EI
    allocate (sf_ei_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_ei_mapping_t)
       call mapping%init (a, eps)
    end select
  end subroutine sf_channel_set_ei_mapping

@ %def sf_channel_set_ei_mapping
@ This sets a combined endpoint/ISR mapping with resonance.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_eir_mapping => sf_channel_set_eir_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_eir_mapping (channel, i_sf, a, eps, m, w)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: a, eps, m, w
    channel%map_code(i_sf) = SFMAP_MULTI_EI
    allocate (sf_eir_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_eir_mapping_t)
       call mapping%init (a, eps, m, w)
    end select
  end subroutine sf_channel_set_eir_mapping

@ %def sf_channel_set_eir_mapping
@ This sets a combined endpoint/ISR mapping, on-shell.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_eio_mapping => sf_channel_set_eio_mapping
<<SF mappings: procedures>>=
  subroutine sf_channel_set_eio_mapping (channel, i_sf, a, eps, m)
    class(sf_channel_t), intent(inout) :: channel
    integer, dimension(:), intent(in) :: i_sf
    real(default), intent(in), optional :: a, eps, m
    channel%map_code(i_sf) = SFMAP_MULTI_EI
    allocate (sf_eio_mapping_t :: channel%multi_mapping)
    select type (mapping => channel%multi_mapping)
    type is (sf_eio_mapping_t)
       call mapping%init (a, eps, m)
    end select
  end subroutine sf_channel_set_eio_mapping

@ %def sf_channel_set_eio_mapping
@ Return true if the mapping code at position [[i_sf]] is [[SFMAP_SINGLE]].
<<SF mappings: sf channel: TBP>>=
  procedure :: is_single_mapping => sf_channel_is_single_mapping
<<SF mappings: procedures>>=
  function sf_channel_is_single_mapping (channel, i_sf) result (flag)
    class(sf_channel_t), intent(in) :: channel
    integer, intent(in) :: i_sf
    logical :: flag
    flag = channel%map_code(i_sf) == SFMAP_SINGLE
  end function sf_channel_is_single_mapping 

@ %def sf_channel_is_single_mapping
@ Return true if the mapping code at position [[i_sf]] is any of the
[[SFMAP_MULTI]] mappings.
<<SF mappings: sf channel: TBP>>=
  procedure :: is_multi_mapping => sf_channel_is_multi_mapping
<<SF mappings: procedures>>=
  function sf_channel_is_multi_mapping (channel, i_sf) result (flag)
    class(sf_channel_t), intent(in) :: channel
    integer, intent(in) :: i_sf
    logical :: flag
    select case (channel%map_code(i_sf))
    case (SFMAP_NONE, SFMAP_SINGLE)
       flag = .false.
    case default
       flag = .true.
    end select
  end function sf_channel_is_multi_mapping 

@ %def sf_channel_is_multi_mapping
@ Return true if there is any nontrivial mapping in any of the channels.

Note: we provide an explicit public function.  gfortran 4.6.3 has
problems with the alternative implementation as a type-bound
procedure for an array base object.
<<SF mappings: public>>=
  public :: any_sf_channel_has_mapping
<<SF mappings: procedures>>=
  function any_sf_channel_has_mapping (channel) result (flag)
    type(sf_channel_t), dimension(:), intent(in) :: channel
    logical :: flag
    integer :: c
    flag = .false.
    do c = 1, size (channel)
       flag = flag .or. any (channel(c)%map_code /= SFMAP_NONE)
    end do
  end function any_sf_channel_has_mapping
  
@ %def any_sf_channel_has_mapping
@ Set a parameter index for an active multi mapping.  We assume that
the index array is allocated properly.
<<SF mappings: sf channel: TBP>>=
  procedure :: set_par_index => sf_channel_set_par_index
<<SF mappings: procedures>>=
  subroutine sf_channel_set_par_index (channel, j, i_par)
    class(sf_channel_t), intent(inout) :: channel
    integer, intent(in) :: j
    integer, intent(in) :: i_par
    call channel%multi_mapping%set_index (j, i_par)
  end subroutine sf_channel_set_par_index
    
@ %def sf_channel_set_par_index
@
\subsection{Unit tests}
<<SF mappings: public>>=
  public :: sf_mappings_test
<<SF mappings: tests>>=
  subroutine sf_mappings_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF mappings: execute tests>>
  end subroutine sf_mappings_test
  
@ %def sf_mappings_test
@ 
\subsubsection{Check standard mapping}
Probe the standard mapping of the unit square for different parameter
values.  Also calculates integrals.  For a finite number of bins, they differ
slightly from $1$, but the result is well-defined because we are not using
random points.
<<SF mappings: execute tests>>=
  call test (sf_mappings_1, "sf_mappings_1", &
       "standard pair mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_1 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_1"
    write (u, "(A)")  "*   Purpose: probe standard mapping"
    write (u, "(A)")
    
    allocate (sf_s_mapping_t :: mapping)
    select type (mapping)
    type is (sf_s_mapping_t)
       call mapping%init ()
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.1):"
    p = [0.1_default, 0.1_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)
    allocate (sf_s_mapping_t :: mapping)
    select type (mapping)
    type is (sf_s_mapping_t)
       call mapping%init (power=2._default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    write (u, *)
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.1):"
    p = [0.1_default, 0.1_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)")  "I =", mapping%integral (100000)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_1"

  end subroutine sf_mappings_1
  
@ %def sf_mappings_1
@ 
\subsubsection{Channel entries}
Construct channel entries and print them.
<<SF mappings: execute tests>>=
  call test (sf_mappings_2, "sf_mappings_2", &
       "structure-function mapping channels", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_2 (u)
    integer, intent(in) :: u
    type(sf_channel_t), dimension(:), allocatable :: channel
    integer :: c
    
    write (u, "(A)")  "* Test output: sf_mappings_2"
    write (u, "(A)")  "*   Purpose: construct and display &
         &mapping-channel objects"
    write (u, "(A)")
    
    call allocate_sf_channels (channel, n_channel = 6, n_strfun = 2)
    call channel(2)%activate_mapping ([1])
    call channel(3)%set_s_mapping ([1,2])
    call channel(4)%set_s_mapping ([1,2], power=2._default)
    call channel(5)%set_res_mapping ([1,2], m = 0.5_default, w = 0.1_default)
    call channel(6)%set_os_mapping ([1,2], m = 0.5_default)
    
    call channel(3)%set_par_index (1, 1)
    call channel(3)%set_par_index (2, 4)

    call channel(4)%set_par_index (1, 1)
    call channel(4)%set_par_index (2, 4)

    call channel(5)%set_par_index (1, 1)
    call channel(5)%set_par_index (2, 3)

    call channel(6)%set_par_index (1, 1)
    call channel(6)%set_par_index (2, 2)

    do c = 1, size (channel)
       write (u, "(I0,':')", advance="no")  c
       call channel(c)%write (u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_2"

  end subroutine sf_mappings_2
  
@ %def sf_mappings_2
@ 
\subsubsection{Check resonance mapping}
Probe the resonance mapping of the unit square for different parameter
values.  Also calculates integrals.  For a finite number of bins, they differ
slightly from $1$, but the result is well-defined because we are not using
random points.

The resonance mass is at $1/2$ the energy, the width is $1/10$.
<<SF mappings: execute tests>>=
  call test (sf_mappings_3, "sf_mappings_3", &
       "resonant pair mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_3 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_3"
    write (u, "(A)")  "*   Purpose: probe resonance pair mapping"
    write (u, "(A)")
    
    allocate (sf_res_mapping_t :: mapping)
    select type (mapping)
    type is (sf_res_mapping_t)
       call mapping%init (0.5_default, 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.1):"
    p = [0.1_default, 0.1_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_3"

  end subroutine sf_mappings_3
  
@ %def sf_mappings_3
@ 
\subsubsection{Check on-shell mapping}
Probe the on-shell mapping of the unit square for different parameter
values.  Also calculates integrals.  In this case, the Jacobian is
constant and given by $|\log m^2|$, so this is also the value of the
integral.  The factor results from the variable change in the $\delta$
function $\delta (m^2 - x_1x_2)$ which multiplies the cross section
for the case at hand.

For the test, the (rescaled) resonance mass is set at $1/2$ the
energy.
<<SF mappings: execute tests>>=
  call test (sf_mappings_4, "sf_mappings_4", &
       "on-shell pair mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_4 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_4"
    write (u, "(A)")  "*   Purpose: probe on-shell pair mapping"
    write (u, "(A)")
    
    allocate (sf_os_mapping_t :: mapping)
    select type (mapping)
    type is (sf_os_mapping_t)
       call mapping%init (0.5_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0,0.1):"
    p = [0._default, 0.1_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0,1.0):"
    p = [0._default, 1.0_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_4"

  end subroutine sf_mappings_4
  
@ %def sf_mappings_4
@ 
\subsubsection{Check endpoint mapping}
Probe the endpoint mapping of the unit square for different parameter
values.  Also calculates integrals.  For a finite number of bins, they differ
slightly from $1$, but the result is well-defined because we are not using
random points.
<<SF mappings: execute tests>>=
  call test (sf_mappings_5, "sf_mappings_5", &
       "endpoint pair mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_5 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_5"
    write (u, "(A)")  "*   Purpose: probe endpoint pair mapping"
    write (u, "(A)")
    
    allocate (sf_ep_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ep_mapping_t)
       call mapping%init ()
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_5"

  end subroutine sf_mappings_5
  
@ %def sf_mappings_5
@ 
\subsubsection{Check endpoint resonant mapping}
Probe the endpoint mapping with resonance.  Also calculates integrals.
<<SF mappings: execute tests>>=
  call test (sf_mappings_6, "sf_mappings_6", &
       "endpoint resonant mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_6 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_6"
    write (u, "(A)")  "*   Purpose: probe endpoint resonant mapping"
    write (u, "(A)")
    
    allocate (sf_epr_mapping_t :: mapping)
    select type (mapping)
    type is (sf_epr_mapping_t)
       call mapping%init (a = 1._default, m = 0.5_default, w = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Same mapping without resonance:"
    write (u, "(A)")

    allocate (sf_epr_mapping_t :: mapping)
    select type (mapping)
    type is (sf_epr_mapping_t)
       call mapping%init (a = 1._default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_6"

  end subroutine sf_mappings_6
  
@ %def sf_mappings_6
@ 
\subsubsection{Check endpoint on-shell mapping}
Probe the endpoint mapping with an on-shell particle.  Also calculates
integrals.
<<SF mappings: execute tests>>=
  call test (sf_mappings_7, "sf_mappings_7", &
       "endpoint on-shell mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_7 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p
    
    write (u, "(A)")  "* Test output: sf_mappings_7"
    write (u, "(A)")  "*   Purpose: probe endpoint on-shell mapping"
    write (u, "(A)")
    
    allocate (sf_epo_mapping_t :: mapping)
    select type (mapping)
    type is (sf_epo_mapping_t)
       call mapping%init (a = 1._default, m = 0.5_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0):"
    p = [0._default, 0._default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.1,0.5):"
    p = [0.1_default, 0.5_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    call mapping%check (u, p, 1-p, "F7.5")

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_7"

  end subroutine sf_mappings_7
  
@ %def sf_mappings_7
@ 
\subsubsection{Check power mapping}
Probe the power mapping of the unit square for different parameter
values.  Also calculates integrals.  For a finite number of bins, they differ
slightly from $1$, but the result is well-defined because we are not using
random points.
<<SF mappings: execute tests>>=
  call test (sf_mappings_8, "sf_mappings_8", &
       "power pair mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_8 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_8"
    write (u, "(A)")  "*   Purpose: probe power pair mapping"
    write (u, "(A)")
    
    allocate (sf_ip_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ip_mapping_t)
       call mapping%init (eps = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0.5):"
    p = [0._default, 0.5_default]
    pb= [1._default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9,0.5):"
    p = [0.9_default, 0.5_default]
    pb= [0.1_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    pb= [0.3_default, 0.8_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.8):"
    p = [0.7_default, 0.8_default]
    pb= [0.3_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.99,0.02):"
    p = [0.99_default, 0.02_default]
    pb= [0.01_default, 0.98_default]
    call mapping%check (u, p, pb, FMT_14, FMT_12)

    write (u, *)
    write (u, "(A)")  "Probe at (0.99,0.98):"
    p = [0.99_default, 0.98_default]
    pb= [0.01_default, 0.02_default]
    call mapping%check (u, p, pb, FMT_14, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_8"

  end subroutine sf_mappings_8
  
@ %def sf_mappings_8
@ 
\subsubsection{Check resonant power mapping}
Probe the power mapping of the unit square, adapted for an s-channel
resonance, for different parameter values.  Also calculates integrals.
For a finite number of bins, they differ slightly from $1$, but the
result is well-defined because we are not using random points.
<<SF mappings: execute tests>>=
  call test (sf_mappings_9, "sf_mappings_9", &
       "power resonance mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_9 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_9"
    write (u, "(A)")  "*   Purpose: probe power resonant pair mapping"
    write (u, "(A)")
    
    allocate (sf_ipr_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ipr_mapping_t)
       call mapping%init (eps = 0.1_default, m = 0.5_default, w = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0.5):"
    p = [0._default, 0.5_default]
    pb= [1._default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9,0.5):"
    p = [0.9_default, 0.5_default]
    pb= [0.1_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    pb= [0.3_default, 0.8_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.8):"
    p = [0.7_default, 0.8_default]
    pb= [0.3_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9999,0.02):"
    p = [0.9999_default, 0.02_default]
    pb= [0.0001_default, 0.98_default]
    call mapping%check (u, p, pb, FMT_15, FMT_12)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9999,0.98):"
    p = [0.9999_default, 0.98_default]
    pb= [0.0001_default, 0.02_default]
    call mapping%check (u, p, pb, FMT_15, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Same mapping without resonance:"
    write (u, "(A)")
    
    allocate (sf_ipr_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ipr_mapping_t)
       call mapping%init (eps = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0.5):"
    p = [0._default, 0.5_default]
    pb= [1._default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.5,0.5):"
    p = [0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9,0.5):"
    p = [0.9_default, 0.5_default]
    pb= [0.1_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.2):"
    p = [0.7_default, 0.2_default]
    pb= [0.3_default, 0.8_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7,0.8):"
    p = [0.7_default, 0.8_default]
    pb= [0.3_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_9"

  end subroutine sf_mappings_9
  
@ %def sf_mappings_9
@ 
\subsubsection{Check on-shell power mapping}
Probe the power mapping of the unit square, adapted for
single-particle production, for different parameter values.  Also
calculates integrals.  For a finite number of bins, they differ
slightly from $1$, but the result is well-defined because we are not
using random points.
<<SF mappings: execute tests>>=
  call test (sf_mappings_10, "sf_mappings_10", &
       "power on-shell mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_10 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(2) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_10"
    write (u, "(A)")  "*   Purpose: probe power on-shell mapping"
    write (u, "(A)")
    
    allocate (sf_ipo_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ipo_mapping_t)
       call mapping%init (eps = 0.1_default, m = 0.5_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0,0.5):"
    p = [0._default, 0.5_default]
    pb= [1._default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0,0.02):"
    p = [0._default, 0.02_default]
    pb= [1._default, 0.98_default]
    call mapping%check (u, p, pb, FMT_15, FMT_12)

    write (u, *)
    write (u, "(A)")  "Probe at (0,0.98):"
    p = [0._default, 0.98_default]
    pb= [1._default, 0.02_default]
    call mapping%check (u, p, pb, FMT_15, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_10"

  end subroutine sf_mappings_10
  
@ %def sf_mappings_10
@ 
\subsubsection{Check combined endpoint-power mapping}
Probe the mapping for the beamstrahlung/ISR combination.
<<SF mappings: execute tests>>=
  call test (sf_mappings_11, "sf_mappings_11", &
       "endpoint/power combined mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_11 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(4) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_11"
    write (u, "(A)")  "*   Purpose: probe power pair mapping"
    write (u, "(A)")
    
    allocate (sf_ei_mapping_t :: mapping)
    select type (mapping)
    type is (sf_ei_mapping_t)
       call mapping%init (eps = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
       call mapping%set_index (3, 3)
       call mapping%set_index (4, 4)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0.5, 0.5, 0.5, 0.5):"
    p = [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7, 0.2, 0.4, 0.8):"
    p = [0.7_default, 0.2_default, 0.4_default, 0.8_default]
    pb= [0.3_default, 0.8_default, 0.6_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9, 0.06, 0.95, 0.1):"
    p = [0.9_default, 0.06_default, 0.95_default, 0.1_default]
    pb= [0.1_default, 0.94_default, 0.05_default, 0.9_default]
    call mapping%check (u, p, pb, FMT_13, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_11"

  end subroutine sf_mappings_11
  
@ %def sf_mappings_11
@ 
\subsubsection{Check resonant endpoint-power mapping}
Probe the mapping for the beamstrahlung/ISR combination.
<<SF mappings: execute tests>>=
  call test (sf_mappings_12, "sf_mappings_12", &
       "endpoint/power resonant combined mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_12 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(4) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_12"
    write (u, "(A)")  "*   Purpose: probe resonant combined mapping"
    write (u, "(A)")
    
    allocate (sf_eir_mapping_t :: mapping)
    select type (mapping)
    type is (sf_eir_mapping_t)
       call mapping%init (a = 1._default, &
            eps = 0.1_default, m = 0.5_default, w = 0.1_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
       call mapping%set_index (3, 3)
       call mapping%set_index (4, 4)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0.5, 0.5, 0.5, 0.5):"
    p = [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7, 0.2, 0.4, 0.8):"
    p = [0.7_default, 0.2_default, 0.4_default, 0.8_default]
    pb= [0.3_default, 0.8_default, 0.6_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9, 0.06, 0.95, 0.1):"
    p = [0.9_default, 0.06_default, 0.95_default, 0.1_default]
    pb= [0.1_default, 0.94_default, 0.05_default, 0.9_default]
    call mapping%check (u, p, pb, FMT_15, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_12"

  end subroutine sf_mappings_12
  
@ %def sf_mappings_12
@ 
\subsubsection{Check on-shell endpoint-power mapping}
Probe the mapping for the beamstrahlung/ISR combination.
<<SF mappings: execute tests>>=
  call test (sf_mappings_13, "sf_mappings_13", &
       "endpoint/power on-shell combined mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_13 (u)
    integer, intent(in) :: u
    class(sf_mapping_t), allocatable :: mapping
    real(default), dimension(4) :: p, pb
    
    write (u, "(A)")  "* Test output: sf_mappings_13"
    write (u, "(A)")  "*   Purpose: probe on-shell combined mapping"
    write (u, "(A)")
    
    allocate (sf_eio_mapping_t :: mapping)
    select type (mapping)
    type is (sf_eio_mapping_t)
       call mapping%init (a = 1._default, eps = 0.1_default, m = 0.5_default)
       call mapping%set_index (1, 1)
       call mapping%set_index (2, 2)
       call mapping%set_index (3, 3)
       call mapping%set_index (4, 4)
    end select
       
    call mapping%write (u)
    
    write (u, *)
    write (u, "(A)")  "Probe at (0.5, 0.5, 0.5, 0.5):"
    p = [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    pb= [0.5_default, 0.5_default, 0.5_default, 0.5_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.7, 0.2, 0.4, 0.8):"
    p = [0.7_default, 0.2_default, 0.4_default, 0.8_default]
    pb= [0.3_default, 0.8_default, 0.6_default, 0.2_default]
    call mapping%check (u, p, pb, FMT_16)

    write (u, *)
    write (u, "(A)")  "Probe at (0.9, 0.06, 0.95, 0.1):"
    p = [0.9_default, 0.06_default, 0.95_default, 0.1_default]
    pb= [0.1_default, 0.94_default, 0.05_default, 0.9_default]
    call mapping%check (u, p, pb, FMT_14, FMT_12)

    write (u, *)
    write (u, "(A)")  "Compute integral:"
    write (u, "(3x,A,1x,F7.5)") "I =", mapping%integral (100000)

    deallocate (mapping)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_13"

  end subroutine sf_mappings_13
  
@ %def sf_mappings_13
@ 
\subsubsection{Check rescaling}
Check the rescaling factor in on-shell basic mapping.
<<SF mappings: execute tests>>=
  call test (sf_mappings_14, "sf_mappings_14", &
       "rescaled on-shell mapping", &
       u, results)
<<SF mappings: tests>>=
  subroutine sf_mappings_14 (u)
    integer, intent(in) :: u
    real(default), dimension(2) :: p, r
    real(default) :: f, x_free, m2
    
    write (u, "(A)")  "* Test output: sf_mappings_14"
    write (u, "(A)")  "*   Purpose: probe rescaling in os mapping"
    write (u, "(A)")
    
    p = [0.1_default, 0.2_default]
    x_free = 0.9_default
    m2 = 0.5_default
    
    call map_on_shell (r, f, p, -log (m2), x_free)
    
    write (u, "(A,9(1x," // FMT_14 // "))")  "p =", p
    write (u, "(A,9(1x," // FMT_14 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_14 // "))")  "f =", f
    write (u, "(A,9(1x," // FMT_14 // "))")  "*r=", x_free * product (r)

    write (u, *)

    call map_on_shell_inverse (r, f, p, -log (m2), x_free)
    
    write (u, "(A,9(1x," // FMT_14 // "))")  "p =", p
    write (u, "(A,9(1x," // FMT_14 // "))")  "r =", r
    write (u, "(A,9(1x," // FMT_14 // "))")  "f =", f
    write (u, "(A,9(1x," // FMT_14 // "))")  "*r=", x_free * product (r)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_mappings_14"

  end subroutine sf_mappings_14
  
@ %def sf_mappings_14
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Structure function base}

<<[[sf_base.f90]]>>=
<<File header>>

module sf_base

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use format_defs, only: FMT_17, FMT_19
  use unit_tests
  use diagnostics
  use lorentz
  use model_data
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use pdg_arrays
  use particles
  use beams
  use sf_aux
  use sf_mappings

<<Standard module head>>

<<SF base: public>>

<<SF base: parameters>>

<<SF base: types>>

<<SF base: interfaces>>

<<SF base: test types>>

contains

<<SF base: procedures>>

<<SF base: tests>>

end module sf_base
@ %def sf_base
@
\subsection{Abstract structure-function data type}
This type should hold all configuration data for a specific type of
structure function.  The base object is empty; the implementations
will fill it.
<<SF base: public>>=
  public :: sf_data_t
<<SF base: types>>=
  type, abstract :: sf_data_t
   contains
   <<SF base: sf data: TBP>>
  end type sf_data_t

@ %def sf_data_t
@ Output.
<<SF base: sf data: TBP>>=
  procedure (sf_data_write), deferred :: write
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_data_write (data, unit, verbose)
       import
       class(sf_data_t), intent(in) :: data
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: verbose
     end subroutine sf_data_write
  end interface
  
@ %def sf_data_write
@ Return true if this structure function is in generator mode.  In
that case, all parameters are free, otherwise bound.  (We do not
support mixed cases.)  Default is: no generator.
<<SF base: sf data: TBP>>=
  procedure :: is_generator => sf_data_is_generator
<<SF base: procedures>>=
  function sf_data_is_generator (data) result (flag)
    class(sf_data_t), intent(in) :: data
    logical :: flag
    flag = .false.
  end function sf_data_is_generator
  
@ %def sf_data_is_generator
@ Return the number of input parameters that determine the
structure function.
<<SF base: sf data: TBP>>=
  procedure (sf_data_get_int), deferred :: get_n_par
<<SF base: interfaces>>=
  abstract interface
     function sf_data_get_int (data) result (n)
       import
       class(sf_data_t), intent(in) :: data
       integer :: n
     end function sf_data_get_int
  end interface

@ %def sf_data_get_int
@ Return the outgoing particle PDG codes for the current setup.  The codes can
be an array of particles, for each beam.
<<SF base: sf data: TBP>>=
  procedure (sf_data_get_pdg_out), deferred :: get_pdg_out
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_data_get_pdg_out (data, pdg_out)
       import
       class(sf_data_t), intent(in) :: data
       type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
     end subroutine sf_data_get_pdg_out
  end interface
  
@ %def sf_data_get_pdg_out
@ Allocate a matching structure function interaction object and
properly initialize it.

<<SF base: sf data: TBP>>=
  procedure (sf_data_allocate_sf_int), deferred :: allocate_sf_int
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_data_allocate_sf_int (data, sf_int)
       import
       class(sf_data_t), intent(in) :: data
       class(sf_int_t), intent(inout), allocatable :: sf_int
     end subroutine sf_data_allocate_sf_int
  end interface

@ %def sf_data_allocate_sf_int
@ Return the PDF set index, if applicable.  We implement a default
method which returns zero.  The PDF (builtin and LHA) implementations
will override this.
<<SF base: sf data: TBP>>=
  procedure :: get_pdf_set => sf_data_get_pdf_set
<<SF base: procedures>>=
  function sf_data_get_pdf_set (data) result (pdf_set)
    class(sf_data_t), intent(in) :: data
    integer :: pdf_set
    pdf_set = 0
  end function sf_data_get_pdf_set
  
@ %def sf_data_get_pdf_set
@
\subsection{Structure-function chain configuration}
This is the data type that the [[processes]] module uses for setting
up its structure-function chain.  For each structure function described
by the beam data, there is an entry.  The [[i]] array indicates the
beam(s) to which this structure function applies, and the [[data]]
object contains the actual configuration data.
<<SF base: public>>=
  public :: sf_config_t
<<SF base: types>>=
  type :: sf_config_t
     integer, dimension(:), allocatable :: i
     class(sf_data_t), allocatable :: data
   contains
   <<SF base: sf config: TBP>>
  end type sf_config_t
  
@ %def sf_config_t
@ Output:
<<SF base: sf config: TBP>>=
  procedure :: write => sf_config_write
<<SF base: procedures>>=
  subroutine sf_config_write (object, unit)
    class(sf_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (allocated (object%i)) then
       write (u, "(1x,A,2(1x,I0))")  "Structure-function configuration: &
            &beam(s)", object%i
       if (allocated (object%data))  call object%data%write (u)
    else
       write (u, "(1x,A)")  "Structure-function configuration: [undefined]"
    end if
  end subroutine sf_config_write
       
@ %def sf_config_write
@ Initialize.
<<SF base: sf config: TBP>>=
  procedure :: init => sf_config_init
<<SF base: procedures>>=
  subroutine sf_config_init (sf_config, i_beam, sf_data)
    class(sf_config_t), intent(out) :: sf_config
    integer, dimension(:), intent(in) :: i_beam
    class(sf_data_t), intent(in) :: sf_data
    allocate (sf_config%i (size (i_beam)), source = i_beam)
    allocate (sf_config%data, source = sf_data)
  end subroutine sf_config_init
  
@ %def sf_config_init
@ Return the PDF set, if any.
<<SF base: sf config: TBP>>=
  procedure :: get_pdf_set => sf_config_get_pdf_set
<<SF base: procedures>>=
  function sf_config_get_pdf_set (sf_config) result (pdf_set)
    class(sf_config_t), intent(in) :: sf_config
    integer :: pdf_set
    pdf_set = sf_config%data%get_pdf_set ()
  end function sf_config_get_pdf_set
  
@ %def sf_config_get_pdf_set
@
\subsection{Structure-function instance}
The [[sf_int_t]] data type contains an [[interaction_t]] object (it is
an extension of this type) and a pointer to the [[sf_data_t]]
configuration data.  This interaction, or copies of it, is used to
implement structure-function kinematics and dynamics in the context of
process evaluation.

The status code [[status]] tells whether the interaction is undefined,
has defined kinematics (but matrix elements invalid), or is completely
defined.  There is also a status code for failure.  The implementation
is responsible for updating the status.

The entries [[mi2]], [[mr2]], and [[mo2]] hold the squared
invariant masses of the incoming, radiated, and outgoing particle,
respectively.  They are supposed to be set upon initialization, but
could also be varied event by event.

If the radiated or outgoing mass is nonzero, we may need to apply an
on-shell projection.  The projection mode is stored as
[[on_shell_mode]].

The array [[beam_index]] is the list of beams on which this structure
function applies ($1$, $2$, or both).  The arrays [[incoming]],
[[radiated]], and [[outgoing]] contain the indices of the respective
particle sets within the interaction, for convenient lookup.  The
array [[par_index]] indicates the MC input parameters that this entry
will use up in the structure-function chain.  The first parameter (or
the first two, for a spectrum) in this array determines the momentum
fraction and is thus subject to global mappings.

In the abstract base type, we do not implement the data pointer.  This
allows us to restrict its type in the implementations.
<<SF base: public>>=
  public :: sf_int_t
<<SF base: types>>=
  type, abstract, extends (interaction_t) :: sf_int_t
     integer :: status = SF_UNDEFINED
     real(default), dimension(:), allocatable :: mi2
     real(default), dimension(:), allocatable :: mr2
     real(default), dimension(:), allocatable :: mo2
     integer :: on_shell_mode = KEEP_ENERGY
     logical :: qmin_defined = .false.
     logical :: qmax_defined = .false.
     real(default), dimension(:), allocatable :: qmin
     real(default), dimension(:), allocatable :: qmax
     integer, dimension(:), allocatable :: beam_index
     integer, dimension(:), allocatable :: incoming
     integer, dimension(:), allocatable :: radiated
     integer, dimension(:), allocatable :: outgoing
     integer, dimension(:), allocatable :: par_index
     integer, dimension(:), allocatable :: par_primary
   contains
   <<SF base: sf int: TBP>>
  end type sf_int_t
  
@ %def sf_int_t
@ Status codes.  The codes that refer to links, masks, and
connections, apply to structure-function chains only.

The status codes are public.
<<SF base: parameters>>=
  integer, parameter, public :: SF_UNDEFINED = 0
  integer, parameter, public :: SF_INITIAL = 1
  integer, parameter, public :: SF_DONE_LINKS = 2
  integer, parameter, public :: SF_FAILED_MASK = 3
  integer, parameter, public :: SF_DONE_MASK = 4
  integer, parameter, public :: SF_FAILED_CONNECTIONS = 5
  integer, parameter, public :: SF_DONE_CONNECTIONS = 6
  integer, parameter, public :: SF_SEED_KINEMATICS = 10
  integer, parameter, public :: SF_FAILED_KINEMATICS = 11
  integer, parameter, public :: SF_DONE_KINEMATICS = 12
  integer, parameter, public :: SF_FAILED_EVALUATION = 13
  integer, parameter, public :: SF_EVALUATED = 20

@ %def SF_UNDEFINED SF_INITIAL 
@ %def SF_DONE_LINKS SF_DONE_MASK SF_DONE_CONNECTIONS
@ %def SF_DONE_KINEMATICS SF_EVALUATED
@ %def SF_FAILED_MASK SF_FAILED_CONNECTIONS
@ %def SF_FAILED_KINEMATICS SF_FAILED_EVALUATION
@ Write a string version of the status code:
<<SF base: procedures>>=
  subroutine write_sf_status (status, u)
    integer, intent(in) :: status
    integer, intent(in) :: u
    select case (status)
    case (SF_UNDEFINED)
       write (u, "(1x,'[',A,']')")  "undefined"
    case (SF_INITIAL)
       write (u, "(1x,'[',A,']')")  "initialized"
    case (SF_DONE_LINKS)
       write (u, "(1x,'[',A,']')")  "links set"
    case (SF_FAILED_MASK)
       write (u, "(1x,'[',A,']')")  "mask mismatch"
    case (SF_DONE_MASK)
       write (u, "(1x,'[',A,']')")  "mask set"
    case (SF_FAILED_CONNECTIONS)
       write (u, "(1x,'[',A,']')")  "connections failed"
    case (SF_DONE_CONNECTIONS)
       write (u, "(1x,'[',A,']')")  "connections set"
    case (SF_SEED_KINEMATICS)
       write (u, "(1x,'[',A,']')")  "incoming momenta set"
    case (SF_FAILED_KINEMATICS)
       write (u, "(1x,'[',A,']')")  "kinematics failed"
    case (SF_DONE_KINEMATICS)
       write (u, "(1x,'[',A,']')")  "kinematics set"
    case (SF_FAILED_EVALUATION)
       write (u, "(1x,'[',A,']')")  "evaluation failed"
    case (SF_EVALUATED)
       write (u, "(1x,'[',A,']')")  "evaluated"
    end select
  end subroutine write_sf_status

@ %def write_sf_status
@ Finalizer.  Required because the base interaction needs a
finalizer.  We provide an implementation, which need not be
overwritten if the implementation does not add finalizable
subobjects.
<<SF base: sf int: TBP>>=
  procedure :: final => sf_int_final
<<SF base: procedures>>=
  subroutine sf_int_final (object)
    class(sf_int_t), intent(inout) :: object
    call interaction_final (object%interaction_t)
  end subroutine sf_int_final

@ %def sf_int_final
@ This is the basic output routine.  Display status and interaction.
<<SF base: sf int: TBP>>=
  procedure :: base_write => sf_int_base_write
<<SF base: procedures>>=
  subroutine sf_int_base_write (object, unit, testflag)
    class(sf_int_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "SF instance:"
    call write_sf_status (object%status, u)
    if (allocated (object%beam_index)) &
         write (u, "(3x,A,2(1x,I0))")  "beam      =", object%beam_index
    if (allocated (object%incoming)) &
         write (u, "(3x,A,2(1x,I0))")  "incoming  =", object%incoming
    if (allocated (object%radiated)) &
         write (u, "(3x,A,2(1x,I0))")  "radiated  =", object%radiated
    if (allocated (object%outgoing)) &
         write (u, "(3x,A,2(1x,I0))")  "outgoing  =", object%outgoing
    if (allocated (object%par_index)) &
         write (u, "(3x,A,2(1x,I0))")  "parameter =", object%par_index
    if (object%qmin_defined) &
         write (u, "(3x,A,1x," // FMT_19 // ")")  "q_min     =", object%qmin
    if (object%qmax_defined) &
         write (u, "(3x,A,1x," // FMT_19 // ")")  "q_max     =", object%qmax
    call interaction_write (object%interaction_t, u, testflag = testflag)
  end subroutine sf_int_base_write
  
@ %def sf_int_base_write
@ The type string identifies the structure function class, and possibly more
details about the structure function.
<<SF base: sf int: TBP>>=
  procedure (sf_int_type_string), deferred :: type_string
<<SF base: interfaces>>=
  abstract interface
     function sf_int_type_string (object) result (string)
       import
       class(sf_int_t), intent(in) :: object
       type(string_t) :: string
     end function sf_int_type_string
  end interface
  
@ %def sf_int_type_string
@ Output of the concrete object.  We should not forget to call the
output routine for the base type.
<<SF base: sf int: TBP>>=
  procedure (sf_int_write), deferred :: write
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_int_write (object, unit, testflag)
       import
       class(sf_int_t), intent(in) :: object
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: testflag
     end subroutine sf_int_write
  end interface
  
@ %def sf_int_write
@ Basic initialization: set the invariant masses for the particles and
initialize the interaction.  The caller should then add states to the
interaction and freeze it.

The dimension of the mask should be equal to the sum of the dimensions
of the mass-squared arrays, which determine incoming, radiated, and
outgoing particles, respectively.

Optionally, we can define minimum and maximum values for the momentum
transfer to the outgoing particle(s).  If all masses are zero, this is
actually required for non-collinear splitting.
<<SF base: sf int: TBP>>=
  procedure :: base_init => sf_int_base_init
<<SF base: procedures>>=
  subroutine sf_int_base_init &
       (sf_int, mask, mi2, mr2, mo2, qmin, qmax, hel_lock)
    class(sf_int_t), intent(out) :: sf_int
    type (quantum_numbers_mask_t), dimension(:), intent(in) :: mask
    real(default), dimension(:), intent(in) :: mi2, mr2, mo2
    real(default), dimension(:), intent(in), optional :: qmin, qmax
    integer, dimension(:), intent(in), optional :: hel_lock
    allocate (sf_int%mi2 (size (mi2)))
    sf_int%mi2 = mi2
    allocate (sf_int%mr2 (size (mr2)))
    sf_int%mr2 = mr2
    allocate (sf_int%mo2 (size (mo2)))
    sf_int%mo2 = mo2
    if (present (qmin)) then
       sf_int%qmin_defined = .true.
       allocate (sf_int%qmin (size (qmin)))
       sf_int%qmin = qmin
    end if
    if (present (qmax)) then
       sf_int%qmax_defined = .true.
       allocate (sf_int%qmax (size (qmax)))
       sf_int%qmax = qmax
    end if
    call interaction_init (sf_int%interaction_t, &
         size (mi2), 0, size (mr2) + size (mo2), &
         mask = mask, hel_lock = hel_lock, set_relations = .true.)
  end subroutine sf_int_base_init
    
@ %def sf_int_base_init
@ Set the indices of the incoming, radiated, and outgoing particles,
respectively.
<<SF base: sf int: TBP>>=
  procedure :: set_incoming => sf_int_set_incoming
  procedure :: set_radiated => sf_int_set_radiated
  procedure :: set_outgoing => sf_int_set_outgoing
<<SF base: procedures>>=
  subroutine sf_int_set_incoming (sf_int, incoming)
    class(sf_int_t), intent(inout) :: sf_int
    integer, dimension(:), intent(in) :: incoming
    allocate (sf_int%incoming (size (incoming)))
    sf_int%incoming = incoming
  end subroutine sf_int_set_incoming

  subroutine sf_int_set_radiated (sf_int, radiated)
    class(sf_int_t), intent(inout) :: sf_int
    integer, dimension(:), intent(in) :: radiated
    allocate (sf_int%radiated (size (radiated)))
    sf_int%radiated = radiated
  end subroutine sf_int_set_radiated

  subroutine sf_int_set_outgoing (sf_int, outgoing)
    class(sf_int_t), intent(inout) :: sf_int
    integer, dimension(:), intent(in) :: outgoing
    allocate (sf_int%outgoing (size (outgoing)))
    sf_int%outgoing = outgoing
  end subroutine sf_int_set_outgoing

@ %def sf_int_set_incoming
@ %def sf_int_set_radiated
@ %def sf_int_set_outgoing
@ Initialization.  This proceeds via an abstract data object, which
for the actual implementation should have the matching concrete type.
Since all implementations have the same signature, we can prepare a
deferred procedure.  The data object will become the target of a
corresponding pointer within the [[sf_int_t]] implementation.

This should call the previous procedure.
<<SF base: sf int: TBP>>=
  procedure (sf_int_init), deferred :: init
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_int_init (sf_int, data)
       import
       class(sf_int_t), intent(out) :: sf_int
       class(sf_data_t), intent(in), target :: data
     end subroutine sf_int_init
  end interface
     
@ %def sf_int_init
@ Complete initialization.  This routine contains initializations that can
only be performed after the interaction object got its final shape, i.e.,
redundant helicities have been eliminated by matching with beams and process.

The default implementation does nothing.
<<SF base: sf int: TBP>>=
  procedure :: setup_constants => sf_int_setup_constants
<<SF base: procedures>>=
  subroutine sf_int_setup_constants (sf_int)
    class(sf_int_t), intent(inout) :: sf_int
  end subroutine sf_int_setup_constants
  
@ %def sf_int_setup_constants
@ Set beam indices, i.e., the beam(s) on which
this structure function applies.
<<SF base: sf int: TBP>>=
  procedure :: set_beam_index => sf_int_set_beam_index
<<SF base: procedures>>=
  subroutine sf_int_set_beam_index (sf_int, beam_index)
    class(sf_int_t), intent(inout) :: sf_int
    integer, dimension(:), intent(in) :: beam_index
    allocate (sf_int%beam_index (size (beam_index)))
    sf_int%beam_index = beam_index
  end subroutine sf_int_set_beam_index

@ %def sf_int_set_beam_index
@ Set parameter indices, indicating which MC input parameters are to
be used for evaluating this structure function.
<<SF base: sf int: TBP>>=
  procedure :: set_par_index => sf_int_set_par_index
<<SF base: procedures>>=
  subroutine sf_int_set_par_index (sf_int, par_index)
    class(sf_int_t), intent(inout) :: sf_int
    integer, dimension(:), intent(in) :: par_index
    allocate (sf_int%par_index (size (par_index)))
    sf_int%par_index = par_index
  end subroutine sf_int_set_par_index

@ %def sf_int_set_par_index
@ Initialize the structure-function kinematics, setting incoming
momenta.  We assume that array shapes match.

Three versions.  The first version relies on the momenta being linked
to another interaction.  The second version sets the momenta
explicitly.  In the third version, we first compute momenta for the
specified energies and store those.
<<SF base: sf int: TBP>>=
  generic :: seed_kinematics => sf_int_receive_momenta
  generic :: seed_kinematics => sf_int_seed_momenta
  generic :: seed_kinematics => sf_int_seed_energies
  procedure :: sf_int_receive_momenta
  procedure :: sf_int_seed_momenta
  procedure :: sf_int_seed_energies
<<SF base: procedures>>=
  subroutine sf_int_receive_momenta (sf_int)
    class(sf_int_t), intent(inout) :: sf_int
    if (sf_int%status >= SF_INITIAL) then
       call interaction_receive_momenta (sf_int%interaction_t)
       sf_int%status = SF_SEED_KINEMATICS
    end if
  end subroutine sf_int_receive_momenta

  subroutine sf_int_seed_momenta (sf_int, k)
    class(sf_int_t), intent(inout) :: sf_int
    type(vector4_t), dimension(:), intent(in) :: k
    if (sf_int%status >= SF_INITIAL) then
       call interaction_set_momenta (sf_int%interaction_t, k, &
            outgoing=.false.)
       sf_int%status = SF_SEED_KINEMATICS
    end if
  end subroutine sf_int_seed_momenta
  
  subroutine sf_int_seed_energies (sf_int, E)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: E
    type(vector4_t), dimension(:), allocatable :: k
    integer :: j
    if (sf_int%status >= SF_INITIAL) then
       allocate (k (size (E)))
       if (all (E**2 >= sf_int%mi2)) then
          do j = 1, size (E)
             k(j) = vector4_moving (E(j), &
                  (3-2*j) * sqrt (E(j)**2 - sf_int%mi2(j)), 3)
          end do
          call sf_int%seed_kinematics (k)
       end if
    end if
  end subroutine sf_int_seed_energies
  
@ %def sf_int_seed_momenta
@ %def sf_int_seed_energies
@ Tell if in generator mode.  By default, this is false.  To be
overridden where appropriate; we may refer to the [[is_generator]]
method of the [[data]] component in the concrete type.
<<SF base: sf int: TBP>>=
  procedure :: is_generator => sf_int_is_generator
<<SF base: procedures>>=
  function sf_int_is_generator (sf_int) result (flag)
    class(sf_int_t), intent(in) :: sf_int
    logical :: flag
    flag = .false.
  end function sf_int_is_generator

@ %def sf_int_is_generator
@ Generate free parameters [[r]].  Parameters are free if they do not
correspond to integration parameters (i.e., are bound), but are
generated by the structure function object itself.  By default, all
parameters are bound, and the output values of this procedure will be
discarded.  With free parameters, we have to override this procedure.  

The value [[x_free]] is the renormalization factor of the total energy
that corresponds to the free parameters.  If there are no free
parameters, the procedure will not change its value, which starts as
unity.  Otherwise, the fraction is typically decreased, but may also
be increased in some cases.
<<SF base: sf int: TBP>>=
  procedure :: generate_free => sf_int_generate_free
<<SF base: procedures>>=
  subroutine sf_int_generate_free (sf_int, r, rb,  x_free)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(inout) :: x_free
    r = 0
    rb= 1
  end subroutine sf_int_generate_free
    
@ %def sf_int_generate_free
@ Complete the structure-function kinematics, derived from an input
parameter (array) $r$ between 0 and 1.  The interaction momenta are
calculated, and we return $x$ (the momentum fraction), and $f$ (the
Jacobian factor for the map $r\to x$), if [[map]] is set.

If the [[map]] flag is unset, $r$ and $x$ values will coincide, and $f$ will
become unity.  If it is set, the structure-function implementation chooses a
convenient mapping from $r$ to $x$ with Jacobian $f$.

In the [[inverse_kinematics]] variant, we exchange the intent of [[x]]
and [[r]].  The momenta are calculated only if the optional flag
[[set_momenta]] is present and set.
<<SF base: sf int: TBP>>=
  procedure (sf_int_complete_kinematics), deferred :: complete_kinematics
  procedure (sf_int_inverse_kinematics), deferred :: inverse_kinematics
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_int_complete_kinematics (sf_int, x, f, r, rb, map)
       import
       class(sf_int_t), intent(inout) :: sf_int
       real(default), dimension(:), intent(out) :: x
       real(default), intent(out) :: f
       real(default), dimension(:), intent(in) :: r
       real(default), dimension(:), intent(in) :: rb
       logical, intent(in) :: map
     end subroutine sf_int_complete_kinematics
  end interface
  
  abstract interface
     subroutine sf_int_inverse_kinematics (sf_int, x, f, r, rb, map, &
          set_momenta)
       import
       class(sf_int_t), intent(inout) :: sf_int
       real(default), dimension(:), intent(in) :: x
       real(default), intent(out) :: f
       real(default), dimension(:), intent(out) :: r
       real(default), dimension(:), intent(out) :: rb
       logical, intent(in) :: map
       logical, intent(in), optional :: set_momenta
     end subroutine sf_int_inverse_kinematics
  end interface
  
@ %def sf_int_complete_kinematics
@ %def sf_int_inverse_kinematics
@ Single splitting: compute momenta, given $x$ input parameters.  We
assume that the incoming momentum is set.  The status code is set to
[[SF_FAILED_KINEMATICS]] if
the $x$ array does not correspond to a valid momentum configuration.
Otherwise, it is updated to [[SF_DONE_KINEMATICS]].

We force the outgoing particle on-shell.  The on-shell projection is
determined by the [[on_shell_mode]].  The radiated particle should already be
on shell.
<<SF base: sf int: TBP>>=
  procedure :: split_momentum => sf_int_split_momentum
<<SF base: procedures>>=
  subroutine sf_int_split_momentum (sf_int, x, xb1)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(in) :: xb1
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    type(splitting_data_t) :: sd
    real(default) :: E1, E2
    logical :: fail
    if (sf_int%status >= SF_SEED_KINEMATICS) then
       k = interaction_get_momentum (sf_int%interaction_t, 1)
       call sd%init (k, &
            sf_int%mi2(1), sf_int%mr2(1), sf_int%mo2(1), &
            collinear = size (x) == 1)
       call sd%set_t_bounds (x(1), xb1)
       select case (size (x))
       case (1)
       case (3)
          if (sf_int%qmax_defined) then
             if (sf_int%qmin_defined) then
                call sd%sample_t (x(2), &
                     t0 = - sf_int%qmax(1) ** 2, t1 = - sf_int%qmin(1) ** 2)
             else
                call sd%sample_t (x(2), &
                     t0 = - sf_int%qmax(1) ** 2)
             end if
          else
             if (sf_int%qmin_defined) then
                call sd%sample_t (x(2), t1 = - sf_int%qmin(1) ** 2)
             else
                call sd%sample_t (x(2))
             end if
          end if
          call sd%sample_phi (x(3))
       case default
          call msg_bug ("Structure function: impossible number of parameters")
       end select
       q = sd%split_momentum (k)
       call on_shell (q, [sf_int%mr2, sf_int%mo2], &
            sf_int%on_shell_mode)
       call interaction_set_momenta (sf_int%interaction_t, &
            q, outgoing=.true.)
       E1 = energy (q(1))
       E2 = energy (q(2))
       fail = E1 < 0 .or. E2 < 0 &
            .or. E1 ** 2 < sf_int%mr2(1) &
            .or. E2 ** 2 < sf_int%mo2(1)
       if (fail) then
          sf_int%status = SF_FAILED_KINEMATICS
       else
          sf_int%status = SF_DONE_KINEMATICS
       end if
    end if
  end subroutine sf_int_split_momentum
    
@ %def sf_test_split_momentum
@ Pair splitting: two incoming momenta, two radiated, two outgoing.
This is simple because we insist on all momenta being collinear.
<<SF base: sf int: TBP>>=
  procedure :: split_momenta => sf_int_split_momenta
<<SF base: procedures>>=
  subroutine sf_int_split_momenta (sf_int, x, xb1)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), dimension(:), intent(in) :: xb1
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(4) :: q
    real(default), dimension(4) :: E
    logical :: fail
    if (sf_int%status >= SF_SEED_KINEMATICS) then
       select case (size (x))
       case (2)
       case default
          call msg_bug ("Pair structure function: recoil requested &
               &but not implemented yet")
       end select
       k(1) = interaction_get_momentum (sf_int%interaction_t, 1)
       k(2) = interaction_get_momentum (sf_int%interaction_t, 2)
       q(1:2) = xb1 * k
       q(3:4) = x * k
       select case (size (sf_int%mr2))
       case (2)
          call on_shell (q, &
               [sf_int%mr2(1), sf_int%mr2(2), &
               sf_int%mo2(1), sf_int%mo2(2)], &
               sf_int%on_shell_mode)
          call interaction_set_momenta (sf_int%interaction_t, &
               q, outgoing=.true.)
          E = energy (q)
          fail = any (E < 0) &
               .or. any (E(1:2) ** 2 < sf_int%mr2) &
               .or. any (E(3:4) ** 2 < sf_int%mo2)
       case default;  call msg_bug ("split momenta: incorrect use")
       end select
       if (fail) then
          sf_int%status = SF_FAILED_KINEMATICS
       else
          sf_int%status = SF_DONE_KINEMATICS
       end if
    end if
  end subroutine sf_int_split_momenta
    
@ %def sf_int_split_momenta
@ Pair spectrum: the reduced version of the previous splitting,
without radiated momenta.
<<SF base: sf int: TBP>>=
  procedure :: reduce_momenta => sf_int_reduce_momenta
<<SF base: procedures>>=
  subroutine sf_int_reduce_momenta (sf_int, x)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(2) :: q
    real(default), dimension(2) :: E
    logical :: fail
    if (sf_int%status >= SF_SEED_KINEMATICS) then
       select case (size (x))
       case (2)
       case default
          call msg_bug ("Pair spectrum: recoil requested &
               &but not implemented yet")
       end select
       k(1) = interaction_get_momentum (sf_int%interaction_t, 1)
       k(2) = interaction_get_momentum (sf_int%interaction_t, 2)
       q = x * k
       call on_shell (q, &
            [sf_int%mo2(1), sf_int%mo2(2)], &
            sf_int%on_shell_mode)
       call interaction_set_momenta (sf_int%interaction_t, &
            q, outgoing=.true.)
       E = energy (q)
       fail = any (E < 0) &
            .or. any (E ** 2 < sf_int%mo2)
       if (fail) then
          sf_int%status = SF_FAILED_KINEMATICS
       else
          sf_int%status = SF_DONE_KINEMATICS
       end if
    end if
  end subroutine sf_int_reduce_momenta
    
@ %def sf_int_reduce_momenta
@ The inverse procedure: we compute the [[x]] array from the momentum
configuration.  In an overriding TBP, we may also set internal data
that depend on this, for convenience.

NOTE: Here and above, the single-particle case is treated in detail,
allowing for non-collinearity and non-vanishing masses and nontrivial
momentum-transfer bounds.  For the pair case, we currently implement
only collinear splitting and assume massless particles.  This should
be improved.

NOTE: We should also improve this in the sense of extracting both $x$
and $\bar x$, where for the latter we may consult the beam remnant.
The current implementation is not sensitive to small $\bar x$ values.
<<SF base: sf int: TBP>>=
  procedure :: recover_x => sf_int_recover_x
  procedure :: base_recover_x => sf_int_recover_x
<<SF base: procedures>>=
  subroutine sf_int_recover_x (sf_int, x, x_free)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(inout), optional :: x_free
    type(vector4_t), dimension(:), allocatable :: k
    type(vector4_t), dimension(:), allocatable :: q
    type(splitting_data_t) :: sd
    if (sf_int%status >= SF_SEED_KINEMATICS) then
       allocate (k (interaction_get_n_in (sf_int%interaction_t)))
       allocate (q (interaction_get_n_out (sf_int%interaction_t)))
       k = interaction_get_momenta (sf_int%interaction_t, outgoing=.false.)
       q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
       select case (size (k))
       case (1)
          call sd%init (k(1), &
               sf_int%mi2(1), sf_int%mr2(1), sf_int%mo2(1), &
               collinear = size (x) == 1) 
          call sd%recover (k(1), q(2), sf_int%on_shell_mode)
          x(1) = sd%get_x ()
          select case (size (x))
          case (1)
          case (3)
             if (sf_int%qmax_defined) then
                if (sf_int%qmin_defined) then
                   call sd%inverse_t (x(2), &
                        t0 = - sf_int%qmax(1) ** 2, t1 = - sf_int%qmin(1) ** 2)
                else
                   call sd%inverse_t (x(2), &
                        t0 = - sf_int%qmax(1) ** 2)
                end if
             else
                if (sf_int%qmin_defined) then
                   call sd%inverse_t (x(2), t1 = - sf_int%qmin(1) ** 2)
                else
                   call sd%inverse_t (x(2)) 
                end if
             end if
             call sd%inverse_phi (x(3))
          case default
             call msg_bug ("Structure function: impossible number &
                  &of parameters")
          end select
       case (2)
          select case (size (x))
          case (2)
          case default
             call msg_bug ("Pair structure function: recoil requested &
                  &but not implemented yet")
          end select
          select case (sf_int%on_shell_mode)
          case (KEEP_ENERGY)
             select case (size (q))
             case (4)
                x = energy (q(3:4)) / energy (k)
             case (2)
                x = energy (q) / energy (k)
             end select
          case (KEEP_MOMENTUM)
             select case (size (q))
             case (4)
                x = longitudinal_part (q(3:4)) / longitudinal_part (k)
             case (2)
                x = longitudinal_part (q) / longitudinal_part (k)
             end select
          end select
       end select
    end if
  end subroutine sf_int_recover_x
  
@ %def sf_int_recover_x
@ Apply the structure function, i.e., evaluate the interaction.  For
the calculation, we may use the stored momenta, any further
information stored inside the [[sf_int]] implementation during
kinematics setup, and the given energy scale.  It may happen that for
the given kinematics the value is not defined.  This should be
indicated by the status code.
<<SF base: sf int: TBP>>=
  procedure (sf_int_apply), deferred :: apply
<<SF base: interfaces>>=
  abstract interface
     subroutine sf_int_apply (sf_int, scale)
       import
       class(sf_int_t), intent(inout) :: sf_int
       real(default), intent(in) :: scale
     end subroutine sf_int_apply
  end interface

@ %def sf_int_apply
@
\subsection{Accessing the structure function}
Return metadata.  Once [[interaction_t]] is rewritten in OO, some of this will
be inherited.

The number of outgoing is equal to the number of incoming particles.  The
radiated particles are the difference.
<<SF base: sf int: TBP>>=
  procedure :: get_n_in => sf_int_get_n_in
  procedure :: get_n_rad => sf_int_get_n_rad
  procedure :: get_n_out => sf_int_get_n_out
<<SF base: procedures>>=
  function sf_int_get_n_in (sf_int) result (n_in)
    class(sf_int_t), intent(in) :: sf_int
    integer :: n_in
    n_in = interaction_get_n_in (sf_int%interaction_t)
  end function sf_int_get_n_in
  
  function sf_int_get_n_rad (sf_int) result (n_rad)
    class(sf_int_t), intent(in) :: sf_int
    integer :: n_rad
    n_rad = interaction_get_n_out (sf_int%interaction_t) &
         - interaction_get_n_in (sf_int%interaction_t)
  end function sf_int_get_n_rad
  
  function sf_int_get_n_out (sf_int) result (n_out)
    class(sf_int_t), intent(in) :: sf_int
    integer :: n_out
    n_out = interaction_get_n_in (sf_int%interaction_t)
  end function sf_int_get_n_out
  
@ %def sf_int_get_n_in
@ %def sf_int_get_n_rad
@ %def sf_int_get_n_out
@ Number of matrix element entries in the interaction:
<<SF base: sf int: TBP>>=
  procedure :: get_n_states => sf_int_get_n_states
<<SF base: procedures>>=
  function sf_int_get_n_states (sf_int) result (n_states)
    class(sf_int_t), intent(in) :: sf_int
    integer :: n_states
    n_states = interaction_get_n_matrix_elements (sf_int%interaction_t)
  end function sf_int_get_n_states
  
@ %def sf_int_get_n_states
@ Return a specific state as a quantum-number array.
<<SF base: sf int: TBP>>=
  procedure :: get_state => sf_int_get_state
<<SF base: procedures>>=
  function sf_int_get_state (sf_int, i) result (qn)
    class(sf_int_t), intent(in) :: sf_int
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer, intent(in) :: i
    allocate (qn (interaction_get_n_tot (sf_int%interaction_t)))
    qn = interaction_get_quantum_numbers (sf_int%interaction_t, i)
  end function sf_int_get_state

@ %def sf_int_get_state
@ Return the matrix-element values for all states.  We can assume that
the matrix elements are real, so we take the real part.
<<SF base: sf int: TBP>>=
  procedure :: get_values => sf_int_get_values
<<SF base: procedures>>=
  subroutine sf_int_get_values (sf_int, value)
    class(sf_int_t), intent(in) :: sf_int
    real(default), dimension(:), intent(out) :: value
    integer :: i
    if (sf_int%status >= SF_EVALUATED) then
       do i = 1, size (value)
          value(i) = interaction_get_matrix_element &
               (sf_int%interaction_t, i)
       end do
    else
       value = 0
    end if
  end subroutine sf_int_get_values

@ %def sf_int_get_values
@ 
\subsection{Direct calculations}
Compute a structure function value (array) directly, given an array of $x$
values and a scale.  If the energy is also given, we initialize the
kinematics for that energy, otherwise take it from a previous run.

We assume that the [[E]] array has dimension [[n_in]], and the [[x]]
array has [[n_par]]. 
<<SF base: sf int: TBP>>=
  procedure :: compute_values => sf_int_compute_values
<<SF base: procedures>>=
  subroutine sf_int_compute_values (sf_int, value, x, xb, scale, E)
    class(sf_int_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: value
    real(default), dimension(:), intent(in) :: x
    real(default), dimension(:), intent(in) :: xb
    real(default), intent(in) :: scale
    real(default), dimension(:), intent(in), optional :: E
    real(default), dimension(size (x)) :: xx
    real(default) :: f
    if (present (E))  call sf_int%seed_kinematics (E)
    if (sf_int%status >= SF_SEED_KINEMATICS) then
       call sf_int%complete_kinematics (xx, f, x, xb, map=.false.)
       call sf_int%apply (scale)
       call sf_int%get_values (value)
       value = value * f
    else
       value = 0
    end if
  end subroutine sf_int_compute_values

@ %def sf_int_compute_values
@ Compute just a single value for one of the states, i.e., throw the
others away.
<<SF base: sf int: TBP>>=
  procedure :: compute_value => sf_int_compute_value
<<SF base: procedures>>=
  subroutine sf_int_compute_value &
       (sf_int, i_state, value, x, xb, scale, E)
    class(sf_int_t), intent(inout) :: sf_int
    integer, intent(in) :: i_state
    real(default), intent(out) :: value
    real(default), dimension(:), intent(in) :: x
    real(default), dimension(:), intent(in) :: xb
    real(default), intent(in) :: scale
    real(default), dimension(:), intent(in), optional :: E
    real(default), dimension(:), allocatable :: value_array
    if (sf_int%status >= SF_INITIAL) then
       allocate (value_array (sf_int%get_n_states ()))
       call sf_int%compute_values (value_array, x, xb, scale, E)
       value = value_array(i_state)
    else
       value = 0
    end if
  end subroutine sf_int_compute_value

@ %def sf_int_compute_value
@
\subsection{Structure-function instance}
This is a wrapper for [[sf_int_t]] objects, such that we can
build an array with different structure-function types.  The
structure-function contains an array (a sequence) of [[sf_int_t]]
objects.

The object, it holds the evaluator that connects the preceding part of the
structure-function chain to the current interaction.

It also stores the input and output parameter values for the
contained structure function.  The [[r]] array has a second dimension,
corresponding to the mapping channels in a multi-channel
configuration.  There is a Jacobian entry [[f]] for each channel.  The
corresponding logical array [[mapping]] tells whether we apply the
mapping appropriate for the current structure function in this channel.
The [[x]] parameter values (energy fractions) are common to all
channels. 
<<SF base: types>>=
  type :: sf_instance_t
     class(sf_int_t), allocatable :: int
     type(evaluator_t) :: eval
     real(default), dimension(:,:), allocatable :: r
     real(default), dimension(:,:), allocatable :: rb
     real(default), dimension(:), allocatable :: f
     logical, dimension(:), allocatable :: m
     real(default), dimension(:), allocatable :: x
  end type sf_instance_t
  
@ %def sf_instance_t
@
\subsection{Structure-function chain}
A chain is an array of structure functions [[sf]], initiated by a beam setup.
We do not use this directly for evaluation, but create instances with
copies of the contained interactions.

[[n_par]] is the total number of parameters that is necessary for
completely determining the structure-function chain.  [[n_bound]] is
the number of MC input parameters that are requested from the
integrator.  The difference of [[n_par]] and [[n_bound]] is the number
of free parameters, which are generated by a structure-function
object in generator mode.
<<SF base: public>>=
  public :: sf_chain_t
<<SF base: types>>=
  type, extends (beam_t) :: sf_chain_t
     type(beam_data_t), pointer :: beam_data => null ()
     integer :: n_in = 0
     integer :: n_strfun = 0
     integer :: n_par = 0
     integer :: n_bound = 0
     type(sf_instance_t), dimension(:), allocatable :: sf
     logical :: trace_enable = .false.
     integer :: trace_unit = 0
   contains
   <<SF base: sf chain: TBP>>
  end type sf_chain_t
     
@ %def sf_chain_t
@ Finalizer.
<<SF base: sf chain: TBP>>=
  procedure :: final => sf_chain_final
<<SF base: procedures>>=
  subroutine sf_chain_final (object)
    class(sf_chain_t), intent(inout) :: object
    integer :: i
    call object%final_tracing ()
    if (allocated (object%sf)) then 
       do i = 1, size (object%sf, 1)
          associate (sf => object%sf(i))
            if (allocated (sf%int)) then
               call sf%int%final ()
            end if
          end associate
       end do
    end if
    call beam_final (object%beam_t)
  end subroutine sf_chain_final

@ %def sf_chain_final
@ Output.
<<SF base: sf chain: TBP>>=
  procedure :: write => sf_chain_write
<<SF base: procedures>>=
  subroutine sf_chain_write (object, unit)
    class(sf_chain_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Incoming particles / structure-function chain:"
    if (associated (object%beam_data)) then
       write (u, "(3x,A,I0)")  "n_in      = ", object%n_in
       write (u, "(3x,A,I0)")  "n_strfun  = ", object%n_strfun
       write (u, "(3x,A,I0)")  "n_par     = ", object%n_par
       if (object%n_par /= object%n_bound) then
          write (u, "(3x,A,I0)")  "n_bound   = ", object%n_bound
       end if
       call beam_data_write (object%beam_data, u)
       call write_separator (u)
       call beam_write (object%beam_t, u)
       if (allocated (object%sf)) then
          do i = 1, object%n_strfun
             associate (sf => object%sf(i))
               call write_separator (u)
               if (allocated (sf%int)) then
                  call sf%int%write (u)
               else
                  write (u, "(1x,A)")  "SF instance: [undefined]"
               end if
             end associate
          end do
       end if
    else
       write (u, "(3x,A)")  "[undefined]"
    end if
  end subroutine sf_chain_write
  
@ %def sf_chain_write
@ Initialize: setup beams.  The [[beam_data]] target must remain valid
for the lifetime of the chain, since we just establish a pointer.  The
structure-function configuration array is used to initialize the
individual structure-function entries.  The target attribute is needed
because the [[sf_int]] entries establish pointers to the configuration data.
<<SF base: sf chain: TBP>>=
  procedure :: init => sf_chain_init
<<SF base: procedures>>=
  subroutine sf_chain_init (sf_chain, beam_data, sf_config)
    class(sf_chain_t), intent(out) :: sf_chain
    type(beam_data_t), intent(in), target :: beam_data
    type(sf_config_t), dimension(:), intent(in), optional, target :: sf_config
    integer :: i
    sf_chain%beam_data => beam_data
    sf_chain%n_in = beam_data_get_n_in (beam_data)
    call beam_init (sf_chain%beam_t, beam_data)
    if (present (sf_config)) then
       sf_chain%n_strfun = size (sf_config)
       allocate (sf_chain%sf (sf_chain%n_strfun))
       do i = 1, sf_chain%n_strfun
          call sf_chain%set_strfun (i, sf_config(i)%i, sf_config(i)%data)
       end do
    end if
  end subroutine sf_chain_init
  
@ %def sf_chain_init
@ Receive the beam momenta from a source to which the beam interaction
is linked.
<<SF base: sf chain: TBP>>=
  procedure :: receive_beam_momenta => sf_chain_receive_beam_momenta
<<SF base: procedures>>=
  subroutine sf_chain_receive_beam_momenta (sf_chain)
    class(sf_chain_t), intent(inout), target :: sf_chain
    type(interaction_t), pointer :: beam_int
    beam_int => sf_chain%get_beam_int_ptr ()
    call interaction_receive_momenta (beam_int)
  end subroutine sf_chain_receive_beam_momenta
  
@ %def sf_chain_receive_beam_momenta
@ Explicitly set the beam momenta.
<<SF base: sf chain: TBP>>=
  procedure :: set_beam_momenta => sf_chain_set_beam_momenta
<<SF base: procedures>>=
  subroutine sf_chain_set_beam_momenta (sf_chain, p)
    class(sf_chain_t), intent(inout) :: sf_chain
    type(vector4_t), dimension(:), intent(in) :: p
    call beam_set_momenta (sf_chain%beam_t, p)
  end subroutine sf_chain_set_beam_momenta

@ %def sf_chain_set_beam_momenta
@ Set a structure-function entry.  We use the [[data]] input to
allocate the [[int]] structure-function instance with appropriate
type, then initialize the entry.  The entry establishes a pointer to
[[data]].

The index [[i]] is the structure-function index in the chain.
<<SF base: sf chain: TBP>>=
  procedure :: set_strfun => sf_chain_set_strfun
<<SF base: procedures>>=
  subroutine sf_chain_set_strfun (sf_chain, i, beam_index, data)
    class(sf_chain_t), intent(inout) :: sf_chain
    integer, intent(in) :: i
    integer, dimension(:), intent(in) :: beam_index
    class(sf_data_t), intent(in), target :: data
    integer :: n_par, j
    n_par = data%get_n_par ()
    call data%allocate_sf_int (sf_chain%sf(i)%int)
    associate (sf_int => sf_chain%sf(i)%int)
      call sf_int%init (data)
      call sf_int%set_beam_index (beam_index)
      call sf_int%set_par_index &
           ([(j, j = sf_chain%n_par + 1, sf_chain%n_par + n_par)])
      sf_chain%n_par = sf_chain%n_par + n_par
      if (.not. data%is_generator ()) then
         sf_chain%n_bound = sf_chain%n_bound + n_par
      end if
    end associate
  end subroutine sf_chain_set_strfun
    
@ %def sf_chain_set_strfun
@ Return the number of structure-function parameters.
<<SF base: sf chain: TBP>>=
  procedure :: get_n_par => sf_chain_get_n_par
  procedure :: get_n_bound => sf_chain_get_n_bound
<<SF base: procedures>>=
  function sf_chain_get_n_par (sf_chain) result (n)
    class(sf_chain_t), intent(in) :: sf_chain
    integer :: n
    n = sf_chain%n_par
  end function sf_chain_get_n_par
  
  function sf_chain_get_n_bound (sf_chain) result (n)
    class(sf_chain_t), intent(in) :: sf_chain
    integer :: n
    n = sf_chain%n_bound
  end function sf_chain_get_n_bound
  
@ %def sf_chain_get_n_par
@ %def sf_chain_get_n_bound
@ Return a pointer to the beam interaction.
<<SF base: sf chain: TBP>>=
  procedure :: get_beam_int_ptr => sf_chain_get_beam_int_ptr
<<SF base: procedures>>=
  function sf_chain_get_beam_int_ptr (sf_chain) result (int)
    class(sf_chain_t), intent(in), target :: sf_chain
    type(interaction_t), pointer :: int
    int => beam_get_int_ptr (sf_chain%beam_t)
  end function sf_chain_get_beam_int_ptr
  
@ %def sf_chain_get_beam_int_ptr
@ Enable the trace feature: record structure function data (input
parameters, $x$ values, evaluation result) to an external file.
<<SF base: sf chain: TBP>>=
  procedure :: setup_tracing => sf_chain_setup_tracing
  procedure :: final_tracing => sf_chain_final_tracing
<<SF base: procedures>>=
  subroutine sf_chain_setup_tracing (sf_chain, file)
    class(sf_chain_t), intent(inout) :: sf_chain
    type(string_t), intent(in) :: file
    if (sf_chain%n_strfun > 0) then
       sf_chain%trace_enable = .true.
       sf_chain%trace_unit = free_unit ()
       open (sf_chain%trace_unit, file = char (file), action = "write", &
            status = "replace")
       call sf_chain%write_trace_header ()
    else
       call msg_error ("Beam structure: no structure functions, tracing &
            &disabled")
    end if
  end subroutine sf_chain_setup_tracing

  subroutine sf_chain_final_tracing (sf_chain)
    class(sf_chain_t), intent(inout) :: sf_chain
    if (sf_chain%trace_enable) then
       close (sf_chain%trace_unit)
       sf_chain%trace_enable = .false.
    end if
  end subroutine sf_chain_final_tracing

@ %def sf_chain_setup_tracing
@ %def sf_chain_final_tracing
@ Write the header for the tracing file.
<<SF base: sf chain: TBP>>=
  procedure :: write_trace_header => sf_chain_write_trace_header
<<SF base: procedures>>=
  subroutine sf_chain_write_trace_header (sf_chain)
    class(sf_chain_t), intent(in) :: sf_chain
    integer :: u
    if (sf_chain%trace_enable) then
       u = sf_chain%trace_unit
       write (u, "('# ',A)")  "WHIZARD output: &
            &structure-function sampling data"
       write (u, "('# ',A,1x,I0)")  "Number of sf records:", sf_chain%n_strfun
       write (u, "('# ',A,1x,I0)")  "Number of parameters:", sf_chain%n_par
       write (u, "('# ',A)")  "Columns: channel, p(n_par), x(n_par), f, Jac * f"
    end if
  end subroutine sf_chain_write_trace_header
    
@ %def sf_chain_write_trace_header
@ Write a record which collects the structure function data for the
current data point.  For the selected channel, we print first the
input integration parameters, then the $x$ values, then the
structure-function value summed over all quantum numbers, then the
structure function value times the mapping Jacobian.
<<SF base: sf chain: TBP>>=
  procedure :: trace => sf_chain_trace
<<SF base: procedures>>=
  subroutine sf_chain_trace (sf_chain, c_sel, p, x, f, sf_sum)
    class(sf_chain_t), intent(in) :: sf_chain
    integer, intent(in) :: c_sel
    real(default), dimension(:,:), intent(in) :: p
    real(default), dimension(:), intent(in) :: x
    real(default), dimension(:), intent(in) :: f
    real(default), intent(in) :: sf_sum
    integer :: u, i
    if (sf_chain%trace_enable) then
       u = sf_chain%trace_unit
       write (u, "(1x,I0)", advance="no")  c_sel
       write (u, "(2x)", advance="no")
       do i = 1, sf_chain%n_par
          write (u, "(1x," // FMT_17 // ")", advance="no")  p(i,c_sel)
       end do
       write (u, "(2x)", advance="no")
       do i = 1, sf_chain%n_par
          write (u, "(1x," // FMT_17 // ")", advance="no")  x(i)
       end do
       write (u, "(2x)", advance="no")
       write (u, "(2(1x," // FMT_17 // "))")  sf_sum, f(c_sel) * sf_sum
    end if
  end subroutine sf_chain_trace
  
@ %def sf_chain_trace
@
\subsection{Chain instances}
A structure-function chain instance contains copies of the
interactions in the configuration chain, suitably linked to each other
and connected by evaluators.

After initialization, [[out_sf]] should point, for each beam, to the
last structure function that affects this beam.  [[out_sf_i]] should
indicate the index of the corresponding outgoing particle within that
structure-function interaction.

Analogously, [[out_eval]] is the last evaluator in the
structure-function chain, which contains the complete set of outgoing
particles. [[out_eval_i]] should indicate the index of the outgoing
particles, within that evaluator, which will initiate the collision.

When calculating actual kinematics, we fill the [[p]], [[r]], and
[[x]] arrays and the [[f]] factor.  The [[p]] array denotes the MC
input parameters as they come from the random-number generator.  The
[[r]] array results from applying global mappings.  The [[x]] array
results from applying structure-function local mappings.  The $x$
values can be interpreted directly as momentum fractions (or angle
fractions, where recoil is involved).  The [[f]] factor is the
Jacobian that results from applying all mappings.

The [[mapping]] entry may store a global mapping that is applied to a
combination of $x$ values and structure functions, as opposed to mappings that
affect only a single structure function.  It is applied before the latter
mappings, in the transformation from the [[p]] array to the [[r]] array.  For
parameters affected by this mapping, we should ensure that they are not
involved in a local mapping.
<<SF base: public>>=
  public :: sf_chain_instance_t
<<SF base: types>>=
  type, extends (beam_t) :: sf_chain_instance_t
     type(sf_chain_t), pointer :: config => null ()
     integer :: status = SF_UNDEFINED
     type(sf_instance_t), dimension(:), allocatable :: sf
     integer, dimension(:), allocatable :: out_sf
     integer, dimension(:), allocatable :: out_sf_i
     integer :: out_eval = 0
     integer, dimension(:), allocatable :: out_eval_i
     integer :: selected_channel = 0
     real(default), dimension(:,:), allocatable :: p, pb
     real(default), dimension(:,:), allocatable :: r, rb
     real(default), dimension(:), allocatable :: f
     real(default), dimension(:), allocatable :: x
     logical, dimension(:), allocatable :: bound
     real(default) :: x_free = 1
     type(sf_channel_t), dimension(:), allocatable :: channel
   contains
   <<SF base: sf chain instance: TBP>>
  end type sf_chain_instance_t
     
@ %def sf_chain_instance_t
@ Finalizer.
<<SF base: sf chain instance: TBP>>=
  procedure :: final => sf_chain_instance_final
<<SF base: procedures>>=
  subroutine sf_chain_instance_final (object)
    class(sf_chain_instance_t), intent(inout) :: object
    integer :: i
    if (allocated (object%sf)) then
       do i = 1, size (object%sf, 1)
          associate (sf => object%sf(i))
            if (allocated (sf%int)) then
               call evaluator_final (sf%eval)
               call sf%int%final ()
            end if
          end associate
       end do
    end if
    call beam_final (object%beam_t)
  end subroutine sf_chain_instance_final

@ %def sf_chain_instance_final
@ Output.

Note: nagfor 5.3.1 appears to be slightly confused with the allocation
status.  We check both for allocation and nonzero size.
<<SF base: sf chain instance: TBP>>=
  procedure :: write => sf_chain_instance_write
<<SF base: procedures>>=
  subroutine sf_chain_instance_write (object, unit)
    class(sf_chain_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i, c
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "Structure-function chain instance:"
    call write_sf_status (object%status, u)
    if (allocated (object%out_sf)) then
       write (u, "(3x,A)", advance="no")  "outgoing (interactions) ="
       do i = 1, size (object%out_sf)
          write (u, "(1x,I0,':',I0)", advance="no") &
               object%out_sf(i), object%out_sf_i(i)
       end do
       write (u, *)
    end if
    if (object%out_eval /= 0) then
       write (u, "(3x,A)", advance="no")  "outgoing (evaluators)   ="
       do i = 1, size (object%out_sf)
          write (u, "(1x,I0,':',I0)", advance="no") &
               object%out_eval, object%out_eval_i(i)
       end do
       write (u, *)
    end if
    if (allocated (object%sf)) then
       if (size (object%sf) /= 0) then
          write (u, "(1x,A)")  "Structure-function parameters:"
          do c = 1, size (object%f)
             write (u, "(1x,A,I0,A)", advance="no")  "Channel #", c, ":"
             if (c == object%selected_channel) then
                write (u, "(1x,A)")  "[selected]"
             else
                write (u, *)
             end if
             write (u, "(3x,A,9(1x,F9.7))")  "p =", object%p(:,c)
             write (u, "(3x,A,9(1x,F9.7))")  "r =", object%r(:,c)
             write (u, "(3x,A,9(1x,ES13.7))")  "f =", object%f(c)
             write (u, "(3x,A)", advance="no") "m ="
             call object%channel(c)%write (u)
          end do
          write (u, "(3x,A,9(1x,F9.7))")  "x =", object%x
          if (.not. all (object%bound)) then
             write (u, "(3x,A,9(1x,L1))")  "bound =", object%bound
          end if
       end if
    end if
    call write_separator (u)
    call beam_write (object%beam_t, u)
    if (allocated (object%sf)) then
       do i = 1, size (object%sf)
          associate (sf => object%sf(i))
            call write_separator (u)
            if (allocated (sf%int)) then
               if (allocated (sf%r)) then
                  write (u, "(1x,A)")  "Structure-function parameters:"
                  do c = 1, size (sf%f)
                     write (u, "(1x,A,I0,A)", advance="no")  "Channel #", c, ":"
                     if (c == object%selected_channel) then
                        write (u, "(1x,A)")  "[selected]"
                     else
                        write (u, *)
                     end if
                     write (u, "(3x,A,9(1x,F9.7))")  "r =", sf%r(:,c)
                     write (u, "(3x,A,9(1x,ES13.7))")  "f =", sf%f(c)
                     write (u, "(3x,A,9(1x,L1,7x))") "m =", sf%m(c)
                  end do
                  write (u, "(3x,A,9(1x,F9.7))")  "x =", sf%x
               end if
               call sf%int%write (u)
               if (.not. evaluator_is_empty (sf%eval)) then
                     call sf%eval%write (u)
               end if
            end if
          end associate
       end do
    end if
  end subroutine sf_chain_instance_write
  
@ %def sf_chain_instance_write
@ Initialize.  This creates a copy of the interactions in the
configuration chain, assumed to be properly initialized.  In the copy,
we allocate the [[p]] etc.\ arrays.

The brute-force assignment of the [[sf]] component would be
straightforward, but at least gfortran 4.6.3 would like a more
fine-grained copy.  In any case, the copy is deep
as far as allocatables are concerned, but for the contained
[[interaction_t]] objects the copy is shallow, as long as we do not
bind defined assignment to the type.  Therefore, we have to re-assign
the [[interaction_t]] components explicitly, this time calling the
proper defined assignment.  Furthermore, we allocate the parameter
arrays for each structure function.
<<SF base: sf chain instance: TBP>>=
  procedure :: init => sf_chain_instance_init
<<SF base: procedures>>=
  subroutine sf_chain_instance_init (chain, config, n_channel)
    class(sf_chain_instance_t), intent(out), target :: chain
    type(sf_chain_t), intent(in), target :: config
    integer, intent(in) :: n_channel
    integer :: i, j
    integer :: n_par_tot, n_par, n_strfun
    chain%config => config
    n_strfun = config%n_strfun
    chain%beam_t = config%beam_t
    allocate (chain%out_sf (config%n_in), chain%out_sf_i (config%n_in))
    allocate (chain%out_eval_i (config%n_in))
    chain%out_sf = 0
    chain%out_sf_i = [(i, i = 1, config%n_in)]
    chain%out_eval_i = chain%out_sf_i
    n_par_tot = 0
    if (n_strfun /= 0) then
       allocate (chain%sf (n_strfun))
       do i = 1, n_strfun
          associate (sf => chain%sf(i))
            allocate (sf%int, source=config%sf(i)%int)
            sf%int%interaction_t = config%sf(i)%int%interaction_t
            n_par = size (sf%int%par_index)
            allocate (sf%r (n_par, n_channel));  sf%r = 0
            allocate (sf%rb(n_par, n_channel));  sf%rb= 0
            allocate (sf%f (n_channel));         sf%f = 0
            allocate (sf%m (n_channel));         sf%m = .false.
            allocate (sf%x (n_par));             sf%x = 0
            n_par_tot = n_par_tot + n_par
          end associate
       end do
       allocate (chain%p (n_par_tot, n_channel));  chain%p = 0
       allocate (chain%pb(n_par_tot, n_channel));  chain%pb= 0
       allocate (chain%r (n_par_tot, n_channel));  chain%r = 0
       allocate (chain%rb(n_par_tot, n_channel));  chain%rb= 0
       allocate (chain%f (n_channel));             chain%f = 0
       allocate (chain%x (n_par_tot));             chain%x = 0
       call allocate_sf_channels &
            (chain%channel, n_channel=n_channel, n_strfun=n_strfun)
    end if
    allocate (chain%bound (n_par_tot), source = .true.)
    do i = 1, n_strfun
       associate (sf => chain%sf(i))
         if (sf%int%is_generator ()) then
            do j = 1, size (sf%int%par_index)
               chain%bound(sf%int%par_index(j)) = .false.
            end do
         end if
       end associate
    end do
    chain%status = SF_INITIAL
  end subroutine sf_chain_instance_init
  
@ %def sf_chain_instance_init
@ Manually select a channel.
<<SF base: sf chain instance: TBP>>=
  procedure :: select_channel => sf_chain_instance_select_channel
<<SF base: procedures>>=
  subroutine sf_chain_instance_select_channel (chain, channel)
    class(sf_chain_instance_t), intent(inout) :: chain
    integer, intent(in), optional :: channel
    if (present (channel)) then
       chain%selected_channel = channel
    else
       chain%selected_channel = 0
    end if
  end subroutine sf_chain_instance_select_channel
  
@ %def sf_chain_instance_select_channel
@ Copy a channel-mapping object to the structure-function
chain instance.  We assume that assignment is sufficient, i.e., any
non-static components of the [[channel]] object are allocatable und
thus recursively copied.

After the copy, we extract the single-entry mappings and activate them
for the individual structure functions.  If there is a multi-entry
mapping, we obtain the corresponding MC parameter indices and set them
in the copy of the channel object.
<<SF base: sf chain instance: TBP>>=
  procedure :: set_channel => sf_chain_instance_set_channel
<<SF base: procedures>>=
  subroutine sf_chain_instance_set_channel (chain, c, channel)
    class(sf_chain_instance_t), intent(inout) :: chain
    integer, intent(in) :: c
    type(sf_channel_t), intent(in) :: channel
    integer :: i, j, k
    if (chain%status >= SF_INITIAL) then
       chain%channel(c) = channel
       j = 0
       do i = 1, chain%config%n_strfun
          associate (sf => chain%sf(i))
            sf%m(c) = channel%is_single_mapping (i)
            if (channel%is_multi_mapping (i)) then
               do k = 1, size (sf%int%beam_index)
                  j = j + 1
                  call chain%channel(c)%set_par_index (j, sf%int%par_index(k))
               end do
            end if
          end associate
       end do
       chain%status = SF_INITIAL
    end if
  end subroutine sf_chain_instance_set_channel
  
@ %def sf_chain_instance_set_channel
@ Link the interactions in the chain.  First, link the beam instance
to its template in the configuration chain, which should have the
appropriate momenta fixed.

Then, we follow the chain via the
arrays [[out_sf]] and [[out_sf_i]].  The arrays are (up to)
two-dimensional, the entries correspond to the beam particle(s).
For each beam, the entry [[out_sf]] points to the last interaction
that affected this beam, and [[out_sf_i]] is the
out-particle index within that interaction.  For the initial beam,
[[out_sf]] is zero by definition.

For each entry in the chain, we scan the affected beams (one or two).
We look for [[out_sf]] and link the out-particle there to the
corresponding in-particle in the current interaction.  Then, we update
the entry in [[out_sf]] and [[out_sf_i]] to point to the current
interaction.
<<SF base: sf chain instance: TBP>>=
  procedure :: link_interactions => sf_chain_instance_link_interactions
<<SF base: procedures>>=
  subroutine sf_chain_instance_link_interactions (chain)
    class(sf_chain_instance_t), intent(inout), target :: chain
    type(interaction_t), pointer :: int
    integer :: i, j, b
    if (chain%status >= SF_INITIAL) then
       do b = 1, chain%config%n_in
          int => beam_get_int_ptr (chain%beam_t)
          call interaction_set_source_link (int, b, &
               chain%config%beam_t, b)
       end do
       if (allocated (chain%sf)) then
          do i = 1, size (chain%sf)
             associate (sf_int => chain%sf(i)%int)
               do j = 1, size (sf_int%beam_index)
                  b = sf_int%beam_index(j)
                  call link (sf_int%interaction_t, b, sf_int%incoming(j))
                  chain%out_sf(b) = i
                  chain%out_sf_i(b) = sf_int%outgoing(j)
               end do
             end associate
          end do
       end if
       chain%status = SF_DONE_LINKS
    end if
  contains
    subroutine link (int, b, in_index)
      type(interaction_t), intent(inout) :: int
      integer, intent(in) :: b, in_index
      integer :: i
      i = chain%out_sf(b)
      select case (i)
      case (0)
         call interaction_set_source_link (int, in_index, &
              chain%beam_t, chain%out_sf_i(b))
      case default
         call interaction_set_source_link (int, in_index, &
              chain%sf(i)%int%interaction_t, chain%out_sf_i(b))
      end select
    end subroutine link
  end subroutine sf_chain_instance_link_interactions
  
@ %def sf_chain_instance_link_interactions
@ Exchange the quantum-number masks between the interactions in the
chain, so we can combine redundant entries and detect any obvious mismatch.

We proceed first in the forward direction and then backwards again.

After this is finished, we finalize initialization by calling the
[[setup_constants]] method, which prepares constant data that depend on the
matrix element structure.
<<SF base: sf chain instance: TBP>>=
  procedure :: exchange_mask => sf_chain_exchange_mask
<<SF base: procedures>>=
  subroutine sf_chain_exchange_mask (chain)
    class(sf_chain_instance_t), intent(inout), target :: chain
    type(interaction_t), pointer :: int
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask
    integer :: i
    if (chain%status >= SF_DONE_LINKS) then
       if (allocated (chain%sf)) then
          int => beam_get_int_ptr (chain%beam_t)
          allocate (mask (interaction_get_n_out (int)))
          mask = interaction_get_mask (int)
          if (size (chain%sf) /= 0) then
             do i = 1, size (chain%sf) - 1
                call interaction_exchange_mask (chain%sf(i)%int%interaction_t)
             end do
             do i = size (chain%sf), 1, -1
                call interaction_exchange_mask (chain%sf(i)%int%interaction_t)
             end do
             if (any (mask .neqv. interaction_get_mask (int))) then
                chain%status = SF_FAILED_MASK
                return
             end if
             do i = 1, size (chain%sf)
                call chain%sf(i)%int%setup_constants ()
             end do
          end if
       end if
       chain%status = SF_DONE_MASK
    end if
  end subroutine sf_chain_exchange_mask
  
@ %def sf_chain_exchange_mask
@ Initialize the evaluators that connect the interactions in the
chain.
<<SF base: sf chain instance: TBP>>=
  procedure :: init_evaluators => sf_chain_instance_init_evaluators
<<SF base: procedures>>=
  subroutine sf_chain_instance_init_evaluators (chain)
    class(sf_chain_instance_t), intent(inout), target :: chain
    type(interaction_t), pointer :: int
    type(quantum_numbers_mask_t) :: mask
    integer :: i
    if (chain%status >= SF_DONE_MASK) then
       if (allocated (chain%sf)) then
          if (size (chain%sf) /= 0) then
             mask = new_quantum_numbers_mask (.false., .false., .true.)
             int => beam_get_int_ptr (chain%beam_t)
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call evaluator_init_product (sf%eval, &
                       int, sf%int%interaction_t, &
                       mask)
                  if (evaluator_is_empty (sf%eval)) then
                     chain%status = SF_FAILED_CONNECTIONS
                     return
                  end if
                  int => evaluator_get_int_ptr (sf%eval)
                end associate
             end do
             call find_outgoing_particles ()
          end if
       end if
       chain%status = SF_DONE_CONNECTIONS
    end if
  contains
  <<SF base: init evaluators: find outgoing particles>>
  end subroutine sf_chain_instance_init_evaluators
  
@ %def sf_chain_instance_init_evaluators
@ This is an internal subroutine of the previous one: After evaluators
are set, trace the outgoing particles to the last evaluator.  We only
need the first channel, all channels are equivalent for this purpose.

For each beam, the outgoing particle is located by [[out_sf]] (the
structure-function object where it originates) and [[out_sf_i]] (the
index within that object).  This particle is referenced by the
corresponding evaluator, which in turn is referenced by the next
evaluator, until we are at the end of the chain.  We can trace back
references by [[interaction_find_link]].  Knowing that [[out_eval]] is
the index of the last evaluator, we thus determine [[out_eval_i]], the
index of the outgoing particle within that evaluator.
<<SF base: init evaluators: find outgoing particles>>=
  subroutine find_outgoing_particles ()
    type(interaction_t), pointer :: int, int_next
    integer :: i, j, out_sf, out_i
    chain%out_eval = size (chain%sf)
    do j = 1, size (chain%out_eval_i)
       out_sf = chain%out_sf(j)
       out_i = chain%out_sf_i(j)
       if (out_sf == 0) then
          int => beam_get_int_ptr (chain%beam_t)
          out_sf = 1
       else
          int => chain%sf(out_sf)%int%interaction_t
       end if
       do i = out_sf, chain%out_eval
          int_next => evaluator_get_int_ptr (chain%sf(i)%eval)
          out_i = interaction_find_link (int_next, int, out_i)
          int => int_next
       end do
       chain%out_eval_i(j) = out_i
    end do
  end subroutine find_outgoing_particles
@ %def find_outgoing_particles
@ Compute the kinematics in the chain instance.  We can assume that
the seed momenta are set in the configuration beams.  Scanning the
chain, we first transfer the incoming momenta.  Then, the use up the MC input
parameter array [[p]] to compute the radiated and outgoing momenta.

In the multi-channel case, [[c_sel]] is the channel which we use for
computing the kinematics and the [[x]] values.  In the other channels,
we invert the kinematics in order to recover the corresponding rows in
the [[r]] array, and the Jacobian [[f]].

We first apply any global mapping to transform the input [[p]] into
the array [[r]].  This is then given to the structure functions which
compute the final array [[x]] and Jacobian factors [[f]], which we
multiply to obtain the overall Jacobian.
<<SF base: sf chain instance: TBP>>=
  procedure :: compute_kinematics => sf_chain_instance_compute_kinematics
<<SF base: procedures>>=
  subroutine sf_chain_instance_compute_kinematics (chain, c_sel, p_in)
    class(sf_chain_instance_t), intent(inout), target :: chain
    integer, intent(in) :: c_sel
    real(default), dimension(:), intent(in) :: p_in
    type(interaction_t), pointer :: int
    real(default) :: f_mapping
    logical, dimension(size (chain%bound)) :: bound
    integer :: i, j, c
    if (chain%status >= SF_DONE_CONNECTIONS) then
       call chain%select_channel (c_sel)
       int => beam_get_int_ptr (chain%beam_t)
       call interaction_receive_momenta (int)
       if (allocated (chain%sf)) then
          if (size (chain%sf) /= 0) then
             forall (i = 1:size (chain%sf))  chain%sf(i)%int%status = SF_INITIAL
             !!! Bug in nagfor 5.3.1(907), fixed in 5.3.1(982)
             ! chain%p (:,c_sel) = unpack (p_in, chain%bound, 0._default)
             !!! Workaround:
             bound = chain%bound
             chain%p (:,c_sel) = unpack (p_in, bound, 0._default)
             chain%pb(:,c_sel) = 1 - chain%p(:,c_sel)
             chain%f = 1
             chain%x_free = 1
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call sf%int%generate_free (sf%r(:,c_sel), sf%rb(:,c_sel), &
                       chain%x_free)
                  do j = 1, size (sf%x)
                     if (.not. chain%bound(sf%int%par_index(j))) then
                        chain%p (sf%int%par_index(j),c_sel) = sf%r (j,c_sel)
                        chain%pb(sf%int%par_index(j),c_sel) = sf%rb(j,c_sel)
                     end if
                  end do
                end associate
             end do
             if (allocated (chain%channel(c_sel)%multi_mapping)) then
                call chain%channel(c_sel)%multi_mapping%compute &
                     (chain%r(:,c_sel), chain%rb(:,c_sel), &
                      f_mapping, &
                      chain%p(:,c_sel), chain%pb(:,c_sel), &
                      chain%x_free)
                chain%f(c_sel) = f_mapping
             else
                chain%r (:,c_sel) = chain%p (:,c_sel)
                chain%rb(:,c_sel) = chain%pb(:,c_sel)
                chain%f(c_sel) = 1
             end if
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call sf%int%seed_kinematics ()
                  do j = 1, size (sf%x)
                     sf%r (j,c_sel) = chain%r (sf%int%par_index(j),c_sel)
                     sf%rb(j,c_sel) = chain%rb(sf%int%par_index(j),c_sel)
                  end do
                  call sf%int%complete_kinematics &
                       (sf%x, sf%f(c_sel), sf%r(:,c_sel), sf%rb(:,c_sel), &
                        sf%m(c_sel))
                  do j = 1, size (sf%x)
                     chain%x(sf%int%par_index(j)) = sf%x(j)
                  end do
                  if (sf%int%status <= SF_FAILED_KINEMATICS) then
                     chain%status = SF_FAILED_KINEMATICS
                     return
                  end if
                  do c = 1, size (sf%f)
                     if (c /= c_sel) then
                        call sf%int%inverse_kinematics &
                             (sf%x, sf%f(c), sf%r(:,c), sf%rb(:,c), sf%m(c))
                        do j = 1, size (sf%x)
                           chain%r (sf%int%par_index(j),c) = sf%r (j,c)
                           chain%rb(sf%int%par_index(j),c) = sf%rb(j,c)
                        end do
                     end if
                     chain%f(c) = chain%f(c) * sf%f(c)
                  end do
                  if (.not. evaluator_is_empty (sf%eval)) then
                     call evaluator_receive_momenta (sf%eval)
                  end if
                end associate
             end do
             do c = 1, size (chain%f)
                if (c /= c_sel) then
                   if (allocated (chain%channel(c)%multi_mapping)) then
                      call chain%channel(c)%multi_mapping%inverse &
                           (chain%r(:,c), chain%rb(:,c), &
                            f_mapping, &
                            chain%p(:,c), chain%pb(:,c), &
                            chain%x_free)
                      chain%f(c) = chain%f(c) * f_mapping
                   else
                      chain%p (:,c) = chain%r (:,c)
                      chain%pb(:,c) = chain%rb(:,c)
                   end if
                end if
             end do
          end if
       end if
       chain%status = SF_DONE_KINEMATICS
    end if
  end subroutine sf_chain_instance_compute_kinematics
  
@ %def sf_chain_instance_compute_kinematics
@ This is a variant of the previous procedure.  We know the $x$ parameters and
reconstruct the momenta and the MC input parameters [[p]].  We do not need to
select a channel.

Note: this is probably redundant, since the method we actually want
starts from the momenta, recovers all $x$ parameters, and then
inverts mappings.  See below [[recover_kinematics]].
<<SF base: sf chain instance: TBP>>=
  procedure :: inverse_kinematics => sf_chain_instance_inverse_kinematics
<<SF base: procedures>>=
  subroutine sf_chain_instance_inverse_kinematics (chain, x)
    class(sf_chain_instance_t), intent(inout), target :: chain
    real(default), dimension(:), intent(in) :: x
    type(interaction_t), pointer :: int
    real(default) :: f_mapping
    integer :: i, j, c
    if (chain%status >= SF_DONE_CONNECTIONS) then
       call chain%select_channel ()
       int => beam_get_int_ptr (chain%beam_t)
       call interaction_receive_momenta (int)
       if (allocated (chain%sf)) then
          chain%f = 1
          if (size (chain%sf) /= 0) then
             forall (i = 1:size (chain%sf))  chain%sf(i)%int%status = SF_INITIAL
             chain%x = x
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call sf%int%seed_kinematics ()
                  do j = 1, size (sf%x)
                     sf%x(j) = chain%x(sf%int%par_index(j))
                  end do
                  do c = 1, size (sf%f)
                     call sf%int%inverse_kinematics &
                          (sf%x, sf%f(c), sf%r(:,c), sf%rb(:,c), sf%m(c), c==1)
                     chain%f(c) = chain%f(c) * sf%f(c)
                     do j = 1, size (sf%x)
                        chain%r (sf%int%par_index(j),c) = sf%r (j,c)
                        chain%rb(sf%int%par_index(j),c) = sf%rb(j,c)
                     end do
                  end do
                  if (.not. evaluator_is_empty (sf%eval)) then
                     call evaluator_receive_momenta (sf%eval)
                  end if
                end associate
             end do
             do c = 1, size (chain%f)
                if (allocated (chain%channel(c)%multi_mapping)) then
                   call chain%channel(c)%multi_mapping%inverse &
                        (chain%r(:,c), chain%rb(:,c), &
                        f_mapping, &
                        chain%p(:,c), chain%pb(:,c), &
                        chain%x_free)
                   chain%f(c) = chain%f(c) * f_mapping
                else
                   chain%p (:,c) = chain%r (:,c)
                   chain%pb(:,c) = chain%rb(:,c)
                end if
             end do
          end if
       end if
       chain%status = SF_DONE_KINEMATICS
    end if
  end subroutine sf_chain_instance_inverse_kinematics
  
@ %def sf_chain_instance_inverse_kinematics
@ Recover the kinematics: assuming that the last evaluator has
been filled with a valid set of momenta, we travel the momentum links
backwards and fill the preceding evaluators and, as a side effect,
interactions.  We stop at the beam interaction.

After all momenta are set, apply the [[inverse_kinematics]] procedure
above, suitably modified, to recover the $x$ and $p$ parameters and
the Jacobian factors.

The [[c_sel]] (channel) argument is just used to mark a selected
channel for the records, otherwise the recovery procedure is
independent of this.
<<SF base: sf chain instance: TBP>>=
  procedure :: recover_kinematics => sf_chain_instance_recover_kinematics
<<SF base: procedures>>=
  subroutine sf_chain_instance_recover_kinematics (chain, c_sel)
    class(sf_chain_instance_t), intent(inout), target :: chain
    integer, intent(in) :: c_sel
    real(default) :: f_mapping
    integer :: i, j, c
    if (chain%status >= SF_DONE_CONNECTIONS) then
       call chain%select_channel (c_sel)
       if (allocated (chain%sf)) then
          do i = size (chain%sf), 1, -1
             associate (sf => chain%sf(i))
               if (.not. evaluator_is_empty (sf%eval)) then
                  call evaluator_send_momenta (sf%eval)
               end if
             end associate
          end do
          chain%f = 1
          if (size (chain%sf) /= 0) then
             forall (i = 1:size (chain%sf))  chain%sf(i)%int%status = SF_INITIAL
             chain%x_free = 1
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call sf%int%seed_kinematics ()
                  call sf%int%recover_x (sf%x, chain%x_free)
                  do j = 1, size (sf%x)
                     chain%x(sf%int%par_index(j)) = sf%x(j)
                  end do
                  do c = 1, size (sf%f)
                     call sf%int%inverse_kinematics &
                          (sf%x, sf%f(c), sf%r(:,c), sf%rb(:,c), sf%m(c), c==1)
                     chain%f(c) = chain%f(c) * sf%f(c)
                     do j = 1, size (sf%x)
                        chain%r (sf%int%par_index(j),c) = sf%r (j,c)
                        chain%rb(sf%int%par_index(j),c) = sf%rb(j,c)
                     end do
                  end do
                end associate
             end do
             do c = 1, size (chain%f)
                if (allocated (chain%channel(c)%multi_mapping)) then
                   call chain%channel(c)%multi_mapping%inverse &
                        (chain%r(:,c), chain%rb(:,c), &
                        f_mapping, &
                        chain%p(:,c), chain%pb(:,c), &
                        chain%x_free)
                   chain%f(c) = chain%f(c) * f_mapping
                else
                   chain%p (:,c) = chain%r (:,c)
                   chain%pb(:,c) = chain%rb(:,c)
                end if
             end do
          end if
       end if
       chain%status = SF_DONE_KINEMATICS
    end if
  end subroutine sf_chain_instance_recover_kinematics

@ %def sf_chain_instance_recover_kinematics
@ Return the initial beam momenta to their source, thus completing
kinematics recovery.  Obviously, this works as a side effect.
<<SF base: sf chain instance: TBP>>=
  procedure :: return_beam_momenta => sf_chain_instance_return_beam_momenta
<<SF base: procedures>>=
  subroutine sf_chain_instance_return_beam_momenta (chain)
    class(sf_chain_instance_t), intent(in), target :: chain
    type(interaction_t), pointer :: int
    if (chain%status >= SF_DONE_KINEMATICS) then
       int => beam_get_int_ptr (chain%beam_t)
       call interaction_send_momenta (int)
    end if
  end subroutine sf_chain_instance_return_beam_momenta

@ %def sf_chain_instance_return_beam_momenta
@ Evaluate all interactions in the chain and the product evaluators.
We provide a [[scale]] argument that is given to all structure
functions in the chain.
<<SF base: sf chain instance: TBP>>=
  procedure :: evaluate => sf_chain_instance_evaluate
<<SF base: procedures>>=
  subroutine sf_chain_instance_evaluate (chain, scale)
    class(sf_chain_instance_t), intent(inout), target :: chain
    real(default), intent(in) :: scale
    type(interaction_t), pointer :: out_int
    real(default) :: sf_sum
    integer :: i
    if (chain%status >= SF_DONE_KINEMATICS) then
       if (allocated (chain%sf)) then
          if (size (chain%sf) /= 0) then
             do i = 1, size (chain%sf)
                associate (sf => chain%sf(i))
                  call sf%int%apply (scale)
                  if (sf%int%status <= SF_FAILED_EVALUATION) then
                     chain%status = SF_FAILED_EVALUATION
                     return
                  end if
                  if (.not. evaluator_is_empty (sf%eval)) then
                     call sf%eval%evaluate ()
                  end if
                end associate
             end do
             out_int => chain%get_out_int_ptr ()
             sf_sum = interaction_sum (out_int)
             call chain%config%trace &
                  (chain%selected_channel, chain%p, chain%x, chain%f, sf_sum)
          end if
       end if
       chain%status = SF_EVALUATED
    end if
  end subroutine sf_chain_instance_evaluate
  
@ %def sf_chain_instance_evaluate
@ 
\subsection{Access to the chain instance}
Transfer the outgoing momenta to the array [[p]].  We assume that
array sizes match.
<<SF base: sf chain instance: TBP>>=
  procedure :: get_out_momenta => sf_chain_instance_get_out_momenta
<<SF base: procedures>>=
  subroutine sf_chain_instance_get_out_momenta (chain, p)
    class(sf_chain_instance_t), intent(in), target :: chain
    type(vector4_t), dimension(:), intent(out) :: p
    type(interaction_t), pointer :: int
    integer :: i, j
    if (chain%status >= SF_DONE_KINEMATICS) then
       do j = 1, size (chain%out_sf)
          i = chain%out_sf(j)
          select case (i)
          case (0)
             int => beam_get_int_ptr (chain%beam_t)
          case default
             int => chain%sf(i)%int%interaction_t
          end select
          p(j) = interaction_get_momentum (int, chain%out_sf_i(j))
       end do
    end if
  end subroutine sf_chain_instance_get_out_momenta
       
@ %def sf_chain_instance_get_out_momenta
@ Return a pointer to the last evaluator in the chain (to the interaction).
<<SF base: sf chain instance: TBP>>=
  procedure :: get_out_int_ptr => sf_chain_instance_get_out_int_ptr
<<SF base: procedures>>=
  function sf_chain_instance_get_out_int_ptr (chain) result (int)
    class(sf_chain_instance_t), intent(in), target :: chain
    type(interaction_t), pointer :: int
    if (chain%out_eval == 0) then
       int => beam_get_int_ptr (chain%beam_t)
    else
       int => evaluator_get_int_ptr (chain%sf(chain%out_eval)%eval)
    end if
  end function sf_chain_instance_get_out_int_ptr

@ %def sf_chain_instance_get_out_int_ptr
@ Return the index of the [[j]]-th outgoing particle, within the last
evaluator.
<<SF base: sf chain instance: TBP>>=
  procedure :: get_out_i => sf_chain_instance_get_out_i
<<SF base: procedures>>=
  function sf_chain_instance_get_out_i (chain, j) result (i)
    class(sf_chain_instance_t), intent(in) :: chain
    integer, intent(in) :: j
    integer :: i
    i = chain%out_eval_i(j)
  end function sf_chain_instance_get_out_i
    
@ %def sf_chain_instance_get_out_i
@ Return the mask for the outgoing particle(s), within the last evaluator.
<<SF base: sf chain instance: TBP>>=
  procedure :: get_out_mask => sf_chain_instance_get_out_mask
<<SF base: procedures>>=
  function sf_chain_instance_get_out_mask (chain) result (mask)
    class(sf_chain_instance_t), intent(in), target :: chain
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask
    type(interaction_t), pointer :: int
    allocate (mask (chain%config%n_in))
    int => chain%get_out_int_ptr ()
    mask = interaction_get_mask (int, chain%out_eval_i)
  end function sf_chain_instance_get_out_mask
    
@ %def sf_chain_instance_get_out_mask
@ Return the array of MC input parameters that corresponds to channel [[c]].
This is the [[p]] array, the parameters before all mappings.

The [[p]] array may be deallocated.  This should correspond to a
zero-size [[r]] argument, so nothing to do then.
<<SF base: sf chain instance: TBP>>=
  procedure :: get_mcpar => sf_chain_instance_get_mcpar
<<SF base: procedures>>=
  subroutine sf_chain_instance_get_mcpar (chain, c, r)
    class(sf_chain_instance_t), intent(in) :: chain
    integer, intent(in) :: c
    real(default), dimension(:), intent(out) :: r
    if (allocated (chain%p))  r = pack (chain%p(:,c), chain%bound)
  end subroutine sf_chain_instance_get_mcpar
  
@ %def sf_chain_instance_get_mcpar
@ Return the Jacobian factor that corresponds to channel [[c]].
<<SF base: sf chain instance: TBP>>=
  procedure :: get_f => sf_chain_instance_get_f
<<SF base: procedures>>=
  function sf_chain_instance_get_f (chain, c) result (f)
    class(sf_chain_instance_t), intent(in) :: chain
    integer, intent(in) :: c
    real(default) :: f
    if (allocated (chain%f)) then
       f = chain%f(c)
    else
       f = 1
    end if
  end function sf_chain_instance_get_f
  
@ %def sf_chain_instance_get_f
@ Return the evaluation status.
<<SF base: sf chain instance: TBP>>=
  procedure :: get_status => sf_chain_instance_get_status
<<SF base: procedures>>=
  function sf_chain_instance_get_status (chain) result (status)
    class(sf_chain_instance_t), intent(in) :: chain
    integer :: status
    status = chain%status
  end function sf_chain_instance_get_status
  
@ %def sf_chain_instance_get_status
@
\subsection{Unit tests}
<<SF base: public>>=
  public :: sf_base_test
<<SF base: tests>>=
  subroutine sf_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<SF base: execute tests>>
  end subroutine sf_base_test
  
@ %def sf_base_test
@
\subsection{Test implementation: structure function}
This is a template for the actual structure-function implementation
which will be defined in separate modules.

\subsubsection{Configuration data}
The test structure function uses the [[Test]] model.  It describes a
scalar within an arbitrary initial particle, which is given in the
initialization.  The radiated particle is also a scalar, the same one,
but we set its mass artificially to zero.
<<SF base: public>>=
  public :: sf_test_data_t
<<SF base: test types>>=
  type, extends (sf_data_t) :: sf_test_data_t
     class(model_data_t), pointer :: model => null ()
     integer :: mode = 0
     type(flavor_t) :: flv_in
     type(flavor_t) :: flv_out
     type(flavor_t) :: flv_rad
     real(default) :: m = 0
     logical :: collinear = .true.
     real(default), dimension(:), allocatable :: qbounds
   contains
   <<SF base: sf test data: TBP>>
  end type sf_test_data_t
  
@ %def sf_test_data_t
@ Output.
<<SF base: sf test data: TBP>>=
  procedure :: write => sf_test_data_write
<<SF base: procedures>>=
  subroutine sf_test_data_write (data, unit, verbose)
    class(sf_test_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "SF test data:"
    write (u, "(3x,A,A)") "model     = ", char (data%model%get_name ())
    write (u, "(3x,A)", advance="no") "incoming  = "
    call flavor_write (data%flv_in, u);  write (u, *)
    write (u, "(3x,A)", advance="no") "outgoing  = "
    call flavor_write (data%flv_out, u);  write (u, *)
    write (u, "(3x,A)", advance="no") "radiated  = "
    call flavor_write (data%flv_rad, u);  write (u, *)
    write (u, "(3x,A," // FMT_19 // ")")  "mass      = ", data%m
    write (u, "(3x,A,L1)")  "collinear = ", data%collinear
    if (.not. data%collinear .and. allocated (data%qbounds)) then
       write (u, "(3x,A," // FMT_19 // ")")  "qmin      = ", data%qbounds(1)
       write (u, "(3x,A," // FMT_19 // ")")  "qmax      = ", data%qbounds(2)
    end if
  end subroutine sf_test_data_write
    
@ %def sf_test_data_write
@ Initialization.
<<SF base: sf test data: TBP>>=
  procedure :: init => sf_test_data_init
<<SF base: procedures>>=
  subroutine sf_test_data_init (data, model, pdg_in, collinear, qbounds, mode)
    class(sf_test_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    logical, intent(in), optional :: collinear
    real(default), dimension(2), intent(in), optional :: qbounds
    integer, intent(in), optional :: mode
    data%model => model
    if (present (mode))  data%mode = mode
    if (pdg_array_get (pdg_in, 1) /= 25) then
       call msg_fatal ("Test spectrum function: input flavor must be 's'")
    end if
    call flavor_init (data%flv_in, 25, model)
    data%m = flavor_get_mass (data%flv_in)
    if (present (collinear))  data%collinear = collinear
    call flavor_init (data%flv_out, 25, model)
    call flavor_init (data%flv_rad, 25, model)
    if (present (qbounds)) then
       allocate (data%qbounds (2))
       data%qbounds = qbounds
    end if
  end subroutine sf_test_data_init
  
@ %def sf_test_data_init
@ Return the number of parameters: 1 if only consider collinear
splitting, 3 otherwise.
<<SF base: sf test data: TBP>>=
  procedure :: get_n_par => sf_test_data_get_n_par
<<SF base: procedures>>=
  function sf_test_data_get_n_par (data) result (n)
    class(sf_test_data_t), intent(in) :: data
    integer :: n
    if (data%collinear) then
       n = 1
    else
       n = 3
    end if
  end function sf_test_data_get_n_par
  
@ %def sf_test_data_get_n_par
@ Return the outgoing particle PDG code: 25
<<SF base: sf test data: TBP>>=
  procedure :: get_pdg_out => sf_test_data_get_pdg_out
<<SF base: procedures>>=
  subroutine sf_test_data_get_pdg_out (data, pdg_out)
    class(sf_test_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    pdg_out(1) = 25
  end subroutine sf_test_data_get_pdg_out
  
@ %def sf_test_data_get_pdg_out
@ Allocate the matching interaction.
<<SF base: sf test data: TBP>>=
  procedure :: allocate_sf_int => sf_test_data_allocate_sf_int
<<SF base: procedures>>=
  subroutine sf_test_data_allocate_sf_int (data, sf_int)
    class(sf_test_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (sf_test_t :: sf_int)
  end subroutine sf_test_data_allocate_sf_int
    
@ %def sf_test_data_allocate_sf_int
@
\subsubsection{Interaction}
<<SF base: test types>>=
  type, extends (sf_int_t) :: sf_test_t
     type(sf_test_data_t), pointer :: data => null ()
     real(default) :: x = 0
   contains
   <<SF base: sf test int: TBP>>
  end type sf_test_t
  
@ %def sf_test_t
@ Type string: constant
<<SF base: sf test int: TBP>>=
  procedure :: type_string => sf_test_type_string
<<SF base: procedures>>=
  function sf_test_type_string (object) result (string)
    class(sf_test_t), intent(in) :: object
    type(string_t) :: string
    string = "Test"
  end function sf_test_type_string
  
@ %def sf_test_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF base: sf test int: TBP>>=
  procedure :: write => sf_test_write
<<SF base: procedures>>=
  subroutine sf_test_write (object, unit, testflag)
    class(sf_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "SF test data: [undefined]"
    end if
  end subroutine sf_test_write
    
@ %def sf_test_write
@ Initialize.  We know that [[data]] will be of concrete type
[[sf_test_data_t]], but we have to cast this explicitly.

For this implementation, we set the incoming and outgoing masses equal
to the physical particle mass, but keep the radiated mass zero.

Optionally, we can provide minimum and maximum values for the momentum
transfer.
<<SF base: sf test int: TBP>>=
  procedure :: init => sf_test_init
<<SF base: procedures>>=
  subroutine sf_test_init (sf_int, data)
    class(sf_test_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(3) :: mask
    type(helicity_t) :: hel0
    type(quantum_numbers_t), dimension(3) :: qn
    mask = new_quantum_numbers_mask (.false., .false., .false.)
    select type (data)
    type is (sf_test_data_t)
       if (allocated (data%qbounds)) then
          call sf_int%base_init (mask, &
               [data%m**2], [0._default], [data%m**2], &
               [data%qbounds(1)], [data%qbounds(2)])
       else
          call sf_int%base_init (mask, &
               [data%m**2], [0._default], [data%m**2])
       end if
       sf_int%data => data
       call helicity_init (hel0, 0)
       call quantum_numbers_init (qn(1), data%flv_in,  hel0)
       call quantum_numbers_init (qn(2), data%flv_rad, hel0)
       call quantum_numbers_init (qn(3), data%flv_out, hel0)
       call interaction_add_state (sf_int%interaction_t, qn)
       call interaction_freeze (sf_int%interaction_t)
       call sf_int%set_incoming ([1])
       call sf_int%set_radiated ([2])
       call sf_int%set_outgoing ([3])
    end select
    sf_int%status = SF_INITIAL
  end subroutine sf_test_init

@ %def sf_test_init
@ Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ and consequently $f(r)=2r$.
<<SF base: sf test int: TBP>>=
  procedure :: complete_kinematics => sf_test_complete_kinematics
<<SF base: procedures>>=
  subroutine sf_test_complete_kinematics (sf_int, x, f, r, rb, map)
    class(sf_test_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default) :: xb1
    if (map) then
       x(1) = r(1)**2
       f = 2 * r(1)
    else
       x(1) = r(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    if (size (x) == 3)  x(2:3) = r(2:3)
    call sf_int%split_momentum (x, xb1)
    sf_int%x = x(1)
    select case (sf_int%status)
    case (SF_FAILED_KINEMATICS);  f = 0
    end select
  end subroutine sf_test_complete_kinematics

@ %def sf_test_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF base: sf test int: TBP>>=
  procedure :: inverse_kinematics => sf_test_inverse_kinematics
<<SF base: procedures>>=
  subroutine sf_test_inverse_kinematics (sf_int, x, f, r, rb, map, set_momenta)
    class(sf_test_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       r(1) = sqrt (x(1))
       f = 2 * r(1)
    else
       r(1) = x(1)
       f = 1
    end if
    xb1 = 1 - x(1)
    if (size (x) == 3)  r(2:3) = x(2:3)
    rb = 1 - r
    sf_int%x = x(1)
    if (set_mom) then
       call sf_int%split_momentum (x, xb1)
       select case (sf_int%status)
       case (SF_FAILED_KINEMATICS);  f = 0
       end select
    end if
  end subroutine sf_test_inverse_kinematics

@ %def sf_test_inverse_kinematics
@ Apply the structure function.  The matrix element becomes unity and
the application always succeeds.

If the [[mode]] indicator is one, the matrix element is equal to the
parameter~$x$.
<<SF base: sf test int: TBP>>=
  procedure :: apply => sf_test_apply
<<SF base: procedures>>=
  subroutine sf_test_apply (sf_int, scale)
    class(sf_test_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    select case (sf_int%data%mode)
    case (0)
       call interaction_set_matrix_element (sf_int%interaction_t, &
            cmplx (1._default, kind=default))
    case (1)
       call interaction_set_matrix_element (sf_int%interaction_t, &
            cmplx (sf_int%x, kind=default))
    end select
    sf_int%status = SF_EVALUATED
  end subroutine sf_test_apply

@ %def sf_test_apply
@
\subsection{Test implementation: pair spectrum}
Another template, this time for a incoming particle pair, splitting
into two radiated and two outgoing particles.

\subsubsection{Configuration data}
For simplicity, the spectrum contains two mirror images of the
previous structure-function configuration: the incoming and all
outgoing particles are test scalars.

We have two versions, one with radiated particles, one without.
<<SF base: test types>>=
  type, extends (sf_data_t) :: sf_test_spectrum_data_t
     class(model_data_t), pointer :: model => null ()
     type(flavor_t) :: flv_in
     type(flavor_t) :: flv_out
     type(flavor_t) :: flv_rad
     logical :: with_radiation = .true.
     real(default) :: m = 0
   contains
   <<SF base: sf test spectrum data: TBP>>
  end type sf_test_spectrum_data_t
  
@ %def sf_test_spectrum_data_t
@ Output.
<<SF base: sf test spectrum data: TBP>>=
  procedure :: write => sf_test_spectrum_data_write
<<SF base: procedures>>=
  subroutine sf_test_spectrum_data_write (data, unit, verbose)
    class(sf_test_spectrum_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "SF test spectrum data:"
    write (u, "(3x,A,A)") "model     = ", char (data%model%get_name ())
    write (u, "(3x,A)", advance="no") "incoming  = "
    call flavor_write (data%flv_in, u);  write (u, *)
    write (u, "(3x,A)", advance="no") "outgoing  = "
    call flavor_write (data%flv_out, u);  write (u, *)
    write (u, "(3x,A)", advance="no") "radiated  = "
    call flavor_write (data%flv_rad, u);  write (u, *)
    write (u, "(3x,A," // FMT_19 // ")")  "mass      = ", data%m
  end subroutine sf_test_spectrum_data_write
    
@ %def sf_test_spectrum_data_write
@ Initialization.
<<SF base: sf test spectrum data: TBP>>=
  procedure :: init => sf_test_spectrum_data_init
<<SF base: procedures>>=
  subroutine sf_test_spectrum_data_init (data, model, pdg_in, with_radiation)
    class(sf_test_spectrum_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    logical, intent(in) :: with_radiation
    data%model => model
    data%with_radiation = with_radiation
    if (pdg_array_get (pdg_in, 1) /= 25) then
       call msg_fatal ("Test structure function: input flavor must be 's'")
    end if
    call flavor_init (data%flv_in, 25, model)
    data%m = flavor_get_mass (data%flv_in)
    call flavor_init (data%flv_out, 25, model)
    if (with_radiation) then
       call flavor_init (data%flv_rad, 25, model)
    end if
  end subroutine sf_test_spectrum_data_init
  
@ %def sf_test_spectrum_data_init
@ Return the number of parameters: 2, since we have only collinear
splitting here.
<<SF base: sf test spectrum data: TBP>>=
  procedure :: get_n_par => sf_test_spectrum_data_get_n_par
<<SF base: procedures>>=
  function sf_test_spectrum_data_get_n_par (data) result (n)
    class(sf_test_spectrum_data_t), intent(in) :: data
    integer :: n
    n = 2
  end function sf_test_spectrum_data_get_n_par
  
@ %def sf_test_spectrum_data_get_n_par
@ Return the outgoing particle PDG codes: 25
<<SF base: sf test spectrum data: TBP>>=
  procedure :: get_pdg_out => sf_test_spectrum_data_get_pdg_out
<<SF base: procedures>>=
  subroutine sf_test_spectrum_data_get_pdg_out (data, pdg_out)
    class(sf_test_spectrum_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    pdg_out(1) = 25
    pdg_out(2) = 25
  end subroutine sf_test_spectrum_data_get_pdg_out
  
@ %def sf_test_spectrum_data_get_pdg_out
@ Allocate the matching interaction.
<<SF base: sf test spectrum data: TBP>>=
  procedure :: allocate_sf_int => &
       sf_test_spectrum_data_allocate_sf_int
<<SF base: procedures>>=
  subroutine sf_test_spectrum_data_allocate_sf_int (data, sf_int)
    class(sf_test_spectrum_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (sf_test_spectrum_t :: sf_int)
  end subroutine sf_test_spectrum_data_allocate_sf_int
    
@ %def sf_test_spectrum_data_allocate_sf_int
@
\subsubsection{Interaction}
<<SF base: test types>>=
  type, extends (sf_int_t) :: sf_test_spectrum_t
     type(sf_test_spectrum_data_t), pointer :: data => null ()
   contains
   <<SF base: sf test spectrum: TBP>>
  end type sf_test_spectrum_t
  
@ %def sf_test_spectrum_t
<<SF base: sf test spectrum: TBP>>=
  procedure :: type_string => sf_test_spectrum_type_string
<<SF base: procedures>>=
  function sf_test_spectrum_type_string (object) result (string)
    class(sf_test_spectrum_t), intent(in) :: object
    type(string_t) :: string
    string = "Test Spectrum"
  end function sf_test_spectrum_type_string
  
@ %def sf_test_spectrum_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF base: sf test spectrum: TBP>>=
  procedure :: write => sf_test_spectrum_write
<<SF base: procedures>>=
  subroutine sf_test_spectrum_write (object, unit, testflag)
    class(sf_test_spectrum_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "SF test spectrum data: [undefined]"
    end if
  end subroutine sf_test_spectrum_write
    
@ %def sf_test_spectrum_write
@ Initialize.  We know that [[data]] will be of concrete type
[[sf_test_spectrum_data_t]], but we have to cast this explicitly.

For this implementation, we set the incoming and outgoing masses equal
to the physical particle mass, but keep the radiated mass zero.

Optionally, we can provide minimum and maximum values for the momentum
transfer.
<<SF base: sf test spectrum: TBP>>=
  procedure :: init => sf_test_spectrum_init
<<SF base: procedures>>=
  subroutine sf_test_spectrum_init (sf_int, data)
    class(sf_test_spectrum_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(6) :: mask
    type(helicity_t) :: hel0
    type(quantum_numbers_t), dimension(6) :: qn
    mask = new_quantum_numbers_mask (.false., .false., .false.)
    select type (data)
    type is (sf_test_spectrum_data_t)
       if (data%with_radiation) then
          call sf_int%base_init (mask(1:6), &
               [data%m**2, data%m**2], &
               [0._default, 0._default], &
               [data%m**2, data%m**2])
          sf_int%data => data
          call helicity_init (hel0, 0)
          call quantum_numbers_init (qn(1), data%flv_in,  hel0)
          call quantum_numbers_init (qn(2), data%flv_in,  hel0)
          call quantum_numbers_init (qn(3), data%flv_rad, hel0)
          call quantum_numbers_init (qn(4), data%flv_rad, hel0)
          call quantum_numbers_init (qn(5), data%flv_out, hel0)
          call quantum_numbers_init (qn(6), data%flv_out, hel0)
          call interaction_add_state (sf_int%interaction_t, qn(1:6))
          call sf_int%set_incoming ([1,2])
          call sf_int%set_radiated ([3,4])
          call sf_int%set_outgoing ([5,6])
       else
          call sf_int%base_init (mask(1:4), &
               [data%m**2, data%m**2], &
               [real(default) :: ], &
               [data%m**2, data%m**2])
          sf_int%data => data
          call helicity_init (hel0, 0)
          call quantum_numbers_init (qn(1), data%flv_in,  hel0)
          call quantum_numbers_init (qn(2), data%flv_in,  hel0)
          call quantum_numbers_init (qn(3), data%flv_out, hel0)
          call quantum_numbers_init (qn(4), data%flv_out, hel0)
          call interaction_add_state (sf_int%interaction_t, qn(1:4))
          call sf_int%set_incoming ([1,2])
          call sf_int%set_outgoing ([3,4])
       end if
       call interaction_freeze (sf_int%interaction_t)
    end select
    sf_int%status = SF_INITIAL
  end subroutine sf_test_spectrum_init

@ %def sf_test_spectrum_init
@ Set kinematics.  If [[map]] is unset, the $r$ and $x$ values
coincide, and the Jacobian $f(r)$ is trivial.

If [[map]] is set, we are asked to provide an efficient mapping.
For the test case, we set $x=r^2$ (as above) for both $x$ parameters
and consequently $f(r)=4r_1r_2$.

<<SF base: sf test spectrum: TBP>>=
  procedure :: complete_kinematics => sf_test_spectrum_complete_kinematics
<<SF base: procedures>>=
  subroutine sf_test_spectrum_complete_kinematics (sf_int, x, f, r, rb, map)
    class(sf_test_spectrum_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    real(default), dimension(2) :: xb1
    if (map) then
       x = r**2
       f = 4 * r(1) * r(2)
    else
       x = r
       f = 1
    end if
    if (sf_int%data%with_radiation) then
       xb1 = 1 - x
       call sf_int%split_momenta (x, xb1)
    else
       call sf_int%reduce_momenta (x)
    end if
    select case (sf_int%status)
    case (SF_FAILED_KINEMATICS);  f = 0
    end select
  end subroutine sf_test_spectrum_complete_kinematics

@ %def sf_test_spectrum_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF base: sf test spectrum: TBP>>=
  procedure :: inverse_kinematics => sf_test_spectrum_inverse_kinematics
<<SF base: procedures>>=
  subroutine sf_test_spectrum_inverse_kinematics &
       (sf_int, x, f, r, rb, map, set_momenta)
    class(sf_test_spectrum_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    real(default), dimension(2) :: xb1
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    if (map) then
       r = sqrt (x)
       f = 4 * r(1) * r(2)
    else
       r = x
       f = 1
    end if
    rb = 1 - r
    if (set_mom)  then
       if (sf_int%data%with_radiation) then
          xb1 = 1 - x
          call sf_int%split_momenta (x, xb1)
       else
          call sf_int%reduce_momenta (x)
       end if
       select case (sf_int%status)
       case (SF_FAILED_KINEMATICS);  f = 0
       end select
    end if
  end subroutine sf_test_spectrum_inverse_kinematics

@ %def sf_test_spectrum_inverse_kinematics
@ Apply the structure function.  The matrix element becomes unity and
the application always succeeds.
<<SF base: sf test spectrum: TBP>>=
  procedure :: apply => sf_test_spectrum_apply
<<SF base: procedures>>=
  subroutine sf_test_spectrum_apply (sf_int, scale)
    class(sf_test_spectrum_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    call interaction_set_matrix_element (sf_int%interaction_t, &
         cmplx (1._default, kind=default))
    sf_int%status = SF_EVALUATED
  end subroutine sf_test_spectrum_apply

@ %def sf_test_spectrum_apply
@
\subsection{Test implementation: generator spectrum}
A generator for two beams, no radiation (for simplicity).

\subsubsection{Configuration data}
For simplicity, the spectrum contains two mirror images of the
previous structure-function configuration: the incoming and all
outgoing particles are test scalars.

We have two versions, one with radiated particles, one without.
<<SF base: test types>>=
  type, extends (sf_data_t) :: sf_test_generator_data_t
     class(model_data_t), pointer :: model => null ()
     type(flavor_t) :: flv_in
     type(flavor_t) :: flv_out
     type(flavor_t) :: flv_rad
     real(default) :: m = 0
   contains
   <<SF base: sf test generator data: TBP>>
  end type sf_test_generator_data_t
  
@ %def sf_test_generator_data_t
@ Output.
<<SF base: sf test generator data: TBP>>=
  procedure :: write => sf_test_generator_data_write
<<SF base: procedures>>=
  subroutine sf_test_generator_data_write (data, unit, verbose)
    class(sf_test_generator_data_t), intent(in) :: data
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "SF test generator data:"
    write (u, "(3x,A,A)") "model     = ", char (data%model%get_name ())
    write (u, "(3x,A)", advance="no") "incoming  = "
    call flavor_write (data%flv_in, u);  write (u, *)
    write (u, "(3x,A)", advance="no") "outgoing  = "
    call flavor_write (data%flv_out, u);  write (u, *)
    write (u, "(3x,A," // FMT_19 // ")")  "mass      = ", data%m
  end subroutine sf_test_generator_data_write
    
@ %def sf_test_generator_data_write
@ Initialization.
<<SF base: sf test generator data: TBP>>=
  procedure :: init => sf_test_generator_data_init
<<SF base: procedures>>=
  subroutine sf_test_generator_data_init (data, model, pdg_in)
    class(sf_test_generator_data_t), intent(out) :: data
    class(model_data_t), intent(in), target :: model
    type(pdg_array_t), intent(in) :: pdg_in
    data%model => model
    if (pdg_array_get (pdg_in, 1) /= 25) then
       call msg_fatal ("Test generator: input flavor must be 's'")
    end if
    call flavor_init (data%flv_in, 25, model)
    data%m = flavor_get_mass (data%flv_in)
    call flavor_init (data%flv_out, 25, model)
  end subroutine sf_test_generator_data_init
  
@ %def sf_test_generator_data_init
@ This structure function is a generator.
<<SF base: sf test generator data: TBP>>=
  procedure :: is_generator => sf_test_generator_data_is_generator
<<SF base: procedures>>=
  function sf_test_generator_data_is_generator (data) result (flag)
    class(sf_test_generator_data_t), intent(in) :: data
    logical :: flag
    flag = .true.
  end function sf_test_generator_data_is_generator
  
@ %def sf_test_generator_data_is_generator
@ Return the number of parameters: 2, since we have only collinear
splitting here.
<<SF base: sf test generator data: TBP>>=
  procedure :: get_n_par => sf_test_generator_data_get_n_par
<<SF base: procedures>>=
  function sf_test_generator_data_get_n_par (data) result (n)
    class(sf_test_generator_data_t), intent(in) :: data
    integer :: n
    n = 2
  end function sf_test_generator_data_get_n_par
  
@ %def sf_test_generator_data_get_n_par
@ Return the outgoing particle PDG codes: 25
<<SF base: sf test generator data: TBP>>=
  procedure :: get_pdg_out => sf_test_generator_data_get_pdg_out
<<SF base: procedures>>=
  subroutine sf_test_generator_data_get_pdg_out (data, pdg_out)
    class(sf_test_generator_data_t), intent(in) :: data
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_out
    pdg_out(1) = 25
    pdg_out(2) = 25
  end subroutine sf_test_generator_data_get_pdg_out
  
@ %def sf_test_generator_data_get_pdg_out
@ Allocate the matching interaction.
<<SF base: sf test generator data: TBP>>=
  procedure :: allocate_sf_int => &
       sf_test_generator_data_allocate_sf_int
<<SF base: procedures>>=
  subroutine sf_test_generator_data_allocate_sf_int (data, sf_int)
    class(sf_test_generator_data_t), intent(in) :: data
    class(sf_int_t), intent(inout), allocatable :: sf_int
    allocate (sf_test_generator_t :: sf_int)
  end subroutine sf_test_generator_data_allocate_sf_int
    
@ %def sf_test_generator_data_allocate_sf_int
@
\subsubsection{Interaction}
<<SF base: test types>>=
  type, extends (sf_int_t) :: sf_test_generator_t
     type(sf_test_generator_data_t), pointer :: data => null ()
   contains
   <<SF base: sf test generator: TBP>>
  end type sf_test_generator_t
  
@ %def sf_test_generator_t
<<SF base: sf test generator: TBP>>=
  procedure :: type_string => sf_test_generator_type_string
<<SF base: procedures>>=
  function sf_test_generator_type_string (object) result (string)
    class(sf_test_generator_t), intent(in) :: object
    type(string_t) :: string
    string = "Test Generator"
  end function sf_test_generator_type_string
  
@ %def sf_test_generator_type_string
@ Output.  Call the interaction routine after displaying the configuration.
<<SF base: sf test generator: TBP>>=
  procedure :: write => sf_test_generator_write
<<SF base: procedures>>=
  subroutine sf_test_generator_write (object, unit, testflag)
    class(sf_test_generator_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%data)) then
       call object%data%write (u)
       call object%base_write (u, testflag)
    else
       write (u, "(1x,A)")  "SF test generator data: [undefined]"
    end if
  end subroutine sf_test_generator_write
    
@ %def sf_test_generator_write
@ Initialize.  We know that [[data]] will be of concrete type
[[sf_test_generator_data_t]], but we have to cast this explicitly.

For this implementation, we set the incoming and outgoing masses equal
to the physical particle mass.  No radiation.
<<SF base: sf test generator: TBP>>=
  procedure :: init => sf_test_generator_init
<<SF base: procedures>>=
  subroutine sf_test_generator_init (sf_int, data)
    class(sf_test_generator_t), intent(out) :: sf_int
    class(sf_data_t), intent(in), target :: data
    type(quantum_numbers_mask_t), dimension(4) :: mask
    type(helicity_t) :: hel0
    type(quantum_numbers_t), dimension(4) :: qn
    mask = new_quantum_numbers_mask (.false., .false., .false.)
    select type (data)
    type is (sf_test_generator_data_t)
       call sf_int%base_init (mask(1:4), &
            [data%m**2, data%m**2], &
            [real(default) :: ], &
            [data%m**2, data%m**2])
       sf_int%data => data
       call helicity_init (hel0, 0)
       call quantum_numbers_init (qn(1), data%flv_in,  hel0)
       call quantum_numbers_init (qn(2), data%flv_in,  hel0)
       call quantum_numbers_init (qn(3), data%flv_out, hel0)
       call quantum_numbers_init (qn(4), data%flv_out, hel0)
       call interaction_add_state (sf_int%interaction_t, qn(1:4))
       call sf_int%set_incoming ([1,2])
       call sf_int%set_outgoing ([3,4])
       call interaction_freeze (sf_int%interaction_t)
    end select
    sf_int%status = SF_INITIAL
  end subroutine sf_test_generator_init

@ %def sf_test_generator_init
@ This structure function is a generator.
<<SF base: sf test generator: TBP>>=
  procedure :: is_generator => sf_test_generator_is_generator
<<SF base: procedures>>=
  function sf_test_generator_is_generator (sf_int) result (flag)
    class(sf_test_generator_t), intent(in) :: sf_int
    logical :: flag
    flag = sf_int%data%is_generator ()
  end function sf_test_generator_is_generator
  
@ %def sf_test_generator_is_generator
@ Generate free parameters.  This mock generator always produces the
nubmers 0.8 and 0.5.
<<SF base: sf test generator: TBP>>=
  procedure :: generate_free => sf_test_generator_generate_free
<<SF base: procedures>>=
  subroutine sf_test_generator_generate_free (sf_int, r, rb,  x_free)
    class(sf_test_generator_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: r, rb
    real(default), intent(inout) :: x_free
    r = [0.8, 0.5]
    rb= 1 - r
    x_free = x_free * product (r)
  end subroutine sf_test_generator_generate_free
    
@ %def sf_test_generator_generate_free
@ Recover momentum fractions.  Since the x values are free, we also set the [[x_free]] parameter.
<<SF base: sf test generator: TBP>>=
  procedure :: recover_x => sf_test_generator_recover_x
<<SF base: procedures>>=
  subroutine sf_test_generator_recover_x (sf_int, x, x_free)
    class(sf_test_generator_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(inout), optional :: x_free
    call sf_int%base_recover_x (x)
    if (present (x_free))  x_free = x_free * product (x)
  end subroutine sf_test_generator_recover_x
  
@ %def sf_test_generator_recover_x
@ Set kinematics.  Since this is a generator, just transfer input to output.
<<SF base: sf test generator: TBP>>=
  procedure :: complete_kinematics => sf_test_generator_complete_kinematics
<<SF base: procedures>>=
  subroutine sf_test_generator_complete_kinematics (sf_int, x, f, r, rb, map)
    class(sf_test_generator_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(out) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(in) :: r
    real(default), dimension(:), intent(in) :: rb
    logical, intent(in) :: map
    x = r
    f = 1
    call sf_int%reduce_momenta (x)
  end subroutine sf_test_generator_complete_kinematics

@ %def sf_test_generator_complete_kinematics
@ Compute inverse kinematics.  Here, we start with the $x$ array and
compute the ``input'' $r$ values and the Jacobian $f$.  After this, we
can set momenta by the same formula as for normal kinematics.
<<SF base: sf test generator: TBP>>=
  procedure :: inverse_kinematics => sf_test_generator_inverse_kinematics
<<SF base: procedures>>=
  subroutine sf_test_generator_inverse_kinematics &
       (sf_int, x, f, r, rb, map, set_momenta)
    class(sf_test_generator_t), intent(inout) :: sf_int
    real(default), dimension(:), intent(in) :: x
    real(default), intent(out) :: f
    real(default), dimension(:), intent(out) :: r
    real(default), dimension(:), intent(out) :: rb
    logical, intent(in) :: map
    logical, intent(in), optional :: set_momenta
    logical :: set_mom
    set_mom = .false.;  if (present (set_momenta))  set_mom = set_momenta
    r = x
    rb= 1 - x
    f = 1
    if (set_mom)  call sf_int%reduce_momenta (x)
  end subroutine sf_test_generator_inverse_kinematics

@ %def sf_test_generator_inverse_kinematics
@ Apply the structure function.  The matrix element becomes unity and
the application always succeeds.
<<SF base: sf test generator: TBP>>=
  procedure :: apply => sf_test_generator_apply
<<SF base: procedures>>=
  subroutine sf_test_generator_apply (sf_int, scale)
    class(sf_test_generator_t), intent(inout) :: sf_int
    real(default), intent(in) :: scale
    call interaction_set_matrix_element (sf_int%interaction_t, &
         cmplx (1._default, kind=default))
    sf_int%status = SF_EVALUATED
  end subroutine sf_test_generator_apply

@ %def sf_test_generator_apply
@
\subsubsection{Test structure function data}
Construct and display a test structure function data object.
<<SF base: execute tests>>=
  call test (sf_base_1, "sf_base_1", &
       "structure function configuration", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    class(sf_data_t), allocatable :: data
    
    write (u, "(A)")  "* Test output: sf_base_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test structure function data"
    write (u, "(A)")
    
    call model%init_test ()
    pdg_in = 25

    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select
       
    call data%write (u)

    write (u, "(A)") 

    write (u, "(1x,A)")  "Outgoing particle code:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(2x,99(1x,I0))")  pdg1
    
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_1"

  end subroutine sf_base_1

@ %def sf_base_1
@
\subsubsection{Test and probe structure function}
Construct and display a structure function object based on the test
structure function.
<<SF base: execute tests>>=
  call test (sf_base_2, "sf_base_2", &
       "structure function instance", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_base_2"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &test structure function object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    pdg_in = 25
    call flavor_init (flv, 25, model)

    call reset_interaction_counter ()
    
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"
    write (u, "(A)")
    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call vector4_write (k, u)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = 0
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=1"
    write (u, "(A)")

    r = 1
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics with mapping for r=0.8"
    write (u, "(A)")

    r = 0.8_default
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    call sf_int%set_beam_index ([1])

    call sf_int%seed_kinematics ([k])
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)

    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Compute inverse kinematics for x=0.64 and evaluate"
    write (u, "(A)")

    x = 0.64_default
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true.)
    call sf_int%apply (scale=0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_2"

  end subroutine sf_base_2

@ %def sf_base_2
@
\subsubsection{Collinear kinematics}
Scan over the possibilities for mass assignment and on-shell
projections, collinear case.
<<SF base: execute tests>>=
  call test (sf_base_3, "sf_base_3", &
       "alternatives for collinear kinematics", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_base_3"
    write (u, "(A)")  "*   Purpose: check various kinematical setups"
    write (u, "(A)")  "*            for collinear structure-function splitting."
    write (u, "(A)")  "             (two masses equal, one zero)"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    pdg_in = 25
    call flavor_init (flv, 25, model)

    call reset_interaction_counter ()
    
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    
    call sf_int%write (u)

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"

    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set radiated mass to zero"

    sf_int%mr2 = 0
    sf_int%mo2 = sf_int%mi2
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping energy"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping momentum"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set outgoing mass to zero"

    sf_int%mr2 = sf_int%mi2
    sf_int%mo2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping energy"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping momentum"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming mass to zero"

    k = vector4_moving (E, E, 3)
    call sf_int%seed_kinematics ([k])

    sf_int%mr2 = sf_int%mi2
    sf_int%mo2 = sf_int%mi2
    sf_int%mi2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping energy"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping momentum"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set all masses to zero"

    sf_int%mr2 = 0
    sf_int%mo2 = 0
    sf_int%mi2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping energy"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5, keeping momentum"
    write (u, "(A)")

    r = 0.5_default
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_3"

  end subroutine sf_base_3

@ %def sf_base_3
@
\subsubsection{Non-collinear kinematics}
Scan over the possibilities for mass assignment and on-shell
projections, non-collinear case.
<<SF base: execute tests>>=
  call test (sf_base_4, "sf_base_4", &
       "alternatives for non-collinear kinematics", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t) :: k
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_base_4"
    write (u, "(A)")  "*   Purpose: check various kinematical setups"
    write (u, "(A)")  "*            for free structure-function splitting."
    write (u, "(A)")  "             (two masses equal, one zero)"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    pdg_in = 25
    call flavor_init (flv, 25, model)

    call reset_interaction_counter ()
    
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in, collinear=.false.)
    end select
       
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    
    call sf_int%write (u)

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momentum with E=500"

    E = 500
    k = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set radiated mass to zero"

    sf_int%mr2 = 0
    sf_int%mo2 = sf_int%mi2
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping energy"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping momentum"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set outgoing mass to zero"

    sf_int%mr2 = sf_int%mi2
    sf_int%mo2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping energy"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping momentum"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming mass to zero"

    k = vector4_moving (E, E, 3)
    call sf_int%seed_kinematics ([k])

    sf_int%mr2 = sf_int%mi2
    sf_int%mo2 = sf_int%mi2
    sf_int%mi2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping energy"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping momentum"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set all masses to zero"

    sf_int%mr2 = 0
    sf_int%mo2 = 0
    sf_int%mi2 = 0
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-Initialize structure-function object with Q bounds"
    
    call reset_interaction_counter ()
    
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in, collinear=.false., &
            qbounds = [1._default, 100._default])
    end select
       
    call sf_int%init (data)
    call sf_int%seed_kinematics ([k])

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping energy"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_ENERGY
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.5/0.5/0.125, keeping momentum"
    write (u, "(A)")

    r = [0.5_default, 0.5_default, 0.125_default]
    rb = 1 - r
    sf_int%on_shell_mode = KEEP_MOMENTUM
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover x and r"
    write (u, "(A)")

    call sf_int%recover_x (x)
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "r =", r
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_4"

  end subroutine sf_base_4

@ %def sf_base_4
@
\subsubsection{Pair spectrum}
Construct and display a structure function object for a pair spectrum
(a structure function involving two particles simultaneously).
<<SF base: execute tests>>=
  call test (sf_base_5, "sf_base_5", &
       "pair spectrum with radiation", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(pdg_array_t), dimension(2) :: pdg_out
    integer, dimension(:), allocatable :: pdg1, pdg2
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(4) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_base_5"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &a pair spectrum object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    allocate (sf_test_spectrum_data_t :: data)
    select type (data)
    type is (sf_test_spectrum_data_t)
       call data%init (model, pdg_in, with_radiation=.true.)
    end select
       
    write (u, "(1x,A)")  "Outgoing particle codes:"
    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    pdg2 = pdg_out(2)
    write (u, "(2x,99(1x,I0))")  pdg1, pdg2
    
    write (u, "(A)") 
    write (u, "(A)")  "* Initialize spectrum object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize incoming momenta with sqrts=1000"

    E = 500
    k(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    k(2) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call sf_int%seed_kinematics (k)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.4,0.8"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = [0.4_default, 0.8_default]
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics with mapping for r=0.6,0.8"
    write (u, "(A)")

    r = [0.6_default, 0.8_default]
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.true.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call reset_interaction_counter ()
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    call sf_int%seed_kinematics (k)
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Compute inverse kinematics for x=0.36,0.64 &
         &and evaluate"
    write (u, "(A)")

    x = [0.36_default, 0.64_default]
    call sf_int%inverse_kinematics (x, f, r, rb, map=.true.)
    call sf_int%apply (scale=0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_5"

  end subroutine sf_base_5

@ %def sf_base_5
@
\subsubsection{Pair spectrum without radiation}
Construct and display a structure function object for a pair spectrum
(a structure function involving two particles simultaneously).
<<SF base: execute tests>>=
  call test (sf_base_6, "sf_base_6", &
       "pair spectrum without radiation", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_6 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f
    
    write (u, "(A)")  "* Test output: sf_base_6"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &a pair spectrum object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    allocate (sf_test_spectrum_data_t :: data)
    select type (data)
    type is (sf_test_spectrum_data_t)
       call data%init (model, pdg_in, with_radiation=.false.)
    end select
       
    write (u, "(A)")  "* Initialize spectrum object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)
    
    write (u, "(A)")  "* Initialize incoming momenta with sqrts=1000"

    E = 500
    k(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    k(2) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call sf_int%seed_kinematics (k)

    write (u, "(A)")
    write (u, "(A)")  "* Set kinematics for x=0.4,0.8"
    write (u, "(A)")

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))

    r = [0.4_default, 0.8_default]
    rb = 1 - r
    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call reset_interaction_counter ()
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    call sf_int%seed_kinematics (k)
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    call sf_int%recover_x (x)
    write (u, "(A,9(1x,F10.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Compute inverse kinematics for x=0.4,0.8 &
         &and evaluate"
    write (u, "(A)")

    x = [0.4_default, 0.8_default]
    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    call sf_int%apply (scale=0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_6"

  end subroutine sf_base_6

@ %def sf_base_6
@
\subsubsection{Direct access to structure function}
Probe a structure function directly.
<<SF base: execute tests>>=
  call test (sf_base_7, "sf_base_7", &
       "direct access", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_7 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(pdg_array_t) :: pdg_in
    type(flavor_t) :: flv
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    real(default), dimension(:), allocatable :: value
    
    write (u, "(A)")  "* Test output: sf_base_7"
    write (u, "(A)")  "*   Purpose: check direct access method"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    write (u, "(A)")  "* Initialize structure-function object"
    write (u, "(A)")
    
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select
       
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    write (u, "(A)")  "* Probe structure function: states"
    write (u, "(A)")
    
    write (u, "(A,I0)")  "n_states = ", sf_int%get_n_states ()
    write (u, "(A,I0)")  "n_in     = ", sf_int%get_n_in ()
    write (u, "(A,I0)")  "n_rad    = ", sf_int%get_n_rad ()
    write (u, "(A,I0)")  "n_out    = ", sf_int%get_n_out ()
    write (u, "(A)")
    write (u, "(A)", advance="no")  "state(1)  = "
    call quantum_numbers_write (sf_int%get_state (1), u)
    write (u, *)
    
    allocate (value (sf_int%get_n_states ()))
    call sf_int%compute_values (value, &
         E=[500._default], x=[0.5_default], xb=[0.5_default], scale=0._default)

    write (u, "(A)")
    write (u, "(A)", advance="no")  "value (E=500, x=0.5) ="
    write (u, "(9(1x," // FMT_19 // "))")  value

    call sf_int%compute_values (value, &
         x=[0.1_default], xb=[0.9_default], scale=0._default)

    write (u, "(A)")
    write (u, "(A)", advance="no")  "value (E=500, x=0.1) ="
    write (u, "(9(1x," // FMT_19 // "))")  value


    write (u, "(A)")
    write (u, "(A)")  "* Initialize spectrum object"
    write (u, "(A)")
    
    deallocate (value)
    call sf_int%final ()
    deallocate (sf_int)
    deallocate (data)
    
    allocate (sf_test_spectrum_data_t :: data)
    select type (data)
    type is (sf_test_spectrum_data_t)
       call data%init (model, pdg_in, with_radiation=.false.)
    end select
       
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    write (u, "(A)")  "* Probe spectrum: states"
    write (u, "(A)")
    
    write (u, "(A,I0)")  "n_states = ", sf_int%get_n_states ()
    write (u, "(A,I0)")  "n_in     = ", sf_int%get_n_in ()
    write (u, "(A,I0)")  "n_rad    = ", sf_int%get_n_rad ()
    write (u, "(A,I0)")  "n_out    = ", sf_int%get_n_out ()
    write (u, "(A)")
    write (u, "(A)", advance="no")  "state(1)  = "
    call quantum_numbers_write (sf_int%get_state (1), u)
    write (u, *)
    
    allocate (value (sf_int%get_n_states ()))
    call sf_int%compute_value (1, value(1), &
         E = [500._default, 500._default], &
         x = [0.5_default, 0.6_default], &
         xb= [0.5_default, 0.4_default], &
         scale = 0._default)

    write (u, "(A)")
    write (u, "(A)", advance="no")  "value (E=500,500, x=0.5,0.6) ="
    write (u, "(9(1x," // FMT_19 // "))")  value

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_7"

  end subroutine sf_base_7

@ %def sf_base_7
@
\subsubsection{Structure function chain configuration}
<<SF base: execute tests>>=
  call test (sf_base_8, "sf_base_8", &
       "structure function chain configuration", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_8 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data_strfun
    class(sf_data_t), allocatable, target :: data_spectrum
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_chain_t) :: sf_chain
    
    write (u, "(A)")  "* Test output: sf_base_8"
    write (u, "(A)")  "*   Purpose: set up a structure-function chain"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data_strfun)
    select type (data_strfun)
    type is (sf_test_data_t)
       call data_strfun%init (model, pdg_in)
    end select
       
    allocate (sf_test_spectrum_data_t :: data_spectrum)
    select type (data_spectrum)
    type is (sf_test_spectrum_data_t)
       call data_spectrum%init (model, pdg_in, with_radiation=.true.)
    end select
       
    write (u, "(A)")  "* Set up chain with beams only"
    write (u, "(A)")
    
    call sf_chain%init (beam_data)
    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with structure function"
    write (u, "(A)")
    
    allocate (sf_config (1))
    call sf_config(1)%init ([1], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with spectrum and structure function"
    write (u, "(A)")
    
    deallocate (sf_config)
    allocate (sf_config (2))
    call sf_config(1)%init ([1,2], data_spectrum)
    call sf_config(2)%init ([2], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_8"

  end subroutine sf_base_8

@ %def sf_base_8
@
\subsubsection{Structure function instance configuration}
We create a structure-function chain instance which implements a
configured structure-function chain.  We link the momentum entries in
the interactions and compute kinematics.

We do not actually connect the interactions and create evaluators.  We
skip this step and manually advance the status of the chain instead.
<<SF base: execute tests>>=
  call test (sf_base_9, "sf_base_9", &
       "structure function chain instance", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_9 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data_strfun
    class(sf_data_t), allocatable, target :: data_spectrum
    type(sf_config_t), dimension(:), allocatable, target :: sf_config
    type(sf_chain_t), target :: sf_chain
    type(sf_chain_instance_t), target :: sf_chain_instance
    type(sf_channel_t), dimension(2) :: sf_channel
    type(vector4_t), dimension(2) :: p
    integer :: j
    
    write (u, "(A)")  "* Test output: sf_base_9"
    write (u, "(A)")  "*   Purpose: set up a structure-function chain &
         &and create an instance"
    write (u, "(A)")  "*            compute kinematics"
    write (u, "(A)")
   
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data_strfun)
    select type (data_strfun)
    type is (sf_test_data_t)
       call data_strfun%init (model, pdg_in)
    end select
       
    allocate (sf_test_spectrum_data_t :: data_spectrum)
    select type (data_spectrum)
    type is (sf_test_spectrum_data_t)
       call data_spectrum%init (model, pdg_in, with_radiation=.true.)
    end select
       
    write (u, "(A)")  "* Set up chain with beams only"
    write (u, "(A)")
    
    call sf_chain%init (beam_data)

    call sf_chain_instance%init (sf_chain, n_channel = 1)

    call sf_chain_instance%link_interactions ()
    sf_chain_instance%status = SF_DONE_CONNECTIONS
    call sf_chain_instance%compute_kinematics (1, [real(default) ::])

    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call sf_chain_instance%get_out_momenta (p)
    
    write (u, "(A)")
    write (u, "(A)")  "* Outgoing momenta:"
    
    do j = 1, 2
       write (u, "(A)")
       call vector4_write (p(j), u)
    end do
  
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with structure function"
    write (u, "(A)")
    
    allocate (sf_config (1))
    call sf_config(1)%init ([1], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call sf_chain_instance%init (sf_chain, n_channel = 1)
    
    call sf_channel(1)%init (1)
    call sf_channel(1)%activate_mapping ([1])
    call sf_chain_instance%set_channel (1, sf_channel(1))

    call sf_chain_instance%link_interactions ()
    sf_chain_instance%status = SF_DONE_CONNECTIONS
    call sf_chain_instance%compute_kinematics (1, [0.8_default])
    
    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call sf_chain_instance%get_out_momenta (p)
    
    write (u, "(A)")
    write (u, "(A)")  "* Outgoing momenta:"
    
    do j = 1, 2
       write (u, "(A)")
       call vector4_write (p(j), u)
    end do
    
    call sf_chain_instance%final ()
    call sf_chain%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with spectrum and structure function"
    write (u, "(A)")
    
    deallocate (sf_config)
    allocate (sf_config (2))
    call sf_config(1)%init ([1,2], data_spectrum)
    call sf_config(2)%init ([2], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call sf_chain_instance%init (sf_chain, n_channel = 1)
    
    call sf_channel(2)%init (2)
    call sf_channel(2)%activate_mapping ([2])
    call sf_chain_instance%set_channel (1, sf_channel(2))

    call sf_chain_instance%link_interactions ()
    sf_chain_instance%status = SF_DONE_CONNECTIONS
    call sf_chain_instance%compute_kinematics &
         (1, [0.5_default, 0.6_default, 0.8_default])
    
    call write_separator (u, 2)
    call sf_chain%write (u)
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call sf_chain_instance%get_out_momenta (p)
    
    write (u, "(A)")
    write (u, "(A)")  "* Outgoing momenta:"
    
    do j = 1, 2
       write (u, "(A)")
       call vector4_write (p(j), u)
    end do
    
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_9"

  end subroutine sf_base_9

@ %def sf_base_9
@
\subsubsection{Structure function chain mappings}
Set up a structure function chain instance with a pair of
single-particle structure functions.  We test different global
mappings for this setup.

Again, we skip evaluators.
<<SF base: execute tests>>=
 call test (sf_base_10, "sf_base_10", &
      "structure function chain mapping", &
      u, results)
<<SF base: tests>>=
  subroutine sf_base_10 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data_strfun
    type(sf_config_t), dimension(:), allocatable, target :: sf_config
    type(sf_chain_t), target :: sf_chain
    type(sf_chain_instance_t), target :: sf_chain_instance
    type(sf_channel_t), dimension(2) :: sf_channel
    real(default), dimension(2) :: x_saved
    
    write (u, "(A)")  "* Test output: sf_base_10"
    write (u, "(A)")  "*   Purpose: set up a structure-function chain"
    write (u, "(A)")  "*            and check mappings"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data_strfun)
    select type (data_strfun)
    type is (sf_test_data_t)
       call data_strfun%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Set up chain with structure function pair &
         &and standard mapping"
    write (u, "(A)")
    
    allocate (sf_config (2))
    call sf_config(1)%init ([1], data_strfun)
    call sf_config(2)%init ([2], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call sf_chain_instance%init (sf_chain, n_channel = 1)

    call sf_channel(1)%init (2)
    call sf_channel(1)%set_s_mapping ([1,2])
    call sf_chain_instance%set_channel (1, sf_channel(1))

    call sf_chain_instance%link_interactions ()
    sf_chain_instance%status = SF_DONE_CONNECTIONS
    call sf_chain_instance%compute_kinematics (1, [0.8_default, 0.6_default])
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Invert the kinematics calculation"
    write (u, "(A)")

    x_saved = sf_chain_instance%x

    call sf_chain_instance%init (sf_chain, n_channel = 1)

    call sf_channel(2)%init (2)
    call sf_channel(2)%set_s_mapping ([1, 2])
    call sf_chain_instance%set_channel (1, sf_channel(2))

    call sf_chain_instance%link_interactions ()
    sf_chain_instance%status = SF_DONE_CONNECTIONS
    call sf_chain_instance%inverse_kinematics (x_saved)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    
    call sf_chain_instance%final ()
    call sf_chain%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_10"

  end subroutine sf_base_10

@ %def sf_base_10
@
\subsubsection{Structure function chain evaluation}
Here, we test the complete workflow for structure-function chains.
First, we create the template chain, then initialize an instance.  We
set up links, mask, and evaluators.  Finally, we set kinematics and
evaluate the matrix elements and their products.
<<SF base: execute tests>>=
  call test (sf_base_11, "sf_base_11", &
       "structure function chain evaluation", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_11 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data_strfun
    class(sf_data_t), allocatable, target :: data_spectrum
    type(sf_config_t), dimension(:), allocatable, target :: sf_config
    type(sf_chain_t), target :: sf_chain
    type(sf_chain_instance_t), target :: sf_chain_instance
    type(sf_channel_t), dimension(2) :: sf_channel
    type(particle_set_t) :: pset
    type(interaction_t), pointer :: int
    logical :: ok
    
    write (u, "(A)")  "* Test output: sf_base_11"
    write (u, "(A)")  "*   Purpose: set up a structure-function chain"
    write (u, "(A)")  "*            create an instance and evaluate"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data_strfun)
    select type (data_strfun)
    type is (sf_test_data_t)
       call data_strfun%init (model, pdg_in)
    end select
       
    allocate (sf_test_spectrum_data_t :: data_spectrum)
    select type (data_spectrum)
    type is (sf_test_spectrum_data_t)
       call data_spectrum%init (model, pdg_in, with_radiation=.true.)
    end select
       
    write (u, "(A)")  "* Set up chain with beams only"
    write (u, "(A)")
    
    call sf_chain%init (beam_data)

    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()
    
    call sf_chain_instance%compute_kinematics (1, [real(default) ::])
    call sf_chain_instance%evaluate (scale=0._default)

    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_init (pset, ok, int, int, FM_IGNORE_HELICITY, &
         [0._default, 0._default], .false., .true.)
    call sf_chain_instance%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")

    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover chain:"
    write (u, "(A)")
    
    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_fill_interaction (pset, int, 2)

    call sf_chain_instance%recover_kinematics (1)
    call sf_chain_instance%evaluate (scale=0._default)

    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call particle_set_final (pset)
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")
    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with structure function"
    write (u, "(A)")
    
    allocate (sf_config (1))
    call sf_config(1)%init ([1], data_strfun)
    call sf_chain%init (beam_data, sf_config)

    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_channel(1)%init (1)
    call sf_channel(1)%activate_mapping ([1])
    call sf_chain_instance%set_channel (1, sf_channel(1))
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    call sf_chain_instance%compute_kinematics (1, [0.8_default])
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_init (pset, ok, int, int, FM_IGNORE_HELICITY, &
         [0._default, 0._default], .false., .true.)
    call sf_chain_instance%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")

    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover chain:"
    write (u, "(A)")
    
    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_channel(1)%init (1)
    call sf_channel(1)%activate_mapping ([1])
    call sf_chain_instance%set_channel (1, sf_channel(1))
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_fill_interaction (pset, int, 2)

    call sf_chain_instance%recover_kinematics (1)
    call sf_chain_instance%evaluate (scale=0._default)

    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call particle_set_final (pset)
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")
    write (u, "(A)")
    write (u, "(A)")  "* Set up chain with spectrum and structure function"
    write (u, "(A)")
    
    deallocate (sf_config)
    allocate (sf_config (2))
    call sf_config(1)%init ([1,2], data_spectrum)
    call sf_config(2)%init ([2], data_strfun)
    call sf_chain%init (beam_data, sf_config)
    
    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_channel(2)%init (2)
    call sf_channel(2)%activate_mapping ([2])
    call sf_chain_instance%set_channel (1, sf_channel(2))
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    call sf_chain_instance%compute_kinematics &
         (1, [0.5_default, 0.6_default, 0.8_default])
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_init (pset, ok, int, int, FM_IGNORE_HELICITY, &
         [0._default, 0._default], .false., .true.)
    call sf_chain_instance%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")

    call write_separator (u)
    call particle_set_write (pset, u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover chain:"
    write (u, "(A)")
    
    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_channel(2)%init (2)
    call sf_channel(2)%activate_mapping ([2])
    call sf_chain_instance%set_channel (1, sf_channel(2))
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    int => sf_chain_instance%get_out_int_ptr ()
    call particle_set_fill_interaction (pset, int, 2)

    call sf_chain_instance%recover_kinematics (1)
    call sf_chain_instance%evaluate (scale=0._default)

    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    call particle_set_final (pset)
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_11"

  end subroutine sf_base_11

@ %def sf_base_11
@
\subsubsection{Multichannel case}
We set up a structure-function chain as before, but with three
different parameterizations.  The first instance is without mappings,
the second one with single-particle mappings, and the third one with
two-particle mappings.
<<SF base: execute tests>>=
  call test (sf_base_12, "sf_base_12", &
       "multi-channel structure function chain", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_12 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable, target :: sf_config
    type(sf_chain_t), target :: sf_chain
    type(sf_chain_instance_t), target :: sf_chain_instance
    real(default), dimension(2) :: x_saved
    real(default), dimension(2,3) :: p_saved
    type(sf_channel_t), dimension(:), allocatable :: sf_channel
    
    write (u, "(A)")  "* Test output: sf_base_12"
    write (u, "(A)")  "*   Purpose: set up and evaluate a multi-channel &
         &structure-function chain"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Set up chain with structure function pair &
         &and three different mappings"
    write (u, "(A)")
    
    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data) 
    call sf_chain%init (beam_data, sf_config)

    call sf_chain_instance%init (sf_chain, n_channel = 3)

    call allocate_sf_channels (sf_channel, n_channel = 3, n_strfun = 2)

    ! channel 1: no mapping
    call sf_chain_instance%set_channel (1, sf_channel(1))

    ! channel 2: single-particle mappings
    call sf_channel(2)%activate_mapping ([1,2])
    ! call sf_chain_instance%activate_mapping (2, [1,2])
    call sf_chain_instance%set_channel (2, sf_channel(2))
   
    ! channel 3: two-particle mapping
    call sf_channel(3)%set_s_mapping ([1,2])
    ! call sf_chain_instance%set_s_mapping (3, [1, 2])
    call sf_chain_instance%set_channel (3, sf_channel(3))

    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    write (u, "(A)")  "* Compute kinematics in channel 1 and evaluate"
    write (u, "(A)")

    call sf_chain_instance%compute_kinematics (1, [0.8_default, 0.6_default])
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Invert the kinematics calculation"
    write (u, "(A)")

    x_saved = sf_chain_instance%x

    call sf_chain_instance%inverse_kinematics (x_saved)
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Compute kinematics in channel 2 and evaluate"
    write (u, "(A)")

    p_saved = sf_chain_instance%p

    call sf_chain_instance%compute_kinematics (2, p_saved(:,2))
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Compute kinematics in channel 3 and evaluate"
    write (u, "(A)")

    call sf_chain_instance%compute_kinematics (3, p_saved(:,3))
    call sf_chain_instance%evaluate (scale=0._default)
    
    call write_separator (u, 2)
    call sf_chain_instance%write (u)
    call write_separator (u, 2)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_chain_instance%final ()
    call sf_chain%final ()

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_12"

  end subroutine sf_base_12

@ %def sf_base_12
@
\subsubsection{Generated spectrum}
Construct and evaluate a structure function object for a pair spectrum
which is evaluated as a beam-event generator.
<<SF base: execute tests>>=
  call test (sf_base_13, "sf_base_13", &
       "pair spectrum generator", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_13 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    class(sf_int_t), allocatable :: sf_int
    type(vector4_t), dimension(2) :: k
    type(vector4_t), dimension(2) :: q
    real(default) :: E
    real(default), dimension(:), allocatable :: r, rb, x
    real(default) :: f, x_free
    
    write (u, "(A)")  "* Test output: sf_base_13"
    write (u, "(A)")  "*   Purpose: initialize and fill &
         &a pair generator object"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    allocate (sf_test_generator_data_t :: data)
    select type (data)
    type is (sf_test_generator_data_t)
       call data%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Initialize generator object"
    write (u, "(A)")
    
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    allocate (r (data%get_n_par ()))
    allocate (rb(size (r)))
    allocate (x (size (r)))
    
    write (u, "(A)")  "* Generate free r values"
    write (u, "(A)")

    x_free = 1
    call sf_int%generate_free (r, rb, x_free)

    write (u, "(A)")  "* Initialize incoming momenta with sqrts=1000"

    E = 500
    k(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    k(2) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    call sf_int%seed_kinematics (k)

    write (u, "(A)")
    write (u, "(A)")  "* Complete kinematics"
    write (u, "(A)")

    call sf_int%complete_kinematics (x, f, r, rb, map=.false.)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "f =", f
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Recover x from momenta"
    write (u, "(A)")

    q = interaction_get_momenta (sf_int%interaction_t, outgoing=.true.)
    call sf_int%final ()
    deallocate (sf_int)

    call reset_interaction_counter ()
    call data%allocate_sf_int (sf_int)
    call sf_int%init (data)

    call sf_int%seed_kinematics (k)
    call interaction_set_momenta (sf_int%interaction_t, q, outgoing=.true.)
    x_free = 1
    call sf_int%recover_x (x, x_free)
    write (u, "(A,9(1x,F10.7))")  "x =", x
    write (u, "(A,9(1x,F10.7))")  "xf=", x_free

    write (u, "(A)")
    write (u, "(A)")  "* Compute inverse kinematics &
         &and evaluate"
    write (u, "(A)")

    call sf_int%inverse_kinematics (x, f, r, rb, map=.false.)
    call sf_int%apply (scale=0._default)
    call sf_int%write (u)

    write (u, "(A)")
    write (u, "(A,9(1x,F10.7))")  "r =", r
    write (u, "(A,9(1x,F10.7))")  "f =", f

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call sf_int%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_13"

  end subroutine sf_base_13

@ %def sf_base_13
@
\subsubsection{Structure function chain evaluation}
Here, we test the complete workflow for a structure-function chain
with generator.  First, we create the template chain, then initialize
an instance.  We set up links, mask, and evaluators.  Finally, we set
kinematics and evaluate the matrix elements and their products.
<<SF base: execute tests>>=
  call test (sf_base_14, "sf_base_14", &
       "structure function generator evaluation", &
       u, results)
<<SF base: tests>>=
  subroutine sf_base_14 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(pdg_array_t) :: pdg_in
    type(beam_data_t), target :: beam_data
    class(sf_data_t), allocatable, target :: data_strfun
    class(sf_data_t), allocatable, target :: data_generator
    type(sf_config_t), dimension(:), allocatable, target :: sf_config
    real(default), dimension(:), allocatable :: p_in
    type(sf_chain_t), target :: sf_chain
    type(sf_chain_instance_t), target :: sf_chain_instance
    
    write (u, "(A)")  "* Test output: sf_base_14"
    write (u, "(A)")  "*   Purpose: set up a structure-function chain"
    write (u, "(A)")  "*            create an instance and evaluate"
    write (u, "(A)")
    
    write (u, "(A)")  "* Initialize configuration data"
    write (u, "(A)")

    call model%init_test ()
    call flavor_init (flv, 25, model)
    pdg_in = 25

    call reset_interaction_counter ()
    
    call beam_data_init_sqrts (beam_data, &
         1000._default, [flv, flv])

    allocate (sf_test_data_t :: data_strfun)
    select type (data_strfun)
    type is (sf_test_data_t)
       call data_strfun%init (model, pdg_in)
    end select
       
    allocate (sf_test_generator_data_t :: data_generator)
    select type (data_generator)
    type is (sf_test_generator_data_t)
       call data_generator%init (model, pdg_in)
    end select
       
    write (u, "(A)")  "* Set up chain with generator and structure function"
    write (u, "(A)")
    
    allocate (sf_config (2))
    call sf_config(1)%init ([1,2], data_generator)
    call sf_config(2)%init ([2], data_strfun)
    call sf_chain%init (beam_data, sf_config)
    
    call sf_chain_instance%init (sf_chain, n_channel = 1)
    call sf_chain_instance%link_interactions ()
    call sf_chain_instance%exchange_mask ()
    call sf_chain_instance%init_evaluators ()

    write (u, "(A)")  "* Inject integration parameter"
    write (u, "(A)")

    allocate (p_in (sf_chain%get_n_bound ()), source = 0.9_default)
    write (u, "(A,9(1x,F10.7))")  "p_in =", p_in
    
    write (u, "(A)")
    write (u, "(A)")  "* Evaluate"
    write (u, "(A)")

    call sf_chain_instance%compute_kinematics (1, p_in)
    call sf_chain_instance%evaluate (scale=0._default)
    
    call sf_chain_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extract integration parameter"
    write (u, "(A)")

    call sf_chain_instance%get_mcpar (1, p_in)
    write (u, "(A,9(1x,F10.7))")  "p_in =", p_in
    
    call sf_chain_instance%final ()
    call sf_chain%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: sf_base_14"

  end subroutine sf_base_14

@ %def sf_base_14
