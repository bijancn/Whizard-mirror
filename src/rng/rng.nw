% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: random number generator and such
\chapter{Random-Number Generator}
\includemodulegraph{rng}

These modules implement abstract types and tools for random-number
generation.
\begin{description}
\item[rng\_base]
  Abstract random-number generator and factory
\item[selectors]
  Selection depending on weights and random numbers
\end{description}

Implementation of the RNG abstract types:
\begin{description}
\item[Module [[rng_tao]]:]
  Interface to the TAO random number generator
  which the VAMP package provides.  Note that VAMP explicitly requests
  this generator.
\end{description}



\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Generic Random-Number Generator}
For all generator implementations, we define a [[rng]] type which
represents the state of a random-number generator with the associated
methods that produce a random number.  Furthermore, we define a
[[rng_factory]] type.  An object of this type is capable of allocating
a sequence of [[rng]] objects.  These generator states should be, if
possible, statistically independent, so they can be used in parallel
in different places of the event-generation chain.
<<[[rng_base.f90]]>>=
<<File header>>

module rng_base

<<Use kinds>>
  use kinds, only: i16
  use constants, only: TWOPI

<<Standard module head>>

<<RNG base: public>>

<<RNG base: types>>

<<RNG base: interfaces>>

contains

<<RNG base: procedures>>

end module rng_base
@ %def rng_base
@
\subsection{Generator type}
The rng object is actually the state of the random-number generator.
The methods initialize/reset and call the generator for this state.
<<RNG base: public>>=
  public :: rng_t
<<RNG base: types>>=
  type, abstract :: rng_t
   contains
   <<RNG base: rng: TBP>>
  end type rng_t

@ %def rng_t
@ The [[init]] method initializes the generator and sets a seed.
We should implement the interface such that a single integer is
sufficient for a seed.

The seed may be omitted.  The behavior without seed is not defined, however.
<<RNG base: rng: TBP>>=
  procedure (rng_init), deferred :: init
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_init (rng, seed)
       import
       class(rng_t), intent(out) :: rng
       integer, intent(in), optional :: seed
     end subroutine rng_init
  end interface

@ %def init
@ The [[final]] method deallocates memory where necessary and allows
for another call of [[init]] to reset the generator.
<<RNG base: rng: TBP>>=
  procedure (rng_final), deferred :: final
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_final (rng)
       import
       class(rng_t), intent(inout) :: rng
     end subroutine rng_final
  end interface

@ %def final
@ Output.  We should, at least, identify the generator.
<<RNG base: rng: TBP>>=
  procedure (rng_write), deferred :: write
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_write (rng, unit, indent)
       import
       class(rng_t), intent(in) :: rng
       integer, intent(in), optional :: unit, indent
     end subroutine rng_write
  end interface

@ %def rng_write
@ These routines generate a single and an array of uniformly distributed
default-precision random numbers, respectively.
<<RNG base: rng: TBP>>=
  generic :: generate => generate_single, generate_array
  procedure (rng_generate_single), deferred :: generate_single
  procedure (rng_generate_array), deferred :: generate_array
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_generate_single (rng, x)
       import
       class(rng_t), intent(inout) :: rng
       real(default), intent(out) :: x
     end subroutine rng_generate_single
  end interface

  abstract interface
     subroutine rng_generate_array (rng, x)
       import
       class(rng_t), intent(inout) :: rng
       real(default), dimension(:), intent(out) :: x
     end subroutine rng_generate_array
  end interface

@ %def generate_single generate_array
@ These routines generate a single and an array of Gaussian (normal)
distributed default-precision random numbers, respectively.  Mean is 0 and
$\sigma=1$.  Note that $z=\mu + \sigma x$ then distributes with mean $\mu$ and
variance $\sigma^2$.

The algorithm uses twice as much uniformly distributed random numbers, taken
from the PDG review.
<<RNG base: rng: TBP>>=
  generic :: generate_gaussian => &
       rng_generate_gaussian_single, rng_generate_gaussian_array
  procedure, private :: rng_generate_gaussian_single
  procedure, private :: rng_generate_gaussian_array
<<RNG base: procedures>>=
  subroutine rng_generate_gaussian_single (rng, x)
    class(rng_t), intent(inout) :: rng
    real(default), intent(out) :: x
    real(default), dimension(2) :: u
    call rng%generate (u)
    x = sin (twopi * u(1)) * sqrt (- 2 * log (u(2)))
  end subroutine rng_generate_gaussian_single

  subroutine rng_generate_gaussian_array (rng, x)
    class(rng_t), intent(inout) :: rng
    real(default), dimension(:), intent(out) :: x
    integer :: i
    do i = 1, size (x)
       call rng%generate_gaussian (x(i))
    end do
  end subroutine rng_generate_gaussian_array

@ %def generate_gaussian_single generate_gaussian_array
@
\subsection{RNG Factory}
A factory object has a [[make]] method that allocates and initializes
a new generator of appropriate type.  It uses a 16-bit integer for
initialization.  For a real-life implementation, the factory should
return a sequence of statistically independent generators, and for
different seeds, the sequences should also be independent.
<<RNG base: public>>=
  public :: rng_factory_t
<<RNG base: types>>=
  type, abstract :: rng_factory_t
   contains
   <<RNG base: rng factory: TBP>>
  end type rng_factory_t

@ %def rng_factory_t
@ Output.  Should be short, just report the seed and current state of
the factory.
<<RNG base: rng factory: TBP>>=
  procedure (rng_factory_write), deferred :: write
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_factory_write (object, unit)
       import
       class(rng_factory_t), intent(in) :: object
       integer, intent(in), optional :: unit
     end subroutine rng_factory_write
  end interface

@ %def rng_factory_write
@ Initialize.  It should be possible to do this repeatedly, resetting the
state.  The default seed should be 0.
<<RNG base: rng factory: TBP>>=
  procedure (rng_factory_init), deferred :: init
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_factory_init (factory, seed)
       import
       class(rng_factory_t), intent(out) :: factory
       integer(i16), intent(in), optional :: seed
     end subroutine rng_factory_init
  end interface

@ %def rng_factory_init
@ Spawn a new generator.
<<RNG base: rng factory: TBP>>=
  procedure (rng_factory_make), deferred :: make
<<RNG base: interfaces>>=
  abstract interface
     subroutine rng_factory_make (factory, rng)
       import
       class(rng_factory_t), intent(inout) :: factory
       class(rng_t), intent(out), allocatable :: rng
     end subroutine rng_factory_make
  end interface

@ %def rng_factory_make
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[rng_base_ut.f90]]>>=
<<File header>>

module rng_base_ut
  use unit_tests
  use rng_base_uti

<<Standard module head>>

<<RNG base: public test>>

<<RNG base: public test auxiliary>>

contains

<<RNG base: test driver>>

end module rng_base_ut
@ %def rng_base_ut
@
<<[[rng_base_uti.f90]]>>=
<<File header>>

module rng_base_uti

<<Use kinds>>
  use kinds, only: i16
  use format_utils, only: write_indent
  use io_units

  use rng_base

<<Standard module head>>

<<RNG base: public test auxiliary>>

<<RNG base: test declarations>>

<<RNG base: test types>>

contains

<<RNG base: tests>>

<<RNG base: test auxiliary>>

end module rng_base_uti
@ %def rng_base_ut
@ API: driver for the unit tests below.
<<RNG base: public test>>=
  public :: rng_base_test
<<RNG base: test driver>>=
  subroutine rng_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<RNG base: execute tests>>
  end subroutine rng_base_test

@ %def rng_base_test
@
\subsubsection{Test generator}
The test 'mock' random generator generates a repeating series with the numbers
$0.1, 0.3, 0.5, 0.7, 0.9$.  It has an integer stored as state.  The
integer must be one of $1,3,5,7,9$.
<<RNG base: public test auxiliary>>=
  public :: rng_test_t
<<RNG base: test types>>=
  type, extends (rng_t) :: rng_test_t
     integer :: state = 1
   contains
     procedure :: write => rng_test_write
     procedure :: init => rng_test_init
     procedure :: final => rng_test_final
     procedure :: generate_single => rng_test_generate_single
     procedure :: generate_array => rng_test_generate_array
  end type rng_test_t

@ %def rng_test_t
@ Output.  The state is a single number, so print it.
<<RNG base: test auxiliary>>=
  subroutine rng_test_write (rng, unit, indent)
    class(rng_test_t), intent(in) :: rng
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A,I0,A)")  "Random-number generator: &
         &test (state = ", rng%state, ")"
  end subroutine rng_test_write

@ %def rng_test_write
@ The default seed is 1.
<<RNG base: test auxiliary>>=
  subroutine rng_test_init (rng, seed)
    class(rng_test_t), intent(out) :: rng
    integer, intent(in), optional :: seed
    if (present (seed))  rng%state = seed
  end subroutine rng_test_init

@ %def rng_test_init
@ Nothing to finalize:
<<RNG base: test auxiliary>>=
  subroutine rng_test_final (rng)
    class(rng_test_t), intent(inout) :: rng
  end subroutine rng_test_final

@ %def rng_test_final
@ Generate a single number and advance the state.
<<RNG base: test auxiliary>>=
  subroutine rng_test_generate_single (rng, x)
    class(rng_test_t), intent(inout) :: rng
    real(default), intent(out) :: x
    x = rng%state / 10._default
    rng%state = mod (rng%state + 2, 10)
  end subroutine rng_test_generate_single

@ %def rng_generate_single
@ The array generator calls the single-item generator multiple times.
<<RNG base: test auxiliary>>=
  subroutine rng_test_generate_array (rng, x)
    class(rng_test_t), intent(inout) :: rng
    real(default), dimension(:), intent(out) :: x
    integer :: i
    do i = 1, size (x)
       call rng%generate (x(i))
    end do
  end subroutine rng_test_generate_array

@ %def rng_generate_array
@
\subsubsection{Test Factory}
This factory makes [[rng_test_t]] generators, initialized with
integers 1, 3, 5, 7, 9 if given the input 0, 1, 2, 3, 4.  The
generators within one sequence are all identical, however.
<<RNG base: public test auxiliary>>=
  public :: rng_test_factory_t
<<RNG base: test types>>=
  type, extends (rng_factory_t) :: rng_test_factory_t
     integer :: seed = 1
   contains
   <<RNG base: rng test factory: TBP>>
  end type rng_test_factory_t

@ %def rng_test_factory_t
@ Output.
<<RNG base: rng test factory: TBP>>=
  procedure :: write => rng_test_factory_write
<<RNG base: test auxiliary>>=
  subroutine rng_test_factory_write (object, unit)
    class(rng_test_factory_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,I0,A)")  "RNG factory: test (", object%seed, ")"
  end subroutine rng_test_factory_write

@ %def rng_test_factory_write
@ Initialize, translating the given seed.
<<RNG base: rng test factory: TBP>>=
  procedure :: init => rng_test_factory_init
<<RNG base: test auxiliary>>=
  subroutine rng_test_factory_init (factory, seed)
    class(rng_test_factory_t), intent(out) :: factory
    integer(i16), intent(in), optional :: seed
    if (present (seed))  factory%seed = mod (seed * 2 + 1, 10)
  end subroutine rng_test_factory_init

@ %def rng_test_factory_init
<<RNG base: rng test factory: TBP>>=
  procedure :: make => rng_test_factory_make
<<RNG base: test auxiliary>>=
  subroutine rng_test_factory_make (factory, rng)
    class(rng_test_factory_t), intent(inout) :: factory
    class(rng_t), intent(out), allocatable :: rng
    allocate (rng_test_t :: rng)
    select type (rng)
    type is (rng_test_t)
       call rng%init (int (factory%seed))
    end select
  end subroutine rng_test_factory_make

@ %def rng_test_factory_make
@
\subsubsection{Generator check}
Initialize the generator and draw random numbers.
<<RNG base: execute tests>>=
  call test (rng_base_1, "rng_base_1", &
       "rng initialization and call", &
       u, results)
<<RNG base: test declarations>>=
  public :: rng_base_1
<<RNG base: tests>>=
  subroutine rng_base_1 (u)
    integer, intent(in) :: u
    class(rng_t), allocatable :: rng

    real(default) :: x
    real(default), dimension(2) :: x2

    write (u, "(A)")  "* Test output: rng_base_1"
    write (u, "(A)")  "*   Purpose: initialize and call a test random-number &
         &generator"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize generator"
    write (u, "(A)")

    allocate (rng_test_t :: rng)
    call rng%init (3)

    call rng%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Get random number"
    write (u, "(A)")

    call rng%generate (x)
    write (u, "(A,2(1x,F9.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Get random number pair"
    write (u, "(A)")

    call rng%generate (x2)
    write (u, "(A,2(1x,F9.7))")  "x =", x2

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call rng%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_base_1"

  end subroutine rng_base_1

@ %def rng_base_1
@
\subsubsection{Factory check}
Set up a factory and spawn generators.
<<RNG base: execute tests>>=
  call test (rng_base_2, "rng_base_2", &
       "rng factory", &
       u, results)
<<RNG base: test declarations>>=
  public :: rng_base_2
<<RNG base: tests>>=
  subroutine rng_base_2 (u)
    integer, intent(in) :: u
    type(rng_test_factory_t) :: rng_factory
    class(rng_t), allocatable :: rng

    write (u, "(A)")  "* Test output: rng_base_2"
    write (u, "(A)")  "*   Purpose: initialize and use a rng factory"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize factory"
    write (u, "(A)")

    call rng_factory%init ()
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Make a generator"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call rng%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_base_2"

  end subroutine rng_base_2

@ %def rng_base_2
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Select from a weighted sample}
<<[[selectors.f90]]>>=
<<File header>>

module selectors

<<Use kinds>>
  use io_units
  use diagnostics
  use rng_base

<<Standard module head>>

<<Selectors: public>>

<<Selectors: types>>

contains

<<Selectors: procedures>>

end module selectors
@ %def selectors
@
\subsection{Selector type}
The rng object is actually the state of the random-number generator.
The methods initialize/reset and call the generator for this state.
<<Selectors: public>>=
  public :: selector_t
<<Selectors: types>>=
  type :: selector_t
     integer, dimension(:), allocatable :: map
     real(default), dimension(:), allocatable :: weight
     real(default), dimension(:), allocatable :: acc
   contains
   <<Selectors: selector: TBP>>
end type selector_t

@ %def selector_t
@ Display contents.
<<Selectors: selector: TBP>>=
  procedure :: write => selector_write
<<Selectors: procedures>>=
  subroutine selector_write (object, unit)
    class(selector_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Selector: i, weight, acc. weight"
    if (allocated (object%weight)) then
       do i = 1, size (object%weight)
          write (u, "(3x,I0,1x,ES19.12,1x,ES19.12)") &
               object%map(i), object%weight(i), object%acc(i)
       end do
    else
       write (u, "(3x,A)")  "[undefined]"
    end if
  end subroutine selector_write

@ %def selector_write
@ We pack the input weight array such that zero-weight entries are
removed.  We also normalize it.  This makes a [[map]] array for
mapping the selected weight to the actual entry necessary.

We may encounter a case where all weights are zero.  We do not reject
this, but set up the selector so that it always returns the first
entry.
<<Selectors: selector: TBP>>=
  procedure :: init => selector_init
<<Selectors: procedures>>=
  subroutine selector_init (selector, weight, negative_weights)
    class(selector_t), intent(out) :: selector
    real(default), dimension(:), intent(in) :: weight
    logical, intent(in), optional :: negative_weights
    real(default) :: s
    integer :: n, i
    logical :: neg_wgt
    logical, dimension(:), allocatable :: mask
    if (size (weight) == 0) &
         call msg_bug ("Selector init: zero-size weight array")
    neg_wgt = .false.
    if (present (negative_weights))  neg_wgt = negative_weights
    if (.not. neg_wgt .and. any (weight < 0)) &
         call msg_fatal ("Selector init: negative weight encountered")
    s = sum (weight)
    allocate (mask (size (weight)), &
         source = weight /= 0)
    n = count (mask)
    if (n > 0) then
       allocate (selector%map (n), &
            source = pack ([(i, i = 1, size (weight))], mask))
       allocate (selector%weight (n), &
            source = pack (abs (weight) / s, mask))
       allocate (selector%acc (n))
       selector%acc(1) = selector%weight(1)
       do i = 2, n - 1
          selector%acc(i) = selector%acc(i-1) + selector%weight(i)
       end do
       selector%acc(n) = 1
    else
       allocate (selector%map (1), source = 1)
       allocate (selector%weight (1), source = 0._default)
       allocate (selector%acc (1), source = 1._default)
    end if
  end subroutine selector_init

@ %def selector_init
@ Select an entry based upon the number [[x]], which should be a
uniformly distributed random number between 0 and 1.
<<Selectors: selector: TBP>>=
  procedure :: select => selector_select
<<Selectors: procedures>>=
  function selector_select (selector, x) result (n)
    class(selector_t), intent(in) :: selector
    real(default), intent(in) :: x
    integer :: n
    integer :: i
    if (x < 0 .or. x > 1) &
         call msg_bug ("Selector: random number out of range")
    do i = 1, size (selector%acc)
       if (x <= selector%acc(i))  exit
    end do
    n = selector%map(i)
  end function selector_select

@ %def selector_select
@ Use the provided random-number generator to select an entry.  (Unless there
is only one entry.)
<<Selectors: selector: TBP>>=
  procedure :: generate => selector_generate
<<Selectors: procedures>>=
  subroutine selector_generate (selector, rng, n)
    class(selector_t), intent(in) :: selector
    class(rng_t), intent(inout) :: rng
    integer, intent(out) :: n
    real(default) :: x
    select case (size (selector%acc))
    case (1);  n = 1
    case default
       call rng%generate (x)
       n = selector%select (x)
    end select
  end subroutine selector_generate

@ %def selector_generate
@ Determine the normalized weight for a selected entry.  We use a
linear search for the inverse lookup, assuming that efficiency is not
an issue for this function.
<<Selectors: selector: TBP>>=
  procedure :: get_weight => selector_get_weight
<<Selectors: procedures>>=
  function selector_get_weight (selector, n) result (weight)
    class(selector_t), intent(in) :: selector
    integer, intent(in) :: n
    real(default) :: weight
    integer :: i
    do i = 1, size (selector%weight)
       if (selector%map(i) == n) then
          weight = selector%weight(i)
          return
       end if
    end do
    weight = 0
  end function selector_get_weight

@ %def selector_get_weight
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[selectors_ut.f90]]>>=
<<File header>>

module selectors_ut
  use unit_tests
  use selectors_uti

<<Standard module head>>

<<Selectors: public test>>

contains

<<Selectors: test driver>>

end module selectors_ut
@ %def selectors_ut
@
<<[[selectors_uti.f90]]>>=
<<File header>>

module selectors_uti

<<Use kinds>>
  use rng_base

  use selectors

  use rng_base_ut, only: rng_test_t

<<Standard module head>>

<<Selectors: test declarations>>

contains

<<Selectors: tests>>

end module selectors_uti
@ %def selectors_ut
@ API: driver for the unit tests below.
<<Selectors: public test>>=
  public :: selectors_test
<<Selectors: test driver>>=
  subroutine selectors_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Selectors: execute tests>>
  end subroutine selectors_test

@ %def selectors_test
@
\subsubsection{Basic check}
Initialize the selector and draw random numbers.
<<Selectors: execute tests>>=
  call test (selectors_1, "selectors_1", &
       "rng initialization and call", &
       u, results)
<<Selectors: test declarations>>=
  public :: selectors_1
<<Selectors: tests>>=
  subroutine selectors_1 (u)
    integer, intent(in) :: u
    type(selector_t) :: selector
    class(rng_t), allocatable, target :: rng
    integer :: i, n

    write (u, "(A)")  "* Test output: selectors_1"
    write (u, "(A)")  "*   Purpose: initialize a selector and test it"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize selector"
    write (u, "(A)")

    call selector%init &
         ([2._default, 3.5_default, 0._default, &
         2._default, 0.5_default, 2._default])
    call selector%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Select numbers using predictable test generator"
    write (u, "(A)")

    allocate (rng_test_t :: rng)
    call rng%init (1)

    do i = 1, 5
       call selector%generate (rng, n)
       write (u, "(1x,I0)")  n
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Select numbers using real input number"
    write (u, "(A)")

    write (u, "(1x,A,I0)")  "select(0.00) = ", selector%select (0._default)
    write (u, "(1x,A,I0)")  "select(0.77) = ", selector%select (0.77_default)
    write (u, "(1x,A,I0)")  "select(1.00) = ", selector%select (1._default)

    write (u, "(A)")
    write (u, "(A)")  "* Get weight"
    write (u, "(A)")

    write (u, "(1x,A,ES19.12)")  "weight(2) =", selector%get_weight(2)
    write (u, "(1x,A,ES19.12)")  "weight(3) =", selector%get_weight(3)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call rng%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: selectors_1"

  end subroutine selectors_1

@ %def selectors_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{TAO Random-Number Generator}
This module provides an implementation for the generic random-number
generator.  Actually, we interface the TAO random-number generator
which is available via the VAMP package.
<<[[rng_tao.f90]]>>=
<<File header>>

module rng_tao

<<Use kinds>>
  use io_units
  use format_utils, only: write_indent
  use tao_random_numbers !NODEP!

  use rng_base

<<Standard module head>>

<<RNG tao: public>>

<<RNG tao: types>>

contains

<<RNG tao: procedures>>

end module rng_tao
@ %def rng_tao
@
\subsection{Generator type}
The rng object is actually the state of the random-number generator.
The methods initialize/reset and call the generator for this state.

We keep the seed, in case we want to recover it later, and count the
number of calls since seeding.
<<RNG tao: public>>=
  public :: rng_tao_t
<<RNG tao: types>>=
  type, extends (rng_t) :: rng_tao_t
     integer :: seed = 0
     integer :: n_calls = 0
     type(tao_random_state) :: state
   contains
   <<RNG tao: rng tao: TBP>>
  end type rng_tao_t

@ %def rng_tao_t
@ Output: Display seed and number of calls.
<<RNG tao: rng tao: TBP>>=
  procedure :: write => rng_tao_write
<<RNG tao: procedures>>=
  subroutine rng_tao_write (rng, unit, indent)
    class(rng_tao_t), intent(in) :: rng
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(A)")  "TAO random-number generator:"
    call write_indent (u, ind)
    write (u, "(2x,A,I0)")  "seed  = ", rng%seed
    call write_indent (u, ind)
    write (u, "(2x,A,I0)")  "calls = ", rng%n_calls
  end subroutine rng_tao_write

@ %def rng_tao_write
@ The [[init]] method initializes the generator and sets a seed.
We should implement the interface such that a single integer is
sufficient for a seed.

The seed may be omitted.  The default seed is 0.
<<RNG tao: rng tao: TBP>>=
  procedure :: init => rng_tao_init
<<RNG tao: procedures>>=
  subroutine rng_tao_init (rng, seed)
    class(rng_tao_t), intent(out) :: rng
    integer, intent(in), optional :: seed
    if (present (seed))  rng%seed = seed
    call tao_random_create (rng%state, rng%seed)
  end subroutine rng_tao_init

@ %def rng_tao_init
@ The [[final]] method deallocates memory where necessary and allows
for another call of [[init]] to reset the generator.
<<RNG tao: rng tao: TBP>>=
  procedure :: final => rng_tao_final
<<RNG tao: procedures>>=
  subroutine rng_tao_final (rng)
    class(rng_tao_t), intent(inout) :: rng
    call tao_random_destroy (rng%state)
  end subroutine rng_tao_final

@ %def rng_tao_final
@ These routines generate a single and an array of default-precision
random numbers, respectively.

We have to convert from explicit double to abstract default
precision.  Under normal conditions, both are equivalent, however.
Unless, someone decides to do single precision, there is always
an interface for [[tao_random_numbers]].
<<RNG tao: rng tao: TBP>>=
  procedure :: generate_single => rng_tao_generate_single
  procedure :: generate_array => rng_tao_generate_array
<<RNG tao: procedures>>=
  subroutine rng_tao_generate_single (rng, x)
    class(rng_tao_t), intent(inout) :: rng
    real(default), intent(out) :: x
    real(default) :: r
    call tao_random_number (rng%state, r)
    x = r
    rng%n_calls = rng%n_calls + 1
  end subroutine rng_tao_generate_single

  subroutine rng_tao_generate_array (rng, x)
    class(rng_tao_t), intent(inout) :: rng
    real(default), dimension(:), intent(out) :: x
    real(default) :: r
    integer :: i
    do i = 1, size (x)
       call tao_random_number (rng%state, r)
       x(i) = r
    end do
    rng%n_calls = rng%n_calls + size (x)
  end subroutine rng_tao_generate_array

@ %def rng_tao_generate_single rng_tao_generate_array
@
\subsubsection{Factory}
This factory makes [[rng_tao_t]] generators, initialized with the seeds
\begin{equation}
  s_i = s_0 * 2^{16} + i
\end{equation}
where $s_0$ is the seed (a 16-bit integer) given to the factory
object, and $i$ is the index in the generated sequence of generators,
starting with zero.
<<RNG tao: public>>=
  public :: rng_tao_factory_t
<<RNG tao: types>>=
  type, extends (rng_factory_t) :: rng_tao_factory_t
     integer(i16) :: s = 0
     integer(i16) :: i = 0
   contains
   <<RNG tao: rng tao factory: TBP>>
  end type rng_tao_factory_t

@ %def rng_tao_factory_t
@ Output.
<<RNG tao: rng tao factory: TBP>>=
  procedure :: write => rng_tao_factory_write
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_write (object, unit)
    class(rng_tao_factory_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,2(I0,A))") &
         "RNG factory: tao (", object%s, ",", object%i, ")"
  end subroutine rng_tao_factory_write

@ %def rng_tao_factory_write
@ Initialize, translating the given seed.
<<RNG tao: rng tao factory: TBP>>=
  procedure :: init => rng_tao_factory_init
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_init (factory, seed)
    class(rng_tao_factory_t), intent(out) :: factory
    integer(i16), intent(in), optional :: seed
    if (present (seed))  factory%s = seed
  end subroutine rng_tao_factory_init

@ %def rng_tao_factory_init
<<RNG tao: rng tao factory: TBP>>=
  procedure :: make => rng_tao_factory_make
<<RNG tao: procedures>>=
  subroutine rng_tao_factory_make (factory, rng)
    class(rng_tao_factory_t), intent(inout) :: factory
    class(rng_t), intent(out), allocatable :: rng
    allocate (rng_tao_t :: rng)
    select type (rng)
    type is (rng_tao_t)
       call rng%init (factory%s * 65536 + factory%i)
       factory%i = int (factory%i + 1, kind = i16)
    end select
  end subroutine rng_tao_factory_make

@ %def rng_tao_factory_make
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[rng_tao_ut.f90]]>>=
<<File header>>

module rng_tao_ut
  use unit_tests
  use rng_tao_uti

<<Standard module head>>

<<RNG tao: public test>>

contains

<<RNG tao: test driver>>

end module rng_tao_ut
@ %def rng_tao_ut
@
<<[[rng_tao_uti.f90]]>>=
<<File header>>

module rng_tao_uti

<<Use kinds>>
  use kinds, only: i16
  use rng_base

  use rng_tao

<<Standard module head>>

<<RNG tao: test declarations>>

contains

<<RNG tao: tests>>

end module rng_tao_uti
@ %def rng_tao_ut
@ API: driver for the unit tests below.
<<RNG tao: public test>>=
  public :: rng_tao_test
<<RNG tao: test driver>>=
  subroutine rng_tao_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<RNG tao: execute tests>>
  end subroutine rng_tao_test

@ %def rng_tao_test
@
\subsubsection{Generator check}
Initialize the generator and draw random numbers.
<<RNG tao: execute tests>>=
  call test (rng_tao_1, "rng_tao_1", &
       "rng initialization and call", &
       u, results)
<<RNG tao: test declarations>>=
  public :: rng_tao_1
<<RNG tao: tests>>=
  subroutine rng_tao_1 (u)
    integer, intent(in) :: u
    class(rng_t), allocatable, target :: rng

    real(default) :: x
    real(default), dimension(2) :: x2

    write (u, "(A)")  "* Test output: rng_tao_1"
    write (u, "(A)")  "*   Purpose: initialize and call the TAO random-number &
         &generator"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize generator (default seed)"
    write (u, "(A)")

    allocate (rng_tao_t :: rng)
    call rng%init ()

    call rng%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Get random number"
    write (u, "(A)")

    call rng%generate (x)
    write (u, "(A,2(1x,F9.7))")  "x =", x

    write (u, "(A)")
    write (u, "(A)")  "* Get random number pair"
    write (u, "(A)")

    call rng%generate (x2)
    write (u, "(A,2(1x,F9.7))")  "x =", x2

    write (u, "(A)")
    call rng%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call rng%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_tao_1"

  end subroutine rng_tao_1

@ %def rng_tao_1
@
\subsubsection{Factory check}
Set up a factory and spawn generators.
<<RNG tao: execute tests>>=
  call test (rng_tao_2, "rng_tao_2", &
       "rng factory", &
       u, results)
<<RNG tao: test declarations>>=
  public :: rng_tao_2
<<RNG tao: tests>>=
  subroutine rng_tao_2 (u)
    integer, intent(in) :: u
    type(rng_tao_factory_t) :: rng_factory
    class(rng_t), allocatable :: rng
    real(default) :: x

    write (u, "(A)")  "* Test output: rng_tao_2"
    write (u, "(A)")  "*   Purpose: initialize and use a rng factory"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize factory"
    write (u, "(A)")

    call rng_factory%init ()
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Make a generator"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)

    write (u, "(A)")
    write (u, "(A)")  "* Repeat"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)

    write (u, *)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize factory with different seed"
    write (u, "(A)")

    call rng_factory%init (1_i16)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Make a generator"
    write (u, "(A)")

    call rng_factory%make (rng)
    call rng%write (u)
    call rng%generate (x)
    write (u, *)
    write (u, "(1x,A,F7.5)")  "x = ", x
    call rng%final ()
    deallocate (rng)

    write (u, *)
    call rng_factory%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rng_tao_2"

  end subroutine rng_tao_2

@ %def rng_tao_2
\section{Dispatch}
@
<<[[dispatch_rng.f90]]>>=
<<File header>>

module dispatch_rng

  use kinds, only: i16
<<Use strings>>
  use diagnostics
  use variables

  use rng_base
  use rng_tao

<<Standard module head>>

<<Dispatch rng: public>>

<<Dispatch rng: variables>>

contains

<<Dispatch rng: procedures>>

end module dispatch_rng
@ %def dispatch_rng
Allocate a random-number generator factory according to the variable
[[$rng_method]], using the current seed in the global record.  We take
only the lower 15 bits of the seed, so the actual value fits into a
positive 16-bit signed integer.

Since we want to guarantee that all random-number generators in a run
are independent, we increment the global seed by one after creating
the rng factory.  If the user wants to have identical sequences, he
can always set the seed manually, before it is used.
<<Dispatch rng: public>>=
  public :: dispatch_rng_factory
<<Dispatch rng: procedures>>=
  subroutine dispatch_rng_factory (rng_factory, var_list_global, var_list_local)
    class(rng_factory_t), allocatable, intent(inout) :: rng_factory
    type(var_list_t), intent(inout) :: var_list_global
    type(var_list_t), intent(in), optional :: var_list_local
    type(var_list_t) :: local
    type(string_t) :: rng_method
    integer :: seed
    character(30) :: buffer
    integer(i16) :: s
    if (present (var_list_local)) then
       local = var_list_local
    else
       local = var_list_global
    end if
    rng_method = local%get_sval (var_str ("$rng_method"))
    seed = local%get_ival (var_str ("seed"))
    s = int (mod (seed, 32768), i16)
    select case (char (rng_method))
    case ("tao")
       allocate (rng_tao_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing TAO random-number generator")
    case default
       if (associated (dispatch_rng_factory_extra)) then
          call dispatch_rng_factory_extra (rng_factory, var_list_global, var_list_local)
       end if
       if (.not. allocated (rng_factory)) then
          call msg_fatal ("Random-number generator '" &
               // char (rng_method) // "' not implemented")
       end if
    end select
    write (buffer, "(I0)")  s
    call msg_message ("RNG: Setting seed for random-number generator to " &
            // trim (buffer))
    call rng_factory%init (s)
    call var_list_global%set_int (var_str ("seed"), seed + 1, &
         is_known = .true.)
  end subroutine dispatch_rng_factory

@ %def dispatch_rng_factory
@ This is a hook that allows us to inject further handlers for
RNG factory objects, in particular a test RNG.
<<Dispatch rng: public>>=
  public :: dispatch_rng_factory_extra
<<Dispatch rng: variables>>=
  procedure (dispatch_rng_factory), pointer :: &
       dispatch_rng_factory_extra => null ()
@ %def dispatch_rng_factory_extra
@
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[dispatch_rng_ut.f90]]>>=
<<File header>>

module dispatch_rng_ut
  use unit_tests
  use dispatch_rng_uti

<<Standard module head>>

<<Dispatch rng: public test>>

<<Dispatch rng: public test auxiliary>>

contains

<<Dispatch rng: test driver>>

end module dispatch_rng_ut
@ %def dispatch_rng_ut
@
<<[[dispatch_rng_uti.f90]]>>=
<<File header>>

module dispatch_rng_uti

<<Use strings>>
  use variables
  use diagnostics
  use rng_base
  use dispatch_rng

<<Standard module head>>

<<Dispatch rng: public test auxiliary>>

<<Dispatch rng: test declarations>>

contains

<<Dispatch rng: tests>>

<<Dispatch rng: test auxiliary>>

end module dispatch_rng_uti
@ %def dispatch_rng_ut
@ API: driver for the unit tests below.
<<Dispatch rng: public test>>=
  public ::dispatch_rng_test
<<Dispatch rng: test driver>>=
  subroutine dispatch_rng_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Dispatch rng: execute tests>>
  end subroutine dispatch_rng_test

@  %def dispatch_rng_test
\subsubsection{Select type: random number generator}
This is an extra dispatcher that enables the test RNG.  This procedure
should be assigned to the [[dispatch_rng_factory_extra]] hook before
any tests are executed.
<<Dispatch rng: public test auxiliary>>=
  public :: dispatch_rng_factory_test
<<Dispatch rng: test auxiliary>>=
  subroutine dispatch_rng_factory_test (rng_factory, var_list_global, var_list_local)
    use rng_base
    use rng_base_ut, only: rng_test_factory_t
    class(rng_factory_t), allocatable, intent(inout) :: rng_factory
    type(var_list_t), intent(inout) :: var_list_global
    type(var_list_t), intent(in), optional :: var_list_local
    type(var_list_t) :: local
    type(string_t) :: rng_method
    if (present (var_list_local)) then
       local = var_list_local
    else
       local = var_list_global
    end if
    rng_method = &
         local%get_sval (var_str ("$rng_method"))
    select case (char (rng_method))
    case ("unit_test")
       allocate (rng_test_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing Test random-number generator")
    end select
  end subroutine dispatch_rng_factory_test

@ %def dispatch_rng_factory_test
@
<<Dispatch rng: execute tests>>=
  call test (dispatch_rng_1, "dispatch_rng_1", &
       "random-number generator", &
       u, results)
<<Dispatch rng: test declarations>>=
  public :: dispatch_rng_1
<<Dispatch rng: tests>>=
  subroutine dispatch_rng_1 (u)
    integer, intent(in) :: u
    type(var_list_t) :: var_list
    class(rng_factory_t), allocatable :: rng_factory

    write (u, "(A)")  "* Test output: dispatch_rng_1"
    write (u, "(A)")  "*   Purpose: select random-number generator"
    write (u, "(A)")

    call var_list%init_defaults (0)

    write (u, "(A)")  "* Allocate RNG factory as rng_test_factory_t"
    write (u, "(A)")

    call var_list%set_string (&
         var_str ("$rng_method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list%set_int (&
         var_str ("seed"), 1, is_known = .true.)
    call dispatch_rng_factory (rng_factory, var_list)
    call rng_factory%write (u)
    deallocate (rng_factory)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate RNG factory as rng_tao_factory_t"
    write (u, "(A)")

    call var_list%set_string (&
         var_str ("$rng_method"), &
         var_str ("tao"), is_known = .true.)
    call dispatch_rng_factory (rng_factory, var_list)
    call rng_factory%write (u)
    deallocate (rng_factory)

    call var_list%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_rng_1"

  end subroutine dispatch_rng_1

@ %def dispatch_rng_1
@
