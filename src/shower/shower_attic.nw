%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Attic}
<<Procedures of [[shower_add_interaction_2ton_CKKW]] (not used)>>=
function shower_clustering_allowed (shower, partons, i, j) result (allowed)
  type(shower_t), intent(inout) :: shower
  logical :: allowed
  type(parton_pointer_t), intent(in), dimension(:), allocatable :: partons
  integer, intent(in) :: i, j
  !!! TODO implement checking if clustering is allowed, e.g.
  !!!     in e+e- -> qqg don't cluster the quarks together first
  allowed = .true.
end function shower_clustering_allowed

@
<<Shower core: procedures (not used)>>=
  subroutine shower_get_final_partons (shower, partons, include_remnants)
    type(shower_t), intent(in) :: shower
    type(parton_pointer_t), dimension(:), allocatable, intent(inout) :: partons
    logical, intent(in), optional :: include_remnants
    integer :: i, j
    type(parton_t), pointer :: prt
    if (allocated (partons))  deallocate (partons)
    allocate (partons(1:shower%get_nr_of_partons( &
         include_remnants = include_remnants)))
    j = 0
    do i = 1, size (shower%partons)
       prt => shower%partons(i)%p
       if (.not. associated (prt)) cycle
       if (.not. parton_is_final (prt)) cycle
       if (prt%type == BEAM_REMNANT) then
          if (present (include_remnants)) then
             if (.not. include_remnants) cycle
          end if
       end if
       j = j + 1
       partons(j)%p => prt
    end do
  end subroutine shower_get_final_partons

@ %def shower_get_final_partons
@
<<Shower core: procedures (not used)>>=
  function shower_interaction_get_shat (interaction) result (shat)
    type(shower_interaction_t), intent(in) :: interaction
    real(default) :: shat
    shat = (interaction%partons(1)%p%momentum + &
            interaction%partons(2)%p%momentum)**2
  end function shower_interaction_get_shat

@ %def shower_interaction_get_shat
@
<<Shower core: procedures (not used)>>=
  function shower_is_finished (shower) result (finished)
    type(shower_t), intent(in) :: shower
    logical :: finished
    finished = shower_isr_is_finished (shower) .and. &
               shower_fsr_is_finished(shower)
  end function shower_is_finished

@ %def shower_is_finished
@
<<Shower core: procedures (not used)>>=
  subroutine shower_prepare_for_simulate_isr_ana (shower, prt1, prt2)
    type(shower_t), intent(inout) :: shower
    type(parton_t), intent(inout), target :: prt1, prt2
    type(parton_t), pointer :: prt
    real(default) :: scale, factor
    real(default) :: oldscales(1:2)
    type(parton_pointer_t) :: temppp
    integer :: i

    if (signal_is_pending ()) return

    if (.not. associated (prt1%initial) .or. &
        .not. associated (prt2%initial)) then
       return
    end if

    scale = - (prt1%momentum + prt2%momentum) ** 2

    prt1%t = -shower%tscalefactor_isr * abs(scale)
    prt2%t = -shower%tscalefactor_isr * abs(scale)
    !!! rescale momenta
    do i = 1, 2
       if (i == 1) then
          prt => prt1
       else
          prt => prt2
       end if

       factor = sqrt (prt%momentum%p(0)**2 - prt%t) / &
            space_part_norm(prt%momentum)

       prt%momentum = vector4_moving (prt%momentum%p(0), &
            factor * space_part (prt%momentum))
    end do

    !!! ensure that belongstointeraction bits are set correctly
    prt1%belongstointeraction = .true.
    prt2%belongstointeraction = .true.

    call shower%add_parent (prt1)
    call shower%add_parent (prt2)

    call parton_set_simulated (prt1)
    prt1%parent%type = prt1%type
    prt1%parent%z = one
    prt1%parent%momentum = prt1%momentum
    prt1%parent%t = scale
    prt1%parent%x = prt1%x
    prt1%parent%initial => prt1%initial
    prt1%parent%belongstoFSR = .false.
    prt1%parent%c1 = prt1%c1
    prt1%parent%c2 = prt1%c2
    call shower%add_child (prt1%parent, 2)

    call parton_set_simulated (prt2)
    prt2%parent%type = prt2%type
    prt2%parent%z = one
    prt2%parent%momentum = prt2%momentum
    prt2%parent%t = scale
    prt2%parent%x = prt2%x
    prt2%parent%initial => prt2%initial
    prt2%parent%belongstoFSR = .false.
    prt2%parent%c1 = prt2%c1
    prt2%parent%c2 = prt2%c2
    call shower%add_child (prt2%parent, 2)

    FIRST_BRANCHINGS: do
       if (signal_is_pending ()) return
       oldscales(1) = prt1%parent%t
       oldscales(2) = prt2%parent%t
       if (abs(prt1%parent%t) > abs(prt2%parent%t)) then
          temppp%p => prt1%parent
       else
          temppp%p => prt2%parent
       end if
       if (.not. temppp%p%simulated .and. .not. parton_is_proton &
            (temppp%p)) then
          call shower_isr_step (shower, temppp%p)
          if (temppp%p%simulated) then
             ! call parton_generate_ps_ini(prt2%parent)
             if (temppp%p%t < zero) then
                call shower%execute_next_isr_branching (temppp)
                ! call shower%write ()
             else
                call shower_replace_parent_by_hadron (shower, temppp%p%child1)
             end if
          end if
       end if

       if (oldscales(1) == prt1%parent%t .and. &
           oldscales(2) == prt2%parent%t) then
          exit FIRST_BRANCHINGS
       end if
    end do FIRST_BRANCHINGS

  end subroutine shower_prepare_for_simulate_isr_ana

@ %def shower_prepare_for_simulate_isr_ana
@
<<Shower core: procedures (not used)>>=
  subroutine shower_generate_next_fsr_branchings (shower)
    type(shower_t), intent(inout) :: shower
    integer i, index
    type(parton_t),  pointer :: prt

    !!! find mother with highest t to be simulated
    index = 0
    do i = 1, size (shower%partons)
       prt => shower%partons(i)%p
       if (.not. prt%belongstoFSR .or. prt%belongstointeraction) cycle
       if (associated(prt%child1) .and. associated(prt%child2)) then
          if (prt%child1%simulated .and. &
              prt%child2%simulated) cycle
       end if
       if (parton_is_final (prt)) cycle
         index = i
         exit
      end do

      if (index == 0) then
         call msg_message ("Shower: no branchable partons found")
         return
      end if

      prt => shower%partons(index)%p
      call shower_simulate_children_ana (shower, prt)

    end subroutine shower_generate_next_fsr_branchings

@ %def shower_generate_next_fsr_branchings
@
<<Shower PYTHIA6: procedures (not used)>>=
  recursive subroutine shower_topythia_recursive_weighted (prt, mode, first)
    IMPLICIT DOUBLE PRECISION(A-H, O-Z)
    IMPLICIT INTEGER(I-N)
    !    C...  Commonblocks.
    COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
    COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
    COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
    COMMON/PYDAT3/MDCY(500,3),MDME(8000,2),BRAT(8000),KFDP(8000,5)
    COMMON/PYSUBS/MSEL,MSELPD,MSUB(500),KFIN(2,-40:40),CKIN(200)
    COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
    SAVE /PYJETS/,/PYDAT1/,/PYDAT2/,/PYDAT3/,/PYSUBS/,/PYPARS/

    type(parton_t), intent(in), target :: prt
    integer, intent(in) :: mode, first
    integer :: n_emissions
    type(parton_t), pointer :: tempprt, finalprt
    real(default), dimension(:), allocatable :: costhetas
    type(parton_pointer_t), dimension(:), allocatable :: emittedpartons
    integer :: i, max
    real(default) :: maxcostheta

    n_emissions = 0

    if (parton_is_final(prt)) then
       N = N + 1
       K(N,1) = 2
       if (parton_is_quark(prt)) then
          ! check if quark is end of a color connection
          if (prt%type < 0) then
             K(N,1) = 1
          end if
       end if
       K(N,2) = prt%type
       K(N,3) = first
       K(N,4) = 0
       K(N,5) = 0
       P(N,1) = prt%momentum%p(1)
       P(N,2) = prt%momentum%p(2)
       P(N,3) = prt%momentum%p(3)
       P(N,4) = prt%momentum%p(0)
       P(N,5) = prt%t
    else
       !!! search for following final partons
       if (parton_is_gluon (prt)) then
          if (parton_is_gluon(prt%child1)) then
             !!! g-> gg so sequence is unimportant
             call shower_topythia_recursive_weighted (prt%child1, 1, first)
             call shower_topythia_recursive_weighted (prt%child2, 1, first)
          else
             !!! g-> qqbar -> use antiquark first,
             !!!       so that color flow is given correctly
             if (prt%child1%type < 0) then
                call shower_topythia_recursive_weighted (prt%child1, 1, first)
                call shower_topythia_recursive_weighted (prt%child2, 2, first)
             else
                call shower_topythia_recursive_weighted (prt%child2, 2, first)
                call shower_topythia_recursive_weighted (prt%child1, 1, first)
             end if
          end if
       else
          !!! parton is quark
          !!! find the emitted gluons and order them by the emission angle
          n_emissions = 0
          tempprt = prt
          do
             !!! calculate how many emissions there are
             if (associated (tempprt%child1)) then
                tempprt => tempprt%child1
                n_emissions = n_emissions +1
                cycle
             else
                exit
             end if
          end do

          allocate (costhetas(1:n_emissions))
          allocate (emittedpartons(1:n_emissions))

          tempprt => prt
          n_emissions = 1
          do
             if (associated (tempprt%child1)) then
                costhetas(n_emissions) = parton_get_costheta_correct (tempprt)
                emittedpartons(n_emissions)%p => tempprt%child2
                n_emissions = n_emissions +1
                tempprt => tempprt%child1
                cycle
             else
                finalprt=>tempprt
                exit
             end if
          end do

          !!! if mode == 1 write quark first
          if (mode == 1) &
               call shower_topythia_recursive_weighted (finalprt, 1, first)

          !!! if mode == 2 write out gluons in recursive order <= replace
          !!!      costheta by 1- costheta
          if (mode == 2) then
             do i = 1, size (costhetas)
                costhetas(i) = one - costhetas(i)
             end do
          end if

          do
             max = 0
             maxcostheta = zero
             do i = 1, size (costhetas)
                if (costhetas(i) > maxcostheta) then
                   maxcostheta = costhetas(i)
                   max = i
                end if
             end do
             if (maxcostheta == zero) then
                exit
             end if

             call shower_topythia_recursive_weighted &
                  (emittedpartons(max)%p, mode, first)
             costhetas(max) = zero
          end do

          !!! if mode == 2 write quark last
          if (mode == 2) then
             call shower_topythia_recursive_weighted (finalprt, 2, first)
          end if

       end if
    end if
  end subroutine shower_topythia_recursive_weighted

@ %def shower_topythia_recursive_weighted
@
<<MLM matching: procedures (not used)>>=
  SUBROUTINE KTCLUS(IMODE,PP,NN,ECUT,Y,*)
    IMPLICIT NONE
!C---DO CLUSTER ANALYSIS OF PARTICLES IN PP
!C
!C   IMODE   = INPUT  : DESCRIBED ABOVE
!C   PP(I,J) = INPUT  : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
!C   NN      = INPUT  : NUMBER OF PARTICLES
!C   ECUT    = INPUT  : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   Y(J)    = OUTPUT : VALUE OF Y FOR WHICH EVENT CHANGES FROM BEING
!C                        J JET TO J-1 JET
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED (MOST LIKELY DUE TO TOO MANY PARTICLES)
!C
!C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
!C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
    INTEGER IMODE,NN
    DOUBLE PRECISION PP(4,*)
    DOUBLE PRECISION ECUT,Y(*),ONE
    ONE=1
    CALL KTCLUR(IMODE,PP,NN,ONE,ECUT,Y,*999)
    RETURN
999 RETURN 1
  END SUBROUTINE KTCLUS
!C-----------------------------------------------------------------------
<<MLM matching: procedures (not used)>>=
      SUBROUTINE KTYCUT(ECUT,NY,YCUT,NJET,*)
      IMPLICIT NONE
!C---COUNT THE NUMBER OF JETS AT EACH VALUE OF YCUT, FOR EVENT WHICH HAS
!C   ALREADY BEEN ANALYSED BY KTCLUS.
!C
!C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   NY      = INPUT : NUMBER OF YCUT VALUES
!C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF JETS ARE COUNTED
!C   NJET(J) =OUTPUT : NUMBER OF JETS AT YCUT(J)
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NY,NJET(NY),NMAX,HIST,I,J,NUM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION YCUT(NY),ETOT,RSQ,P,KT,KTP,KTS,ETSQ,ECUT,KTLAST, &
           ROUND
      PARAMETER (ROUND=0.99999D0)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTYCUT',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      DO I=1,NY
         NJET(I)=0
      END DO
      DO I=NUM,1,-1
         DO J=1,NY
            IF (NJET(J).EQ.0.AND.KT(I)*ETSQ.GE.ROUND*YCUT(J)) NJET(J)=I
         END DO
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTYCUT
!C-----------------------------------------------------------------------
    SUBROUTINE KTYSUB(ECUT,NY,YCUT,YMAC,NSUB,*)
      IMPLICIT NONE
!C---COUNT THE NUMBER OF SUB-JETS AT EACH VALUE OF YCUT, FOR EVENT WHICH
!C   HAS ALREADY BEEN ANALYSED BY KTCLUS.
!C   REMEMBER THAT A SUB-JET IS DEFINED AS A JET AT Y=YCUT WHICH HAS NOT
!C   YET BEEN MERGED WITH THE BEAM AT Y=YMAC.
!C
!C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   NY      = INPUT : NUMBER OF YCUT VALUES
!C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF SUB-JETS ARE COUNTED
!C   YMAC    = INPUT : Y VALUE USED TO DEFINE MACRO-JETS, TO DETERMINE
!C                       WHICH JETS ARE SUB-JETS
!C   NSUB(J) =OUTPUT : NUMBER OF SUB-JETS AT YCUT(J)
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NY,NSUB(NY),NMAX,HIST,I,J,NUM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION YCUT(NY),YMAC,ETOT,RSQ,P,KT,KTP,KTS,ETSQ,ECUT, &
           KTLAST,ROUND
      PARAMETER (ROUND=0.99999D0)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTYSUB',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      DO I=1,NY
         NSUB(I)=0
      END DO
      DO I=NUM,1,-1
         DO J=1,NY
            IF (NSUB(J).EQ.0.AND.KT(I)*ETSQ.GE.ROUND*YCUT(J)) NSUB(J)=I
            IF (NSUB(J).NE.0.AND.KTLAST(I)*ETSQ.LT.ROUND*YMAC) &
                 NSUB(J)=NSUB(J)-1
         END DO
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTYSUB
!C-----------------------------------------------------------------------
    SUBROUTINE KTBEAM(ECUT,Y,*)
      IMPLICIT NONE
!C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
!C   TRANSITIONS WHERE A JET WAS MERGED WITH THE BEAM JET ARE RECORDED
!C
!C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   Y(J)    =OUTPUT : Y VALUE WHERE Jth HARDEST JET WAS MERGED WITH BEAM
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,HIST,NUM,I,J
      PARAMETER (NMAX=512)
      DOUBLE PRECISION ETOT,RSQ,P,KT,KTP,KTS,ECUT,ETSQ,Y(*),KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTBEAM',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      J=1
      DO I=1,NUM
         IF (HIST(I).LE.NMAX) THEN
            Y(J)=ETSQ*KT(I)
            J=J+1
         ENDIF
      END DO
      DO I=J,NUM
         Y(I)=0
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTBEAM
!C-----------------------------------------------------------------------
    SUBROUTINE KTJOIN(ECUT,YMAC,Y,*)
      IMPLICIT NONE
!C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
!C   TRANSITIONS WHERE TWO SUB-JETS WERE JOINED ARE RECORDED
!C   REMEMBER THAT A SUB-JET IS DEFINED AS A JET AT Y=YCUT WHICH HAS NOT
!C   YET BEEN MERGED WITH THE BEAM AT Y=YMAC.
!C
!C   ECUT    = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   YMAC    = INPUT : VALUE OF Y USED TO DEFINE MACRO-JETS
!C   Y(J)    =OUTPUT : Y VALUE WHERE EVENT CHANGED FROM HAVING
!C                         N+J SUB-JETS TO HAVING N+J-1, WHERE N IS
!C                         THE NUMBER OF MACRO-JETS AT SCALE YMAC
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,HIST,NUM,I,J
      PARAMETER (NMAX=512)
      DOUBLE PRECISION ETOT,RSQ,P,KT,KTP,KTS,ECUT,ETSQ,Y(*),YMAC,KTLAST, &
           ROUND
      PARAMETER (ROUND=0.99999D0)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      IF (ETOT.EQ.0) CALL KTWARN('KTJOIN',100,*999)
      IF (ECUT.EQ.0) THEN
         ETSQ=1/ETOT**2
      ELSE
         ETSQ=1/ECUT**2
      ENDIF
      J=1
      DO I=1,NUM
         IF (HIST(I).GT.NMAX.AND.ETSQ*KTLAST(I).GE.ROUND*YMAC) THEN
            Y(J)=ETSQ*KT(I)
            J=J+1
         ENDIF
      END DO
      DO I=J,NUM
         Y(I)=0
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTJOIN
<<MLM matching: procedures (not used)>>=
    SUBROUTINE KTINCL(RECO,PP,NN,PJET,JET,NJET,*)
      IMPLICIT NONE
!C---RECONSTRUCT KINEMATICS OF JET SYSTEM, WHICH HAS ALREADY BEEN
!C   ANALYSED BY KTCLUS ACCORDING TO THE INCLUSIVE JET DEFINITION. NOTE
!C   THAT NO CONSISTENCY CHECK IS MADE: USER IS TRUSTED TO USE THE SAME
!C   PP VALUES AS FOR KTCLUS
!C
!C   RECO     = INPUT : RECOMBINATION SCHEME (NEED NOT BE SAME AS KTCLUS)
!C   PP(I,J)  = INPUT : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
!C   NN       = INPUT : NUMBER OF PARTICLES
!C   PJET(I,J)=OUTPUT : 4-MOMENTUM OF Jth JET AT SCALE YCUT
!C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE
!C   NJET     =OUTPUT : THE NUMBER OF JETS
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
!C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,RECO,NUM,N,NN,NJET,JET(*),HIST,IMIN,JMIN,I,J
      PARAMETER (NMAX=512)
      DOUBLE PRECISION PP(4,*),PJET(4,*)
      DOUBLE PRECISION P,KT,KTP,KTS,ETOT,RSQ,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
!C---CHECK INPUT
      IF (RECO.LT.1.OR.RECO.GT.3) CALL KTWARN('KTINCL',100,*999)
!C---COPY PP TO P
      N=NN
      IF (NUM.NE.NN) CALL KTWARN('KTINCL',101,*999)
      CALL KTCOPY(PP,N,P,(RECO.NE.1))
!C---INITIALLY EVERY PARTICLE IS IN ITS OWN JET
      DO I=1,NN
         JET(I)=I
      END DO
!C---KEEP MERGING TO THE BITTER END
      NJET=0
200   IF (N.GT.0) THEN
         IF (HIST(N).LE.NMAX) THEN
            IMIN=0
            JMIN=HIST(N)
            NJET=NJET+1
            IF (RECO.EQ.1) THEN
               DO J=1,4
                  PJET(J,NJET)=P(J,JMIN)
               END DO
            ELSE
               PJET(1,NJET)=P(6,JMIN)*COS(P(8,JMIN))
               PJET(2,NJET)=P(6,JMIN)*SIN(P(8,JMIN))
               PJET(3,NJET)=P(6,JMIN)*SINH(P(7,JMIN))
               PJET(4,NJET)=P(6,JMIN)*COSH(P(7,JMIN))
            ENDIF
            CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,0)
         ELSE
            IMIN=HIST(N)/NMAX
            JMIN=HIST(N)-IMIN*NMAX
            CALL KTMERG(P,KTP,KTS,NMAX,IMIN,JMIN,N,0,0,0,RECO)
            CALL KTMOVE(P,KTP,KTS,NMAX,N,JMIN,0)
         ENDIF
         DO I=1,NN
            IF (JET(I).EQ.JMIN) JET(I)=IMIN
            IF (JET(I).EQ.N) JET(I)=JMIN
            IF (JET(I).EQ.0) JET(I)=-NJET
         END DO
         N=N-1
         GOTO 200
      ENDIF
!C---FINALLY EVERY PARTICLE MUST BE IN AN INCLUSIVE JET
      DO I=1,NN
!C---IF THERE ARE ANY UNASSIGNED PARTICLES SOMETHING MUST HAVE GONE WRONG
         IF (JET(I).GE.0) CALL KTWARN('KTINCL',102,*999)
         JET(I)=-JET(I)
      END DO
      RETURN
 999  RETURN 1
    END SUBROUTINE KTINCL
!C-----------------------------------------------------------------------
    SUBROUTINE KTISUB(N,NY,YCUT,NSUB,*)
      IMPLICIT NONE
!C---COUNT THE NUMBER OF SUB-JETS IN THE Nth INCLUSIVE JET OF AN EVENT
!C   THAT HAS ALREADY BEEN ANALYSED BY KTCLUS.
!C
!C   N       = INPUT : WHICH INCLUSIVE JET TO USE
!C   NY      = INPUT : NUMBER OF YCUT VALUES
!C   YCUT(J) = INPUT : Y VALUES AT WHICH NUMBERS OF SUB-JETS ARE COUNTED
!C   NSUB(J) =OUTPUT : NUMBER OF SUB-JETS AT YCUT(J)
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER N,NY,NSUB(NY),NMAX,HIST,I,J,NUM,NM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION YCUT(NY),ETOT,RSQ,P,KT,KTP,KTS,KTLAST,ROUND,EPS
      PARAMETER (ROUND=0.99999D0)
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DATA EPS/1D-6/
      DO I=1,NY
         NSUB(I)=0
      END DO
!C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO I=NUM,1,-1
        IF (HIST(I).LE.NMAX) J=J+1
        IF (J.EQ.N) THEN
          NM=I
          GOTO 120
        ENDIF
     END DO
120  CONTINUE
!C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
      IF (NM.EQ.0) CALL KTWARN('KTISUB',100,*999)
      DO I=NUM,1,-1
         DO J=1,NY
            IF (NSUB(J).EQ.0.AND.RSQ*KT(I).GE.ROUND*YCUT(J)*KT(NM)) &
                 NSUB(J)=I
            IF (NSUB(J).NE.0.AND.ABS(KTLAST(I)-KTLAST(NM)).GT.EPS) &
                 NSUB(J)=NSUB(J)-1
         END DO
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTISUB
!C-----------------------------------------------------------------------
    SUBROUTINE KTIJOI(N,Y,*)
      IMPLICIT NONE
!C---GIVE SAME INFORMATION AS LAST CALL TO KTCLUS EXCEPT THAT ONLY
!C   MERGES OF TWO SUB-JETS INSIDE THE Nth INCLUSIVE JET ARE RECORDED
!C
!C   N       = INPUT : WHICH INCLUSIVE JET TO USE
!C   Y(J)    =OUTPUT : Y VALUE WHERE JET CHANGED FROM HAVING
!C                         J+1 SUB-JETS TO HAVING J
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,HIST,NUM,I,J,N,NM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION ETOT,RSQ,P,KT,KTP,KTS,Y(*),KTLAST,EPS
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DATA EPS/1D-6/
!C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO I=NUM,1,-1
        IF (HIST(I).LE.NMAX) J=J+1
        IF (J.EQ.N) THEN
          NM=I
          GOTO 105
        ENDIF
     END DO
105  CONTINUE
!C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
     IF (NM.EQ.0) CALL KTWARN('KTIJOI',100,*999)
     J=1
     DO I=1,NUM
        IF (HIST(I).GT.NMAX.AND.ABS(KTLAST(I)-KTLAST(NM)).LT.EPS) THEN
           Y(J)=RSQ*KT(I)/KT(NM)
           J=J+1
        ENDIF
     END DO
     DO I=J,NUM
        Y(I)=0
     END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTIJOI
!C-----------------------------------------------------------------------
    SUBROUTINE KTIREC(RECO,PP,NN,N,YCUT,PSUB,NSUB,*)
      IMPLICIT NONE
!C---RECONSTRUCT KINEMATICS OF SUB-JET SYSTEM IN THE Nth INCLUSIVE JET
!C   OF AN EVENT THAT HAS ALREADY BEEN ANALYSED BY KTCLUS
!C
!C   RECO     = INPUT : RECOMBINATION SCHEME (NEED NOT BE SAME AS KTCLUS)
!C   PP(I,J)  = INPUT : 4-MOMENTUM OF Jth PARTICLE: I=1,4 => PX,PY,PZ,E
!C   NN       = INPUT : NUMBER OF PARTICLES
!C   N        = INPUT : WHICH INCLUSIVE JET TO USE
!C   YCUT     = INPUT : Y VALUE AT WHICH TO RECONSTRUCT JET MOMENTA
!C   PSUB(I,J)=OUTPUT : 4-MOMENTUM OF Jth SUB-JET AT SCALE YCUT
!C   NSUB     =OUTPUT : THE NUMBER OF SUB-JETS
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT THE MOMENTA ARE DECLARED DOUBLE PRECISION,
!C   AND ALL OTHER FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,RECO,NUM,NN,NJET,NSUB,JET,HIST,I,J,N,NM
      PARAMETER (NMAX=512)
      DOUBLE PRECISION PP(4,*),PSUB(4,*)
      DOUBLE PRECISION ECUT,P,KT,KTP,KTS,ETOT,RSQ,YCUT,YMAC,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DIMENSION JET(NMAX)
!C---FIND WHICH MERGING CORRESPONDS TO THE NTH INCLUSIVE JET
      NM=0
      J=0
      DO I=NUM,1,-1
         IF (HIST(I).LE.NMAX) J=J+1
         IF (J.EQ.N) THEN
            NM=I
            GOTO 110
         ENDIF
      END DO
110   CONTINUE
!C---GIVE UP IF THERE ARE LESS THAN N INCLUSIVE JETS
      IF (NM.EQ.0) CALL KTWARN('KTIREC',102,*999)
!C---RECONSTRUCT THE JETS AT THE APPROPRIATE SCALE
      ECUT=SQRT(KT(NM)/RSQ)
      YMAC=RSQ
      CALL KTRECO(RECO,PP,NN,ECUT,YCUT,YMAC,PSUB,JET,NJET,NSUB,*999)
!C---GET RID OF THE ONES THAT DO NOT END UP IN THE JET WE WANT
      NSUB=0
      DO I=1,NJET
         IF (JET(I).EQ.HIST(NM)) THEN
            NSUB=NSUB+1
            DO J=1,4
               PSUB(J,NSUB)=PSUB(J,I)
            END DO
         ENDIF
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTIREC
!C-----------------------------------------------------------------------
    SUBROUTINE KTWICH(ECUT,YCUT,JET,NJET,*)
      IMPLICIT NONE
!C---GIVE A LIST OF WHICH JET EACH ORIGINAL PARTICLE ENDED UP IN AT SCALE
!C   YCUT, TOGETHER WITH THE NUMBER OF JETS AT THAT SCALE.
!C
!C   ECUT     = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   YCUT     = INPUT : Y VALUE AT WHICH TO DEFINE JETS
!C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE,
!C                        SET TO ZERO IF IT WAS PUT INTO THE BEAM JETS
!C   NJET     =OUTPUT : THE NUMBER OF JETS AT SCALE YCUT (SO JET()
!C                        ENTRIES WILL BE IN THE RANGE 0 -> NJET)
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER JET(*),NJET,NTEMP
      DOUBLE PRECISION ECUT,YCUT
      CALL KTWCHS(ECUT,YCUT,YCUT,JET,NJET,NTEMP,*999)
      RETURN
 999  RETURN 1
    END SUBROUTINE KTWICH
!C-----------------------------------------------------------------------
    SUBROUTINE KTWCHS(ECUT,YCUT,YMAC,JET,NJET,NSUB,*)
      IMPLICIT NONE
!C---GIVE A LIST OF WHICH SUB-JET EACH ORIGINAL PARTICLE ENDED UP IN AT
!C   SCALE YCUT, WITH MACRO-JET SCALE YMAC, TOGETHER WITH THE NUMBER OF
!C   JETS AT SCALE YCUT AND THE NUMBER OF THEM WHICH ARE SUB-JETS.
!C
!C   ECUT     = INPUT : DENOMINATOR OF KT MEASURE. IF ZERO, ETOT IS USED
!C   YCUT     = INPUT : Y VALUE AT WHICH TO DEFINE JETS
!C   YMAC     = INPUT : Y VALUE AT WHICH TO DEFINE MACRO-JETS
!C   JET(J)   =OUTPUT : THE JET WHICH CONTAINS THE Jth PARTICLE,
!C                        SET TO ZERO IF IT WAS PUT INTO THE BEAM JETS
!C   NJET     =OUTPUT : THE NUMBER OF JETS AT SCALE YCUT (SO JET()
!C                        ENTRIES WILL BE IN THE RANGE 0 -> NJET)
!C   NSUB     =OUTPUT : THE NUMBER OF SUB-JETS AT SCALE YCUT, WITH
!C                        MACRO-JETS DEFINED AT SCALE YMAC (SO ONLY NSUB
!C                        OF THE JETS 1 -> NJET WILL APPEAR IN JET())
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL FLOATING POINT VARIABLES ARE DECLARED DOUBLE PRECISION
!C
      INTEGER NMAX,JET(*),NJET,NSUB,HIST,NUM,I,J,JSUB
      PARAMETER (NMAX=512)
      DOUBLE PRECISION P1(4,NMAX),P2(4,NMAX)
      DOUBLE PRECISION ECUT,YCUT,YMAC,ZERO,ETOT,RSQ,P,KTP,KTS,KT,KTLAST
      COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
           KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM
      DIMENSION JSUB(NMAX)
!C---THE MOMENTA HAVE TO BEEN GIVEN LEGAL VALUES,
!C   EVEN THOUGH THEY WILL NEVER BE USED
      DATA ((P1(J,I),I=1,NMAX),J=1,4),ZERO &
           /NMAX*1,NMAX*0,NMAX*0,NMAX*1,0/
!C---FIRST GET A LIST OF WHICH PARTICLE IS IN WHICH JET AT YCUT
      CALL KTRECO(1,P1,NUM,ECUT,ZERO,YCUT,P2,JET,NJET,NSUB,*999)
!C---THEN FIND OUT WHICH JETS ARE SUBJETS
      CALL KTRECO(1,P1,NUM,ECUT,YCUT,YMAC,P2,JSUB,NJET,NSUB,*999)
!C---AND MODIFY JET() ACCORDINGLY
      DO I=1,NUM
         IF (JET(I).NE.0) THEN
            IF (JSUB(JET(I)).EQ.0) JET(I)=0
         ENDIF
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTWCHS
!C-----------------------------------------------------------------------
    SUBROUTINE KTFRAM(IOPT,CMF,SIGN,Z,XZ,N,P,Q,*)
      IMPLICIT NONE
!C---BOOST PARTICLES IN P TO/FROM FRAME GIVEN BY CMF, Z, XZ.
!C---IN THIS FRAME CMZ IS STATIONARY,
!C                   Z IS ALONG THE (SIGN)Z-AXIS (SIGN=+ OR -)
!C                  XZ IS IN THE X-Z PLANE (WITH POSITIVE X COMPONENT)
!C---IF Z HAS LENGTH ZERO, OR SIGN=0, NO ROTATION IS PERFORMED
!C---IF XZ HAS ZERO COMPONENT PERPENDICULAR TO Z IN THAT FRAME,
!C   NO AZIMUTHAL ROTATION IS PERFORMED
!C
!C   IOPT    = INPUT  : 0=TO FRAME, 1=FROM FRAME
!C   CMF(I)  = INPUT  : 4-MOMENTUM WHICH IS STATIONARY IN THE FRAME
!C   SIGN    = INPUT  : DIRECTION OF Z IN THE FRAME, NOTE THAT
!C                        ONLY ITS SIGN IS USED, NOT ITS MAGNITUDE
!C   Z(I)    = INPUT  : 4-MOMENTUM WHICH LIES ON THE (SIGN)Z-AXIS
!C   XZ(I)   = INPUT  : 4-MOMENTUM WHICH LIES IN THE X-Z PLANE
!C   N       = INPUT  : NUMBER OF PARTICLES IN P
!C   P(I,J)  = INPUT  : 4-MOMENTUM OF JTH PARTICLE BEFORE
!C   Q(I,J)  = OUTPUT : 4-MOMENTUM OF JTH PARTICLE AFTER
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED
!C
!C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
!C
!C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
!C
      INTEGER IOPT,I,N
      DOUBLE PRECISION CMF(4),SIGN,Z(4),XZ(4),P(4,N),Q(4,N), &
           R(4,4),NEW(4),OLD(4)
      IF (IOPT.LT.0.OR.IOPT.GT.1) CALL KTWARN('KTFRAM',200,*999)
!C---FIND BOOST TO GET THERE FROM LAB
      CALL KTUNIT(R)
      CALL KTLBST(0,R,CMF,*999)
!C---FIND ROTATION TO PUT BOOSTED Z ON THE (SIGN)Z AXIS
      IF (SIGN.NE.0) THEN
         CALL KTVMUL(R,Z,OLD)
         IF (OLD(1).NE.0.OR.OLD(2).NE.0.OR.OLD(3).NE.0) THEN
            NEW(1)=0
            NEW(2)=0
            NEW(3)=SIGN
            NEW(4)=ABS(SIGN)
            CALL KTRROT(R,OLD,NEW,*999)
!C---FIND ROTATION TO PUT BOOSTED AND ROTATED XZ INTO X-Z PLANE
            CALL KTVMUL(R,XZ,OLD)
            IF (OLD(1).NE.0.OR.OLD(2).NE.0) THEN
               NEW(1)=1
               NEW(2)=0
               NEW(3)=0
               NEW(4)=1
               OLD(3)=0
!C---NOTE THAT A POTENTIALLY AWKWARD SPECIAL CASE IS AVERTED, BECAUSE IF
!C   OLD AND NEW ARE EXACTLY BACK-TO-BACK, THE ROTATION AXIS IS UNDEFINED
!C   BUT IN THAT CASE KTRROT WILL USE THE Z AXIS, AS REQUIRED
               CALL KTRROT(R,OLD,NEW,*999)
            ENDIF
         ENDIF
      ENDIF
!C---INVERT THE TRANSFORMATION IF NECESSARY
      IF (IOPT.EQ.1) CALL KTINVT(R,R)
!C---APPLY THE RESULT TO ALL THE VECTORS
      DO I=1,N
         CALL KTVMUL(R,P(1,I),Q(1,I))
      END DO
      RETURN
999   RETURN 1
    END SUBROUTINE KTFRAM
!C-----------------------------------------------------------------------
    SUBROUTINE KTBREI(IOPT,PLEP,PHAD,POUT,N,P,Q,*)
      IMPLICIT NONE
!C---BOOST PARTICLES IN P TO/FROM BREIT FRAME
!C
!C   IOPT    = INPUT  : 0/2=TO BREIT FRAME, 1/3=FROM BREIT FRAME
!C                      0/1=NO AZIMUTHAL ROTATION AFTERWARDS
!C                      2/3=LEPTON PLANE ROTATED INTO THE X-Z PLANE
!C   PLEP    = INPUT  : MOMENTUM OF INCOMING LEPTON IN +Z DIRECTION
!C   PHAD    = INPUT  : MOMENTUM OF INCOMING HADRON IN +Z DIRECTION
!C   POUT(I) = INPUT  : 4-MOMENTUM OF OUTGOING LEPTON
!C   N       = INPUT  : NUMBER OF PARTICLES IN P
!C   P(I,J)  = INPUT  : 4-MOMENTUM OF JTH PARTICLE BEFORE
!C   Q(I,J)  = OUTPUT : 4-MOMENTUM OF JTH PARTICLE AFTER
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF FOR ANY REASON THE EVENT
!C   COULD NOT BE PROCESSED (MOST LIKELY DUE TO PARTICLES HAVING SMALLER
!C   ENERGY THAN MOMENTUM)
!C
!C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
!C
!C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
!C
      INTEGER IOPT,N
      DOUBLE PRECISION PLEP,PHAD,POUT(4),P(4,N),Q(4,N), &
           CMF(4),Z(4),XZ(4),DOT,QDQ
!C---CHECK INPUT
      IF (IOPT.LT.0.OR.IOPT.GT.3) CALL KTWARN('KTBREI',200,*999)
!C---FIND 4-MOMENTUM OF BREIT FRAME (TIMES AN ARBITRARY FACTOR)
      DOT=ABS(PHAD)*(ABS(PLEP)-POUT(4))-PHAD*(PLEP-POUT(3))
      QDQ=(ABS(PLEP)-POUT(4))**2-(PLEP-POUT(3))**2-POUT(2)**2-POUT(1)**2
      CMF(1)=DOT*(         -POUT(1))
      CMF(2)=DOT*(         -POUT(2))
      CMF(3)=DOT*(    PLEP -POUT(3))-QDQ*    PHAD
      CMF(4)=DOT*(ABS(PLEP)-POUT(4))-QDQ*ABS(PHAD)
!C---FIND ROTATION TO PUT INCOMING HADRON BACK ON Z-AXIS
      Z(1)=0
      Z(2)=0
      Z(3)=PHAD
      Z(4)=ABS(PHAD)
      XZ(1)=0
      XZ(2)=0
      XZ(3)=0
      XZ(4)=0
!C---DO THE BOOST
      IF (IOPT.LE.1) THEN
         CALL KTFRAM(IOPT,CMF,PHAD,Z,XZ,N,P,Q,*999)
      ELSE
         CALL KTFRAM(IOPT-2,CMF,PHAD,Z,POUT,N,P,Q,*999)
      ENDIF
      RETURN
999   RETURN 1
    END SUBROUTINE KTBREI
!C-----------------------------------------------------------------------
    SUBROUTINE KTHADR(IOPT,PLEP,PHAD,POUT,N,P,Q,*)
      IMPLICIT NONE
!C---BOOST PARTICLES IN P TO/FROM HADRONIC CMF
!C
!C   ARGUMENTS ARE EXACTLY AS FOR KTBREI
!C
!C   NOTE THAT ALL MOMENTA ARE DOUBLE PRECISION
!C
!C   NOTE THAT IT IS SAFE TO CALL WITH P=Q
!C
      INTEGER IOPT,N
      DOUBLE PRECISION PLEP,PHAD,POUT(4),P(4,N),Q(4,N), &
           CMF(4),Z(4),XZ(4)
!C---CHECK INPUT
      IF (IOPT.LT.0.OR.IOPT.GT.3) CALL KTWARN('KTHADR',200,*999)
!C---FIND 4-MOMENTUM OF HADRONIC CMF
      CMF(1)=         -POUT(1)
      CMF(2)=         -POUT(2)
      CMF(3)=    PLEP -POUT(3)+    PHAD
      CMF(4)=ABS(PLEP)-POUT(4)+ABS(PHAD)
!C---FIND ROTATION TO PUT INCOMING HADRON BACK ON Z-AXIS
      Z(1)=0
      Z(2)=0
      Z(3)=PHAD
      Z(4)=ABS(PHAD)
      XZ(1)=0
      XZ(2)=0
      XZ(3)=0
      XZ(4)=0
!C---DO THE BOOST
      IF (IOPT.LE.1) THEN
         CALL KTFRAM(IOPT,CMF,PHAD,Z,XZ,N,P,Q,*999)
      ELSE
         CALL KTFRAM(IOPT-2,CMF,PHAD,Z,POUT,N,P,Q,*999)
      ENDIF
      RETURN
999   RETURN 1
    END SUBROUTINE KTHADR
<<MLM matching: procedures (not used)>>=
    SUBROUTINE KTUNIT(R)
      IMPLICIT NONE
!C   SET R EQUAL TO THE 4 BY 4 IDENTITY MATRIX
      DOUBLE PRECISION R(4,4)
      INTEGER I,J
      DO I=1,4
         DO J=1,4
            R(I,J)=0
            IF (I.EQ.J) R(I,J)=1
         END DO
      END DO
    END SUBROUTINE KTUNIT
!C-----------------------------------------------------------------------
    SUBROUTINE KTLBST(IOPT,R,A,*)
      IMPLICIT NONE
!C   PREMULTIPLY R BY THE 4 BY 4 MATRIX TO
!C   LORENTZ BOOST TO/FROM THE CM FRAME OF A
!C   IOPT=0 => TO
!C   IOPT=1 => FROM
!C
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF A IS NOT TIME-LIKE
!C
      INTEGER IOPT,I,J
      DOUBLE PRECISION R(4,4),A(4),B(4),C(4,4),M
      DO I=1,4
         B(I)=A(I)
      END DO
      M=B(4)**2-B(1)**2-B(2)**2-B(3)**2
      IF (M.LE.0) CALL KTWARN('KTLBST',100,*999)
      M=SQRT(M)
      B(4)=B(4)+M
      M=1/(M*B(4))
      IF (IOPT.EQ.0) THEN
        B(4)=-B(4)
      ELSEIF (IOPT.NE.1) THEN
        CALL KTWARN('KTLBST',200,*999)
        STOP
      ENDIF
      DO I=1,4
         DO J=1,4
            C(I,J)=B(I)*B(J)*M
            IF (I.EQ.J) C(I,J)=C(I,J)+1
         END DO
      END DO
      C(4,4)=C(4,4)-2
      CALL KTMMUL(C,R,R)
      RETURN
999   RETURN 1
    END SUBROUTINE KTLBST
!C-----------------------------------------------------------------------
    SUBROUTINE KTRROT(R,A,B,*)
      IMPLICIT NONE
!C   PREMULTIPLY R BY THE 4 BY 4 MATRIX TO
!C   ROTATE FROM VECTOR A TO VECTOR B BY THE SHORTEST ROUTE
!C   IF THEY ARE EXACTLY BACK-TO-BACK, THE ROTATION AXIS IS THE VECTOR
!C   WHICH IS PERPENDICULAR TO THEM AND THE X AXIS, UNLESS THEY ARE
!C   PERPENDICULAR TO THE Y AXIS, WHEN IT IS THE VECTOR WHICH IS
!C   PERPENDICULAR TO THEM AND THE Y AXIS.
!C   NOTE THAT THESE CONDITIONS GUARANTEE THAT IF BOTH ARE PERPENDICULAR
!C   TO THE Z AXIS, IT WILL BE USED AS THE ROTATION AXIS.
!C
!C   LAST ARGUMENT IS LABEL TO JUMP TO IF EITHER HAS LENGTH ZERO
!C
      DOUBLE PRECISION R(4,4),M(4,4),A(4),B(4),C(4),D(4),AL,BL,CL,DL,EPS
!C---SQRT(2*EPS) IS THE ANGLE IN RADIANS OF THE SMALLEST ALLOWED ROTATION
!C   NOTE THAT IF YOU CONVERT THIS PROGRAM TO SINGLE PRECISION, YOU WILL
!C   NEED TO INCREASE EPS TO AROUND 0.5E-4
      PARAMETER (EPS=0.5D-6)
      AL=A(1)**2+A(2)**2+A(3)**2
      BL=B(1)**2+B(2)**2+B(3)**2
      IF (AL.LE.0.OR.BL.LE.0) CALL KTWARN('KTRROT',100,*999)
      AL=1/SQRT(AL)
      BL=1/SQRT(BL)
      CL=(A(1)*B(1)+A(2)*B(2)+A(3)*B(3))*AL*BL
!C---IF THEY ARE COLLINEAR, DON'T NEED TO DO ANYTHING
      IF (CL.GE.1-EPS) THEN
         RETURN
!C---IF THEY ARE BACK-TO-BACK, USE THE AXIS PERP TO THEM AND X AXIS
      ELSEIF (CL.LE.-1+EPS) THEN
         IF (ABS(B(2)).GT.EPS) THEN
            C(1)= 0
            C(2)=-B(3)
            C(3)= B(2)
!C---UNLESS THEY ARE PERPENDICULAR TO THE Y AXIS,
         ELSE
            C(1)= B(3)
            C(2)= 0
            C(3)=-B(1)
         ENDIF
!C---OTHERWISE FIND ROTATION AXIS
      ELSE
         C(1)=A(2)*B(3)-A(3)*B(2)
         C(2)=A(3)*B(1)-A(1)*B(3)
         C(3)=A(1)*B(2)-A(2)*B(1)
      ENDIF
      CL=C(1)**2+C(2)**2+C(3)**2
      IF (CL.LE.0) CALL KTWARN('KTRROT',101,*999)
      CL=1/SQRT(CL)
!C---FIND ROTATION TO INTERMEDIATE AXES FROM A
      D(1)=A(2)*C(3)-A(3)*C(2)
      D(2)=A(3)*C(1)-A(1)*C(3)
      D(3)=A(1)*C(2)-A(2)*C(1)
      DL=AL*CL
      M(1,1)=A(1)*AL
      M(1,2)=A(2)*AL
      M(1,3)=A(3)*AL
      M(1,4)=0
      M(2,1)=C(1)*CL
      M(2,2)=C(2)*CL
      M(2,3)=C(3)*CL
      M(2,4)=0
      M(3,1)=D(1)*DL
      M(3,2)=D(2)*DL
      M(3,3)=D(3)*DL
      M(3,4)=0
      M(4,1)=0
      M(4,2)=0
      M(4,3)=0
      M(4,4)=1
      CALL KTMMUL(M,R,R)
!C---AND ROTATION FROM INTERMEDIATE AXES TO B
      D(1)=B(2)*C(3)-B(3)*C(2)
      D(2)=B(3)*C(1)-B(1)*C(3)
      D(3)=B(1)*C(2)-B(2)*C(1)
      DL=BL*CL
      M(1,1)=B(1)*BL
      M(2,1)=B(2)*BL
      M(3,1)=B(3)*BL
      M(1,2)=C(1)*CL
      M(2,2)=C(2)*CL
      M(3,2)=C(3)*CL
      M(1,3)=D(1)*DL
      M(2,3)=D(2)*DL
      M(3,3)=D(3)*DL
      CALL KTMMUL(M,R,R)
      RETURN
 999  RETURN 1
    END SUBROUTINE KTRROT
!C-----------------------------------------------------------------------
    SUBROUTINE KTVMUL(M,A,B)
      IMPLICIT NONE
!C   4 BY 4 MATRIX TIMES 4 VECTOR: B=M*A.
!C   ALL ARE DOUBLE PRECISION
!C   IT IS SAFE TO CALL WITH B=A
!C   FIRST SUBSCRIPT=ROWS, SECOND=COLUMNS
      DOUBLE PRECISION M(4,4),A(4),B(4),C(4)
      INTEGER I,J
      DO I=1,4
         C(I)=0
         DO J=1,4
            C(I)=C(I)+M(I,J)*A(J)
         END DO
      END DO
      DO I=1,4
         B(I)=C(I)
      END DO
    END SUBROUTINE KTVMUL
!C-----------------------------------------------------------------------
    SUBROUTINE KTMMUL(A,B,C)
      IMPLICIT NONE
!C   4 BY 4 MATRIX MULTIPLICATION: C=A*B.
!C   ALL ARE DOUBLE PRECISION
!C   IT IS SAFE TO CALL WITH C=A OR B.
!C   FIRST SUBSCRIPT=ROWS, SECOND=COLUMNS
      DOUBLE PRECISION A(4,4),B(4,4),C(4,4),D(4,4)
      INTEGER I,J,K
      DO I=1,4
         DO J=1,4
            D(I,J)=0
            DO K=1,4
               D(I,J)=D(I,J)+A(I,K)*B(K,J)
            END DO
         END DO
      END DO
      DO I=1,4
         DO J=1,4
            C(I,J)=D(I,J)
         END DO
      END DO
    END SUBROUTINE KTMMUL
!C-----------------------------------------------------------------------
    SUBROUTINE KTINVT(A,B)
      IMPLICIT NONE
!C---INVERT TRANSFORMATION MATRIX A
!C
!C   A = INPUT  : 4 BY 4 TRANSFORMATION MATRIX
!C   B = OUTPUT : INVERTED TRANSFORMATION MATRIX
!C
!C   IF A IS NOT A TRANSFORMATION MATRIX YOU WILL GET STRANGE RESULTS
!C
!C   NOTE THAT IT IS SAFE TO CALL WITH A=B
!C
      DOUBLE PRECISION A(4,4),B(4,4),C(4,4)
      INTEGER I,J
!C---TRANSPOSE
      DO I=1,4
         DO J=1,4
            C(I,J)=A(J,I)
         END DO
      END DO
!C---NEGATE ENERGY-MOMENTUM MIXING TERMS
      DO I=1,3
         C(4,I)=-C(4,I)
         C(I,4)=-C(I,4)
      END DO
!C---OUTPUT
      DO I=1,4
         DO J=1,4
            B(I,J)=C(I,J)
         END DO
      END DO
    END SUBROUTINE KTINVT
!C-----------------------------------------------------------------------
<<Shower PYTHIA6: procedures (not used)>>=
  recursive subroutine shower_topythia_recursive (prt, mode,first)
    IMPLICIT DOUBLE PRECISION(A-H, O-Z)
    IMPLICIT INTEGER(I-N)
    !    C...  Commonblocks.
    COMMON/PYJETS/N,NPAD,K(4000,5),P(4000,5),V(4000,5)
    COMMON/PYDAT1/MSTU(200),PARU(200),MSTJ(200),PARJ(200)
    COMMON/PYDAT2/KCHG(500,4),PMAS(500,4),PARF(2000),VCKM(4,4)
    COMMON/PYDAT3/MDCY(500,3),MDME(8000,2),BRAT(8000),KFDP(8000,5)
    COMMON/PYSUBS/MSEL,MSELPD,MSUB(500),KFIN(2,-40:40),CKIN(200)
    COMMON/PYPARS/MSTP(200),PARP(200),MSTI(200),PARI(200)
    SAVE /PYJETS/,/PYDAT1/,/PYDAT2/,/PYDAT3/,/PYSUBS/,/PYPARS/

    type(parton_t), intent(in) :: prt
    integer, intent(in) :: mode, first

    if (parton_is_final (prt)) then
       N = N + 1
       K(N,1) = 2
       if (parton_is_quark(prt)) then
          !!! check if quark is end of a color connection
          if (prt%type < 0) then
             K(N,1) = 1
          end if
       end if
       K(N,2) = prt%type
       K(N,3) = first
       K(N,4) = 0
       K(N,5) = 0
       P(N,1) = prt%momentum%p(1)
       P(N,2) = prt%momentum%p(2)
       P(N,3) = prt%momentum%p(3)
       P(N,4) = prt%momentum%p(0)
       P(N,5) = prt%t
    else
       !!! search for following final partons
       if (parton_is_gluon (prt)) then
          if (parton_is_gluon (prt%child1)) then
             !!! g-> gg so sequence is unimportant
             call shower_topythia_recursive (prt%child1, 1, first)
             call shower_topythia_recursive (prt%child2, 1, first)
          else
             !!! g-> qqbar -> use antiquark first, so that color flow
             !!!     is given correctly
             if (prt%child1%type < 0) then
                call shower_topythia_recursive (prt%child1, 1, first)
                call shower_topythia_recursive (prt%child2, 2, first)
             else
                call shower_topythia_recursive (prt%child2, 2, first)
                call shower_topythia_recursive (prt%child1, 1, first)
             end if
          endif
       else
          if (mode == 1) then
             call shower_topythia_recursive (prt%child1, 1, first)
             call shower_topythia_recursive (prt%child2, 1, first)
          else
             call shower_topythia_recursive (prt%child2, 2, first)
             call shower_topythia_recursive (prt%child1, 2, first)
          end if
       end if
    end if
  end subroutine shower_topythia_recursive

@ %def shower_topythia_recursive
@
