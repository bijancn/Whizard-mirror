%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: phase space
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Phase Space}

The abstract representation of a type that parameterizes phase space,
with methods for construction and evaluation.
\begin{description}
\item[phs\_base]
  Abstract phase-space representation.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract phase-space module}

In this module we define an abstract base type (and a trivial test
implementation) for multi-channel phase-space parameterizations.
<<[[phs_base.f90]]>>=
<<File header>>

module phs_base

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: TWOPI, TWOPI4
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use md5
  use physics_defs
  use lorentz
  use model_data
  use flavors
  use sf_mappings
  use sf_base
  use process_constants

<<Standard module head>>

<<PHS base: public>>

<<PHS base: types>>

<<PHS base: interfaces>>

<<PHS base: test types>>

contains

<<PHS base: procedures>>

<<PHS base: tests>>

end module phs_base
@ %def phs_base
@
\subsection{Phase-space channels}
The kinematics configuration may generate multiple parameterizations of phase
space.  Some of those have specific properties, such as a resonance in the s
channel.

\subsubsection{Channel properties}
This is the abstract type for the channel properties.  We need them as
a data transfer container, so everything is public and transparent.
<<PHS base: public>>=
  public :: channel_prop_t
<<PHS base: types>>=
  type, abstract :: channel_prop_t
   contains
     procedure (channel_prop_to_string), deferred :: to_string
     generic :: operator (==) => is_equal
     procedure (channel_eq), deferred :: is_equal
  end type channel_prop_t

@ %def channel_prop_t
<<PHS base: interfaces>>=
  abstract interface
     function channel_prop_to_string (object) result (string)
       import
       class(channel_prop_t), intent(in) :: object
       type(string_t) :: string
     end function channel_prop_to_string
  end interface

@ %def channel_prop_to_string
<<PHS base: interfaces>>=
  abstract interface
     function channel_eq (prop1, prop2) result (flag)
       import
       class(channel_prop_t), intent(in) :: prop1, prop2
       logical :: flag
     end function channel_eq
  end interface

@ %def channel_prop_to_string
@
Here is a resonance as a channel property.  Mass and width are stored
here in physical units.
<<PHS base: public>>=
  public :: resonance_t
<<PHS base: types>>=
  type, extends (channel_prop_t) :: resonance_t
     real(default) :: mass = 0
     real(default) :: width = 0
   contains
     procedure :: to_string => resonance_to_string
     procedure :: is_equal => resonance_is_equal
  end type resonance_t
  
@ %def resonance_t
@ Print mass and width.
<<PHS base: procedures>>=
  function resonance_to_string (object) result (string)
    class(resonance_t), intent(in) :: object
    type(string_t) :: string
    character(32) :: buffer
    string = "resonant: m ="
    write (buffer, "(" // FMT_19 // ")")  object%mass
    string = string // trim (buffer) // " GeV, w ="
    write (buffer, "(" // FMT_19 // ")")  object%width
    string = string // trim (buffer) // " GeV"
  end function resonance_to_string

@ %def resonance_to_string
@ Equality.
<<PHS base: procedures>>=
  function resonance_is_equal (prop1, prop2) result (flag)
    class(resonance_t), intent(in) :: prop1
    class(channel_prop_t), intent(in) :: prop2
    logical :: flag
    select type (prop2)
    type is (resonance_t)
       flag = prop1%mass == prop2%mass .and. prop1%width == prop2%width
    class default
       flag = .false.
    end select
  end function resonance_is_equal
  
@ %def resonance_is_equal
@
This is the limiting case of a resonance, namely an on-shell particle.
We just store the mass in physical units.
<<PHS base: public>>=
  public :: on_shell_t
<<PHS base: types>>=
  type, extends (channel_prop_t) :: on_shell_t
     real(default) :: mass = 0
   contains
     procedure :: to_string => on_shell_to_string
     procedure :: is_equal => on_shell_is_equal
  end type on_shell_t
  
@ %def on_shell_t
@ Print mass and width.
<<PHS base: procedures>>=
  function on_shell_to_string (object) result (string)
    class(on_shell_t), intent(in) :: object
    type(string_t) :: string
    character(32) :: buffer
    string = "on shell: m ="
    write (buffer, "(" // FMT_19 // ")")  object%mass
    string = string // trim (buffer) // " GeV"
  end function on_shell_to_string

@ %def on_shell_to_string
@ Equality.
<<PHS base: procedures>>=
  function on_shell_is_equal (prop1, prop2) result (flag)
    class(on_shell_t), intent(in) :: prop1
    class(channel_prop_t), intent(in) :: prop2
    logical :: flag
    select type (prop2)
    type is (on_shell_t)
       flag = prop1%mass == prop2%mass
    class default
       flag = .false.
    end select
  end function on_shell_is_equal
  
@ %def on_shell_is_equal
@
\subsubsection{Channel equivalences}
This type describes an equivalence.  The current channel is equivalent
to channel [[c]].  The equivalence involves a permutation [[perm]] of
integration dimensions and, within each integration dimension, a
mapping [[mode]].
<<PHS base: types>>=
  type :: phs_equivalence_t
     integer :: c = 0
     integer, dimension(:), allocatable :: perm
     integer, dimension(:), allocatable :: mode
   contains
   <<PHS base: phs equivalence: TBP>>
  end type phs_equivalence_t
  
@ %def phs_equivalence_t
@ 
The mapping modes are
<<PHS base: types>>=
  integer, parameter, public :: &
       EQ_IDENTITY = 0, EQ_INVERT = 1, EQ_SYMMETRIC = 2, EQ_INVARIANT = 3

@ %def EQ_IDENTITY EQ_INVERT EQ_SYMMETRIC
@ In particular, if a channel is equivalent to itself in the
[[EQ_SYMMETRIC]] mode, the integrand can be assumed to be symmetric
w.r.t.\ a reflection $x\to 1 - x$ of the correponding integration variable.

These are the associated tags, for output:
<<PHS base: types>>=
  character, dimension(0:3), parameter :: TAG = ["+", "-", ":", "x"]

@ %def TAG
@ Write an equivalence.
<<PHS base: phs equivalence: TBP>>=
  procedure :: write => phs_equivalence_write
<<PHS base: procedures>>=
  subroutine phs_equivalence_write (object, unit)
    class(phs_equivalence_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, j
    u = given_output_unit (unit)
    write (u, "(5x,'=',1x,I0,1x)", advance = "no")  object%c
    if (allocated (object%perm)) then
       write (u, "(A)", advance = "no")  "("
       do j = 1, size (object%perm)
          if (j > 1)  write (u, "(1x)", advance = "no")
          write (u, "(I0,A1)", advance = "no") &
               object%perm(j), TAG(object%mode(j))
       end do
       write (u, "(A)")  ")"
    else
       write (u, "(A)")
    end if
  end subroutine phs_equivalence_write
  
@ %def phs_equivalence_write
@ Initialize an equivalence.  This allocates the [[perm]] and [[mode]]
arrays with equal size.
<<PHS base: phs equivalence: TBP>>=
  procedure :: init => phs_equivalence_init
<<PHS base: procedures>>=
  subroutine phs_equivalence_init (eq, n_dim)
    class(phs_equivalence_t), intent(out) :: eq
    integer, intent(in) :: n_dim
    allocate (eq%perm (n_dim), source = 0)
    allocate (eq%mode (n_dim), source = EQ_IDENTITY)
  end subroutine phs_equivalence_init
  
@ %def phs_equivalence_init
@
\subsubsection{Channel objects}
The channel entry holds (optionally) specific properties.

[[sf_channel]] is the structure-function channel that corresponds to this
phase-space channel.  The structure-function channel may be set up with a
specific mapping that depends on the phase-space channel properties.  (The
default setting is to leave the properties empty.)
<<PHS base: public>>=
  public :: phs_channel_t
<<PHS base: types>>=
  type :: phs_channel_t
     class(channel_prop_t), allocatable :: prop
     integer :: sf_channel = 1
     type(phs_equivalence_t), dimension(:), allocatable :: eq
   contains
   <<PHS base: phs channel: TBP>>
  end type phs_channel_t
  
@ %def phs_channel_t
@ Output.
<<PHS base: phs channel: TBP>>=
  procedure :: write => phs_channel_write
<<PHS base: procedures>>=
  subroutine phs_channel_write (object, unit)
    class(phs_channel_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, j
    u = given_output_unit (unit)
    write (u, "(1x,I0)", advance="no") object%sf_channel
    if (allocated (object%prop)) then
       write (u, "(1x,A)")  char (object%prop%to_string ())
    else
       write (u, *)
    end if
    if (allocated (object%eq)) then
       do j = 1, size (object%eq)
          call object%eq(j)%write (u)
       end do
    end if
  end subroutine phs_channel_write
    
@ %def phs_channel_write
@ Identify the channel with an s-channel resonance.
<<PHS base: phs channel: TBP>>=
  procedure :: set_resonant => channel_set_resonant
<<PHS base: procedures>>=
  subroutine channel_set_resonant (channel, mass, width)
    class(phs_channel_t), intent(inout) :: channel
    real(default), intent(in) :: mass, width
    allocate (resonance_t :: channel%prop)
    select type (prop => channel%prop)
    type is (resonance_t)
       prop%mass = mass
       prop%width = width
    end select
  end subroutine channel_set_resonant
  
@ %def channel_set_resonant
@ Identify the channel with an on-shell particle.
<<PHS base: phs channel: TBP>>=
  procedure :: set_on_shell => channel_set_on_shell
<<PHS base: procedures>>=
  subroutine channel_set_on_shell (channel, mass)
    class(phs_channel_t), intent(inout) :: channel
    real(default), intent(in) :: mass
    allocate (on_shell_t :: channel%prop)
    select type (prop => channel%prop)
    type is (on_shell_t)
       prop%mass = mass
    end select
  end subroutine channel_set_on_shell
  
@ %def channel_set_on_shell
@
\subsection{Property collection}
We can set up a list of all distinct channel properties for a given
set of channels.
<<PHS base: public>>=
  public :: phs_channel_collection_t
<<PHS base: types>>=
  type :: prop_entry_t
     integer :: i = 0
     class(channel_prop_t), allocatable :: prop
     type(prop_entry_t), pointer :: next => null ()
  end type prop_entry_t
  
  type :: phs_channel_collection_t
     integer :: n = 0
     type(prop_entry_t), pointer :: first => null ()
   contains
   <<PHS base: phs channel collection: TBP>>
  end type phs_channel_collection_t

@ %def prop_entry_t
@ %def phs_channel_collection_t
@ Finalizer for the list.
<<PHS base: phs channel collection: TBP>>=
  procedure :: final => phs_channel_collection_final
<<PHS base: procedures>>=
  subroutine phs_channel_collection_final (object)
    class(phs_channel_collection_t), intent(inout) :: object
    type(prop_entry_t), pointer :: entry
    do while (associated (object%first))
       entry => object%first
       object%first => entry%next
       deallocate (entry)
    end do
  end subroutine phs_channel_collection_final

@ %def phs_channel_collection_final
@ Output.

Note: eliminating the [[string]] auxiliary triggers an ICE in gfortran 4.7.2.
<<PHS base: phs channel collection: TBP>>=
  procedure :: write => phs_channel_collection_write
<<PHS base: procedures>>=
  subroutine phs_channel_collection_write (object, unit)
    class(phs_channel_collection_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(prop_entry_t), pointer :: entry
    type(string_t) :: string
    integer :: u
    u = given_output_unit (unit)
    entry => object%first
    do while (associated (entry))
       if (allocated (entry%prop)) then
          string = entry%prop%to_string ()
          write (u, "(1x,I0,1x,A)")  entry%i, char (string)
       else
          write (u, "(1x,I0)")  entry%i
       end if
       entry => entry%next
    end do
  end subroutine phs_channel_collection_write
  
@ %def phs_channel_collection_write
@ Push a new property to the stack if it is not yet included.
Simultaneously, set the [[sf_channel]] entry in the phase-space
channel object to the index of the matching entry, or the new entry if
there was no match.
<<PHS base: phs channel collection: TBP>>=
  procedure :: push => phs_channel_collection_push
<<PHS base: procedures>>=
  subroutine phs_channel_collection_push (coll, channel)
    class(phs_channel_collection_t), intent(inout) :: coll
    type(phs_channel_t), intent(inout) :: channel
    type(prop_entry_t), pointer :: entry, new
    if (associated (coll%first)) then
       entry => coll%first
       do
          if (allocated (entry%prop)) then
             if (allocated (channel%prop)) then
                if (entry%prop == channel%prop) then
                   channel%sf_channel = entry%i
                   return
                end if
             end if
          else if (.not. allocated (channel%prop)) then
             channel%sf_channel = entry%i
             return
          end if
          if (associated (entry%next)) then
             entry => entry%next
          else
             exit
          end if
       end do
       allocate (new)
       entry%next => new
    else
       allocate (new)
       coll%first => new
    end if
    coll%n = coll%n + 1
    new%i = coll%n
    channel%sf_channel = new%i
    if (allocated (channel%prop)) then
       allocate (new%prop, source = channel%prop)
    end if
  end subroutine phs_channel_collection_push
    
@ %def phs_channel_collection_push
@ Return the number of collected distinct channels.
<<PHS base: phs channel collection: TBP>>=
  procedure :: get_n => phs_channel_collection_get_n
<<PHS base: procedures>>=
  function phs_channel_collection_get_n (coll) result (n)
    class(phs_channel_collection_t), intent(in) :: coll
    integer :: n
    n = coll%n
  end function phs_channel_collection_get_n
  
@ %def phs_channel_collection_get_n
@ Return a specific channel (property object).
<<PHS base: phs channel collection: TBP>>=
  procedure :: get_entry => phs_channel_collection_get_entry
<<PHS base: procedures>>=
  subroutine phs_channel_collection_get_entry (coll, i, prop)
    class(phs_channel_collection_t), intent(in) :: coll
    integer, intent(in) :: i
    class(channel_prop_t), intent(out), allocatable :: prop
    type(prop_entry_t), pointer :: entry
    integer :: k
    if (i > 0 .and. i <= coll%n) then
       entry => coll%first
       do k = 2, i
          entry => entry%next
       end do
       if (allocated (entry%prop)) then
	  if (allocated (prop))  deallocate (prop)
          allocate (prop, source = entry%prop)
       end if
    else
       call msg_bug ("PHS channel collection: get entry: illegal index")
    end if
  end subroutine phs_channel_collection_get_entry
    
@ %def phs_channel_collection_get_entry
@
\subsection{Kinematics configuration}
Here, we store the universal information that is specifically relevant
for phase-space generation.  It is a subset of the process data,
supplemented by basic information on phase-space parameterization
channels.

A concrete implementation will contain more data, that describe the
phase space in detail.

MD5 sums: the phase space setup depends on the process, it depends on
the model parameters (the masses, that is), and on the configuration
parameters.  (It doesn't depend on the QCD setup.)
<<PHS base: public>>=
  public :: phs_config_t
<<PHS base: types>>=
  type, abstract :: phs_config_t
     ! private
     type(string_t) :: id
     integer :: n_in = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     integer :: n_state = 0
     integer :: n_par = 0
     integer :: n_channel = 0
     real(default) :: sqrts = 0
     logical :: sqrts_fixed = .true.
     logical :: cm_frame = .true.
     logical :: azimuthal_dependence = .false.
     integer, dimension(:), allocatable :: dim_flat
     logical :: provides_equivalences = .false.
     logical :: provides_chains = .false.
     logical :: vis_channels = .false.
     integer, dimension(:), allocatable :: chain
     class(model_data_t), pointer :: model => null ()
     type(flavor_t), dimension(:,:), allocatable :: flv
     type(phs_channel_t), dimension(:), allocatable :: channel
     character(32) :: md5sum_process = ""
     character(32) :: md5sum_model_par = ""
     character(32) :: md5sum_phs_config = ""
     type(string_t) :: nlo_type
   contains
   <<PHS base: phs config: TBP>>
  end type phs_config_t
  
@ %def phs_config_t
@ Finalizer, deferred.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_final), deferred :: final
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_final (object)
       import
       class(phs_config_t), intent(inout) :: object
     end subroutine phs_config_final
  end interface

@ %def phs_config_final
@ Output.  We provide an implementation for the output of the base-type
contents and an interface for the actual write method.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_write), deferred :: write
  procedure :: base_write => phs_config_write
<<PHS base: procedures>>=
  subroutine phs_config_write (object, unit)
    class(phs_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i, j
    integer :: n_tot_flv
    n_tot_flv = object%n_tot
    u = given_output_unit (unit)
    write (u, "(3x,A,A,A)") "ID        = '", char (object%id), "'"
    write (u, "(3x,A,I0)")  "n_in      = ", object%n_in
    write (u, "(3x,A,I0)")  "n_out     = ", object%n_out
    write (u, "(3x,A,I0)")  "n_tot     = ", object%n_tot
    write (u, "(3x,A,I0)")  "n_state   = ", object%n_state
    write (u, "(3x,A,I0)")  "n_par     = ", object%n_par
    write (u, "(3x,A,I0)")  "n_channel = ", object%n_channel
    write (u, "(3x,A," // FMT_19 // ")")  "sqrts     = ", object%sqrts
    write (u, "(3x,A,L1)")  "s_fixed   = ", object%sqrts_fixed
    write (u, "(3x,A,L1)")  "cm_frame  = ", object%cm_frame
    write (u, "(3x,A,L1)")  "azim.dep. = ", object%azimuthal_dependence
    if (allocated (object%dim_flat)) then
       write (u, "(3x,A,I0)")  "flat dim. = ", object%dim_flat
    end if
    write (u, "(1x,A)")  "Flavor combinations:"
    do i = 1, object%n_state
       write (u, "(3x,I0,':')", advance="no")  i
!       do j = 1, object%n_tot
       do j = 1, n_tot_flv
          write (u, "(1x,A)", advance="no") &
               char (flavor_get_name (object%flv(j,i)))
       end do
       write (u, *)
    end do
    if (allocated (object%channel)) then
       write (u, "(1x,A)")  "Phase-space / structure-function channels:"
       do i = 1, object%n_channel
          write (u, "(3x,I0,':')", advance="no") i
          call object%channel(i)%write (u)
       end do
    end if
    if (object%md5sum_process /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (process)    = '", &
            object%md5sum_process, "'"
    end if
    if (object%md5sum_model_par /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (model par)  = '", &
            object%md5sum_model_par, "'"
    end if
    if (object%md5sum_phs_config /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (phs config) = '", &
            object%md5sum_phs_config, "'"
    end if
  end subroutine phs_config_write

@ %def phs_config_write
@ Similarly, a basic initializer and an interface.  The model pointer is taken
as an argument; we may verify that this has the expected model name.

The intent is [[inout]].  We want to be able to set parameters in advance.
<<PHS base: phs config: TBP>>=
  procedure :: init => phs_config_init
<<PHS base: procedures>>=
  subroutine phs_config_init (phs_config, data, model)
    class(phs_config_t), intent(inout) :: phs_config
    type(process_constants_t), intent(in) :: data
    class(model_data_t), intent(in), target :: model
    integer :: i, j
    phs_config%id = data%id
    phs_config%n_in  = data%n_in
    phs_config%n_out = data%n_out
    phs_config%n_tot = data%n_in + data%n_out
    phs_config%n_state = data%n_flv
    if (data%model_name == model%get_name ()) then
       phs_config%model => model
    else
       call msg_bug ("phs_config_init: model name mismatch")
    end if
    allocate (phs_config%flv (phs_config%n_tot, phs_config%n_state))    
    do i = 1, phs_config%n_state
       do j = 1, phs_config%n_tot
          call flavor_init (phs_config%flv(j,i), data%flv_state(j,i), &
               phs_config%model)
       end do
    end do
    phs_config%md5sum_process = data%md5sum
  end subroutine phs_config_init
    
@ %def phs_config_init
@ This procedure should complete the phase-space configuration.  We
need the [[sqrts]] value as overall scale, which is known only after
the beams have been defined.  The procedure should determine the number of
channels, their properties (if any), and allocate and fill the [[channel]]
array accordingly.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_configure), deferred :: configure
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_configure (phs_config, sqrts, &
          sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
          nlo_type)
       import
       class(phs_config_t), intent(inout) :: phs_config
       real(default), intent(in) :: sqrts
       logical, intent(in), optional :: sqrts_fixed
       logical, intent(in), optional :: cm_frame
       logical, intent(in), optional :: azimuthal_dependence
       logical, intent(in), optional :: rebuild
       logical, intent(in), optional :: ignore_mismatch
       type(string_t), intent(inout), optional :: nlo_type
     end subroutine phs_config_configure
  end interface

@ %def phs_config_configure
@ Manually assign structure-function channel indices to the phase-space
channel objects.  (Used by a test routine.)
<<PHS base: phs config: TBP>>=
  procedure :: set_sf_channel => phs_config_set_sf_channel
<<PHS base: procedures>>=
  subroutine phs_config_set_sf_channel (phs_config, sf_channel)
    class(phs_config_t), intent(inout) :: phs_config
    integer, dimension(:), intent(in) :: sf_channel
    phs_config%channel%sf_channel = sf_channel
  end subroutine phs_config_set_sf_channel
  
@ %def phs_config_set_sf_channel
@ Collect new channels not yet in the collection from this phase-space
configuration object.  At the same time, assign structure-function channels.
<<PHS base: phs config: TBP>>=
  procedure :: collect_channels => phs_config_collect_channels
<<PHS base: procedures>>=
  subroutine phs_config_collect_channels (phs_config, coll)
    class(phs_config_t), intent(inout) :: phs_config
    type(phs_channel_collection_t), intent(inout) :: coll
    integer :: c
    do c = 1, phs_config%n_channel
       call coll%push (phs_config%channel(c))
    end do
  end subroutine phs_config_collect_channels
    
@ %def phs_config_collect_channels
@ Compute the MD5 sum.  We abuse the [[write]] method.  In
type implementations, [[write]] should only display information that is
relevant for the MD5 sum.  The data include the process MD5 sum which is taken
from the process constants, and the MD5 sum of the model parameters.  This may
change, so it is computed here.
<<PHS base: phs config: TBP>>=
  procedure :: compute_md5sum => phs_config_compute_md5sum
<<PHS base: procedures>>=
  subroutine phs_config_compute_md5sum (phs_config)
    class(phs_config_t), intent(inout) :: phs_config
    integer :: u
    phs_config%md5sum_model_par = phs_config%model%get_parameters_md5sum ()
    phs_config%md5sum_phs_config = ""
    u = free_unit ()
    open (u, status = "scratch", action = "readwrite")
    call phs_config%write (u)
    rewind (u)
    phs_config%md5sum_phs_config = md5sum (u)
    close (u)
  end subroutine phs_config_compute_md5sum
    
@ %def phs_config_compute_md5sum
@ Print an informative message after phase-space configuration.
<<PHS base: phs config: TBP>>=
  procedure (phs_startup_message), deferred :: startup_message
  procedure :: base_startup_message => phs_startup_message
<<PHS base: procedures>>=
  subroutine phs_startup_message (phs_config, unit)
    class(phs_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    write (msg_buffer, "(A,3(1x,I0,1x,A))") &
         "Phase space:", &
         phs_config%n_channel, "channels,", &
         phs_config%n_par, "dimensions"
    call msg_message (unit = unit)
  end subroutine phs_startup_message

@ %def phs_startup_message
@ This procedure should be implemented such that the phase-space
configuration object allocates a phase-space instance of matching type.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_allocate_instance), nopass, deferred :: &
       allocate_instance
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_allocate_instance (phs)
       import
       class(phs_t), intent(inout), pointer :: phs
     end subroutine phs_config_allocate_instance
  end interface

@ %def phs_config_allocate_instance
@ 
\subsection{Extract data}
Return the number of MC input parameters.
<<PHS base: phs config: TBP>>=
  procedure :: get_n_par => phs_config_get_n_par
<<PHS base: procedures>>=
  function phs_config_get_n_par (phs_config) result (n)
    class(phs_config_t), intent(in) :: phs_config
    integer :: n
    n = phs_config%n_par
  end function phs_config_get_n_par
  
@ %def phs_config_get_n_par
@ Return dimensions (parameter indices) for which the phase-space
dimension is flat, so integration and event generation can be simplified.
<<PHS base: phs config: TBP>>=
  procedure :: get_flat_dimensions => phs_config_get_flat_dimensions
<<PHS base: procedures>>=
  function phs_config_get_flat_dimensions (phs_config) result (dim_flat)
    class(phs_config_t), intent(in) :: phs_config
    integer, dimension(:), allocatable :: dim_flat
    if (allocated (phs_config%dim_flat)) then
       allocate (dim_flat (size (phs_config%dim_flat)))
       dim_flat = phs_config%dim_flat
    else
       allocate (dim_flat (0))
    end if
  end function phs_config_get_flat_dimensions
  
@ %def phs_config_get_flat_dimensions
@ Return the number of phase-space channels.
<<PHS base: phs config: TBP>>=
  procedure :: get_n_channel => phs_config_get_n_channel
<<PHS base: procedures>>=
  function phs_config_get_n_channel (phs_config) result (n)
    class(phs_config_t), intent(in) :: phs_config
    integer :: n
    n = phs_config%n_channel
  end function phs_config_get_n_channel
  
@ %def phs_config_get_n_channel
@ Return the structure-function channel that corresponds to the
phase-space channel [[c]].  If the channel array is not allocated (which
happens if there is no structure function), return zero.
<<PHS base: phs config: TBP>>=
  procedure :: get_sf_channel => phs_config_get_sf_channel
<<PHS base: procedures>>=
  function phs_config_get_sf_channel (phs_config, c) result (c_sf)
    class(phs_config_t), intent(in) :: phs_config
    integer, intent(in) :: c
    integer :: c_sf
    if (allocated (phs_config%channel)) then
       c_sf = phs_config%channel(c)%sf_channel
    else
       c_sf = 0
    end if
  end function phs_config_get_sf_channel
  
@ %def phs_config_get_sf_channel
@ Return the mass(es) of the incoming particle(s).  We take the first flavor
combination in the array, assuming that masses must be degenerate among
flavors.
<<PHS base: phs config: TBP>>=
  procedure :: get_masses_in => phs_config_get_masses_in
<<PHS base: procedures>>=
  subroutine phs_config_get_masses_in (phs_config, m)
    class(phs_config_t), intent(in) :: phs_config
    real(default), dimension(:), intent(out) :: m
    integer :: i
    do i = 1, phs_config%n_in
       m(i) = flavor_get_mass (phs_config%flv(i,1))
    end do
  end subroutine phs_config_get_masses_in
  
@ %def phs_config_get_masses_in
@ Return the MD5 sum of the configuration.
<<PHS base: phs config: TBP>>=
  procedure :: get_md5sum => phs_config_get_md5sum
<<PHS base: procedures>>=
  function phs_config_get_md5sum (phs_config) result (md5sum)
    class(phs_config_t), intent(in) :: phs_config
    character(32) :: md5sum
    md5sum = phs_config%md5sum_phs_config
  end function phs_config_get_md5sum
  
@ %def phs_config_get_md5sum
@
\subsection{Phase-space point instance}
The [[phs_t]] object holds the workspace for phase-space generation.
In the base object, we have the MC input parameters [[r]] and the
Jacobian factor [[f]], for each channel, and the incoming and outgoing
momenta.

Note: The [[active_channel]] array is not used yet, all elements are
initialized with [[.true.]].  It should be touched by the integrator if it
decides to drop irrelevant channels.
<<PHS base: public>>=
  public :: phs_t
<<PHS base: types>>=
  type, abstract :: phs_t
     class(phs_config_t), pointer :: config => null ()
     logical :: r_defined = .false.
     integer :: selected_channel = 0
     logical, dimension(:), allocatable :: active_channel
     real(default), dimension(:,:), allocatable :: r
     real(default), dimension(:), allocatable :: f
     real(default), dimension(:), allocatable :: m_in
     real(default), dimension(:), allocatable :: m_out
     real(default) :: flux = 0
     real(default) :: volume = 0
     type(lorentz_transformation_t) :: lt_cm_to_lab
     logical :: p_defined = .false.
     real(default) :: sqrts_hat = 0
     type(vector4_t), dimension(:), allocatable :: p
     logical :: q_defined = .false.
     type(vector4_t), dimension(:), allocatable :: q
   contains
   <<PHS base: phs: TBP>>
  end type phs_t
     
@ %def phs_t
@ Output.  Since phase space may get complicated, we include a
[[verbose]] option for the abstract [[write]] procedure.
<<PHS base: phs: TBP>>=
  procedure (phs_write), deferred :: write
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_write (object, unit, verbose)
       import
       class(phs_t), intent(in) :: object
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: verbose
     end subroutine phs_write
  end interface
  
@ %def phs_write
@ This procedure can be called to print the contents of the base type.
<<PHS base: phs: TBP>>=
  procedure :: base_write => phs_base_write
<<PHS base: procedures>>=
  subroutine phs_base_write (object, unit)
    class(phs_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, c, i
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "Partonic phase space: parameters"
    if (object%r_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    write (u, "(3x,A,999(1x," // FMT_19 // "))") "m_in    =", object%m_in
    write (u, "(3x,A,999(1x," // FMT_19 // "))") "m_out   =", object%m_out
    write (u, "(3x,A," // FMT_19 // ")")  "Flux   = ", object%flux
    write (u, "(3x,A," // FMT_19 // ")")  "Volume = ", object%volume
    if (allocated (object%f)) then
       do c = 1, size (object%r, 2)
          write (u, "(1x,A,I0,A)", advance="no")  "Channel #", c, ":"
          if (c == object%selected_channel) then
             write (u, "(1x,A)")  "[selected]"
          else
             write (u, *)
          end if
          write (u, "(3x,A)", advance="no")  "r ="
          do i = 1, size (object%r, 1)
             write (u, "(1x,F9.7)", advance="no")  object%r(i,c)
          end do
          write (u, *)
          write (u, "(3x,A,1x,ES13.7)")  "f =", object%f(c)
       end do
    end if
    write (u, "(1x,A)")  "Partonic phase space: momenta"
    if (object%p_defined) then
       write (u, "(3x,A," // FMT_19 // ")")  "sqrts  = ", object%sqrts_hat
    end if
    write (u, "(1x,A)", advance="no")  "Incoming:"
    if (object%p_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%p)) then
       do i = 1, size (object%p)
          call vector4_write (object%p(i), u)
       end do
    end if
    write (u, "(1x,A)", advance="no")  "Outgoing:"
    if (object%q_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%q)) then
       do i = 1, size (object%q)
          call vector4_write (object%q(i), u)
       end do
    end if
    if (object%p_defined .and. .not. object%config%cm_frame) then
       write (u, "(1x,A)")  "Transformation c.m -> lab frame"
       call lorentz_transformation_write (object%lt_cm_to_lab, u)
    end if
  end subroutine phs_base_write
          
@ %def phs_base_write
@ Finalizer.  The base type does not need it, but extensions may.
<<PHS base: phs: TBP>>=
  procedure (phs_final), deferred :: final
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_final (object)
       import
       class(phs_t), intent(inout) :: object
     end subroutine phs_final
  end interface
  
@ %def phs_final
@ Initializer.  Everything should be contained in the [[process_data]]
configuration object, so we can require a universal interface.
<<PHS base: phs: TBP>>=
  procedure (phs_init), deferred :: init
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_init (phs, phs_config)
       import
       class(phs_t), intent(out) :: phs
       class(phs_config_t), intent(in), target :: phs_config
     end subroutine phs_init
  end interface
  
@ %def phs_init
@ The base version will just allocate the arrays.  It should be called
at the beginning of the implementation of [[phs_init]].
<<PHS base: phs: TBP>>=
  procedure :: base_init => phs_base_init
<<PHS base: procedures>>=
  subroutine phs_base_init (phs, phs_config)
    class(phs_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    phs%config => phs_config
    allocate (phs%active_channel (phs%config%n_channel))
    phs%active_channel = .true.
    allocate (phs%r (phs%config%n_par, phs%config%n_channel));  phs%r = 0
    allocate (phs%f (phs%config%n_channel));                    phs%f = 0
    allocate (phs%p (phs%config%n_in))
    allocate (phs%m_in  (phs%config%n_in), &
         source = flavor_get_mass (phs_config%flv(:phs_config%n_in, 1)))
    allocate (phs%q (phs%config%n_out))
    allocate (phs%m_out (phs%config%n_out), &
         source = flavor_get_mass (phs_config%flv(phs_config%n_in+1:, 1)))
    call phs%compute_flux ()
  end subroutine phs_base_init

@ %def phs_base_init
@ Manually select a channel.
<<PHS base: phs: TBP>>=
  procedure :: select_channel => phs_base_select_channel
<<PHS base: procedures>>=
  subroutine phs_base_select_channel (phs, channel)
    class(phs_t), intent(inout) :: phs
    integer, intent(in), optional :: channel
    if (present (channel)) then
       phs%selected_channel = channel
    else
       phs%selected_channel = 0
    end if
  end subroutine phs_base_select_channel
  
@ %def phs_base_select_channel
@ Set incoming momenta.  Assume that array shapes match.  If
requested, compute the Lorentz transformation from the c.m.\ to the
lab frame and apply that transformation to the incoming momenta.

In the c.m.\ frame, the sum of three-momenta is zero.  In a scattering
process, the $z$ axis is the direction of the first beam, the second
beam is along the negative $z$ axis.  The transformation from the
c.m.\ to the lab frame is a rotation from the $z$ axis to the boost
axis followed by a boost, such that the c.m.\ momenta are transformed
into the lab-frame momenta.  In a decay process, we just boost along
the flight direction, without rotation.
<<PHS base: phs: TBP>>=
  procedure :: set_incoming_momenta => phs_set_incoming_momenta
<<PHS base: procedures>>=
  subroutine phs_set_incoming_momenta (phs, p)
    class(phs_t), intent(inout) :: phs
    type(vector4_t), dimension(:), intent(in) :: p
    type(vector4_t) :: p0, p1
    type(lorentz_transformation_t) :: lt0
    phs%p = p
    if (phs%config%cm_frame) then
       phs%sqrts_hat = phs%config%sqrts
       phs%p = p
    else
       p0 = sum (p)
       if (phs%config%sqrts_fixed) then
          phs%sqrts_hat = phs%config%sqrts
       else
          phs%sqrts_hat = p0 ** 1
       end if
       lt0 = boost (p0, phs%sqrts_hat)
       select case (phs%config%n_in)
       case (1)
          phs%lt_cm_to_lab = lt0
       case (2)
          p1 = inverse (lt0) * p(1)
          phs%lt_cm_to_lab = lt0 * rotation_to_2nd (3, space_part (p1))
       end select
       phs%p = inverse (phs%lt_cm_to_lab) * p
    end if
    phs%p_defined = .true.
  end subroutine phs_set_incoming_momenta
  
@ %def phs_set_incoming_momenta
@ Set outgoing momenta.  Assume that array shapes match.  The incoming
momenta must be known, so can apply the Lorentz transformation from
c.m.\ to lab (inverse) to the momenta.
<<PHS base: phs: TBP>>=
  procedure :: set_outgoing_momenta => phs_set_outgoing_momenta
<<PHS base: procedures>>=
  subroutine phs_set_outgoing_momenta (phs, q)
    class(phs_t), intent(inout) :: phs
    type(vector4_t), dimension(:), intent(in) :: q
    if (phs%p_defined) then
       if (phs%config%cm_frame) then
          phs%q = q
       else
          phs%q = inverse (phs%lt_cm_to_lab) * q
       end if
       phs%q_defined = .true.
    end if
  end subroutine phs_set_outgoing_momenta
  
@ %def phs_set_outgoing_momenta
@ Return outgoing momenta.  Apply the c.m.\ to lab transformation if
necessary.
<<PHS base: phs: TBP>>=
  procedure :: get_outgoing_momenta => phs_get_outgoing_momenta
<<PHS base: procedures>>=
  subroutine phs_get_outgoing_momenta (phs, q)
    class(phs_t), intent(in) :: phs
    type(vector4_t), dimension(:), intent(out) :: q
    if (phs%p_defined .and. phs%q_defined) then
       if (phs%config%cm_frame) then
          q = phs%q
       else
          q = phs%lt_cm_to_lab * phs%q
       end if
    else
       q = vector4_null
    end if
  end subroutine phs_get_outgoing_momenta
  
@ %def phs_get_outgoing_momenta
@ Return the input parameter array for a channel.
<<PHS base: phs: TBP>>=
  procedure :: get_mcpar => phs_get_mcpar
<<PHS base: procedures>>=
  subroutine phs_get_mcpar (phs, c, r)
    class(phs_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default), dimension(:), intent(out) :: r
    if (phs%r_defined) then
       r = phs%r(:,c)
    else
       r = 0
    end if
  end subroutine phs_get_mcpar
  
@ %def phs_get_mcpar
@ Return the Jacobian factor for a channel.
<<PHS base: phs: TBP>>=
  procedure :: get_f => phs_get_f
<<PHS base: procedures>>=
  function phs_get_f (phs, c) result (f)
    class(phs_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default) :: f
    if (phs%r_defined) then
       f = phs%f(c)
    else
       f = 0
    end if
  end function phs_get_f
    
@ %def phs_get_f
@ Return the overall factor, which is the product of the flux factor for the
incoming partons and the phase-space volume for the outgoing partons.
<<PHS base: phs: TBP>>=
  procedure :: get_overall_factor => phs_get_overall_factor
<<PHS base: procedures>>=
  function phs_get_overall_factor (phs) result (f)
    class(phs_t), intent(in) :: phs
    real(default) :: f
    f = phs%flux * phs%volume
  end function phs_get_overall_factor
  
@ %def phs_get_overall_factor
@ Compute flux factor.  We do this during initialization (when the
incoming momenta [[p]] are undefined), unless [[sqrts]] is variable.  We do
this again once for each phase-space point, but then we skip the calculation
if [[sqrts]] is fixed.

There are three different flux factors.
\begin{enumerate}
\item
  For a decaying massive particle, the factor is
  \begin{equation}
    f = (2\pi)^4 / (2M)
  \end{equation}
\item
  For a $2\to n$ scattering process with $n>1$, the factor is
  \begin{equation}
    f = (2\pi)^4 / (2\sqrt{\lambda})
  \end{equation}
  where for massless incoming particles, $\sqrt{\lambda} = s$.
\item For a $2\to 1$ on-shell production process, the factor includes
  an extra $1/(2\pi)^3$ factor and a $1/m^2$ factor from the
  phase-space delta function $\delta (x_1x_2 - m^2/s)$, which
  originate from the one-particle phase space that we integrate out.
  \begin{equation}
    f = 2\pi / (2s m^2)
  \end{equation}
  The delta function is handled by the structure-function
  parameterization.
\end{enumerate}
<<PHS base: phs: TBP>>=
  procedure :: compute_flux => phs_compute_flux
<<PHS base: procedures>>=
  subroutine phs_compute_flux (phs)
    class(phs_t), intent(inout) :: phs
    real(default) :: s_hat, lda
    select case (phs%config%n_in)
    case (1)
       if (.not. phs%p_defined) then
          phs%flux = twopi4 / (2 * phs%m_in(1))
       end if
    case (2)
       if (phs%p_defined) then
          if (phs%config%sqrts_fixed) then
             return
          else
             s_hat = sum (phs%p) ** 2
          end if
       else
          if (phs%config%sqrts_fixed) then
             s_hat = phs%config%sqrts ** 2
          else
             return
          end if
       end if
       select case (phs%config%n_out)
       case (2:)
          lda = lambda (s_hat, phs%m_in(1) ** 2, phs%m_in(2) ** 2)
          if (lda > 0) then
             phs%flux = conv * twopi4 / (2 * sqrt (lda))
          else
             phs%flux = 0
          end if
       case (1)
          phs%flux = conv * twopi &
               / (2 * phs%config%sqrts ** 2 * phs%m_out(1) ** 2)
       case default
          phs%flux = 0
       end select
    end select
  end subroutine phs_compute_flux

@ %def phs_compute_flux
@ Evaluate the phase-space point for a particular channel and compute momenta,
Jacobian, and phase-space volume. This is, of course, deferred to
the implementation.
<<PHS base: phs: TBP>>=
  procedure (phs_evaluate_selected_channel), deferred :: &
       evaluate_selected_channel
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_evaluate_selected_channel (phs, c_in, r_in)
       import
       class(phs_t), intent(inout) :: phs
       integer, intent(in) :: c_in
       real(default), dimension(:), intent(in) :: r_in
     end subroutine phs_evaluate_selected_channel
  end interface
  
@ %def phs_evaluate_selected_channel
@ Compute the inverse mappings to completely fill the [[r]] and [[f]] arrays,
for the non-selected channels.
<<PHS base: phs: TBP>>=
  procedure (phs_evaluate_other_channels), deferred :: &
       evaluate_other_channels
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_evaluate_other_channels (phs, c_in)
       import
       class(phs_t), intent(inout) :: phs
       integer, intent(in) :: c_in
     end subroutine phs_evaluate_other_channels
  end interface
  
@ %def phs_evaluate_other_channels
@ Inverse evaluation.  If all momenta are known, we compute the
inverse mappings to fill the [[r]] and [[f]] arrays.
<<PHS base: phs: TBP>>=
  procedure (phs_inverse), deferred :: inverse
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_inverse (phs)
       import
       class(phs_t), intent(inout) :: phs
     end subroutine phs_inverse
  end interface
  
@ %def phs_inverse
@
\subsection{Auxiliary stuff}
The [[pacify]] subroutine, which is provided by the Lorentz module,
has the purpose of setting numbers to zero which are (by comparing
with a [[tolerance]] parameter) considered equivalent with zero.  This
is useful for numerical checks.
<<PHS base: public>>=
  public :: pacify
<<PHS base: interfaces>>=
  interface pacify
     module procedure pacify_phs
  end interface pacify
  
<<PHS base: procedures>>=
  subroutine pacify_phs (phs)
    class(phs_t), intent(inout) :: phs
    if (phs%p_defined) then
       call pacify (phs%p, 30 * epsilon (1._default) * phs%config%sqrts)
       call pacify (phs%lt_cm_to_lab, 30 * epsilon (1._default))
    end if
    if (phs%q_defined) then
       call pacify (phs%q, 30 * epsilon (1._default) * phs%config%sqrts)
    end if
  end subroutine pacify_phs
    
@ %def pacify
@
\subsection{Unit tests}
<<PHS base: public>>=
  public :: phs_base_test
<<PHS base: tests>>=
  subroutine phs_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS base: execute tests>>
  end subroutine phs_base_test
  
@ %def phs_base_test
@
\subsubsection{Test process data}
We provide a procedure that initializes a test case for the process
constants.  This set of process data contains just the minimal
contents that we need for the phase space.  The rest is left
uninitialized.
<<PHS base: public>>=
  public :: init_test_process_data
<<PHS base: tests>>=
  subroutine init_test_process_data (id, data)
    type(process_constants_t), intent(out) :: data 
    type(string_t), intent(in), optional :: id
    if (present (id)) then
       data%id = id
    else
       data%id = "testproc"
    end if
    data%model_name = "Test"
    data%n_in = 2
    data%n_out = 2
    data%n_flv = 1
    allocate (data%flv_state (data%n_in + data%n_out, data%n_flv))
    data%flv_state = 25
  end subroutine init_test_process_data

@ %def init_test_process_data
@ This is the variant for a decay process.
<<PHS base: public>>=
  public :: init_test_decay_data
<<PHS base: tests>>=
  subroutine init_test_decay_data (id, data)
    type(process_constants_t), intent(out) :: data 
    type(string_t), intent(in), optional :: id
    if (present (id)) then
       data%id = id
    else
       data%id = "testproc"
    end if
    data%model_name = "Test"
    data%n_in = 1
    data%n_out = 2
    data%n_flv = 1
    allocate (data%flv_state (data%n_in + data%n_out, data%n_flv))
    data%flv_state(:,1) = [25, 6, -6]
  end subroutine init_test_decay_data

@ %def init_test_decay_data
@
\subsubsection{Test kinematics configuration}
This is a trivial implementation of the [[phs_config_t]] configuration object.
<<PHS base: public>>=
  public :: phs_test_config_t
<<PHS base: test types>>=
  type, extends (phs_config_t) :: phs_test_config_t
     logical :: create_equivalences = .false.
   contains
     procedure :: final => phs_test_config_final
     procedure :: write => phs_test_config_write
     procedure :: configure => phs_test_config_configure
     procedure :: startup_message => phs_test_config_startup_message
     procedure, nopass :: allocate_instance => phs_test_config_allocate_instance
  end type phs_test_config_t

@ %def phs_test_config_t
@ The finalizer is empty.
<<PHS base: tests>>=
  subroutine phs_test_config_final (object)
    class(phs_test_config_t), intent(inout) :: object
  end subroutine phs_test_config_final

@ %def phs_test_config_final
@ The [[cm_frame]] parameter is not tested here; we defer this to the
[[phs_single]] implementation.
<<PHS base: tests>>=
  subroutine phs_test_config_write (object, unit)
    class(phs_test_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Partonic phase-space configuration:"
    call object%base_write (unit)
  end subroutine phs_test_config_write
  
  subroutine phs_test_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_test_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(string_t), intent(inout), optional :: nlo_type
    phs_config%n_channel = 2
    phs_config%n_par = 2
    phs_config%sqrts = sqrts
    if (.not. present (nlo_type)) &
      phs_config%nlo_type = 'Born'
    if (present (sqrts_fixed)) then
       phs_config%sqrts_fixed = sqrts_fixed
    end if
    if (present (cm_frame)) then
       phs_config%cm_frame = cm_frame
    end if
    if (present (azimuthal_dependence)) then
       phs_config%azimuthal_dependence = azimuthal_dependence
    end if
    if (allocated (phs_config%channel))  deallocate (phs_config%channel)
    allocate (phs_config%channel (phs_config%n_channel))
    if (phs_config%create_equivalences) then
       call setup_test_equivalences (phs_config)
       call setup_test_channel_props (phs_config)
    end if
    call phs_config%compute_md5sum ()
  end subroutine phs_test_config_configure

@ %def phs_test_config_write
@ %def phs_test_config_configure
@ If requested, we make up an arbitrary set of equivalences.
<<PHS base: tests>>=
  subroutine setup_test_equivalences (phs_config)
    class(phs_test_config_t), intent(inout) :: phs_config
    integer :: i
    associate (channel => phs_config%channel(1))
      allocate (channel%eq (2))
      do i = 1, size (channel%eq)
         call channel%eq(i)%init (phs_config%n_par)
      end do
      associate (eq => channel%eq(1))
        eq%c = 1;  eq%perm = [1, 2];  eq%mode = [EQ_IDENTITY, EQ_SYMMETRIC]
      end associate
      associate (eq => channel%eq(2))
        eq%c = 2;  eq%perm = [2, 1];  eq%mode = [EQ_INVARIANT, EQ_IDENTITY]
      end associate
    end associate
  end subroutine setup_test_equivalences
      
@ %def setup_test_equivalences
@ Ditto, for channel properties.
<<PHS base: tests>>=
  subroutine setup_test_channel_props (phs_config)
    class(phs_test_config_t), intent(inout) :: phs_config
    associate (channel => phs_config%channel(2))
      call channel%set_resonant (140._default, 3.1415_default)
    end associate
  end subroutine setup_test_channel_props
      
@ %def setup_test_channel_props
@ Startup message
<<PHS base: tests>>=
  subroutine phs_test_config_startup_message (phs_config, unit)
    class(phs_test_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%base_startup_message (unit)
    write (msg_buffer, "(A)") "Phase space: Test"
    call msg_message (unit = unit)
  end subroutine phs_test_config_startup_message
  
@ %def phs_test_config_startup_message
@ The instance type that matches [[phs_test_config_t]] is [[phs_test_t]].
<<PHS base: tests>>=
  subroutine phs_test_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_test_t :: phs)
  end subroutine phs_test_config_allocate_instance
  
@ %def phs_test_config_allocate_instance
@
\subsubsection{Test kinematics implementation}
This implementation of kinematics generates a simple two-particle
configuration from the incoming momenta.  The incoming momenta must be
in the c.m.\ system, all masses equal.

There are two channels: one generates $\cos\theta$ and $\phi$
uniformly, in the other channel we map the $r_1$ parameter which
belongs to $\cos\theta$.

We should store the mass parameter that we need.
<<PHS base: public>>=
  public :: phs_test_t
<<PHS base: test types>>=
  type, extends (phs_t) :: phs_test_t
     real(default) :: m = 0
     real(default), dimension(:), allocatable :: x
   contains
   <<PHS base: phs test: TBP>>
  end type phs_test_t
  
@ %def phs_test_t
@ Output.  The specific data are displayed only if [[verbose]] is set.
<<PHS base: phs test: TBP>>=
  procedure :: write => phs_test_write
<<PHS base: tests>>=
  subroutine phs_test_write (object, unit, verbose)
    class(phs_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    logical :: verb
    u = given_output_unit (unit)
    verb = .false.;  if (present (verbose))  verb = verbose
    if (verb) then
       write (u, "(1x,A)")  "Partonic phase space: data"
       write (u, "(3x,A," // FMT_19 // ")")  "m = ", object%m
    end if
    call object%base_write (u)
  end subroutine phs_test_write
    
@ %def phs_test_write
@ The finalizer is empty.
<<PHS base: phs test: TBP>>=
  procedure :: final => phs_test_final
<<PHS base: tests>>=
  subroutine phs_test_final (object)
    class(phs_test_t), intent(inout) :: object
  end subroutine phs_test_final
  
@ %def phs_test_final
@ Initialization: set the mass value.
<<PHS base: phs test: TBP>>=
  procedure :: init => phs_test_init
<<PHS base: tests>>=
  subroutine phs_test_init (phs, phs_config)
    class(phs_test_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    phs%m = flavor_get_mass (phs%config%flv(1,1))
    allocate (phs%x (phs_config%n_par), source = 0._default)
  end subroutine phs_test_init
  
@ %def phs_test_init
@ Evaluation.  In channel 1, we uniformly generate $\cos\theta$ and
$\phi$, with Jacobian normalized to one.  In channel 2, we prepend a
mapping $r_1 \to r_1^(1/3)$ with Jacobian $f=3r_1^2$.

The component [[x]] is allocated in the first subroutine, used and deallocated
in the second one.
<<PHS base: phs test: TBP>>=
  procedure :: evaluate_selected_channel => phs_test_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_test_evaluate_other_channels
<<PHS base: tests>>=
  subroutine phs_test_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_test_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    if (phs%p_defined) then
       call phs%select_channel (c_in)
       phs%r(:,c_in) = r_in
       select case (c_in)
       case (1)
          phs%x = r_in
       case (2)
          phs%x(1) = r_in(1) ** (1 / 3._default)
          phs%x(2) = r_in(2)
       end select
       call compute_kinematics_solid_angle (phs%p, phs%q, phs%x) 
       phs%volume = 1
       phs%q_defined = .true.
    end if
  end subroutine phs_test_evaluate_selected_channel
  
  subroutine phs_test_evaluate_other_channels (phs, c_in)
    class(phs_test_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    integer :: c, n_channel
    if (phs%p_defined) then
       n_channel = phs%config%n_channel
       do c = 1, n_channel
          if (c /= c_in) then
             call inverse_kinematics_solid_angle (phs%p, phs%q, phs%x)
             select case (c)
             case (1)
                phs%r(:,c) = phs%x
             case (2)
                phs%r(1,c) = phs%x(1) ** 3
                phs%r(2,c) = phs%x(2)
             end select
          end if
       end do
       phs%f(1) = 1
       if (phs%r(1,2) /= 0) then
          phs%f(2) = 1 / (3 * phs%r(1,2) ** (2/3._default))
       else
          phs%f(2) = 0
       end if
       phs%r_defined = .true.
    end if
  end subroutine phs_test_evaluate_other_channels
  
@ %def phs_test_evaluate_selected_channels
@ %def phs_test_evaluate_other_channels
@ Inverse evaluation.
<<PHS base: phs test: TBP>>=
  procedure :: inverse => phs_test_inverse
<<PHS base: tests>>=
  subroutine phs_test_inverse (phs)
    class(phs_test_t), intent(inout) :: phs
    integer :: c, n_channel
    real(default), dimension(:), allocatable :: x
    if (phs%p_defined .and. phs%q_defined) then
       call phs%select_channel ()
       n_channel = phs%config%n_channel
       allocate (x (phs%config%n_par))
       do c = 1, n_channel
          call inverse_kinematics_solid_angle (phs%p, phs%q, x)
          select case (c)
          case (1)
             phs%r(:,c) = x
          case (2)
             phs%r(1,c) = x(1) ** 3
             phs%r(2,c) = x(2)
          end select
       end do
       phs%f(1) = 1
       if (phs%r(1,2) /= 0) then
          phs%f(2) = 1 / (3 * phs%r(1,2) ** (2/3._default))
       else
          phs%f(2) = 0
       end if
       phs%volume = 1
       phs%r_defined = .true.
    end if
  end subroutine phs_test_inverse
  
@ %def phs_test_inverse
@ 
\subsubsection{Uniform angular distribution}
These procedures implement the uniform angular distribution, generated
from two parameters $x_1$ and $x_2$:
\begin{equation}
  \cos\theta = 1 - 2x_1, \qquad \phi = 2\pi x_2
\end{equation}
We generate a rotation (Lorentz transformation) which rotates the
positive $z$ axis into this point on the unit sphere.  This rotation
is applied to the [[p]] momenta, which are assumed to be
back-to-back, on-shell, and with the correct mass.

We do not compute a Jacobian (constant).  The uniform distribution is
assumed to be normalized.
<<PHS base: public>>=
  public :: compute_kinematics_solid_angle
<<PHS base: tests>>=
  subroutine compute_kinematics_solid_angle (p, q, x)
    type(vector4_t), dimension(2), intent(in) :: p
    type(vector4_t), dimension(2), intent(out) :: q
    real(default), dimension(2), intent(in) :: x
    real(default) :: ct, st, phi
    type(lorentz_transformation_t) :: rot
    integer :: i
    ct = 1 - 2*x(1)
    st = sqrt (1 - ct**2)
    phi = twopi * x(2)
    rot = rotation (phi, 3) * rotation (ct, st, 2)
    do i = 1, 2
       q(i) = rot * p(i)
    end do
  end subroutine compute_kinematics_solid_angle
  
@ %def compute_kinematics_solid_angle
@ This is the inverse transformation.  We assume that the outgoing
momenta are rotated versions of the incoming momenta, back-to-back.
Thus, we determine the angles from $q(1)$ alone.  [[p]] is unused.
<<PHS base: public>>=
  public :: inverse_kinematics_solid_angle
<<PHS base: tests>>=
  subroutine inverse_kinematics_solid_angle (p, q, x)
    type(vector4_t), dimension(:), intent(in) :: p
    type(vector4_t), dimension(2), intent(in) :: q
    real(default), dimension(2), intent(out) :: x
    real(default) :: ct, phi
    ct = polar_angle_ct (q(1))
    phi = azimuthal_angle (q(1))
    x(1) = (1 - ct) / 2
    x(2) = phi / twopi
  end subroutine inverse_kinematics_solid_angle

@ %def inverse_kinematics_solid_angle
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.
<<PHS base: execute tests>>=
  call test (phs_base_1, "phs_base_1", &
       "phase-space configuration", &
       u, results)
<<PHS base: tests>>=
  subroutine phs_base_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_1"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
       
    call phs_data%write (u)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_1"

  end subroutine phs_base_1

@ %def phs_base_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS base: execute tests>>=
  call test (phs_base_2, "phs_base_2", &
       "phase-space evaluation", &
       u, results)
<<PHS base: tests>>=
  subroutine phs_base_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    
    write (u, "(A)")  "* Test output: phs_base_2"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flavor_init (flv, 25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_2"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    select type (phs)
    type is (phs_test_t)
       call phs%init (phs_data)
    end select
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flavor_get_mass (flv)**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flavor_get_mass (flv)**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point in channel 1 &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point in channel 2 &
         &for x = 0.125, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (2, [0.125_default, 0.125_default])
    call phs%evaluate_other_channels (2)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    select type (phs_data)
    type is (phs_test_config_t)
       call phs_data%configure (sqrts)
    end select

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_2"

  end subroutine phs_base_2

@ %def phs_base_2
@
\subsubsection{Phase-space equivalences}
Construct a test phase-space configuration which contains channel
equivalences.
<<PHS base: execute tests>>=
  call test (phs_base_3, "phs_base_3", &
       "channel equivalences", &
       u, results)
<<PHS base: tests>>=
  subroutine phs_base_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_3"
    write (u, "(A)")  "*   Purpose: construct phase-space configuration data &
         &with equivalences"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_3"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_test_config_t)
       phs_data%create_equivalences = .true.
    end select
       
    call phs_data%configure (1000._default)
    call phs_data%write (u)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_3"

  end subroutine phs_base_3

@ %def phs_base_3
@
\subsubsection{MD5 sum checks}
Construct a test phase-space configuration, compute and compare MD5 sums.
<<PHS base: execute tests>>=
  call test (phs_base_4, "phs_base_4", &
       "MD5 sum", &
       u, results)
<<PHS base: tests>>=
  subroutine phs_base_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_4"
    write (u, "(A)")  "*   Purpose: compute and compare MD5 sums"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Model parameters"
    write (u, "(A)")

    call model%write (unit = u, &
         show_parameters = .true., &
         show_particles = .false., show_vertices = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_4"), process_data)
    process_data%md5sum = "test_process_data_m6sum_12345678"

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
    
    call phs_data%compute_md5sum ()
    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Modify model parameter"
    write (u, "(A)")

    call model%set_par (var_str ("ms"), 100._default)
    call model%write (show_parameters = .true., &
         show_particles = .false., show_vertices = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* PHS configuration"
    write (u, "(A)")

    call phs_data%compute_md5sum ()
    call phs_data%write (u)

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_4"

  end subroutine phs_base_4

@ %def phs_base_4
@
\subsubsection{Phase-space channel collection}
Set up an array of various phase-space channels and collect them in a list.
<<PHS base: execute tests>>=
  call test (phs_base_5, "phs_base_5", &
       "channel collection", &
       u, results)
<<PHS base: tests>>=
  subroutine phs_base_5 (u)
    integer, intent(in) :: u
    type(phs_channel_t), dimension(:), allocatable :: channel
    type(phs_channel_collection_t) :: coll
    integer :: i, n
    
    write (u, "(A)")  "* Test output: phs_base_5"
    write (u, "(A)")  "*   Purpose: collect channel properties"
    write (u, "(A)")
    
    write (u, "(A)")  "* Set up an array of channels"
    write (u, "(A)")

    n = 6

    allocate (channel (n))
    call channel(2)%set_resonant (75._default, 3._default)
    call channel(4)%set_resonant (130._default, 1._default)
    call channel(5)%set_resonant (75._default, 3._default)
    call channel(6)%set_on_shell (33._default)

    do i = 1, n
       write (u, "(1x,I0)", advance="no")  i
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Collect distinct properties"
    write (u, "(A)")
    
    do i = 1, n
       call coll%push (channel(i))
    end do

    write (u, "(1x,A,I0)")  "n = ", coll%get_n ()
    write (u, "(A)")

    call coll%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Channel array with collection index assigned"
    write (u, "(A)")

    do i = 1, n
       write (u, "(1x,I0)", advance="no")  i
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call coll%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_5"

  end subroutine phs_base_5

@ %def phs_base_5
