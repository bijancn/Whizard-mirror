%% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: phase space
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Phase Space}

The abstract representation of a type that parameterizes phase space,
with methods for construction and evaluation.
\begin{description}
\item[phs\_base]
  Abstract phase-space representation.
\end{description}

A simple implementation:
\begin{description}
\item[phs\_single]
  Parameterize the phase space of a single particle, i.e., the solid
  angle.  This is useful only for very restricted problems, but it
  avoids the complexity of a generic approach in those trivial cases.
\end{description}

The standard implementation is called \emph{wood} phase space.  It
consists of several auxiliary modules and the actual implementation
module. 
\begin{description}
\item[mappings] 
  Generate invariant masses and decay angles from given
  random numbers (or the inverse operation).  Each mapping pertains to a
  particular node in a phase-space tree.  Different mappings account for
  uniform distributions, resonances, zero-mass behavior, and so on.
\item[phs\_trees] 
  Phase space parameterizations for scattering
  processes are defined recursively as if there was an initial particle
  decaying.  This module sets up a representation in terms of abstract
  trees, where each node gets a unique binary number.  Each tree is
  stored as an array of branches, where integers indicate the
  connections.  This emulates pointers in a transparent way.  Real
  pointers would also be possible, but seem to be less efficient for
  this particular case.
\item[phs\_forests] 
  The type defined by this module collects the
  decay trees corresponding to a given process and the applicable
  mappings.  To set this up, a file is read which is either written by
  the user or by the \textbf{cascades} module functions.  The module
  also contains the routines that evaluate phase space, i.e., generate
  momenta from random numbers and back.
\item[cascades] 
  This module is a pseudo Feynman diagram generator with the
  particular purpose of finding the phase space parameterizations best
  suited for a given process.  It uses a model file to set up the
  possible vertices, generates all possible diagrams, identifies
  resonances and singularities, and simplifies the list by merging
  equivalent diagrams and dropping irrelevant ones.  This process can be
  controlled at several points by user-defined parameters.  Note that it
  depends on the particular values of particle masses, so it cannot be
  done before reading the input file.
\item[phs\_wood]
  Make the functionality available in form of an implementation of the
  abstract phase-space type.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract phase-space module}

In this module we define an abstract base type (and a trivial test
implementation) for multi-channel phase-space parameterizations.
<<[[phs_base.f90]]>>=
<<File header>>

module phs_base

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants, only: TWOPI, TWOPI4
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use md5
  use physics_defs
  use lorentz
  use model_data
  use flavors
  use process_constants

<<Standard module head>>

<<PHS base: public>>

<<PHS base: types>>

<<PHS base: interfaces>>

contains

<<PHS base: procedures>>

end module phs_base
@ %def phs_base
@
\subsection{Phase-space channels}
The kinematics configuration may generate multiple parameterizations of phase
space.  Some of those have specific properties, such as a resonance in the s
channel.

\subsubsection{Channel properties}
This is the abstract type for the channel properties.  We need them as
a data transfer container, so everything is public and transparent.
<<PHS base: public>>=
  public :: channel_prop_t
<<PHS base: types>>=
  type, abstract :: channel_prop_t
   contains
     procedure (channel_prop_to_string), deferred :: to_string
     generic :: operator (==) => is_equal
     procedure (channel_eq), deferred :: is_equal
  end type channel_prop_t

@ %def channel_prop_t
<<PHS base: interfaces>>=
  abstract interface
     function channel_prop_to_string (object) result (string)
       import
       class(channel_prop_t), intent(in) :: object
       type(string_t) :: string
     end function channel_prop_to_string
  end interface

@ %def channel_prop_to_string
<<PHS base: interfaces>>=
  abstract interface
     function channel_eq (prop1, prop2) result (flag)
       import
       class(channel_prop_t), intent(in) :: prop1, prop2
       logical :: flag
     end function channel_eq
  end interface

@ %def channel_prop_to_string
@
Here is a resonance as a channel property.  Mass and width are stored
here in physical units.
<<PHS base: public>>=
  public :: resonance_t
<<PHS base: types>>=
  type, extends (channel_prop_t) :: resonance_t
     real(default) :: mass = 0
     real(default) :: width = 0
   contains
     procedure :: to_string => resonance_to_string
     procedure :: is_equal => resonance_is_equal
  end type resonance_t
  
@ %def resonance_t
@ Print mass and width.
<<PHS base: procedures>>=
  function resonance_to_string (object) result (string)
    class(resonance_t), intent(in) :: object
    type(string_t) :: string
    character(32) :: buffer
    string = "resonant: m ="
    write (buffer, "(" // FMT_19 // ")")  object%mass
    string = string // trim (buffer) // " GeV, w ="
    write (buffer, "(" // FMT_19 // ")")  object%width
    string = string // trim (buffer) // " GeV"
  end function resonance_to_string

@ %def resonance_to_string
@ Equality.
<<PHS base: procedures>>=
  function resonance_is_equal (prop1, prop2) result (flag)
    class(resonance_t), intent(in) :: prop1
    class(channel_prop_t), intent(in) :: prop2
    logical :: flag
    select type (prop2)
    type is (resonance_t)
       flag = prop1%mass == prop2%mass .and. prop1%width == prop2%width
    class default
       flag = .false.
    end select
  end function resonance_is_equal
  
@ %def resonance_is_equal
@
This is the limiting case of a resonance, namely an on-shell particle.
We just store the mass in physical units.
<<PHS base: public>>=
  public :: on_shell_t
<<PHS base: types>>=
  type, extends (channel_prop_t) :: on_shell_t
     real(default) :: mass = 0
   contains
     procedure :: to_string => on_shell_to_string
     procedure :: is_equal => on_shell_is_equal
  end type on_shell_t
  
@ %def on_shell_t
@ Print mass and width.
<<PHS base: procedures>>=
  function on_shell_to_string (object) result (string)
    class(on_shell_t), intent(in) :: object
    type(string_t) :: string
    character(32) :: buffer
    string = "on shell: m ="
    write (buffer, "(" // FMT_19 // ")")  object%mass
    string = string // trim (buffer) // " GeV"
  end function on_shell_to_string

@ %def on_shell_to_string
@ Equality.
<<PHS base: procedures>>=
  function on_shell_is_equal (prop1, prop2) result (flag)
    class(on_shell_t), intent(in) :: prop1
    class(channel_prop_t), intent(in) :: prop2
    logical :: flag
    select type (prop2)
    type is (on_shell_t)
       flag = prop1%mass == prop2%mass
    class default
       flag = .false.
    end select
  end function on_shell_is_equal
  
@ %def on_shell_is_equal
@
\subsubsection{Channel equivalences}
This type describes an equivalence.  The current channel is equivalent
to channel [[c]].  The equivalence involves a permutation [[perm]] of
integration dimensions and, within each integration dimension, a
mapping [[mode]].
<<PHS base: types>>=
  type :: phs_equivalence_t
     integer :: c = 0
     integer, dimension(:), allocatable :: perm
     integer, dimension(:), allocatable :: mode
   contains
   <<PHS base: phs equivalence: TBP>>
  end type phs_equivalence_t
  
@ %def phs_equivalence_t
@ 
The mapping modes are
<<PHS base: types>>=
  integer, parameter, public :: &
       EQ_IDENTITY = 0, EQ_INVERT = 1, EQ_SYMMETRIC = 2, EQ_INVARIANT = 3

@ %def EQ_IDENTITY EQ_INVERT EQ_SYMMETRIC
@ In particular, if a channel is equivalent to itself in the
[[EQ_SYMMETRIC]] mode, the integrand can be assumed to be symmetric
w.r.t.\ a reflection $x\to 1 - x$ of the correponding integration variable.

These are the associated tags, for output:
<<PHS base: types>>=
  character, dimension(0:3), parameter :: TAG = ["+", "-", ":", "x"]

@ %def TAG
@ Write an equivalence.
<<PHS base: phs equivalence: TBP>>=
  procedure :: write => phs_equivalence_write
<<PHS base: procedures>>=
  subroutine phs_equivalence_write (object, unit)
    class(phs_equivalence_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, j
    u = given_output_unit (unit)
    write (u, "(5x,'=',1x,I0,1x)", advance = "no")  object%c
    if (allocated (object%perm)) then
       write (u, "(A)", advance = "no")  "("
       do j = 1, size (object%perm)
          if (j > 1)  write (u, "(1x)", advance = "no")
          write (u, "(I0,A1)", advance = "no") &
               object%perm(j), TAG(object%mode(j))
       end do
       write (u, "(A)")  ")"
    else
       write (u, "(A)")
    end if
  end subroutine phs_equivalence_write
  
@ %def phs_equivalence_write
@ Initialize an equivalence.  This allocates the [[perm]] and [[mode]]
arrays with equal size.
<<PHS base: phs equivalence: TBP>>=
  procedure :: init => phs_equivalence_init
<<PHS base: procedures>>=
  subroutine phs_equivalence_init (eq, n_dim)
    class(phs_equivalence_t), intent(out) :: eq
    integer, intent(in) :: n_dim
    allocate (eq%perm (n_dim), source = 0)
    allocate (eq%mode (n_dim), source = EQ_IDENTITY)
  end subroutine phs_equivalence_init
  
@ %def phs_equivalence_init
@
\subsubsection{Channel objects}
The channel entry holds (optionally) specific properties.

[[sf_channel]] is the structure-function channel that corresponds to this
phase-space channel.  The structure-function channel may be set up with a
specific mapping that depends on the phase-space channel properties.  (The
default setting is to leave the properties empty.)
<<PHS base: public>>=
  public :: phs_channel_t
<<PHS base: types>>=
  type :: phs_channel_t
     class(channel_prop_t), allocatable :: prop
     integer :: sf_channel = 1
     type(phs_equivalence_t), dimension(:), allocatable :: eq
   contains
   <<PHS base: phs channel: TBP>>
  end type phs_channel_t
  
@ %def phs_channel_t
@ Output.
<<PHS base: phs channel: TBP>>=
  procedure :: write => phs_channel_write
<<PHS base: procedures>>=
  subroutine phs_channel_write (object, unit)
    class(phs_channel_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, j
    u = given_output_unit (unit)
    write (u, "(1x,I0)", advance="no") object%sf_channel
    if (allocated (object%prop)) then
       write (u, "(1x,A)")  char (object%prop%to_string ())
    else
       write (u, *)
    end if
    if (allocated (object%eq)) then
       do j = 1, size (object%eq)
          call object%eq(j)%write (u)
       end do
    end if
  end subroutine phs_channel_write
    
@ %def phs_channel_write
@ Identify the channel with an s-channel resonance.
<<PHS base: phs channel: TBP>>=
  procedure :: set_resonant => channel_set_resonant
<<PHS base: procedures>>=
  subroutine channel_set_resonant (channel, mass, width)
    class(phs_channel_t), intent(inout) :: channel
    real(default), intent(in) :: mass, width
    allocate (resonance_t :: channel%prop)
    select type (prop => channel%prop)
    type is (resonance_t)
       prop%mass = mass
       prop%width = width
    end select
  end subroutine channel_set_resonant
  
@ %def channel_set_resonant
@ Identify the channel with an on-shell particle.
<<PHS base: phs channel: TBP>>=
  procedure :: set_on_shell => channel_set_on_shell
<<PHS base: procedures>>=
  subroutine channel_set_on_shell (channel, mass)
    class(phs_channel_t), intent(inout) :: channel
    real(default), intent(in) :: mass
    allocate (on_shell_t :: channel%prop)
    select type (prop => channel%prop)
    type is (on_shell_t)
       prop%mass = mass
    end select
  end subroutine channel_set_on_shell
  
@ %def channel_set_on_shell
@
\subsection{Property collection}
We can set up a list of all distinct channel properties for a given
set of channels.
<<PHS base: public>>=
  public :: phs_channel_collection_t
<<PHS base: types>>=
  type :: prop_entry_t
     integer :: i = 0
     class(channel_prop_t), allocatable :: prop
     type(prop_entry_t), pointer :: next => null ()
  end type prop_entry_t
  
  type :: phs_channel_collection_t
     integer :: n = 0
     type(prop_entry_t), pointer :: first => null ()
   contains
   <<PHS base: phs channel collection: TBP>>
  end type phs_channel_collection_t

@ %def prop_entry_t
@ %def phs_channel_collection_t
@ Finalizer for the list.
<<PHS base: phs channel collection: TBP>>=
  procedure :: final => phs_channel_collection_final
<<PHS base: procedures>>=
  subroutine phs_channel_collection_final (object)
    class(phs_channel_collection_t), intent(inout) :: object
    type(prop_entry_t), pointer :: entry
    do while (associated (object%first))
       entry => object%first
       object%first => entry%next
       deallocate (entry)
    end do
  end subroutine phs_channel_collection_final

@ %def phs_channel_collection_final
@ Output.

Note: eliminating the [[string]] auxiliary triggers an ICE in gfortran 4.7.2.
<<PHS base: phs channel collection: TBP>>=
  procedure :: write => phs_channel_collection_write
<<PHS base: procedures>>=
  subroutine phs_channel_collection_write (object, unit)
    class(phs_channel_collection_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(prop_entry_t), pointer :: entry
    type(string_t) :: string
    integer :: u
    u = given_output_unit (unit)
    entry => object%first
    do while (associated (entry))
       if (allocated (entry%prop)) then
          string = entry%prop%to_string ()
          write (u, "(1x,I0,1x,A)")  entry%i, char (string)
       else
          write (u, "(1x,I0)")  entry%i
       end if
       entry => entry%next
    end do
  end subroutine phs_channel_collection_write
  
@ %def phs_channel_collection_write
@ Push a new property to the stack if it is not yet included.
Simultaneously, set the [[sf_channel]] entry in the phase-space
channel object to the index of the matching entry, or the new entry if
there was no match.
<<PHS base: phs channel collection: TBP>>=
  procedure :: push => phs_channel_collection_push
<<PHS base: procedures>>=
  subroutine phs_channel_collection_push (coll, channel)
    class(phs_channel_collection_t), intent(inout) :: coll
    type(phs_channel_t), intent(inout) :: channel
    type(prop_entry_t), pointer :: entry, new
    if (associated (coll%first)) then
       entry => coll%first
       do
          if (allocated (entry%prop)) then
             if (allocated (channel%prop)) then
                if (entry%prop == channel%prop) then
                   channel%sf_channel = entry%i
                   return
                end if
             end if
          else if (.not. allocated (channel%prop)) then
             channel%sf_channel = entry%i
             return
          end if
          if (associated (entry%next)) then
             entry => entry%next
          else
             exit
          end if
       end do
       allocate (new)
       entry%next => new
    else
       allocate (new)
       coll%first => new
    end if
    coll%n = coll%n + 1
    new%i = coll%n
    channel%sf_channel = new%i
    if (allocated (channel%prop)) then
       allocate (new%prop, source = channel%prop)
    end if
  end subroutine phs_channel_collection_push
    
@ %def phs_channel_collection_push
@ Return the number of collected distinct channels.
<<PHS base: phs channel collection: TBP>>=
  procedure :: get_n => phs_channel_collection_get_n
<<PHS base: procedures>>=
  function phs_channel_collection_get_n (coll) result (n)
    class(phs_channel_collection_t), intent(in) :: coll
    integer :: n
    n = coll%n
  end function phs_channel_collection_get_n
  
@ %def phs_channel_collection_get_n
@ Return a specific channel (property object).
<<PHS base: phs channel collection: TBP>>=
  procedure :: get_entry => phs_channel_collection_get_entry
<<PHS base: procedures>>=
  subroutine phs_channel_collection_get_entry (coll, i, prop)
    class(phs_channel_collection_t), intent(in) :: coll
    integer, intent(in) :: i
    class(channel_prop_t), intent(out), allocatable :: prop
    type(prop_entry_t), pointer :: entry
    integer :: k
    if (i > 0 .and. i <= coll%n) then
       entry => coll%first
       do k = 2, i
          entry => entry%next
       end do
       if (allocated (entry%prop)) then
	  if (allocated (prop))  deallocate (prop)
          allocate (prop, source = entry%prop)
       end if
    else
       call msg_bug ("PHS channel collection: get entry: illegal index")
    end if
  end subroutine phs_channel_collection_get_entry
    
@ %def phs_channel_collection_get_entry
@
\subsection{Kinematics configuration}
Here, we store the universal information that is specifically relevant
for phase-space generation.  It is a subset of the process data,
supplemented by basic information on phase-space parameterization
channels.

A concrete implementation will contain more data, that describe the
phase space in detail.

MD5 sums: the phase space setup depends on the process, it depends on
the model parameters (the masses, that is), and on the configuration
parameters.  (It doesn't depend on the QCD setup.)
<<PHS base: public>>=
  public :: phs_config_t
<<PHS base: types>>=
  type, abstract :: phs_config_t
     ! private
     type(string_t) :: id
     integer :: n_in = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     integer :: n_state = 0
     integer :: n_par = 0
     integer :: n_channel = 0
     real(default) :: sqrts = 0
     logical :: sqrts_fixed = .true.
     logical :: cm_frame = .true.
     logical :: azimuthal_dependence = .false.
     integer, dimension(:), allocatable :: dim_flat
     logical :: provides_equivalences = .false.
     logical :: provides_chains = .false.
     logical :: vis_channels = .false.
     integer, dimension(:), allocatable :: chain
     class(model_data_t), pointer :: model => null ()
     type(flavor_t), dimension(:,:), allocatable :: flv
     type(phs_channel_t), dimension(:), allocatable :: channel
     character(32) :: md5sum_process = ""
     character(32) :: md5sum_model_par = ""
     character(32) :: md5sum_phs_config = ""
     integer :: nlo_type
   contains
   <<PHS base: phs config: TBP>>
  end type phs_config_t
  
@ %def phs_config_t
@ Finalizer, deferred.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_final), deferred :: final
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_final (object)
       import
       class(phs_config_t), intent(inout) :: object
     end subroutine phs_config_final
  end interface

@ %def phs_config_final
@ Output.  We provide an implementation for the output of the base-type
contents and an interface for the actual write method.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_write), deferred :: write
  procedure :: base_write => phs_config_write
<<PHS base: procedures>>=
  subroutine phs_config_write (object, unit)
    class(phs_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i, j
    integer :: n_tot_flv
    n_tot_flv = object%n_tot
    u = given_output_unit (unit)
    write (u, "(3x,A,A,A)") "ID        = '", char (object%id), "'"
    write (u, "(3x,A,I0)")  "n_in      = ", object%n_in
    write (u, "(3x,A,I0)")  "n_out     = ", object%n_out
    write (u, "(3x,A,I0)")  "n_tot     = ", object%n_tot
    write (u, "(3x,A,I0)")  "n_state   = ", object%n_state
    write (u, "(3x,A,I0)")  "n_par     = ", object%n_par
    write (u, "(3x,A,I0)")  "n_channel = ", object%n_channel
    write (u, "(3x,A," // FMT_19 // ")")  "sqrts     = ", object%sqrts
    write (u, "(3x,A,L1)")  "s_fixed   = ", object%sqrts_fixed
    write (u, "(3x,A,L1)")  "cm_frame  = ", object%cm_frame
    write (u, "(3x,A,L1)")  "azim.dep. = ", object%azimuthal_dependence
    if (allocated (object%dim_flat)) then
       write (u, "(3x,A,I0)")  "flat dim. = ", object%dim_flat
    end if
    write (u, "(1x,A)")  "Flavor combinations:"
    do i = 1, object%n_state
       write (u, "(3x,I0,':')", advance="no")  i
!       do j = 1, object%n_tot
       do j = 1, n_tot_flv
          write (u, "(1x,A)", advance="no")  char (object%flv(j,i)%get_name ())
       end do
       write (u, "(A)")
    end do
    if (allocated (object%channel)) then
       write (u, "(1x,A)")  "Phase-space / structure-function channels:"
       do i = 1, object%n_channel
          write (u, "(3x,I0,':')", advance="no") i
          call object%channel(i)%write (u)
       end do
    end if
    if (object%md5sum_process /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (process)    = '", &
            object%md5sum_process, "'"
    end if
    if (object%md5sum_model_par /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (model par)  = '", &
            object%md5sum_model_par, "'"
    end if
    if (object%md5sum_phs_config /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (phs config) = '", &
            object%md5sum_phs_config, "'"
    end if
  end subroutine phs_config_write

@ %def phs_config_write
@ Similarly, a basic initializer and an interface.  The model pointer is taken
as an argument; we may verify that this has the expected model name.

The intent is [[inout]].  We want to be able to set parameters in advance.
<<PHS base: phs config: TBP>>=
  procedure :: init => phs_config_init
<<PHS base: procedures>>=
  subroutine phs_config_init (phs_config, data, model)
    class(phs_config_t), intent(inout) :: phs_config
    type(process_constants_t), intent(in) :: data
    class(model_data_t), intent(in), target :: model
    integer :: i, j
    phs_config%id = data%id
    phs_config%n_in  = data%n_in
    phs_config%n_out = data%n_out
    phs_config%n_tot = data%n_in + data%n_out
    phs_config%n_state = data%n_flv
    if (data%model_name == model%get_name ()) then
       phs_config%model => model
    else
       call msg_bug ("phs_config_init: model name mismatch")
    end if
    allocate (phs_config%flv (phs_config%n_tot, phs_config%n_state))    
    do i = 1, phs_config%n_state
       do j = 1, phs_config%n_tot
          call phs_config%flv(j,i)%init (data%flv_state(j,i), &
               phs_config%model)
       end do
    end do
    phs_config%md5sum_process = data%md5sum
  end subroutine phs_config_init
    
@ %def phs_config_init
@ This procedure should complete the phase-space configuration.  We
need the [[sqrts]] value as overall scale, which is known only after
the beams have been defined.  The procedure should determine the number of
channels, their properties (if any), and allocate and fill the [[channel]]
array accordingly.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_configure), deferred :: configure
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_configure (phs_config, sqrts, &
          sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
          nlo_type)
       import
       class(phs_config_t), intent(inout) :: phs_config
       real(default), intent(in) :: sqrts
       logical, intent(in), optional :: sqrts_fixed
       logical, intent(in), optional :: cm_frame
       logical, intent(in), optional :: azimuthal_dependence
       logical, intent(in), optional :: rebuild
       logical, intent(in), optional :: ignore_mismatch
       integer, intent(inout), optional :: nlo_type
     end subroutine phs_config_configure
  end interface

@ %def phs_config_configure
@ Manually assign structure-function channel indices to the phase-space
channel objects.  (Used by a test routine.)
<<PHS base: phs config: TBP>>=
  procedure :: set_sf_channel => phs_config_set_sf_channel
<<PHS base: procedures>>=
  subroutine phs_config_set_sf_channel (phs_config, sf_channel)
    class(phs_config_t), intent(inout) :: phs_config
    integer, dimension(:), intent(in) :: sf_channel
    phs_config%channel%sf_channel = sf_channel
  end subroutine phs_config_set_sf_channel
  
@ %def phs_config_set_sf_channel
@ Collect new channels not yet in the collection from this phase-space
configuration object.  At the same time, assign structure-function channels.
<<PHS base: phs config: TBP>>=
  procedure :: collect_channels => phs_config_collect_channels
<<PHS base: procedures>>=
  subroutine phs_config_collect_channels (phs_config, coll)
    class(phs_config_t), intent(inout) :: phs_config
    type(phs_channel_collection_t), intent(inout) :: coll
    integer :: c
    do c = 1, phs_config%n_channel
       call coll%push (phs_config%channel(c))
    end do
  end subroutine phs_config_collect_channels
    
@ %def phs_config_collect_channels
@ Compute the MD5 sum.  We abuse the [[write]] method.  In
type implementations, [[write]] should only display information that is
relevant for the MD5 sum.  The data include the process MD5 sum which is taken
from the process constants, and the MD5 sum of the model parameters.  This may
change, so it is computed here.
<<PHS base: phs config: TBP>>=
  procedure :: compute_md5sum => phs_config_compute_md5sum
<<PHS base: procedures>>=
  subroutine phs_config_compute_md5sum (phs_config)
    class(phs_config_t), intent(inout) :: phs_config
    integer :: u
    phs_config%md5sum_model_par = phs_config%model%get_parameters_md5sum ()
    phs_config%md5sum_phs_config = ""
    u = free_unit ()
    open (u, status = "scratch", action = "readwrite")
    call phs_config%write (u)
    rewind (u)
    phs_config%md5sum_phs_config = md5sum (u)
    close (u)
  end subroutine phs_config_compute_md5sum
    
@ %def phs_config_compute_md5sum
@ Print an informative message after phase-space configuration.
<<PHS base: phs config: TBP>>=
  procedure (phs_startup_message), deferred :: startup_message
  procedure :: base_startup_message => phs_startup_message
<<PHS base: procedures>>=
  subroutine phs_startup_message (phs_config, unit)
    class(phs_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    write (msg_buffer, "(A,3(1x,I0,1x,A))") &
         "Phase space:", &
         phs_config%n_channel, "channels,", &
         phs_config%n_par, "dimensions"
    call msg_message (unit = unit)
  end subroutine phs_startup_message

@ %def phs_startup_message
@ This procedure should be implemented such that the phase-space
configuration object allocates a phase-space instance of matching type.
<<PHS base: phs config: TBP>>=
  procedure (phs_config_allocate_instance), nopass, deferred :: &
       allocate_instance
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_config_allocate_instance (phs)
       import
       class(phs_t), intent(inout), pointer :: phs
     end subroutine phs_config_allocate_instance
  end interface

@ %def phs_config_allocate_instance
@ 
\subsection{Extract data}
Return the number of MC input parameters.
<<PHS base: phs config: TBP>>=
  procedure :: get_n_par => phs_config_get_n_par
<<PHS base: procedures>>=
  function phs_config_get_n_par (phs_config) result (n)
    class(phs_config_t), intent(in) :: phs_config
    integer :: n
    n = phs_config%n_par
  end function phs_config_get_n_par
  
@ %def phs_config_get_n_par
@ Return dimensions (parameter indices) for which the phase-space
dimension is flat, so integration and event generation can be simplified.
<<PHS base: phs config: TBP>>=
  procedure :: get_flat_dimensions => phs_config_get_flat_dimensions
<<PHS base: procedures>>=
  function phs_config_get_flat_dimensions (phs_config) result (dim_flat)
    class(phs_config_t), intent(in) :: phs_config
    integer, dimension(:), allocatable :: dim_flat
    if (allocated (phs_config%dim_flat)) then
       allocate (dim_flat (size (phs_config%dim_flat)))
       dim_flat = phs_config%dim_flat
    else
       allocate (dim_flat (0))
    end if
  end function phs_config_get_flat_dimensions
  
@ %def phs_config_get_flat_dimensions
@ Return the number of phase-space channels.
<<PHS base: phs config: TBP>>=
  procedure :: get_n_channel => phs_config_get_n_channel
<<PHS base: procedures>>=
  function phs_config_get_n_channel (phs_config) result (n)
    class(phs_config_t), intent(in) :: phs_config
    integer :: n
    n = phs_config%n_channel
  end function phs_config_get_n_channel
  
@ %def phs_config_get_n_channel
@ Return the structure-function channel that corresponds to the
phase-space channel [[c]].  If the channel array is not allocated (which
happens if there is no structure function), return zero.
<<PHS base: phs config: TBP>>=
  procedure :: get_sf_channel => phs_config_get_sf_channel
<<PHS base: procedures>>=
  function phs_config_get_sf_channel (phs_config, c) result (c_sf)
    class(phs_config_t), intent(in) :: phs_config
    integer, intent(in) :: c
    integer :: c_sf
    if (allocated (phs_config%channel)) then
       c_sf = phs_config%channel(c)%sf_channel
    else
       c_sf = 0
    end if
  end function phs_config_get_sf_channel
  
@ %def phs_config_get_sf_channel
@ Return the mass(es) of the incoming particle(s).  We take the first flavor
combination in the array, assuming that masses must be degenerate among
flavors.
<<PHS base: phs config: TBP>>=
  procedure :: get_masses_in => phs_config_get_masses_in
<<PHS base: procedures>>=
  subroutine phs_config_get_masses_in (phs_config, m)
    class(phs_config_t), intent(in) :: phs_config
    real(default), dimension(:), intent(out) :: m
    integer :: i
    do i = 1, phs_config%n_in
       m(i) = phs_config%flv(i,1)%get_mass ()
    end do
  end subroutine phs_config_get_masses_in
  
@ %def phs_config_get_masses_in
@ Return the MD5 sum of the configuration.
<<PHS base: phs config: TBP>>=
  procedure :: get_md5sum => phs_config_get_md5sum
<<PHS base: procedures>>=
  function phs_config_get_md5sum (phs_config) result (md5sum)
    class(phs_config_t), intent(in) :: phs_config
    character(32) :: md5sum
    md5sum = phs_config%md5sum_phs_config
  end function phs_config_get_md5sum
  
@ %def phs_config_get_md5sum
@
\subsection{Phase-space point instance}
The [[phs_t]] object holds the workspace for phase-space generation.
In the base object, we have the MC input parameters [[r]] and the
Jacobian factor [[f]], for each channel, and the incoming and outgoing
momenta.

Note: The [[active_channel]] array is not used yet, all elements are
initialized with [[.true.]].  It should be touched by the integrator if it
decides to drop irrelevant channels.
<<PHS base: public>>=
  public :: phs_t
<<PHS base: types>>=
  type, abstract :: phs_t
     class(phs_config_t), pointer :: config => null ()
     logical :: r_defined = .false.
     integer :: selected_channel = 0
     logical, dimension(:), allocatable :: active_channel
     real(default), dimension(:,:), allocatable :: r
     real(default), dimension(:), allocatable :: f
     real(default), dimension(:), allocatable :: m_in
     real(default), dimension(:), allocatable :: m_out
     real(default) :: flux = 0
     real(default) :: volume = 0
     type(lorentz_transformation_t) :: lt_cm_to_lab
     logical :: p_defined = .false.
     real(default) :: sqrts_hat = 0
     type(vector4_t), dimension(:), allocatable :: p
     logical :: q_defined = .false.
     type(vector4_t), dimension(:), allocatable :: q
   contains
   <<PHS base: phs: TBP>>
  end type phs_t
     
@ %def phs_t
@ Output.  Since phase space may get complicated, we include a
[[verbose]] option for the abstract [[write]] procedure.
<<PHS base: phs: TBP>>=
  procedure (phs_write), deferred :: write
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_write (object, unit, verbose)
       import
       class(phs_t), intent(in) :: object
       integer, intent(in), optional :: unit
       logical, intent(in), optional :: verbose
     end subroutine phs_write
  end interface
  
@ %def phs_write
@ This procedure can be called to print the contents of the base type.
<<PHS base: phs: TBP>>=
  procedure :: base_write => phs_base_write
<<PHS base: procedures>>=
  subroutine phs_base_write (object, unit)
    class(phs_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, c, i
    u = given_output_unit (unit)
    write (u, "(1x,A)", advance="no")  "Partonic phase space: parameters"
    if (object%r_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    write (u, "(3x,A,999(1x," // FMT_19 // "))") "m_in    =", object%m_in
    write (u, "(3x,A,999(1x," // FMT_19 // "))") "m_out   =", object%m_out
    write (u, "(3x,A," // FMT_19 // ")")  "Flux   = ", object%flux
    write (u, "(3x,A," // FMT_19 // ")")  "Volume = ", object%volume
    if (allocated (object%f)) then
       do c = 1, size (object%r, 2)
          write (u, "(1x,A,I0,A)", advance="no")  "Channel #", c, ":"
          if (c == object%selected_channel) then
             write (u, "(1x,A)")  "[selected]"
          else
             write (u, *)
          end if
          write (u, "(3x,A)", advance="no")  "r ="
          do i = 1, size (object%r, 1)
             write (u, "(1x,F9.7)", advance="no")  object%r(i,c)
          end do
          write (u, *)
          write (u, "(3x,A,1x,ES13.7)")  "f =", object%f(c)
       end do
    end if
    write (u, "(1x,A)")  "Partonic phase space: momenta"
    if (object%p_defined) then
       write (u, "(3x,A," // FMT_19 // ")")  "sqrts  = ", object%sqrts_hat
    end if
    write (u, "(1x,A)", advance="no")  "Incoming:"
    if (object%p_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%p)) then
       do i = 1, size (object%p)
          call vector4_write (object%p(i), u)
       end do
    end if
    write (u, "(1x,A)", advance="no")  "Outgoing:"
    if (object%q_defined) then
       write (u, *)
    else
       write (u, "(1x,A)")  "[undefined]"
    end if
    if (allocated (object%q)) then
       do i = 1, size (object%q)
          call vector4_write (object%q(i), u)
       end do
    end if
    if (object%p_defined .and. .not. object%config%cm_frame) then
       write (u, "(1x,A)")  "Transformation c.m -> lab frame"
       call lorentz_transformation_write (object%lt_cm_to_lab, u)
    end if
  end subroutine phs_base_write
          
@ %def phs_base_write
@ Finalizer.  The base type does not need it, but extensions may.
<<PHS base: phs: TBP>>=
  procedure (phs_final), deferred :: final
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_final (object)
       import
       class(phs_t), intent(inout) :: object
     end subroutine phs_final
  end interface
  
@ %def phs_final
@ Initializer.  Everything should be contained in the [[process_data]]
configuration object, so we can require a universal interface.
<<PHS base: phs: TBP>>=
  procedure (phs_init), deferred :: init
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_init (phs, phs_config)
       import
       class(phs_t), intent(out) :: phs
       class(phs_config_t), intent(in), target :: phs_config
     end subroutine phs_init
  end interface
  
@ %def phs_init
@ The base version will just allocate the arrays.  It should be called
at the beginning of the implementation of [[phs_init]].
<<PHS base: phs: TBP>>=
  procedure :: base_init => phs_base_init
<<PHS base: procedures>>=
  subroutine phs_base_init (phs, phs_config)
    class(phs_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    real(default), dimension(phs_config%n_in) :: m_in
    real(default), dimension(phs_config%n_out) :: m_out    
    phs%config => phs_config
    allocate (phs%active_channel (phs%config%n_channel))
    phs%active_channel = .true.    
    allocate (phs%r (phs%config%n_par, phs%config%n_channel));  phs%r = 0
    allocate (phs%f (phs%config%n_channel));                    phs%f = 0
    allocate (phs%p (phs%config%n_in))    
    !!! !!! !!! Workaround for gfortran 5.0 ICE
    m_in  = phs_config%flv(:phs_config%n_in, 1)%get_mass ()
    m_out = phs_config%flv(phs_config%n_in+1:, 1)%get_mass ()
    allocate (phs%m_in  (phs%config%n_in), source = m_in)
    !!! allocate (phs%m_in  (phs%config%n_in), &
    !!!      source = phs_config%flv(:phs_config%n_in, 1)%get_mass ())
    allocate (phs%q (phs%config%n_out))
    allocate (phs%m_out (phs%config%n_out), source = m_out)
    !!! allocate (phs%m_out (phs%config%n_out), &
    !!!      source = phs_config%flv(phs_config%n_in+1:, 1)%get_mass ())    
    call phs%compute_flux ()
  end subroutine phs_base_init
 
@ %def phs_base_init
@ Manually select a channel.
<<PHS base: phs: TBP>>=
  procedure :: select_channel => phs_base_select_channel
<<PHS base: procedures>>=
  subroutine phs_base_select_channel (phs, channel)
    class(phs_t), intent(inout) :: phs
    integer, intent(in), optional :: channel
    if (present (channel)) then
       phs%selected_channel = channel
    else
       phs%selected_channel = 0
    end if
  end subroutine phs_base_select_channel
  
@ %def phs_base_select_channel
@ Set incoming momenta.  Assume that array shapes match.  If
requested, compute the Lorentz transformation from the c.m.\ to the
lab frame and apply that transformation to the incoming momenta.

In the c.m.\ frame, the sum of three-momenta is zero.  In a scattering
process, the $z$ axis is the direction of the first beam, the second
beam is along the negative $z$ axis.  The transformation from the
c.m.\ to the lab frame is a rotation from the $z$ axis to the boost
axis followed by a boost, such that the c.m.\ momenta are transformed
into the lab-frame momenta.  In a decay process, we just boost along
the flight direction, without rotation.
<<PHS base: phs: TBP>>=
  procedure :: set_incoming_momenta => phs_set_incoming_momenta
<<PHS base: procedures>>=
  subroutine phs_set_incoming_momenta (phs, p)
    class(phs_t), intent(inout) :: phs
    type(vector4_t), dimension(:), intent(in) :: p
    type(vector4_t) :: p0, p1
    type(lorentz_transformation_t) :: lt0, lt0_inv, lt_inv
    !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
    integer :: i
    phs%p = p
    if (phs%config%cm_frame) then
       phs%sqrts_hat = phs%config%sqrts
       phs%p = p
    else
       p0 = sum (p)
       if (phs%config%sqrts_fixed) then
          phs%sqrts_hat = phs%config%sqrts
       else
          phs%sqrts_hat = p0 ** 1
       end if
       lt0 = boost (p0, phs%sqrts_hat)
       select case (phs%config%n_in)
       case (1)
          phs%lt_cm_to_lab = lt0
       case (2)
          !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
          lt0_inv = inverse (lt0)
          p1 = lt0_inv * p(1)
          !!! p1 = inverse (lt0) * p(1)
          phs%lt_cm_to_lab = lt0 * rotation_to_2nd (3, space_part (p1))
       end select
       !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
       lt_inv = inverse (phs%lt_cm_to_lab)
       do i = 1, size (p)
          phs%p(i) = lt_inv * p(i)
       end do
       !!! phs%p = inverse (phs%lt_cm_to_lab) * p       
    end if
    phs%p_defined = .true.
  end subroutine phs_set_incoming_momenta
  
@ %def phs_set_incoming_momenta
@ Set outgoing momenta.  Assume that array shapes match.  The incoming
momenta must be known, so can apply the Lorentz transformation from
c.m.\ to lab (inverse) to the momenta.
<<PHS base: phs: TBP>>=
  procedure :: set_outgoing_momenta => phs_set_outgoing_momenta
<<PHS base: procedures>>=
  subroutine phs_set_outgoing_momenta (phs, q)
    class(phs_t), intent(inout) :: phs
    type(vector4_t), dimension(:), intent(in) :: q
    !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
    type(lorentz_transformation_t) :: l_inv
    integer :: i
    if (phs%p_defined) then
       if (phs%config%cm_frame) then
          phs%q = q
       else
          l_inv = inverse (phs%lt_cm_to_lab)
          do i = 1, size (q)
             phs%q(i) = l_inv * q(i)
          end do
          !!! phs%q = inverse (phs%lt_cm_to_lab) * q
       end if
       phs%q_defined = .true.
    end if
  end subroutine phs_set_outgoing_momenta
  
@ %def phs_set_outgoing_momenta
@ Return outgoing momenta.  Apply the c.m.\ to lab transformation if
necessary.
<<PHS base: phs: TBP>>=
  procedure :: get_outgoing_momenta => phs_get_outgoing_momenta
<<PHS base: procedures>>=
  subroutine phs_get_outgoing_momenta (phs, q)
    class(phs_t), intent(in) :: phs
    type(vector4_t), dimension(:), intent(out) :: q
    if (phs%p_defined .and. phs%q_defined) then
       if (phs%config%cm_frame) then
          q = phs%q
       else
          q = phs%lt_cm_to_lab * phs%q
       end if
    else
       q = vector4_null
    end if
  end subroutine phs_get_outgoing_momenta
  
@ %def phs_get_outgoing_momenta
@
<<PHS base: phs: TBP>>=
  procedure :: is_cm_frame => phs_is_cm_frame
<<PHS base: procedures>>=
  function phs_is_cm_frame (phs) result (cm_frame)
    logical :: cm_frame
    class(phs_t), intent(in) :: phs
    cm_frame = phs%config%cm_frame
  end function phs_is_cm_frame

@ %def phs_is_cm_frame
@
<<PHS base: phs: TBP>>=
  procedure :: get_lorentz_transformation => phs_get_lorentz_transformation
<<PHS base: procedures>>=
  function phs_get_lorentz_transformation (phs) result (lt)
    type(lorentz_transformation_t) :: lt
    class(phs_t), intent(in) :: phs
    lt = phs%lt_cm_to_lab
  end function phs_get_lorentz_transformation

@ %def phs_get_lorentz_transformation
@ Return the input parameter array for a channel.
<<PHS base: phs: TBP>>=
  procedure :: get_mcpar => phs_get_mcpar
<<PHS base: procedures>>=
  subroutine phs_get_mcpar (phs, c, r)
    class(phs_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default), dimension(:), intent(out) :: r
    if (phs%r_defined) then
       r = phs%r(:,c)
    else
       r = 0
    end if
  end subroutine phs_get_mcpar
  
@ %def phs_get_mcpar
@ Return the Jacobian factor for a channel.
<<PHS base: phs: TBP>>=
  procedure :: get_f => phs_get_f
<<PHS base: procedures>>=
  function phs_get_f (phs, c) result (f)
    class(phs_t), intent(in) :: phs
    integer, intent(in) :: c
    real(default) :: f
    if (phs%r_defined) then
       f = phs%f(c)
    else
       f = 0
    end if
  end function phs_get_f
    
@ %def phs_get_f
@ Return the overall factor, which is the product of the flux factor for the
incoming partons and the phase-space volume for the outgoing partons.
<<PHS base: phs: TBP>>=
  procedure :: get_overall_factor => phs_get_overall_factor
<<PHS base: procedures>>=
  function phs_get_overall_factor (phs) result (f)
    class(phs_t), intent(in) :: phs
    real(default) :: f
    f = phs%flux * phs%volume
  end function phs_get_overall_factor
  
@ %def phs_get_overall_factor
@ Compute flux factor.  We do this during initialization (when the
incoming momenta [[p]] are undefined), unless [[sqrts]] is variable.  We do
this again once for each phase-space point, but then we skip the calculation
if [[sqrts]] is fixed.

There are three different flux factors.
\begin{enumerate}
\item
  For a decaying massive particle, the factor is
  \begin{equation}
    f = (2\pi)^4 / (2M)
  \end{equation}
\item
  For a $2\to n$ scattering process with $n>1$, the factor is
  \begin{equation}
    f = (2\pi)^4 / (2\sqrt{\lambda})
  \end{equation}
  where for massless incoming particles, $\sqrt{\lambda} = s$.
\item For a $2\to 1$ on-shell production process, the factor includes
  an extra $1/(2\pi)^3$ factor and a $1/m^2$ factor from the
  phase-space delta function $\delta (x_1x_2 - m^2/s)$, which
  originate from the one-particle phase space that we integrate out.
  \begin{equation}
    f = 2\pi / (2s m^2)
  \end{equation}
  The delta function is handled by the structure-function
  parameterization.
\end{enumerate}
<<PHS base: phs: TBP>>=
  procedure :: compute_flux => phs_compute_flux
<<PHS base: procedures>>=
  subroutine phs_compute_flux (phs)
    class(phs_t), intent(inout) :: phs
    real(default) :: s_hat, lda
    select case (phs%config%n_in)
    case (1)
       if (.not. phs%p_defined) then
          phs%flux = twopi4 / (2 * phs%m_in(1))
       end if
    case (2)
       if (phs%p_defined) then
          if (phs%config%sqrts_fixed) then
             return
          else
             s_hat = sum (phs%p) ** 2
          end if
       else
          if (phs%config%sqrts_fixed) then
             s_hat = phs%config%sqrts ** 2
          else
             return
          end if
       end if
       select case (phs%config%n_out)
       case (2:)
          lda = lambda (s_hat, phs%m_in(1) ** 2, phs%m_in(2) ** 2)
          if (lda > 0) then
             phs%flux = conv * twopi4 / (2 * sqrt (lda))
          else
             phs%flux = 0
          end if
       case (1)
          phs%flux = conv * twopi &
               / (2 * phs%config%sqrts ** 2 * phs%m_out(1) ** 2)
       case default
          phs%flux = 0
       end select
    end select
  end subroutine phs_compute_flux

@ %def phs_compute_flux
@ Evaluate the phase-space point for a particular channel and compute momenta,
Jacobian, and phase-space volume. This is, of course, deferred to
the implementation.
<<PHS base: phs: TBP>>=
  procedure (phs_evaluate_selected_channel), deferred :: &
       evaluate_selected_channel
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_evaluate_selected_channel (phs, c_in, r_in)
       import
       class(phs_t), intent(inout) :: phs
       integer, intent(in) :: c_in
       real(default), dimension(:), intent(in) :: r_in
     end subroutine phs_evaluate_selected_channel
  end interface
  
@ %def phs_evaluate_selected_channel
@ Compute the inverse mappings to completely fill the [[r]] and [[f]] arrays,
for the non-selected channels.
<<PHS base: phs: TBP>>=
  procedure (phs_evaluate_other_channels), deferred :: &
       evaluate_other_channels
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_evaluate_other_channels (phs, c_in)
       import
       class(phs_t), intent(inout) :: phs
       integer, intent(in) :: c_in
     end subroutine phs_evaluate_other_channels
  end interface
  
@ %def phs_evaluate_other_channels
@ Inverse evaluation.  If all momenta are known, we compute the
inverse mappings to fill the [[r]] and [[f]] arrays.
<<PHS base: phs: TBP>>=
  procedure (phs_inverse), deferred :: inverse
<<PHS base: interfaces>>=
  abstract interface
     subroutine phs_inverse (phs)
       import
       class(phs_t), intent(inout) :: phs
     end subroutine phs_inverse
  end interface
  
@ %def phs_inverse
@ 
\subsubsection{Uniform angular distribution}
These procedures implement the uniform angular distribution, generated
from two parameters $x_1$ and $x_2$:
\begin{equation}
  \cos\theta = 1 - 2x_1, \qquad \phi = 2\pi x_2
\end{equation}
We generate a rotation (Lorentz transformation) which rotates the
positive $z$ axis into this point on the unit sphere.  This rotation
is applied to the [[p]] momenta, which are assumed to be
back-to-back, on-shell, and with the correct mass.

We do not compute a Jacobian (constant).  The uniform distribution is
assumed to be normalized.
<<PHS base: public>>=
  public :: compute_kinematics_solid_angle
<<PHS base: procedures>>=
  subroutine compute_kinematics_solid_angle (p, q, x)
    type(vector4_t), dimension(2), intent(in) :: p
    type(vector4_t), dimension(2), intent(out) :: q
    real(default), dimension(2), intent(in) :: x
    real(default) :: ct, st, phi
    type(lorentz_transformation_t) :: rot
    integer :: i
    ct = 1 - 2*x(1)
    st = sqrt (1 - ct**2)
    phi = twopi * x(2)
    rot = rotation (phi, 3) * rotation (ct, st, 2)
    do i = 1, 2
       q(i) = rot * p(i)
    end do
  end subroutine compute_kinematics_solid_angle
  
@ %def compute_kinematics_solid_angle
@ This is the inverse transformation.  We assume that the outgoing
momenta are rotated versions of the incoming momenta, back-to-back.
Thus, we determine the angles from $q(1)$ alone.  [[p]] is unused.
<<PHS base: public>>=
  public :: inverse_kinematics_solid_angle
<<PHS base: procedures>>=
  subroutine inverse_kinematics_solid_angle (p, q, x)
    type(vector4_t), dimension(:), intent(in) :: p
    type(vector4_t), dimension(2), intent(in) :: q
    real(default), dimension(2), intent(out) :: x
    real(default) :: ct, phi
    ct = polar_angle_ct (q(1))
    phi = azimuthal_angle (q(1))
    x(1) = (1 - ct) / 2
    x(2) = phi / twopi
  end subroutine inverse_kinematics_solid_angle

@ %def inverse_kinematics_solid_angle
@
\subsection{Auxiliary stuff}
The [[pacify]] subroutine, which is provided by the Lorentz module,
has the purpose of setting numbers to zero which are (by comparing
with a [[tolerance]] parameter) considered equivalent with zero.  This
is useful for numerical checks.
<<PHS base: public>>=
  public :: pacify
<<PHS base: interfaces>>=
  interface pacify
     module procedure pacify_phs
  end interface pacify
  
<<PHS base: procedures>>=
  subroutine pacify_phs (phs)
    class(phs_t), intent(inout) :: phs
    if (phs%p_defined) then
       call pacify (phs%p, 30 * epsilon (1._default) * phs%config%sqrts)
       call pacify (phs%lt_cm_to_lab, 30 * epsilon (1._default))
    end if
    if (phs%q_defined) then
       call pacify (phs%q, 30 * epsilon (1._default) * phs%config%sqrts)
    end if
  end subroutine pacify_phs
    
@ %def pacify
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[phs_base_ut.f90]]>>=
<<File header>>

module phs_base_ut
  use unit_tests
  use phs_base_uti
  
<<Standard module head>>

<<PHS base: public test>>

<<PHS base: public test auxiliary>>

contains
  
<<PHS base: test driver>>

end module phs_base_ut
@ %def phs_base_ut
@
<<[[phs_base_uti.f90]]>>=
<<File header>>

module phs_base_uti

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use io_units
  use format_defs, only: FMT_19
  use physics_defs, only: BORN
  use lorentz
  use flavors
  use model_data
  use process_constants

  use phs_base

<<Standard module head>>

<<PHS base: public test auxiliary>>

<<PHS base: test declarations>>

<<PHS base: test types>>

contains

<<PHS base: tests>>

<<PHS base: test auxiliary>>

end module phs_base_uti
@ %def phs_base_ut
@ API: driver for the unit tests below.
<<PHS base: public test>>=
  public :: phs_base_test
<<PHS base: test driver>>=
  subroutine phs_base_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS base: execute tests>>
  end subroutine phs_base_test
  
@ %def phs_base_test
@
\subsubsection{Test process data}
We provide a procedure that initializes a test case for the process
constants.  This set of process data contains just the minimal
contents that we need for the phase space.  The rest is left
uninitialized.
<<PHS base: public test auxiliary>>=
  public :: init_test_process_data
<<PHS base: test auxiliary>>=
  subroutine init_test_process_data (id, data)
    type(process_constants_t), intent(out) :: data 
    type(string_t), intent(in), optional :: id
    if (present (id)) then
       data%id = id
    else
       data%id = "testproc"
    end if
    data%model_name = "Test"
    data%n_in = 2
    data%n_out = 2
    data%n_flv = 1
    allocate (data%flv_state (data%n_in + data%n_out, data%n_flv))
    data%flv_state = 25
  end subroutine init_test_process_data

@ %def init_test_process_data
@ This is the variant for a decay process.
<<PHS base: public test auxiliary>>=
  public :: init_test_decay_data
<<PHS base: test auxiliary>>=
  subroutine init_test_decay_data (id, data)
    type(process_constants_t), intent(out) :: data 
    type(string_t), intent(in), optional :: id
    if (present (id)) then
       data%id = id
    else
       data%id = "testproc"
    end if
    data%model_name = "Test"
    data%n_in = 1
    data%n_out = 2
    data%n_flv = 1
    allocate (data%flv_state (data%n_in + data%n_out, data%n_flv))
    data%flv_state(:,1) = [25, 6, -6]
  end subroutine init_test_decay_data

@ %def init_test_decay_data
@
\subsubsection{Test kinematics configuration}
This is a trivial implementation of the [[phs_config_t]] configuration object.
<<PHS base: public test auxiliary>>=
  public :: phs_test_config_t
<<PHS base: test types>>=
  type, extends (phs_config_t) :: phs_test_config_t
     logical :: create_equivalences = .false.
   contains
     procedure :: final => phs_test_config_final
     procedure :: write => phs_test_config_write
     procedure :: configure => phs_test_config_configure
     procedure :: startup_message => phs_test_config_startup_message
     procedure, nopass :: allocate_instance => phs_test_config_allocate_instance
  end type phs_test_config_t

@ %def phs_test_config_t
@ The finalizer is empty.
<<PHS base: test auxiliary>>=
  subroutine phs_test_config_final (object)
    class(phs_test_config_t), intent(inout) :: object
  end subroutine phs_test_config_final

@ %def phs_test_config_final
@ The [[cm_frame]] parameter is not tested here; we defer this to the
[[phs_single]] implementation.
<<PHS base: test auxiliary>>=
  subroutine phs_test_config_write (object, unit)
    class(phs_test_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Partonic phase-space configuration:"
    call object%base_write (unit)
  end subroutine phs_test_config_write
  
  subroutine phs_test_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_test_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    integer, intent(inout), optional :: nlo_type
    phs_config%n_channel = 2
    phs_config%n_par = 2
    phs_config%sqrts = sqrts
    if (.not. present (nlo_type)) &
      phs_config%nlo_type = BORN
    if (present (sqrts_fixed)) then
       phs_config%sqrts_fixed = sqrts_fixed
    end if
    if (present (cm_frame)) then
       phs_config%cm_frame = cm_frame
    end if
    if (present (azimuthal_dependence)) then
       phs_config%azimuthal_dependence = azimuthal_dependence
    end if
    if (allocated (phs_config%channel))  deallocate (phs_config%channel)
    allocate (phs_config%channel (phs_config%n_channel))
    if (phs_config%create_equivalences) then
       call setup_test_equivalences (phs_config)
       call setup_test_channel_props (phs_config)
    end if
    call phs_config%compute_md5sum ()
  end subroutine phs_test_config_configure

@ %def phs_test_config_write
@ %def phs_test_config_configure
@ If requested, we make up an arbitrary set of equivalences.
<<PHS base: test auxiliary>>=
  subroutine setup_test_equivalences (phs_config)
    class(phs_test_config_t), intent(inout) :: phs_config
    integer :: i
    associate (channel => phs_config%channel(1))
      allocate (channel%eq (2))
      do i = 1, size (channel%eq)
         call channel%eq(i)%init (phs_config%n_par)
      end do
      associate (eq => channel%eq(1))
        eq%c = 1;  eq%perm = [1, 2];  eq%mode = [EQ_IDENTITY, EQ_SYMMETRIC]
      end associate
      associate (eq => channel%eq(2))
        eq%c = 2;  eq%perm = [2, 1];  eq%mode = [EQ_INVARIANT, EQ_IDENTITY]
      end associate
    end associate
  end subroutine setup_test_equivalences
      
@ %def setup_test_equivalences
@ Ditto, for channel properties.
<<PHS base: test auxiliary>>=
  subroutine setup_test_channel_props (phs_config)
    class(phs_test_config_t), intent(inout) :: phs_config
    associate (channel => phs_config%channel(2))
      call channel%set_resonant (140._default, 3.1415_default)
    end associate
  end subroutine setup_test_channel_props
      
@ %def setup_test_channel_props
@ Startup message
<<PHS base: test auxiliary>>=
  subroutine phs_test_config_startup_message (phs_config, unit)
    class(phs_test_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%base_startup_message (unit)
    write (msg_buffer, "(A)") "Phase space: Test"
    call msg_message (unit = unit)
  end subroutine phs_test_config_startup_message
  
@ %def phs_test_config_startup_message
@ The instance type that matches [[phs_test_config_t]] is [[phs_test_t]].
<<PHS base: test auxiliary>>=
  subroutine phs_test_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_test_t :: phs)
  end subroutine phs_test_config_allocate_instance
  
@ %def phs_test_config_allocate_instance
@
\subsubsection{Test kinematics implementation}
This implementation of kinematics generates a simple two-particle
configuration from the incoming momenta.  The incoming momenta must be
in the c.m.\ system, all masses equal.

There are two channels: one generates $\cos\theta$ and $\phi$
uniformly, in the other channel we map the $r_1$ parameter which
belongs to $\cos\theta$.

We should store the mass parameter that we need.
<<PHS base: public test auxiliary>>=
  public :: phs_test_t
<<PHS base: test types>>=
  type, extends (phs_t) :: phs_test_t
     real(default) :: m = 0
     real(default), dimension(:), allocatable :: x
   contains
   <<PHS base: phs test: TBP>>
  end type phs_test_t
  
@ %def phs_test_t
@ Output.  The specific data are displayed only if [[verbose]] is set.
<<PHS base: phs test: TBP>>=
  procedure :: write => phs_test_write
<<PHS base: test auxiliary>>=
  subroutine phs_test_write (object, unit, verbose)
    class(phs_test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    logical :: verb
    u = given_output_unit (unit)
    verb = .false.;  if (present (verbose))  verb = verbose
    if (verb) then
       write (u, "(1x,A)")  "Partonic phase space: data"
       write (u, "(3x,A," // FMT_19 // ")")  "m = ", object%m
    end if
    call object%base_write (u)
  end subroutine phs_test_write
    
@ %def phs_test_write
@ The finalizer is empty.
<<PHS base: phs test: TBP>>=
  procedure :: final => phs_test_final
<<PHS base: test auxiliary>>=
  subroutine phs_test_final (object)
    class(phs_test_t), intent(inout) :: object
  end subroutine phs_test_final
  
@ %def phs_test_final
@ Initialization: set the mass value.
<<PHS base: phs test: TBP>>=
  procedure :: init => phs_test_init
<<PHS base: test auxiliary>>=
  subroutine phs_test_init (phs, phs_config)
    class(phs_test_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    phs%m = phs%config%flv(1,1)%get_mass ()
    allocate (phs%x (phs_config%n_par), source = 0._default)
  end subroutine phs_test_init
  
@ %def phs_test_init
@ Evaluation.  In channel 1, we uniformly generate $\cos\theta$ and
$\phi$, with Jacobian normalized to one.  In channel 2, we prepend a
mapping $r_1 \to r_1^(1/3)$ with Jacobian $f=3r_1^2$.

The component [[x]] is allocated in the first subroutine, used and deallocated
in the second one.
<<PHS base: phs test: TBP>>=
  procedure :: evaluate_selected_channel => phs_test_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_test_evaluate_other_channels
<<PHS base: test auxiliary>>=
  subroutine phs_test_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_test_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    if (phs%p_defined) then
       call phs%select_channel (c_in)
       phs%r(:,c_in) = r_in
       select case (c_in)
       case (1)
          phs%x = r_in
       case (2)
          phs%x(1) = r_in(1) ** (1 / 3._default)
          phs%x(2) = r_in(2)
       end select
       call compute_kinematics_solid_angle (phs%p, phs%q, phs%x) 
       phs%volume = 1
       phs%q_defined = .true.
    end if
  end subroutine phs_test_evaluate_selected_channel
  
  subroutine phs_test_evaluate_other_channels (phs, c_in)
    class(phs_test_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    integer :: c, n_channel
    if (phs%p_defined) then
       n_channel = phs%config%n_channel
       do c = 1, n_channel
          if (c /= c_in) then
             call inverse_kinematics_solid_angle (phs%p, phs%q, phs%x)
             select case (c)
             case (1)
                phs%r(:,c) = phs%x
             case (2)
                phs%r(1,c) = phs%x(1) ** 3
                phs%r(2,c) = phs%x(2)
             end select
          end if
       end do
       phs%f(1) = 1
       if (phs%r(1,2) /= 0) then
          phs%f(2) = 1 / (3 * phs%r(1,2) ** (2/3._default))
       else
          phs%f(2) = 0
       end if
       phs%r_defined = .true.
    end if
  end subroutine phs_test_evaluate_other_channels
  
@ %def phs_test_evaluate_selected_channels
@ %def phs_test_evaluate_other_channels
@ Inverse evaluation.
<<PHS base: phs test: TBP>>=
  procedure :: inverse => phs_test_inverse
<<PHS base: test auxiliary>>=
  subroutine phs_test_inverse (phs)
    class(phs_test_t), intent(inout) :: phs
    integer :: c, n_channel
    real(default), dimension(:), allocatable :: x
    if (phs%p_defined .and. phs%q_defined) then
       call phs%select_channel ()
       n_channel = phs%config%n_channel
       allocate (x (phs%config%n_par))
       do c = 1, n_channel
          call inverse_kinematics_solid_angle (phs%p, phs%q, x)
          select case (c)
          case (1)
             phs%r(:,c) = x
          case (2)
             phs%r(1,c) = x(1) ** 3
             phs%r(2,c) = x(2)
          end select
       end do
       phs%f(1) = 1
       if (phs%r(1,2) /= 0) then
          phs%f(2) = 1 / (3 * phs%r(1,2) ** (2/3._default))
       else
          phs%f(2) = 0
       end if
       phs%volume = 1
       phs%r_defined = .true.
    end if
  end subroutine phs_test_inverse
  
@ %def phs_test_inverse
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.
<<PHS base: execute tests>>=
  call test (phs_base_1, "phs_base_1", &
       "phase-space configuration", &
       u, results)
<<PHS base: test declarations>>=
  public :: phs_base_1
<<PHS base: tests>>=
  subroutine phs_base_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &test phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_1"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
       
    call phs_data%write (u)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_1"

  end subroutine phs_base_1

@ %def phs_base_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS base: execute tests>>=
  call test (phs_base_2, "phs_base_2", &
       "phase-space evaluation", &
       u, results)
<<PHS base: test declarations>>=
  public :: phs_base_2
<<PHS base: tests>>=
  subroutine phs_base_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    
    write (u, "(A)")  "* Test output: phs_base_2"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flv%init (25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_2"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    select type (phs)
    type is (phs_test_t)
       call phs%init (phs_data)
    end select
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flv%get_mass ()**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flv%get_mass ()**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point in channel 1 &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point in channel 2 &
         &for x = 0.125, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (2, [0.125_default, 0.125_default])
    call phs%evaluate_other_channels (2)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    select type (phs_data)
    type is (phs_test_config_t)
       call phs_data%configure (sqrts)
    end select

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_2"

  end subroutine phs_base_2

@ %def phs_base_2
@
\subsubsection{Phase-space equivalences}
Construct a test phase-space configuration which contains channel
equivalences.
<<PHS base: execute tests>>=
  call test (phs_base_3, "phs_base_3", &
       "channel equivalences", &
       u, results)
<<PHS base: test declarations>>=
  public :: phs_base_3
<<PHS base: tests>>=
  subroutine phs_base_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_3"
    write (u, "(A)")  "*   Purpose: construct phase-space configuration data &
         &with equivalences"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_3"), process_data)

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_test_config_t)
       phs_data%create_equivalences = .true.
    end select
       
    call phs_data%configure (1000._default)
    call phs_data%write (u)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_3"

  end subroutine phs_base_3

@ %def phs_base_3
@
\subsubsection{MD5 sum checks}
Construct a test phase-space configuration, compute and compare MD5 sums.
<<PHS base: execute tests>>=
  call test (phs_base_4, "phs_base_4", &
       "MD5 sum", &
       u, results)
<<PHS base: test declarations>>=
  public :: phs_base_4
<<PHS base: tests>>=
  subroutine phs_base_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    
    write (u, "(A)")  "* Test output: phs_base_4"
    write (u, "(A)")  "*   Purpose: compute and compare MD5 sums"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Model parameters"
    write (u, "(A)")

    call model%write (unit = u, &
         show_parameters = .true., &
         show_particles = .false., show_vertices = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_base_4"), process_data)
    process_data%md5sum = "test_process_data_m6sum_12345678"

    allocate (phs_test_config_t :: phs_data)
    call phs_data%init (process_data, model)
    
    call phs_data%compute_md5sum ()
    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Modify model parameter"
    write (u, "(A)")

    call model%set_par (var_str ("ms"), 100._default)
    call model%write (show_parameters = .true., &
         show_particles = .false., show_vertices = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* PHS configuration"
    write (u, "(A)")

    call phs_data%compute_md5sum ()
    call phs_data%write (u)

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_4"

  end subroutine phs_base_4

@ %def phs_base_4
@
\subsubsection{Phase-space channel collection}
Set up an array of various phase-space channels and collect them in a list.
<<PHS base: execute tests>>=
  call test (phs_base_5, "phs_base_5", &
       "channel collection", &
       u, results)
<<PHS base: test declarations>>=
  public :: phs_base_5
<<PHS base: tests>>=
  subroutine phs_base_5 (u)
    integer, intent(in) :: u
    type(phs_channel_t), dimension(:), allocatable :: channel
    type(phs_channel_collection_t) :: coll
    integer :: i, n
    
    write (u, "(A)")  "* Test output: phs_base_5"
    write (u, "(A)")  "*   Purpose: collect channel properties"
    write (u, "(A)")
    
    write (u, "(A)")  "* Set up an array of channels"
    write (u, "(A)")

    n = 6

    allocate (channel (n))
    call channel(2)%set_resonant (75._default, 3._default)
    call channel(4)%set_resonant (130._default, 1._default)
    call channel(5)%set_resonant (75._default, 3._default)
    call channel(6)%set_on_shell (33._default)

    do i = 1, n
       write (u, "(1x,I0)", advance="no")  i
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Collect distinct properties"
    write (u, "(A)")
    
    do i = 1, n
       call coll%push (channel(i))
    end do

    write (u, "(1x,A,I0)")  "n = ", coll%get_n ()
    write (u, "(A)")

    call coll%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Channel array with collection index assigned"
    write (u, "(A)")

    do i = 1, n
       write (u, "(1x,I0)", advance="no")  i
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call coll%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_base_5"

  end subroutine phs_base_5

@ %def phs_base_5
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Single-particle phase space}

This module implements the phase space for a single particle, i.e., the solid
angle, in a straightforward parameterization with a single channel.  The
phase-space implementation may be used either for $1\to 2$ decays or for $2\to
2$ scattering processes, so the number of incoming particles is the only free
parameter in the configuration.  In the latter case, we should restrict its
use to non-resonant s-channel processes, because there is no mapping of the
scattering angle.

(We might extend this later to account for generic $2\to 2$ situations, e.g.,
account for a Coulomb singularity or detect an s-channel resonance structure
that requires matching structure-function mappings.)

This is derived from the [[phs_test]] implementation in the
[[phs_base]] module above, even more simplified, but intended for
actual use.
<<[[phs_single.f90]]>>=
<<File header>>

module phs_single

<<Use kinds>>
  use io_units
  use constants
  use unit_tests
  use diagnostics
  use os_interface
  use lorentz
  use physics_defs
  use model_data
  use flavors
  use process_constants
  use sf_mappings
  use sf_base
  use phs_base
  
<<Standard module head>>

<<PHS single: public>>

<<PHS single: types>>

contains

<<PHS single: procedures>>

end module phs_single
@ %def phs_single
@
\subsection{Configuration}
<<PHS single: public>>=
  public :: phs_single_config_t
<<PHS single: types>>=
  type, extends (phs_config_t) :: phs_single_config_t  
   contains
   <<PHS single: phs single config: TBP>>
  end type phs_single_config_t

@ %def phs_single_config_t
@ The finalizer is empty.
<<PHS single: phs single config: TBP>>=
  procedure :: final => phs_single_config_final
<<PHS single: procedures>>=
  subroutine phs_single_config_final (object)
    class(phs_single_config_t), intent(inout) :: object
  end subroutine phs_single_config_final

@ %def phs_single_final
@ Output.
<<PHS single: phs single config: TBP>>=
  procedure :: write => phs_single_config_write
<<PHS single: procedures>>=
  subroutine phs_single_config_write (object, unit)
    class(phs_single_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Partonic phase-space configuration (single-particle):"
    call object%base_write (unit)
  end subroutine phs_single_config_write
  
@ %def phs_single_config_write
@ Configuration: there is only one channel and two parameters.  The
second parameter is the azimuthal angle, which may be a flat dimension.
<<PHS single: phs single config: TBP>>=
  procedure :: configure => phs_single_config_configure
<<PHS single: procedures>>=
  subroutine phs_single_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_single_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    integer, intent(inout), optional :: nlo_type
    if (.not. present (nlo_type)) &
      phs_config%nlo_type = BORN
    if (phs_config%n_out == 2) then
       phs_config%n_channel = 1
       phs_config%n_par = 2
       phs_config%sqrts = sqrts
       if (present (sqrts_fixed))  phs_config%sqrts_fixed = sqrts_fixed
       if (present (cm_frame))  phs_config%cm_frame = cm_frame
       if (present (azimuthal_dependence)) then
          phs_config%azimuthal_dependence = azimuthal_dependence
          if (.not. azimuthal_dependence) then
             allocate (phs_config%dim_flat (1))
             phs_config%dim_flat(1) = 2
          end if
       end if
       if (allocated (phs_config%channel))  deallocate (phs_config%channel)
       allocate (phs_config%channel (1))
       call phs_config%compute_md5sum ()
    else
       call msg_fatal ("Single-particle phase space requires n_out = 2")
    end if
  end subroutine phs_single_config_configure
  
@ %def phs_single_config_configure
@ Startup message, after configuration is complete.
<<PHS single: phs single config: TBP>>=
  procedure :: startup_message => phs_single_config_startup_message
<<PHS single: procedures>>=
  subroutine phs_single_config_startup_message (phs_config, unit)
    class(phs_single_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    call phs_config%base_startup_message (unit)
    write (msg_buffer, "(A,2(1x,I0,1x,A))") &
         "Phase space: single-particle"
    call msg_message (unit = unit)
  end subroutine phs_single_config_startup_message
    
@ %def phs_single_config_startup_message
@ Allocate an instance: the actual phase-space object.
<<PHS single: phs single config: TBP>>=
  procedure, nopass :: allocate_instance => phs_single_config_allocate_instance
<<PHS single: procedures>>=
  subroutine phs_single_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_single_t :: phs)
  end subroutine phs_single_config_allocate_instance
  
@ %def phs_single_config_allocate_instance
@
\subsection{Kinematics implementation}
We generate $\cos\theta$ and $\phi$ uniformly, covering the solid angle.

Note: The incoming momenta must be in the c.m. system.
<<PHS single: public>>=
  public :: phs_single_t
<<PHS single: types>>=
  type, extends (phs_t) :: phs_single_t
   contains
   <<PHS single: phs single: TBP>>
  end type phs_single_t
  
@ %def phs_single_t
@ Output.  The [[verbose]] setting is irrelevant, we just display the contents
of the base object.
<<PHS single: phs single: TBP>>=
  procedure :: write => phs_single_write
<<PHS single: procedures>>=
  subroutine phs_single_write (object, unit, verbose)
    class(phs_single_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
  end subroutine phs_single_write
    
@ %def phs_single_write
@ The finalizer is empty.
<<PHS single: phs single: TBP>>=
  procedure :: final => phs_single_final
<<PHS single: procedures>>=
  subroutine phs_single_final (object)
    class(phs_single_t), intent(inout) :: object
  end subroutine phs_single_final
  
@ %def phs_single_final
@ Initialization.  We allocate arrays ([[base_init]]) and adjust the
phase-space volume.  The massless two-particle phase space volume is
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.55294034614 \times 10^{-5}
\end{equation}
For a decay with nonvanishing masses ($m_3$, $m_4$), there is a correction
factor 
\begin{equation}
  \Phi_2(m) / \Phi_2(0) = \frac{1}{\hat s}
  \lambda^{1/2}(\hat s, m_3^2, m_4^2).
\end{equation}
For a scattering process with nonvanishing masses, the correction
factor is
\begin{equation}
  \Phi_2(m) / \Phi_2(0) = \frac{1}{\hat s ^ 2}
  \lambda^{1/2}(\hat s, m_1^2, m_2^2)\,
  \lambda^{1/2}(\hat s, m_3^2, m_4^2).
\end{equation}
If the energy is fixed, this is constant.  Otherwise, we have to account for
varying $\hat s$.
<<PHS single: phs single: TBP>>=
  procedure :: init => phs_single_init
<<PHS single: procedures>>=
  subroutine phs_single_init (phs, phs_config)
    class(phs_single_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    phs%volume = 1 / (4 * twopi5)
    call phs%compute_factor ()
  end subroutine phs_single_init
  
@ %def phs_single_init
@ Compute the correction factor for nonzero masses.  We do this during
initialization (when the incoming momenta [[p]] are undefined), unless
[[sqrts]] is variable.  We do this again once for each phase-space point, but
then we skip the calculation if [[sqrts]] is fixed.
<<PHS single: phs single: TBP>>=
  procedure :: compute_factor => phs_single_compute_factor
<<PHS single: procedures>>=
  subroutine phs_single_compute_factor (phs)
    class(phs_single_t), intent(inout) :: phs
    real(default) :: s_hat
    select case (phs%config%n_in)
    case (1)
       if (.not. phs%p_defined) then
          if (sum (phs%m_out) < phs%m_in(1)) then
             s_hat = phs%m_in(1) ** 2
             phs%f(1) = 1 / s_hat &
                  * sqrt (lambda (s_hat, phs%m_out(1)**2, phs%m_out(2)**2))
          else
             print *, "m_in  = ", phs%m_in
             print *, "m_out = ", phs%m_out
             call msg_fatal ("Decay is kinematically forbidden")
          end if
       end if
    case (2)
       if (phs%config%sqrts_fixed) then
          if (phs%p_defined)  return
          s_hat = phs%config%sqrts ** 2
       else
          if (.not. phs%p_defined)  return
          s_hat = sum (phs%p) ** 2
       end if
       if (sum (phs%m_in)**2 < s_hat .and. sum (phs%m_out)**2 < s_hat) then
          phs%f(1) = 1 / s_hat * &
               ( lambda (s_hat, phs%m_in (1)**2, phs%m_in (2)**2)   &
               * lambda (s_hat, phs%m_out(1)**2, phs%m_out(2)**2) ) &
               ** 0.25_default
       else
          phs%f(1) = 0
       end if
    end select
  end subroutine phs_single_compute_factor
    
@ %def phs_single_compute_factor
@ Evaluation.  We uniformly generate $\cos\theta$ and
$\phi$, with Jacobian normalized to one.

There is only a single channel, so the second subroutine does nothing.

Note: the current implementation works for elastic scattering only.
<<PHS single: phs single: TBP>>=
  procedure :: evaluate_selected_channel => phs_single_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_single_evaluate_other_channels
<<PHS single: procedures>>=
  subroutine phs_single_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_single_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    !!! !!! !!! Catching a gfortran bogus warning
    type(vector4_t), dimension(2) :: p_dum
    if (phs%p_defined) then
       call phs%select_channel (c_in)
       phs%r(:,c_in) = r_in
       select case (phs%config%n_in)
       case (2)
          if (all (phs%m_in == phs%m_out)) then
             call compute_kinematics_solid_angle (phs%p, phs%q, r_in) 
          else
             call msg_bug ("PHS single: inelastic scattering not implemented")
          end if
       case (1)
          !!! !!! !!! Catching a gfortran bogus warning
          !!! call compute_kinematics_solid_angle (phs%decay_p (), phs%q, x)
          p_dum = phs%decay_p ()
          call compute_kinematics_solid_angle (p_dum, phs%q, r_in)
       end select
       call phs%compute_factor ()
       phs%q_defined = .true.
       phs%r_defined = .true.
    end if
  end subroutine phs_single_evaluate_selected_channel
  
  subroutine phs_single_evaluate_other_channels (phs, c_in)
    class(phs_single_t), intent(inout) :: phs
    integer, intent(in) :: c_in
  end subroutine phs_single_evaluate_other_channels
  
@ %def phs_single_evaluate_selected_channel
@ %def phs_single_evaluate_other_channels
@ Auxiliary: split a decaying particle at rest into the decay products,
aligned along the $z$ axis.
<<PHS single: phs single: TBP>>=
  procedure :: decay_p => phs_single_decay_p
<<PHS single: procedures>>=
  function phs_single_decay_p (phs) result (p)
    class(phs_single_t), intent(in) :: phs
    type(vector4_t), dimension(2) :: p
    real(default) :: k
    real(default), dimension(2) :: E
    k = sqrt (lambda (phs%m_in(1) ** 2, phs%m_out(1) ** 2, phs%m_out(2) ** 2)) &
         / (2 * phs%m_in(1))
    E = sqrt (phs%m_out ** 2 + k ** 2)
    p(1) = vector4_moving (E(1), k, 3)
    p(2) = vector4_moving (E(2),-k, 3)
  end function phs_single_decay_p
  
@ %def phs_single_decay_p
@ Inverse evaluation.
<<PHS single: phs single: TBP>>=
  procedure :: inverse => phs_single_inverse
<<PHS single: procedures>>=
  subroutine phs_single_inverse (phs)
    class(phs_single_t), intent(inout) :: phs
    real(default), dimension(:), allocatable :: x
    if (phs%p_defined .and. phs%q_defined) then
       call phs%select_channel ()
       allocate (x (phs%config%n_par))
       call inverse_kinematics_solid_angle (phs%p, phs%q, x)
       phs%r(:,1) = x
       call phs%compute_factor ()
       phs%r_defined = .true.
    end if
  end subroutine phs_single_inverse
  
@ %def phs_single_inverse
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[phs_single_ut.f90]]>>=
<<File header>>

module phs_single_ut
  use unit_tests
  use phs_single_uti
  
<<Standard module head>>

<<PHS single: public test>>

contains
  
<<PHS single: test driver>>

end module phs_single_ut
@ %def phs_single_ut
@
<<[[phs_single_uti.f90]]>>=
<<File header>>

module phs_single_uti

<<Use kinds>>
<<Use strings>>
  use flavors
  use lorentz
  use model_data
  use process_constants
  use phs_base

  use phs_single
  
  use phs_base_ut, only: init_test_process_data, init_test_decay_data

<<Standard module head>>

<<PHS single: test declarations>>

contains

<<PHS single: tests>>

end module phs_single_uti
@ %def phs_single_ut
@ API: driver for the unit tests below.
<<PHS single: public test>>=
  public :: phs_single_test
<<PHS single: test driver>>=
  subroutine phs_single_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS single: execute tests>>
  end subroutine phs_single_test
  
@ %def phs_single_test
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.  Also
check the [[azimuthal_dependence]] flag.
<<PHS single: execute tests>>=
  call test (phs_single_1, "phs_single_1", &
       "phase-space configuration", &
       u, results)
<<PHS single: test declarations>>=
  public :: phs_single_1
<<PHS single: tests>>=
  subroutine phs_single_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    real(default) :: sqrts
    
    write (u, "(A)")  "* Test output: phs_single_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_1"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts, azimuthal_dependence=.false.)
       
    call phs_data%write (u)
  
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_1"

  end subroutine phs_single_1

@ %def phs_single_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS single: execute tests>>=
  call test (phs_single_2, "phs_single_2", &
       "phase-space evaluation", &
       u, results)
<<PHS single: test declarations>>=
  public :: phs_single_2
<<PHS single: tests>>=
  subroutine phs_single_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    
    write (u, "(A)")  "* Test output: phs_single_2"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flv%init (25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_2"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flv%get_mass ()**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flv%get_mass ()**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_2"

  end subroutine phs_single_2

@ %def phs_single_2
@
\subsubsection{Phase space for non-c.m. system}
Compute kinematics for given parameters, also invert the calculation.
Since this will involve cancellations, we call [[pacify]] to eliminate
numerical noise.
<<PHS single: execute tests>>=
  call test (phs_single_3, "phs_single_3", &
       "phase-space evaluation in lab frame", &
       u, results)
<<PHS single: test declarations>>=
  public :: phs_single_3
<<PHS single: tests>>=
  subroutine phs_single_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    type(lorentz_transformation_t) :: lt
    
    write (u, "(A)")  "* Test output: phs_single_3"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")  "*            without c.m. kinematics assumption"
    write (u, "(A)")
    
    call model%init_test ()
    call flv%init (25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_single_3"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    sqrts = 1000._default
    call phs_data%configure (sqrts, cm_frame=.false., sqrts_fixed=.false.)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta in lab system"
    write (u, "(A)")

    lt = boost (0.1_default, 1) * boost (0.3_default, 3)
    
    E = sqrts / 2
    p(1) = lt * vector4_moving (E, sqrt (E**2 - flv%get_mass ()**2), 3)
    p(2) = lt * vector4_moving (E,-sqrt (E**2 - flv%get_mass ()**2), 3)

    call vector4_write (p(1), u)
    call vector4_write (p(2), u)

    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    
    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call pacify (phs)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Extract outgoing momenta in lab system"
    write (u, "(A)")
    
    call phs%get_outgoing_momenta (q)
    call vector4_write (q(1), u)
    call vector4_write (q(2), u)

    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call pacify (phs)
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_3"

  end subroutine phs_single_3

@ %def phs_single_3
@
\subsubsection{Decay Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.  This
time, implement a decay process.
<<PHS single: execute tests>>=
  call test (phs_single_4, "phs_single_4", &
       "decay phase-space evaluation", &
       u, results)
<<PHS single: test declarations>>=
  public :: phs_single_4
<<PHS single: tests>>=
  subroutine phs_single_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(1) :: p
    type(vector4_t), dimension(2) :: q
    
    write (u, "(A)")  "* Test output: phs_single_4"
    write (u, "(A)")  "*   Purpose: test simple two-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()

    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))
    call flv%init (25, model)

    write (u, "(A)")  "* Initialize a decay and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_decay_data (var_str ("phs_single_4"), process_data)

    allocate (phs_single_config_t :: phs_data)
    call phs_data%init (process_data, model)

    call phs_data%configure (flv%get_mass ())

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    p(1) = vector4_at_rest (flv%get_mass ())

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.5, 0.125"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.5_default, 0.125_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    deallocate (phs)
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs_data%configure (flv%get_mass ())

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    call phs%final ()
    deallocate (phs)
    
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_single_4"

  end subroutine phs_single_4

@ %def phs_single_4
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Mappings}

Mappings are objects that encode the transformation of the interval
$(0,1)$ to a physical variable $m^2$ or $\cos\theta$ (and back), as it
is used in the phase space parameterization.  The mapping objects
contain fixed parameters, the associated methods implement the mapping
and inverse mapping operations, including the computation of the
Jacobian (phase space factor).
<<[[mappings.f90]]>>=
<<File header>>

module mappings

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use constants, only: pi
  use format_defs, only: FMT_19
  use diagnostics
  use md5
  use model_data
  use flavors

<<Standard module head>>

<<Mappings: public>>

<<Mappings: parameters>>

<<Mappings: types>>

<<Mappings: interfaces>>

contains

<<Mappings: procedures>>

end module mappings
@ %def mappings
@ 
\subsection{Default parameters}
This type holds the default parameters, needed for setting the scale
in cases where no mass parameter is available.  The contents are public.
<<Mappings: public>>=
  public :: mapping_defaults_t
<<Mappings: types>>=
  type :: mapping_defaults_t
     real(default) :: energy_scale = 10
     real(default) :: invariant_mass_scale = 10
     real(default) :: momentum_transfer_scale = 10
     logical :: step_mapping = .true.
     logical :: step_mapping_exp = .true.
     logical :: enable_s_mapping = .false.
   contains
   <<Mappings: mapping defaults: TBP>>
  end type mapping_defaults_t

@ %def mapping_defaults_t
@ Output.
<<Mappings: mapping defaults: TBP>>=
  procedure :: write => mapping_defaults_write
<<Mappings: procedures>>=
  subroutine mapping_defaults_write (object, unit)
    class(mapping_defaults_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A," // FMT_19 // ")") "energy scale  = ", &
         object%energy_scale
    write (u, "(3x,A," // FMT_19 // ")") "mass scale    = ", &
         object%invariant_mass_scale
    write (u, "(3x,A," // FMT_19 // ")") "q scale       = ", &
         object%momentum_transfer_scale
    write (u, "(3x,A,L1)") "step mapping     = ", &
         object%step_mapping
    write (u, "(3x,A,L1)") "step exp. mode   = ", &
         object%step_mapping_exp
    write (u, "(3x,A,L1)") "allow s mapping  = ", &
         object%enable_s_mapping
  end subroutine mapping_defaults_write    

@ %def mapping_defaults_write
@ 
<<Mappings: public>>=
  public :: mapping_defaults_md5sum
<<Mappings: procedures>>=
  function mapping_defaults_md5sum (mapping_defaults) result (md5sum_map)
    character(32) :: md5sum_map
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    integer :: u
    u = free_unit ()
    open (u, status = "scratch")
    write (u, *)  mapping_defaults%energy_scale
    write (u, *)  mapping_defaults%invariant_mass_scale
    write (u, *)  mapping_defaults%momentum_transfer_scale
    write (u, *)  mapping_defaults%step_mapping
    write (u, *)  mapping_defaults%step_mapping_exp
    write (u, *)  mapping_defaults%enable_s_mapping
    rewind (u)
    md5sum_map = md5sum (u)
    close (u)
  end function mapping_defaults_md5sum

@ %def mapping_defaults_md5sum
@
\subsection{The Mapping type}
Each mapping has a type (e.g., s-channel, infrared), a binary code
(redundant, but useful for debugging), and a reference particle.  The
flavor code of this particle is stored for bookkeeping reasons, what
matters are the mass and width of this particle.  Furthermore,
depending on the type, various mapping parameters can be set and used.

The parameters [[a1]] to [[a3]] (for $m^2$ mappings) and [[b1]] to
[[b3]] (for $\cos\theta$ mappings) are values that are stored once to
speed up the calculation, if [[variable_limits]] is false.  The exact
meaning of these parameters depends on the mapping type.  The limits
are fixed if there is a fixed c.m. energy.
<<Mappings: public>>=
  public :: mapping_t
<<Mappings: types>>=
  type :: mapping_t
     private
     integer :: type = NO_MAPPING
     integer(TC) :: bincode
     type(flavor_t) :: flv
     real(default) :: mass = 0
     real(default) :: width = 0
     logical :: a_unknown = .true.
     real(default) :: a1 = 0
     real(default) :: a2 = 0
     real(default) :: a3 = 0
     logical :: b_unknown = .true.
     real(default) :: b1 = 0
     real(default) :: b2 = 0
     real(default) :: b3 = 0
     logical :: variable_limits = .true.
  end type mapping_t
  
@ %def mapping_t
@ The valid mapping types.  The extra type [[STEP_MAPPING]] is used
only internally.
<<Mappings: parameters>>=
<<Mapping modes>>
@
\subsection{Screen output}
Do not write empty mappings.
<<Mappings: public>>=
  public :: mapping_write
<<Mappings: procedures>>=
  subroutine mapping_write (map, unit, verbose)
    type(mapping_t), intent(in) :: map
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    character(len=9) :: str
    u = given_output_unit (unit);  if (u < 0)  return
    select case(map%type)
    case(S_CHANNEL); str = "s_channel"
    case(COLLINEAR); str = "collinear"
    case(INFRARED);  str = "infrared "
    case(RADIATION); str = "radiation"
    case(T_CHANNEL); str = "t_channel"
    case(U_CHANNEL); str = "u_channel"
    case(STEP_MAPPING_E);  str = "step_exp"
    case(STEP_MAPPING_H);  str = "step_hyp"
    case(ON_SHELL);  str = "on_shell"
    case default;    str = "????????"
    end select
    if (map%type /= NO_MAPPING) then
       write (u, '(1x,A,I4,A)') &
            "Branch #", map%bincode, ":  " // &
            "Mapping (" // str // ") for particle " // &
            '"' // char (map%flv%get_name ()) // '"'
       if (present (verbose)) then
          if (verbose) then
             select case (map%type)
             case (S_CHANNEL, RADIATION, STEP_MAPPING_E, STEP_MAPPING_H)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  m/w    = ", map%mass, map%width
             case default
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  m      = ", map%mass
             end select
             select case (map%type)
             case (S_CHANNEL, T_CHANNEL, U_CHANNEL, &
                  STEP_MAPPING_E, STEP_MAPPING_H, &
                  COLLINEAR, INFRARED, RADIATION)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  a1/2/3 = ", map%a1, map%a2, map%a3
             end select
             select case (map%type)
             case (T_CHANNEL, U_CHANNEL, COLLINEAR)
                write (u, "(1x,A,3(" // FMT_19 // "))")  &
                     "  b1/2/3 = ", map%b1, map%b2, map%b3
             end select
          end if
       end if
    end if
  end subroutine mapping_write

@ %def mapping_write
@ 
\subsection{Define a mapping}
The initialization routine sets the mapping type and the particle
(binary code and flavor code) for which the mapping applies (e.g., a
$Z$ resonance in branch \#3).  We only need the absolute value of the
flavor code.
<<Mappings: public>>=
  public :: mapping_init
<<Mappings: procedures>>=
  subroutine mapping_init (mapping, bincode, type, f, model)
    type(mapping_t), intent(inout) :: mapping
    integer(TC), intent(in) :: bincode
    type(string_t), intent(in) :: type
    integer, intent(in), optional :: f
    class(model_data_t), intent(in), optional, target :: model
    mapping%bincode = bincode
    select case (char (type))
    case ("s_channel");  mapping%type = S_CHANNEL
    case ("collinear");  mapping%type = COLLINEAR
    case ("infrared");   mapping%type = INFRARED
    case ("radiation");  mapping%type = RADIATION
    case ("t_channel");  mapping%type = T_CHANNEL
    case ("u_channel");  mapping%type = U_CHANNEL
    case ("step_exp");  mapping%type = STEP_MAPPING_E
    case ("step_hyp");  mapping%type = STEP_MAPPING_H
    case ("on_shell");  mapping%type = ON_SHELL
    case default
       call msg_bug ("Mappings: encountered undefined mapping key '" &
            // char (type) // "'")
    end select
    if (present (f) .and. present (model)) &
         call mapping%flv%init (abs (f), model)
  end subroutine mapping_init

@ %def mapping_init
@ This sets the actual mass and width, using a parameter set.  Since
the auxiliary parameters will only be determined when the mapping is
first called, they are marked as unknown.
<<Mappings: public>>=
  public :: mapping_set_parameters
<<Mappings: procedures>>=
  subroutine mapping_set_parameters (map, mapping_defaults, variable_limits)
    type(mapping_t), intent(inout) :: map
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    if (map%type /= NO_MAPPING) then
       map%mass  = map%flv%get_mass ()
       map%width = map%flv%get_width ()
       map%variable_limits = variable_limits
       map%a_unknown = .true.
       map%b_unknown = .true.
       select case (map%type)
       case (S_CHANNEL)
          if (map%mass <= 0) then
             call mapping_write (map)
             call msg_fatal &
                  & (" S-channel resonance must have positive mass")
          else if (map%width <= 0) then
             call mapping_write (map)
             call msg_fatal &
                  & (" S-channel resonance must have positive width")
          end if
       case (RADIATION)
          map%width = max (map%width, mapping_defaults%energy_scale)
       case (INFRARED, COLLINEAR)
          map%mass = max (map%mass, mapping_defaults%invariant_mass_scale)
       case (T_CHANNEL, U_CHANNEL)
          map%mass = max (map%mass, mapping_defaults%momentum_transfer_scale)
       end select
    end if
  end subroutine mapping_set_parameters

@ %def mapping_set_code mapping_set_parameters
@ For a step mapping the mass and width are set directly, instead of
being determined from the flavor parameter (which is meaningless
here).  They correspond to the effective upper bound of phase space
due to a resonance, as opposed to the absolute upper bound.
<<Mappings: public>>=
  public :: mapping_set_step_mapping_parameters
<<Mappings: procedures>>=
  subroutine mapping_set_step_mapping_parameters (map, &
       mass, width, variable_limits)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: mass, width
    logical, intent(in) :: variable_limits
    select case (map%type)
    case (STEP_MAPPING_E, STEP_MAPPING_H)
       map%variable_limits = variable_limits
       map%a_unknown = .true.
       map%b_unknown = .true.
       map%mass = mass
       map%width = width
    end select
  end subroutine mapping_set_step_mapping_parameters

@ %def mapping_set_step_mapping_parameters
@ 
\subsection{Retrieve contents}
Return true if there is any / an s-channel mapping.
<<Mappings: public>>=
  public :: mapping_is_set
  public :: mapping_is_s_channel
  public :: mapping_is_on_shell
<<Mappings: procedures>>=
  function mapping_is_set (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type /= NO_MAPPING
  end function mapping_is_set

  function mapping_is_s_channel (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type == S_CHANNEL
  end function mapping_is_s_channel

  function mapping_is_on_shell (mapping) result (flag)
    logical :: flag
    type(mapping_t), intent(in) :: mapping
    flag = mapping%type == ON_SHELL
  end function mapping_is_on_shell

@ %def mapping_is_set
@ %def mapping_is_s_channel
@ %def mapping_is_on_shell
@ Return stored mass and width, respectively.
<<Mappings: public>>=
  public :: mapping_get_mass
  public :: mapping_get_width
<<Mappings: procedures>>=
  function mapping_get_mass (mapping) result (mass)
    real(default) :: mass
    type(mapping_t), intent(in) :: mapping
    mass = mapping%mass
  end function mapping_get_mass

  function mapping_get_width (mapping) result (width)
    real(default) :: width
    type(mapping_t), intent(in) :: mapping
    width = mapping%width
  end function mapping_get_width

@ %def mapping_get_mass
@ %def mapping_get_width
@ 
\subsection{Compare mappings}
Equality for single mappings and arrays
<<Mappings: public>>=
  public :: operator(==)
<<Mappings: interfaces>>=
  interface operator(==)
     module procedure mapping_equal
  end interface
<<Mappings: procedures>>=
  function mapping_equal (m1, m2) result (equal)
    type(mapping_t), intent(in) :: m1, m2
    logical :: equal
    if (m1%type == m2%type) then
       select case (m1%type)
       case (NO_MAPPING)
          equal = .true.
       case (S_CHANNEL, RADIATION, STEP_MAPPING_E, STEP_MAPPING_H)
          equal = (m1%mass == m2%mass) .and. (m1%width == m2%width)
       case default
          equal = (m1%mass == m2%mass)
       end select
    else
       equal = .false.
    end if
  end function mapping_equal

@ %def mapping_equal
@
\subsection{Mappings of the invariant mass}
Inserting an $x$ value between 0 and 1, we want to compute the
corresponding invariant mass $m^2(x)$ and the jacobian, aka phase
space factor $f(x)$.  We also need the reverse operation.

In general, the phase space factor $f$ is defined by
\begin{equation}
  \frac{1}{s}\int_{m^2_{\textrm{min}}}^{m^2_{\textrm{max}}} dm^2\,g(m^2)
  = \int_0^1 dx\,\frac{1}{s}\,\frac{dm^2}{dx}\,g(m^2(x))
  = \int_0^1 dx\,f(x)\,g(x),
\end{equation}
where thus
\begin{equation}
  f(x) = \frac{1}{s}\,\frac{dm^2}{dx}.
\end{equation}
With this mapping, a function of the form
\begin{equation}
  g(m^2) = c\frac{dx(m^2)}{dm^2}
\end{equation}
is mapped to a constant:
\begin{equation}
  \frac{1}{s}\int_{m^2_{\textrm{min}}}^{m^2_{\textrm{max}}} dm^2\,g(m^2)
  = \int_0^1 dx\,f(x)\,g(m^2(x)) = \int_0^1 dx\,\frac{c}{s}.
\end{equation}

Here is the mapping routine.  Input are the available energy
squared [[s]], the limits for $m^2$, and the $x$ value.  Output are
the $m^2$ value and the phase space factor $f$.
<<Mappings: public>>=
  public :: mapping_compute_msq_from_x
<<Mappings: procedures>>=
  subroutine mapping_compute_msq_from_x (map, s, msq_min, msq_max, msq, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s, msq_min, msq_max
    real(default), intent(out) :: msq, f
    real(default), intent(in) :: x
    real(default) :: z, msq0, msq1, tmp
    integer :: type
    type = map%type
    if (s == 0) &
         call msg_fatal (" Applying msq mapping for zero energy")
  <<Modify mapping type if necessary>>
    select case(type)
    case (NO_MAPPING)
     <<Constants for trivial msq mapping>>
     <<Apply trivial msq mapping>>
    case (S_CHANNEL)
     <<Constants for s-channel resonance mapping>>
     <<Apply s-channel resonance mapping>>
    case (COLLINEAR, INFRARED, RADIATION)
     <<Constants for s-channel pole mapping>>
     <<Apply s-channel pole mapping>>
    case (T_CHANNEL, U_CHANNEL)
     <<Constants for t-channel pole mapping>>
     <<Apply t-channel pole mapping>>
    case (STEP_MAPPING_E)
     <<Constants for exponential step mapping>>
     <<Apply exponential step mapping>>
    case (STEP_MAPPING_H)
     <<Constants for hyperbolic step mapping>>
     <<Apply hyperbolic step mapping>>
    case default
       call msg_fatal ( " Attempt to apply undefined msq mapping")
    end select
  end subroutine mapping_compute_msq_from_x

@ %def mapping_compute_msq_from_x
@ The inverse mapping
<<Mappings: public>>=
  public :: mapping_compute_x_from_msq
<<Mappings: procedures>>=
  subroutine mapping_compute_x_from_msq (map, s, msq_min, msq_max, msq, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s, msq_min, msq_max
    real(default), intent(in) :: msq
    real(default), intent(out) :: f, x
    real(default) :: msq0, msq1, tmp, z
    integer :: type
    type = map%type
    if (s == 0) &
         call msg_fatal (" Applying inverse msq mapping for zero energy")
  <<Modify mapping type if necessary>>
    select case (type)
    case (NO_MAPPING)
     <<Constants for trivial msq mapping>>
     <<Apply inverse trivial msq mapping>>
    case (S_CHANNEL)
     <<Constants for s-channel resonance mapping>>
     <<Apply inverse s-channel resonance mapping>>
    case (COLLINEAR, INFRARED, RADIATION)
     <<Constants for s-channel pole mapping>>
     <<Apply inverse s-channel pole mapping>>
    case (T_CHANNEL, U_CHANNEL)
     <<Constants for t-channel pole mapping>>
     <<Apply inverse t-channel pole mapping>>
    case (STEP_MAPPING_E)
     <<Constants for exponential step mapping>>
     <<Apply inverse exponential step mapping>>
    case (STEP_MAPPING_H)
     <<Constants for hyperbolic step mapping>>
     <<Apply inverse hyperbolic step mapping>>
    case default
       call msg_fatal ( " Attempt to apply undefined msq mapping")
    end select
  end subroutine mapping_compute_x_from_msq

@ %def mapping_compute_x_from_msq
@
\subsubsection{Trivial mapping}
We simply map the boundaries of the interval $(m_{\textrm{min}},
m_{\textrm{max}})$ to $(0,1)$:
\begin{equation}
  m^2 = (1-x) m_{\textrm{min}}^2 + x m_{\textrm{max}}^2;
\end{equation}
the inverse is
\begin{equation}
  x = \frac{m^2 - m_{\textrm{min}}^2}{m_{\textrm{max}}^2- m_{\textrm{min}}^2}.
\end{equation}
Hence
\begin{equation}
  f(x) = \frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{s},
\end{equation}
and we have, as required,
\begin{equation}
  f(x)\,\frac{dx}{dm^2} = \frac{1}{s}.
\end{equation}

We store the constant parameters the first time the mapping is called
-- or, if limits vary, recompute them each time.
<<Constants for trivial msq mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a1 = 0
     map%a2 = msq_max - msq_min
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply trivial msq mapping>>=
  msq = (1-x) * msq_min + x * msq_max
  f = map%a3
<<Apply inverse trivial msq mapping>>=
  if (map%a2 /= 0) then
     x = (msq - msq_min) / map%a2
  else
     x = 0
  end if
  f = map%a3
@ Resonance or step mapping does not make much sense if the resonance mass is
outside the kinematical bounds.  If this is the case, revert to
[[NO_MAPPING]].  This is possible even if the kinematical bounds vary
from event to event.
<<Modify mapping type if necessary>>=
  select case (type)
  case (S_CHANNEL, STEP_MAPPING_E, STEP_MAPPING_H)
     msq0 = map%mass**2
     if (msq0 < msq_min .or. msq0 > msq_max)  type = NO_MAPPING
  end select
@ 
\subsubsection{Breit-Wigner mapping}
A Breit-Wigner resonance with mass $M$ and width $\Gamma$ is flattened
by the following mapping:

This mapping does not make much sense if the resonance mass is too low.
If this is the case, revert to [[NO_MAPPING]].  There is a tricky
point with this if the mass is too high: [[msq_max]] is not a
constant if structure functions are around.  However, switching the
type depending on the overall energy does not change the integral, it
is just another branching point.
\begin{equation}
  m^2 = M(M+t\Gamma),
\end{equation}
where
\begin{equation}
  t = \tan\left[(1-x)\arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}
                + x  \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}\right].
\end{equation}
The inverse:
\begin{equation}
  x = \frac{  \arctan\frac{m^2 - M^2}{M\Gamma}
            - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}}
           {  \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}
            - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}}
\end{equation}
The phase-space factor of this transformation is
\begin{equation}
  f(x) = \frac{M\Gamma}{s}\left(
           \arctan\frac{m^2_{\textrm{max}} - M^2}{M\Gamma}
         - \arctan\frac{m^2_{\textrm{min}} - M^2}{M\Gamma}\right)
	 (1 + t^2).
\end{equation}
This maps any function proportional to
\begin{equation}
  g(m^2) = \frac{M\Gamma}{(m^2-M^2)^2 + M^2\Gamma^2}
\end{equation}
to a constant times $1/s$.
<<Constants for s-channel resonance mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     msq0 = map%mass ** 2
     map%a1 = atan ((msq_min - msq0) / (map%mass * map%width))
     map%a2 = atan ((msq_max - msq0) / (map%mass * map%width))
     map%a3 = (map%a2 - map%a1) * (map%mass * map%width) / s 
     map%a_unknown = .false.
  end if
<<Apply s-channel resonance mapping>>=
  z = (1-x) * map%a1 + x * map%a2
  if (-pi/2 < z .and. z < pi/2) then
     tmp = tan (z)
     msq = map%mass * (map%mass + map%width * tmp)
     f = map%a3 * (1 + tmp**2) 
  else
     msq = 0
     f = 0
  end if
<<Apply inverse s-channel resonance mapping>>=
  tmp = (msq - msq0) / (map%mass * map%width)
  x = (atan (tmp) - map%a1) / (map%a2 - map%a1)
  f = map%a3 * (1 + tmp**2)
@ 
\subsubsection{Mapping for massless splittings}
This mapping accounts for approximately scale-invariant behavior where
$\ln M^2$ is evenly distributed.
\begin{equation}
  m^2 = m_{\textrm{min}}^2 + M^2\left(\exp(xL)-1\right)
\end{equation}
where
\begin{equation}
  L = \ln\left(\frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{M^2} + 1\right).
\end{equation}
The inverse:
\begin{equation}
  x = \frac1L\ln\left(\frac{m^2-m_{\textrm{min}}^2}{M^2} + 1\right)
\end{equation}
The constant $M$ is a characteristic scale.  Above this scale
($m^2-m_{\textrm{min}}^2 \gg M^2$), this mapping behaves like
$x\propto\ln m^2$, while below the scale it reverts to a linear
mapping.

The phase-space factor is
\begin{equation}
  f(x) = \frac{M^2}{s}\,\exp(xL)\,L.
\end{equation}
A function proportional to
\begin{equation}
  g(m^2) = \frac{1}{(m^2-m_{\textrm{min}}^2) + M^2}
\end{equation}
is mapped to a constant, i.e., a simple pole near $m_{\textrm{min}}$
with a regulator mass $M$.

This type of mapping is useful for massless collinear and infrared
singularities, where the scale is stored as the mass parameter.  In
the radiation case (IR radiation off massive particle), the heavy
particle width is the characteristic scale.
<<Constants for s-channel pole mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     if (type == RADIATION) then
        msq0 = map%width**2
     else
        msq0 = map%mass**2
     end if
     map%a1 = msq0
     map%a2 = log ((msq_max - msq_min) / msq0 + 1)
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply s-channel pole mapping>>=
  msq1 = map%a1 * exp (x * map%a2)
  msq = msq1 - map%a1 + msq_min 
  f = map%a3 * msq1
<<Apply inverse s-channel pole mapping>>=
  msq1 = msq - msq_min + map%a1
  x = log (msq1 / map%a1) / map%a2
  f = map%a3 * msq1
@ 
\subsubsection{Mapping for t-channel poles}
This is also approximately scale-invariant, and we use the same type
of mapping as before.  However, we map $1/x$ singularities at both
ends of the interval; again, the mapping becomes linear when the
distance is less than $M^2$:
\begin{equation}
  m^2 = 
  \begin{cases}
    m_{\textrm{min}}^2 + M^2\left(\exp(xL)-1\right)
    &
    \text{for $0 < x < \frac12$}
    \\
    m_{\textrm{max}}^2 - M^2\left(\exp((1-x)L)-1\right)
    &
    \text{for $\frac12 \leq x < 1$}
  \end{cases}
\end{equation}
where
\begin{equation}
  L = 2\ln\left(\frac{m_{\textrm{max}}^2 - m_{\textrm{min}}^2}{2M^2} 
                + 1\right).
\end{equation}
The inverse:
\begin{equation}
  x = 
  \begin{cases}
    \frac1L\ln\left(\frac{m^2-m_{\textrm{min}}^2}{M^2} + 1\right)
    &
    \text{for $m^2 < (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
    \\
    1 - \frac1L\ln\left(\frac{m_{\textrm{max}}-m^2}{M^2} + 1\right)
    &
    \text{for $m^2 \geq (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
  \end{cases}
\end{equation}
The phase-space factor is
\begin{equation}
  f(x) = 
  \begin{cases}
    \frac{M^2}{s}\,\exp(xL)\,L.
    &
    \text{for $0 < x < \frac12$}
    \\
    \frac{M^2}{s}\,\exp((1-x)L)\,L.
    &
    \text{for $\frac12 \leq x < 1$}
  \end{cases}
\end{equation}
A (continuous) function proportional to
\begin{equation}
  g(m^2) =
  \begin{cases}
    1/(m^2-m_{\textrm{min}}^2) + M^2)
    &
    \text{for $m^2 < (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
    \\
    1/((m_{\textrm{max}}^2 - m^2) + M^2)
    &
    \text{for $m^2 \leq (m_{\textrm{max}}^2 - m_{\textrm{min}}^2)/2$}
  \end{cases}
\end{equation}
is mapped to a constant by this mapping, i.e., poles near both ends of
the interval.
<<Constants for t-channel pole mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     msq0 = map%mass**2
     map%a1 = msq0
     map%a2 = 2 * log ((msq_max - msq_min)/(2*msq0) + 1)
     map%a3 = map%a2 / s
     map%a_unknown = .false.
  end if
<<Apply t-channel pole mapping>>=
  if (x < .5_default) then
     msq1 = map%a1 * exp (x * map%a2)
     msq = msq1 - map%a1 + msq_min
  else
     msq1 = map%a1 * exp ((1-x) * map%a2)
     msq = -(msq1 - map%a1) + msq_max
  end if
  f = map%a3 * msq1
<<Apply inverse t-channel pole mapping>>=
  if (msq < (msq_max + msq_min)/2) then
     msq1 = msq - msq_min + map%a1
     x = log (msq1/map%a1) / map%a2
  else
     msq1 = msq_max - msq + map%a1
     x = 1 - log (msq1/map%a1) / map%a2
  end if
  f = map%a3 * msq1
@
\subsection{Step mapping}
Step mapping is useful when the allowed range for a squared-mass
variable is large, but only a fraction at the lower end is populated
because the particle in question is an (off-shell) decay product of a
narrow resonance.  I.e., if the resonance was forced to be on-shell,
the upper end of the range would be the resonance mass, minus the
effective (real or resonance) mass of the particle(s) in the sibling
branch of the decay.

The edge of this phase space section has a width which is determined
by the width of the parent, plus the width of the sibling branch.  (The
widths might be added in quadrature, but this precision is probably
not important.)

\subsubsection{Fermi function}

A possible mapping is derived from the Fermi function which has
precisely this behavior.  The Fermi function is given by
\begin{equation}
  f(x) = \frac{1}{1 + \exp\frac{x-\mu}{\gamma}}
\end{equation}
where $x$ is taken as the invariant mass squared, $\mu$ is the
invariant mass squared of the edge, and $\gamma$ is the effective
width which is given by the widths of the parent and the sibling
branch.  (Widths might be added in quadrature, but we do not require
this level of precision.)
\begin{align}
  x &= \frac{m^2 - m_{\text{min}}^2}{\Delta m^2}
\\
  \mu &= 
  \frac{m_{\text{max,eff}}^2 - m_{\text{min}}^2}
          {\Delta m^2}
\\
  \gamma &= \frac{2m_{\text{max,eff}}\Gamma}{\Delta m^2}
\end{align}
with
\begin{equation}
  \Delta m^2 = m_{\text{max}}^2 - m_{\text{min}}^2
\end{equation}
$m^2$ is thus given by
\begin{equation}
  m^2(x) = xm_{\text{max}}^2 + (1-x)m_{\text{min}}^2
\end{equation}
For the mapping, we compute the integral $g(x)$ of the Fermi function,
normalized such that $g(0)=0$ and $g(1)=1$.  We introduce the abbreviations
\begin{align}
  \alpha &= 1 - \gamma\ln\frac{1 + \beta e^{1/\gamma}}{1 + \beta}
\\
  \beta  &= e^{- \mu/\gamma}
\end{align}
and obtain
\begin{equation}
  g(x) = \frac{1}{\alpha}
         \left(x - \gamma\ln\frac{1 + \beta e^{x/\gamma}}
                                 {1 + \beta}\right)
\end{equation}
The actual mapping is the inverse function $h(y) = g^{-1}(y)$,
\begin{equation}
  h(y) = -\gamma\ln\left(e^{-\alpha y/\gamma}(1 + \beta) - \beta\right)
\end{equation}
The Jacobian is
\begin{equation}
  \frac{dh}{dy} = \alpha\left(1 - e^{\alpha y/\gamma}
                                  \frac{\beta}{1 + \beta}\right)^{-1}
\end{equation}
which is equal to $1/(dg/dx)$, namely
\begin{equation}
  \frac{dg}{dx} = \frac{1}{\alpha}\,\frac{1}{1 + \beta e^{x/\gamma}}
\end{equation}
The final result is
\begin{align}
  \int_{m_{\text{min}}^2}^{m_{\text{max}}^2} dm^2\,F(m^2)
  &= \Delta m^2\int_0^1\,dx\,F(m^2(x))
\\
  &= \Delta m^2\int_0^1\,dy\,F(m^2(h(y)))\,\frac{dh}{dy}
\end{align}
Here is the implementation.  We fill [[a1]], [[a2]], [[a3]] with
$\alpha,\beta,\gamma$, respectively.
<<Constants for exponential step mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a3 = max (2 * map%mass * map%width / (msq_max - msq_min), 0.01_default)
     map%a2 = exp (- (map%mass**2 - msq_min) / (msq_max - msq_min) &
                     / map%a3)
     map%a1 = 1 - map%a3 * log ((1 + map%a2 * exp (1 / map%a3)) / (1 + map%a2))
  end if
<<Apply exponential step mapping>>=
  tmp = exp (- x * map%a1 / map%a3) * (1 + map%a2)
  z = - map%a3 * log (tmp - map%a2)
  msq  = z * msq_max + (1 - z) * msq_min
  f = map%a1 / (1 - map%a2 / tmp) * (msq_max - msq_min) / s
<<Apply inverse exponential step mapping>>=
  z = (msq - msq_min) / (msq_max - msq_min)
  tmp = 1 + map%a2 * exp (z / map%a3)
  x = (z - map%a3 * log (tmp / (1 + map%a2))) &
      / map%a1
  f = map%a1 * tmp * (msq_max - msq_min) / s
@ 
\subsubsection{Hyperbolic mapping}

The Fermi function has the drawback that it decreases exponentially.
It might be preferable to take a function with a power-law decrease,
such that the high-mass region is not completely depopulated.

Here, we start with the actual mapping which we take as
\begin{equation}
  h(y) = \frac{b}{a-y} - \frac{b}{a} + \mu y
\end{equation}
with the abbreviation
\begin{equation}
  a = \frac12\left(1 + \sqrt{1 + \frac{4b}{1-\mu}}\right)
\end{equation}
This is a hyperbola in the $xy$ plane.  The derivative is
\begin{equation}
  \frac{dh}{dy} = \frac{b}{(a-y)^2} + \mu
\end{equation}
The constants correspond to
\begin{align}
  \mu &= 
  \frac{m_{\text{max,eff}}^2 - m_{\text{min}}^2}
          {\Delta m^2}
\\
  b &= \frac{1}{\mu}\left(\frac{2m_{\text{max,eff}}\Gamma}{\Delta m^2}\right)^2
\end{align}
The inverse function is the solution of a quadratic equation,
\begin{equation}
  g(x) = \frac{1}{2}
         \left[\left(a + \frac{x}{\mu} + \frac{b}{a\mu}\right) 
               - \sqrt{\left(a-\frac{x}{\mu}\right)^2
                       + 2\frac{b}{a\mu}\left(a + \frac{x}{\mu}\right)
                       + \left(\frac{b}{a\mu}\right)^2}\right]
\end{equation}
The constants $a_{1,2,3}$ are identified with $a,b,\mu$.
<<Constants for hyperbolic step mapping>>=
  if (map%variable_limits .or. map%a_unknown) then
     map%a3 = (map%mass**2 - msq_min) / (msq_max - msq_min)
     map%a2 = max ((2 * map%mass * map%width / (msq_max - msq_min))**2 &
                   / map%a3, 1e-6_default)
     map%a1 = (1 + sqrt (1 + 4 * map%a2 / (1 - map%a3))) / 2
  end if
<<Apply hyperbolic step mapping>>=
  z = map%a2 / (map%a1 - x) - map%a2 / map%a1 + map%a3 * x
  msq = z * msq_max + (1 - z) * msq_min
  f = (map%a2 / (map%a1 - x)**2 + map%a3) * (msq_max - msq_min) / s
<<Apply inverse hyperbolic step mapping>>=
  z = (msq - msq_min) / (msq_max - msq_min)
  tmp = map%a2 / (map%a1 * map%a3)
  x = ((map%a1 + z / map%a3 + tmp) &
       - sqrt ((map%a1 - z / map%a3)**2 + 2 * tmp * (map%a1 + z / map%a3) &
               + tmp**2)) / 2
  f = (map%a2 / (map%a1 - x)**2 + map%a3) * (msq_max - msq_min) / s
@ 
\subsection{Mappings of the polar angle}
The other type of singularity, a simple pole just outside the
integration region, can occur in the integration over $\cos\theta$.
This applies to exchange of massless (or light) particles.

Double poles (Coulomb scattering) are also possible, but only in
certain cases.  These are also handled by the single-pole mapping.

The mapping is analogous to the previous $m^2$ pole mapping, but with
a different normalization and notation of variables:
\begin{equation}
  \frac12\int_{-1}^1 d\cos\theta\,g(\theta)
  = \int_0^1 dx\,\frac{d\cos\theta}{dx}\,g(\theta(x))
  = \int_0^1 dx\,f(x)\,g(x),
\end{equation}
where thus
\begin{equation}
  f(x) = \frac12\,\frac{d\cos\theta}{dx}.
\end{equation}
With this mapping, a function of the form
\begin{equation}
  g(\theta) = c\frac{dx(\cos\theta)}{d\cos\theta}
\end{equation}
is mapped to a constant:
\begin{equation}
  \int_{-1}^1 d\cos\theta\,g(\theta)
  = \int_0^1 dx\,f(x)\,g(\theta(x)) = \int_0^1 dx\,c.
\end{equation}
<<Mappings: public>>=
  public :: mapping_compute_ct_from_x
<<Mappings: procedures>>=
  subroutine mapping_compute_ct_from_x (map, s, ct, st, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s
    real(default), intent(out) :: ct, st, f
    real(default), intent(in) :: x
    real(default) :: tmp, ct1
    select case (map%type)
    case (NO_MAPPING, S_CHANNEL, INFRARED, RADIATION, &
         STEP_MAPPING_E, STEP_MAPPING_H)
     <<Apply trivial ct mapping>>
    case (T_CHANNEL, U_CHANNEL, COLLINEAR)
     <<Constants for ct pole mapping>>
     <<Apply ct pole mapping>>
    case default
       call msg_fatal (" Attempt to apply undefined ct mapping")
    end select
  end subroutine mapping_compute_ct_from_x

@ %def mapping_compute_ct_from_x
<<Mappings: public>>=
  public :: mapping_compute_x_from_ct
<<Mappings: procedures>>=
  subroutine mapping_compute_x_from_ct (map, s, ct, f, x)
    type(mapping_t), intent(inout) :: map
    real(default), intent(in) :: s
    real(default), intent(in) :: ct
    real(default), intent(out) :: f, x
    real(default) :: ct1
    select case (map%type)
    case (NO_MAPPING, S_CHANNEL, INFRARED, RADIATION, &
         STEP_MAPPING_E, STEP_MAPPING_H)
     <<Apply inverse trivial ct mapping>>
    case (T_CHANNEL, U_CHANNEL, COLLINEAR)
     <<Constants for ct pole mapping>>
     <<Apply inverse ct pole mapping>>
    case default
       call msg_fatal (" Attempt to apply undefined inverse ct mapping")
    end select
  end subroutine mapping_compute_x_from_ct

@ %def mapping_compute_x_from_ct
@
\subsubsection{Trivial mapping}
This is just the mapping of the interval $(-1,1)$ to $(0,1)$:
\begin{equation}
  \cos\theta = -1 + 2x
\end{equation}
and
\begin{equation}
  f(x) = 1
\end{equation}
with the inverse
\begin{equation}
  x = \frac{1+\cos\theta}{2}
\end{equation}
<<Apply trivial ct mapping>>=
  tmp = 2 * (1-x)
  ct = 1 - tmp
  st = sqrt (tmp * (2-tmp))
  f = 1
<<Apply inverse trivial ct mapping>>=
  x = (ct + 1) / 2
  f = 1
@ 
\subsubsection{Pole mapping}
As above for $m^2$, we simultaneously map poles at both ends of the
$\cos\theta$ interval.  The formulae are completely analogous:
\begin{equation}
  \cos\theta =
  \begin{cases}
    \frac{M^2}{s}\left[\exp(xL)-1\right] - 1
    &
    \text{for $x<\frac12$}
    \\
    -\frac{M^2}{s}\left[\exp((1-x)L)-1\right] + 1
    &
    \text{for $x\geq\frac12$}
  \end{cases}
\end{equation}
where
\begin{equation}
  L = 2\ln\frac{M^2+s}{M^2}.
\end{equation}
Inverse:
\begin{equation}
  x = 
  \begin{cases}
    \frac{1}{2L}\ln\frac{1 + \cos\theta + M^2/s}{M^2/s}
    &
    \text{for $\cos\theta < 0$}
    \\
    1 - \frac{1}{2L}\ln\frac{1 - \cos\theta + M^2/s}{M^2/s}
    &
    \text{for $\cos\theta \geq 0$}
  \end{cases}
\end{equation}
The phase-space factor:
\begin{equation}
  f(x) = 
  \begin{cases}
    \frac{M^2}{s}\exp(xL)\,L
    &
    \text{for $x<\frac12$}
    \\
    \frac{M^2}{s}\exp((1-x)L)\,L
    &
    \text{for $x\geq\frac12$}
  \end{cases}
\end{equation}
<<Constants for ct pole mapping>>=
  if (map%variable_limits .or. map%b_unknown) then
     map%b1 = map%mass**2 / s
     map%b2 = log ((map%b1 + 1) / map%b1)
     map%b3 = 0
     map%b_unknown = .false.
  end if
<<Apply ct pole mapping>>=
  if (x < .5_default) then
     ct1 = map%b1 * exp (2 * x * map%b2)
     ct = ct1 - map%b1 - 1
  else
     ct1 = map%b1 * exp (2 * (1-x) * map%b2)
     ct = -(ct1 - map%b1) + 1
  end if
  if (ct >= -1 .and. ct <= 1) then
     st = sqrt (1 - ct**2)
     f = ct1 * map%b2
  else
     ct = 1;  st = 0;  f = 0
  end if
<<Apply inverse ct pole mapping>>=
  if (ct < 0) then
     ct1 = ct + map%b1 + 1
     x = log (ct1 / map%b1) / (2 * map%b2)
  else
     ct1 = -ct + map%b1 + 1
     x = 1 - log (ct1 / map%b1) / (2 * map%b2)
  end if
  f = ct1 * map%b2
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\clearpage
\section{Phase-space trees}
The phase space evaluation is organized in terms of trees, where each
branch corresponds to three integrations: $m^2$, $\cos\theta$, and
$\phi$.  The complete tree thus makes up a specific parameterization
of the multidimensional phase-space integral.  For the multi-channel
integration, the phase-space tree is a single channel.

The trees imply mappings of formal Feynman tree graphs into arrays of
integer numbers: Each branch, corresponding to a particular line in
the graph, is assigned an integer code $c$ (with kind value [[TC]] =
tree code).

In this integer, each bit determines whether a particular external
momentum flows through the line.  The external branches therefore have
codes $1,2,4,8,\ldots$.  An internal branch has those bits ORed
corresponding to the momenta flowing through it.  For example, a
branch with momentum $p_1+p_4$ has code $2^0+2^3=1+8=9$.

There is a two-fold ambiguity: Momentum conservation implies that the
branch with code
\begin{equation}
  c_0 = \sum_{i=1}^{n(\rm{ext})} 2^{i-1}
\end{equation}
i.e. the branch with momentum $p_1+p_2+\ldots p_n$ has momentum zero,
which is equivalent to tree code $0$ by definition.  Correspondingly,
\begin{equation}
  c \quad\textrm{and}\quad c_0 - c = c\;\textrm{XOR}\;c_0
\end{equation}
are equivalent.  E.g., if there are five externals with codes
$c=1,2,4,8,16$, then $c=9$ and $\bar c=31-9=22$ are equivalent.

This ambiguity may be used to assign a direction to the line: If all
momenta are understood as outgoing, $c=9$ in the example above means
$p_1+p_4$, but $c=22$ means $p_2+p_3+p_5 = -(p_1+p_4)$.

Here we make use of the ambiguity in a slightly different way.  First,
the initial particles are singled out as those externals with the
highest bits, the IN-bits.  (Here: $8$ and $16$ for a $2\to 3$
scattering process, $16$ only for a $1\to 4$ decay.)  Then we invert
those codes where all IN-bits are set.  For a decay process this maps
each tree of an equivalence class onto a unique representative (that one
with the smallest integer codes).  For a scattering process we proceed
further:

The ambiguity remains in all branches where only one IN-bit is set,
including the initial particles.  If there are only externals with
this property, we have an $s$-channel graph which we leave as it is.
In all other cases, an internal with only one IN-bit is a $t$-channel
line, which for phase space integration should be associated with one
of the initial momenta as a reference axis.  We take that one whose
bit is set in the current tree code.  (E.g., for branch $c=9$ we use
the initial particle $c=8$ as reference axis, whereas for the same
branch we would take $c=16$ if it had been assigned $\bar c=31-9=22$
as tree code.) Thus, different ways of coding the same $t$-channel
graph imply different phase space parameterizations.

$s$-channel graphs have a unique parameterization.  The same sets of
parameterizations are used for $t$-channel graphs, except for the
reference frames of their angular parts.  We map each
$t$-channel graph onto an $s$-channel graph as follows:

Working in ascending order, for each $t$-channel line (whose code has
exactly one IN-bit set) the attached initial line is flipped upstream,
while the outgoing line is flipped downstream.  (This works only if
$t$-channel graphs are always parameterized beginning at their outer
vertices, which we require as a restriction.)  After all possible
flips have been applied, we have an $s$-channel graph.  We only have
to remember the initial particle a vertex was originally attached to.
<<[[phs_trees.f90]]>>=
<<File header>>

module phs_trees

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use constants, only: twopi, twopi2, twopi5
  use format_defs, only: FMT_19
  use diagnostics
  use lorentz
  use permutations, only: permutation_t, permutation_size
  use permutations, only: permutation_init, permutation_find
  use permutations, only: tc_decay_level, tc_permute
  use model_data
  use flavors
  use mappings

<<Standard module head>>

<<PHS trees: public>>

<<PHS trees: types>>

contains

<<PHS trees: procedures>>

end module phs_trees
@ %def phs_trees
@ 
\subsection{Particles}
We define a particle type which contains only four-momentum and
invariant mass squared, and a flag that tells whether the momentum is
filled or not.
<<PHS trees: public>>=
  public :: phs_prt_t
<<PHS trees: types>>=
  type :: phs_prt_t
     private
     logical :: defined = .false.
     type(vector4_t) :: p
     real(default) :: p2
  end type phs_prt_t

@ %def phs_prt_t
@ Set contents:
<<PHS trees: public>>=
  public :: phs_prt_set_defined
  public :: phs_prt_set_undefined
  public :: phs_prt_set_momentum
  public :: phs_prt_set_msq
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_set_defined (prt)
    type(phs_prt_t), intent(inout) :: prt
    prt%defined = .true.
  end subroutine phs_prt_set_defined

  elemental subroutine phs_prt_set_undefined (prt)
    type(phs_prt_t), intent(inout) :: prt
    prt%defined = .false.
  end subroutine phs_prt_set_undefined

  elemental subroutine phs_prt_set_momentum (prt, p)
    type(phs_prt_t), intent(inout) :: prt
    type(vector4_t), intent(in) :: p
    prt%p = p
  end subroutine phs_prt_set_momentum

  elemental subroutine phs_prt_set_msq (prt, p2)
    type(phs_prt_t), intent(inout) :: prt
    real(default), intent(in) :: p2
    prt%p2 = p2
  end subroutine phs_prt_set_msq

@ %def phs_prt_set_defined phs_prt_set_momentum phs_prt_set_msq
@ Access methods:
<<PHS trees: public>>=
  public :: phs_prt_is_defined
  public :: phs_prt_get_momentum
  public :: phs_prt_get_msq
<<PHS trees: procedures>>=
  elemental function phs_prt_is_defined (prt) result (defined)
    logical :: defined
    type(phs_prt_t), intent(in) :: prt
    defined = prt%defined
  end function phs_prt_is_defined

  elemental function phs_prt_get_momentum (prt) result (p)
    type(vector4_t) :: p
    type(phs_prt_t), intent(in) :: prt
    p = prt%p
  end function phs_prt_get_momentum

  elemental function phs_prt_get_msq (prt) result (p2)
    real(default) :: p2
    type(phs_prt_t), intent(in) :: prt
    p2 = prt%p2
  end function phs_prt_get_msq

@ %def phs_prt_is_defined phs_prt_get_momentum phs_prt_get_msq
@ Addition of momenta (invariant mass square is computed).
<<PHS trees: public>>=
  public :: phs_prt_combine
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_combine (prt, prt1, prt2)
    type(phs_prt_t), intent(inout) :: prt
    type(phs_prt_t), intent(in) :: prt1, prt2
    prt%defined = .true.
    prt%p = prt1%p + prt2%p
    prt%p2 = prt%p ** 2
    call phs_prt_check (prt)
  end subroutine phs_prt_combine

@ %def phs_prt_combine
@ Output
<<PHS trees: public>>=
  public :: phs_prt_write
<<PHS trees: procedures>>=    
  subroutine phs_prt_write (prt, unit)
    type(phs_prt_t), intent(in) :: prt
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    if (prt%defined) then
       call vector4_write (prt%p, u)
       write (u, "(1x,A,1x," // FMT_19 // ")") "T = ", prt%p2
    else
       write (u, "(3x,A)") "[undefined]"
    end if
  end subroutine phs_prt_write

@ %def phs_prt_write
<<PHS trees: public>>=
  public :: phs_prt_check
<<PHS trees: procedures>>=
  elemental subroutine phs_prt_check (prt)
    type(phs_prt_t), intent(inout) :: prt
    if (prt%p2 < 0._default) then
       prt%p2 = 0._default
    end if
  end subroutine phs_prt_check

@ %def phs_prt_check
@
\subsection{The phase-space tree type}
\subsubsection{Definition}
In the concrete implementation, each branch $c$ may have two
\emph{daughters} $c_1$ and $c_2$ such that $c_1+c_2=c$, a
\emph{sibling} $c_s$ and a \emph{mother} $c_m$ such that $c+c_s =
c_m$, and a \emph{friend} which is kept during flips, such that it can
indicate a fixed reference frame.  Absent entries are set $c=0$.

First, declare the branch type.  There is some need to have this
public. Give initializations for all components, so no [[init]]
routine is necessary.  The branch has some information about the
associated coordinates and about connections.
<<PHS trees: types>>=
  type :: phs_branch_t
     private
     logical :: set = .false.
     logical :: inverted_decay = .false.
     logical :: inverted_axis = .false.
     integer(TC) :: mother = 0
     integer(TC) :: sibling = 0
     integer(TC) :: friend = 0
     integer(TC) :: origin = 0
     integer(TC), dimension(2) :: daughter = 0
     integer :: firstborn = 0
     logical :: has_children = .false.
     logical :: has_friend = .false.
     logical :: is_real = .false.
  end type phs_branch_t

@ %def phs_branch_t
@ The tree type: No initialization, this is done by
[[phs_tree_init]].  In addition to the branch array which 

The branches are collected in an array which holds all possible
branches, of which only a few are set.  After flips have been applied,
the branch $c_M=\sum_{i=1}^{n({\rm fin})}2^{i-1}$ must be there,
indicating the mother of all decay products.  In addition, we should
check for consistency at the beginning.

[[n_branches]] is the number of those actually set.  [[n_externals]]
defines the number of significant bit, and [[mask]] is a code where all
bits are set.  Analogous: [[n_in]] and [[mask_in]] for the incoming
particles.

The [[mapping]] array contains the mappings associated to the branches
(corresponding indices).  The array [[mass_sum]] contains the sum of
the real masses of the external final-state particles associated to
the branch.  During phase-space evaluation, this determines the
boundaries.
<<PHS trees: public>>=
  public :: phs_tree_t
<<PHS trees: types>>=
  type :: phs_tree_t
     private
     integer :: n_branches, n_externals, n_in, n_msq, n_angles
     integer(TC) :: n_branches_tot, n_branches_out
     integer(TC) :: mask, mask_in, mask_out
     type(phs_branch_t), dimension(:), allocatable :: branch
     type(mapping_t), dimension(:), allocatable :: mapping
     real(default), dimension(:), allocatable :: mass_sum
     real(default), dimension(:), allocatable :: effective_mass
     real(default), dimension(:), allocatable :: effective_width
     logical :: real_phsp = .false.
     integer(TC) :: emitter = 0
     integer, dimension(:), allocatable :: momentum_link
  end type phs_tree_t

@ %def phs_tree_t
@ The maximum number of external particles that can be represented is
related to the bit size of the integer that stores binary codes.  With
the default integer of 32 bit on common machines, this is more than
enough space.  If [[TC]] is actually the default integer kind, there
is no need to keep it separate, but doing so marks this as a
special type of integer.  So, just state that the maximum number is 32:
<<Limits: public parameters>>=
  integer, parameter, public :: MAX_EXTERNAL = 32
@ %def MAX_EXTERNAL
@
\subsubsection{Constructor and destructor}
Allocate memory for a phase-space tree with given number of externals and
incoming.  The number of allocated branches can easily become large,
but appears manageable for realistic cases, e.g., for [[n_in=2]] and
[[n_out=8]] we get $2^{10}-1=1023$.
<<PHS trees: public>>=
  public :: phs_tree_init
  public :: phs_tree_final
@ Here we set the masks for incoming and for all externals.
<<PHS trees: procedures>>=
  elemental subroutine phs_tree_init (tree, n_in, n_out, n_masses, n_angles)
    type(phs_tree_t), intent(inout) :: tree
    integer, intent(in) :: n_in, n_out, n_masses, n_angles
    integer(TC) :: i
    tree%n_externals = n_in + n_out
    tree%n_branches_tot = 2**(n_in+n_out) - 1
    tree%n_branches_out = 2**n_out - 1
    tree%mask = 0
    do i = 0, n_in + n_out - 1
       tree%mask = ibset (tree%mask, i)
    end do
    tree%n_in = n_in
    tree%mask_in = 0
    do i = n_out, n_in + n_out - 1
       tree%mask_in = ibset (tree%mask_in, i)
    end do
    tree%mask_out = ieor (tree%mask, tree%mask_in)
    tree%n_msq = n_masses
    tree%n_angles = n_angles
    allocate (tree%branch (tree%n_branches_tot))
    tree%n_branches  = 0
    allocate (tree%mapping (tree%n_branches_out))
    allocate (tree%mass_sum (tree%n_branches_out))
    allocate (tree%effective_mass (tree%n_branches_out))
    allocate (tree%effective_width (tree%n_branches_out))
  end subroutine phs_tree_init

  elemental subroutine phs_tree_final (tree)
    type(phs_tree_t), intent(inout) :: tree
    deallocate (tree%branch)
    deallocate (tree%mapping)
    deallocate (tree%mass_sum)
    deallocate (tree%effective_mass)
    deallocate (tree%effective_width)
  end subroutine phs_tree_final

@ %def phs_tree_init phs_tree_final
@
\subsubsection{Screen output}
Write only the branches that are set:
<<PHS trees: public>>=
  public :: phs_tree_write
<<PHS trees: procedures>>=
  subroutine phs_tree_write (tree, unit)
    type(phs_tree_t), intent(in) :: tree
    integer, intent(in), optional :: unit
    integer :: u
    integer(TC) :: k
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'External:', tree%n_externals, 'Mask:', tree%mask
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'Incoming:', tree%n_in, 'Mask:', tree%mask_in
    write (u, '(3X,A,1x,I0,5X,A,I3)') &
         'Branches:', tree%n_branches
    do k = size (tree%branch), 1, -1
       if (tree%branch(k)%set) &
            call phs_branch_write (tree%branch(k), unit=unit, kval=k)
    end do
    do k = 1, size (tree%mapping)
       call mapping_write (tree%mapping (k), unit, verbose=.true.)
    end do
    write (u, "(3x,A)") "Arrays: mass_sum, effective_mass, effective_width"
    do k = 1, size (tree%mass_sum)
       if (tree%branch(k)%set) then
          write (u, "(5x,I0,3(2x," // FMT_19 // "))") k, tree%mass_sum(k), &
               tree%effective_mass(k), tree%effective_width(k)
       end if
    end do
  end subroutine phs_tree_write

  subroutine phs_branch_write (b, unit, kval)
    type(phs_branch_t), intent(in) :: b
    integer, intent(in), optional :: unit
    integer(TC), intent(in), optional :: kval
    integer :: u
    integer(TC) :: k
    character(len=6) :: tmp
    character(len=1) :: firstborn(2), sign_decay, sign_axis
    integer :: i
    u = given_output_unit (unit);  if (u < 0)  return
    k = 0;  if (present (kval))  k = kval
    if (b%origin /= 0) then
       write(tmp, '(A,I4,A)') '(', b%origin, ')'
    else
       tmp = ' '
    end if
    do i=1, 2
       if (b%firstborn == i) then
          firstborn(i) = "*"
       else
          firstborn(i) = " "
       end if
    end do
    if (b%inverted_decay) then
       sign_decay = "-"
    else
       sign_decay = "+"
    end if
    if (b%inverted_axis) then
       sign_axis = "-"
    else
       sign_axis = "+"
    end if
    if (b%has_children) then
       if (b%has_friend) then
          write(u,'(4X,A1,I0,3x,A,1X,A,I0,A1,1x,I0,A1,1X,A1,1X,A,1x,I0)') &
               &   '*', k, tmp, &
               &   'Daughters: ', &
               &   b%daughter(1), firstborn(1), &
               &   b%daughter(2), firstborn(2), sign_decay, &
               &   'Friend:    ', b%friend
       else
          write(u,'(4X,A1,I0,3x,A,1X,A,I0,A1,1x,I0,A1,1X,A1,1X,A)') &
               &   '*', k, tmp, &
               &   'Daughters: ', &
               &   b%daughter(1), firstborn(1), &
               &   b%daughter(2), firstborn(2), sign_decay, &
               &   '(axis '//sign_axis//')'
       end if
    else
       write(u,'(5X,I0)') k
    end if
  end subroutine phs_branch_write

@ %def phs_tree_write phs_branch_write
@
\subsection{PHS tree setup}
\subsubsection{Transformation into an array of branch codes and back}
Assume that the tree/array has been created before with the
appropriate length and is empty.  
<<PHS trees: public>>=
  public :: phs_tree_from_array
<<PHS trees: procedures>>=
  subroutine phs_tree_from_array (tree, a)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC), dimension(:), intent(in) :: a
    integer :: i
    integer(TC) :: k
  <<Set branches from array [[a]]>>
  <<Set external branches if necessary>>
  <<Check number of branches>>
  <<Determine the connections>>
  contains
  <<Subroutine: set relatives>>
  end subroutine phs_tree_from_array

@ %def phs_tree_from_array
@ First, set all branches specified by the user.  If all IN-bits
are set, we invert the branch code.  
<<Set branches from array [[a]]>>=
  do i=1, size(a)
     k = a(i)
     if (iand(k, tree%mask_in) == tree%mask_in)  k = ieor(tree%mask, k)
     tree%branch(k)%set = .true.
     tree%n_branches = tree%n_branches+1
  end do
@ The external branches are understood, so set them now if not yet
done.  In all cases ensure that the representative with one bit set is
used, except for decays where the in-particle is represented by all
OUT-bits set instead.
<<Set external branches if necessary>>=
  do i=0, tree%n_externals-1
     k = ibset(0,i)
     if (iand(k, tree%mask_in) == tree%mask_in)  k = ieor(tree%mask, k)
     if (tree%branch(ieor(tree%mask, k))%set) then
        tree%branch(ieor(tree%mask, k))%set = .false.
        tree%branch(k)%set = .true.
     else if (.not.tree%branch(k)%set) then
        tree%branch(k)%set = .true.
        tree%n_branches = tree%n_branches+1
     end if
  end do
@ Now the number of branches set can be checked.  Here we assume that
the tree is binary.  For three externals there are three branches in
total, and for each additional external branch we get another internal
one.
<<Check number of branches>>=
  if (tree%n_branches /= tree%n_externals*2-3) then
     call phs_tree_write (tree)
     call msg_bug &
          & (" Wrong number of branches set in phase space tree")
  end if
@ For all branches that are set, except for the externals, we try to
find the daughter branches:
<<Determine the connections>>=
  do k=1, size (tree%branch)
     if (tree%branch(k)%set .and. tc_decay_level (k) /= 1) then
        call branch_set_relatives(k)
     end if
  end do
@ To this end, we scan all codes less than the current code, whether
we can find two branches which are set and which together give the
current code.  After that, the tree may still not be connected, but at
least we know if a branch does not have daughters: This indicates some
inconsistency.

The algorithm ensures that, at this stage, the first daughter has a
smaller code value than the second one.
<<Subroutine: set relatives>>=
  subroutine branch_set_relatives (k)
    integer(TC), intent(in) :: k
    integer(TC) :: m,n
    do m=1, k-1
       if(iand(k,m)==m) then
          n = ieor(k,m)
          if ( tree%branch(m)%set .and. tree%branch(n)%set ) then
             tree%branch(k)%daughter(1) = m;  tree%branch(k)%daughter(2) = n
             tree%branch(m)%mother      = k;  tree%branch(n)%mother      = k
             tree%branch(m)%sibling     = n;  tree%branch(n)%sibling     = m
             tree%branch(k)%has_children = .true.
             return
          end if
       end if
    end do
    call phs_tree_write (tree)
    call msg_bug &
         & (" Missing daughter branch(es) in phase space tree")
  end subroutine branch_set_relatives

@ The inverse: this is trivial, fortunately.
@
\subsubsection{Flip $t$-channel into $s$-channel}
Flipping the tree is done upwards, beginning from the decay products.
First we select a $t$-channel branch [[k]]: one which is set, which
does have an IN-bit, and which is not an external particle.

Next, we determine the adjacent in-particle (called the 'friend' [[f]]
here, since it will provide the reference axis for the angular
integration).  In addition, we look for the 'mother' and 'sibling' of
this particle.  If the latter field is empty, we select the (unique)
other out-particle which has no mother, calling the internal
subroutine [[find_orphan]].  

The flip is done as follows: We assume that the first daughter [[d]]
is an $s$-channel line, which is true if the daughters are sorted.
This will stay the first daughter.  The second one is a $t$-channel
line; it is exchanged with the 'sibling' [[s]].  The new line which
replaces the branch [[k]] is just the sum of [[s]] and [[d]].  In
addition, we have to rearrange the relatives of [[s]] and [[d]], as
well of [[f]].

Finally, we flip 'sibling' and 'friend' and set the new $s$-channel
branch [[n]] which replaces the $t$-channel branch [[k]].  After this
is complete, we are ready to execute another flip.

[Although the friend is not needed for the final flip, since it would
be an initial particle anyway, we need to know whether we have $t$- or
$u$-channel.]
<<PHS trees: public>>=
  public :: phs_tree_flip_t_to_s_channel
<<PHS trees: procedures>>=
  subroutine phs_tree_flip_t_to_s_channel (tree)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC) :: k, f, m, n, d, s
    if (tree%n_in == 2) then
       FLIP: do k=3, tree%mask-1
          if (.not. tree%branch(k)%set) cycle FLIP
          f = iand(k,tree%mask_in)
          if (f==0 .or. f==k) cycle FLIP
          m = tree%branch(k)%mother
          s = tree%branch(k)%sibling
          if (s==0) call find_orphan(s)
          d = tree%branch(k)%daughter(1)
          n = ior(d,s)  
          tree%branch(k)%set = .false.
          tree%branch(n)%set = .true.
          tree%branch(n)%origin = k
          tree%branch(n)%daughter(1) = d; tree%branch(d)%mother  = n
          tree%branch(n)%daughter(2) = s; tree%branch(s)%mother  = n
          tree%branch(n)%has_children = .true.
          tree%branch(d)%sibling = s;  tree%branch(s)%sibling = d
          tree%branch(n)%sibling = f;  tree%branch(f)%sibling = n
          tree%branch(n)%mother      = m
          tree%branch(f)%mother      = m
          if (m/=0) then
             tree%branch(m)%daughter(1) = n
             tree%branch(m)%daughter(2) = f
          end if
          tree%branch(n)%friend = f
          tree%branch(n)%has_friend = .true.
          tree%branch(n)%firstborn = 2
       end do FLIP
    end if
  contains
    subroutine find_orphan(s)
      integer(TC) :: s
      do s=1, tree%mask_out
         if (tree%branch(s)%set .and. tree%branch(s)%mother==0) return
      end do
      call phs_tree_write (tree)
      call msg_bug (" Can't flip phase space tree to channel")
    end subroutine find_orphan
  end subroutine phs_tree_flip_t_to_s_channel

@ %def phs_tree_flip_t_to_s_channel
@ After the tree has been flipped, one may need to determine what has
become of a particular $t$-channel branch.  This function gives the
bincode of the flipped tree.  If the original bincode does not contain
IN-bits, we leave it as it is.
<<PHS trees: procedures>>=
  function tc_flipped (tree, kt) result (ks)
    type(phs_tree_t), intent(in) :: tree
    integer(TC), intent(in) :: kt
    integer(TC) :: ks
    if (iand (kt, tree%mask_in) == 0) then
       ks = kt
    else
       ks = tree%branch(iand (kt, tree%mask_out))%mother
    end if
  end function tc_flipped

@ %def tc_flipped
@ Scan a tree and make sure that the first daughter has always a
smaller code than the second one.  Furthermore, delete any [[friend]]
entry in the root branch -- this branching has the incoming particle
direction as axis anyway.  Keep track of reordering by updating
[[inverted_axis]], [[inverted_decay]] and [[firstborn]].
<<PHS trees: public>>=
  public :: phs_tree_canonicalize
<<PHS trees: procedures>>=
  subroutine phs_tree_canonicalize (tree)
    type(phs_tree_t), intent(inout) :: tree
    integer :: n_out
    integer(TC) :: k_out
    call branch_canonicalize (tree%branch(tree%mask_out))
    n_out = tree%n_externals - tree%n_in
    k_out = tree%mask_out
    if (tree%branch(k_out)%has_friend &
         & .and. tree%branch(k_out)%friend == ibset (0, n_out)) then
       tree%branch(k_out)%inverted_axis = .not.tree%branch(k_out)%inverted_axis
    end if
    tree%branch(k_out)%has_friend = .false.
    tree%branch(k_out)%friend = 0
  contains
    recursive subroutine branch_canonicalize (b)
      type(phs_branch_t), intent(inout) :: b
      integer(TC) :: d1, d2
      if (b%has_children) then
         d1 = b%daughter(1)
         d2 = b%daughter(2)
         if (d1 > d2) then
            b%daughter(1) = d2
            b%daughter(2) = d1
            b%inverted_decay = .not.b%inverted_decay
            if (b%firstborn /= 0)  b%firstborn = 3 - b%firstborn
         end if
         call branch_canonicalize (tree%branch(b%daughter(1)))
         call branch_canonicalize (tree%branch(b%daughter(2)))
      end if
    end subroutine branch_canonicalize
  end subroutine phs_tree_canonicalize

@ %def phs_tree_canonicalize
@ 
\subsubsection{Mappings}
Initialize a mapping for the current tree.  This is done while reading
from file, so the mapping parameters are read, but applied to the
flipped tree.  Thus, the size of the array of mappings is given by the
number of outgoing particles only.
<<PHS trees: public>>=
  public :: phs_tree_init_mapping
<<PHS trees: procedures>>=
  subroutine phs_tree_init_mapping (tree, k, type, pdg, model)
    type(phs_tree_t), intent(inout) :: tree
    integer(TC), intent(in) :: k
    type(string_t), intent(in) :: type
    integer, intent(in) :: pdg
    class(model_data_t), intent(in), target :: model
    integer(TC) :: kk
    kk = tc_flipped (tree, k)
    call mapping_init (tree%mapping(kk), kk, type, pdg, model)
  end subroutine phs_tree_init_mapping

@ %def phs_tree_init_mapping
@ Set the physical parameters for the mapping, using a specific
parameter set.  Also set the mass sum array.
<<PHS trees: public>>=
  public :: phs_tree_set_mapping_parameters
<<PHS trees: procedures>>=
  subroutine phs_tree_set_mapping_parameters &
       (tree, mapping_defaults, variable_limits)
    type(phs_tree_t), intent(inout) :: tree
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    integer(TC) :: k
    do k = 1, tree%n_branches_out
       call mapping_set_parameters &
            (tree%mapping(k), mapping_defaults, variable_limits) 
    end do
  end subroutine phs_tree_set_mapping_parameters

@ %def phs_tree_set_mapping_parameters
@ Return the mapping for the sum of all outgoing particles.  This
should either be no mapping or a global s-channel mapping.
<<PHS trees: public>>=
  public :: phs_tree_assign_s_mapping
<<PHS trees: procedures>>=
  subroutine phs_tree_assign_s_mapping (tree, mapping)
    type(phs_tree_t), intent(in) :: tree
    type(mapping_t), intent(out) :: mapping
    mapping = tree%mapping(tree%mask_out)
  end subroutine phs_tree_assign_s_mapping

@ %def phs_tree_assign_s_mapping
@ 
\subsubsection{Kinematics}
Fill the mass sum array, starting from the external particles and
working down to the tree root.  For each bincode [[k]] we scan the
bits in [[k]]; if only one is set, we take the physical mass of the
corresponding external particle; if more then one is set, we sum up
the two masses (which we know have already been set).
<<PHS trees: public>>=
  public :: phs_tree_set_mass_sum
<<PHS trees: procedures>>=
  subroutine phs_tree_set_mass_sum (tree, flv)
    type(phs_tree_t), intent(inout) :: tree
    type(flavor_t), dimension(:), intent(in) :: flv
    integer(TC) :: k
    integer :: i
    tree%mass_sum = 0
    do k = 1, tree%n_branches_out
       do i = 0, size (flv) - 1
          if (btest(k,i)) then
             if (ibclr(k,i) == 0) then
                tree%mass_sum(k) = flv(i+1)%get_mass ()
             else
                tree%mass_sum(k) = &
                     tree%mass_sum(ibclr(k,i)) + tree%mass_sum(ibset(0,i))
             end if
             exit
          end if
       end do
    end do
  end subroutine phs_tree_set_mass_sum
  
@ %def phs_tree_set_mass_sum
@ Set the effective masses and widths.  For each non-resonant branch
in a tree, the effective mass is equal to the sum of the effective
masses of the children (and analogous for the width).  External
particles have their real mass and width zero.  For resonant branches,
we insert mass and width from the corresponding mapping.

This routine has [[phs_tree_set_mass_sum]] and
[[phs_tree_set_mapping_parameters]] as prerequisites.
<<PHS trees: public>>=
  public :: phs_tree_set_effective_masses
<<PHS trees: procedures>>=
  subroutine phs_tree_set_effective_masses (tree)
    type(phs_tree_t), intent(inout) :: tree
    tree%effective_mass = 0
    tree%effective_width = 0
    call set_masses_x (tree%mask_out)
  contains
    recursive subroutine set_masses_x (k)
      integer(TC), intent(in) :: k
      integer(TC) :: k1, k2
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1)
         k2 = tree%branch(k)%daughter(2)
         call set_masses_x (k1)
         call set_masses_x (k2)
         if (mapping_is_s_channel (tree%mapping(k))) then
            tree%effective_mass(k) = mapping_get_mass (tree%mapping(k))
            tree%effective_width(k) = mapping_get_width (tree%mapping(k))
         else
            tree%effective_mass(k) = &
                 tree%effective_mass(k1) + tree%effective_mass(k2)
            tree%effective_width(k) = &
                 tree%effective_width(k1) + tree%effective_width(k2)
         end if
      else
         tree%effective_mass(k) = tree%mass_sum(k)
      end if
    end subroutine set_masses_x
  end subroutine phs_tree_set_effective_masses

@ %def phs_tree_set_effective_masses
@ Define step mappings, recursively, for the decay products of all
intermediate resonances.  Step mappings account for the fact that a
branch may originate from a resonance, which almost replaces the
upper limit on the possible invariant mass.  The step
mapping implements a smooth cutoff that interpolates between the
resonance and the real kinematic limit.  The mapping width determines
the sharpness of the cutoff.

Step mappings are inserted only for branches that are not mapped
otherwise.

At each branch, we record the mass that is effectively available for
phase space, by taking the previous limit and subtracting the
effective mass of the sibling branch.  Widths are added, not subtracted.

If we encounter a resonance decay, we discard the previous limit and
replace it by the mass and width of the resonance, also subtracting
the sibling branch.

Initially, the limit is zero, so it becomes negative at any branch.  Only
if there is a resonance, the limit becomes positive.  Whenever the
limit is positive, and the current branch decays, we activate a step
mapping for the current branch.

As a result, step mappings are implemented for all internal lines that
originate from an intermediate resonance decay.

The flag [[variable_limits]] applies to the ultimate limit from the
available energy, not to the intermediate resonances whose masses are
always fixed.

This routine requires [[phs_tree_set_effective_masses]]
<<PHS trees: public>>=
  public :: phs_tree_set_step_mappings
<<PHS trees: procedures>>=
  subroutine phs_tree_set_step_mappings (tree, exp_type, variable_limits)
    type(phs_tree_t), intent(inout) :: tree
    logical, intent(in) :: exp_type
    logical, intent(in) :: variable_limits
    type(string_t) :: map_str
    integer(TC) :: k
    if (exp_type) then
       map_str = "step_exp"
    else
       map_str = "step_hyp"
    end if
    k = tree%mask_out
    call set_step_mappings_x (k, 0._default, 0._default)
  contains
    recursive subroutine set_step_mappings_x (k, m_limit, w_limit)
      integer(TC), intent(in) :: k
      real(default), intent(in) :: m_limit, w_limit
      integer(TC), dimension(2) :: kk
      real(default), dimension(2) :: m, w
      if (tree%branch(k)%has_children) then
         if (m_limit > 0) then
            if (.not. mapping_is_set (tree%mapping(k))) then
               call mapping_init (tree%mapping(k), k, map_str)
               call mapping_set_step_mapping_parameters (tree%mapping(k), &
                    m_limit, w_limit, &
                    variable_limits)
            end if
         end if
         kk = tree%branch(k)%daughter
         m = tree%effective_mass(kk)
         w = tree%effective_width(kk)
         if (mapping_is_s_channel (tree%mapping(k))) then
            call set_step_mappings_x (kk(1), &
                 mapping_get_mass (tree%mapping(k)) - m(2), &
                 mapping_get_width (tree%mapping(k)) + w(2))
            call set_step_mappings_x (kk(2), &
                 mapping_get_mass (tree%mapping(k)) - m(1), &
                 mapping_get_width (tree%mapping(k)) + w(1))
         else if (m_limit > 0) then
            call set_step_mappings_x (kk(1), &
                 m_limit - m(2), &
                 w_limit + w(2))
            call set_step_mappings_x (kk(2), &
                 m_limit - m(1), &
                 w_limit + w(1))
         else
            call set_step_mappings_x (kk(1), &
                 - m(2), &
                 + w(2))
            call set_step_mappings_x (kk(2), &
                 - m(1), &
                 + w(1))
         end if
      end if
    end subroutine set_step_mappings_x
  end subroutine phs_tree_set_step_mappings

@ %def phs_tree_set_step_mappings
@ 
\subsubsection{Structural comparison}
This function allows to check whether one tree is the permutation of
another one.  The permutation is applied to the second tree in the
argument list.  We do not make up a temporary permuted tree, but
compare the two trees directly.  The branches are scanned recursively,
where for each daughter we check the friend and the mapping as well.
Once a discrepancy is found, the recursion is exited immediately.
<<PHS trees: public>>=
  public :: phs_tree_equivalent
<<PHS trees: procedures>>=
  function phs_tree_equivalent (t1, t2, perm) result (is_equal)
    type(phs_tree_t), intent(in) :: t1, t2
    type(permutation_t), intent(in) :: perm
    logical :: equal, is_equal
    integer(TC) :: k1, k2, mask_in
    k1 = t1%mask_out
    k2 = t2%mask_out
    mask_in = t1%mask_in
    equal = .true.
    call check (t1%branch(k1), t2%branch(k2), k1, k2)
    is_equal = equal
  contains
    recursive subroutine check (b1, b2, k1, k2)
      type(phs_branch_t), intent(in) :: b1, b2
      integer(TC), intent(in) :: k1, k2
      integer(TC), dimension(2) :: d1, d2, pd2
      integer :: i
      if (.not.b1%has_friend .and. .not.b2%has_friend) then
         equal = .true.
      else if (b1%has_friend .and. b2%has_friend) then
         equal = (b1%friend == tc_permute (b2%friend, perm, mask_in))
      end if
      if (equal) then
         if (b1%has_children .and. b2%has_children) then
            d1 = b1%daughter
            d2 = b2%daughter
            do i=1, 2
               pd2(i) = tc_permute (d2(i), perm, mask_in)
            end do
            if (d1(1)==pd2(1) .and. d1(2)==pd2(2)) then
               equal = (b1%firstborn == b2%firstborn)
               if (equal) call check &
                    &     (t1%branch(d1(1)), t2%branch(d2(1)), d1(1), d2(1))
               if (equal) call check &
                    &     (t1%branch(d1(2)), t2%branch(d2(2)), d1(2), d2(2))
            else if (d1(1)==pd2(2) .and. d1(2)==pd2(1)) then
               equal = ( (b1%firstborn == 0 .and. b2%firstborn == 0) &
                    &   .or. (b1%firstborn == 3 - b2%firstborn) )
               if (equal) call check &
                    &     (t1%branch(d1(1)), t2%branch(d2(2)), d1(1), d2(2))
               if (equal) call check &
                    &     (t1%branch(d1(2)), t2%branch(d2(1)), d1(2), d2(1))
            else
               equal = .false.
            end if
         end if
      end if
      if (equal) then
         equal = (t1%mapping(k1) == t2%mapping(k2))
      end if
    end subroutine check
  end function phs_tree_equivalent

@ %def phs_tree_equivalent
@ Scan two decay trees and determine the correspondence of mass
variables, i.e., the permutation that transfers the ordered list of
mass variables belonging to the second tree into the first one.  Mass
variables are assigned beginning from branches and ending at the root.
<<PHS trees: public>>=
  public :: phs_tree_find_msq_permutation
<<PHS trees: procedures>>=
  subroutine phs_tree_find_msq_permutation (tree1, tree2, perm2, msq_perm)
    type(phs_tree_t), intent(in) :: tree1, tree2
    type(permutation_t), intent(in) :: perm2
    type(permutation_t), intent(out) :: msq_perm
    type(permutation_t) :: perm1
    integer(TC) :: mask_in, root
    integer(TC), dimension(:), allocatable :: index1, index2
    integer :: i
    allocate (index1 (tree1%n_msq), index2 (tree2%n_msq))
    call permutation_init (perm1, permutation_size (perm2))
    mask_in = tree1%mask_in
    root = tree1%mask_out
    i = 0
    call tree_scan (tree1, root, perm1, index1)
    i = 0
    call tree_scan (tree2, root, perm2, index2)
    call permutation_find (msq_perm, index1, index2)
  contains
    recursive subroutine tree_scan (tree, k, perm, index)
      type(phs_tree_t), intent(in) :: tree
      integer(TC), intent(in) :: k
      type(permutation_t), intent(in) :: perm
      integer, dimension(:), intent(inout) :: index
      if (tree%branch(k)%has_children) then
         call tree_scan (tree, tree%branch(k)%daughter(1), perm, index)
         call tree_scan (tree, tree%branch(k)%daughter(2), perm, index)
         i = i + 1
         if (i <= size (index))  index(i) = tc_permute (k, perm, mask_in)
      end if
    end subroutine tree_scan
  end subroutine phs_tree_find_msq_permutation

@ %def phs_tree_find_msq_permutation
<<PHS trees: public>>=
  public :: phs_tree_find_angle_permutation
<<PHS trees: procedures>>=
  subroutine phs_tree_find_angle_permutation &
       (tree1, tree2, perm2, angle_perm, sig2)
    type(phs_tree_t), intent(in) :: tree1, tree2
    type(permutation_t), intent(in) :: perm2
    type(permutation_t), intent(out) :: angle_perm
    logical, dimension(:), allocatable, intent(out) :: sig2
    type(permutation_t) :: perm1
    integer(TC) :: mask_in, root
    integer(TC), dimension(:), allocatable :: index1, index2
    logical, dimension(:), allocatable :: sig1
    integer :: i
    allocate (index1 (tree1%n_angles), index2 (tree2%n_angles))
    allocate (sig1 (tree1%n_angles), sig2 (tree2%n_angles))
    call permutation_init (perm1, permutation_size (perm2))
    mask_in = tree1%mask_in
    root = tree1%mask_out
    i = 0
    call tree_scan (tree1, root, perm1, index1, sig1)
    i = 0
    call tree_scan (tree2, root, perm2, index2, sig2)
    call permutation_find (angle_perm, index1, index2)
  contains
    recursive subroutine tree_scan (tree, k, perm, index, sig)
      type(phs_tree_t), intent(in) :: tree
      integer(TC), intent(in) :: k
      type(permutation_t), intent(in) :: perm
      integer, dimension(:), intent(inout) :: index
      logical, dimension(:), intent(inout) :: sig
      integer(TC) :: k1, k2, kp
      logical :: s
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1)
         k2 = tree%branch(k)%daughter(2)
         s = (tc_permute(k1, perm, mask_in) < tc_permute(k2, perm, mask_in))
         kp = tc_permute (k, perm, mask_in)
         i = i + 1
         index(i) = kp
         sig(i) = s
         i = i + 1
         index(i) = - kp
         sig(i) = s
         call tree_scan (tree, k1, perm, index, sig)
         call tree_scan (tree, k2, perm, index, sig)
      end if
    end subroutine tree_scan
  end subroutine phs_tree_find_angle_permutation

@ %def phs_tree_find_angle_permutation
@
\subsection{Phase-space evaluation} 
\subsubsection{Phase-space volume}
We compute the phase-space volume recursively, following the same path
as for computing other kinematical variables.  However, the volume
depends just on $\sqrt{\hat s}$, not on the momentum configuration.

Note: counting branches, we may replace this by a simple formula.
<<PHS trees: public>>=
  public :: phs_tree_compute_volume
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_volume (tree, sqrts, volume)
    type(phs_tree_t), intent(in) :: tree
    real(default), intent(in) :: sqrts
    real(default), intent(out) :: volume
    integer(TC) :: k
    k  = tree%mask_out
    if (tree%branch(k)%has_children) then
       call compute_volume_x (tree%branch(k), k, volume, .true.)
    else
       volume = 1
    end if
  contains
    recursive subroutine compute_volume_x (b, k, volume, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: volume
      logical, intent(in) :: initial
      integer(TC) :: k1, k2
      real(default) :: v1, v2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call compute_volume_x (tree%branch(k1), k1, v1, .false.)
      else
         v1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call compute_volume_x (tree%branch(k2), k2, v2, .false.)
      else
         v2 = 1
      end if
      if (initial) then
         volume = v1 * v2 / (4 * twopi5)
      else
         volume = v1 * v2 * sqrts**2 / (4 * twopi2)
      end if
    end subroutine compute_volume_x
  end subroutine phs_tree_compute_volume

@ %def phs_tree_compute_volume
@ 
\subsubsection{Determine momenta}
This is done in two steps: First the masses are determined.  This step
may fail, in which case [[ok]] is set to false.  If successful, we
generate angles and the actual momenta.  The array [[decay_p]] serves
for transferring the individual three-momenta of the daughter
particles in their mother rest frame from the mass generation to the
momentum generation step.
<<PHS trees: public>>=
  public :: phs_tree_compute_momenta_from_x
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_momenta_from_x &
       (tree, prt, factor, volume, sqrts, x, ok)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(out) :: factor, volume
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    logical, intent(out) :: ok
    real(default), dimension(tree%mask_out) :: decay_p
    integer :: n1, n2
    integer :: n_out
    if (tree%real_phsp) then
      n_out = tree%n_externals - tree%n_in - 1
      n1 = max (n_out-2, 0)
      n2 = n1 + max (2*n_out, 0)
    else
      n1 = tree%n_msq
      n2 = n1 + tree%n_angles
    end if
    call phs_tree_set_msq &
         (tree, prt, factor, volume, decay_p, sqrts, x(1:n1), ok)
    if (ok) call phs_tree_set_angles &
         (tree, prt, factor, decay_p, sqrts, x(n1+1:n2))
  end subroutine phs_tree_compute_momenta_from_x

@ %def phs_tree_compute_momenta_from_x
@ Mass generation is done recursively.  The [[ok]] flag causes the
filled tree to be discarded if set to [[.false.]].  This happens if a
three-momentum turns out to be imaginary, indicating impossible
kinematics.  The index [[ix]] tells us how far we have used up the
input array [[x]].
<<PHS trees: procedures>>=
  subroutine phs_tree_set_msq &
       (tree, prt, factor, volume, decay_p, sqrts, x, ok)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(out) :: factor, volume
    real(default), dimension(:), intent(out) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    logical, intent(out) :: ok
    integer :: ix
    integer(TC) :: k
    real(default) :: m_tot
    ok =.true.
    ix = 1
    k  = tree%mask_out
    m_tot = tree%mass_sum(k)
    decay_p(k) = 0.
    if (m_tot < sqrts .or. k == 1) then
       if (tree%branch(k)%has_children) then
          call set_msq_x (tree%branch(k), k, factor, volume, .true.)
       else
          factor = 1
          volume = 1
       end if
    else
       ok = .false.
    end if
  contains
    recursive subroutine set_msq_x (b, k, factor, volume, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: factor, volume
      logical, intent(in) :: initial
      real(default) :: msq, m, m_min, m_max, m1, m2, msq1, msq2, lda, rlda
      integer(TC) :: k1, k2
      real(default) :: f1, f2, v1, v2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call set_msq_x (tree%branch(k1), k1, f1, v1, .false.)
         if (.not.ok) return
      else
         f1 = 1;  v1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call set_msq_x (tree%branch(k2), k2, f2, v2, .false.)
         if (.not.ok) return
      else
         f2 = 1;  v2 = 1
      end if
      m_min = tree%mass_sum(k)
      if (initial) then
         msq = sqrts**2
         m = sqrts
         m_max = sqrts
         factor = f1 * f2
         volume = v1 * v2 / (4 * twopi5)
      else
         m_max = sqrts - m_tot + m_min
         call mapping_compute_msq_from_x &
              (tree%mapping(k), sqrts**2, m_min**2, m_max**2, msq, factor, &
               x(ix)); ix = ix + 1
         if (msq >= 0) then
            m = sqrt (msq)
            factor = f1 * f2 * factor
            volume = v1 * v2 * sqrts**2 / (4 * twopi2)
            call phs_prt_set_msq (prt(k), msq)
            call phs_prt_set_defined (prt(k))
         else
            ok = .false.
         end if
      end if
      if (ok) then
         msq1 = phs_prt_get_msq (prt(k1));  m1 = sqrt (msq1)
         msq2 = phs_prt_get_msq (prt(k2));  m2 = sqrt (msq2)
         lda = lambda (msq, msq1, msq2)
         if (lda > 0 .and. m > m1 + m2 .and. m <= m_max) then
            rlda = sqrt (lda)
            decay_p(k1) = rlda / (2*m)
            decay_p(k2) = - decay_p(k1)
            factor = rlda / msq * factor
         else
            ok = .false.
         end if
      end if
    end subroutine set_msq_x

  end subroutine phs_tree_set_msq

@ %def phs_tree_set_msq
@ 
The heart of phase space generation: Now we have the invariant masses,
let us generate angles.  At each branch, we take a Lorentz
transformation and augment it by a boost to the current particle
rest frame, and by rotations $\phi$ and $\theta$ around the $z$ and
$y$ axis, respectively.  This transformation is passed down to the
daughter particles, if present.
<<PHS trees: procedures>>=
  subroutine phs_tree_set_angles (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    real(default), intent(inout) :: factor
    real(default), dimension(:), intent(in) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(in) :: x
    integer :: ix
    integer(TC) :: k
    ix = 1
    k  = tree%mask_out
    call set_angles_x (tree%branch(k), k)
  contains
    recursive subroutine set_angles_x (b, k, L0)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      type(lorentz_transformation_t), intent(in), optional :: L0
      real(default) :: m, msq, ct, st, phi, f, E, p, bg
      type(lorentz_transformation_t) :: L, LL
      integer(TC) :: k1, k2
      type(vector3_t) :: axis
      p = decay_p(k)
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      E = sqrt (msq + p**2)
      if (present (L0)) then
         call phs_prt_set_momentum (prt(k), L0 * vector4_moving (E,p,3))
      else
         call phs_prt_set_momentum (prt(k), vector4_moving (E,p,3))
      end if
      call phs_prt_set_defined (prt(k))
      if (b%has_children) then
         k1 = b%daughter(1)
         k2 = b%daughter(2)
         if (m > 0) then
            bg = p / m
         else
            bg = 0
         end if
         phi = x(ix) * twopi;  ix = ix + 1
         call mapping_compute_ct_from_x &
              (tree%mapping(k), sqrts**2, ct, st, f, x(ix));  ix = ix + 1
         factor = factor * f
         if (.not. b%has_friend) then
            L = LT_compose_r2_r3_b3 (ct, st, cos(phi), sin(phi), bg)
            !!! The function above is equivalent to:
            ! L = boost (bg,3) * rotation (phi,3) * rotation (ct,st,2)
         else
            LL = boost (-bg,3);  if (present (L0))  LL = LL * inverse(L0)
            axis = space_part ( &
                 LL * phs_prt_get_momentum (prt(tree%branch(k)%friend)) )
            L = boost(bg,3) * rotation_to_2nd (vector3_canonical(3), axis) &
                 * LT_compose_r2_r3_b3 (ct, st, cos(phi), sin(phi), 0._default)
         end if
         if (present (L0))  L = L0 * L
         call set_angles_x (tree%branch(k1), k1, L)
         call set_angles_x (tree%branch(k2), k2, L)
      end if
    end subroutine set_angles_x

  end subroutine phs_tree_set_angles

@ %def phs_tree_set_angles
@ 
\subsubsection{Recover random numbers}
For the other channels we want to compute the random numbers that
would have generated the momenta that we already know.
<<PHS trees: public>>=
  public :: phs_tree_compute_x_from_momenta
<<PHS trees: procedures>>=
  subroutine phs_tree_compute_x_from_momenta (tree, prt, factor, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(out) :: factor
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(inout) :: x
    real(default), dimension(tree%mask_out) :: decay_p
    integer :: n1, n2
    n1 = tree%n_msq
    n2 = n1 + tree%n_angles
    call phs_tree_get_msq &
         (tree, prt, factor, decay_p, sqrts, x(1:n1))
    call phs_tree_get_angles &
         (tree, prt, factor, decay_p, sqrts, x(n1+1:n2))
  end subroutine phs_tree_compute_x_from_momenta

@ %def phs_tree_compute_x_from_momenta
@ The inverse operation follows exactly the same steps.  The tree is
[[inout]] because it contains mappings whose parameters can be reset
when the mapping is applied.
<<PHS trees: procedures>>=
  subroutine phs_tree_get_msq (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(out) :: factor
    real(default), dimension(:), intent(out) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(inout) :: x
    integer :: ix
    integer(TC) :: k
    real(default) :: m_tot
    ix = 1
    k  = tree%mask_out
    m_tot = tree%mass_sum(k)
    decay_p(k) = 0.
    if (tree%branch(k)%has_children) then
       call get_msq_x (tree%branch(k), k, factor, .true.)
    else
       factor = 1
    end if
  contains
    recursive subroutine get_msq_x (b, k, factor, initial)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(out) :: factor
      logical, intent(in) :: initial
      real(default) :: msq, m, m_min, m_max, msq1, msq2, lda, rlda
      integer(TC) :: k1, k2
      real(default) :: f1, f2
      k1 = b%daughter(1);  k2 = b%daughter(2)
      if (tree%branch(k1)%has_children) then
         call get_msq_x (tree%branch(k1), k1, f1, .false.)
      else
         f1 = 1
      end if
      if (tree%branch(k2)%has_children) then
         call get_msq_x (tree%branch(k2), k2, f2, .false.)
      else
         f2 = 1
      end if
      m_min = tree%mass_sum(k)
      m_max = sqrts - m_tot + m_min
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      if (initial) then
         factor = f1 * f2
      else
         call mapping_compute_x_from_msq &
              (tree%mapping(k), sqrts**2, m_min**2, m_max**2, msq, factor, &
               x(ix));  ix = ix + 1
         factor = f1 * f2 * factor
      end if
      msq1 = phs_prt_get_msq (prt(k1))
      msq2 = phs_prt_get_msq (prt(k2))  
      lda = lambda (msq, msq1, msq2)
      if (lda > 0) then
         rlda = sqrt (lda)
         decay_p(k1) = rlda / (2 * m)
         decay_p(k2) = - decay_p(k1)
         factor = rlda / msq * factor
      else
         decay_p(k1) = 0
         decay_p(k2) = 0
         factor = 0
      end if
    end subroutine get_msq_x

  end subroutine phs_tree_get_msq

@ %def phs_tree_get_msq
@ This subroutine is the most time-critical part of the whole
program.  Therefore, we do not exactly parallel the angle generation
routine above but make sure that things get evaluated only if they are
really needed, at the expense of readability.  Particularly important
is to have as few multiplications of Lorentz transformations as
possible.
<<PHS trees: procedures>>=
  subroutine phs_tree_get_angles (tree, prt, factor, decay_p, sqrts, x)
    type(phs_tree_t), intent(inout) :: tree
    type(phs_prt_t), dimension(:), intent(in) :: prt
    real(default), intent(inout) :: factor
    real(default), dimension(:), intent(in) :: decay_p
    real(default), intent(in) :: sqrts
    real(default), dimension(:), intent(out) :: x
    integer :: ix
    integer(TC) :: k
    ix = 1
    k  = tree%mask_out
    if (tree%branch(k)%has_children) then
       call get_angles_x (tree%branch(k), k)
    end if
  contains
    recursive subroutine get_angles_x (b, k, ct0, st0, phi0, L0)
      type(phs_branch_t), intent(in) :: b
      integer(TC), intent(in) :: k
      real(default), intent(in), optional :: ct0, st0, phi0
      type(lorentz_transformation_t), intent(in), optional :: L0
      real(default) :: cp0, sp0, m, msq, ct, st, phi, bg, f
      type(lorentz_transformation_t) :: L, LL
      type(vector4_t) :: p1, pf
      type(vector3_t) :: n, axis
      integer(TC) :: k1, k2, kf
      logical :: has_friend, need_L
      k1 = b%daughter(1)
      k2 = b%daughter(2)
      kf = b%friend
      has_friend = b%has_friend
      if (present(L0)) then
         p1 = L0 * phs_prt_get_momentum (prt(k1))
         if (has_friend)  pf = L0 * phs_prt_get_momentum (prt(kf))
      else
         p1 = phs_prt_get_momentum (prt(k1))
         if (has_friend)  pf = phs_prt_get_momentum (prt(kf))
      end if
      if (present(phi0)) then
         cp0 = cos (phi0)
         sp0 = sin (phi0)
      end if
      msq = phs_prt_get_msq (prt(k));  m = sqrt (msq)
      if (m > 0) then
         bg = decay_p(k) / m
      else
         bg = 0
      end if
      if (has_friend) then
         if (present (phi0)) then
            axis = axis_from_p_r3_r2_b3 (pf, cp0, -sp0, ct0, -st0, -bg)
            LL = rotation_to_2nd (axis, vector3_canonical (3)) &
                 * LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg)
         else
            axis = axis_from_p_b3 (pf, -bg)
            LL = rotation_to_2nd (axis, vector3_canonical(3))
            if (bg /= 0)  LL = LL * boost(-bg, 3)
         end if
         n = space_part (LL * p1)
      else if (present (phi0)) then
         n = axis_from_p_r3_r2_b3 (p1, cp0, -sp0, ct0, -st0, -bg)
      else
         n = axis_from_p_b3 (p1, -bg)
      end if
      phi = azimuthal_angle (n)
      x(ix) = phi / twopi;  ix = ix + 1
      ct = polar_angle_ct (n)
      st = sqrt (1 - ct**2)
      call mapping_compute_x_from_ct (tree%mapping(k), sqrts**2, ct, f, &
           x(ix));  ix = ix + 1
      factor = factor * f
      if (tree%branch(k1)%has_children .or. tree%branch(k2)%has_children) then
         need_L = .true.
         if (has_friend) then
            if (present (L0)) then
               L = LL * L0
            else
               L = LL
            end if
         else if (present (L0)) then
            L = LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg) * L0
         else if (present (phi0)) then
            L = LT_compose_r3_r2_b3 (cp0, -sp0, ct0, -st0, -bg)
         else if (bg /= 0) then
            L = boost(-bg, 3)
         else
            need_L = .false.
         end if
         if (need_L) then
            if (tree%branch(k1)%has_children) &
                 call get_angles_x (tree%branch(k1), k1, ct, st, phi, L)
            if (tree%branch(k2)%has_children) &
                 call get_angles_x (tree%branch(k2), k2, ct, st, phi, L)
         else
            if (tree%branch(k1)%has_children) &
                 call get_angles_x (tree%branch(k1), k1, ct, st, phi)
            if (tree%branch(k2)%has_children) &
                 call get_angles_x (tree%branch(k2), k2, ct, st, phi)
         end if
      end if
    end subroutine get_angles_x
  end subroutine phs_tree_get_angles

@ %def phs_tree_get_angles
@ 
\subsubsection{Auxiliary stuff}
This calculates all momenta that are not yet known by summing up
daughter particle momenta.  The external particles must be known.
Only composite particles not yet known are calculated.
<<PHS trees: public>>=
  public :: phs_tree_combine_particles
<<PHS trees: procedures>>=
  subroutine phs_tree_combine_particles (tree, prt)
    type(phs_tree_t), intent(in) :: tree
    type(phs_prt_t), dimension(:), intent(inout) :: prt
    call combine_particles_x (tree%mask_out)
  contains
    recursive subroutine combine_particles_x (k)
      integer(TC), intent(in) :: k
      integer :: k1, k2
      if (tree%branch(k)%has_children) then
         k1 = tree%branch(k)%daughter(1);  k2 = tree%branch(k)%daughter(2)
         call combine_particles_x (k1)
         call combine_particles_x (k2)
         if (.not. prt(k)%defined) then
            call phs_prt_combine (prt(k), prt(k1), prt(k2))
         end if
      end if
    end subroutine combine_particles_x
  end subroutine phs_tree_combine_particles

@ %def phs_tree_combine_particles
@ The previous routine is to be evaluated at runtime.  Instead of
scanning trees, we can as well set up a multiplication table.  This is
generated here.  Note that the table is [[intent(out)]].
<<PHS trees: public>>=
  public :: phs_tree_setup_prt_combinations
<<PHS trees: procedures>>=
  subroutine phs_tree_setup_prt_combinations (tree, comb)
    type(phs_tree_t), intent(in) :: tree
    integer, dimension(:,:), intent(out) :: comb
    comb = 0
    call setup_prt_combinations_x (tree%mask_out)
  contains
    recursive subroutine setup_prt_combinations_x (k)
      integer(TC), intent(in) :: k
      integer, dimension(2) :: kk
      if (tree%branch(k)%has_children) then
         kk = tree%branch(k)%daughter
         call setup_prt_combinations_x (kk(1))
         call setup_prt_combinations_x (kk(2))
         comb(:,k) = kk
      end if
    end subroutine setup_prt_combinations_x
  end subroutine phs_tree_setup_prt_combinations
      
@ %def phs_tree_setup_prt_combinations
@
<<PHS trees: public>>=
  public :: phs_tree_reshuffle_mappings
<<PHS trees: procedures>>=
  subroutine phs_tree_reshuffle_mappings (tree)
   type(phs_tree_t), intent(inout) :: tree
   integer(TC) :: k0, k_old, k_new, k2
   integer :: i
   type(mapping_t) :: mapping_tmp
   real(default) :: mass_tmp
   do i = 1, size (tree%momentum_link)
     if (i /= tree%momentum_link (i)) then
       k_old = 2**(i-tree%n_in-1)
       k_new = 2**(tree%momentum_link(i)-tree%n_in-1)
       k0 = tree%branch(k_old)%mother
       k2 = k_new + tree%branch(k_old)%sibling
       mapping_tmp = tree%mapping(k0)
       mass_tmp = tree%mass_sum(k0)
       tree%mapping(k0) = tree%mapping(k2)
       tree%mapping(k2) = mapping_tmp
       tree%mass_sum(k0) = tree%mass_sum(k2)
       tree%mass_sum(k2) = mass_tmp
     end if
   end do
  end subroutine phs_tree_reshuffle_mappings

@ %def phs_tree_reshuffle_mappings
@
<<PHS trees: public>>=
  public :: phs_tree_set_momentum_links
<<PHS trees: procedures>>=
  subroutine phs_tree_set_momentum_links (tree, list)
    type(phs_tree_t), intent(inout) :: tree
    integer, dimension(:), allocatable :: list
    tree%momentum_link = list
  end subroutine phs_tree_set_momentum_links

@ %def phs_tree_set_momentum_links
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{The phase-space forest}
Simply stated, a phase-space forest is a collection of phase-space
trees.  More precisely, a [[phs_forest]] object contains all
parameterizations of phase space that \whizard\ will use for a single
hard process, prepared in the form of [[phs_tree]] objects.  This is
suitable for evaluation by the \vamp\ integration package:  each
parameterization (tree) is a valid channel in the multi-channel
adaptive integration, and each variable in a tree corresponds to an
integration dimension, defined by an appropriate mapping of the
$(0,1)$ interval to the allowed range of the integration variable.

The trees are grouped in groves.  The trees (integration channels)
within a grove share a common weight, assuming that they are related
by some approximate symmetry.

Trees/channels that are related by an exact symmetry are connected by
an array of equivalences; each equivalence object holds the data that
relate one channel to another.

The phase-space setup, i.e., the detailed structure of trees and
forest, are read from a file.  Therefore, this module also contains
the syntax definition and the parser needed for interpreting this
file.
<<[[phs_forests.f90]]>>=
<<File header>>

module phs_forests

<<Use kinds>>
  use kinds, only: TC
<<Use strings>>
  use io_units
  use format_defs, only: FMT_19
  use diagnostics
  use lorentz
  use unit_tests
  use permutations
  use ifiles
  use syntax_rules
  use lexers
  use parser
  use model_data
  use model_data
  use flavors
  use interactions

  use phs_base
  use mappings
  use phs_trees

<<Standard module head>>

<<PHS forests: public>>

<<PHS forests: types>>

<<PHS forests: interfaces>>

<<PHS forests: variables>>

contains

<<PHS forests: procedures>>

end module phs_forests
@ %def phs_forests
@ 
\subsection{Phase-space setup parameters}
This transparent container holds the parameters that the algorithm
needs for phase-space setup, with reasonable defaults.

The threshold mass (for considering a particle as effectively
massless) is specified separately for s- and t-channel. The default is
to treat $W$ and $Z$ bosons as massive in the s-channel, but as
massless in the t-channel.  The $b$-quark is treated always massless,
the $t$-quark always massive.
<<PHS forests: public>>=
  public :: phs_parameters_t
<<PHS forests: types>>=
  type :: phs_parameters_t
     real(default) :: sqrts = 0
     real(default) :: m_threshold_s = 50._default
     real(default) :: m_threshold_t = 100._default
     integer :: off_shell = 1
     integer :: t_channel = 2
     logical :: keep_nonresonant = .true.
  end type phs_parameters_t

@ %def phs_parameters_t
@ Write phase-space parameters to file.
<<PHS forests: public>>=
  public :: phs_parameters_write
<<PHS forests: procedures>>=
  subroutine phs_parameters_write (phs_par, unit)
    type(phs_parameters_t), intent(in) :: phs_par
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A," // FMT_19 // ")") "sqrts         = ", phs_par%sqrts
    write (u, "(3x,A," // FMT_19 // ")") "m_threshold_s = ", phs_par%m_threshold_s
    write (u, "(3x,A," // FMT_19 // ")") "m_threshold_t = ", phs_par%m_threshold_t
    write (u, "(3x,A,I0)") "off_shell = ", phs_par%off_shell
    write (u, "(3x,A,I0)") "t_channel = ", phs_par%t_channel
    write (u, "(3x,A,L1)") "keep_nonresonant = ", phs_par%keep_nonresonant
  end subroutine phs_parameters_write

@ %def phs_parameters_write
@ Read phase-space parameters from file.
<<PHS forests: public>>=
  public :: phs_parameters_read
<<PHS forests: procedures>>=
  subroutine phs_parameters_read (phs_par, unit)
    type(phs_parameters_t), intent(out) :: phs_par
    integer, intent(in) :: unit
    character(20) :: dummy
    character :: equals
    read (unit, *)  dummy, equals, phs_par%sqrts
    read (unit, *)  dummy, equals, phs_par%m_threshold_s
    read (unit, *)  dummy, equals, phs_par%m_threshold_t
    read (unit, *)  dummy, equals, phs_par%off_shell
    read (unit, *)  dummy, equals, phs_par%t_channel
    read (unit, *)  dummy, equals, phs_par%keep_nonresonant
  end subroutine phs_parameters_read

@ %def phs_parameters_write
@ Comparison.
<<PHS forests: interfaces>>=
  interface operator(==)
     module procedure phs_parameters_eq
  end interface
  interface operator(/=)
     module procedure phs_parameters_ne
  end interface
<<PHS forests: procedures>>=
  function phs_parameters_eq (phs_par1, phs_par2) result (equal)
    logical :: equal
    type(phs_parameters_t), intent(in) :: phs_par1, phs_par2
    equal = phs_par1%sqrts == phs_par2%sqrts &
         .and. phs_par1%m_threshold_s == phs_par2%m_threshold_s &
         .and. phs_par1%m_threshold_t == phs_par2%m_threshold_t &
         .and. phs_par1%off_shell == phs_par2%off_shell &
         .and. phs_par1%t_channel == phs_par2%t_channel &
	 .and.(phs_par1%keep_nonresonant .eqv. phs_par2%keep_nonresonant)
  end function phs_parameters_eq

  function phs_parameters_ne (phs_par1, phs_par2) result (ne)
    logical :: ne
    type(phs_parameters_t), intent(in) :: phs_par1, phs_par2
    ne = phs_par1%sqrts /= phs_par2%sqrts &
         .or. phs_par1%m_threshold_s /= phs_par2%m_threshold_s &
         .or. phs_par1%m_threshold_t /= phs_par2%m_threshold_t &
         .or. phs_par1%off_shell /= phs_par2%off_shell &
         .or. phs_par1%t_channel /= phs_par2%t_channel &
	 .or.(phs_par1%keep_nonresonant .neqv. phs_par2%keep_nonresonant)
  end function phs_parameters_ne

@ %def phs_parameters_eq phs_parameters_ne
@ 
\subsection{Equivalences}
This type holds information about equivalences between phase-space
trees.  We make a linked list, where each node contains the two
trees which are equivalent and the corresponding permutation of
external particles.  Two more arrays are to be filled: The permutation
of mass variables and the permutation of angular variables, where the
signature indicates a necessary exchange of daughter branches.
<<PHS forests: types>>=
  type :: equivalence_t
     private
     integer :: left, right
     type(permutation_t) :: perm
     type(permutation_t) :: msq_perm, angle_perm
     logical, dimension(:), allocatable :: angle_sig
     type(equivalence_t), pointer :: next => null ()
  end type equivalence_t

@ %def equivalence_t
<<PHS forests: types>>=
  type :: equivalence_list_t
     private
     integer :: length = 0
     type(equivalence_t), pointer :: first => null ()
     type(equivalence_t), pointer :: last => null ()
  end type equivalence_list_t

@ %def equivalence_list_t
@ Append an equivalence to the list
<<PHS forests: procedures>>=
  subroutine equivalence_list_add (eql, left, right, perm)
    type(equivalence_list_t), intent(inout) :: eql
    integer, intent(in) :: left, right
    type(permutation_t), intent(in) :: perm
    type(equivalence_t), pointer :: eq
    allocate (eq)
    eq%left = left
    eq%right = right
    eq%perm = perm
    if (associated (eql%last)) then
       eql%last%next => eq
    else
       eql%first => eq
    end if
    eql%last => eq
    eql%length = eql%length + 1
  end subroutine equivalence_list_add

@ %def equivalence_list_add
@ Delete the list contents.  Has to be pure because it is called from
an elemental subroutine.
<<PHS forests: procedures>>=
  pure subroutine equivalence_list_final (eql)
    type(equivalence_list_t), intent(inout) :: eql
    type(equivalence_t), pointer :: eq
    do while (associated (eql%first))
       eq => eql%first
       eql%first => eql%first%next
       deallocate (eq)
    end do
    eql%last => null ()
    eql%length = 0
  end subroutine equivalence_list_final

@ %def equivalence_list_final
@ Make a deep copy of the equivalence list.  This allows for deep
copies of groves and forests.
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure equivalence_list_assign
  end interface

<<PHS forests: procedures>>=
  subroutine equivalence_list_assign (eql_out, eql_in)
    type(equivalence_list_t), intent(out) :: eql_out
    type(equivalence_list_t), intent(in) :: eql_in
    type(equivalence_t), pointer :: eq, eq_copy
    eq => eql_in%first
    do while (associated (eq))
       allocate (eq_copy)
       eq_copy = eq
       eq_copy%next => null ()
       if (associated (eql_out%first)) then
          eql_out%last%next => eq_copy
       else
          eql_out%first => eq_copy
       end if
       eql_out%last => eq_copy
       eq => eq%next
    end do
  end subroutine equivalence_list_assign

@ %def equivalence_list_assign
@ The number of list entries
<<PHS forests: procedures>>=
  elemental function equivalence_list_length (eql) result (length)
    integer :: length
    type(equivalence_list_t), intent(in) :: eql
    length = eql%length
  end function equivalence_list_length

@ %def equivalence_list_length
@ Recursively write the equivalences list
<<PHS forests: procedures>>=
  subroutine equivalence_list_write (eql, unit)
    type(equivalence_list_t), intent(in) :: eql
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    if (associated (eql%first)) then
       call equivalence_write_rec (eql%first, u)
    else
       write (u, *) " [empty]"
    end if
  contains
    recursive subroutine equivalence_write_rec (eq, u)
      type(equivalence_t), intent(in) :: eq
      integer, intent(in) :: u
      integer :: i
      write (u, "(3x,A,1x,I0,1x,I0,2x,A)", advance="no") &
           "Equivalence:", eq%left, eq%right, "Final state permutation:"
      call permutation_write (eq%perm, u)
      write (u, "(1x,12x,1x,A,1x)", advance="no") &
           "       msq permutation:  "
      call permutation_write (eq%msq_perm, u)
      write (u, "(1x,12x,1x,A,1x)", advance="no") &
           "       angle permutation:"
      call permutation_write (eq%angle_perm, u)
      write (u, "(1x,12x,1x,26x)", advance="no")
      do i = 1, size (eq%angle_sig)
         if (eq%angle_sig(i)) then
            write (u, "(1x,A)", advance="no") "+"
         else
            write (u, "(1x,A)", advance="no") "-"
         end if
      end do
      write (u, *) 
      if (associated (eq%next))  call equivalence_write_rec (eq%next, u)
    end subroutine equivalence_write_rec
  end subroutine equivalence_list_write

@ %def equivalence_list_write
@ 
\subsection{Groves}
A grove is a group of trees (phase-space channels) that share a common
weight in the integration.  Within a grove, channels can be declared
equivalent, so they also share their integration grids (up to
symmetries).  The grove contains a list of equivalences.  The
[[tree_count_offset]] is the total number of trees of the preceding
groves; when the trees are counted per forest (integration channels),
the offset has to be added to all tree indices.
<<PHS forests: types>>=
  type :: phs_grove_t
     private
     integer :: tree_count_offset
     type(phs_tree_t), dimension(:), allocatable :: tree
     type(equivalence_list_t) :: equivalence_list
  end type phs_grove_t

@ %def phs_grove_t
@ Call [[phs_tree_init]] which is also elemental:
<<PHS forests: procedures>>=
  elemental subroutine phs_grove_init &
       (grove, n_trees, n_in, n_out, n_masses, n_angles)
    type(phs_grove_t), intent(inout) :: grove
    integer, intent(in) :: n_trees, n_in, n_out, n_masses, n_angles
    grove%tree_count_offset = 0
    allocate (grove%tree (n_trees))
    call phs_tree_init (grove%tree, n_in, n_out, n_masses, n_angles)
  end subroutine phs_grove_init

@ %def phs_grove_init
@ The trees do not have pointer components, thus no call to
[[phs_tree_final]]:
<<PHS forests: procedures>>=
  elemental subroutine phs_grove_final (grove)
    type(phs_grove_t), intent(inout) :: grove
    deallocate (grove%tree)
    call equivalence_list_final (grove%equivalence_list)
  end subroutine phs_grove_final

@ %def phs_grove_final
@ Deep copy.
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure phs_grove_assign0
     module procedure phs_grove_assign1
  end interface

<<PHS forests: procedures>>=
  subroutine phs_grove_assign0 (grove_out, grove_in)
    type(phs_grove_t), intent(out) :: grove_out
    type(phs_grove_t), intent(in) :: grove_in
    grove_out%tree_count_offset = grove_in%tree_count_offset
    if (allocated (grove_in%tree)) then
       allocate (grove_out%tree (size (grove_in%tree)))
       grove_out%tree = grove_in%tree
    end if
    grove_out%equivalence_list = grove_in%equivalence_list
  end subroutine phs_grove_assign0

  subroutine phs_grove_assign1 (grove_out, grove_in)
    type(phs_grove_t), dimension(:), intent(out) :: grove_out
    type(phs_grove_t), dimension(:), intent(in) :: grove_in
    integer :: i
    do i = 1, size (grove_in)
       call phs_grove_assign0 (grove_out(i), grove_in(i))
    end do
  end subroutine phs_grove_assign1

@ %def phs_grove_assign
@ Get the global (s-channel) mappings.  Implemented as a subroutine
which returns an array (slice).
<<PHS forests: procedures>>=
  subroutine phs_grove_assign_s_mappings (grove, mapping)
    type(phs_grove_t), intent(in) :: grove
    type(mapping_t), dimension(:), intent(out) :: mapping
    integer :: i
    if (size (mapping) == size (grove%tree)) then
       do i = 1, size (mapping)
          call phs_tree_assign_s_mapping (grove%tree(i), mapping(i))
       end do
    else
       call msg_bug ("phs_grove_assign_s_mappings: array size mismatch")
    end if
  end subroutine phs_grove_assign_s_mappings

@ %def phs_grove_assign_s_mappings
@
\subsection{The forest type}
This is a collection of trees and associated particles.  In a given
tree, each branch code corresponds to a particle in the [[prt]] array.
Furthermore, we have an array of mass sums which is independent of the
decay tree and of the particular event.  The mappings directly
correspond to the decay trees, and the decay groves collect the trees
in classes.  The permutation list consists of all permutations of
outgoing particles that map the decay forest onto itself.

The particle codes [[flv]] (one for each external particle) are needed
for determining masses and such.  The trees and associated information
are collected in the [[grove]] array, together with a lookup table
that associates tree indices to groves.  Finally, the [[prt]] array
serves as workspace for phase-space evaluation.

The [[prt_combination]] is a list of index pairs, namely the particle
momenta pairs that need to be combined in order to provide all
momentum combinations that the phase-space trees need to know.
<<PHS forests: public>>=
  public :: phs_forest_t
<<PHS forests: types>>=
  type :: phs_forest_t
     private
     integer :: n_in, n_out, n_tot
     integer :: n_masses, n_angles, n_dimensions
     integer :: n_trees, n_equivalences
     type(flavor_t), dimension(:), allocatable :: flv
     type(phs_grove_t), dimension(:), allocatable :: grove
     integer, dimension(:), allocatable :: grove_lookup
     type(phs_prt_t), dimension(:), allocatable :: prt_in
     type(phs_prt_t), dimension(:), allocatable :: prt_out
     type(phs_prt_t), dimension(:), allocatable :: prt
     integer(TC), dimension(:,:), allocatable :: prt_combination
     type(mapping_t), dimension(:), allocatable :: s_mapping
   contains
   <<PHS forests: phs forest: TBP>>
  end type phs_forest_t

@ %def phs_forest_t
@ 
The initialization merely allocates memory.  We have to know how many
trees there are in each grove, so we can initialize everything.  The
number of groves is the size of the [[n_tree]] array.

In the [[grove_lookup]] table we store the grove index that belongs to
each absolute tree index.  The difference between the absolute index
and the relative (to the grove) index is stored, for each grove, as
[[tree_count_offset]].

The particle array is allocated according to the total number of
branches each tree has, but not filled.
<<PHS forests: public>>=
  public :: phs_forest_init
<<PHS forests: procedures>>=
  subroutine phs_forest_init (forest, n_tree, n_in, n_out)
    type(phs_forest_t), intent(inout) :: forest
    integer, dimension(:), intent(in) :: n_tree
    integer, intent(in) :: n_in, n_out
    integer :: g, count, k_root
    forest%n_in = n_in
    forest%n_out = n_out
    forest%n_tot = n_in + n_out
    forest%n_masses = max (n_out - 2, 0)
    forest%n_angles = max (2*n_out - 2, 0)
    forest%n_dimensions = forest%n_masses + forest%n_angles
    forest%n_trees = sum (n_tree)
    forest%n_equivalences = 0
    allocate (forest%grove (size (n_tree)))
    call phs_grove_init &
         (forest%grove, n_tree, n_in, n_out, forest%n_masses, &
          forest%n_angles)
    allocate (forest%grove_lookup (forest%n_trees))
    count = 0
    do g = 1, size (forest%grove)
       forest%grove(g)%tree_count_offset = count
       forest%grove_lookup (count+1:count+n_tree(g)) = g
       count = count + n_tree(g)
    end do
    allocate (forest%prt_in  (n_in))
    allocate (forest%prt_out (forest%n_out))
    k_root = 2**forest%n_tot - 1
    allocate (forest%prt (k_root))
    allocate (forest%prt_combination (2, k_root))
    allocate (forest%s_mapping (forest%n_trees))
  end subroutine phs_forest_init

@ %def phs_forest_init
@ Assign the global (s-channel) mappings.
<<PHS forests: public>>=
  public :: phs_forest_set_s_mappings
<<PHS forests: procedures>>=
  subroutine phs_forest_set_s_mappings (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: g, i0, i1, n
    do g = 1, size (forest%grove)
       call phs_forest_get_grove_bounds (forest, g, i0, i1, n)
       call phs_grove_assign_s_mappings &
            (forest%grove(g), forest%s_mapping(i0:i1))
    end do
  end subroutine phs_forest_set_s_mappings

@ %def phs_forest_set_s_mappings
@ The grove finalizer is called because it contains the equivalence list:
<<PHS forests: public>>=
  public :: phs_forest_final
<<PHS forests: procedures>>=
  subroutine phs_forest_final (forest)
    type(phs_forest_t), intent(inout) :: forest
    if (allocated (forest%grove)) then
       call phs_grove_final (forest%grove)
       deallocate (forest%grove)
    end if
    if (allocated (forest%grove_lookup))  deallocate (forest%grove_lookup)
    if (allocated (forest%prt))  deallocate (forest%prt)
    if (allocated (forest%s_mapping))  deallocate (forest%s_mapping)
  end subroutine phs_forest_final

@ %def phs_forest_final
@ 
\subsection{Screen output}
Write the particles that are non-null, then the trees which point to
them:
<<PHS forests: public>>=
  public :: phs_forest_write
<<PHS forests: phs forest: TBP>>=
  procedure :: write => phs_forest_write
<<PHS forests: procedures>>=
  subroutine phs_forest_write (forest, unit)
    class(phs_forest_t), intent(in) :: forest
    integer, intent(in), optional :: unit
    integer :: u
    integer :: i, g, k
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)") "Phase space forest:"
    write (u, "(3x,A,I0)") "n_in  = ", forest%n_in
    write (u, "(3x,A,I0)") "n_out = ", forest%n_out
    write (u, "(3x,A,I0)") "n_tot = ", forest%n_tot
    write (u, "(3x,A,I0)") "n_masses = ", forest%n_masses
    write (u, "(3x,A,I0)") "n_angles = ", forest%n_angles
    write (u, "(3x,A,I0)") "n_dim    = ", forest%n_dimensions
    write (u, "(3x,A,I0)") "n_trees  = ", forest%n_trees
    write (u, "(3x,A,I0)") "n_equiv  = ", forest%n_equivalences
    write (u, "(3x,A)", advance="no") "flavors  ="
    if (allocated (forest%flv)) then
       do i = 1, size (forest%flv)
          write (u, "(1x,I0)", advance="no")  forest%flv(i)%get_pdg ()
       end do
       write (u, "(A)")
    else
       write (u, "(1x,A)") "[empty]"
    end if
    write (u, "(1x,A)") "Particle combinations:"
    if (allocated (forest%prt_combination)) then
       do k = 1, size (forest%prt_combination, 2)
          if (forest%prt_combination(1, k) /= 0) then
             write (u, "(3x,I0,1x,'<=',1x,I0,1x,'+',1x,I0)") &
                  k, forest%prt_combination(:,k)
          end if
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(1x,A)") "Groves and trees:"
    if (allocated (forest%grove)) then
       do g = 1, size (forest%grove)
          write (u, "(3x,A,1x,I0)") "Grove    ", g
          call phs_grove_write (forest%grove(g), unit)
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(1x,A,I0)") "Total number of equivalences: ", &
         forest%n_equivalences
    write (u, "(A)")
    write (u, "(1x,A)") "Global s-channel mappings:"
    if (allocated (forest%s_mapping)) then
       do i = 1, size (forest%s_mapping)
          associate (mapping => forest%s_mapping(i))
            if (mapping_is_s_channel (mapping) &
                 .or. mapping_is_on_shell (mapping)) then
               write (u, "(1x,I0,':',1x)", advance="no")  i
               call mapping_write (forest%s_mapping(i), unit)
            end if
          end associate
       end do
    else
       write (u, "(3x,A)") "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Incoming particles:"
    if (allocated (forest%prt_in)) then
       if (any (phs_prt_is_defined (forest%prt_in))) then
          do i = 1, size (forest%prt_in)
             if (phs_prt_is_defined (forest%prt_in(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt_in(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(3x,A)")  "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Outgoing particles:"
    if (allocated (forest%prt_out)) then
       if (any (phs_prt_is_defined (forest%prt_out))) then
          do i = 1, size (forest%prt_out)
             if (phs_prt_is_defined (forest%prt_out(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt_out(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(1x,A)")  "  [empty]"
    end if
    write (u, "(A)")
    write (u, "(1x,A)") "Tree particles:"
    if (allocated (forest%prt)) then
       if (any (phs_prt_is_defined (forest%prt))) then
          do i = 1, size (forest%prt)
             if (phs_prt_is_defined (forest%prt(i))) then
                write (u, "(1x,A,1x,I0)")  "Particle", i
                call phs_prt_write (forest%prt(i), u)
             end if
          end do
       else
          write (u, "(3x,A)")  "[all undefined]"
       end if
    else
       write (u, "(3x,A)")  "  [empty]"
    end if
  end subroutine phs_forest_write

  subroutine phs_grove_write (grove, unit)
    type(phs_grove_t), intent(in) :: grove
    integer, intent(in), optional :: unit
    integer :: u
    integer :: t
    u = given_output_unit (unit);  if (u < 0)  return
    do t = 1, size (grove%tree)
       write (u, "(3x,A,I0)") "Tree      ", t
       call phs_tree_write (grove%tree(t), unit)
    end do
    write (u, "(1x,A)") "Equivalence list:"
    call equivalence_list_write (grove%equivalence_list, unit)
  end subroutine phs_grove_write

@ %def phs_grove_write phs_forest_write
@ Deep copy.
<<PHS forests: public>>=
  public :: assignment(=)
<<PHS forests: interfaces>>=
  interface assignment(=)
     module procedure phs_forest_assign
  end interface

<<PHS forests: procedures>>=
  subroutine phs_forest_assign (forest_out, forest_in)
    type(phs_forest_t), intent(out) :: forest_out
    type(phs_forest_t), intent(in) :: forest_in
    forest_out%n_in  = forest_in%n_in
    forest_out%n_out = forest_in%n_out
    forest_out%n_tot = forest_in%n_tot
    forest_out%n_masses = forest_in%n_masses
    forest_out%n_angles = forest_in%n_angles
    forest_out%n_dimensions  = forest_in%n_dimensions
    forest_out%n_trees  = forest_in%n_trees
    forest_out%n_equivalences  = forest_in%n_equivalences
    if (allocated (forest_in%flv)) then
       allocate (forest_out%flv (size (forest_in%flv)))
       forest_out%flv = forest_in%flv
    end if
    if (allocated (forest_in%grove)) then
       allocate (forest_out%grove (size (forest_in%grove)))
       forest_out%grove = forest_in%grove
    end if
    if (allocated (forest_in%grove_lookup)) then
       allocate (forest_out%grove_lookup (size (forest_in%grove_lookup)))
       forest_out%grove_lookup = forest_in%grove_lookup
    end if
    if (allocated (forest_in%prt_in)) then
       allocate (forest_out%prt_in (size (forest_in%prt_in)))
       forest_out%prt_in = forest_in%prt_in
    end if
    if (allocated (forest_in%prt_out)) then
       allocate (forest_out%prt_out (size (forest_in%prt_out)))
       forest_out%prt_out = forest_in%prt_out
    end if
    if (allocated (forest_in%prt)) then
       allocate (forest_out%prt (size (forest_in%prt)))
       forest_out%prt = forest_in%prt
    end if
    if (allocated (forest_in%s_mapping)) then
       allocate (forest_out%s_mapping (size (forest_in%s_mapping)))
       forest_out%s_mapping = forest_in%s_mapping
    end if
    if (allocated (forest_in%prt_combination)) then
       allocate (forest_out%prt_combination &
            (2, size (forest_in%prt_combination, 2)))
       forest_out%prt_combination = forest_in%prt_combination
    end if
  end subroutine phs_forest_assign

@ %def phs_forest_assign
@ 
\subsection{Accessing contents}
Get the number of integration parameters
<<PHS forests: public>>=
  public :: phs_forest_get_n_parameters
<<PHS forests: procedures>>=
  function phs_forest_get_n_parameters (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_dimensions
  end function phs_forest_get_n_parameters

@ %def phs_forest_get_n_parameters
@ Get the number of integration channels
<<PHS forests: public>>=
  public :: phs_forest_get_n_channels
<<PHS forests: procedures>>=
  function phs_forest_get_n_channels (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_trees
  end function phs_forest_get_n_channels

@ %def phs_forest_get_n_channels
@ Get the number of groves
<<PHS forests: public>>=
  public :: phs_forest_get_n_groves
<<PHS forests: procedures>>=
  function phs_forest_get_n_groves (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = size (forest%grove)
  end function phs_forest_get_n_groves

@ %def phs_forest_get_n_groves
@ Get the index bounds for a specific grove.
<<PHS forests: public>>=
  public :: phs_forest_get_grove_bounds
<<PHS forests: procedures>>=
  subroutine phs_forest_get_grove_bounds (forest, g, i0, i1, n)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: g
    integer, intent(out) :: i0, i1, n
    n = size (forest%grove(g)%tree)
    i0 = forest%grove(g)%tree_count_offset + 1
    i1 = forest%grove(g)%tree_count_offset + n
  end subroutine phs_forest_get_grove_bounds

@ %def phs_forest_get_grove_bounds
@ Get the number of equivalences
<<PHS forests: public>>=
  public :: phs_forest_get_n_equivalences
<<PHS forests: procedures>>=
  function phs_forest_get_n_equivalences (forest) result (n)
    integer :: n
    type(phs_forest_t), intent(in) :: forest
    n = forest%n_equivalences
  end function phs_forest_get_n_equivalences

@ %def phs_forest_get_n_equivalences
@ Return true if a particular channel has a global (s-channel)
mapping; also return the resonance mass and width for this mapping.
<<PHS forests: public>>=
  public :: phs_forest_get_s_mapping
  public :: phs_forest_get_on_shell
<<PHS forests: procedures>>=
  subroutine phs_forest_get_s_mapping (forest, channel, flag, mass, width)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: channel
    logical, intent(out) :: flag
    real(default), intent(out) :: mass, width
    flag = mapping_is_s_channel (forest%s_mapping(channel))
    if (flag) then
       mass = mapping_get_mass (forest%s_mapping(channel))
       width = mapping_get_width (forest%s_mapping(channel))
    else
       mass = 0
       width = 0
    end if
  end subroutine phs_forest_get_s_mapping

  subroutine phs_forest_get_on_shell (forest, channel, flag, mass)
    type(phs_forest_t), intent(in) :: forest
    integer, intent(in) :: channel
    logical, intent(out) :: flag
    real(default), intent(out) :: mass
    flag = mapping_is_on_shell (forest%s_mapping(channel))
    if (flag) then
       mass = mapping_get_mass (forest%s_mapping(channel))
    else
       mass = 0
    end if
  end subroutine phs_forest_get_on_shell

@ %def phs_forest_get_s_mapping
@ %def phs_forest_get_on_shell
@ 
\subsection{Read the phase space setup from file}
The phase space setup is stored in a file.  The file may be generated
by the [[cascades]] module below, or by other means.  This file has to
be read and parsed to create the PHS forest as the internal
phase-space representation.

Create lexer and syntax:
<<PHS forests: procedures>>=
  subroutine define_phs_forest_syntax (ifile)
    type(ifile_t) :: ifile
    call ifile_append (ifile, "SEQ phase_space_list = process_phase_space*")
    call ifile_append (ifile, "SEQ process_phase_space = " &
         // "process_def process_header phase_space")
    call ifile_append (ifile, "SEQ process_def = process process_list")
    call ifile_append (ifile, "KEY process")
    call ifile_append (ifile, "LIS process_list = process_tag*")
    call ifile_append (ifile, "IDE process_tag")
    call ifile_append (ifile, "SEQ process_header = " &
         // "md5sum_process = md5sum " &
         // "md5sum_model_par = md5sum " &
         // "md5sum_phs_config = md5sum " &
         // "sqrts = real " &
         // "m_threshold_s = real " &
         // "m_threshold_t = real " &
         // "off_shell = integer " &
         // "t_channel = integer " &
         // "keep_nonresonant = logical")
    call ifile_append (ifile, "KEY '='")
    call ifile_append (ifile, "KEY md5sum_process")
    call ifile_append (ifile, "KEY md5sum_model_par")
    call ifile_append (ifile, "KEY md5sum_phs_config")
    call ifile_append (ifile, "KEY sqrts")
    call ifile_append (ifile, "KEY m_threshold_s")
    call ifile_append (ifile, "KEY m_threshold_t")
    call ifile_append (ifile, "KEY off_shell")
    call ifile_append (ifile, "KEY t_channel")
    call ifile_append (ifile, "KEY keep_nonresonant")
    call ifile_append (ifile, "QUO md5sum = '""' ... '""'")
    call ifile_append (ifile, "REA real")
    call ifile_append (ifile, "INT integer")
    call ifile_append (ifile, "IDE logical")
    call ifile_append (ifile, "SEQ phase_space = grove_def+")
    call ifile_append (ifile, "SEQ grove_def = grove tree_def+")
    call ifile_append (ifile, "KEY grove")
    call ifile_append (ifile, "SEQ tree_def = tree bincodes mapping*")
    call ifile_append (ifile, "KEY tree")
    call ifile_append (ifile, "SEQ bincodes = bincode*")
    call ifile_append (ifile, "INT bincode")
    call ifile_append (ifile, "SEQ mapping = map bincode channel pdg")
    call ifile_append (ifile, "KEY map")
    call ifile_append (ifile, "ALT channel = &
         &s_channel | t_channel | u_channel | &
         &collinear | infrared | radiation | on_shell")
    call ifile_append (ifile, "KEY s_channel")
    ! call ifile_append (ifile, "KEY t_channel")   !!! Key already exists
    call ifile_append (ifile, "KEY u_channel")
    call ifile_append (ifile, "KEY collinear")
    call ifile_append (ifile, "KEY infrared")
    call ifile_append (ifile, "KEY radiation")
    call ifile_append (ifile, "KEY on_shell")
    call ifile_append (ifile, "INT pdg")
  end subroutine define_phs_forest_syntax

@ %def define_phs_forest_syntax
@ The model-file syntax and lexer are fixed, therefore stored as
module variables:
<<PHS forests: variables>>=
  type(syntax_t), target, save :: syntax_phs_forest

@ %def syntax_phs_forest
<<PHS forests: public>>=
  public :: syntax_phs_forest_init
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_init ()
    type(ifile_t) :: ifile
    call define_phs_forest_syntax (ifile)
    call syntax_init (syntax_phs_forest, ifile)
    call ifile_final (ifile)
  end subroutine syntax_phs_forest_init

@ %def syntax_phs_forest_init
<<PHS forests: procedures>>=
  subroutine lexer_init_phs_forest (lexer)
    type(lexer_t), intent(out) :: lexer
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "", &
         special_class = ["="] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_phs_forest))
  end subroutine lexer_init_phs_forest

@ %def lexer_init_phs_forest
<<PHS forests: public>>=
  public :: syntax_phs_forest_final
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_final ()
    call syntax_final (syntax_phs_forest)
  end subroutine syntax_phs_forest_final

@ %def syntax_phs_forest_final
<<PHS forests: public>>=
  public :: syntax_phs_forest_write
<<PHS forests: procedures>>=
  subroutine syntax_phs_forest_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_phs_forest, unit)
  end subroutine syntax_phs_forest_write

@ %def syntax_phs_forest_write
@ The concrete parser and interpreter.  Generate an input stream for
the external [[unit]], read the parse tree (with given [[syntax]] and
[[lexer]]) from this stream, and transfer the contents of the parse
tree to the PHS [[forest]].

We look for the matching [[process]] tag, count groves and trees for
initializing the [[forest]], and fill the trees.

If the optional parameters are set, compare the parameters stored in
the file to those.  Set [[match]] true if everything agrees.
<<PHS forests: public>>=
  public :: phs_forest_read
<<PHS forests: interfaces>>=
  interface phs_forest_read
     module procedure phs_forest_read_file
     module procedure phs_forest_read_unit
     module procedure phs_forest_read_parse_tree
  end interface

<<PHS forests: procedures>>=
  subroutine phs_forest_read_file &
       (forest, filename, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, &
        md5sum_phs_config, phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    type(string_t), intent(in) :: filename
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_tree_t), target :: parse_tree
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_phs_forest (lexer)
    call stream_init (stream, char (filename))
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_phs_forest, lexer)
    call phs_forest_read (forest, parse_tree, &
         process_id, n_in, n_out, model, found, &
         md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
    call stream_final (stream)
    call lexer_final (lexer)
    call parse_tree_final (parse_tree)
  end subroutine phs_forest_read_file

  subroutine phs_forest_read_unit &
       (forest, unit, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, md5sum_phs_config, &
        phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    integer, intent(in) :: unit
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_tree_t), target :: parse_tree
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    call lexer_init_phs_forest (lexer)
    call stream_init (stream, unit)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_phs_forest, lexer)
    call phs_forest_read (forest, parse_tree, &
         process_id, n_in, n_out, model, found, &
         md5sum_process, md5sum_model_par, md5sum_phs_config, &
         phs_par, match)
    call stream_final (stream)
    call lexer_final (lexer)
    call parse_tree_final (parse_tree)
  end subroutine phs_forest_read_unit

  subroutine phs_forest_read_parse_tree &
       (forest, parse_tree, process_id, n_in, n_out, model, found, &
        md5sum_process, md5sum_model_par, md5sum_phs_config, &
        phs_par, match)
    type(phs_forest_t), intent(out) :: forest
    type(parse_tree_t), intent(in), target :: parse_tree
    type(string_t), intent(in) :: process_id
    integer, intent(in) :: n_in, n_out
    class(model_data_t), intent(in), target :: model
    logical, intent(out) :: found
    character(32), intent(in), optional :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out), optional :: match
    type(parse_node_t), pointer :: node_header, node_phs, node_grove
    integer :: n_grove, g
    integer, dimension(:), allocatable :: n_tree
    integer :: t
    node_header => parse_tree_get_process_ptr (parse_tree, process_id)
    found = associated (node_header);  if (.not. found)  return
    if (present (match)) then
       call phs_forest_check_input (node_header, &
            md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
       if (.not. match)  return
    end if
    node_phs => parse_node_get_next_ptr (node_header)
    n_grove = parse_node_get_n_sub (node_phs)
    allocate (n_tree (n_grove))
    do g = 1, n_grove
       node_grove => parse_node_get_sub_ptr (node_phs, g)
       n_tree(g) = parse_node_get_n_sub (node_grove) - 1
    end do
    call phs_forest_init (forest, n_tree, n_in, n_out)
    do g = 1, n_grove
       node_grove => parse_node_get_sub_ptr (node_phs, g)
       do t = 1, n_tree(g)
          call phs_tree_set (forest%grove(g)%tree(t), &
               parse_node_get_sub_ptr (node_grove, t+1), model)
       end do
    end do
  end subroutine phs_forest_read_parse_tree

@ %def phs_forest
@ Check the input for consistency.  If any MD5 sum or phase-space
parameter disagrees, the phase-space file cannot be used.  The MD5
sum checks are skipped if the stored MD5 sum is empty.
<<PHS forests: procedures>>=
  subroutine phs_forest_check_input (pn_header, &
       md5sum_process, md5sum_model_par, md5sum_phs_config, phs_par, match)
    type(parse_node_t), intent(in), target :: pn_header
    character(32), intent(in) :: &
         md5sum_process, md5sum_model_par, md5sum_phs_config
    type(phs_parameters_t), intent(in), optional :: phs_par
    logical, intent(out) :: match
    type(parse_node_t), pointer :: pn_md5sum, pn_rval, pn_ival, pn_lval
    character(32) :: md5sum
    type(phs_parameters_t) :: phs_par_old
    character(1) :: lstr
    pn_md5sum => parse_node_get_sub_ptr (pn_header, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_process) then
       call msg_message ("Phase space: discarding old configuration &
            &(process changed)")
       match = .false.;  return
    end if
    pn_md5sum => parse_node_get_next_ptr (pn_md5sum, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_model_par) then
       call msg_message ("Phase space: discarding old configuration &
            &(model parameters changed)")
       match = .false.;  return
    end if
    pn_md5sum => parse_node_get_next_ptr (pn_md5sum, 3)
    md5sum = parse_node_get_string (pn_md5sum)
    if (md5sum /= "" .and. md5sum /= md5sum_phs_config) then
       call msg_message ("Phase space: discarding old configuration &
            &(configuration parameters changed)")
       match = .false.;  return
    end if
    if (present (phs_par)) then
       pn_rval => parse_node_get_next_ptr (pn_md5sum, 3)
       phs_par_old%sqrts = parse_node_get_real (pn_rval)
       pn_rval => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%m_threshold_s = parse_node_get_real (pn_rval)
       pn_rval => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%m_threshold_t = parse_node_get_real (pn_rval)
       pn_ival => parse_node_get_next_ptr (pn_rval, 3)
       phs_par_old%off_shell = parse_node_get_integer (pn_ival)
       pn_ival => parse_node_get_next_ptr (pn_ival, 3)
       phs_par_old%t_channel = parse_node_get_integer (pn_ival)
       pn_lval => parse_node_get_next_ptr (pn_ival, 3)
       lstr = parse_node_get_string (pn_lval)
       read (lstr, "(L1)")  phs_par_old%keep_nonresonant
       if (phs_par_old /= phs_par) then
          call msg_message &
               ("Phase space: discarding old configuration &
               &(configuration parameters changed)")
          match = .false.;  return
       end if
    end if
    match = .true.
  end subroutine phs_forest_check_input

@ %def phs_forest_check_input
@ Initialize a specific tree in the forest, using the contents of the
'tree' node.  First, count the bincodes, allocate an array and read
them in, and make the tree.  Each $t$-channel tree is flipped to
$s$-channel.  Then, find mappings and initialize them.
<<PHS forests: procedures>>=
  subroutine phs_tree_set (tree, node, model)
    type(phs_tree_t), intent(inout) :: tree
    type(parse_node_t), intent(in), target :: node
    class(model_data_t), intent(in), target :: model
    type(parse_node_t), pointer :: node_bincodes, node_mapping
    integer :: n_bincodes, offset
    integer(TC), dimension(:), allocatable :: bincode
    integer :: b, n_mappings, m
    integer(TC) :: k
    type(string_t) :: type
    integer :: pdg
    node_bincodes => parse_node_get_sub_ptr (node, 2)
    if (associated (node_bincodes)) then
       select case (char (parse_node_get_rule_key (node_bincodes)))
       case ("bincodes")
          n_bincodes = parse_node_get_n_sub (node_bincodes)
          offset = 2
       case default
          n_bincodes = 0
          offset = 1
       end select
    else
       n_bincodes = 0
       offset = 2
    end if
    allocate (bincode (n_bincodes))
    do b = 1, n_bincodes
       bincode(b) = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_bincodes, b))
    end do
    call phs_tree_from_array (tree, bincode)
    call phs_tree_flip_t_to_s_channel (tree)
    call phs_tree_canonicalize (tree)
    n_mappings = parse_node_get_n_sub (node) - offset
    do m = 1, n_mappings
       node_mapping => parse_node_get_sub_ptr (node, m + offset)
       k = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_mapping, 2))
       type = parse_node_get_key &
            (parse_node_get_sub_ptr (node_mapping, 3))
       pdg = parse_node_get_integer &
            (parse_node_get_sub_ptr (node_mapping, 4))
       call phs_tree_init_mapping (tree, k, type, pdg, model)
    end do
  end subroutine phs_tree_set

@ %def phs_tree_set
@ 
\subsection{Preparation}
The trees that we read from file do not carry flavor information.
This is set separately:

The flavor list must be unique for a unique set of masses; if a given
particle can have different flavor, the mass must be degenerate, so we
can choose one of the possible flavor combinations.
<<PHS forests: public>>=
  public :: phs_forest_set_flavors
<<PHS forests: procedures>>=
  subroutine phs_forest_set_flavors (forest, flv, reshuffle, flv_extra)
    type(phs_forest_t), intent(inout) :: forest
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, intent(in), dimension(:), allocatable, optional :: reshuffle
    type(flavor_t), intent(in), optional :: flv_extra
    integer :: i, n_flv0
    if (present (reshuffle) .and. present (flv_extra)) then
       n_flv0 = size (flv)
       do i = 1, n_flv0
          if (reshuffle(i) <= n_flv0) then
             forest%flv(i) = flv (reshuffle(i))
          else
             forest%flv(i) = flv_extra
          end if
       end do
    else
       allocate (forest%flv (size (flv)))
       forest%flv = flv
    end if
  end subroutine phs_forest_set_flavors

@ %def phs_forest_set_flavors
@ 
<<PHS forests: public>>=
  public :: phs_forest_set_momentum_links
<<PHS forests: procedures>>=
  subroutine phs_forest_set_momentum_links (forest, list)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in), dimension(:), allocatable :: list
    integer :: g, t
    do g = 1, size (forest%grove)
      do t = 1, size (forest%grove(g)%tree)
        associate (tree => forest%grove(g)%tree(t))
          call phs_tree_set_momentum_links (tree, list)
!!!          call phs_tree_reshuffle_mappings (tree)
        end associate
      end do
    end do
  end subroutine phs_forest_set_momentum_links

@ %def phs_forest_set_momentum_links  
@ Once the parameter set is fixed, the masses and the widths of the
particles are known and the [[mass_sum]] arrays as well as the mapping
parameters can be computed.  Note that order is important: we first
compute the mass sums, then the ordinary mappings.  The resonances
obtained here determine the effective masses, which in turn are used
to implement step mappings for resonance decay products that are not
mapped otherwise.
<<PHS forests: public>>=
  public :: phs_forest_set_parameters
<<PHS forests: procedures>>=
  subroutine phs_forest_set_parameters &
       (forest, mapping_defaults, variable_limits)
    type(phs_forest_t), intent(inout) :: forest
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    logical, intent(in) :: variable_limits
    integer :: g, t
    do g = 1, size (forest%grove)
       do t = 1, size (forest%grove(g)%tree)
          call phs_tree_set_mass_sum &
               (forest%grove(g)%tree(t), forest%flv(forest%n_in+1:))
          call phs_tree_set_mapping_parameters (forest%grove(g)%tree(t), &
               mapping_defaults, variable_limits)
          call phs_tree_set_effective_masses (forest%grove(g)%tree(t))
          if (mapping_defaults%step_mapping) then
             call phs_tree_set_step_mappings (forest%grove(g)%tree(t), &
                  mapping_defaults%step_mapping_exp, variable_limits)
          end if
       end do
    end do
  end subroutine phs_forest_set_parameters

@ %def phs_forest_set_parameters
@ Generate the particle combination table.  Scan all trees and merge
their individual combination tables.  At the end, valid entries are
non-zero, and they indicate the indices of a pair of particles to be
combined to a new particle.  If a particle is accessible by more than
one tree (this is usual), only keep the first possibility.
<<PHS forests: public>>=
  public :: phs_forest_setup_prt_combinations
<<PHS forests: procedures>>=
  subroutine phs_forest_setup_prt_combinations (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: g, t
    integer, dimension(:,:), allocatable :: tree_prt_combination
    forest%prt_combination = 0
    allocate (tree_prt_combination (2, size (forest%prt_combination, 2)))
    do g = 1, size (forest%grove)
       do t = 1, size (forest%grove(g)%tree)
          call phs_tree_setup_prt_combinations &
               (forest%grove(g)%tree(t), tree_prt_combination)
          where (tree_prt_combination /= 0 .and. forest%prt_combination == 0)
             forest%prt_combination = tree_prt_combination
          end where
       end do
    end do
  end subroutine phs_forest_setup_prt_combinations

@ %def phs_forest_setup_prt_combinations
@ 
\subsection{Accessing the particle arrays}
Set the incoming particles from the contents of an interaction.
<<PHS forests: public>>=
  public :: phs_forest_set_prt_in
<<PHS forests: interfaces>>=
  interface phs_forest_set_prt_in
     module procedure phs_forest_set_prt_in_int, phs_forest_set_prt_in_mom
  end interface phs_forest_set_prt_in
<<PHS forests: procedures>>=
  subroutine phs_forest_set_prt_in_int (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(interaction_t), intent(in) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_in, &
            inverse (lt_cm_to_lab) * &
            int%get_momenta (outgoing=.false.))
    else
       call phs_prt_set_momentum (forest%prt_in, &
            int%get_momenta (outgoing=.false.))
    end if
    associate (m_in => forest%flv(:forest%n_in)%get_mass ())
      call phs_prt_set_msq (forest%prt_in, m_in ** 2)
    end associate
    call phs_prt_set_defined (forest%prt_in)
  end subroutine phs_forest_set_prt_in_int

  subroutine phs_forest_set_prt_in_mom (forest, mom, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(vector4_t), dimension(size (forest%prt_in)), intent(in) :: mom
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_in, &
            inverse (lt_cm_to_lab) * mom)
    else
       call phs_prt_set_momentum (forest%prt_in, mom)
    end if
    associate (m_in => forest%flv(:forest%n_in)%get_mass ())
      call phs_prt_set_msq (forest%prt_in, m_in ** 2)
    end associate
    call phs_prt_set_defined (forest%prt_in)
  end subroutine phs_forest_set_prt_in_mom

@ %def phs_forest_set_prt_in
@ Set the outgoing particles from the contents of an interaction.
<<PHS forests: public>>=
  public :: phs_forest_set_prt_out
<<PHS forests: interfaces>>=
  interface phs_forest_set_prt_out
     module procedure phs_forest_set_prt_out_int, phs_forest_set_prt_out_mom
  end interface phs_forest_set_prt_out
<<PHS forests: procedures>>=
  subroutine phs_forest_set_prt_out_int (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(interaction_t), intent(in) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_out, &
            inverse (lt_cm_to_lab) * &
            int%get_momenta (outgoing=.true.))
    else
       call phs_prt_set_momentum (forest%prt_out, &
            int%get_momenta (outgoing=.true.))
    end if
    associate (m_out => forest%flv(forest%n_in+1:)%get_mass ())
      call phs_prt_set_msq (forest%prt_out, m_out ** 2)
    end associate
    call phs_prt_set_defined (forest%prt_out)
  end subroutine phs_forest_set_prt_out_int

  subroutine phs_forest_set_prt_out_mom (forest, mom, lt_cm_to_lab)
    type(phs_forest_t), intent(inout) :: forest
    type(vector4_t), dimension(size (forest%prt_out)), intent(in) :: mom
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call phs_prt_set_momentum (forest%prt_out, &
            inverse (lt_cm_to_lab) * mom)
    else
       call phs_prt_set_momentum (forest%prt_out, mom)
    end if
    associate (m_out => forest%flv(forest%n_in+1:)%get_mass ())
      call phs_prt_set_msq (forest%prt_out, m_out ** 2)
    end associate
    call phs_prt_set_defined (forest%prt_out)
  end subroutine phs_forest_set_prt_out_mom

@ %def phs_forest_set_prt_out
@ Combine particles as described by the particle combination table.
Particle momentum sums will be calculated only if the resulting
particle is contained in at least one of the trees in the current
forest.  The others are kept undefined.
<<PHS forests: public>>=
  public :: phs_forest_combine_particles
<<PHS forests: procedures>>=
  subroutine phs_forest_combine_particles (forest)
    type(phs_forest_t), intent(inout) :: forest
    integer :: k
    integer, dimension(2) :: kk
    do k = 1, size (forest%prt_combination, 2)
       kk = forest%prt_combination(:,k)
       if (kk(1) /= 0) then
          call phs_prt_combine (forest%prt(k), &
               forest%prt(kk(1)), forest%prt(kk(2)))
       end if
    end do
  end subroutine phs_forest_combine_particles

@ %def phs_forest_combine_particles
@ Extract the outgoing particles and insert into an interaction.
<<PHS forests: public>>=
  public :: phs_forest_get_prt_out
<<PHS forests: procedures>>=
  subroutine phs_forest_get_prt_out (forest, int, lt_cm_to_lab)
    type(phs_forest_t), intent(in) :: forest
    type(interaction_t), intent(inout) :: int
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    if (present (lt_cm_to_lab)) then
       call int%set_momenta (lt_cm_to_lab * &
            phs_prt_get_momentum (forest%prt_out), outgoing=.true.)
    else
       call int%set_momenta (phs_prt_get_momentum (forest%prt_out), &
            outgoing=.true.)
    end if
  end subroutine phs_forest_get_prt_out

@ %def phs_forest_get_prt_out
@ Extract the outgoing particle momenta
<<PHS forests: public>>=
  public :: phs_forest_get_momenta_out
<<PHS forests: procedures>>=
  function phs_forest_get_momenta_out (forest, lt_cm_to_lab) result (p)
    type(phs_forest_t), intent(in) :: forest
    type(lorentz_transformation_t), intent(in), optional :: lt_cm_to_lab
    type(vector4_t), dimension(size (forest%prt_out)) :: p
    p = phs_prt_get_momentum (forest%prt_out)
    if (present (lt_cm_to_lab)) p = p * lt_cm_to_lab
  end function phs_forest_get_momenta_out
  
@ %def phs_forest_get_momenta_out
@
\subsection{Find equivalences among phase-space trees}
Scan phase space for equivalences.  We generate the complete set of
unique permutations for the given list of outgoing particles, and use
this for scanning equivalences within each grove.
@ We scan all pairs of trees, using all permutations.  This implies
that trivial equivalences are included, and equivalences between
different trees are recorded twice.  This is intentional.
<<PHS forests: procedures>>=
  subroutine phs_grove_set_equivalences (grove, perm_array)
    type(phs_grove_t), intent(inout) :: grove
    type(permutation_t), dimension(:), intent(in) :: perm_array
    type(equivalence_t), pointer :: eq
    integer :: t1, t2, i
    do t1 = 1, size (grove%tree)
       do t2 = 1, size (grove%tree)
          SCAN_PERM: do i = 1, size (perm_array)
             if (phs_tree_equivalent &
                  (grove%tree(t1), grove%tree(t2), perm_array(i))) then
                call equivalence_list_add &
                     (grove%equivalence_list, t1, t2, perm_array(i))
                eq => grove%equivalence_list%last
                call phs_tree_find_msq_permutation &
                     (grove%tree(t1), grove%tree(t2), eq%perm, &
                      eq%msq_perm)
                call phs_tree_find_angle_permutation &
                     (grove%tree(t1), grove%tree(t2), eq%perm, &
                      eq%angle_perm, eq%angle_sig)
	     end if
          end do SCAN_PERM
       end do
    end do
  end subroutine phs_grove_set_equivalences

@ %def phs_grove_set_equivalences
<<PHS forests: public>>=
  public :: phs_forest_set_equivalences
<<PHS forests: procedures>>=
  subroutine phs_forest_set_equivalences (forest)
    type(phs_forest_t), intent(inout) :: forest
    type(permutation_t), dimension(:), allocatable :: perm_array
    integer :: i
    call permutation_array_make &
         (perm_array, forest%flv(forest%n_in+1:)%get_pdg ())
    do i = 1, size (forest%grove)
       call phs_grove_set_equivalences (forest%grove(i), perm_array)
    end do
    forest%n_equivalences = sum (forest%grove%equivalence_list%length)
  end subroutine phs_forest_set_equivalences

@ %def phs_forest_set_equivalences
@ 
\subsection{Interface for channel equivalences}
Here, we store the equivalence list in the appropriate containers that
the [[phs_base]] module provides.  There is one separate list for each
channel.
<<PHS forests: public>>=
  public :: phs_forest_get_equivalences 
<<PHS forests: procedures>>=
  subroutine phs_forest_get_equivalences (forest, channel, azimuthal_dependence)
    type(phs_forest_t), intent(in) :: forest
    type(phs_channel_t), dimension(:), intent(out) :: channel
    logical, intent(in) :: azimuthal_dependence
    integer :: n_masses, n_angles
    integer :: mode_azimuthal_angle
    integer, dimension(:), allocatable :: n_eq
    type(equivalence_t), pointer :: eq
    integer, dimension(:), allocatable :: perm, mode
    integer :: g, c, j, left, right
    n_masses = forest%n_masses
    n_angles = forest%n_angles
    allocate (n_eq (forest%n_trees), source = 0)
    allocate (perm (forest%n_dimensions))
    allocate (mode (forest%n_dimensions), source = EQ_IDENTITY)
    do g = 1, size (forest%grove)
       eq => forest%grove(g)%equivalence_list%first
       do while (associated (eq))
          left = eq%left + forest%grove(g)%tree_count_offset
          n_eq(left) = n_eq(left) + 1
          eq => eq%next
       end do
    end do
    do c = 1, size (channel)
       allocate (channel(c)%eq (n_eq(c)))
       do j = 1, n_eq(c)
          call channel(c)%eq(j)%init (forest%n_dimensions)
       end do
    end do
    n_eq = 0
    if (azimuthal_dependence) then
       mode_azimuthal_angle = EQ_IDENTITY
    else
       mode_azimuthal_angle = EQ_INVARIANT
    end if
    do g = 1, size (forest%grove)
       eq => forest%grove(g)%equivalence_list%first
       do while (associated (eq))
          left = eq%left + forest%grove(g)%tree_count_offset
          right = eq%right + forest%grove(g)%tree_count_offset
          do j = 1, n_masses
             perm(j) = permute (j, eq%msq_perm)
             mode(j) = EQ_IDENTITY
          end do
          do j = 1, n_angles
             perm(n_masses+j) = n_masses + permute (j, eq%angle_perm)
             if (j == 1) then
                mode(n_masses+j) = mode_azimuthal_angle   ! first az. angle
             else if (mod(j,2) == 1) then
                mode(n_masses+j) = EQ_SYMMETRIC          ! other az. angles
             else if (eq%angle_sig(j)) then
                mode(n_masses+j) = EQ_IDENTITY           ! polar angle +
             else
                mode(n_masses+j) = EQ_INVERT             ! polar angle -
             end if
          end do
          n_eq(left) = n_eq(left) + 1
          associate (eq_cur => channel(left)%eq(n_eq(left)))
            eq_cur%c = right
            eq_cur%perm = perm
            eq_cur%mode = mode
          end associate
          eq => eq%next
       end do
    end do
  end subroutine phs_forest_get_equivalences

@ %def phs_forest_get_equivalences
@
\subsection{Phase-space evaluation}
Given one row of the [[x]] parameter array and the corresponding
channel index, compute first all relevant momenta and then recover the
remainder of the [[x]] array, the Jacobians [[phs_factor]], and the
phase-space [[volume]].

The output argument [[ok]] indicates whether this was successful.
<<PHS forests: public>>=
  public :: phs_forest_evaluate_selected_channel
<<PHS forests: procedures>>=
  subroutine phs_forest_evaluate_selected_channel &
       (forest, channel, active, sqrts, x, phs_factor, volume, ok)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    logical, dimension(:), intent(in) :: active
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(out) :: phs_factor
    real(default), intent(out) :: volume
    logical, intent(out) :: ok
    integer :: g, t
    integer(TC) :: k, k_root, k_in

    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset
    call phs_prt_set_undefined (forest%prt)
    call phs_prt_set_undefined (forest%prt_out)
    k_in = forest%n_tot
    
    do k = 1,forest%n_in
       forest%prt(ibset(0,k_in-k)) = forest%prt_in(k)
    end do

    do k = 1, forest%n_out
       call phs_prt_set_msq (forest%prt(ibset(0,k-1)), &
            forest%flv(forest%n_in+k)%get_mass () ** 2)
    end do


    k_root = 2**forest%n_out - 1
    select case (forest%n_in)
    case (1)
       forest%prt(k_root) = forest%prt_in(1)
    case (2)
       call phs_prt_combine &
            (forest%prt(k_root), forest%prt_in(1), forest%prt_in(2))
    end select
    call phs_tree_compute_momenta_from_x (forest%grove(g)%tree(t), &
         forest%prt, phs_factor(channel), volume, sqrts, x(:,channel), ok)
    if (ok) then
       do k = 1, forest%n_out
          forest%prt_out(k) = forest%prt(ibset(0,k-1))
       end do
    end if
  end subroutine phs_forest_evaluate_selected_channel

@ %def phs_forest_evaluate_selected_channel
@ The remainder: recover $x$ values for all channels except for the current 
channel.

NOTE: OpenMP not used for the first loop.  [[combine_particles]] is not a
channel-local operation.
<<PHS forests: public>>=
  public :: phs_forest_evaluate_other_channels
<<PHS forests: procedures>>=
  subroutine phs_forest_evaluate_other_channels &
       (forest, channel, active, sqrts, x, phs_factor, combine)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    logical, dimension(:), intent(in) :: active
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(inout) :: phs_factor
    logical, intent(in) :: combine
    integer :: g, t, ch, n_channel

    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset

    n_channel = forest%n_trees
    if (combine) then
       do ch = 1, n_channel
          if (ch == channel)  cycle
          if (active(ch)) then
             g = forest%grove_lookup(ch)
             t = ch - forest%grove(g)%tree_count_offset
             call phs_tree_combine_particles &
                  (forest%grove(g)%tree(t), forest%prt)
          end if
       end do
    end if

    !OMP PARALLEL PRIVATE (g,t,ch) SHARED(active,forest,sqrts,x,channel)
    !OMP DO SCHEDULE(STATIC)
    do ch = 1, n_channel
       if (ch == channel)  cycle
       if (active(ch)) then
          g = forest%grove_lookup(ch)
          t = ch - forest%grove(g)%tree_count_offset
          call phs_tree_compute_x_from_momenta &
               (forest%grove(g)%tree(t), &
               forest%prt, phs_factor(ch), sqrts, x(:,ch))
       end if
    end do
    !OMP END DO
    !OMP END PARALLEL

  end subroutine phs_forest_evaluate_other_channels

@ %def phs_forest_evaluate_other_channels
@ The complement: recover one row of the [[x]] array and the
associated Jacobian entry, corresponding to
[[channel]], from incoming and outgoing momenta.  Also compute the
phase-space volume.
<<PHS forests: public>>=
  public :: phs_forest_recover_channel
<<PHS forests: procedures>>=
  subroutine phs_forest_recover_channel &
       (forest, channel, sqrts, x, phs_factor, volume)
    type(phs_forest_t), intent(inout) :: forest
    integer, intent(in) :: channel
    real(default), intent(in) :: sqrts
    real(default), dimension(:,:), intent(inout) :: x
    real(default), dimension(:), intent(inout) :: phs_factor
    real(default), intent(out) :: volume
    integer :: g, t
    integer(TC) :: k, k_in
    g = forest%grove_lookup (channel)
    t = channel - forest%grove(g)%tree_count_offset
    call phs_prt_set_undefined (forest%prt)
    k_in = forest%n_tot
    forall (k = 1:forest%n_in)
       forest%prt(ibset(0,k_in-k)) = forest%prt_in(k)
    end forall
    forall (k = 1:forest%n_out)
       forest%prt(ibset(0,k-1)) = forest%prt_out(k)
    end forall
    call phs_forest_combine_particles (forest)
    call phs_tree_compute_volume &
         (forest%grove(g)%tree(t), sqrts, volume)
    call phs_tree_compute_x_from_momenta &
         (forest%grove(g)%tree(t), &
         forest%prt, phs_factor(channel), sqrts, x(:,channel))
  end subroutine phs_forest_recover_channel

@ %def phs_forest_recover_channel
@ 
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[phs_forests_ut.f90]]>>=
<<File header>>

module phs_forests_ut
  use unit_tests
  use phs_forests_uti
  
<<Standard module head>>

<<PHS forests: public test>>

contains
  
<<PHS forests: test driver>>

end module phs_forests_ut
@ %def phs_forests_ut
@
<<[[phs_forests_uti.f90]]>>=
<<File header>>

module phs_forests_uti

<<Use kinds>>
<<Use strings>>
  use format_defs, only: FMT_12
  use lorentz
  use flavors
  use interactions
  use model_data
  use mappings
  use phs_base

  use phs_forests

<<Standard module head>>

<<PHS forests: test declarations>>

contains

<<PHS forests: tests>>

end module phs_forests_uti
@ %def phs_forests_ut
@ API: driver for the unit tests below.
<<PHS forests: public test>>=
  public :: phs_forests_test
<<PHS forests: test driver>>=
  subroutine phs_forests_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS forests: execute tests>>  
  end subroutine phs_forests_test
  
@  %def phs_forests_test
@ 
Write a possible phase-space file for a $2\to 3$ process and make the
corresponding forest, print the forest. Choose some in-particle
momenta and a random-number array and evaluate out-particles and
phase-space factors. 
<<PHS forests: execute tests>>=
  call test (phs_forest_1, "phs_forest_1", &
       "check phs forest setup", &
       u, results)
<<PHS forests: test declarations>>=
  public :: phs_forest_1
<<PHS forests: tests>>= 
  subroutine phs_forest_1 (u)
    use os_interface
    integer, intent(in) :: u
    type(phs_forest_t) :: forest
    type(phs_channel_t), dimension(:), allocatable :: channel
    type(model_data_t), target :: model
    type(string_t) :: process_id
    type(flavor_t), dimension(5) :: flv
    type(string_t) :: filename
    type(interaction_t) :: int
    integer, parameter :: unit_fix = 20
    type(mapping_defaults_t) :: mapping_defaults
    logical :: found_process, ok
    integer :: n_channel, ch, i
    logical, dimension(4) :: active = .true.
    real(default) :: sqrts = 1000
    real(default), dimension(5,4) :: x
    real(default), dimension(4) :: factor
    real(default) :: volume

    write (u, "(A)")  "* Test output: PHS forest"
    write (u, "(A)")  "*   Purpose: test PHS forest routines"
    write (u, "(A)")      
    
    write (u, "(A)")  "* Reading model file"
    
    call model%init_sm_test ()

    write (u, "(A)")
    write (u, "(A)")  "* Create phase-space file 'phs_forest_test.phs'"
    write (u, "(A)")
    
    call flv%init ([11, -11, 11, -11, 22], model)
    open (file="phs_forest_test.phs", unit=unit_fix, action="write")
    write (unit_fix, *) "process foo"
    write (unit_fix, *) 'md5sum_process    = "6ABA33BC2927925D0F073B1C1170780A"'
    write (unit_fix, *) 'md5sum_model_par  = "1A0B151EE6E2DEB92D880320355A3EAB"'
    write (unit_fix, *) 'md5sum_phs_config = "B6A8877058809A8BDD54753CDAB83ACE"'
    write (unit_fix, *) "sqrts         =    100.00000000000000"     
    write (unit_fix, *) "m_threshold_s =    50.000000000000000"     
    write (unit_fix, *) "m_threshold_t =    100.00000000000000"     
    write (unit_fix, *) "off_shell =            2"
    write (unit_fix, *) "t_channel =            6"
    write (unit_fix, *) "keep_nonresonant =  F"
    write (unit_fix, *) ""
    write (unit_fix, *) "  grove"
    write (unit_fix, *) "    tree 3 7"
    write (unit_fix, *) "      map 3 s_channel 23"
    write (unit_fix, *) "    tree 5 7"
    write (unit_fix, *) "    tree 6 7"
    write (unit_fix, *) "  grove"
    write (unit_fix, *) "    tree 9 11"
    write (unit_fix, *) "      map 9 t_channel 22"
    close (unit_fix)

    write (u, "(A)")
    write (u, "(A)")  "* Read phase-space file 'phs_forest_test.phs'"

    call syntax_phs_forest_init ()
    process_id = "foo"
    filename = "phs_forest_test.phs"
    call phs_forest_read &
         (forest, filename, process_id, 2, 3, model, found_process)

    write (u, "(A)")
    write (u, "(A)")  "* Set parameters, flavors, equiv, momenta"
    write (u, "(A)") 
    
    call phs_forest_set_flavors (forest, flv)
    call phs_forest_set_parameters (forest, mapping_defaults, .false.)
    call phs_forest_setup_prt_combinations (forest)
    call phs_forest_set_equivalences (forest)
    call int%basic_init (2, 0, 3)
    call int%set_momentum &
         (vector4_moving (500._default, 500._default, 3), 1)
    call int%set_momentum &
         (vector4_moving (500._default,-500._default, 3), 2)
    call phs_forest_set_prt_in (forest, int)
    n_channel = 2
    x = 0
    x(:,n_channel) = [0.3, 0.4, 0.1, 0.9, 0.6]
    write (u, "(A)")  "   Input values:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  x(:,n_channel)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluating phase space"

    call phs_forest_evaluate_selected_channel (forest, &
         n_channel, active, sqrts, x, factor, volume, ok)
    call phs_forest_evaluate_other_channels (forest, &
         n_channel, active, sqrts, x, factor, combine=.true.)
    call phs_forest_get_prt_out (forest, int)
    write (u, "(A)")  "   Output values:"
    do ch = 1, 4
       write (u, "(3x,5(1x," // FMT_12 // "))")  x(:,ch)
    end do
    call int%basic_write (u)
    write (u, "(A)")  "   Factors:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  factor
    write (u, "(A)")  "   Volume:"
    write (u, "(3x,5(1x," // FMT_12 // "))")  volume
    call phs_forest_write (forest, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compute equivalences"

    n_channel = 4
    allocate (channel (n_channel))
    call phs_forest_get_equivalences (forest, &
         channel, .true.)
    do i = 1, n_channel
       write (u, "(1x,I0,':')", advance = "no")  ch       
       call channel(i)%write (u)
    end do
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call model%final ()
    call phs_forest_final (forest)
    call syntax_phs_forest_final ()
        
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_forest_1"    

  end subroutine phs_forest_1

@ %def phs_forest_1
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Finding phase space parameterizations}
If the phase space configuration is not found in the appropriate file,
we should generate one.

The idea is to construct all Feynman diagrams subject to certain
constraints which eliminate everything that is probably irrelevant for
the integration.  These Feynman diagrams (cascades) are grouped in
groves by finding equivalence classes related by symmetry and ordered
with respect to their importance (resonances).  Finally, the result
(or part of it) is written to file and used for the integration.

This module may eventually disappear and be replaced by CAML code.
In particular, we need here a set of Feynman rules (vertices with
particle codes, but not the factors).  Thus, the module works for the
Standard Model only.

Note that this module is stand-alone, it communicates to the main
program only via the generated ASCII phase-space configuration file.
<<[[cascades.f90]]>>=
<<File header>>

module cascades

<<Use kinds>>
  use kinds, only: TC, i8, i32
<<Use strings>>
  use io_units
  use format_defs, only: FMT_12, FMT_19
  use unit_tests
  use diagnostics
  use hashes
  use sorting
  use physics_defs, only: SCALAR, SPINOR, VECTOR, VECTORSPINOR, TENSOR
  use physics_defs, only: UNDEFINED
  use model_data
  use flavors
  use phs_forests

<<Standard module head>>

<<Cascades: public>>

<<Cascades: parameters>>

<<Cascades: types>>

<<Cascades: interfaces>>

contains

<<Cascades: procedures>>

end module cascades
@ %def cascades
@ 
\subsection{The mapping modes}
The valid mapping modes, to be used below.  We will make use of the convention
that mappings of internal particles have a positive value.  Only for positive
values, the flavor code is propagated when combining cascades.
<<Mapping modes>>=
  integer, parameter :: &
       & EXTERNAL_PRT = -1, &
       & NO_MAPPING = 0, S_CHANNEL = 1, T_CHANNEL =  2, U_CHANNEL = 3, &
       & RADIATION = 4, COLLINEAR = 5, INFRARED = 6, &
       & STEP_MAPPING_E = 11, STEP_MAPPING_H = 12, &
       & ON_SHELL = 99
@ %def EXTERNAL_PRT
@ %def NO_MAPPING S_CHANNEL T_CHANNEL U_CHANNEL
@ %def RADIATION COLLINEAR INFRARED
@ %def STEP_MAPPING_E STEP_MAPPING_H
@ %def ON_SHELL
<<Cascades: parameters>>=
<<Mapping modes>>
@
\subsection{The cascade type}
A cascade is essentially the same as a decay tree (both definitions
may be merged in a later version).  It contains a linked tree of
nodes, each of which representing an internal particle.  In contrast
to decay trees, each node has a definite particle code.  These nodes
need not be modified, therefore we can use pointers and do not have to
copy them.  Thus, physically each cascades has only a single node, the
mother particle.  However, to be able to compare trees quickly, we
store in addition an array of binary codes which is always sorted in
ascending order.  This is accompanied by a corresponding list of
particle codes.  The index is the location of the corresponding
cascade in the cascade set, this may be used to access the daughters
directly.

The real mass is the particle mass belonging to the particle code.
The minimal mass is the sum of the real masses of all its daughters;
this is the kinematical cutoff.  The effective mass may be zero if the
particle mass is below a certain threshold; it may be the real mass if
the particle is resonant; or it may be some other value.

The logical [[t_channel]] is set if this a $t$-channel line, while
[[initial]] is true only for an initial particle.  Note that both
initial particles are also [[t_channel]] by definition, and that they
are distinguished by the direction of the tree:  One of them decays
and is the root of the tree, while the other one is one of the leaves.

The cascade is a list of nodes (particles) which are linked via the
[[daughter]] entries.  The node is the mother particle of
the decay cascade.  Much of the information in the nodes is repeated
in arrays, to be accessible more easily.  The arrays will be kept
sorted by binary codes.

The counter [[n_off_shell]] is increased for each internal line that
is neither resonant nor log-enhanced.  It is set to zero if the
current line is resonant, since this implies on-shell particle production
and subsequent decay.

The counter [[n_t_channel]] is non-negative once an initial particle
is included in the tree: then, it counts the number of $t$-channel lines.

The [[multiplicity]] is the number of branchings to follow until all
daughters are on-shell.  A resonant or non-decaying particle has
multiplicity one.  Merging nodes, the multiplicities add unless the
mother is a resonance.  An initial or final node has multiplicity
zero.

The arrays correspond to the subnode tree [[tree]] of the current
cascade.  PDG codes are stored only for those positions which are
resonant, with the exception of the last entry, i.e., the current node.
Other positions, in particular external legs, are assigned undefined
PDG code.

A cascade is uniquely identified by its tree, the tree of PDG codes,
and the tree of mappings.  The tree of resonances is kept only to mask
the PDG tree as described above.
<<Cascades: types>>=
  type :: cascade_t
     private
     ! counters
     integer :: index = 0
     integer :: grove = 0
     ! status
     logical :: active = .false.
     logical :: complete = .false.
     logical :: incoming = .false.
     ! this node
     integer(TC) :: bincode = 0
     type(flavor_t) :: flv
     integer :: pdg = UNDEFINED
     logical :: is_vector = .false.
     real(default) :: m_min = 0
     real(default) :: m_rea = 0
     real(default) :: m_eff = 0
     integer :: mapping = NO_MAPPING
     logical :: on_shell = .false.
     logical :: resonant = .false.
     logical :: log_enhanced = .false.
     logical :: t_channel = .false.
     ! global tree properties
     integer :: multiplicity = 0
     integer :: internal = 0
     integer :: n_off_shell = 0
     integer :: n_resonances = 0
     integer :: n_log_enhanced = 0
     integer :: n_t_channel = 0
     integer :: res_hash = 0
     ! the sub-node tree
     integer :: depth = 0
     integer(TC), dimension(:), allocatable :: tree
     integer, dimension(:), allocatable :: tree_pdg
     integer, dimension(:), allocatable :: tree_mapping
     logical, dimension(:), allocatable :: tree_resonant
     ! branch connections
     logical :: has_children = .false.
     type(cascade_t), pointer :: daughter1 => null ()
     type(cascade_t), pointer :: daughter2 => null ()
     type(cascade_t), pointer :: mother => null ()
     ! next in list
     type(cascade_t), pointer :: next => null ()
  end type cascade_t

@ %def cascade_t
<<Cascades: procedures>>=
  subroutine cascade_init (cascade, depth)
    type(cascade_t), intent(out) :: cascade
    integer, intent(in) :: depth
    integer, save :: index = 0
    index = cascade_index ()
    cascade%index = index
    cascade%depth = depth
    cascade%active = .true.
    allocate (cascade%tree (depth))
    allocate (cascade%tree_pdg (depth))
    allocate (cascade%tree_mapping (depth))
    allocate (cascade%tree_resonant (depth))
  end subroutine cascade_init
@ %def cascade_init
@ Keep and increment a global index
<<Cascades: procedures>>=
  function cascade_index (seed) result (index)
    integer :: index
    integer, intent(in), optional :: seed
    integer, save :: i = 0
    if (present (seed))  i = seed
    i = i + 1
    index = i
  end function cascade_index

@ %def cascade_index
@ We need three versions of writing cascades.  This goes to the
phase-space file:
<<Cascades: procedures>>=
  subroutine cascade_write_file_format (cascade, model, unit)
    type(cascade_t), intent(in) :: cascade
    class(model_data_t), intent(in), target :: model
    integer, intent(in), optional :: unit
    type(flavor_t) :: flv
    integer :: u, i
1   format(3x,A,1x,40(1x,I4))
2   format(3x,A,1x,I3,1x,A,1x,I7,1x,'!',1x,A)
    u = given_output_unit (unit);  if (u < 0)  return
    call write_reduced (cascade%tree, u)
    write (u, "(A)")
    do i = 1, cascade%depth
       call flv%init (cascade%tree_pdg(i), model)
       select case (cascade%tree_mapping(i))
       case (NO_MAPPING, EXTERNAL_PRT)
       case (S_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 's_channel', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (T_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 't_channel', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (U_CHANNEL)
          write(u,2) 'map', &
               cascade%tree(i), 'u_channel', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (RADIATION)
          write(u,2) 'map', &
               cascade%tree(i), 'radiation', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (COLLINEAR)
          write(u,2) 'map', &
               cascade%tree(i), 'collinear', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (INFRARED)
          write(u,2) 'map', &
               cascade%tree(i), 'infrared ',  abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case (ON_SHELL)
          write(u,2) 'map', &
               cascade%tree(i), 'on_shell ', abs (cascade%tree_pdg(i)), &
               char (flv%get_name ())
       case default
          call msg_bug (" Impossible mapping mode encountered")
       end select
    end do
  contains
    subroutine write_reduced (array, unit)
      integer(TC), dimension(:), intent(in) :: array
      integer, intent(in) :: unit
      integer :: i
      write (u, "(3x,A,1x)", advance="no")  "tree"
      do i = 1, size (array)
         if (decay_level (array(i)) > 1) then
            write (u, "(1x,I0)", advance="no")  array(i)
         end if
      end do
    end subroutine write_reduced

    elemental function decay_level (k) result (l)
      integer(TC), intent(in) :: k
      integer :: l
      integer :: i
      l = 0
      do i = 0, bit_size(k) - 1
         if (btest(k,i)) l = l + 1
      end do
    end function decay_level
    subroutine start_comment (u)
      integer, intent(in) :: u
      write(u, '(1x,A)', advance='no') '!'
    end subroutine start_comment
  end subroutine cascade_write_file_format

@ %def cascade_write_file_format
@ This creates metapost source for graphical display:
<<Cascades: procedures>>=
  subroutine cascade_write_graph_format (cascade, count, unit)
    type(cascade_t), intent(in) :: cascade
    integer, intent(in) :: count
    integer, intent(in), optional :: unit
    integer :: u
    integer(TC) :: mask
    type(string_t) :: left_str, right_str
    u = given_output_unit (unit);  if (u < 0)  return
    mask = 2**((cascade%depth+3)/2) - 1
    left_str = ""
    right_str = ""
    write (u, '(A)') "\begin{minipage}{105pt}"
    write (u, '(A)') "\vspace{30pt}"
    write (u, '(A)') "\begin{center}"
    write (u, '(A)') "\begin{fmfgraph*}(55,55)"
    call graph_write (cascade, mask)
    write (u, '(A)') "\fmfleft{" // char (extract (left_str, 2)) // "}"
    write (u, '(A)') "\fmfright{" // char (extract (right_str, 2)) // "}"
    write (u, '(A)') "\end{fmfgraph*}\\"
    write (u, '(A,I5,A)') "\fbox{$", count, "$}"
    write (u, '(A)') "\end{center}"
    write (u, '(A)') "\end{minipage}"
    write (u, '(A)') "%"
  contains
    recursive subroutine graph_write (cascade, mask, reverse)
      type(cascade_t), intent(in) :: cascade
      integer(TC), intent(in) :: mask
      logical, intent(in), optional :: reverse
      type(flavor_t) :: anti
      logical :: rev
      rev = .false.;  if (present(reverse))  rev = reverse
      if (cascade%has_children) then
         if (.not.rev) then
            call vertex_write (cascade, cascade%daughter1, mask)
            call vertex_write (cascade, cascade%daughter2, mask)
         else
            call vertex_write (cascade, cascade%daughter2, mask, .true.)
            call vertex_write (cascade, cascade%daughter1, mask, .true.)
         end if
         if (cascade%complete) then
            call vertex_write (cascade, cascade%mother, mask, .true.)
            write (u, '(A,I0,A)') "\fmfv{d.shape=square}{v0}"
         end if
      else
         if (cascade%incoming) then
            anti = cascade%flv%anti ()
            call external_write (cascade%bincode, anti%get_tex_name (), &
                 left_str)
         else
            call external_write (cascade%bincode, cascade%flv%get_tex_name (), &
                 right_str)
         end if
      end if
    end subroutine graph_write
    recursive subroutine vertex_write (cascade, daughter, mask, reverse)
      type(cascade_t), intent(in) :: cascade, daughter
      integer(TC), intent(in) :: mask
      logical, intent(in), optional :: reverse
      integer :: bincode
      if (cascade%complete) then
         bincode = 0
      else
         bincode = cascade%bincode
      end if
      call graph_write (daughter, mask, reverse)
      if (daughter%has_children) then
         call line_write (bincode, daughter%bincode, daughter%flv, &
              mapping=daughter%mapping)
      else
         call line_write (bincode, daughter%bincode, daughter%flv)
      end if
    end subroutine vertex_write
    subroutine line_write (i1, i2, flv, mapping)
      integer(TC), intent(in) :: i1, i2
      type(flavor_t), intent(in) :: flv
      integer, intent(in), optional :: mapping
      integer :: k1, k2
      type(string_t) :: prt_type
      select case (flv%get_spin_type ())
      case (SCALAR);       prt_type = "plain"
      case (SPINOR);       prt_type = "fermion"
      case (VECTOR);       prt_type = "boson"
      case (VECTORSPINOR); prt_type = "fermion"
      case (TENSOR);       prt_type = "dbl_wiggly"
      case default;        prt_type = "dashes"
      end select
      if (flv%is_antiparticle ()) then
         k1 = i2;  k2 = i1
      else
         k1 = i1;  k2 = i2
      end if
      if (present (mapping)) then
         select case (mapping)
         case (S_CHANNEL)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=blue,lab=\sm\blue$" // &
                 & char (flv%get_tex_name ()) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (T_CHANNEL, U_CHANNEL)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=cyan,lab=\sm\cyan$" // &
                 & char (flv%get_tex_name ()) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (RADIATION)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=green,lab=\sm\green$" // &
                 & char (flv%get_tex_name ()) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (COLLINEAR)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=magenta,lab=\sm\magenta$" // &
                 & char (flv%get_tex_name ()) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case (INFRARED)
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=red,lab=\sm\red$" // &
                 & char (flv%get_tex_name ()) // "$}" // &
                 & "{v", k1, ",v", k2, "}"
         case default
            write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & ",f=black}" // &
                 & "{v", k1, ",v", k2, "}"
         end select
      else
         write (u, '(A,I0,A,I0,A)') "\fmf{" // char (prt_type) // &
                 & "}" // &
                 & "{v", k1, ",v", k2, "}"
      end if
    end subroutine line_write
    subroutine external_write (bincode, name, ext_str)
      integer(TC), intent(in) :: bincode
      type(string_t), intent(in) :: name
      type(string_t), intent(inout) :: ext_str
      character(len=20) :: str
      write (str, '(A2,I0)') ",v", bincode
      ext_str = ext_str // trim (str)
      write (u, '(A,I0,A,I0,A)') "\fmflabel{\sm$" &
        // char (name) &
        // "\,(", bincode, ")" &
        // "$}{v", bincode, "}"
    end subroutine external_write
  end subroutine cascade_write_graph_format

@ %def cascade_write_graph_format
@ This is for screen/debugging output:
<<Cascades: procedures>>=
  subroutine cascade_write (cascade, unit)
    type(cascade_t), intent(in) :: cascade
    integer, intent(in), optional :: unit
    integer :: u
    character(9) :: depth
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(A,(1x,I7))") 'Cascade #', cascade%index
    write (u, "(A,(1x,I7))") '  Grove:       #', cascade%grove
    write (u, "(A,3(1x,L1))") '  act/cmp/inc:  ', &
         cascade%active, cascade%complete, cascade%incoming
    write (u, "(A,I0)") '  Bincode:      ', cascade%bincode
    write (u, "(A)", advance="no") '  Flavor:       '
    call cascade%flv%write (unit)
    write (u, "(A,I9)") '  Active flavor:', cascade%pdg
    write (u, "(A,L1)") '  Is vector:    ', cascade%is_vector
    write (u, "(A,3(1x," // FMT_19 // "))") '  Mass (m/r/e): ', &
         cascade%m_min, cascade%m_rea, cascade%m_eff
    write (u, "(A,I1)") '  Mapping:      ', cascade%mapping
    write (u, "(A,3(1x,L1))") '  res/log/tch:  ', &
         cascade%resonant, cascade%log_enhanced, cascade%t_channel
    write (u, "(A,(1x,I7))") '  Multiplicity: ', cascade%multiplicity
    write (u, "(A,2(1x,I7))") '  n intern/off: ', &
         cascade%internal, cascade%n_off_shell
    write (u, "(A,3(1x,I7))") '  n res/log/tch:', &
         cascade%n_resonances, cascade%n_log_enhanced, cascade%n_t_channel
    write (u, "(A,I7)") '  Depth:        ', cascade%depth
    write (depth, "(I7)") cascade%depth
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree:         ', cascade%tree
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree(PDG):    ', cascade%tree_pdg
    write (u, "(A," // depth // "(1x,I7))") &
       '  Tree(mapping):', cascade%tree_mapping
    write (u, "(A," // depth // "(1x,L1))") &
       '  Tree(res):    ', cascade%tree_resonant
    if (cascade%has_children) then
       write (u, "(A,I7,1x,I7)") '  Daughter1/2:  ', &
            cascade%daughter1%index, cascade%daughter2%index
    end if
    if (associated (cascade%mother)) then
       write (u, "(A,I7)") '  Mother:       ', cascade%mother%index
    end if
  end subroutine cascade_write

@ %def cascade_write
@
\subsection{Creating new cascades}
This initializes a single-particle cascade (external, final state).
The PDG entry in the tree is set undefined because the cascade is not
resonant.  However, the flavor entry is set, so the cascade flavor
is identified nevertheless.
<<Cascades: procedures>>=
  subroutine cascade_init_outgoing (cascade, flv, pos, m_thr)
    type(cascade_t), intent(out) :: cascade
    type(flavor_t), intent(in) :: flv
    integer, intent(in) :: pos
    real(default), intent(in) :: m_thr
    call cascade_init (cascade, 1)
    cascade%bincode = ibset (0_TC, pos-1)
    cascade%flv = flv
    cascade%pdg = abs (cascade%flv%get_pdg ())
    cascade%is_vector = flv%get_spin_type () == VECTOR
    cascade%m_min = flv%get_mass ()
    cascade%m_rea = cascade%m_min
    if (cascade%m_rea >= m_thr) then
       cascade%m_eff = cascade%m_rea
    end if
    cascade%on_shell = .true.
    cascade%multiplicity = 1
    cascade%tree(1) = cascade%bincode
    cascade%tree_pdg(1) = cascade%pdg
    cascade%tree_mapping(1) = EXTERNAL_PRT
    cascade%tree_resonant(1) = .false.
  end subroutine cascade_init_outgoing

@ %def cascade_init_outgoing
@ The same for an incoming line:
<<Cascades: procedures>>=
  subroutine cascade_init_incoming (cascade, flv, pos, m_thr)
    type(cascade_t), intent(out) :: cascade
    type(flavor_t), intent(in) :: flv
    integer, intent(in) :: pos
    real(default), intent(in) :: m_thr
    call cascade_init (cascade, 1)
    cascade%incoming = .true.
    cascade%bincode = ibset (0_TC, pos-1)
    cascade%flv = flv%anti ()
    cascade%pdg = abs (flv%get_pdg ())
    cascade%is_vector = flv%get_spin_type () == VECTOR
    cascade%m_min = flv%get_mass ()
    cascade%m_rea = cascade%m_min
    if (cascade%m_rea >= m_thr) then
       cascade%m_eff = cascade%m_rea
    end if
    cascade%on_shell = .true.
    cascade%n_t_channel = 0
    cascade%n_off_shell = 0
    cascade%tree(1) = cascade%bincode
    cascade%tree_pdg(1) = cascade%pdg
    cascade%tree_mapping(1) = EXTERNAL_PRT
    cascade%tree_resonant(1) = .false.
  end subroutine cascade_init_incoming

@ %def cascade_init_outgoing
@
\subsection{Tools}
This function returns true if the two cascades share no common
external particle.  This is a requirement for joining them.
<<Cascades: interfaces>>=
  interface operator(.disjunct.)
     module procedure cascade_disjunct
  end interface

<<Cascades: procedures>>=
  function cascade_disjunct (cascade1, cascade2) result (flag)
    logical :: flag
    type(cascade_t), intent(in) :: cascade1, cascade2
    flag = iand (cascade1%bincode, cascade2%bincode) == 0
  end function cascade_disjunct

@ %def cascade_disjunct
@ %def .disjunct.
@ Compute a hash code for the resonance pattern of a cascade.  We count the
number of times each particle appears as a resonance.

We pack the PDG codes of the resonances in two arrays (s-channel and 
t-channel), sort them both, concatenate the results, transfer to
[[i8]] integers, and compute the hash code from this byte stream.
<<Cascades: procedures>>=
  subroutine cascade_assign_resonance_hash (cascade)
    type(cascade_t), intent(inout) :: cascade
    integer(i8), dimension(1) :: mold
    cascade%res_hash = hash (transfer &
         (concat (sort (pack (cascade%tree_pdg, &
                              cascade%tree_resonant)), &
                  sort (pack (cascade%tree_pdg, &
                              cascade%tree_mapping == T_CHANNEL .or. &
                              cascade%tree_mapping == U_CHANNEL))), &
          mold))
  end subroutine cascade_assign_resonance_hash

@ %def cascade_assign_resonance_hash
@ 
\subsection{Hash entries for cascades}
We will set up a hash array which contains keys of and pointers to
cascades.  We hold a list of cascade (pointers) within each bucket.
This is not for collision resolution, but for keeping similar, but
unequal cascades together.
<<Cascades: types>>=
  type :: cascade_p
     type(cascade_t), pointer :: cascade => null ()
     type(cascade_p), pointer :: next => null ()
  end type cascade_p

@ %def cascade_p
@ Here is the bucket or hash entry type:
<<Cascades: types>>=
  type :: hash_entry_t
     integer(i32) :: hashval = 0
     integer(i8), dimension(:), allocatable :: key
     type(cascade_p), pointer :: first => null ()
     type(cascade_p), pointer :: last => null ()
  end type hash_entry_t

@ %def hash_entry_t
@ Finalize: just deallocate the list; the contents are just pointers.
<<Cascades: procedures>>=
  subroutine hash_entry_final (hash_entry)
    type(hash_entry_t), intent(inout) :: hash_entry
    type(cascade_p), pointer :: current
    do while (associated (hash_entry%first))
       current => hash_entry%first
       hash_entry%first => current%next
       deallocate (current)
    end do
  end subroutine hash_entry_final

@ %def hash_entry_final
@ Output: concise format for debugging, just list cascade indices.
<<Cascades: procedures>>=
  subroutine hash_entry_write (hash_entry, unit)
    type(hash_entry_t), intent(in) :: hash_entry
    integer, intent(in), optional :: unit
    type(cascade_p), pointer :: current
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)", advance="no")  "Entry:"
    do i = 1, size (hash_entry%key)
       write (u, "(1x,I0)", advance="no")  hash_entry%key(i)
    end do
    write (u, "(1x,A)", advance="no")  "->"
    current => hash_entry%first
    do while (associated (current))
       write (u, "(1x,I7)", advance="no") current%cascade%index
       current => current%next
    end do
    write (u, *)
  end subroutine hash_entry_write

@ %def hash_entry_write
@ This function adds a cascade pointer to the bucket.  If [[ok]] is
present, check first if it is already there and return failure if yes.
If [[cascade_ptr]] is also present, set it to the current cascade if
successful.  If not, set it to the cascade that is already there.
<<Cascades: procedures>>=
  subroutine hash_entry_add_cascade_ptr (hash_entry, cascade, ok, cascade_ptr)
    type(hash_entry_t), intent(inout) :: hash_entry
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out), optional :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_p), pointer :: current
    if (present (ok)) then
       call hash_entry_check_cascade (hash_entry, cascade, ok, cascade_ptr)
       if (.not. ok)  return
    end if
    allocate (current)
    current%cascade => cascade
    if (associated (hash_entry%last)) then
       hash_entry%last%next => current
    else 
       hash_entry%first => current
    end if
    hash_entry%last => current
  end subroutine hash_entry_add_cascade_ptr

@ %def hash_entry_add_cascade_ptr
@ This function checks whether a cascade is already in the bucket.
For incomplete cascades, we look for an exact match. It should suffice
to verify the tree, the PDG codes, and the mapping modes.  This is the
information that is written to the phase space file.

For complete cascades, we ignore the PDG code at positions with
mappings infrared, collinear, or t/u-channel.  Thus a cascade which is
distinguished only by PDG code at such places, is flagged existent.
If the convention is followed that light particles come before heavier
ones (in the model definition), this ensures that the lightest
particle is kept in the appropriate place, corresponding to the
strongest peak.

For external cascades (incoming/outgoing) we take the PDG code into
account even though it is zeroed in the PDG-code tree.
<<Cascades: procedures>>=
  subroutine hash_entry_check_cascade (hash_entry, cascade, ok, cascade_ptr)
    type(hash_entry_t), intent(in), target :: hash_entry
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_p), pointer :: current
    integer, dimension(:), allocatable :: tree_pdg
    ok = .true.
    allocate (tree_pdg (size (cascade%tree_pdg)))
    if (cascade%complete) then
       where (cascade%tree_mapping == INFRARED .or. &
            cascade%tree_mapping == COLLINEAR .or. &
            cascade%tree_mapping == T_CHANNEL .or. &
            cascade%tree_mapping == U_CHANNEL)
          tree_pdg = 0
       elsewhere
          tree_pdg = cascade%tree_pdg
       end where
    else
       tree_pdg = cascade%tree_pdg
    end if
    current => hash_entry%first
    do while (associated (current))
       if (current%cascade%depth == cascade%depth) then
          if (all (current%cascade%tree == cascade%tree)) then
             if (all (current%cascade%tree_mapping == cascade%tree_mapping)) &
                  then
                if (all (current%cascade%tree_pdg .match. tree_pdg)) then
                   if (present (cascade_ptr))  cascade_ptr => current%cascade
                   ok = .false.;  return
                end if
             end if
          end if
       end if
       current => current%next
    end do
    if (present (cascade_ptr))  cascade_ptr => cascade
  end subroutine hash_entry_check_cascade

@ %def hash_entry_check_cascade
@ For PDG codes, we specify that the undefined code matches any code.
This is already defined for flavor objects, but here we need it for
the codes themselves.
<<Cascades: interfaces>>=
  interface operator(.match.)
     module procedure pdg_match
  end interface
<<Cascades: procedures>>=
  elemental function pdg_match (pdg1, pdg2) result (flag)
    logical :: flag
    integer(TC), intent(in) :: pdg1, pdg2
    select case (pdg1)
    case (0)
       flag = .true.
    case default
       select case (pdg2)
       case (0)
          flag = .true.
       case default
          flag = pdg1 == pdg2
       end select
    end select
  end function pdg_match

@ %def .match.
@ 
\subsection{The cascade set}
The cascade set will later be transformed into the decay forest.  It
is set up as a linked list.  In addition to the usual [[first]] and
[[last]] pointers, there is a [[first_t]] pointer which points to the
first t-channel cascade (after all s-channel cascades), and a
[[first_k]] pointer which points to the first final cascade (with a
keystone).

As an auxiliary device, the object contains a hash array with
associated parameters where an additional pointer is stored for each
cascade.  The keys are made from the relevant cascade data.  This hash
is used for fast detection (and thus avoidance) of double entries in
the cascade list.
<<Cascades: public>>=
  public :: cascade_set_t
<<Cascades: types>>=
  type :: cascade_set_t
     private
     class(model_data_t), pointer :: model
     integer :: n_in, n_out, n_tot
     type(flavor_t), dimension(:,:), allocatable :: flv
     integer :: depth_out, depth_tot
     real(default) :: sqrts = 0
     real(default) :: m_threshold_s = 0
     real(default) :: m_threshold_t = 0
     integer :: off_shell = 0
     integer :: t_channel = 0
     logical :: keep_nonresonant
     integer :: n_groves = 0
     ! The cascade list
     type(cascade_t), pointer :: first => null ()
     type(cascade_t), pointer :: last => null ()
     type(cascade_t), pointer :: first_t => null ()
     type(cascade_t), pointer :: first_k => null ()
     ! The hashtable
     integer :: n_entries = 0
     real :: fill_ratio = 0
     integer :: n_entries_max = 0
     integer(i32) :: mask = 0
     logical :: fatal_beam_decay = .true.
     type(hash_entry_t), dimension(:), allocatable :: entry
  end type cascade_set_t

@ %def cascade_set_t
@ Return true if there are cascades which are active and complete, so
the phase space file would be nonempty.
<<Cascades: public>>=
  public :: cascade_set_is_valid
<<Cascades: procedures>>=
  function cascade_set_is_valid (cascade_set) result (flag)
    logical :: flag
    type(cascade_set_t), intent(in) :: cascade_set
    type(cascade_t), pointer :: cascade
    flag = .false.
    cascade => cascade_set%first_k
    do while (associated (cascade))
       if (cascade%active .and. cascade%complete) then
          flag = .true.
          return
       end if
       cascade => cascade%next
    end do
  end function cascade_set_is_valid

@ %def cascade_set_is_valid
@ The initializer sets up the hash table with some initial size
guessed by looking at the number of external particles.  We choose 256
for 3 external particles and a factor of 4 for each additional
particle, limited at $2^{30}$=1G.

Note: the explicit initialization loop might be avoided (ELEMENTAL),
but a bug in nagfor 5.3.2 prevents this.
<<Cascades: parameters>>=
  real, parameter, public :: CASCADE_SET_FILL_RATIO = 0.1
<<Cascades: procedures>>=
  subroutine cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
        fatal_beam_decay, flv)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    type(flavor_t), dimension(:,:), intent(in), optional :: flv
    integer :: size_guess
    integer :: i, j
    cascade_set%model => model
    cascade_set%n_in = n_in
    cascade_set%n_out = n_out
    cascade_set%n_tot = n_in + n_out
    if (present (flv)) then
       allocate (cascade_set%flv (size (flv, 1), size (flv, 2)))
       do i = 1, size (flv, 2)
          do j = 1, size (flv, 1)
             call cascade_set%flv(j,i)%init (flv(j,i)%get_pdg (), model)
          end do
       end do
    end if
    select case (n_in)
    case (1);  cascade_set%depth_out = 2 * n_out - 3
    case (2);  cascade_set%depth_out = 2 * n_out - 1
    end select
    cascade_set%depth_tot = 2 * cascade_set%n_tot - 3
    cascade_set%sqrts = phs_par%sqrts
    cascade_set%m_threshold_s = phs_par%m_threshold_s
    cascade_set%m_threshold_t = phs_par%m_threshold_t
    cascade_set%off_shell = phs_par%off_shell
    cascade_set%t_channel = phs_par%t_channel
    cascade_set%keep_nonresonant = phs_par%keep_nonresonant
    cascade_set%fill_ratio = CASCADE_SET_FILL_RATIO
    size_guess = ishft (256, min (2 * (cascade_set%n_tot - 3), 22))
    cascade_set%n_entries_max = size_guess * cascade_set%fill_ratio
    cascade_set%mask = size_guess - 1
    allocate (cascade_set%entry (0:cascade_set%mask))
    cascade_set%fatal_beam_decay = fatal_beam_decay
  end subroutine cascade_set_init
    
@ %def cascade_set_init
@ The finalizer has to delete both the hash and the list.
<<Cascades: public>>=
  public :: cascade_set_final
<<Cascades: procedures>>=
  subroutine cascade_set_final (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: current
    integer :: i
    if (allocated (cascade_set%entry)) then
       do i = 0, cascade_set%mask
          call hash_entry_final (cascade_set%entry(i))
       end do
       deallocate (cascade_set%entry)
    end if
    do while (associated (cascade_set%first))
       current => cascade_set%first
       cascade_set%first => cascade_set%first%next
       deallocate (current)
    end do
  end subroutine cascade_set_final

@ %def cascade_set_final
@ Write the process in ASCII format, in columns that are headed by the
corresponding bincode.
<<Cascades: public>>=
  public :: cascade_set_write_process_bincode_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_process_bincode_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    integer, dimension(:), allocatable :: bincode, field_width
    integer :: n_in, n_out, n_tot, n_flv
    integer :: u, f, i, bc
    character(20) :: str
    type(string_t) :: fmt_head
    type(string_t), dimension(:), allocatable :: fmt_proc
    u = given_output_unit (unit);  if (u < 0)  return
    if (.not. allocated (cascade_set%flv)) return
    write (u, "('!',1x,A)")  "List of subprocesses with particle bincodes:"
    n_in  = cascade_set%n_in
    n_out = cascade_set%n_out
    n_tot = cascade_set%n_tot
    n_flv = size (cascade_set%flv, 2)
    allocate (bincode (n_tot), field_width (n_tot), fmt_proc (n_tot))
    bc = 1
    do i = 1, n_out
       bincode(n_in + i) = bc
       bc = 2 * bc
    end do
    do i = n_in, 1, -1
       bincode(i) = bc
       bc = 2 * bc
    end do       
    do i = 1, n_tot
       write (str, "(I0)")  bincode(i)
       field_width(i) = len_trim (str)
       do f = 1, n_flv
          field_width(i) = max (field_width(i), &
               len (cascade_set%flv(i,f)%get_name ()))
       end do
    end do
    fmt_head = "('!'"
    do i = 1, n_tot
       fmt_head = fmt_head // ",1x,"
       fmt_proc(i) = "(1x,"
       write (str, "(I0)")  field_width(i)
       fmt_head = fmt_head // "I" // trim(str)
       fmt_proc(i) = fmt_proc(i) // "A" // trim(str)
       if (i == n_in) then
          fmt_head = fmt_head // ",1x,'  '"
       end if
    end do
    !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug
    do i = 1, n_tot
       fmt_proc(i) = fmt_proc(i) // ")"
    end do
    fmt_head = fmt_head // ")"
    write (u, char (fmt_head))  bincode
    do f = 1, n_flv
       write (u, "('!')", advance="no")
       do i = 1, n_tot
          write (u, char (fmt_proc(i)), advance="no") &
               char (cascade_set%flv(i,f)%get_name ())
          if (i == n_in)  write (u, "(1x,'=>')", advance="no")
       end do
       write (u, *)
    end do
    write (u, char (fmt_head))  bincode
  end subroutine cascade_set_write_process_bincode_format

@ %def cascade_set_write_process_tex_format
@ Write the process as a \LaTeX\ expression.
<<Cascades: procedures>>=
  subroutine cascade_set_write_process_tex_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    integer :: u, f, i
    u = given_output_unit (unit);  if (u < 0)  return
    if (.not. allocated (cascade_set%flv)) return
    write (u, "(A)")  "\begin{align*}"
    do f = 1, size (cascade_set%flv, 2)
       do i = 1, cascade_set%n_in
          if (i > 1)  write (u, "(A)", advance="no") "\quad "
          write (u, "(A)", advance="no") &
               char (cascade_set%flv(i,f)%get_tex_name ())
       end do
       write (u, "(A)", advance="no")  "\quad &\to\quad "
       do i = cascade_set%n_in + 1, cascade_set%n_tot
          if (i > cascade_set%n_in + 1)  write (u, "(A)", advance="no") "\quad "
          write (u, "(A)", advance="no") &
               char (cascade_set%flv(i,f)%get_tex_name ())
       end do
       if (f < size (cascade_set%flv, 2)) then
          write (u, "(A)")  "\\"
       else
          write (u, "(A)")  ""
       end if
    end do       
    write (u, "(A)")  "\end{align*}"
  end subroutine cascade_set_write_process_tex_format

@ %def cascade_set_write_process_tex_format
@ Three output routines: phase-space file, graph source code, and
screen output.

This version generates the phase space file.  It deals only with
complete cascades.
<<Cascades: public>>=
  public :: cascade_set_write_file_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_file_format (cascade_set, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    type(cascade_t), pointer :: cascade
    integer :: u, grove, count
    logical :: first_in_grove
    u = given_output_unit (unit);  if (u < 0)  return
    count = 0
    do grove = 1, cascade_set%n_groves
       first_in_grove = .true.
       cascade => cascade_set%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                if (first_in_grove) then
                   first_in_grove = .false.
                   write (u, "(A)")
                   write (u, "(1x,'!',1x,A,1x,I0,A)", advance='no') &
                      'Multiplicity =', cascade%multiplicity, ","
                   select case (cascade%n_resonances)
                   case (0)
                      write (u, '(1x,A)', advance='no') 'no resonances, '
                   case (1)
                      write (u, '(1x,A)', advance='no') '1 resonance,  '
                   case default
                      write (u, '(1x,I0,1x,A)', advance='no') &
                           cascade%n_resonances, 'resonances, '
                   end select
                   write (u, '(1x,I0,1x,A)', advance='no') &
                        cascade%n_log_enhanced, 'logs, '
                   write (u, '(1x,I0,1x,A)', advance='no') &
                        cascade%n_off_shell, 'off-shell, '
                   select case (cascade%n_t_channel)
                   case (0);  write (u, '(1x,A)') 's-channel graph'
                   case (1);  write (u, '(1x,A)') '1 t-channel line'
                   case default
                      write(u,'(1x,I0,1x,A)') &
                           cascade%n_t_channel, 't-channel lines'
                   end select
                   write (u, '(1x,A,I0)') 'grove #', grove
                end if
                count = count + 1
                write (u, "(1x,'!',1x,A,I0)")  "Channel #", count
                call cascade_write_file_format (cascade, cascade_set%model, u)
             end if
          end if
          cascade => cascade%next
       end do
    end do
  end subroutine cascade_set_write_file_format

@ %def cascade_set_write_file_format
@ This is the graph output format, the driver-file
<<Cascades: public>>=
  public :: cascade_set_write_graph_format
<<Cascades: procedures>>=
  subroutine cascade_set_write_graph_format &
      (cascade_set, filename, process_id, unit)
    type(cascade_set_t), intent(in), target :: cascade_set
    type(string_t), intent(in) :: filename, process_id
    integer, intent(in), optional :: unit
    type(cascade_t), pointer :: cascade
    integer :: u, grove, count, pgcount
    logical :: first_in_grove
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(A)') "\documentclass[10pt]{article}"
    write (u, '(A)') "\usepackage{amsmath}"
    write (u, '(A)') "\usepackage{feynmp}"
    write (u, '(A)') "\usepackage{url}"
    write (u, '(A)') "\usepackage{color}"
    write (u, *)
    write (u, '(A)') "\textwidth 18.5cm"
    write (u, '(A)') "\evensidemargin -1.5cm"
    write (u, '(A)') "\oddsidemargin -1.5cm"
    write (u, *)
    write (u, '(A)') "\newcommand{\blue}{\color{blue}}"
    write (u, '(A)') "\newcommand{\green}{\color{green}}"
    write (u, '(A)') "\newcommand{\red}{\color{red}}"
    write (u, '(A)') "\newcommand{\magenta}{\color{magenta}}"
    write (u, '(A)') "\newcommand{\cyan}{\color{cyan}}"
    write (u, '(A)') "\newcommand{\sm}{\footnotesize}"
    write (u, '(A)') "\setlength{\parindent}{0pt}"
    write (u, '(A)') "\setlength{\parsep}{20pt}"
    write (u, *)
    write (u, '(A)') "\begin{document}"
    write (u, '(A)') "\begin{fmffile}{" // char (filename) // "}"
    write (u, '(A)') "\fmfcmd{color magenta; magenta = red + blue;}"
    write (u, '(A)') "\fmfcmd{color cyan; cyan = green + blue;}"
    write (u, '(A)') "\begin{fmfshrink}{0.5}"
    write (u, '(A)') "\begin{flushleft}"
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{\large\texttt{WHIZARD} phase space channels}" // &
         & "\hfill\today"
    write (u, *)
    write (u, '(A)') "\vspace{10pt}"
    write (u, '(A)') "\noindent" // &
         & "\textbf{Process:} \url{" // char (process_id) // "}"
    call cascade_set_write_process_tex_format (cascade_set, u)
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{Note:} These are pseudo Feynman graphs that " 
    write (u, '(A)') "visualize phase-space parameterizations " // &
         & "(``integration channels'').  "
    write (u, '(A)') "They do \emph{not} indicate Feynman graphs used for the " // &
	 & "matrix element."
    write (u, *)
    write (u, '(A)') "\textbf{Color code:} " // &
         & "{\blue resonance,} " // &
         & "{\cyan t-channel,} " // &
         & "{\green radiation,} "
    write (u, '(A)') "{\red infrared,} " // &
         & "{\magenta collinear,} " // &
         & "external/off-shell"
    write (u, *)
    write (u, '(A)') "\noindent" // &
         & "\textbf{Black square:} Keystone, indicates ordering of " // &
         & "phase space parameters."
    write (u, *)
    write (u, '(A)') "\vspace{-20pt}"
    count = 0
    pgcount = 0
    do grove = 1, cascade_set%n_groves
       first_in_grove = .true.
       cascade => cascade_set%first
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                if (first_in_grove) then
                   first_in_grove = .false.
                   write (u, *)
                   write (u, '(A)') "\vspace{20pt}"
                   write (u, '(A)') "\begin{tabular}{l}"
                   write (u, '(A,I5,A)') &
                        & "\fbox{\bf Grove \boldmath$", grove, "$} \\[10pt]"
                   write (u, '(A,I1,A)') "Multiplicity: ", &
                        cascade%multiplicity, "\\"
                   write (u, '(A,I1,A)') "Resonances:   ", &
                        cascade%n_resonances, "\\"
                   write (u, '(A,I1,A)') "Log-enhanced: ", &
                        cascade%n_log_enhanced, "\\"
                   write (u, '(A,I1,A)') "Off-shell:    ", &
                        cascade%n_off_shell, "\\"
                   write (u, '(A,I1,A)') "t-channel:    ", &
                        cascade%n_t_channel, ""
                   write (u, '(A)') "\end{tabular}"
                end if
                count = count + 1
                call cascade_write_graph_format (cascade, count, unit)
                if (pgcount >= 250) then
                   write (u, '(A)') "\clearpage"
                   pgcount = 0
                end if
             end if
          end if
          cascade => cascade%next
       end do
    end do
    write (u, '(A)') "\end{flushleft}"
    write (u, '(A)') "\end{fmfshrink}"
    write (u, '(A)') "\end{fmffile}"
    write (u, '(A)') "\end{document}"
 end subroutine cascade_set_write_graph_format

@ %def cascade_set_write_graph_format
@ This is for screen output and debugging:
<<Cascades: public>>=
  public :: cascade_set_write
<<Cascades: procedures>>=
  subroutine cascade_set_write (cascade_set, unit, active_only, complete_only)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: active_only, complete_only
    logical :: active, complete
    type(cascade_t), pointer :: cascade
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    active = .true.;  if (present (active_only))  active = active_only
    complete = .false.;  if (present (complete_only))  complete = complete_only
    write (u, "(A)") "Cascade set:"
    write (u, "(3x,A)", advance="no")  "Model:"
    if (associated (cascade_set%model)) then
       write (u, "(1x,A)") char (cascade_set%model%get_name ())
    else
       write (u, "(1x,A)") "[none]"
    end if
    write (u, "(3x,A)", advance="no")  "n_in/out/tot  ="
    write (u, "(3(1x,I7))")  &
         cascade_set%n_in, cascade_set%n_out, cascade_set%n_tot
    write (u, "(3x,A)", advance="no")  "depth_out/tot ="
    write (u, "(2(1x,I7))")  cascade_set%depth_out, cascade_set%depth_tot
    write (u, "(3x,A)", advance="no")  "mass thr(s/t) ="
    write (u, "(2(1x," // FMT_19 // "))")  &
         cascade_set%m_threshold_s, cascade_set%m_threshold_t
    write (u, "(3x,A)", advance="no")  "off shell     ="
    write (u, "(1x,I7)")  cascade_set%off_shell
    write (u, "(3x,A)", advance="no")  "keep_nonreson ="
    write (u, "(1x,L1)")  cascade_set%keep_nonresonant
    write (u, "(3x,A)", advance="no")  "n_groves      ="
    write (u, "(1x,I7)")  cascade_set%n_groves
    write (u, "(A)")
    write (u, "(A)") "Cascade list:"
    if (associated (cascade_set%first)) then
       cascade => cascade_set%first
       do while (associated (cascade))
          if (active .and. .not. cascade%active)  cycle
          if (complete .and. .not. cascade%complete)  cycle
          call cascade_write (cascade, unit)
          cascade => cascade%next
       end do
    else
       write (u, "(A)") "[empty]"
    end if
    write (u, "(A)") "Hash array"
    write (u, "(3x,A)", advance="no")  "n_entries     ="
    write (u, "(1x,I7)")  cascade_set%n_entries
    write (u, "(3x,A)", advance="no")  "fill_ratio    ="
    write (u, "(1x," // FMT_12 // ")")  cascade_set%fill_ratio
    write (u, "(3x,A)", advance="no")  "n_entries_max ="
    write (u, "(1x,I7)")  cascade_set%n_entries_max
    write (u, "(3x,A)", advance="no")  "mask          ="
    write (u, "(1x,I0)")  cascade_set%mask
    do i = 0, ubound (cascade_set%entry, 1)
       if (allocated (cascade_set%entry(i)%key)) then
          write (u, "(1x,I7)") i
          call hash_entry_write (cascade_set%entry(i), u)
       end if
    end do
  end subroutine cascade_set_write

@ %def cascade_set_write
@ 
\subsection{Adding cascades}
Add a deep copy of a cascade to the set.  The copy has all content of the
original, but the pointers are nullified.  We do not care whether insertion
was successful or not.  The pointer argument, if present, is assigned to the
input cascade, or to the hash entry if it is already present.

The procedure is recursive: any daughter or mother entries are also
deep-copied and added to the cascade set before the current copy is added.
<<Cascades: procedures>>=
  recursive subroutine cascade_set_add_copy &
       (cascade_set, cascade_in, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in) :: cascade_in
    type(cascade_t), optional, pointer :: cascade_ptr
    type(cascade_t), pointer :: cascade
    logical :: ok
    allocate (cascade)
    cascade = cascade_in
    if (associated (cascade_in%daughter1))  call cascade_set_add_copy &
         (cascade_set, cascade_in%daughter1, cascade%daughter1)
    if (associated (cascade_in%daughter2))  call cascade_set_add_copy &
         (cascade_set, cascade_in%daughter2, cascade%daughter2)
    if (associated (cascade_in%mother))  call cascade_set_add_copy &
         (cascade_set, cascade_in%mother, cascade%mother)
    cascade%next => null ()
    call cascade_set_add (cascade_set, cascade, ok, cascade_ptr)
    if (.not. ok)  deallocate (cascade)
  end subroutine cascade_set_add_copy

@ %def cascade_set_add_copy
@ Add a cascade to the set.  This does not deep-copy.  We first try to insert
it in the hash array.  If successful, add it to the list.  Failure indicates
that it is already present, and we drop it.

The hash key is built solely from the tree array, so neither particle
codes nor resonances count, just topology.

Technically, hash and list receive only pointers, so the cascade can
be considered as being in either of both.  We treat it as part of the
list.
<<Cascades: procedures>>=
  subroutine cascade_set_add (cascade_set, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i8), dimension(1) :: mold
    call cascade_set_hash_insert &
         (cascade_set, transfer (cascade%tree, mold), cascade, ok, cascade_ptr)
    if (ok)  call cascade_set_list_add (cascade_set, cascade)
  end subroutine cascade_set_add

@ %def cascade_set_add
@ Add a new cascade to the list:
<<Cascades: procedures>>=
  subroutine cascade_set_list_add (cascade_set, cascade)
    type(cascade_set_t), intent(inout) :: cascade_set
    type(cascade_t), intent(in), target :: cascade
    if (associated (cascade_set%last)) then
       cascade_set%last%next => cascade
    else
       cascade_set%first => cascade
    end if
    cascade_set%last => cascade
  end subroutine cascade_set_list_add

@ %def cascade_set_list_add
@ Add a cascade entry to the hash array:
<<Cascades: procedures>>=
  subroutine cascade_set_hash_insert &
       (cascade_set, key, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer(i8), dimension(:), intent(in) :: key
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out) :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i32) :: h
    if (cascade_set%n_entries >= cascade_set%n_entries_max) &
         call cascade_set_hash_expand (cascade_set)
    h = hash (key)
    call cascade_set_hash_insert_rec &
         (cascade_set, h, h, key, cascade, ok, cascade_ptr)
  end subroutine cascade_set_hash_insert

@ %def cascade_set_hash_insert
@ Double the hashtable size when necesssary:
<<Cascades: procedures>>=
  subroutine cascade_set_hash_expand (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(hash_entry_t), dimension(:), allocatable, target :: table_tmp
    type(cascade_p), pointer :: current
    integer :: i, s
    allocate (table_tmp (0:cascade_set%mask))
    table_tmp = cascade_set%entry
    deallocate (cascade_set%entry)
    s = 2 * size (table_tmp)
    cascade_set%n_entries = 0
    cascade_set%n_entries_max = s * cascade_set%fill_ratio
    cascade_set%mask = s - 1
    allocate (cascade_set%entry (0:cascade_set%mask))
    do i = 0, ubound (table_tmp, 1)
       current => table_tmp(i)%first
       do while (associated (current))
          call cascade_set_hash_insert_rec &
               (cascade_set, table_tmp(i)%hashval, table_tmp(i)%hashval, &
                table_tmp(i)%key, current%cascade)
          current => current%next
       end do
    end do
  end subroutine cascade_set_hash_expand

@ %def cascade_set_hash_expand
@ Insert the cascade at the bucket determined by the hash value.  If
the bucket is filled, check first for a collision (unequal keys).  In
that case, choose the following bucket and repeat.  Otherwise, add the
cascade to the bucket.

If the bucket is empty, record the hash value, allocate and store the
key, and then add the cascade to the bucket.

If [[ok]] is present, before insertion we check whether the cascade is
already stored, and return failure if yes.
<<Cascades: procedures>>=
  recursive subroutine cascade_set_hash_insert_rec &
       (cascade_set, h, hashval, key, cascade, ok, cascade_ptr)
    type(cascade_set_t), intent(inout) :: cascade_set
    integer(i32), intent(in) :: h, hashval
    integer(i8), dimension(:), intent(in) :: key
    type(cascade_t), intent(in), target :: cascade
    logical, intent(out), optional :: ok
    type(cascade_t), optional, pointer :: cascade_ptr
    integer(i32) :: i
    i = iand (h, cascade_set%mask)
    if (allocated (cascade_set%entry(i)%key)) then
       if (size (cascade_set%entry(i)%key) /= size (key)) then
          call cascade_set_hash_insert_rec &
               (cascade_set, h + 1, hashval, key, cascade, ok, cascade_ptr)
       else if (any (cascade_set%entry(i)%key /= key)) then
          call cascade_set_hash_insert_rec &
               (cascade_set, h + 1, hashval, key, cascade, ok, cascade_ptr)
       else
          call hash_entry_add_cascade_ptr &
               (cascade_set%entry(i), cascade, ok, cascade_ptr)
       end if
    else
       cascade_set%entry(i)%hashval = hashval
       allocate (cascade_set%entry(i)%key (size (key)))
       cascade_set%entry(i)%key = key
       call hash_entry_add_cascade_ptr &
            (cascade_set%entry(i), cascade, ok, cascade_ptr)
       cascade_set%n_entries = cascade_set%n_entries + 1
    end if
  end subroutine cascade_set_hash_insert_rec

@ %def cascade_set_hash_insert_rec
@ 
\subsection{External particles}
We want to initialize the cascade set with the outgoing particles.  In
case of multiple processes, initial cascades are prepared for all of
them.  The hash array check ensures that no particle appears more than
once at the same place.
<<Cascades: interfaces>>=
  interface cascade_set_add_outgoing
     module procedure cascade_set_add_outgoing1
     module procedure cascade_set_add_outgoing2
  end interface
 
<<Cascades: procedures>>=
  subroutine cascade_set_add_outgoing2 (cascade_set, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(flavor_t), dimension(:,:), intent(in) :: flv
    integer :: pos, prc, n_out, n_prc
    type(cascade_t), pointer :: cascade
    logical :: ok
    n_out = size (flv, dim=1)
    n_prc = size (flv, dim=2)
    do prc = 1, n_prc
       do pos = 1, n_out
          allocate (cascade)
          call cascade_init_outgoing &
               (cascade, flv(pos,prc), pos, cascade_set%m_threshold_s)
          call cascade_set_add (cascade_set, cascade, ok)
          if (.not. ok) then
             deallocate (cascade)
          end if
       end do
    end do
  end subroutine cascade_set_add_outgoing2

  subroutine cascade_set_add_outgoing1 (cascade_set, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(flavor_t), dimension(:), intent(in) :: flv
    integer :: pos, n_out
    type(cascade_t), pointer :: cascade
    logical :: ok
    n_out = size (flv, dim=1)
    do pos = 1, n_out
       allocate (cascade)
       call cascade_init_outgoing &
            (cascade, flv(pos), pos, cascade_set%m_threshold_s)
       call cascade_set_add (cascade_set, cascade, ok)
       if (.not. ok) then
          deallocate (cascade)
       end if
    end do
  end subroutine cascade_set_add_outgoing1

@ %def cascade_set_add_outgoing
@ The incoming particles are added one at a time.  Nevertheless, we
may have several processes which are looped over.  At the first
opportunity, we set the pointer [[first_t]] in the cascade set which
should point to the first t-channel cascade.

Return the indices of the first and last cascade generated.
<<Cascades: interfaces>>=
  interface cascade_set_add_incoming
     module procedure cascade_set_add_incoming0
     module procedure cascade_set_add_incoming1
  end interface
 
<<Cascades: procedures>>=
  subroutine cascade_set_add_incoming1 (cascade_set, n1, n2, pos, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(out) :: n1, n2
    integer, intent(in) :: pos
    type(flavor_t), dimension(:), intent(in) :: flv
    integer :: prc, n_prc
    type(cascade_t), pointer :: cascade
    logical :: ok
    n1 = 0
    n2 = 0
    n_prc = size (flv)
    do prc = 1, n_prc
       allocate (cascade)
       call cascade_init_incoming &
            (cascade, flv(prc), pos, cascade_set%m_threshold_t)
       call cascade_set_add (cascade_set, cascade, ok)
       if (ok) then
          if (n1 == 0)  n1 = cascade%index
          n2 = cascade%index
          if (.not. associated (cascade_set%first_t)) then
             cascade_set%first_t => cascade
          end if
       else
          deallocate (cascade)
       end if
    end do
  end subroutine cascade_set_add_incoming1

  subroutine cascade_set_add_incoming0 (cascade_set, n1, n2, pos, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(out) :: n1, n2
    integer, intent(in) :: pos
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade
    logical :: ok
    n1 = 0
    n2 = 0
    allocate (cascade)
    call cascade_init_incoming &
         (cascade, flv, pos, cascade_set%m_threshold_t)
    call cascade_set_add (cascade_set, cascade, ok)
    if (ok) then
       if (n1 == 0)  n1 = cascade%index
       n2 = cascade%index
       if (.not. associated (cascade_set%first_t)) then
          cascade_set%first_t => cascade
       end if
    else
       deallocate (cascade)
    end if
  end subroutine cascade_set_add_incoming0

@ %def cascade_set_add_incoming
@ 
\subsection{Cascade combination I: flavor assignment}
We have two disjunct cascades, now use the vertex table to determine
the possible flavors of the combination cascade.  For each
possibility, try to generate a new cascade.  The total cascade depth
has to be one less than the limit, because this is reached by setting
the keystone.
<<Cascades: procedures>>=
  subroutine cascade_match_pair (cascade_set, cascade1, cascade2, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    logical, intent(in) :: s_channel
    integer, dimension(:), allocatable :: pdg3
    integer :: i, depth_max
    type(flavor_t) :: flv
    if (s_channel) then
       depth_max = cascade_set%depth_out
    else
       depth_max = cascade_set%depth_tot
    end if
    if (cascade1%depth + cascade2%depth < depth_max) then
       call cascade_set%model%match_vertex ( &
            cascade1%flv%get_pdg (), &
            cascade2%flv%get_pdg (), &
            pdg3)
       do i = 1, size (pdg3)
          call flv%init (pdg3(i), cascade_set%model)
          if (s_channel) then
             call cascade_combine_s (cascade_set, cascade1, cascade2, flv)
          else
             call cascade_combine_t (cascade_set, cascade1, cascade2, flv)
          end if
       end do
       deallocate (pdg3)
    end if
  end subroutine cascade_match_pair

@ %def cascade_match_pair
@ The triplet version takes a third cascade, and we check whether this
triplet has a matching vertex in the database.  If yes, we make a
keystone cascade.
<<Cascades: procedures>>=
  subroutine cascade_match_triplet &
       (cascade_set, cascade1, cascade2, cascade3, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    logical, intent(in) :: s_channel
    integer :: depth_max
    depth_max = cascade_set%depth_tot
    if (cascade1%depth + cascade2%depth + cascade3%depth == depth_max) then
       if (cascade_set%model%check_vertex ( &
            cascade1%flv%get_pdg (), &
            cascade2%flv%get_pdg (), &
            cascade3%flv%get_pdg ())) then
          call cascade_combine_keystone &
               (cascade_set, cascade1, cascade2, cascade3, s_channel)
       end if
    end if
  end subroutine cascade_match_triplet

@ %def cascade_match_triplet
@
\subsection{Cascade combination II: kinematics setup and check}
Having three matching flavors, we start constructing the combination
cascade.  We look at the mass hierarchies and determine whether the
cascade is to be kept.  In passing we set mapping modes, resonance
properties and such.

If successful, the cascade is finalized.  For a resonant cascade, we
prepare in addition a copy without the resonance.
<<Cascades: procedures>>=
  subroutine cascade_combine_s (cascade_set, cascade1, cascade2, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade3, cascade4
    logical :: keep
    keep = .false.
    allocate (cascade3)
    call cascade_init (cascade3, cascade1%depth + cascade2%depth + 1)
    cascade3%bincode = ior (cascade1%bincode, cascade2%bincode)
    cascade3%flv = flv%anti ()
    cascade3%pdg = abs (cascade3%flv%get_pdg ())
    cascade3%is_vector = flv%get_spin_type () == VECTOR
    cascade3%m_min = cascade1%m_min + cascade2%m_min
    cascade3%m_rea = flv%get_mass ()
    if (cascade3%m_rea > cascade_set%m_threshold_s) then
       cascade3%m_eff = cascade3%m_rea
    end if
    ! Potentially resonant cases [sqrts = m_rea for on-shell decay]
    if (cascade3%m_rea > cascade3%m_min &
         .and. cascade3%m_rea <= cascade_set%sqrts) then
       if (flv%get_width () /= 0) then
          if (cascade1%on_shell .or. cascade2%on_shell) then
             keep = .true.
             cascade3%mapping = S_CHANNEL
             cascade3%resonant = .true.
          end if
       else
          call warn_decay (flv)
       end if
    ! Collinear and IR singular cases
    else if (cascade3%m_rea < cascade_set%sqrts) then
       ! Massless splitting
       if (cascade1%m_eff == 0 .and. cascade2%m_eff == 0 &
            .and. cascade3%depth <= 3) then
          keep = .true.
          cascade3%log_enhanced = .true.
          if (cascade3%is_vector) then
             if (cascade1%is_vector .and. cascade2%is_vector) then
                cascade3%mapping = COLLINEAR   ! three-vector-vertex
             else
                cascade3%mapping = INFRARED    ! vector splitting into matter
             end if
          else
             if (cascade1%is_vector .or. cascade2%is_vector) then
                cascade3%mapping = COLLINEAR   ! vector radiation off matter
             else
                cascade3%mapping = INFRARED    ! scalar radiation/splitting
             end if
          end if
       ! IR radiation off massive particle
       else if (cascade3%m_eff > 0 .and. cascade1%m_eff > 0 &
            .and. cascade2%m_eff == 0 &
            .and. (cascade1%on_shell .or. cascade1%mapping == RADIATION) &
            .and. abs (cascade3%m_eff - cascade1%m_eff) &
                       < cascade_set%m_threshold_s) &
            then
          keep = .true.
          cascade3%log_enhanced = .true.
          cascade3%mapping = RADIATION
       else if (cascade3%m_eff > 0 .and. cascade2%m_eff > 0 &
            .and. cascade1%m_eff == 0 &
            .and. (cascade2%on_shell .or. cascade2%mapping == RADIATION) &
            .and. abs (cascade3%m_eff - cascade2%m_eff) &
                  < cascade_set%m_threshold_s) &
            then
          keep = .true.
          cascade3%log_enhanced = .true.
          cascade3%mapping = RADIATION
       end if
    end if
    ! Non-singular cases, including failed resonances
    if (.not. keep) then
       ! Two on-shell particles from a virtual mother
       if (cascade1%on_shell .or. cascade2%on_shell) then
          keep = .true.
          cascade3%m_eff = max (cascade3%m_min, &
                                cascade1%m_eff + cascade2%m_eff)
          if (cascade3%m_eff < cascade_set%m_threshold_s) then
             cascade3%m_eff = 0
          end if
       end if
    end if
    ! Complete and register the cascade (two in case of resonance)
    if (keep) then
       cascade3%on_shell = cascade3%resonant .or. cascade3%log_enhanced
       if (cascade3%resonant) then
          cascade3%pdg = abs (cascade3%flv%get_pdg ())
	  if (cascade_set%keep_nonresonant) then
             allocate (cascade4)
             cascade4 = cascade3
             cascade4%index = cascade_index ()
             cascade4%pdg = UNDEFINED
             cascade4%mapping = NO_MAPPING
             cascade4%resonant = .false.
             cascade4%on_shell = .false.
          end if      
	  cascade3%m_min = cascade3%m_rea
          call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
	  if (cascade_set%keep_nonresonant) then
             call cascade_fusion (cascade_set, cascade1, cascade2, cascade4)
          end if
       else
          call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
       end if
    else
       deallocate (cascade3)
    end if
  contains
    subroutine warn_decay (flv)
      type(flavor_t), intent(in) :: flv
      integer :: i
      integer, dimension(MAX_WARN_RESONANCE), save :: warned_code = 0
      LOOP_WARNED: do i = 1, MAX_WARN_RESONANCE
         if (warned_code(i) == 0) then
            warned_code(i) = flv%get_pdg ()
            write (msg_buffer, "(A)") &
                 & " Intermediate decay of zero-width particle " &
                 & // char (flv%get_name ()) &
                 & // " may be possible."
            call msg_warning
            exit LOOP_WARNED
         else if (warned_code(i) == flv%get_pdg ()) then
            exit LOOP_WARNED
         end if
      end do LOOP_WARNED
    end subroutine warn_decay
  end subroutine cascade_combine_s

@ %def cascade_combine_s
<<Cascades: parameters>>=
  integer, parameter, public :: MAX_WARN_RESONANCE = 50
@ %def MAX_WARN_RESONANCE
@ This is the t-channel version.  [[cascade1]] is t-channel and
contains the seed, [[cascade2]] is s-channel.  We check for
kinematically allowed beam decay (which is a fatal error), or massless
splitting / soft radiation.  The cascade is kept in all remaining
cases and submitted for registration.
<<Cascades: procedures>>=
  subroutine cascade_combine_t (cascade_set, cascade1, cascade2, flv)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(flavor_t), intent(in) :: flv
    type(cascade_t), pointer :: cascade3
    allocate (cascade3)
    call cascade_init (cascade3, cascade1%depth + cascade2%depth + 1)
    cascade3%bincode = ior (cascade1%bincode, cascade2%bincode)
    cascade3%flv = flv%anti ()
    cascade3%pdg = abs (cascade3%flv%get_pdg ())
    cascade3%is_vector = flv%get_spin_type () == VECTOR
    if (cascade1%incoming) then
       cascade3%m_min = cascade2%m_min
    else
       cascade3%m_min = cascade1%m_min + cascade2%m_min
    end if
    cascade3%m_rea = flv%get_mass ()
    if (cascade3%m_rea > cascade_set%m_threshold_t) then
       cascade3%m_eff = max (cascade3%m_rea, cascade2%m_eff)
    else if (cascade2%m_eff > cascade_set%m_threshold_t) then
       cascade3%m_eff = cascade2%m_eff
    else
       cascade3%m_eff = 0
    end if
    ! Allowed decay of beam particle
    if (cascade1%incoming &
         .and. cascade1%m_rea > cascade2%m_rea + cascade3%m_rea) then
         call beam_decay (cascade_set%fatal_beam_decay)
    ! Massless splitting
    else if (cascade1%m_eff == 0 &
         .and. cascade2%m_eff < cascade_set%m_threshold_t &
         .and. cascade3%m_eff == 0) then
       cascade3%mapping = U_CHANNEL
       cascade3%log_enhanced = .true.
    ! IR radiation off massive particle
    else if (cascade1%m_eff /= 0 .and. cascade2%m_eff == 0 &
         .and. cascade3%m_eff /= 0 &
         .and. (cascade1%on_shell .or. cascade1%mapping == RADIATION) &
         .and. abs (cascade1%m_eff - cascade3%m_eff) &
               < cascade_set%m_threshold_t) &
         then
       cascade3%pdg = abs (flv%get_pdg ())
       cascade3%log_enhanced = .true.
       cascade3%mapping = RADIATION
    end if
    cascade3%t_channel = .true.
    call cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
  contains
    subroutine beam_decay (fatal_beam_decay)
      logical, intent(in) :: fatal_beam_decay
      write (msg_buffer, "(1x,A,1x,'->',1x,A,1x,A)") &
           char (cascade1%flv%get_name ()), &
           char (cascade3%flv%get_name ()), &
           char (cascade2%flv%get_name ())
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (cascade1%flv%get_name ()), cascade1%m_rea
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (cascade3%flv%get_name ()), cascade3%m_rea
      call msg_message
      write (msg_buffer, "(1x,'mass(',A,') =',1x,E17.10)") &
           char (cascade2%flv%get_name ()), cascade2%m_rea
      call msg_message
      if (fatal_beam_decay) then
         call msg_fatal (" Phase space: Initial beam particle can decay")
      else
         call msg_warning (" Phase space: Initial beam particle can decay")
      end if 
    end subroutine beam_decay
  end subroutine cascade_combine_t

@ %def cascade_combine_t
@ Here we complete a decay cascade.  The third input is the
single-particle cascade for the initial particle.  There is no
resonance or mapping assignment.  The only condition for keeping the
cascade is the mass sum of the final state, which must be less than
the available energy.

Two modifications are necessary for scattering cascades: a pure
s-channel diagram (cascade1 is the incoming particle) do not have a
logarithmic mapping at top-level.  And in a t-channel diagram, the
last line exchanged is mapped t-channel, not u-channel.  Finally, we
can encounter the case of a $2\to 1$ process, where cascade1 is
incoming, and cascade2 is the outgoing particle.  In all three cases
we register a new cascade with the modified mapping.
<<Cascades: procedures>>=
  subroutine cascade_combine_keystone &
       (cascade_set, cascade1, cascade2, cascade3, s_channel)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    logical, intent(in) :: s_channel
    type(cascade_t), pointer :: cascade4, cascade0
    logical :: keep, ok
    keep = .false.
    allocate (cascade4)
    call cascade_init &
         (cascade4, cascade1%depth + cascade2%depth + cascade3%depth)
    cascade4%complete = .true.
    if (s_channel) then
       cascade4%bincode = ior (cascade1%bincode, cascade2%bincode)
    else
       cascade4%bincode = cascade3%bincode
    end if
    cascade4%flv = cascade3%flv
    cascade4%pdg = cascade3%pdg
    cascade4%mapping = EXTERNAL_PRT
    cascade4%is_vector = cascade3%is_vector
    cascade4%m_min = cascade1%m_min + cascade2%m_min
    cascade4%m_rea = cascade3%m_rea
    cascade4%m_eff = cascade3%m_rea
    if (cascade4%m_min < cascade_set%sqrts) then
       keep = .true.
    end if
    if (keep) then
       if (cascade1%incoming .and. cascade2%log_enhanced) then
          allocate (cascade0)
          cascade0 = cascade2
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = NO_MAPPING
          cascade0%log_enhanced = .false.
          cascade0%n_log_enhanced = cascade0%n_log_enhanced - 1
          cascade0%tree_mapping(cascade0%depth) = NO_MAPPING
          call cascade_keystone &
               (cascade_set, cascade1, cascade0, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else if (cascade1%t_channel .and. cascade1%mapping == U_CHANNEL) then
          allocate (cascade0)
          cascade0 = cascade1
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = T_CHANNEL
          cascade0%tree_mapping(cascade0%depth) = T_CHANNEL
          call cascade_keystone &
               (cascade_set, cascade0, cascade2, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else if (cascade1%incoming .and. cascade2%depth == 1) then
          allocate (cascade0)
          cascade0 = cascade2
          cascade0%next => null ()
          cascade0%index = cascade_index ()
          cascade0%mapping = ON_SHELL
          cascade0%tree_mapping(cascade0%depth) = ON_SHELL
          call cascade_keystone &
               (cascade_set, cascade1, cascade0, cascade3, cascade4, ok)
          if (ok) then
             call cascade_set_add (cascade_set, cascade0, ok)
          else
             deallocate (cascade0)
          end if
       else
          call cascade_keystone &
               (cascade_set, cascade1, cascade2, cascade3, cascade4, ok)
       end if
    else
       deallocate (cascade4)
    end if
  end subroutine cascade_combine_keystone

@ %def cascade_combine_keystone
@
\subsection{Cascade combination III: node connections and tree fusion}
Here we assign global tree properties.  If the allowed number of
off-shell lines is exceeded, discard the new cascade.  Otherwise,
assign the trees, sort them, and assign connections.  Finally, append
the cascade to the list.  This may fail (because in the hash array
there is already an equivalent cascade).  On failure, discard the
cascade.
<<Cascades: procedures>>=
  subroutine cascade_fusion (cascade_set, cascade1, cascade2, cascade3)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2
    type(cascade_t), pointer :: cascade3
    integer :: i1, i2, i3, i4
    logical :: ok
    cascade3%internal = (cascade3%depth - 3) / 2
    if (cascade3%resonant) then
       cascade3%multiplicity = 1
       cascade3%n_resonances = &
            cascade1%n_resonances + cascade2%n_resonances + 1
    else
       cascade3%multiplicity = cascade1%multiplicity + cascade2%multiplicity
       cascade3%n_resonances = cascade1%n_resonances + cascade2%n_resonances
    end if
    if (cascade3%log_enhanced) then
       cascade3%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced + 1
    else
       cascade3%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced
    end if
    if (cascade3%resonant) then
       cascade3%n_off_shell = 0    
    else if (cascade3%log_enhanced) then
       cascade3%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell
    else
       cascade3%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell + 1
    end if
    if (cascade3%t_channel) then
       cascade3%n_t_channel = cascade1%n_t_channel + 1
    end if
    if (cascade3%n_off_shell > cascade_set%off_shell) then
       deallocate (cascade3)
    else if (cascade3%n_t_channel > cascade_set%t_channel) then
       deallocate (cascade3)
    else
       i1 = cascade1%depth
       i2 = i1 + 1
       i3 = i1 + cascade2%depth
       i4 = cascade3%depth
       cascade3%tree(:i1) = cascade1%tree
       where (cascade1%tree_mapping > NO_MAPPING)
          cascade3%tree_pdg(:i1) = cascade1%tree_pdg
       elsewhere
          cascade3%tree_pdg(:i1) = UNDEFINED
       end where
       cascade3%tree_mapping(:i1) = cascade1%tree_mapping
       cascade3%tree_resonant(:i1) = cascade1%tree_resonant
       cascade3%tree(i2:i3) = cascade2%tree
       where (cascade2%tree_mapping > NO_MAPPING)
          cascade3%tree_pdg(i2:i3) = cascade2%tree_pdg
       elsewhere
          cascade3%tree_pdg(i2:i3) = UNDEFINED
       end where
       cascade3%tree_mapping(i2:i3) = cascade2%tree_mapping
       cascade3%tree_resonant(i2:i3) = cascade2%tree_resonant
       cascade3%tree(i4) = cascade3%bincode
       cascade3%tree_pdg(i4) = cascade3%pdg
       cascade3%tree_mapping(i4) = cascade3%mapping
       cascade3%tree_resonant(i4) = cascade3%resonant
       call tree_sort (cascade3%tree, &
            cascade3%tree_pdg, cascade3%tree_mapping, cascade3%tree_resonant)
       cascade3%has_children = .true.
       cascade3%daughter1 => cascade1
       cascade3%daughter2 => cascade2
       call cascade_set_add (cascade_set, cascade3, ok)
       if (.not. ok)  deallocate (cascade3)
    end if
  end subroutine cascade_fusion

@ %def cascade_fusion
@ Here we combine a cascade pair with an incoming particle, i.e., we
set a keystone.  Otherwise, this is similar.  On the first
opportunity, we set the [[first_k]] pointer in the cascade set.
<<Cascades: procedures>>=
  subroutine cascade_keystone &
       (cascade_set, cascade1, cascade2, cascade3, cascade4, ok)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), intent(in), target :: cascade1, cascade2, cascade3
    type(cascade_t), pointer :: cascade4
    logical, intent(out) :: ok
    integer :: i1, i2, i3, i4
    cascade4%internal = (cascade4%depth - 3) / 2
    cascade4%multiplicity = cascade1%multiplicity + cascade2%multiplicity
    cascade4%n_resonances = cascade1%n_resonances + cascade2%n_resonances
    cascade4%n_off_shell = cascade1%n_off_shell + cascade2%n_off_shell
    cascade4%n_log_enhanced = &
            cascade1%n_log_enhanced + cascade2%n_log_enhanced
    cascade4%n_t_channel = cascade1%n_t_channel + cascade2%n_t_channel
    if (cascade4%n_off_shell > cascade_set%off_shell) then
       deallocate (cascade4)
       ok = .false.
    else if (cascade4%n_t_channel > cascade_set%t_channel) then
       deallocate (cascade4)
       ok = .false.
    else
       i1 = cascade1%depth
       i2 = i1 + 1
       i3 = i1 + cascade2%depth
       i4 = cascade4%depth
       cascade4%tree(:i1) = cascade1%tree
       where (cascade1%tree_mapping > NO_MAPPING)
          cascade4%tree_pdg(:i1) = cascade1%tree_pdg
       elsewhere
          cascade4%tree_pdg(:i1) = UNDEFINED
       end where
       cascade4%tree_mapping(:i1) = cascade1%tree_mapping
       cascade4%tree_resonant(:i1) = cascade1%tree_resonant
       cascade4%tree(i2:i3) = cascade2%tree
       where (cascade2%tree_mapping > NO_MAPPING)
          cascade4%tree_pdg(i2:i3) = cascade2%tree_pdg
       elsewhere
          cascade4%tree_pdg(i2:i3) = UNDEFINED
       end where
       cascade4%tree_mapping(i2:i3) = cascade2%tree_mapping
       cascade4%tree_resonant(i2:i3) = cascade2%tree_resonant
       cascade4%tree(i4) = cascade4%bincode
       cascade4%tree_pdg(i4) = UNDEFINED
       cascade4%tree_mapping(i4) = cascade4%mapping
       cascade4%tree_resonant(i4) = .false.
       call tree_sort (cascade4%tree, &
            cascade4%tree_pdg, cascade4%tree_mapping, cascade4%tree_resonant)
       cascade4%has_children = .true.
       cascade4%daughter1 => cascade1
       cascade4%daughter2 => cascade2
       cascade4%mother => cascade3
       call cascade_set_add (cascade_set, cascade4, ok)
       if (ok) then
          if (.not. associated (cascade_set%first_k)) then
             cascade_set%first_k => cascade4
          end if
       else
          deallocate (cascade4)
       end if
    end if
  end subroutine cascade_keystone

@ %def cascade_keystone
@ 
Sort a tree (array of binary codes) and particle code array
simultaneously, by ascending binary codes.  A convenient method is to
use the [[maxloc]] function iteratively, to find and remove the
largest entry in the tree array one by one.
<<Cascades: procedures>>=
  subroutine tree_sort (tree, pdg, mapping, resonant)
    integer(TC), dimension(:), intent(inout) :: tree
    integer, dimension(:), intent(inout) :: pdg, mapping
    logical, dimension(:), intent(inout) :: resonant
    integer(TC), dimension(size(tree)) :: tree_tmp
    integer, dimension(size(pdg)) :: pdg_tmp, mapping_tmp
    logical, dimension(size(resonant)) :: resonant_tmp
    integer, dimension(1) :: pos
    integer :: i
    tree_tmp = tree
    pdg_tmp = pdg
    mapping_tmp = mapping
    resonant_tmp = resonant
    do i = size(tree),1,-1
       pos = maxloc (tree_tmp)
       tree(i) = tree_tmp (pos(1))
       pdg(i) = pdg_tmp (pos(1))
       mapping(i) = mapping_tmp (pos(1))
       resonant(i) = resonant_tmp (pos(1))
       tree_tmp(pos(1)) = 0
    end do
  end subroutine tree_sort

@ %def tree_sort
@ 
\subsection{Cascade set generation}
These procedures loop over cascades and build up the cascade set.  After each
iteration of the innermost loop, we set a breakpoint.

s-channel: We use a nested scan to combine all cascades with all other
cascades.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_s (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    cascade1 => cascade_set%first
    LOOP1: do while (associated (cascade1))
       cascade2 => cascade_set%first
       LOOP2: do while (associated (cascade2))
          if (cascade2%index >= cascade1%index)  exit LOOP2
          if (cascade1 .disjunct. cascade2) then
             call cascade_match_pair (cascade_set, cascade1, cascade2, .true.)
          end if
          call terminate_now_if_signal ()
          cascade2 => cascade2%next
       end do LOOP2
       cascade1 => cascade1%next
    end do LOOP1
  end subroutine cascade_set_generate_s

@ %def cascade_set_generate_s
@ The t-channel cascades are directed and have a seed (one of the
incoming particles) and a target (the other one).  We loop over all
possible seeds and targets.  Inside this, we loop over all t-channel
cascades ([[cascade1]]) and s-channel cascades ([[cascade2]]) and try
to combine them.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_t (cascade_set, pos_seed, pos_target)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(in) :: pos_seed, pos_target
    type(cascade_t), pointer :: cascade_seed, cascade_target
    type(cascade_t), pointer :: cascade1, cascade2
    integer(TC) :: bc_seed, bc_target
    bc_seed = ibset (0_TC, pos_seed-1)
    bc_target = ibset (0_TC, pos_target-1)
    cascade_seed => cascade_set%first_t
    LOOP_SEED: do while (associated (cascade_seed))
       if (cascade_seed%bincode == bc_seed) then
          cascade_target => cascade_set%first_t
          LOOP_TARGET: do while (associated (cascade_target))
             if (cascade_target%bincode == bc_target) then
                cascade1 => cascade_set%first_t
                LOOP_T: do while (associated (cascade1))
                   if ((cascade1 .disjunct. cascade_target) &
                        .and. .not. (cascade1 .disjunct. cascade_seed)) then
                      cascade2 => cascade_set%first
                      LOOP_S: do while (associated (cascade2))
                         if ((cascade2 .disjunct. cascade_target) &
                              .and. (cascade2 .disjunct. cascade1)) then
                            call cascade_match_pair &
                                 (cascade_set, cascade1, cascade2, .false.)
                         end if
                         call terminate_now_if_signal ()
                         cascade2 => cascade2%next
                      end do LOOP_S
                   end if
                   call terminate_now_if_signal ()
                   cascade1 => cascade1%next
                end do LOOP_T
             end if
             call terminate_now_if_signal ()
             cascade_target => cascade_target%next
          end do LOOP_TARGET
       end if
       call terminate_now_if_signal ()
       cascade_seed => cascade_seed%next
    end do LOOP_SEED
  end subroutine cascade_set_generate_t
                   
@ %def cascade_set_generate_t
@ This part completes the phase space for decay processes.  It is
similar to s-channel cascade generation, but combines two cascade with
the particular cascade of the incoming particle.  This particular
cascade is expected to be pointed at by [[first_t]].
<<Cascades: procedures>>=
  subroutine cascade_set_generate_decay (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    type(cascade_t), pointer :: cascade_in
    cascade_in => cascade_set%first_t
    cascade1 => cascade_set%first
    do while (associated (cascade1))
       if (cascade1 .disjunct. cascade_in) then
          cascade2 => cascade1%next
          do while (associated (cascade2))
             if ((cascade2 .disjunct. cascade1) &
                  .and. (cascade2 .disjunct. cascade_in)) then
                call cascade_match_triplet (cascade_set, &
                     cascade1, cascade2, cascade_in, .true.)
             end if
             call terminate_now_if_signal ()
             cascade2 => cascade2%next
          end do
       end if
       call terminate_now_if_signal ()
       cascade1 => cascade1%next
    end do
  end subroutine cascade_set_generate_decay

@ %def cascade_set_generate_decay
@ This part completes the phase space for scattering processes.  We
combine a t-channel cascade (containing the seed) with a s-channel
cascade and the target.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_scattering &
       (cascade_set, ns1, ns2, nt1, nt2, pos_seed, pos_target)
    type(cascade_set_t), intent(inout), target :: cascade_set
    integer, intent(in) :: pos_seed, pos_target
    integer, intent(in) :: ns1, ns2, nt1, nt2
    type(cascade_t), pointer :: cascade_seed, cascade_target
    type(cascade_t), pointer :: cascade1, cascade2
    integer(TC) :: bc_seed, bc_target
    bc_seed = ibset (0_TC, pos_seed-1)
    bc_target = ibset (0_TC, pos_target-1)
    cascade_seed => cascade_set%first_t
    LOOP_SEED: do while (associated (cascade_seed))
       if (cascade_seed%index < ns1) then
          cascade_seed => cascade_seed%next
          cycle LOOP_SEED
       else if (cascade_seed%index > ns2) then
          exit LOOP_SEED
       else if (cascade_seed%bincode == bc_seed) then
          cascade_target => cascade_set%first_t
          LOOP_TARGET: do while (associated (cascade_target))
             if (cascade_target%index < nt1) then
                cascade_target => cascade_target%next
                cycle LOOP_TARGET
             else if (cascade_target%index > nt2) then
                exit LOOP_TARGET
             else if (cascade_target%bincode == bc_target) then
                cascade1 => cascade_set%first_t
                LOOP_T: do while (associated (cascade1))
                   if ((cascade1 .disjunct. cascade_target) &
                        .and. .not. (cascade1 .disjunct. cascade_seed)) then
                      cascade2 => cascade_set%first
                      LOOP_S: do while (associated (cascade2))
                         if ((cascade2 .disjunct. cascade_target) &
                              .and. (cascade2 .disjunct. cascade1)) then
                            call cascade_match_triplet (cascade_set, &
                                 cascade1, cascade2, cascade_target, .false.)
                         end if
                         call terminate_now_if_signal ()
                         cascade2 => cascade2%next
                      end do LOOP_S
                   end if
                   call terminate_now_if_signal ()
                   cascade1 => cascade1%next
                end do LOOP_T
             end if
             call terminate_now_if_signal ()
             cascade_target => cascade_target%next
          end do LOOP_TARGET
       end if
       call terminate_now_if_signal ()
       cascade_seed => cascade_seed%next
    end do LOOP_SEED
  end subroutine cascade_set_generate_scattering
    
@ %def cascade_set_generate_scattering
@ 
\subsection{Groves}
Before assigning groves, assign hashcodes to the resonance patterns, so they
can easily be compared.
<<Cascades: procedures>>=
  subroutine cascade_set_assign_resonance_hash (cascade_set)
    type(cascade_set_t), intent(inout) :: cascade_set
    type(cascade_t), pointer :: cascade
    cascade => cascade_set%first_k
    do while (associated (cascade))
       call cascade_assign_resonance_hash (cascade)
       cascade => cascade%next
    end do
  end subroutine cascade_set_assign_resonance_hash

@ %def cascade_assign_resonance_hash
@ After all cascades are recorded, we group the complete cascades in
groves.  A grove consists of cascades with identical multiplicity,
number of resonances, log-enhanced, t-channel lines, and resonance flavors.
<<Cascades: procedures>>=
  subroutine cascade_set_assign_groves (cascade_set)
    type(cascade_set_t), intent(inout), target :: cascade_set
    type(cascade_t), pointer :: cascade1, cascade2
    integer :: multiplicity
    integer :: n_resonances, n_log_enhanced, n_t_channel, n_off_shell
    integer :: res_hash
    integer :: grove
    grove = 0
    cascade1 => cascade_set%first_k
    do while (associated (cascade1))
       if (cascade1%active .and. cascade1%complete &
            .and. cascade1%grove == 0) then
          grove = grove + 1
          cascade1%grove = grove
          multiplicity = cascade1%multiplicity
          n_resonances = cascade1%n_resonances
          n_log_enhanced = cascade1%n_log_enhanced
	  n_off_shell = cascade1%n_off_shell
          n_t_channel = cascade1%n_t_channel
	  res_hash = cascade1%res_hash
          cascade2 => cascade1%next
          do while (associated (cascade2))
             if (cascade2%grove == 0) then
                if (cascade2%multiplicity == multiplicity &
                     .and. cascade2%n_resonances == n_resonances &
                     .and. cascade2%n_log_enhanced == n_log_enhanced &
                     .and. cascade2%n_off_shell == n_off_shell &
                     .and. cascade2%n_t_channel == n_t_channel &
                     .and. cascade2%res_hash == res_hash) then
                   cascade2%grove = grove
                end if
             end if
             call terminate_now_if_signal ()
             cascade2 => cascade2%next
          end do
       end if
       call terminate_now_if_signal ()
       cascade1 => cascade1%next
    end do
    cascade_set%n_groves = grove
  end subroutine cascade_set_assign_groves

@ %def cascade_set_assign_groves
@ 
\subsection{Generate the phase space file}
Generate a complete phase space configuration.

For each flavor assignment: First, all s-channel
graphs that can be built up from the outgoing particles.  Then we
distinguish (1) decay, where we complete the s-channel graphs by
connecting to the input line, and (2) scattering, where we now
generate t-channel graphs by introducing an incoming particle, and
complete this by connecting to the other incoming particle.

After all cascade sets have been generated, merge them into a common set.
This eliminates redunancies between flavor assignments.
<<Cascades: public>>=
  public :: cascade_set_generate
<<Cascades: procedures>>=
  subroutine cascade_set_generate &
       (cascade_set, model, n_in, n_out, flv, phs_par, fatal_beam_decay)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(flavor_t), dimension(:,:), intent(in) :: flv
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    type(cascade_set_t), dimension(:), allocatable :: cset
    type(cascade_t), pointer :: cascade
    integer :: i
    if (phase_space_vanishes (phs_par%sqrts, n_in, flv))  return
    call cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
       fatal_beam_decay, flv)
    allocate (cset (size (flv, 2)))
    do i = 1, size (cset)
       call cascade_set_generate_single (cset(i), &
            model, n_in, n_out, flv(:,i), phs_par, fatal_beam_decay)
       cascade => cset(i)%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             call cascade_set_add_copy (cascade_set, cascade)
          end if
          cascade => cascade%next
       end do
       call cascade_set_final (cset(i))
    end do
    cascade_set%first_k => cascade_set%first
    call cascade_set_assign_resonance_hash (cascade_set)
    call cascade_set_assign_groves (cascade_set)
  end subroutine cascade_set_generate

@ %def cascade_set_generate
@ This generates phase space for a single channel, without assigning groves.
<<Cascades: procedures>>=
  subroutine cascade_set_generate_single (cascade_set, &
      model, n_in, n_out, flv, phs_par, fatal_beam_decay)
    type(cascade_set_t), intent(out) :: cascade_set
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_in, n_out
    type(flavor_t), dimension(:), intent(in) :: flv
    type(phs_parameters_t), intent(in) :: phs_par
    logical, intent(in) :: fatal_beam_decay
    integer :: n11, n12, n21, n22
    call cascade_set_init (cascade_set, model, n_in, n_out, phs_par, &
       fatal_beam_decay)
    call cascade_set_add_outgoing (cascade_set, flv(n_in+1:))
    call cascade_set_generate_s (cascade_set)
    select case (n_in)
    case(1)
       call cascade_set_add_incoming &
            (cascade_set, n11, n12, n_out + 1, flv(1))
       call cascade_set_generate_decay (cascade_set)
    case(2)
       call cascade_set_add_incoming &
            (cascade_set, n11, n12, n_out + 1, flv(2))
       call cascade_set_add_incoming &
            (cascade_set, n21, n22, n_out + 2, flv(1))
       call cascade_set_generate_t (cascade_set, n_out + 1, n_out + 2)
       call cascade_set_generate_t (cascade_set, n_out + 2, n_out + 1)
       call cascade_set_generate_scattering &
            (cascade_set, n11, n12, n21, n22, n_out + 1, n_out + 2)
       call cascade_set_generate_scattering &
            (cascade_set, n21, n22, n11, n12, n_out + 2, n_out + 1)
    end select
  end subroutine cascade_set_generate_single

@ %def cascade_set_generate_single
@ Sanity check: Before anything else is done, check if there could
possibly be any phase space.
<<Cascades: procedures>>=
  function phase_space_vanishes (sqrts, n_in, flv) result (flag)
    logical :: flag
    real(default), intent(in) :: sqrts
    integer, intent(in) :: n_in
    type(flavor_t), dimension(:,:), intent(in) :: flv
    real(default), dimension(:,:), allocatable :: mass
    real(default), dimension(:), allocatable :: mass_in, mass_out
    integer :: n_prt, n_flv, i, j
    flag = .false.
    if (sqrts <= 0) then
       call msg_error ("Phase space vanishes (sqrts must be positive)")
       flag = .true.;  return
    end if
    n_prt = size (flv, 1)
    n_flv = size (flv, 2)
    allocate (mass (n_prt, n_flv), mass_in (n_flv), mass_out (n_flv))
    !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
    !!! mass = flv%get_mass ()
    do i = 1, n_prt
       do j = 1, n_flv
          mass(i,j) = flv(i,j)%get_mass ()
       end do
    end do
    mass_in = sum (mass(:n_in,:), 1)
    mass_out = sum (mass(n_in+1:,:), 1)
    if (any (mass_in > sqrts)) then
       call msg_error ("Mass sum of incoming particles " &
            // "is more than available energy")
       flag = .true.;  return
    end if
    if (any (mass_out > sqrts)) then
       call msg_error ("Mass sum of outgoing particles " &
            // "is more than available energy")
       flag = .true.;  return
    end if
  end function phase_space_vanishes

@ %def phase_space_vanishes
@
\subsection{Return the resonance histories for subtraction}
Avoiding nameclash with similar but different [[resonance_t]] of
[[phs_base]]:
<<Cascades: public>>=
  public :: resonance_info_t
<<Cascades: types>>=
  type :: resonance_info_t
     type(flavor_t) :: flavor
     integer, dimension(:), allocatable :: contributors
  contains
   <<Cascades: resonance info: TBP>>
  end type resonance_info_t

@ %def resonance_info_t
@
<<Cascades: resonance info: TBP>>=
  procedure :: write => resonance_info_write
<<Cascades: procedures>>=
  subroutine resonance_info_write (resonance, unit)
    class(resonance_info_t), intent(in) :: resonance
    integer, optional, intent(in) :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, '(A)', advance='no') "Resonance contributors: "
    do i = 1, size(resonance%contributors)
       write (u, '(I0,1X)', advance='no') resonance%contributors(i)
    end do
    call resonance%flavor%write (u)
    write (u, '(A)')
  end subroutine resonance_info_write

@ %def resonance_info_write
@
<<Cascades: resonance info: TBP>>=
  procedure :: init => resonance_info_init
<<Cascades: procedures>>=
  subroutine resonance_info_init (resonance, mom_id, pdg, model, n_out)
    class(resonance_info_t), intent(out) :: resonance
    integer, intent(in) :: mom_id, pdg, n_out
    class(model_data_t), intent(in), target :: model
    integer :: i
    logical, dimension(n_out) :: contrib
    integer, dimension(n_out) :: tmp
    call msg_debug (D_PHASESPACE, "resonance_info_init")
    do i = 1, n_out
       tmp(i) = i
    end do
    contrib = btest (mom_id, tmp - 1)
    allocate (resonance%contributors (count (contrib)))
    resonance%contributors = pack (tmp, contrib)
    call resonance%flavor%init (pdg, model)
  end subroutine resonance_info_init

@ %def resonance_info_init
@ With each resonance region we associate a Breit-Wigner function
\begin{equation*}
  P = \frac{M_{res}^4}{(s - M_{res}^2)^2 + \Gamma_{res}^2 M_{res}^2},
\enq{equation*}
where $s$ denotes the invariant mass of the outgoing momenta originating
from this resonance. Note that the $M_{res}^4$ in the nominator makes
the mapping a dimensionless quantity.
<<Cascades: resonance info: TBP>>=
  procedure :: mapping => resonance_info_mapping
<<Cascades: procedures>>=
  function resonance_info_mapping (resonance, s) result (bw)
    real(default) :: bw
    class(resonance_info_t), intent(in) :: resonance
    real(default), intent(in) :: s
    real(default) :: m, gamma
    m = resonance%flavor%get_mass ()
    gamma = resonance%flavor%get_width ()
    bw = m**4 / ( (s - m**2)**2 + gamma**2 * m**2)
  end function resonance_info_mapping

@ %def resonance_info_mapping
@
<<Cascades: public>>=
  public :: operator(==)
<<Cascades: interfaces>>=
  interface operator(==)
     module procedure resonance_info_equal
     module procedure resonance_history_equal
  end interface
<<Cascades: procedures>>=
  function resonance_info_equal (r1, r2) result (equal)
    logical :: equal
    class(resonance_info_t), intent(in) :: r1, r2
    equal = size (r1%contributors) == size (r2%contributors)
    if (equal) &
       equal = r1%flavor == r2%flavor .and. all (r1%contributors == r2%contributors)
  end function resonance_info_equal

@ %def resonance_info_equal
<<Cascades: procedures>>=
  function resonance_history_equal (rh1, rh2) result (equal)
    logical :: equal
    class(resonance_history_t), intent(in) :: rh1, rh2
    integer :: i
    equal = .false.
    if (rh1%n_resonances == rh2%n_resonances) then
       if (size (rh1%resonances) == size (rh2%resonances)) then
          do i = 1, rh1%n_resonances
             if (.not. rh1%resonances(i) == rh2%resonances(i)) then
                return
             end if
          end do
          equal = .true.
       end if
    end if
  end function resonance_history_equal

@ %def resonance_history_equal
@ A resonance history is determined by the set of [[resonances]].
<<Cascades: public>>=
  public :: resonance_history_t
<<Cascades: types>>=
  type :: resonance_history_t
     type(resonance_info_t), dimension(:), allocatable :: resonances
     integer :: n_resonances = 0
  contains
   <<Cascades: resonance history: TBP>>
  end type resonance_history_t

@ %def resonance_history_t
@
<<Cascades: resonance history: TBP>>=
  procedure :: write => resonance_history_write
<<Cascades: procedures>>=
  subroutine resonance_history_write (res_hist, unit)
    class(resonance_history_t), intent(in) :: res_hist
    integer, optional, intent(in) :: unit
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    write(u, '(A,I0,A)') "Resonance history with ", &
         res_hist%n_resonances, " resonances:"
    do i = 1, res_hist%n_resonances
       call res_hist%resonances(i)%write (u)
    end do
  end subroutine resonance_history_write

@ %def resonance_history_write
@
<<Cascades: resonance history: TBP>>=
  procedure :: add_resonance => resonance_history_add_resonance
<<Cascades: procedures>>=
  subroutine resonance_history_add_resonance (res_hist, resonance)
    class(resonance_history_t), intent(inout) :: res_hist
    type(resonance_info_t), intent(in) :: resonance
    type(resonance_info_t), dimension(:), allocatable :: tmp
    logical :: create_new_array, extend_array
    call msg_debug (D_PHASESPACE, "resonance_history_add_resonance")
    res_hist%n_resonances = res_hist%n_resonances + 1
    create_new_array = .not. allocated (res_hist%resonances)
    extend_array = .false. 
    if (.not. create_new_array) &
       extend_array = res_hist%n_resonances > size (res_hist%resonances)
    if (create_new_array .or. extend_array) then
       if (extend_array) then
          call copy (tmp, res_hist%resonances)
          deallocate (res_hist%resonances)
       end if
       call copy (res_hist%resonances, tmp)
    end if
    res_hist%resonances(res_hist%n_resonances) = resonance
    call msg_debug (D_PHASESPACE, "res_hist%n_resonances", res_hist%n_resonances)
  contains
    pure subroutine copy (A,B)
      type(resonance_info_t), dimension(:), allocatable, intent(inout) :: A, B
      integer :: i
      allocate (A (res_hist%n_resonances + 10))
      do i = 1, res_hist%n_resonances - 1
         A(i) = B(i)
      end do
    end subroutine copy
  end subroutine resonance_history_add_resonance

@ %def resonance_history_add_resonance
@
<<Cascades: resonance history: TBP>>=
  procedure :: of_cascade => resonance_history_of_cascade
<<Cascades: procedures>>=
  !pure
  subroutine resonance_history_of_cascade (res_hist, cascade, model, n_out)
    class(resonance_history_t), intent(out) :: res_hist
    type(cascade_t), intent(in), target :: cascade
    class(model_data_t), intent(in), target :: model
    integer, intent(in) :: n_out
    type(resonance_info_t) :: resonance
    integer :: i, mom_id, pdg
    call msg_debug (D_PHASESPACE, "resonance_history_of_cascade")
    if (cascade%n_resonances > 0) then
       if (cascade%has_children) then
          call msg_debug2 (D_PHASESPACE, "cascade has resonances and children")
          do i = 1, size(cascade%tree_resonant)
             if (cascade%tree_resonant (i)) then
                mom_id = cascade%tree (i)
                pdg = cascade%tree_pdg (i)
                call resonance%init (mom_id, pdg, model, n_out)
                if (debug2_active (D_PHASESPACE)) then
                   print *, 'D: Adding resonance'
                   call resonance%write ()
                end if
                call res_hist%add_resonance (resonance)
             end if
          end do
       end if
    end if
  end subroutine resonance_history_of_cascade

@ %def resonance_history_of_cascade
@
<<Cascades: public>>=
  public :: cascade_set_get_n_trees
<<Cascades: procedures>>=
  function cascade_set_get_n_trees (cascade_set) result (n)
    type(cascade_set_t), intent(in), target :: cascade_set
    integer :: n
    type(cascade_t), pointer :: cascade
    integer :: grove
    call msg_debug (D_PHASESPACE, "cascade_set_get_n_trees")
    n = 0
    do grove = 1, cascade_set%n_groves
       cascade => cascade_set%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                n = n + 1
             end if
          end if
          cascade => cascade%next
       end do
    end do
    call msg_debug (D_PHASESPACE, "n", n)
  end function cascade_set_get_n_trees

@ %def cascade_set_get_n_trees
<<Cascades: public>>=
  public :: cascade_set_get_resonance_histories
<<Cascades: procedures>>=
  subroutine cascade_set_get_resonance_histories (cascade_set, res_hists)
    type(cascade_set_t), intent(in), target :: cascade_set
    type(resonance_history_t), dimension(:), allocatable, intent(out) :: res_hists
    type(resonance_history_t), dimension(:), allocatable :: tmp
    type(cascade_t), pointer :: cascade
    type(resonance_history_t) :: res_hist
    type(resonance_info_t), dimension(:), allocatable :: resonances
    integer :: grove, i, n_hists
    logical :: included
    call msg_debug (D_PHASESPACE, "cascade_set_get_resonance_histories")
    n_hists = 0
    allocate (tmp (cascade_set_get_n_trees (cascade_set)))
    do grove = 1, cascade_set%n_groves
       cascade => cascade_set%first_k
       do while (associated (cascade))
          if (cascade%active .and. cascade%complete) then
             if (cascade%grove == grove) then
                call msg_debug2 (D_PHASESPACE, "grove", grove)
                call res_hist%of_cascade (cascade, cascade_set%model, cascade_set%n_out)
                if (res_hist%n_resonances > 0) then
                   included = .false.
                   call msg_debug (D_PHASESPACE, "Checking if res_hist is already included")
                   do i = 1, n_hists
                      included = tmp (i) == res_hist
                      if (included) then
                         exit
                      end if
                   end do
                   call msg_debug (D_PHASESPACE, "included", included)
                   if (.not. included) then
                      n_hists = n_hists + 1
                      tmp(n_hists) = res_hist
                   end if
                end if
             end if
          end if
          cascade => cascade%next
       end do
    end do
    allocate (res_hists (n_hists))
    do i = 1, n_hists
       res_hists(i) = tmp(i)
    end do
  end subroutine cascade_set_get_resonance_histories

@ %def cascade_set_get_resonance_histories
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[cascades_ut.f90]]>>=
<<File header>>

module cascades_ut
  use unit_tests
  use cascades_uti

<<Standard module head>>

<<Cascades: public test>>

contains

<<Cascades: test driver>>

end module cascades_ut
@ %def cascades_ut
@
<<[[cascades_uti.f90]]>>=
<<File header>>

module cascades_uti

<<Use kinds>>
<<Use strings>>
  use unit_tests
  use flavors
  use model_data
  use phs_forests, only: phs_parameters_t

  use cascades

<<Standard module head>>

<<Cascades: test declarations>>

contains

<<Cascades: tests>>

end module cascades_uti
@ %def cascades_ut
@ API: driver for the unit tests below.
<<Cascades: public test>>=
  public :: cascades_test
<<Cascades: test driver>>=
  subroutine cascades_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Cascades: execute tests>>
  end subroutine cascades_test

@ %def cascades_test
\subsubsection{Check cascade setup}
@ Checking the basic setup up of the phase space cascade parameterizations. 
<<Cascades: execute tests>>=
  call test (cascades_1, "cascades_1", &
       "check cascade setup", &
       u, results)
<<Cascades: test declarations>>=
  public :: cascades_1
<<Cascades: tests>>=
  subroutine cascades_1 (u)  
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(5,2) :: flv
    type(cascade_set_t) :: cascade_set
    type(phs_parameters_t) :: phs_par

    write (u, "(A)")  "* Test output: cascades_1"
    write (u, "(A)")  "*   Purpose: test cascade phase space functions"
    write (u, "(A)")

    write (u, "(A)")  "* Initializing"
    write (u, "(A)")

    call model%init_sm_test ()

    call flv(1,1)%init ( 2, model)
    call flv(2,1)%init (-2, model)
    call flv(3,1)%init ( 1, model)
    call flv(4,1)%init (-1, model)
    call flv(5,1)%init (21, model)
    call flv(1,2)%init ( 2, model)
    call flv(2,2)%init (-2, model)
    call flv(3,2)%init ( 2, model)
    call flv(4,2)%init (-2, model)
    call flv(5,2)%init (21, model)
    phs_par%sqrts = 1000._default
    phs_par%off_shell = 2

    write (u, "(A)")
    write (u, "(A)")  "* Generating the cascades"
    write (u, "(A)")

    call cascade_set_generate (cascade_set, model, 2, 3, flv, phs_par,.true.)
    call cascade_set_write (cascade_set, u)
    call cascade_set_write_file_format (cascade_set, u)

    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")

    call cascade_set_final (cascade_set)
    call model%final ()

    write (u, *)
    write (u, "(A)")  "* Test output end: cascades_1"

  end subroutine cascades_1

@ %def cascades_1
@
\subsubsection{Check resonance history}
<<Cascades: execute tests>>=
  call test(cascades_2, "cascades_2", &
            "Check resonance history", u, results)
<<Cascades: test declarations>>=
  public :: cascades_2
<<Cascades: tests>>=
  subroutine cascades_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t), dimension(5,1) :: flv
    type(cascade_set_t) :: cascade_set
    type(phs_parameters_t) :: phs_par
    type(resonance_history_t), dimension(:), allocatable :: res_hists
    integer :: n, i
    write (u, "(A)")  "* Test output: cascades_2"
    write (u, "(A)")  "*   Purpose: Check resonance history"
    write (u, "(A)")

    write (u, "(A)")  "* Initializing"
    write (u, "(A)")

    call model%init_sm_test ()

    call flv(1,1)%init ( 2, model)
    call flv(2,1)%init (-2, model)
    call flv(3,1)%init ( 1, model)
    call flv(4,1)%init (-1, model)
    call flv(5,1)%init (22, model)
    phs_par%sqrts = 1000._default
    phs_par%off_shell = 2

    write (u, "(A)")
    write (u, "(A)")  "* Generating the cascades"
    write (u, "(A)")

    call cascade_set_generate (cascade_set, model, 2, 3, flv, phs_par,.true.)
    call cascade_set_get_resonance_histories (cascade_set, res_hists)
    n = cascade_set_get_n_trees (cascade_set)
    call assert_equal (u, n, 24, "Number of trees")
    do i = 1, size(res_hists)
       call res_hists(i)%write (u)
       write (u, "(A)")
    end do

    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")

    call cascade_set_final (cascade_set)
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: cascades_2"
  end subroutine cascades_2

@ %def cascades_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{WOOD phase space}

This is the module that interfaces the [[phs_forests]] phase-space
treatment and the [[cascades]] module for generating phase-space
channels.  As an extension of the [[phs_base]] abstract type,
the phase-space configuration and instance implement the standard API.

(Currently, this is the only generic phase-space implementation of
\whizard.  For trivial two-particle phase space, there is
[[phs_wood]] as an alternative.)
<<[[phs_wood.f90]]>>=
<<File header>>

module phs_wood

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use unit_tests
  use diagnostics
  use os_interface
  use md5
  use physics_defs
  use lorentz
  use model_data
  use flavors
  use process_constants
  use sf_mappings
  use sf_base
  use phs_base
  use mappings
  use phs_forests
  use cascades

<<Standard module head>>

<<PHS wood: public>>

<<PHS wood: types>>

contains

<<PHS wood: procedures>>

end module phs_wood
@ %def phs_wood
@
\subsection{Configuration}
<<PHS wood: public>>=
  public :: phs_wood_config_t
<<PHS wood: types>>=
  type, extends (phs_config_t) :: phs_wood_config_t
     character(32) :: md5sum_forest = ""
     integer :: io_unit = 0
     logical :: io_unit_keep_open = .false.
     logical :: use_equivalences = .false.
     logical :: fatal_beam_decay = .true.
     type(mapping_defaults_t) :: mapping_defaults
     type(phs_parameters_t) :: par
     type(string_t) :: run_id 
     type(cascade_set_t), allocatable :: cascade_set
     type(phs_forest_t) :: forest
     type(os_data_t) :: os_data
     logical :: extended_phs = .false.
   contains
   <<PHS wood: phs wood config: TBP>>
  end type phs_wood_config_t
  
@ %def phs_wood_config_t
@ Finalizer.  We should delete the cascade set and the forest subobject.

Also close the I/O unit, just in case.  (We assume that [[io_unit]] is
not standard input/output.)
<<PHS wood: phs wood config: TBP>>=
  procedure :: final => phs_wood_config_final
<<PHS wood: procedures>>=
  subroutine phs_wood_config_final (object)
    class(phs_wood_config_t), intent(inout) :: object
    logical :: opened
    if (object%io_unit /= 0) then
       inquire (unit = object%io_unit, opened = opened)
       if (opened)  close (object%io_unit)
    end if
    call object%clear_phase_space ()
    call phs_forest_final (object%forest)
  end subroutine phs_wood_config_final
  
@ %def phs_wood_config_final
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: increase_n_par => phs_wood_config_increase_n_par
<<PHS wood: procedures>>=
  subroutine phs_wood_config_increase_n_par (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    phs_config%n_par = phs_config%n_par + 3
  end subroutine phs_wood_config_increase_n_par

@ %def phs_wood_config_increase_n_par
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_extended_phs => phs_wood_config_set_extended_phs
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_extended_phs (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    phs_config%extended_phs = .true.
  end subroutine phs_wood_config_set_extended_phs

@
@ Output.  The contents of the PHS forest are not printed explicitly.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write => phs_wood_config_write
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write (object, unit)
    class(phs_wood_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)") &
         "Partonic phase-space configuration (phase-space forest):"
    call object%base_write (unit)
    write (u, "(1x,A)")    "Phase-space configuration parameters:"
    call phs_parameters_write (object%par, u)
    call object%mapping_defaults%write (u)
    write (u, "(3x,A,A,A)")  "Run ID: '", char (object%run_id), "'"
  end subroutine phs_wood_config_write
  
@ %def phs_wood_config_write
@ Print the PHS forest contents.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write_forest => phs_wood_config_write_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write_forest (object, unit)
    class(phs_wood_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call phs_forest_write (object%forest, u)
  end subroutine phs_wood_config_write_forest
  
@ %def phs_wood_config_write_forest
@ Set the phase-space parameters that the configuration generator requests.
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_parameters => phs_wood_config_set_parameters
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_parameters (phs_config, par)
    class(phs_wood_config_t), intent(inout) :: phs_config
    type(phs_parameters_t), intent(in) :: par
    phs_config%par = par
  end subroutine phs_wood_config_set_parameters

@ %def phs_wood_config_set_parameters
@ Enable the generation of channel equivalences (when calling [[configure]]).
<<PHS wood: phs wood config: TBP>>=
  procedure :: enable_equivalences => phs_wood_config_enable_equivalences
<<PHS wood: procedures>>=
  subroutine phs_wood_config_enable_equivalences (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    phs_config%use_equivalences = .true.
  end subroutine phs_wood_config_enable_equivalences
  
@ %def phs_wood_config_enable_equivalences
@ Set the phase-space mapping parameters that the configuration generator
requests.g
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_mapping_defaults => phs_wood_config_set_mapping_defaults
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_mapping_defaults (phs_config, mapping_defaults)
    class(phs_wood_config_t), intent(inout) :: phs_config
    type(mapping_defaults_t), intent(in) :: mapping_defaults
    phs_config%mapping_defaults = mapping_defaults
  end subroutine phs_wood_config_set_mapping_defaults

@ %def phs_wood_config_set_mapping_defaults
@ Define the input stream for the phase-space file as an open logical unit.
The unit must be connected.
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_input => phs_wood_config_set_input
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_input (phs_config, unit)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in) :: unit
    phs_config%io_unit = unit
    rewind (unit)
  end subroutine phs_wood_config_set_input
  
@ %def phs_wood_config_set_input
@ 
\subsection{Phase-space generation}
This subroutine generates a phase space configuration using the
[[cascades]] module.   Note that this may take time, and the
[[cascade_set]] subobject may consume a large amount of memory.
<<PHS wood: phs wood config: TBP>>=
  procedure :: generate_phase_space => phs_wood_config_generate_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_generate_phase_space (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer :: off_shell, extra_off_shell
    call msg_message ("Phase space: generating configuration ...")
    off_shell = phs_config%par%off_shell
    allocate (phs_config%cascade_set)
    do extra_off_shell = 0, max (phs_config%n_tot - 3, 0)
       phs_config%par%off_shell = off_shell + extra_off_shell
       call cascade_set_generate (phs_config%cascade_set, &
            phs_config%model, phs_config%n_in, phs_config%n_out, &
            phs_config%flv, &
            phs_config%par, phs_config%fatal_beam_decay)
       if (cascade_set_is_valid (phs_config%cascade_set)) then
          exit
       else
          call msg_message ("Phase space: ... failed.  &
               &Increasing phs_off_shell ...")
       end if
    end do
    if (cascade_set_is_valid (phs_config%cascade_set)) then
       call msg_message ("Phase space: ... success.")
    else
       call msg_fatal ("Phase-space: generation failed")
    end if
  end subroutine phs_wood_config_generate_phase_space
    
@ %def phs_wood_config_generate_phase_space
@ Using the generated phase-space configuration, write an appropriate
phase-space file to the stored (or explicitly specified) I/O unit.
<<PHS wood: phs wood config: TBP>>=
  procedure :: write_phase_space => phs_wood_config_write_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_write_phase_space (phs_config, &
       filename_vis, unit)
    class(phs_wood_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    type(string_t), intent(in), optional :: filename_vis
    type(string_t) :: setenv_tex, setenv_mp, pipe, pipe_dvi
    integer :: u, unit_tex, unit_dev, status   
    if (allocated (phs_config%cascade_set)) then
       if (present (unit)) then
          u = unit
       else
          u = phs_config%io_unit
       end if
       write (u, "(1x,A,A)") "process ", char (phs_config%id)
       write (u, "(A)")
       call cascade_set_write_process_bincode_format (phs_config%cascade_set, u)
       write (u, "(A)")
       write (u, "(3x,A,A,A32,A)") "md5sum_process    = ", &
            '"', phs_config%md5sum_process, '"'
       write (u, "(3x,A,A,A32,A)") "md5sum_model_par  = ", &
            '"', phs_config%md5sum_model_par, '"'
       write (u, "(3x,A,A,A32,A)") "md5sum_phs_config = ", &
            '"', phs_config%md5sum_phs_config, '"'
       call phs_parameters_write (phs_config%par, u)
       call cascade_set_write_file_format (phs_config%cascade_set, u)
       if (phs_config%vis_channels) then 
          unit_tex = free_unit ()
          open (unit=unit_tex, file=char(filename_vis // ".tex"), &
               action="write", status="replace")      
          call cascade_set_write_graph_format (phs_config%cascade_set, &
               filename_vis // "-graphs", phs_config%id, unit_tex)
          close (unit_tex)      
          call msg_message ("Phase space: visualizing channels in file " & 
               // char(trim(filename_vis)) // "...")
          if (phs_config%os_data%event_analysis_ps) then
             BLOCK: do
                unit_dev = free_unit ()
                open (file = "/dev/null", unit = unit_dev, &
                     action = "write", iostat = status)
                if (status /= 0) then
                   pipe = ""
                   pipe_dvi = ""
                else
                   pipe = " > /dev/null"
                   pipe_dvi = " 2>/dev/null 1>/dev/null"
                end if
                close (unit_dev)
                if (phs_config%os_data%whizard_texpath /= "") then
                   setenv_tex = "TEXINPUTS=" // &
                        phs_config%os_data%whizard_texpath // ":$TEXINPUTS "
                   setenv_mp = "MPINPUTS=" // &
                        phs_config%os_data%whizard_texpath // ":$MPINPUTS "
                else
                   setenv_tex = ""
                   setenv_mp = ""
                end if
                call os_system_call (setenv_tex // &
                     phs_config%os_data%latex // " " // &
                     filename_vis // ".tex " // pipe, status)
                if (status /= 0)  exit BLOCK
                if (phs_config%os_data%mpost /= "") then
                   call os_system_call (setenv_mp // &
                        phs_config%os_data%mpost // " " // &
                        filename_vis // "-graphs.mp" // pipe, status)
                else 
                   call msg_fatal ("Could not use MetaPOST.")
                end if
                if (status /= 0)  exit BLOCK
                call os_system_call (setenv_tex // &
                     phs_config%os_data%latex // " " // &
                     filename_vis // ".tex" // pipe, status)
                if (status /= 0)  exit BLOCK
                call os_system_call &
                     (phs_config%os_data%dvips // " -o " // filename_vis &
                     // ".ps " // filename_vis // ".dvi" // pipe_dvi, status)
                if (status /= 0)  exit BLOCK
                if (phs_config%os_data%event_analysis_pdf) then
                   call os_system_call (phs_config%os_data%ps2pdf // " " // &
                        filename_vis // ".ps", status)
                   if (status /= 0)  exit BLOCK
                end if
                exit BLOCK
             end do BLOCK
             if (status /= 0) then
                call msg_error ("Unable to compile analysis output file")
             end if
          end if
       end if
    else
       call msg_fatal ("Phase-space configuration: &
            &no phase space object generated")
    end if
  end subroutine phs_wood_config_write_phase_space
       
@ %def phs_config_write_phase_space
@ Clear the phase-space configuration.  This is useful since the
object may become \emph{really} large.
<<PHS wood: phs wood config: TBP>>=
  procedure :: clear_phase_space => phs_wood_config_clear_phase_space
<<PHS wood: procedures>>=
  subroutine phs_wood_config_clear_phase_space (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    if (allocated (phs_config%cascade_set)) then
       call cascade_set_final (phs_config%cascade_set)
       deallocate (phs_config%cascade_set)
    end if
  end subroutine phs_wood_config_clear_phase_space
  
@ %def phs_wood_config_clear_phase_space
@
\subsection{Phase-space configuration}
We read the phase-space configuration from the stored I/O unit.  If
this is not set, we assume that we have to generate a phase space
configuration.  When done, we open a scratch file and write the
configuration.

If [[rebuild]] is set, we should trash any existing phase space file
and build a new one.  Otherwise, we try to use an old one, which we
check for existence and integrity.  If [[ignore_mismatch]] is set, we
reuse an existing file even if it does not match the current setup.
<<PHS wood: phs wood config: TBP>>=
  procedure :: configure => phs_wood_config_configure
<<PHS wood: procedures>>=
  subroutine phs_wood_config_configure (phs_config, sqrts, &
       sqrts_fixed, cm_frame, azimuthal_dependence, rebuild, ignore_mismatch, &
       nlo_type)
    class(phs_wood_config_t), intent(inout) :: phs_config
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: sqrts_fixed
    logical, intent(in), optional :: cm_frame
    logical, intent(in), optional :: azimuthal_dependence
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    integer, intent(inout), optional :: nlo_type
    type(string_t) :: filename, filename_vis
    logical :: variable_limits
    logical :: ok, exist, found, check, match, rebuild_phs
    integer :: g, c0, c1, n
    if (present (nlo_type)) then
      phs_config%nlo_type = nlo_type
    else
      phs_config%nlo_type = BORN
    end if
    phs_config%sqrts = sqrts
    phs_config%par%sqrts = sqrts
    if (present (sqrts_fixed)) &
         phs_config%sqrts_fixed = sqrts_fixed
    if (present (cm_frame)) &
         phs_config%cm_frame = cm_frame
    if (present (azimuthal_dependence)) &
         phs_config%azimuthal_dependence = azimuthal_dependence
    if (present (rebuild)) then
       rebuild_phs = rebuild
    else
       rebuild_phs = .true.
    end if
    if (present (ignore_mismatch)) then
       check = .not. ignore_mismatch
       if (ignore_mismatch) &
            call msg_warning ("Reading phs file: MD5 sum check disabled")
    else
       check = .true.
    end if
    phs_config%md5sum_forest = ""
    call phs_config%compute_md5sum ()
    if (phs_config%io_unit == 0) then
       if (phs_config%run_id /= "") then
          filename = phs_config%id // "." // phs_config%run_id // ".phs"
          filename_vis = phs_config%id // "." // phs_config%run_id // "_phs"
       else
          filename = phs_config%id // ".phs"
          filename_vis = phs_config%id // "_phs"          
       end if
       if (.not. rebuild_phs) then
          if (check) then
             call phs_config%read_phs_file (exist, found, match)
             rebuild_phs = .not. (exist .and. found .and. match)
          else
             call phs_config%read_phs_file (exist, found)
             rebuild_phs = .not. (exist .and. found)
          end if
       end if
       if (rebuild_phs) then
          call phs_config%generate_phase_space ()
          phs_config%io_unit = free_unit ()
          if (phs_config%id /= "") then
             call msg_message ("Phase space: writing configuration file '" &
                  // char (filename) // "'")
             open (phs_config%io_unit, file = char (filename), &
                  status = "replace", action = "readwrite")
          else
             open (phs_config%io_unit, status = "scratch", action = "readwrite")
          end if
          call phs_config%write_phase_space (filename_vis)
          rewind (phs_config%io_unit)
       else
          call msg_message ("Phase space: keeping configuration file '" &
               // char (filename) // "'")
       end if
    end if
    if (phs_config%io_unit == 0) then
       ok = .true.
    else
      call phs_forest_read (phs_config%forest, phs_config%io_unit, &
            phs_config%id, phs_config%n_in, phs_config%n_out, &
            phs_config%model, ok)
       if (.not. phs_config%io_unit_keep_open) then
          close (phs_config%io_unit)
          phs_config%io_unit = 0
       end if
    end if
    if (ok) then
       call phs_forest_set_flavors (phs_config%forest, phs_config%flv(:,1))
       variable_limits = .not. phs_config%cm_frame
       call phs_forest_set_parameters &
            (phs_config%forest, phs_config%mapping_defaults, variable_limits)
       call phs_forest_setup_prt_combinations (phs_config%forest)
       phs_config%n_channel = phs_forest_get_n_channels (phs_config%forest)
       phs_config%n_par = phs_forest_get_n_parameters (phs_config%forest)
       allocate (phs_config%channel (phs_config%n_channel))
       if (phs_config%use_equivalences) then
          call phs_forest_set_equivalences (phs_config%forest)
          call phs_forest_get_equivalences (phs_config%forest, &
               phs_config%channel, phs_config%azimuthal_dependence)
          phs_config%provides_equivalences = .true.
       end if
       call phs_forest_set_s_mappings (phs_config%forest)
       call phs_config%record_on_shell ()
       if (phs_config%mapping_defaults%enable_s_mapping) then
          call phs_config%record_s_mappings ()
       end if
       allocate (phs_config%chain (phs_config%n_channel), source = 0)
       do g = 1, phs_forest_get_n_groves (phs_config%forest)
          call phs_forest_get_grove_bounds (phs_config%forest, g, c0, c1, n)
          phs_config%chain (c0:c1) = g
       end do
       phs_config%provides_chains = .true.
       call phs_config%compute_md5sum_forest ()
    else
       write (msg_buffer, "(A,A,A)") &
            "Phase space: process '", &
            char (phs_config%id), "' not found in configuration file"
       call msg_fatal ()
    end if
  end subroutine phs_wood_config_configure
  
@ %def phs_wood_config_configure
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_extra_parameters => phs_wood_config_set_extra_parameters
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_extra_parameters (config)
    class(phs_wood_config_t), intent(inout) :: config
    config%n_par = config%n_par + 3
  end subroutine phs_wood_config_set_extra_parameters

@ %def phs_wood_config_set_extra_parameters
@ 
<<PHS wood: phs wood config: TBP>>=
  procedure :: reshuffle_flavors => phs_wood_config_reshuffle_flavors
<<PHS wood: procedures>>=
  subroutine phs_wood_config_reshuffle_flavors (phs_config, reshuffle, flv_extra)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in), dimension(:), allocatable :: reshuffle
    type(flavor_t), intent(in) :: flv_extra
    call phs_forest_set_flavors (phs_config%forest, phs_config%flv(:,1), reshuffle, flv_extra)
  end subroutine phs_wood_config_reshuffle_flavors

@ %def phs_wood_config_reshuffle_flavors
@
<<PHS wood: phs wood config: TBP>>=
  procedure :: set_momentum_links => phs_wood_config_set_momentum_links
<<PHS wood: procedures>>=
  subroutine phs_wood_config_set_momentum_links (phs_config, reshuffle)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer, intent(in), dimension(:), allocatable :: reshuffle
    call phs_forest_set_momentum_links (phs_config%forest, reshuffle)
  end subroutine phs_wood_config_set_momentum_links

@ %def phs_wood_config_set_momentum_links
@ Identify resonances which are marked by s-channel mappings for the
whole phase space and report them to the channel array.
<<PHS wood: phs wood config: TBP>>=
  procedure :: record_s_mappings => phs_wood_config_record_s_mappings
<<PHS wood: procedures>>=
  subroutine phs_wood_config_record_s_mappings (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical :: flag
    real(default) :: mass, width
    integer :: c
    do c = 1, phs_config%n_channel
       call phs_forest_get_s_mapping (phs_config%forest, c, flag, mass, width)
       if (flag) then
          if (mass == 0) then
             call msg_fatal ("Phase space: s-channel resonance " &
                  // " has zero mass")
          end if
          if (width == 0) then
             call msg_fatal ("Phase space: s-channel resonance " &
                  // " has zero width")
          end if
          call phs_config%channel(c)%set_resonant (mass, width)
       end if
    end do
  end subroutine phs_wood_config_record_s_mappings

@ %def phs_wood_config_record_s_mappings
@ Identify on-shell mappings for the whole phase space and report them
to the channel array.
<<PHS wood: phs wood config: TBP>>=
  procedure :: record_on_shell => phs_wood_config_record_on_shell
<<PHS wood: procedures>>=
  subroutine phs_wood_config_record_on_shell (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical :: flag
    real(default) :: mass
    integer :: c
    do c = 1, phs_config%n_channel
       call phs_forest_get_on_shell (phs_config%forest, c, flag, mass)
       if (flag) then
          call phs_config%channel(c)%set_on_shell (mass)
       end if
    end do
  end subroutine phs_wood_config_record_on_shell

@ %def phs_wood_config_record_on_shell
@ The MD5 sum of the forest is computed in addition to the MD5 sum of
the configuration.  The reason is that the forest may depend on a
user-provided external file.  On the other hand, this MD5 sum encodes
all information that is relevant for further processing.  Therefore,
the [[get_md5sum]] method returns this result, once it is available.
<<PHS wood: phs wood config: TBP>>=
  procedure :: compute_md5sum_forest => phs_wood_config_compute_md5sum_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_config_compute_md5sum_forest (phs_config)
    class(phs_wood_config_t), intent(inout) :: phs_config
    integer :: u
    u = free_unit ()
    open (u, status = "scratch", action = "readwrite")
    call phs_config%write_forest (u)
    rewind (u)
    phs_config%md5sum_forest = md5sum (u)
    close (u)
  end subroutine phs_wood_config_compute_md5sum_forest
  
@ %def phs_wood_config_compute_md5sum_forest
@ Return the most relevant MD5 sum.  This overrides the method of the
base type.
<<PHS wood: phs wood config: TBP>>=
  procedure :: get_md5sum => phs_wood_config_get_md5sum
<<PHS wood: procedures>>=
  function phs_wood_config_get_md5sum (phs_config) result (md5sum)
    class(phs_wood_config_t), intent(in) :: phs_config
    character(32) :: md5sum
    if (phs_config%md5sum_forest /= "") then
       md5sum = phs_config%md5sum_forest
    else
       md5sum = phs_config%md5sum_phs_config
    end if
  end function phs_wood_config_get_md5sum
 
@ %def phs_wood_config_get_md5sum 
@ Check whether a phase-space configuration for the current process exists.
We look for the phase-space file that should correspond to the current
process.  If we find it, we check the MD5 sums stored in the file against the
MD5 sums in the current configuration (if required).

If successful, read the PHS file.
<<PHS wood: phs wood config: TBP>>=
  procedure :: read_phs_file => phs_wood_read_phs_file
<<PHS wood: procedures>>=
  subroutine phs_wood_read_phs_file (phs_config, exist, found, match)
    class(phs_wood_config_t), intent(inout) :: phs_config
    logical, intent(out) :: exist
    logical, intent(out) :: found
    logical, intent(out), optional :: match
    type(string_t) :: filename
    integer :: u
    filename = phs_config%id // ".phs"
    inquire (file = char (filename), exist = exist)
    if (exist) then
       u = free_unit ()
       open (u, file = char (filename), action = "read", status = "old")
       call phs_forest_read (phs_config%forest, u, &
            phs_config%id, phs_config%n_in, phs_config%n_out, &
            phs_config%model, found, &
            phs_config%md5sum_process, &
            phs_config%md5sum_model_par, &
            phs_config%md5sum_phs_config, &
            match = match)
       close (u)
    else
       found = .false.
       if (present (match))  match = .false.
    end if
  end subroutine phs_wood_read_phs_file
    
@ %def phs_wood_read_phs_file
@ Startup message, after configuration is complete.
<<PHS wood: phs wood config: TBP>>=
  procedure :: startup_message => phs_wood_config_startup_message
<<PHS wood: procedures>>=
  subroutine phs_wood_config_startup_message (phs_config, unit)
    class(phs_wood_config_t), intent(in) :: phs_config
    integer, intent(in), optional :: unit
    integer :: n_groves, n_eq
    n_groves = phs_forest_get_n_groves (phs_config%forest)
    n_eq = phs_forest_get_n_equivalences (phs_config%forest)
    call phs_config%base_startup_message (unit)
    if (phs_config%n_channel == 1) then
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channel, collected in ", n_groves, &
            " grove."
    else if (n_groves == 1) then
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channels, collected in ", n_groves, &
            " grove." 
       else
       write (msg_buffer, "(A,2(I0,A))") &
            "Phase space: found ", phs_config%n_channel, &
            " channels, collected in ", &
            phs_forest_get_n_groves (phs_config%forest), &
            " groves."
    end if
    call msg_message (unit = unit)    
    if (phs_config%use_equivalences) then
       if (n_eq == 1) then 
          write (msg_buffer, "(A,I0,A)") &
               "Phase space: Using ", n_eq, &
               " equivalence between channels."
       else
          write (msg_buffer, "(A,I0,A)") &
               "Phase space: Using ", n_eq, &
               " equivalences between channels."          
       end if
    else
       write (msg_buffer, "(A)") &
            "Phase space: no equivalences between channels used."
    end if
    call msg_message (unit = unit)
    write (msg_buffer, "(A,2(1x,I0,1x,A))") &
         "Phase space: wood"
    call msg_message (unit = unit)
  end subroutine phs_wood_config_startup_message
    
@ %def phs_wood_config_startup_message
@ Allocate an instance: the actual phase-space object.
<<PHS wood: phs wood config: TBP>>=
  procedure, nopass :: allocate_instance => phs_wood_config_allocate_instance
<<PHS wood: procedures>>=
  subroutine phs_wood_config_allocate_instance (phs)
    class(phs_t), intent(inout), pointer :: phs
    allocate (phs_wood_t :: phs)
  end subroutine phs_wood_config_allocate_instance
  
@ %def phs_wood_config_allocate_instance
@
\subsection{Kinematics implementation}
We generate $\cos\theta$ and $\phi$ uniformly, covering the solid angle.
<<PHS wood: public>>=
  public :: phs_wood_t
<<PHS wood: types>>=
  type, extends (phs_t) :: phs_wood_t
     real(default) :: sqrts = 0
     type(phs_forest_t) :: forest
     real(default), dimension(3) :: r_real
     integer :: n_r_born = 0
   contains
   <<PHS wood: phs wood: TBP>>
  end type phs_wood_t
  
@ %def phs_wood_t
@ Output.  The [[verbose]] setting is irrelevant, we just display the contents
of the base object.
<<PHS wood: phs wood: TBP>>=
  procedure :: write => phs_wood_write
<<PHS wood: procedures>>=
  subroutine phs_wood_write (object, unit, verbose)
    class(phs_wood_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u)
  end subroutine phs_wood_write
    
@ %def phs_wood_write
@ Write the forest separately.
<<PHS wood: phs wood: TBP>>=
  procedure :: write_forest => phs_wood_write_forest
<<PHS wood: procedures>>=
  subroutine phs_wood_write_forest (object, unit)
    class(phs_wood_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call phs_forest_write (object%forest, u)
  end subroutine phs_wood_write_forest
  
@ %def phs_wood_write_forest
@ Finalizer.
<<PHS wood: phs wood: TBP>>=
  procedure :: final => phs_wood_final
<<PHS wood: procedures>>=
  subroutine phs_wood_final (object)
    class(phs_wood_t), intent(inout) :: object
    call phs_forest_final (object%forest)
  end subroutine phs_wood_final
  
@ %def phs_wood_final
@ Initialization.  We allocate arrays ([[base_init]]) and adjust the
phase-space volume.  The two-particle phase space volume is
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.55294034614 \times 10^{-5}
\end{equation}
independent of the particle masses.
<<PHS wood: phs wood: TBP>>=
  procedure :: init => phs_wood_init
<<PHS wood: procedures>>=
  subroutine phs_wood_init (phs, phs_config)
    class(phs_wood_t), intent(out) :: phs
    class(phs_config_t), intent(in), target :: phs_config
    call phs%base_init (phs_config)
    select type (phs_config)
    type is (phs_wood_config_t)
       phs%forest = phs_config%forest
       if (phs_config%extended_phs) &
          phs%n_r_born = phs_config%n_par - 3
    end select
  end subroutine phs_wood_init
  
@ %def phs_wood_init
@ 
\subsection{Evaluation}
We compute the outgoing momenta from the incoming momenta and
the input parameter set [[r_in]] in channel [[r_in]].  We also compute the
[[r]] parameters and Jacobians [[f]] for all other channels.

We do \emph{not} need to a apply a transformation from/to the c.m.\ frame,
because in [[phs_base]] the momenta are already boosted to the c.m.\ frame
before assigning them in the [[phs]] object, and inversely boosted when
extracting them.
<<PHS wood: phs wood: TBP>>=
  procedure :: evaluate_selected_channel => phs_wood_evaluate_selected_channel
  procedure :: evaluate_other_channels => phs_wood_evaluate_other_channels
<<PHS wood: procedures>>=
  subroutine phs_wood_evaluate_selected_channel (phs, c_in, r_in)
    class(phs_wood_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    real(default), intent(in), dimension(:) :: r_in
    logical :: ok
    phs%q_defined = .false.
    if (phs%p_defined) then
       call phs_forest_set_prt_in (phs%forest, phs%p)
       phs%r(:,c_in) = r_in
       call phs_forest_evaluate_selected_channel (phs%forest, &
            c_in, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, phs%volume, ok)
       select type (config => phs%config)
       type is (phs_wood_config_t)
          if (config%extended_phs) then
             if (phs%n_r_born > 0) then
                phs%r_real = r_in (phs%n_r_born+1:phs%n_r_born+3)
             else
                call msg_fatal ("n_r_born should be larger than 0!")
             end if
          end if
       end select
       if (ok) then
          phs%q = phs_forest_get_momenta_out (phs%forest)
          phs%q_defined = .true.
       end if
    end if
  end subroutine phs_wood_evaluate_selected_channel
  
  subroutine phs_wood_evaluate_other_channels (phs, c_in)
    class(phs_wood_t), intent(inout) :: phs
    integer, intent(in) :: c_in
    integer :: c
    if (phs%q_defined) then
       call phs_forest_evaluate_other_channels (phs%forest, &
            c_in, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, combine=.true.)
       select type (config => phs%config)
       type is (phs_wood_config_t)
          if (config%extended_phs) then
             if (phs%n_r_born > 0) then
                do c = 1, size (phs%r, 2)
                   phs%r(phs%n_r_born+1:phs%n_r_born+3,c) = phs%r_real
                end do
             else
                phs%r_defined = .false.
             end if
          end if
       end select
       phs%r_defined = .true.
    end if
  end subroutine phs_wood_evaluate_other_channels
  
@ %def phs_wood_evaluate_selected_channel
@ %def phs_wood_evaluate_other_channels
@ Inverse evaluation.
<<PHS wood: phs wood: TBP>>=
  procedure :: inverse => phs_wood_inverse
<<PHS wood: procedures>>=
  subroutine phs_wood_inverse (phs)
    class(phs_wood_t), intent(inout) :: phs
    if (phs%p_defined .and. phs%q_defined) then
       call phs_forest_set_prt_in (phs%forest, phs%p)
       call phs_forest_set_prt_out (phs%forest, phs%q)
       call phs_forest_recover_channel (phs%forest, &
            1, &
            phs%sqrts_hat, phs%r, phs%f, phs%volume)
       call phs_forest_evaluate_other_channels (phs%forest, &
            1, phs%active_channel, &
            phs%sqrts_hat, phs%r, phs%f, combine=.false.)
       phs%r_defined = .true.
    end if
  end subroutine phs_wood_inverse
  
@ %def phs_wood_inverse
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[phs_wood_ut.f90]]>>=
<<File header>>

module phs_wood_ut
  use unit_tests
  use phs_wood_uti
  
<<Standard module head>>

<<PHS wood: public test>>

<<PHS wood: public test auxiliary>>

contains
  
<<PHS wood: test driver>>

end module phs_wood_ut
@ %def phs_wood_ut
@
<<[[phs_wood_uti.f90]]>>=
<<File header>>

module phs_wood_uti

<<Use kinds>>
<<Use strings>>
  use io_units
  use os_interface
  use lorentz
  use flavors
  use model_data
  use process_constants
  use mappings
  use phs_base
  use phs_forests

  use phs_wood

  use phs_base_ut, only: init_test_process_data, init_test_decay_data

<<Standard module head>>

<<PHS wood: public test auxiliary>>

<<PHS wood: test declarations>>

<<PHS wood: test types>>

contains

<<PHS wood: tests>>

<<PHS wood: test auxiliary>>

end module phs_wood_uti
@ %def phs_wood_ut
@ API: driver for the unit tests below.
<<PHS wood: public test>>=
  public :: phs_wood_test
<<PHS wood: test driver>>=
  subroutine phs_wood_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS wood: execute tests>>
  end subroutine phs_wood_test
  
@ %def phs_wood_test
<<PHS wood: public test>>=
  public :: phs_wood_vis_test
<<PHS wood: test driver>>=
  subroutine phs_wood_vis_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<PHS wood: execute vis tests>>
  end subroutine phs_wood_vis_test
  
@ %def phs_wood_vis_test
@
\subsubsection{Phase-space configuration data}
Construct and display a test phase-space configuration object.  Also
check the [[azimuthal_dependence]] flag.

This auxiliary routine writes a phase-space configuration file to unit
[[u_phs]].
<<PHS wood: public test auxiliary>>=
  public :: write_test_phs_file
<<PHS wood: test auxiliary>>=
  subroutine write_test_phs_file (u_phs, procname)
    integer, intent(in) :: u_phs
    type(string_t), intent(in), optional :: procname
    if (present (procname)) then
       write (u_phs, "(A,A)")  "process ", char (procname)
    else
       write (u_phs, "(A)")  "process testproc"
    end if
    write (u_phs, "(A,A)")  "   md5sum_process    = ", '""'
    write (u_phs, "(A,A)")  "   md5sum_model_par  = ", '""'
    write (u_phs, "(A,A)")  "   md5sum_phs_config = ", '""'
    write (u_phs, "(A)")  "   sqrts         = 1000"
    write (u_phs, "(A)")  "   m_threshold_s =   50"    
    write (u_phs, "(A)")  "   m_threshold_t =  100"    
    write (u_phs, "(A)")  "   off_shell = 2"
    write (u_phs, "(A)")  "   t_channel = 6"
    write (u_phs, "(A)")  "   keep_nonresonant = T"
    write (u_phs, "(A)")  "  grove #1"
    write (u_phs, "(A)")  "    tree 3"
  end subroutine write_test_phs_file

@ %def write_test_phs_file
@
<<PHS wood: execute tests>>=
  call test (phs_wood_1, "phs_wood_1", &
       "phase-space configuration", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_1
<<PHS wood: tests>>=
  subroutine phs_wood_1 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    type(mapping_defaults_t) :: mapping_defaults
    real(default) :: sqrts
    integer :: u_phs, iostat
    character(32) :: buffer
    
    write (u, "(A)")  "* Test output: phs_wood_1"
    write (u, "(A)")  "*   Purpose: initialize and display &
         &phase-space configuration data"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_1"), process_data)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_1"))
    rewind (u_phs)
    do
       read (u_phs, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup phase-space configuration object"
    write (u, "(A)")

    mapping_defaults%step_mapping = .false.

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
       call phs_data%set_mapping_defaults (mapping_defaults)
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)
       
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_1"

  end subroutine phs_wood_1

@ %def phs_wood_1
@
\subsubsection{Phase space evaluation}
Compute kinematics for given parameters, also invert the calculation.
<<PHS wood: execute tests>>=
  call test (phs_wood_2, "phs_wood_2", &
       "phase-space evaluation", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_2
<<PHS wood: tests>>=
  subroutine phs_wood_2 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(flavor_t) :: flv
    type(process_constants_t) :: process_data
    real(default) :: sqrts, E
    class(phs_config_t), allocatable, target :: phs_data
    class(phs_t), pointer :: phs => null ()
    type(vector4_t), dimension(2) :: p, q
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: phs_wood_2"
    write (u, "(A)")  "*   Purpose: test simple single-channel phase space"
    write (u, "(A)")
    
    call model%init_test ()
    call flv%init (25, model)

    write (u, "(A)")  "* Initialize a process and a matching &
         &phase-space configuration"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_2"), process_data)
    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_2"))
    rewind (u_phs)

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)

    call phs_data%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%write (u, verbose=.true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    E = sqrts / 2
    p(1) = vector4_moving (E, sqrt (E**2 - flv%get_mass ()**2), 3)
    p(2) = vector4_moving (E,-sqrt (E**2 - flv%get_mass ()**2), 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.125, 0.5"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, [0.125_default, 0.5_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_t)
       call phs%write_forest (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    call phs%final ()
    deallocate (phs)
    
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_t)
       call phs%write_forest (u)
    end select
    
    call phs%final ()
    deallocate (phs)
    
    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_2"

  end subroutine phs_wood_2

@ %def phs_wood_2
@
\subsubsection{Phase-space generation}
Generate phase space for a simple process.
<<PHS wood: execute tests>>=
  call test (phs_wood_3, "phs_wood_3", &
       "phase-space generation", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_3
<<PHS wood: tests>>=
  subroutine phs_wood_3 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
    integer :: iostat
    character(80) :: buffer
   
    write (u, "(A)")  "* Test output: phs_wood_3"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_3"), process_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%io_unit_keep_open = .true.
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    select type (phs_data)
    type is (phs_wood_config_t)
       rewind (phs_data%io_unit)
       do
          read (phs_data%io_unit, "(A)", iostat = iostat)  buffer
          if (iostat /= 0)  exit
          write (u, "(A)") trim (buffer)
       end do
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_3"

  end subroutine phs_wood_3

@ %def phs_wood_3
@
\subsubsection{Nontrivial process}
Generate phase space for a $2\to 3$ process.
<<PHS wood: execute tests>>=
  call test (phs_wood_4, "phs_wood_4", &
       "nontrivial process", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_4
<<PHS wood: tests>>=
  subroutine phs_wood_4 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable, target :: phs_data
    integer :: iostat
    character(80) :: buffer
    class(phs_t), pointer :: phs => null ()
    real(default) :: E, pL
    type(vector4_t), dimension(2) :: p
    type(vector4_t), dimension(3) :: q
   
    write (u, "(A)")  "* Test output: phs_wood_4"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    process_data%id = "phs_wood_4"
    process_data%model_name = "Test"
    process_data%n_in = 2
    process_data%n_out = 3
    process_data%n_flv = 1
    allocate (process_data%flv_state (process_data%n_in + process_data%n_out, &
         process_data%n_flv))
    process_data%flv_state(:,1) = [25, 25, 25, 6, -6]

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%io_unit_keep_open = .true.
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    select type (phs_data)
    type is (phs_wood_config_t)
       rewind (phs_data%io_unit)
       do
          read (phs_data%io_unit, "(A)", iostat = iostat)  buffer
          if (iostat /= 0)  exit
          write (u, "(A)") trim (buffer)
       end do
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize the phase-space instance"
    write (u, "(A)")

    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    write (u, "(A)")  "* Set incoming momenta"
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       E = phs_data%sqrts / 2
       pL = sqrt (E**2 - phs_data%flv(1,1)%get_mass ()**2)
    end select
    p(1) = vector4_moving (E, pL, 3)
    p(2) = vector4_moving (E, -pL, 3)

    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    
    write (u, "(A)")  "* Compute phase-space point &
         &for x = 0.1, 0.2, 0.3, 0.4, 0.5"
    write (u, "(A)")

    call phs%evaluate_selected_channel (1, &
         [0.1_default, 0.2_default, 0.3_default, 0.4_default, 0.5_default])
    call phs%evaluate_other_channels (1)
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Inverse kinematics"
    write (u, "(A)")

    call phs%get_outgoing_momenta (q)
    call phs%final ()
    deallocate (phs)
    
    call phs_data%allocate_instance (phs)
    call phs%init (phs_data)
       
    call phs%set_incoming_momenta (p)
    call phs%compute_flux ()
    call phs%set_outgoing_momenta (q)
    
    call phs%inverse ()
    call phs%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs%final ()
    deallocate (phs)

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_4"

  end subroutine phs_wood_4

@ %def phs_wood_4
@
\subsubsection{Equivalences}
Generate phase space for a simple process, including channel equivalences.
<<PHS wood: execute tests>>=
  call test (phs_wood_5, "phs_wood_5", &
       "equivalences", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_5
<<PHS wood: tests>>=
  subroutine phs_wood_5 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
   
    write (u, "(A)")  "* Test output: phs_wood_5"
    write (u, "(A)")  "*   Purpose: generate a phase-space configuration"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_5"), process_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)

    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       call phs_data%enable_equivalences ()
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a scratch phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_5"

  end subroutine phs_wood_5

@ %def phs_wood_5
@
\subsubsection{MD5 sum checks}
Generate phase space for a simple process.  Repeat this with and without
parameter change.
<<PHS wood: execute tests>>=
  call test (phs_wood_6, "phs_wood_6", &
       "phase-space generation", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_6
<<PHS wood: tests>>=
  subroutine phs_wood_6 (u)
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    type(phs_parameters_t) :: phs_par
    class(phs_config_t), allocatable :: phs_data
    logical :: exist, found, match
    integer :: u_phs
    character(*), parameter :: filename = "phs_wood_6_p.phs"
   
    write (u, "(A)")  "* Test output: phs_wood_6"
    write (u, "(A)")  "*   Purpose: generate and check  phase-space file"
    write (u, "(A)")
    
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process and phase-space parameters"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_6"), process_data)
    process_data%id = "phs_wood_6_p"
    process_data%md5sum = "1234567890abcdef1234567890abcdef"
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
    end select

    write (u, "(A)")  "* Remove previous phs file, if any"
    write (u, "(A)")

    inquire (file = filename, exist = exist)
    if (exist) then
       u_phs = free_unit ()
       open (u_phs, file = filename, action = "write")
       close (u_phs, status = "delete")
    end if

    write (u, "(A)")  "* Check phase-space file (should fail)"
    write (u, "(A)")
    
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Generate a phase-space file"
    write (u, "(A)")

    call phs_data%configure (phs_par%sqrts)

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    write (u, "(A)")
    write (u, "(A)")  "* Check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify sqrts and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 500
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify process and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    process_data%md5sum = "77777777777777777777777777777777"
    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify phs parameter and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    process_data%md5sum = "1234567890abcdef1234567890abcdef"
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    phs_par%off_shell = 17
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Modify model parameter and check MD5 sum"
    write (u, "(A)")

    call phs_data%final ()
    deallocate (phs_data)
    allocate (phs_wood_config_t :: phs_data)
    call model%set_par (var_str ("ms"), 100._default)
    call phs_data%init (process_data, model)
    phs_par%sqrts = 1000
    phs_par%off_shell = 1
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_parameters (phs_par)
       phs_data%sqrts = phs_par%sqrts
       phs_data%par%sqrts = phs_par%sqrts
    end select
    call phs_data%compute_md5sum ()

    write (u, "(1x,A,A,A)")  "MD5 sum (process)    = '", &
         phs_data%md5sum_process, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (model par)  = '", &
         phs_data%md5sum_model_par, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (phs config) = '", &
         phs_data%md5sum_phs_config, "'"

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%read_phs_file (exist, found, match)
       write (u, "(1x,A,L1)")  "exist = ", exist
       write (u, "(1x,A,L1)")  "found = ", found
       write (u, "(1x,A,L1)")  "match = ", match
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_6"

  end subroutine phs_wood_6

@ %def phs_wood_6
@
<<PHS wood: execute vis tests>>=
  call test (phs_wood_vis_1, "phs_wood_vis_1", &
       "visualizing phase space channels", &
       u, results)
<<PHS wood: test declarations>>=
  public :: phs_wood_vis_1
<<PHS wood: tests>>=
  subroutine phs_wood_vis_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs_data
    type(mapping_defaults_t) :: mapping_defaults
    type(string_t) :: vis_file, pdf_file, ps_file
    real(default) :: sqrts
    logical :: exist, exist_pdf, exist_ps
    integer :: u_phs, iostat, u_vis
    character(95) :: buffer
    
    write (u, "(A)")  "* Test output: phs_wood_vis_1"
    write (u, "(A)")  "*   Purpose: visualizing the &
         &phase-space configuration"
    write (u, "(A)")
    
    call os_data_init (os_data)
    call model%init_test ()

    call syntax_phs_forest_init ()
    
    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call init_test_process_data (var_str ("phs_wood_vis_1"), process_data)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, status = "scratch", action = "readwrite")
    call write_test_phs_file (u_phs, var_str ("phs_wood_vis_1"))
    rewind (u_phs)
    do
       read (u_phs, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Setup phase-space configuration object"
    write (u, "(A)")

    mapping_defaults%step_mapping = .false.

    allocate (phs_wood_config_t :: phs_data)
    call phs_data%init (process_data, model)
    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%set_input (u_phs)
       call phs_data%set_mapping_defaults (mapping_defaults)
       phs_data%os_data = os_data
       phs_data%io_unit = 0
       phs_data%io_unit_keep_open = .true.
       phs_data%vis_channels = .true.
    end select

    sqrts = 1000._default
    call phs_data%configure (sqrts)
       
    call phs_data%write (u)
    write (u, "(A)")

    select type (phs_data)
    type is (phs_wood_config_t)
       call phs_data%write_forest (u)
    end select
    
    vis_file = "phs_wood_vis_1_phs.tex"
    ps_file  = "phs_wood_vis_1_phs.ps"
    pdf_file = "phs_wood_vis_1_phs.pdf"    
    inquire (file = char (vis_file), exist = exist)
    if (exist) then
       u_vis = free_unit ()
       open (u_vis, file = char (vis_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_vis, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_vis)
    else
       write (u, "(A)")  "[Visualize LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[Visualize Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[Visualize Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[Visualize PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[Visualize PDF file is missing/non-regular]"
    end if        
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    close (u_phs)
    call phs_data%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: phs_wood_vis_1"

  end subroutine phs_wood_vis_1

@ %def phs_wood_vis_1
