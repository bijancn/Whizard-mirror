% $Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Implementation of [[circe2]]}
<<[[implicit none]]>>=
  implicit none
@ 
<<[[circe2.f90]]>>=
! circe2.f90 -- beam spectra for linear colliders and photon colliders
<<Copyleft notice>>
<<Separator>>
module circe2
  use kinds

<<[[implicit none]]>>
  private

<<Public procedures>>

<<Public types>>

<<[[parameter]] declarations>>

<<Declaration: circe2 parameters>>

  type(circe2_params_t), public, save :: c2p

<<Abstract types>>
     
<<Abstract interfaces>>

contains

<<Procedures>>
end module circe2
@ 
<<Separator>>=
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
@ 
<<Copyleft notice>>=
! $Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $
! Copyright (C) 2001-2014 by 
!      Wolfgang Kilian <kilian@physik.uni-siegen.de>
!      Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
!      Juergen Reuter <juergen.reuter@desy.de>
!      Christian Speckner <cnspeckn@googlemail.com>
!
! Circe2 is free software; you can redistribute it and/or modify it
! under the terms of the GNU General Public License as published by
! the Free Software Foundation; either version 2, or (at your option)
! any later version.
!
! Circe2 is distributed in the hope that it will be useful, but
! WITHOUT ANY WARRANTY; without even the implied warranty of
! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
! GNU General Public License for more details.
!
! You should have received a copy of the GNU General Public License
! along with this program; if not, write to the Free Software
! Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@ 
<<[[circe2_c.c]]>>=
/* circe2_c.c -- beam spectra for linear colliders and photon colliders */
<<Copyleft notice (C)>>
<<Separator2 (C)>>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <math.h>
#undef min
#define min(a,b) ((a) < (b) ? (a) : (b))
#undef max
#define max(a,b) ((a) > (b) ? (a) : (b))
<<Separator2 (C)>>
<<Macros (C)>>
<<Separator2 (C)>>
<<Well known constants (C)>>
<<Separator2 (C)>>
<<Data type declarations (C)>>
<<Separator2 (C)>>
<<Private Procedures (C)>>
<<Separator2 (C)>>
<<Public Procedures (C)>>
@ 
<<Separator2 (C)>>=

<<Separator (C)>>

@ 
<<Separator (C)>>=
/**********************************************************************/
@ 
<<Copyleft notice (C)>>=
/* $Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $
   Copyright (C) 2002-2011 by 
        Wolfgang Kilian <kilian@physik.uni-siegen.de>
        Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
	Juergen Reuter <juergen.reuter@desy.de>
	Christian Speckner <cnspeckn@googlemail.com>
  
   Circe2 is free software; you can redistribute it and/or modify it
   under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
  
   Circe2 is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
  
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. */
@ Can't live without it:
<<Private Procedures (C)>>=
void *
xmalloc (size_t size)
{
  void *ptr = malloc (size);
  if (ptr == NULL) {
    fprintf (stderr, "can't get %d bytes ... exiting!\n", size);
    exit (-1);
  }
  return ptr;
}
@ 
<<[[circe2_cpp.cc]]>>=
// circe2_cpp.cc -- beam spectra for linear colliders and photon colliders
<<Copyleft notice (C++)>>
<<Separator2 (C++)>>
<<Data type declarations (C++)>>
<<Procedures (C++)>>
@ 
<<Separator2 (C++)>>=
//
<<Separator (C++)>>
//
@ 
<<Separator (C++)>>=
// ---------------------------------------------------------------------
@ 
<<Copyleft notice (C++)>>=
// $Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $
// Copyright (C) 2002-2011 by 
//      Wolfgang Kilian <kilian@physik.uni-siegen.de>
//      Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
//      Juergen Reuter <juergen.reuter@desy.de>
//      Christian Speckner <cnspeckn@googlemail.com>
//
// Circe2 is free software; you can redistribute it and/or modify it
// under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2, or (at your option)
// any later version.
//
// Circe2 is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Data}
The [[circe2_params_t]] type (old [[/circ2cm/]] common block which had
to be arranged such that the constant [[parameter]]s come first and the variables in order of
decreasing alignment constraints):
<<Public procedures>>=
  public :: circe2_params_t 
<<Declaration: circe2 parameters>>=
  type :: circe2_params_t
    <<8-byte aligned part of circe2 parameters>>
    <<4-byte aligned part of circe2 parameters>>
  end type circe2_params_t

@ 
@ %def circe2_params_t
<<Data type declarations (C)>>=
typedef struct
{
  int n;
  <<[[circe2_division]] components>>
} circe2_division;
@
<<Private Procedures (C)>>=
static circe2_division *
circe2_new_division (int nbins)
{
  circe2_division *d;
  d = xmalloc (sizeof (circe2_division));
  d->n = nbins;
  <<Allocate [[circe2_division]] components [[*d]]>>
  return d;
}
@ 
<<Data type declarations (C)>>=
typedef struct
{
  circe2_division *d1, *d2;
  <<[[circe2_channel]] components>>
} circe2_channel;
@
<<Private Procedures (C)>>=
static circe2_channel *
circe2_new_channel (int nbins1, int nbins2)
{
  circe2_channel *p;
  int i;
  p = xmalloc (sizeof (circe2_channel));
  p->d1 = circe2_new_division (nbins1);
  p->d2 = circe2_new_division (nbins2);
  <<Allocate [[circe2_channel]] components [[*p]]>>
  return p;
}
@ 
<<Data type declarations (C)>>=
typedef struct
{
  int n;
  circe2_channel **ch;
  <<[[circe2_channels]] components>>
} circe2_channels;
@
<<Private Procedures (C)>>=
static circe2_channels *
circe2_new_channels (int nchannels, int nbins1, int nbins2)
{
  int i;
  circe2_channels *p;
  p = xmalloc (sizeof (circe2_channels));
  p->n = nchannels;
  p->ch = xmalloc (p->n * sizeof (circe2_channel *));
  for (i = 0; i < p->n; i++)
    p->ch[i] = circe2_new_channel (nbins1, nbins2);
  return p;
}
@
\begin{figure}
  \begin{center}
    \begin{empgraph}(90,50)
      setrange (0, 0, 1, 1);
      autogrid (,);
      pickup pencircle scaled 0.5pt;
      for i = 2 step 2 until 8:
        x := i / 10;
        gdraw (0,x) -- (1,x);
        gdraw (x,0) -- (x,1);
      endfor
      glabel (btex $x_{1}^{\min}$ etex, (0.0,-0.1));
      glabel (btex $x_{1}^{\max}$ etex, (1.0,-0.1));
      glabel (btex $x_{2}^{\min}$ etex, (-0.1,0.0));
      glabel (btex $x_{3}^{\max}$ etex, (-0.1,1.0));
      glabel (btex $i_1=1$ etex, (0.1,-0.1));
      glabel (btex $2$ etex, (0.3,-0.1));
      glabel (btex $3$ etex, (0.5,-0.1));
      glabel (btex $\ldots$ etex, (0.7,-0.1));
      glabel (btex $n_1$ etex, (0.9,-0.1));
      glabel (btex $1$ etex, (-0.1,0.1));
      glabel (btex $2$ etex, (-0.1,0.3));
      glabel (btex $3$ etex, (-0.1,0.5));
      glabel (btex $\ldots$ etex, (-0.1,0.7));
      glabel (btex $i_2=n_2$ etex, (-0.1,0.9));
      glabel (btex $1$ etex, (0.1,0.1));
      glabel (btex $2$ etex, (0.3,0.1));
      glabel (btex $3$ etex, (0.5,0.1));
      glabel (btex $\ldots$ etex, (0.7,0.1));
      glabel (btex $n_1$ etex, (0.9,0.1));
      glabel (btex $n_1+1$ etex, (0.1,0.3));
      glabel (btex $n_1+2$ etex, (0.3,0.3));
      glabel (btex $\ldots$ etex, (0.5,0.3));
      glabel (btex $\ldots$ etex, (0.7,0.3));
      glabel (btex $2n_1$ etex, (0.9,0.3));
      glabel (btex $2n_1+1$ etex, (0.1,0.5));
      glabel (btex $\ldots$ etex, (0.3,0.5));
      glabel (btex $\ldots$ etex, (0.5,0.5));
      glabel (btex $\ldots$ etex, (0.7,0.5));
      glabel (btex $\ldots$ etex, (0.9,0.5));
      glabel (btex $\ldots$ etex, (0.1,0.7));
      glabel (btex $\ldots$ etex, (0.3,0.7));
      glabel (btex $\ldots$ etex, (0.5,0.7));
      glabel (btex $\ldots$ etex, (0.7,0.7));
      glabel (btex $n_1(n_2-1)$ etex, (0.9,0.7));
      glabel (btex $\displaystyle {n_1(n_2-1)\atop\mbox{}+1}$ etex, (0.1,0.9));
      glabel (btex $\displaystyle {n_1(n_2-1)\atop\mbox{}+2}$ etex, (0.3,0.9));
      glabel (btex $\ldots$ etex, (0.5,0.9));
      glabel (btex $n_1n_2-1$ etex, (0.7,0.9));
      glabel (btex $n_1n_2$ etex, (0.9,0.9));
      pickup pencircle scaled 1.0pt;
    \end{empgraph}
  \end{center}
  \caption{\label{fig:linear-enumeration}%
    Enumerating the bins linearly, starting from 1 (Fortran style).
    Probability distribution functions will have a sentinel at~0
    that's always~0.}
\end{figure}
We store the probability distribution function as a one-dimensional
array~[[wgt]]\footnote{The second ``dimension'' is just an index for
the channel.}, since this simplifies the binary search used for
inverting the distribution.  [wgt(0,ic)] is always 0 and serves as a
convenient sentinel for the binary search.  It is \emph{not} written
in the file, which contains the normalized weight of the bins.
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(0:NBMAX*NBMAX,NCMAX) :: wgt
@ The actual number of bins in each direction is
<<4-byte aligned part of circe2 parameters>>=
    integer, dimension(NCMAX) :: nb1, nb2
@ Of course, we can't make \emph{any}
exceptions to the rule $[[nb]] \le [[NBMAX]]$ (similarly for $[[nc]]
\le [[NCMAX]]$ below). $[[NCMAX]] = (3\cdot2)^2$ for three flavors
($\{e^{+},e^{-},\gamma\}$) and two helicity states.
<<[[parameter]] declarations>>=
  integer, parameter :: NBMAX = 100, NCMAX = 36
@
<<[[circe2_channel]] components>>=
double *weight;
@ 
<<Allocate [[circe2_channel]] components [[*p]]>>=
p->weight = xmalloc ((p->d1->n * p->d2->n + 1) * sizeof(double));
@ Using figure~\ref{fig:linear-enumeration}, calculating the
index of a bin from the two-dimensional coordinates is
straightforward, of course:
<<$[[i]] \leftarrow ([[i1]],[[i2]])$>>=
      i = i1 + (i2 - 1) * c2p%nb1(ic)
@ 
<<$[[i]] \leftarrow ([[i1]],[[i2]])$ (C)>>=
      i = i1 + (i2 - 1) * ch->d1->n
@ The inverse
\begin{subequations}
\begin{align}
  i_1 &= 1 + ((i - 1) \mod n_1) \\
  i_2 &= 1 + \lfloor (i - 1) / n_1 \rfloor
\end{align}
\end{subequations}
can also be written
\begin{subequations}
\begin{align}
  i_2 &= 1 + \lfloor (i - 1) / n_1 \rfloor \\
  i_1 &= i - (i_2 - 1) n_1
\end{align}
\end{subequations}
<<$([[i1]],[[i2]]) \leftarrow [[i]]$>>=
      i2 = 1 + (i - 1) / c2p%nb1(ic)
      i1 = i - (i2 - 1) * c2p%nb1(ic)
@
<<Private Procedures (C)>>=
static inline void
split_index (circe2_channel *ch, int *i1, int *i2, int i) {
  *i2 = 1 + (i - 1) / ch->d1->n;
  *i1 = i - (*i2 - 1) * ch->d1->n;
}
@ The density normalized to the bin size
\begin{equation*}
   v = \frac{w}{\Delta x_1 \Delta x_2}
\end{equation*}
such that
\begin{equation*}
   \int\!\mathrm{d}x_1\mathrm{d}x_2\; v = \sum w = 1
\end{equation*}
For mapped distributions, on the level of bins, we can either use the
area of the domain and apply a jacobian or the area of the codomain
directly
\begin{equation}
\label{eq:jacobian-Delta_x-Delta_y}
 \frac{\mathrm{d}x}{\mathrm{d}y}\cdot\frac{1}{\Delta x}
   \approx \frac{1}{\Delta y}
\end{equation}
We elect to use the former, because this reflects the distribution
of the events generated by~[[cir2gn]] \emph{inside} the bins as well.
This quantity is more conveniently stored as a true two-dimensional array:
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(NBMAX,NBMAX,NCMAX) :: val
@
<<[[circe2_channel]] components>>=
double **value;
@ 
<<Allocate [[circe2_channel]] components [[*p]]>>=
p->value = xmalloc (p->d1->n * sizeof(double *));
for (i = 0; i < p->d1->n; i++)
  p->value[i] = xmalloc (p->d2->n * sizeof(double));
@
\begin{figure}
  \begin{center}
    \begin{empgraph}(50,50)
      pickup pencircle scaled 1.0pt;
      setrange (0, 0, 1, 1);
      autogrid (,);
      for i = 1 upto 15:
        xi := i / 16;
        x := 1 - xi * xi * xi;
        gdraw (0,x) -- (1,x);
        gdraw (x,0) -- (x,1);
      endfor
    \end{empgraph}
  \end{center}
  \caption{%
    Almost factorizable distributions, like $\mathrm{e}^+\mathrm{e}^-$.}
\end{figure}
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(0:NBMAX,NCMAX) :: xb1, xb2
@
<<[[circe2_division]] components>>=
double *x;
@
<<Allocate [[circe2_division]] components [[*d]]>>=
d->x = xmalloc ((d->n + 1) * sizeof(double));
@
\begin{figure}
  \begin{center}
    \begin{empgraph}(50,50)
      setrange (0, 0, 1, 1);
      autogrid (,);
      for i = 1 upto 15:
        xi := i / 16;
        x := 1 - xi * xi * xi;
        pickup pencircle scaled 1.0pt;
        gdraw (0,0) -- (1,x);
        pickup pencircle scaled 0.5pt;
        gdraw (0,0) -- (x,1);
      endfor
      for i = 1 upto 15:
        xi := i / 16;
        x := 0.8 * (1 - xi * xi * xi);
        pickup pencircle scaled 1.0pt;
        gdraw (x,0) -- (x,x);
        pickup pencircle scaled 0.5pt;
        gdraw (0,x) -- (x,x);
      endfor
      pickup pencircle scaled 1.0pt;
      gdraw (0,0) -- (1,1);
    \end{empgraph}
  \end{center}
  \caption{%
    Symmetrical, strongly correlated distributions, e.\,g.~with a
    ridge on the diagonal, like $\gamma\gamma$ at a $\gamma$-collider.}
\end{figure}
<<4-byte aligned part of circe2 parameters>>=
    logical, dimension(NCMAX) :: triang
@
<<[[circe2_channel]] components>>=
int triangle;
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Channels}
The actual number of channels $\gamma\gamma$, $\mathrm{e}^-\gamma$,
$\mathrm{e}^-\mathrm{e}^+$, etc.
<<4-byte aligned part of circe2 parameters>>=
    integer :: nc
@ The particles that are described by this channel and their
polarizations:
<<4-byte aligned part of circe2 parameters>>=
    integer, dimension(NCMAX) :: pid1, pid2
    integer, dimension(NCMAX) :: pol1, pol2
@
<<[[circe2_division]] components>>=
int pid;
int pol;
@ The integrated luminosity of the channel
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(NCMAX) :: lumi
@
<<[[circe2_channel]] components>>=
double lumi;
@ The integrated luminosity of the channel
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(0:NCMAX) :: cwgt
@
<<[[circe2_channel]] components>>=
double channel_weight;
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Maps}
<<4-byte aligned part of circe2 parameters>>=
    integer, dimension(NBMAX,NCMAX) :: map1, map2
@
<<[[circe2_division]] components>>=
int *map;
@
<<Allocate [[circe2_division]] components [[*d]]>>=
d->map = xmalloc (d->n * sizeof(int));
@ 
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(0:NBMAX,NCMAX) :: yb1, yb2
@
<<[[circe2_division]] components>>=
double *y;
@
<<Allocate [[circe2_division]] components [[*d]]>>=
d->y = xmalloc ((d->n + 1) * sizeof(double));
@ 
<<8-byte aligned part of circe2 parameters>>=
    real(kind=double), dimension(NBMAX,NCMAX) :: alpha1, alpha2
    real(kind=double), dimension(NBMAX,NCMAX) :: xi1, xi2
    real(kind=double), dimension(NBMAX,NCMAX) :: eta1, eta2
    real(kind=double), dimension(NBMAX,NCMAX) :: a1, a2
    real(kind=double), dimension(NBMAX,NCMAX) :: b1, b2
@
<<[[circe2_division]] components>>=
double *alpha;
double *xi, *eta;
double *a, *b;
@
<<Allocate [[circe2_division]] components [[*d]]>>=
d->alpha = xmalloc (d->n * sizeof(double));
d->xi = xmalloc (d->n * sizeof(double));
d->eta = xmalloc (d->n * sizeof(double));
d->a = xmalloc (d->n * sizeof(double));
d->b = xmalloc (d->n * sizeof(double));
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Random-Number Generator}
The generator routines do not fix or provide a random-number generator.  The
caller has to provide an implementation which is transferred to the
subroutines in one of two possible forms:
\begin{enumerate}
\item
  as a subroutine which generates a single random number, working on an
  implicit external state
\item
  as an object with a method the generates a single random number, working on
  an internal state
\end{enumerate}
We allow for using both forms, only in the Fortran API.

These snippets should be used by the procedures that use a RNG:
<<RNG dummy arguments>>=
rng, rng_obj
<<RNG dummy declarations>>=
procedure(rng_proc), optional :: rng
class(rng_type), intent(inout), optional :: rng_obj
<<RNG: generate [[u]]>>=
call rng_call (u, <<RNG dummy arguments>>)
<<Procedures>>=
  subroutine rng_call (u, <<RNG dummy arguments>>)
    real(kind=double), intent(out) :: u
    <<RNG dummy declarations>>
    if (present (rng)) then
       call rng (u)
    else if (present (rng_obj)) then
       call rng_obj%generate (u)
    else
       stop "circe2: internal error: generator requires either rng &
            &or rng_obj argument"
    end if
  end subroutine rng_call
  
@ %def rng_call
@ This defines the procedure version of the RNG, corresponding to the
traditional F77 [[external]] interface.  The abstract interface enables the
compiler to check conformance.
<<Abstract interfaces>>=
  abstract interface
    subroutine rng_proc (u)
      import :: double
      real(kind=double), intent(out) :: u
    end subroutine rng_proc
  end interface
  
@ %def rng_proc
@ Here we define the object version of the RNG.  It has to implement a
[[generate]] method which parallels the [[rng_proc]] procedure above.
<<Public types>>=
  public :: rng_type
<<Abstract types>>=
  type, abstract :: rng_type
   contains
     procedure(rng_generate), deferred :: generate
  end type rng_type
  
@ %def rng_type
<<Abstract interfaces>>=
  abstract interface
     subroutine rng_generate (rng_obj, u)
       import :: rng_type, double
       class(rng_type), intent(inout) :: rng_obj
       real(kind=double), intent(out) :: u
     end subroutine rng_generate
  end interface
  
@ %def rng_generate  
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Generation}
Generate a two-dimensional distribution for~$([[x1]],[[x2]])$
according to the histogram for channel [[ic]].
<<Public procedures>>=
  public :: cir2gn
<<Procedures>>=
  subroutine cir2gn (p1, h1, p2, h2, y1, y2, <<RNG dummy arguments>>)
    integer :: p1, h1, p2, h2
    real(kind=double) :: y1, y2
    <<RNG dummy declarations>>
    integer :: i, ic, i1, i2, ibot, itop
    real(kind=double) :: x1, x2
    real(kind=double) :: u, tmp
    <<Find [[ic]] for [[p1]], [[h1]], [[p2]] and [[h2]]>>
    <<Complain and [[return]] iff $[[ic]] \le 0$>>
    <<RNG: generate [[u]]>>
    <<Do a binary search for $[[wgt(i-1)]] \le [[u]] < [[wgt(i)]]$>>
    <<$([[i1]],[[i2]]) \leftarrow [[i]]$>>
    <<$[[x1]]\in[ [[xb1(i1-1)]], [[xb1(i1)]] ]$>>
    <<$[[x2]]\in[ [[xb2(i2-1)]], [[xb2(i2)]] ]$>>
    <<$[[y1]]\leftarrow[[x1]]$>>
    <<$[[y2]]\leftarrow[[x2]]$>>
    <<Inverse triangle map>>
  end subroutine cir2gn

@
<<Public Procedures (C)>>=
void
circe2_generate (circe2_channels *channels,
                 int p1, int h1, int p2, int h2,
                 double *y1, double *y2,
                 void (*rng)(double *))
{
  circe2_channel *ch = NULL;
  int i, i1, i2;
  double u, x1, x2;
  ch = circe2_find_channel (channels, p1, h1, p2, h2);
  <<Complain and [[return]] iff $[[ch]] = \text{NULL}$ (C)>>
  rng (&u);
  i = binary_search (ch->weight, 0, ch->d1->n * ch->d2->n, u);
  split_index (ch, &i1, &i2, i);
  <<$[[x1]]\in[ [[ch->d1->x[i1-1] ]], [[ch->d1->x[i1] ]] ]$ (C)>>
  <<$[[x2]]\in[ [[ch->d2->x[i2-1] ]], [[ch->d2->x[i2] ]] ]$ (C)>>
  <<$[[y1]]\leftarrow[[x1]]$ (C)>>
  <<$[[y2]]\leftarrow[[x2]]$ (C)>>
  <<Inverse triangle map (C)>>
}
@
<<4-byte aligned part of circe2 parameters>>=
    integer :: polspt
@
<<[[circe2_channels]] components>>=
int polarization_support;
@
<<[[parameter]] declarations>>=
  integer, parameter :: POLAVG = 1, POLHEL = 2, POLGEN = 3
@
<<Well known constants (C)>>=
#define POLAVG 1
#define POLHEL 2
#define POLGEN 3
@ A linear search for a matching channel should suffice, because the
number if channels~[[nc]] will always be a small number.  The most
popular channels should be first in the list, anyway.
<<Find [[ic]] for [[p1]], [[h1]], [[p2]] and [[h2]]>>=
    ic = 0
    if (((c2p%polspt .eq. POLAVG) .or. (c2p%polspt .eq. POLGEN)) &
         .and. ((h1 .ne. 0) .or. (h2 .ne. 0))) then
       write (*, '(2A)') 'circe2: current beam description ', &
            'supports only polarization averages'
    else if ((c2p%polspt .eq. POLHEL) &
         .and. ((h1 .eq. 0) .or. (h2 .eq. 0))) then
       write (*, '(2A)') 'circe2: polarization averages ', &
            'not supported by current beam description'
    else
       do i = 1, c2p%nc
          if (       (p1 .eq. c2p%pid1(i)) .and. (h1 .eq. c2p%pol1(i)) & 
               .and. (p2 .eq. c2p%pid2(i)) .and. (h2 .eq. c2p%pol2(i))) then
             ic = i
          end if
       end do								   
    end if
@ 
<<Private Procedures (C)>>=
static circe2_channel *
circe2_find_channel (circe2_channels *channels,
	             int p1, int h1, int p2, int h2)
{
  int i;
  if (((channels->polarization_support == POLAVG)
       || (channels->polarization_support == POLGEN))
      && ((h1 != 0) || (h2 != 0))) {
    fprintf (stderr,
	     "circe2: current beam description "
	     "supports only polarization averages\n");
    return NULL;
  }
  if ((channels->polarization_support == POLHEL)
	   && ((h1 == 0) || (h2 == 0))) {
    fprintf (stderr,
	     "circe2: polarization averages not "
	     "supported by current beam description\n");
    return NULL;
  }
  for (i = 0; i < channels->n; i++) {
    circe2_channel *ch = channels->ch[i];
    if ((p1 == ch->d1->pid) && (h1 == ch->d1->pol)
	&& (p2 == ch->d2->pid) && (h2 == ch->d2->pol))
      return ch;
  }
  return NULL;
}
@ $-3.4\cdot10^{38}$ is a very large negative number that can be represented
in typical 4-byte floating point numbers:
<<Complain and [[return]] iff $[[ic]] \le 0$>>=
    if (ic .le. 0) then
       write (*, '(A,2I4,A,2I3)') &
            'circe2: no channel for particles', p1, p2, &
            ' and polarizations', h1, h2
       y1 = -3.4E+38
       y2 = -3.4E+38
       return
    end if
@ 
<<Complain and [[return]] iff $[[ch]] = \text{NULL}$ (C)>>=
if (ch == NULL) {
  fprintf (stderr,
	   "circe2: no channel for particles (%d, %d) "
	   "and polarizations (%d, %d)\n", p1, p2, h1, h2);
  *y1 = -3.4e+38;
  *y2 = -3.4e+38;
  return;
}
@ The number of bins is typically \emph{much} larger and we must use a
binary search to get a reasonable performance.
<<Do a binary search for $[[wgt(i-1)]] \le [[u]] < [[wgt(i)]]$>>=
      ibot = 0
      itop = c2p%nb1(ic) * c2p%nb2(ic)
      do 
        if (itop .le. (ibot + 1)) then
           i = ibot + 1
           exit
        else
           i = (ibot + itop) / 2
           if (u .lt. c2p%wgt(i,ic)) then
              itop = i
           else
              ibot = i
           end if
        end if 
      end do
@
<<Private Procedures (C)>>=
static int
binary_search (double *x, int bot, int top, double u)
{
  int low = bot;
  int high = top;
  while (1) {
    if (high <= (low + 1)) {
      return (low + 1);
      break;
    } else {
      int i = (low + high) / 2;
      if (u < x[i])
	high = i;
      else
	low = i;
    }
  }
}
@ 
<<$[[x1]]\in[ [[xb1(i1-1)]], [[xb1(i1)]] ]$>>=
      <<RNG: generate [[u]]>>
      x1 = c2p%xb1(i1,ic)*u + c2p%xb1(i1-1,ic)*(1-u)
@ 
<<$[[x2]]\in[ [[xb2(i2-1)]], [[xb2(i2)]] ]$>>=
      <<RNG: generate [[u]]>>
      x2 = c2p%xb2(i2,ic)*u + c2p%xb2(i2-1,ic)*(1-u)
@ 
<<$[[x1]]\in[ [[ch->d1->x[i1-1] ]], [[ch->d1->x[i1] ]] ]$ (C)>>=
      rng (&u);
      x1 = ch->d1->x[i1]*u + ch->d1->x[i1-1]*(1-u);
@ 
<<$[[x2]]\in[ [[ch->d2->x[i2-1] ]], [[ch->d2->x[i2] ]] ]$ (C)>>=
      rng (&u);
      x2 = ch->d2->x[i2]*u + ch->d2->x[i2-1]*(1-u);
@ 
<<$[[y1]]\leftarrow[[x1]]$>>=
    if (c2p%map1(i1,ic) .eq. 0) then
       y1 = x1
    else if (c2p%map1(i1,ic) .eq. 1) then
       y1 = (c2p%a1(i1,ic)*(x1-c2p%xi1(i1,ic)))**c2p%alpha1(i1,ic) / c2p%b1(i1,ic) &
              + c2p%eta1(i1,ic)
    else if (c2p%map1(i1,ic) .eq. 2) then
       y1 = c2p%a1(i1,ic) * tan(c2p%a1(i1,ic)*(x1-c2p%xi1(i1,ic))/c2p%b1(i1,ic)**2) &
              + c2p%eta1(i1,ic)
    else
       write (*, '(A,I3)') &
            'circe2: internal error: invalid map: ', c2p%map1(i1,ic)
    end if
@ 
<<$[[y2]]\leftarrow[[x2]]$>>=
    if (c2p%map2(i2,ic) .eq. 0) then
       y2 = x2
    else if (c2p%map2(i2,ic) .eq. 1) then
       y2 = (c2p%a2(i2,ic)*(x2-c2p%xi2(i2,ic)))**c2p%alpha2(i2,ic) / c2p%b2(i2,ic) &
              + c2p%eta2(i2,ic)
    else if (c2p%map2(i2,ic) .eq. 2) then
       y2 = c2p%a2(i2,ic) * tan(c2p%a2(i2,ic)*(x2-c2p%xi2(i2,ic))/c2p%b2(i2,ic)**2) &
              + c2p%eta2(i2,ic)
    else
       write (*, '(A,I3)') & 
            'circe2: internal error: invalid map: ', c2p%map2(i2,ic)
    end if
@ 
<<$[[y1]]\leftarrow[[x1]]$ (C)>>=
switch (ch->d1->map[i1]) {
case 0:
  *y1 = x1;
case 1:
  *y1 = pow (ch->d1->a[i1] * (x1 - ch->d1->xi[i1]), ch->d1->alpha[i1])
         / ch->d1->b[i1]
         + ch->d1->eta[i1];
case 2:
  *y1 = ch->d1->a[i1] * tan (ch->d1->a[i1] * (x1 - ch->d1->xi[i1])
                              / (ch->d1->b[i1] * ch->d1->b[i1]))
         + ch->d1->eta[i1];
default:
  fprintf (stderr, "circe2: internal error: invalid map: %d\n", ch->d1->map[i1]);
}
@ 
<<$[[y2]]\leftarrow[[x2]]$ (C)>>=
switch (ch->d2->map[i2]) {
case 0:
  *y2 = x2;
case 1:
  *y2 = pow (ch->d2->a[i2] * (x2 - ch->d2->xi[i2]), ch->d2->alpha[i2])
         / ch->d2->b[i2]
         + ch->d2->eta[i2];
case 2:
  *y2 = ch->d2->a[i2] * tan (ch->d2->a[i2] * (x2 - ch->d2->xi[i2])
                              / (ch->d2->b[i2] * ch->d2->b[i2]))
         + ch->d2->eta[i2];
default:
  fprintf (stderr, "circe2: internal error: invalid map: %d\n", ch->d2->map[i2]);
}
@
\begin{dubious}
  There's still something wrong with \emph{unweighted} events
  for the case that there is a triangle map \emph{together} with a
  non-trivial $[[x2]]\to[[y2]]$ map. \emph{Fix this!!!}
\end{dubious}
<<Inverse triangle map>>=
      if (c2p%triang(ic)) then
         y2 = y1 * y2
         <<Swap [[y1]] and [[y2]] in 50\%{} of the cases>>
      end if
@ 
<<Inverse triangle map (C)>>=
if (ch->triangle) {
  *y2 = *y1 * *y2;
  <<Swap [[y1]] and [[y2]] in 50\%{} of the cases (C)>>
}
@
<<Swap [[y1]] and [[y2]] in 50\%{} of the cases>>=
      <<RNG: generate [[u]]>>
      if (2*u .ge. 1) then
         tmp = y1
         y1 = y2
         y2 = tmp
      end if
@
<<Swap [[y1]] and [[y2]] in 50\%{} of the cases (C)>>=
rng (&u);
if (2*u >= 1) {
  double tmp;
  tmp = *y1;
  *y1 = *y2;
  *y2 = tmp;
}
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Channel selection}
We could call [[cir2gn]] immediately, but then [[cir2gn]] and
[[cir2ch]] would have the same calling conventions and might have
caused a lot of confusion.
<<Public procedures>>=
  public :: cir2ch
<<Procedures>>=
  subroutine cir2ch (p1, h1, p2, h2, <<RNG dummy arguments>>)
    integer :: p1, h1, p2, h2
    <<RNG dummy declarations>>
    integer :: ic, ibot, itop
    real(kind=double) :: u
    <<RNG: generate [[u]]>>
    ibot = 0
    itop = c2p%nc
    do
      if (itop .le. (ibot + 1)) then
         ic = ibot + 1
         p1 = c2p%pid1(ic)
         h1 = c2p%pol1(ic)
         p2 = c2p%pid2(ic)
         h2 = c2p%pol2(ic)
         exit
      else
         ic = (ibot + itop) / 2
         if (u .lt. c2p%cwgt(ic)) then
            itop = ic
         else
            ibot = ic
         end if
      end if
    end do
    write (*, '(A)') 'circe2: internal error'
    stop
  end subroutine cir2ch

@ %def cir2ch
@
<<Public Procedures (C)>>=
void
circe2_random_channel (circe2_channels *channels,
                       int *p1, int *h1, int *p2, int *h2,
                       void (*rng) (double *))
{
  circe2_channel *ch;
  int ic, ibot, itop;
  double u;
  POINTER_PANIC(circe2_random_channel, channels, "channels");
  rng (&u);
  ibot = 0;
  itop = channels->n;
  while (ibot + 1 < itop) {
    ic = (ibot + itop) / 2;
    if (u < channels->ch[ic]->channel_weight)
      itop = ic;
    else
      ibot = ic;
  }
  ch = channels->ch[ibot + 1];
  POINTER_PANIC(circe2_random_channel, ch, "selected channel");
  *p1 = ch->d1->pid;
  *h1 = ch->d1->pol;
  *p2 = ch->d2->pid;
  *h2 = ch->d2->pol;
}
@ 
<<Macros (C)>>=
#define POINTER_PANIC(fct,ptr,name) \
  if (ptr == NULL) { \
    fprintf (stderr, "%s: PANIC: %s not initialized!\n", #fct, name); \
    exit (-1); \
  }
@ Below, we will always have $[[h1]]=[[h2]]=0$. but we don't have to
check this explicitely, because [[cir2dm]] will do it anyway.  The
procedure could be made more efficient, since most of [[cir2dm]] is
undoing parts of [[cir2gn]].  
<<Public procedures>>=
  public :: cir2gp
<<Procedures>>=
  subroutine cir2gp (p1, p2, x1, x2, pol, <<RNG dummy arguments>>)
    integer :: p1, p2
    real(kind=double) :: x1, x2
    real(kind=double), dimension(0:3,0:3) :: pol
    <<RNG dummy declarations>>
    integer :: h1, h2, i1, i2
    real(kind=double) :: pol00
    call cir2ch (p1, h1, p2, h2, <<RNG dummy arguments>>)
    call cir2gn (p1, h1, p2, h2, x1, x2, <<RNG dummy arguments>>)
    call cir2dm (p1, p2, x1, x2, pol)
    pol00 = pol(0,0)
    do i1 = 0, 4
       do i2 = 0, 4
          pol(i1,i2) = pol(i1,i2) / pol00
    	 end do     
    end do
  end subroutine cir2gp

@ %def cir2gp
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Luminosity}
<<Public procedures>>=
  public :: cir2lm
<<Procedures>>=
  function cir2lm (p1, h1, p2, h2)
    integer :: p1, h1, p2, h2
    integer :: ic
    real(kind=double) :: cir2lm
    cir2lm = 0
    do ic = 1, c2p%nc
       if (       ((p1 .eq. c2p%pid1(ic)) .or. (p1 .eq. 0)) &
            .and. ((h1 .eq. c2p%pol1(ic)) .or. (h1 .eq. 0)) &
            .and. ((p2 .eq. c2p%pid2(ic)) .or. (p2 .eq. 0)) &
            .and. ((h2 .eq. c2p%pol2(ic)) .or. (h2 .eq. 0))) then
          cir2lm = cir2lm + c2p%lumi(ic)
       end if
    end do
  end function cir2lm

@  %def cir2lm
@ 
<<Public Procedures (C)>>=
double
circe2_lumi (circe2_channels *channels, int p1, int h1, int p2, int h2)
{
  int i;
  double lumi;
  POINTER_PANIC(circe2_random_channel, channels, "channels");
  lumi = 0;
  for (i = 0; i < channels->n; i++) {
    circe2_channel *c = channels->ch[i];
    if (((p1 == c->d1->pid) || (p1 == 0))
	&& ((h1 == c->d1->pol) || (h1 == 0))
        && ((p2 == c->d2->pid) || (p2 == 0))
	&& ((h2 == c->d2->pol) || (h2 == 0)))
      lumi += c->lumi;
  }
  return lumi;
}
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{2D-Distribution}
<<Public procedures>>=
  public :: cir2dn
<<Procedures>>=
  function cir2dn (p1, h1, p2, h2, yy1, yy2)
    integer :: p1, h1, p2, h2
    real(kind=double) :: yy1, yy2
    real(kind=double) :: y1, y2
    real(kind=double) :: cir2dn
    integer :: i, ic, i1, i2, ibot, itop
    <<Find [[ic]] for [[p1]], [[h1]], [[p2]] and [[h2]]>>
    if (ic .le. 0) then
       cir2dn = 0
       return
    end if
    <<$([[y1]],[[y2]])\leftarrow([[yy1]],[[yy2]])$>>
    if (     (y1 .lt. c2p%yb1(0,ic)) .or. (y1 .gt. c2p%yb1(c2p%nb1(ic),ic)) &
        .or. (y2 .lt. c2p%yb2(0,ic)) .or. (y2 .gt. c2p%yb2(c2p%nb2(ic),ic))) then
       cir2dn = 0
       return
    end if
    <<Do a binary search for $[[yb1(i1-1)]] \le [[y1]] < [[yb1(i1)]]$>>
    <<Do a binary search for $[[yb2(i2-1)]] \le [[y2]] < [[yb2(i2)]]$>>
    cir2dn = c2p%val(i1,i2,ic)
    <<Apply Jacobian for $y_1$ map>>
    <<Apply Jacobian for $y_2$ map>>
    <<Apply Jacobian for triangle map>>
  end function cir2dn

@  %def cir2dn
@
<<Public Procedures (C)>>=
double
circe2_distribution (circe2_channels *channels,
                     int p1, int h1, int p2, int h2,
                     double yy1, double yy2)
{
  circe2_channel *ch;
  int i, i1, i2;
  double y1, y2, d;
  POINTER_PANIC(circe2_random_channel, channels, "channels");
  ch = circe2_find_channel (channels, p1, h1, p2, h2);
  if (ch == NULL)
    return 0.0;
  <<$([[y1]],[[y2]])\leftarrow([[yy1]],[[yy2]])$ (C)>>
  if ((y1 < ch->d1->y[0]) || (y1 > ch->d1->y[ch->d1->n])
      || (y2 < ch->d2->y[0]) || (y2 > ch->d2->y[ch->d2->n]))
    return 0.0;
  i1 = binary_search (ch->d1->y, 0, ch->d1->n, y1);
  i2 = binary_search (ch->d2->y, 0, ch->d2->n, y2);
  d = ch->value[i1][i2];
  <<Apply Jacobian for $y_1$ map (C)>>
  <<Apply Jacobian for $y_2$ map (C)>>
  <<Apply Jacobian for triangle map (C)>>
  return d;
}
@ cf.~(\ref{eq:jacobian-Delta_x-Delta_y})
<<Apply Jacobian for $y_1$ map>>=
    if (c2p%map1(i1,ic) .eq. 0) then
    else if (c2p%map1(i1,ic) .eq. 1) then
       cir2dn = cir2dn * c2p%b1(i1,ic) / (c2p%a1(i1,ic)*c2p%alpha1(i1,ic)) &
            * (c2p%b1(i1,ic)*(y1-c2p%eta1(i1,ic)))**(1/c2p%alpha1(i1,ic)-1)
    else if (c2p%map1(i1,ic) .eq. 2) then
       cir2dn = cir2dn * c2p%b1(i1,ic)**2 &
            / ((y1-c2p%eta1(i1,ic))**2 + c2p%a1(i1,ic)**2)
    else
       write (*, '(A,I3)') &
            'circe2: internal error: invalid map: ', c2p%map1(i1,ic)
       stop
    end if
@ 
<<Apply Jacobian for $y_1$ map (C)>>=
switch (ch->d1->map[i1]) {
case 0:
  /* identity */
case 1:
  d = d * ch->d1->b[i1] / (ch->d1->a[i1] * ch->d1->alpha[i1])
        * pow (ch->d1->b[i1] * (y1 - ch->d1->eta[i1]), 1/ch->d1->alpha[i1] - 1);
case 2:
  d = d * ch->d1->b[i1] * ch->d1->b[i1]
        / ((y1 - ch->d1->eta[i1]) * (y1 - ch->d1->eta[i1])
   	     + ch->d1->a[i1] * ch->d1->a[i1]);
default:
  fprintf (stderr, "circe2: internal error: invalid map: %d\n", ch->d1->map[i1]);
  exit (-1);
}
@ 
<<Apply Jacobian for $y_2$ map>>=
    if (c2p%map2(i2,ic) .eq. 0) then
    else if (c2p%map2(i2,ic) .eq. 1) then
       cir2dn = cir2dn * c2p%b2(i2,ic) / (c2p%a2(i2,ic)*c2p%alpha2(i2,ic)) &
            * (c2p%b2(i2,ic)*(y2-c2p%eta2(i2,ic)))**(1/c2p%alpha2(i2,ic)-1)
    else if (c2p%map2(i2,ic) .eq. 2) then
       cir2dn = cir2dn * c2p%b2(i2,ic)**2 &
            / ((y2-c2p%eta2(i2,ic))**2 + c2p%a2(i2,ic)**2)
    else
       write (*, '(A,I3)') &
            'circe2: internal error: invalid map: ', c2p%map2(i2,ic)
       stop
    end if
@ 
<<Apply Jacobian for $y_2$ map (C)>>=
switch (ch->d2->map[i2]) {
case 0:
  /* identity */
case 1:
  d = d * ch->d2->b[i2] / (ch->d2->a[i2] * ch->d2->alpha[i2])
        * pow (ch->d2->b[i2] * (y2 - ch->d2->eta[i2]), 1/ch->d2->alpha[i2] - 1);
case 2:
  d = d * ch->d2->b[i2] * ch->d2->b[i2]
        / ((y2 - ch->d2->eta[i2]) * (y2 - ch->d2->eta[i2])
   	     + ch->d2->a[i2] * ch->d2->a[i2]);
default:
  fprintf (stderr, "circe2: internal error: invalid map: %d\n", ch->d2->map[i2]);
  exit (-1);
}
@ The triangle map
\begin{equation}
  \begin{aligned}
    \tau : \{(x_{1},x_{2}) \in [0,1]\times[0,1] : x_{2} \le x_{1} \}
                    &\to [0,1]\times[0,1] \\
      (x_{1},x_{2}) &\mapsto (y_{1},y_{2}) = (x_{1},x_{1}x_{2})
  \end{aligned}
\end{equation}
and its inverse
\begin{equation}
  \begin{aligned}
    \tau^{-1} : [0,1]\times[0,1]
       &\to \{(x_{1},x_{2}) \in [0,1]\times[0,1] : x_{2} \le x_{1} \} \\
      (y_{1},y_{2}) &\mapsto (x_{1},x_{2}) = (y_{1},y_{2}/y_{1})
  \end{aligned}
\end{equation}
<<$([[y1]],[[y2]])\leftarrow([[yy1]],[[yy2]])$>>=
      if (c2p%triang(ic)) then
         y1 = max (yy1, yy2)
         y2 = min (yy1, yy2) / y1
      else
         y1 = yy1
         y2 = yy2
      end if
@ 
<<$([[y1]],[[y2]])\leftarrow([[yy1]],[[yy2]])$ (C)>>=
if (ch->triangle) {
  y1 = max (yy1, yy2);
  y2 = min (yy1, yy2) / y1;
} else {
  y1 = yy1;
  y2 = yy2;
}
@ with the jacobian~$J^*(y_{1},y_{2})=1/y_{2}$ from
\begin{equation}
  \mathrm{d}x_{1}\wedge\mathrm{d}x_{2}
    = \frac{1}{y_{2}} \cdot \mathrm{d}y_{1}\wedge\mathrm{d}y_{2}
\end{equation}
<<Apply Jacobian for triangle map>>=
      if (c2p%triang(ic)) then
         cir2dn = cir2dn / y1
      end if
@ 
<<Apply Jacobian for triangle map (C)>>=
if (ch->triangle)
  d = d / y1;
@ We avoid name space polution and speed up things at the same time
by explicit inlining:
<<Do a binary search for $[[yb1(i1-1)]] \le [[y1]] < [[yb1(i1)]]$>>=
      ibot = 0
      itop = c2p%nb1(ic)
      do
        if (itop .le. (ibot + 1)) then
           i1 = ibot + 1
           exit
        else
           i1 = (ibot + itop) / 2
           if (y1 .lt. c2p%yb1(i1,ic)) then
              itop = i1
           else
              ibot = i1
           end if
        end if
      end do      
@
<<Do a binary search for $[[yb2(i2-1)]] \le [[y2]] < [[yb2(i2)]]$>>=
      ibot = 0
      itop = c2p%nb2(ic)
      do
        if (itop .le. (ibot + 1)) then
           i2 = ibot + 1
        else
           i2 = (ibot + itop) / 2
           if (y2 .lt. c2p%yb2(i2,ic)) then
              itop = i2
           else
              ibot = i2
           end if
        end if
      end do
@ 
<<Public procedures>>=
  public :: cir2dm
<<Procedures>>=
  subroutine cir2dm (p1, p2, x1, x2, pol)
    integer :: p1, p2
    real(kind=double) :: x1, x2
    real(kind=double) :: pol(0:3,0:3)
    <<Test support for density matrices>>
    print *, 'circe2: cir2dm not implemented yet!'
  end subroutine cir2dm

@  %def cir2dm
@ 
<<Test support for density matrices>>=
    if (c2p%polspt .ne. POLGEN) then
       write (*, '(2A)') 'circe2: current beam ', &
            'description supports no density matrices'
       return
    end if
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Reading Files}
<<Error codes for [[cir2ld]]>>=
    integer, parameter :: EOK = 0
    integer, parameter :: EFILE = -1
    integer, parameter :: EMATCH = -2
    integer, parameter :: EFORMT = -3
    integer, parameter :: ESIZE = -4
@ 
<<Well known constants (C)>>=
#define CIRCE2_EOK     0
#define CIRCE2_EFILE  -1
#define CIRCE2_EMATCH -2
#define CIRCE2_EFORMT -3
#define CIRCE2_ESIZE  -4
@ 
<<Public procedures>>=
  public :: cir2ld
<<Procedures>>=
  subroutine cir2ld (file, design, roots, ierror)
    character(len=*) :: file, design
    real(kind=double) :: roots
    integer :: ierror
    character(len=72) :: buffer
    character(len=72) :: fdesgn
    character(len=72) :: fpolsp
    real(kind=double) :: froots
    integer :: lun, loaded, prefix
    logical :: match
    <<Local variables in [[cir2ld]]>>
    <<Error codes for [[cir2ld]]>>
    <<Find free logical unit for [[lun]]>>
    loaded = 0
    <<Open [[name]] for reading on [[lun]]>>
    if (ierror .gt. 0) then
       write (*, '(2A)') 'cir2ld: $Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $'
    end if
    prefix = index (design, '*') - 1
100 continue
       <<Skip comments until [[CIRCE2]]>>
       if (buffer(8:15) .eq. 'FORMAT#1') then
          read (lun, *)
          read (lun, *) fdesgn, froots
          <<Check if [[design]] and [[fdesgn]] do [[match]]>>
          if (match .and. (abs (froots - roots) .le. 1d0)) then
             <<Load histograms>>
             loaded = loaded + 1
          else
             <<Skip data until [[ECRIC2]]>>
             goto 100
          end if
       else
          write (*, '(2A)') 'cir2ld: invalid format: ', buffer(8:72)
          ierror = EFORMT
          return
       end if
       <<Check for [[ECRIC2]]>>
       goto 100
  end subroutine cir2ld
  
@ 
<<Public Procedures (C)>>=
void
circe2_load (const char *file, const char *design, double roots, int *error)
{
  char buffer[73];
  char file_design[73];
  char file_polarization_support[73];
  double file_roots;
  int loaded;
  FILE *f;
  if (*error > 0)
    printf ("circe2: %s\n",
	    "$Id: circe2.nw,v 1.56 2002/10/14 10:12:06 ohl Exp $");
  loaded = 0;
  f = fopen (file, "r");
  if (f == NULL) {
    fprintf (stderr, "circe2_load: can't open %s: %s\n", file, sys_errlist[errno]);
    *error = CIRCE2_EFILE;
    return;
  }
  while (loaded == 0) {
    <<Skip comments until [[CIRCE2]] (C)>>
    if (strncmp ("FORMAT#1", buffer, 8) == 0) {
    }
    <<Check for [[ECRIC2]] (C)>>
  }
}
/*
      integer prefix
      logical match
      prefix = index (design, '*') - 1
 100  continue
         <<Skip comments until [[CIRCE2]]>>
         if (buffer(8:15) .eq. 'FORMAT#1') then
            read (lun, *)
            read (lun, *) fdesgn, froots
            <<Check if [[design]] and [[fdesgn]] do [[match]]>>
            if (match .and. (abs (froots - roots) .le. 1d0)) then
               <<Load histograms>>
               loaded = loaded + 1
            else
               <<Skip data until [[ECRIC2]]>>
               goto 100
            end if
         else
            write (*, '(2A)') 'cir2ld: invalid format: ', buffer(8:72)
            ierror = EFORMT
            return
         end if
         <<Check for [[ECRIC2]]>>
         goto 100
      end
*/
@ 
<<Check if [[design]] and [[fdesgn]] do [[match]]>>=
    match = .false.
    if (fdesgn .eq. design) then
       match = .true.
    else if (prefix .eq. 0) then
       match = .true.
    else if (prefix .gt. 0) then
       if (fdesgn(1:min(prefix,len(fdesgn))) &
            .eq. design(1:min(prefix,len(design)))) then
          match = .true.
       end if
    end if
@ 
<<Load histograms>>=
    read (lun, *) 
    read (lun, *) c2p%nc, fpolsp
    if (c2p%nc .gt. NCMAX) then
       write (*, '(A)') 'cir2ld: too many channels'
       ierror = ESIZE
       return
    end if
    <<Decode polarization support>>
    c2p%cwgt(0) = 0
    do ic = 1, c2p%nc
       <<Load channel [[ic]]>>
       <<Load division [[xb1]]>>
       <<Load division [[xb2]]>>
       <<Calculate [[yb1]]>>
       <<Calculate [[yb2]]>>
       <<Load weights [[wgt]] and [[val]]>>
    end do   
    do ic = 1, c2p%nc
       c2p%cwgt(ic) = c2p%cwgt(ic) / c2p%cwgt(c2p%nc)
    end do
@ 
<<Decode polarization support>>=
    if (      (fpolsp(1:1).eq.'a') &
         .or. (fpolsp(1:1).eq.'A')) then
       c2p%polspt = POLAVG
    else if (      (fpolsp(1:1).eq.'h') &
              .or. (fpolsp(1:1).eq.'H')) then
       c2p%polspt = POLHEL
    else if (      (fpolsp(1:1).eq.'d') &
              .or. (fpolsp(1:1).eq.'D')) then
       c2p%polspt = POLGEN
    else
       write (*, '(A,I5)') &
            'cir2ld: invalid polarization support: ', fpolsp
       ierror = EFORMT
       return
    end if
@ 
<<Local variables in [[cir2ld]]>>=
    integer :: i, ic
@ 
<<Load channel [[ic]]>>=
    read (lun, *)
    read (lun, *) c2p%pid1(ic), c2p%pol1(ic), &
          c2p%pid2(ic), c2p%pol2(ic), c2p%lumi(ic)
    c2p%cwgt(ic) = c2p%cwgt(ic-1) + c2p%lumi(ic)
    <<Check polarization support>>
@
<<Check polarization support>>=
    if (c2p%polspt .eq. POLAVG &
         .and. (      (c2p%pol1(ic) .ne. 0)  &
                 .or. (c2p%pol2(ic) .ne. 0))) then
       write (*, '(A)') 'cir2ld: expecting averaged polarization'
       ierror = EFORMT
       return
    else if (c2p%polspt .eq. POLHEL &
         .and. (      (c2p%pol1(ic) .eq. 0)       &
                 .or. (c2p%pol2(ic) .eq. 0))) then
       write (*, '(A)') 'cir2ld: expecting helicities'
       ierror = EFORMT
       return
    else if (c2p%polspt .eq. POLGEN) then
       write (*, '(A)') 'cir2ld: general polarizations not supported yet'
       ierror = EFORMT
       return
    else if (c2p%polspt .eq. POLGEN &
         .and. (      (c2p%pol1(ic) .ne. 0)       &
                 .or. (c2p%pol2(ic) .ne. 0))) then
       write (*, '(A)') 'cir2ld: expecting pol = 0'
       ierror = EFORMT
       return
    end if
@ 
<<Load channel [[ic]]>>=
    read (lun, *)
    read (lun, *) c2p%nb1(ic), c2p%nb2(ic), c2p%triang(ic)
    if ((c2p%nb1(ic) .gt. NBMAX) .or. (c2p%nb2(ic) .gt. NBMAX)) then
       write (*, '(A)') 'cir2ld: too many bins'
       ierror = ESIZE
       return
    end if
@ 
<<Load division [[xb1]]>>=
    read (lun, *)
    read (lun, *) c2p%xb1(0,ic)
    do i1 = 1, c2p%nb1(ic)
       read (lun, *) c2p%xb1(i1,ic), c2p%map1(i1,ic), c2p%alpha1(i1,ic), &
           c2p%xi1(i1,ic), c2p%eta1(i1,ic), c2p%a1(i1,ic), c2p%b1(i1,ic)
    end do
@ 
<<Load division [[xb2]]>>=
    read (lun, *)
    read (lun, *) c2p%xb2(0,ic)
    do i2 = 1, c2p%nb2(ic)
       read (lun, *) c2p%xb2(i2,ic), c2p%map2(i2,ic), c2p%alpha2(i2,ic), &
           c2p%xi2(i2,ic), c2p%eta2(i2,ic), c2p%a2(i2,ic), c2p%b2(i2,ic)
    end do
@ The boundaries are guaranteed to be fixed points of the maps
only if the boundaries are not allowed to float. This doesn't affect
the unweighted events, because they never see the codomain grid, but
distribution would be distorted significantly.   In the following sums
[[i1]] and [[i2]] run over the maps, while [[i]] runs over the
boundaries.
\begin{dubious}
  An alternative would be to introduce sentinels [[alpha1(0,:)]],
  [[xi1(0,:)]], etc.
\end{dubious}
<<Calculate [[yb1]]>>=
    do i = 0, c2p%nb1(ic)
       i1 = max (i, 1)
       if (c2p%map1(i1,ic) .eq. 0) then
          c2p%yb1(i,ic) = c2p%xb1(i,ic)
       else if (c2p%map1(i1,ic) .eq. 1) then
          c2p%yb1(i,ic) = &
               (c2p%a1(i1,ic) &
                 * (c2p%xb1(i,ic)-c2p%xi1(i1,ic)))**c2p%alpha1(i1,ic) &
                    / c2p%b1(i1,ic) + c2p%eta1(i1,ic)
       else if (c2p%map1(i1,ic) .eq. 2) then
          c2p%yb1(i,ic) = c2p%a1(i1,ic) &
               * tan(c2p%a1(i1,ic)/c2p%b1(i1,ic)**2 &
                      * (c2p%xb1(i,ic)-c2p%xi1(i1,ic))) &
                   + c2p%eta1(i1,ic)
       else
          write (*, '(A,I3)') 'cir2ld: invalid map: ', c2p%map1(i1,ic)
          ierror = EFORMT
          return
       end if
    end do
@ 
<<Calculate [[yb2]]>>=
    do i = 0, c2p%nb2(ic)
       i2 = max (i, 1)
       if (c2p%map2(i2,ic) .eq. 0) then
          c2p%yb2(i,ic) = c2p%xb2(i,ic)
       else if (c2p%map2(i2,ic) .eq. 1) then
          c2p%yb2(i,ic) &
               = (c2p%a2(i2,ic) &
                   * (c2p%xb2(i,ic)-c2p%xi2(i2,ic)))**c2p%alpha2(i2,ic) &
                      / c2p%b2(i2,ic) + c2p%eta2(i2,ic)
       else if (c2p%map2(i2,ic) .eq. 2) then
          c2p%yb2(i,ic) = c2p%a2(i2,ic) &
               * tan(c2p%a2(i2,ic)/c2p%b2(i2,ic)**2 &
                      * (c2p%xb2(i,ic)-c2p%xi2(i2,ic))) &
                   + c2p%eta2(i2,ic)
       else
          write (*, '(A,I3)') 'cir2ld: invalid map: ', c2p%map2(i2,ic)
          ierror = EFORMT
          return
       end if
    end do
@ cf.~(\ref{eq:jacobian-Delta_x-Delta_y})
<<Load weights [[wgt]] and [[val]]>>=
    read (lun, *)
    c2p%wgt(0,ic) = 0
    do i = 1, c2p%nb1(ic)*c2p%nb2(ic)
       read (lun, *) w
       c2p%wgt(i,ic) = c2p%wgt(i-1,ic) + w
       <<$([[i1]],[[i2]]) \leftarrow [[i]]$>>
       c2p%val(i1,i2,ic) = w & 
            / (  (c2p%xb1(i1,ic) - c2p%xb1(i1-1,ic)) &
               * (c2p%xb2(i2,ic) - c2p%xb2(i2-1,ic)))
    end do
    c2p%wgt(c2p%nb1(ic)*c2p%nb2(ic),ic) = 1
@ 
<<Local variables in [[cir2ld]]>>=
    integer :: i1, i2
    real(kind=double) :: w
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Auxiliary Code For Reading Files}
<<Open [[name]] for reading on [[lun]]>>=
      open (unit = lun, file = file, status = 'old', iostat = status)
      if (status .ne. 0) then
         write (*, '(2A)') 'cir2ld: can''t open ', file
         ierror = EFILE
         return
      end if
@ 
<<Local variables in [[cir2ld]]>>=
    integer :: status
@
<<Skip comments until [[CIRCE2]]>>=
 20   continue
         read (lun, '(A)', end = 29) buffer
         if (buffer(1:6) .eq. 'CIRCE2') then
            goto 21
         else if (buffer(1:1) .eq. '!') then
            if (ierror .gt. 0) then
               write (*, '(A)') buffer
            end if
            goto 20
         end if
         write (*, '(A)') 'cir2ld: invalid file'
         ierror = EFORMT
         return
 29   continue
      if (loaded .gt. 0) then           
         close (unit = lun)
         ierror = EOK
      else
         ierror = EMATCH
      end if
      return
 21   continue
@
<<Skip comments until [[CIRCE2]] (C)>>=
while (1) {
  fgets (buffer, 72, f);
  if (strncmp ("ECRIC2", buffer, 6) == 0) {
    fclose (f);
    if (loaded)
      *error = CIRCE2_EOK;
    else {
      fprintf (stderr, "circe2_load: no match in %s\n", file);
      *error = CIRCE2_EMATCH;
    }
    return;
  } else if ((buffer[0] == '!') && (*error > 0))
    printf ("circe2: %s\n", buffer);
}
fprintf (stderr, "circe2_load: invalid format %s\n", file);
*error = CIRCE2_EFORMT;
return;
@ 
<<Skip data until [[ECRIC2]]>>=
 101  continue
      read (lun, *) buffer
      if (buffer(1:6) .ne. 'ECRIC2') then
         goto 101
      end if
@ 
<<Skip data until [[ECRIC2]] (C)>>=
while (1) {
  fgets (buffer, 72, f);
  if (strncmp ("ECRIC2", buffer, 6) == 0)
    break;
}
@ 
<<Check for [[ECRIC2]]>>=
      read (lun, '(A)') buffer
      if (buffer(1:6) .ne. 'ECRIC2') then
         write (*, '(A)') 'cir2ld: invalid file'
         ierror = EFORMT
         return
      end if
@ 
<<Check for [[ECRIC2]] (C)>>=
fgets (buffer, 72, f);
if (strncmp ("ECRIC2", buffer, 6) != 0) {
  fprintf (stderr, "circe2_load: invalid format %s\n", file);
  *error = CIRCE2_EFORMT;
  return;
}
@ 
<<Find free logical unit for [[lun]]>>=
    do lun = 10, 99
       inquire (unit = lun, exist = exists, &
               opened = isopen, iostat = status)
       if ((status .eq. 0) .and. exists .and. .not.isopen) then
         goto 11
       end if
    end do
    write (*, '(A)') 'cir2ld: no free unit'
    ierror = ESIZE
    stop
11 continue
@ 
<<Local variables in [[cir2ld]]>>=
    logical :: exists, isopen
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Tests and Examples}
<<[[circe2_sample.f90]]>>=
! circe2_sample.f90 -- testing circe2
<<Copyleft notice>>
  module circe2_sample_routines
    use kinds
    use circe2
    use tao_rng

    implicit none
    private

<<Sample procedures: public>>
<<[[write3_ascii]]: public>>

contains

<<Sample procedures>>
<<[[write3_ascii]]>>

  end module circe2_sample_routines  

  program circe2_sample
    use kinds
    use circe2
    use circe2_sample_routines
    
<<[[implicit none]]>>

    integer :: i, p1, h1, p2, h2, n, ierror
    character(len=256) :: file, design, mode
    real(kind=double) :: roots, x1, x2, w
    read *, file, design, roots, p1, h1, p2, h2, mode, n
    ierror = 0
    call cir2ld (file, design, roots, ierror)
    if (ierror .ne. 0) then
       print *, 'sample: cir2ld failed!'
       stop
    end if
    if ((mode(1:1) .eq. 'w') .or. (mode(1:1) .eq. 'W')) then
       <<Generate [[n]] weighted events>>
    else
       <<Generate [[n]] unweighted events>>
    end if
  end program circe2_sample

@ %def circe2_sample
<<[[circe2_sample_binary.f90]]>>=
! circe2_sample_binary.f90 -- testing circe2
<<Copyleft notice>>
  module circe2_sample_routines_binary
    use kinds
    use circe2
    use tao_rng

    implicit none
    private

<<Sample procedures: public>>

contains

<<Sample procedures>>

  end module circe2_sample_routines_binary  

  program circe2_sample_binary
    use kinds
    use circe2
    use circe2_sample_routines_binary
    
<<[[implicit none]]>>

    integer :: i, p1, h1, p2, h2, n, ierror
    character(len=256) :: file, design, mode
    real(kind=double) :: roots, x1, x2, w
    read *, file, design, roots, p1, h1, p2, h2, mode, n
    ierror = 0
    call cir2ld (file, design, roots, ierror)
    if (ierror .ne. 0) then
       print *, 'sample: cir2ld failed!'
       stop
    end if
    if ((mode(1:1) .eq. 'w') .or. (mode(1:1) .eq. 'W')) then
       <<Generate [[n]] weighted events>>
    else
       <<Generate [[n]] unweighted events>>
    end if
  end program circe2_sample_binary

@ %def circe2_sample_binary
@ Generation of unweighted events is \Kirke/'s home turf
<<Generate [[n]] unweighted events>>=
    do i = 1, n    
       call cir2gn (p1, h1, p2, h2, x1, x2, random)
       call write3 (x1, x2, 1d0)
    end do
@ while generation of weighted events without any importance sampling
is slightly abusive and only useful for checking [[cir2dn]].
<<Generate [[n]] weighted events>>=
    do i = 1, n
       call random (x1)
       call random (x2)
       w = cir2dn (p1, h1, p2, h2, x1, x2)
       call write3 (x1, x2, w)
    end do
@ We could have written [[print *, x, y, w]] immediately, but the
seperate [[write3]] allows us to create ASCII and binary versions.
<<[[write3_ascii]]: public>>=
    public :: write3
<<[[write3_ascii]]>>=
  subroutine write3 (x, y, w)
    real(kind=double), intent(in) :: x, y, w
    print *, x, y, w
  end subroutine write3
@ This is not necessarily portable, but the only way to reliably write
binary files without \emph{any} markers uses C.  Binary I/O is useful
because---on my laptop---event generation takes about 10\,\%{} of the
time used by formatted writing of three floating point numbers.
<<[[write3_binary.c]]>>=
#include <stdio.h>
void write3_ (double *x, double *y, double *w) 
{
  double buf[3]; buf[0] = *x; buf[1] = *y; buf[2] = *w;
  if (fwrite (buf, sizeof (double), 3, stdout) != 3) {
    fprintf (stdin, "write3: fwrite failed!\n");
    exit (1);
  }
}
@ The following bare bones random number generator produces
some correlations that have been observed in testing \KirkeTwo/
<<Unused sample procedures>>=
  subroutine random (r)
    real(kind=double) :: r
    integer, parameter :: M = 259200, A = 7141, C = 54773
    integer, save :: n = 0
    n = mod (n*A + C, M)
    r = real (n, kind=double) / real (M, kind=double)
  end subroutine random

@ therfore, it makes sense to call a more sophisticated one:
<<Sample procedures: public>>=
    public :: random
<<Sample procedures>>=
  subroutine random (u)
    real(kind=double), intent(out) :: u
    call taornu (u)
  end subroutine random

@ %def random
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Listing File Contents}
Here's a small utility program for listing the contents of \KirkeTwo/
data files.  It performs \emph{no} verification and assumes that the
file is in the correct format (cf.~table~\ref{tab:fileformat}).
<<[[circe2ls.f90]]>>=
! circe2ls.f90 -- beam spectra for linear colliders and photon colliders
<<Copyleft notice>>
  program circe2ls
    use kinds

    <<[[implicit none]]>>

    integer :: lun
    character(len=72) :: buffer
    character(len=72) :: file
    character(len=60) :: design, polspt
    integer :: pid1, hel1, pid2, hel2, nc
    real(kind=double) :: roots, lumi
    integer :: status
    logical :: exists, isopen
    integer :: ierror
    <<Error codes for [[cir2ld]]>>
    <<Find free logical unit for [[lun]]>>
    write (*, '(A)') 'enter name of Circe2 data file:'
    read (*, '(A)') buffer
    file = buffer
    open (unit = lun, file = file, status = 'old', iostat = status)
    if (status .ne. 0) then
       write (*, '(2A)') 'circe2: can''t open ', file
       stop
    end if
    write (*, '(A,1X,A)') 'file:', file
30   continue
    read (lun, '(A)', end = 39) buffer
    if (buffer(1:7) .eq. 'design,') then
       read (lun, *) design, roots
       read (lun, *)
       read (lun, *) nc, polspt
       <<Write design/beam data>>
       <<Write channel header>>
    else if (buffer(1:5) .eq. 'pid1,') then
       read (lun, *) pid1, hel1, pid2, hel2, lumi
       <<Write channel data>>
    end if
    goto 30
39   continue
  end program circe2ls

@ 
<<Write design/beam data>>=
      write (*, '(2A)')     '        design: ', design
      write (*, '(A,F7.1)') '       sqrt(s): ', roots
      write (*, '(A,I3)')   '     #channels: ', nc
      write (*, '(2A)')     '  polarization: ', polspt
@ 
<<Write channel header>>=
      write (*, '(4X,4(A5,2X),A)') &
       'pid#1', 'hel#1', 'pid#2', 'hel#2', &
       'luminosity / (10^32cm^-2sec^-1)'
@ 
<<Write channel data>>=
      write (*, '(4X,4(I5,2X),F10.2,1X)') pid1, hel1, pid2, hel2, lumi
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Static Data Sets}
For those that despise reading files and prefer big ugly [[block data]]s:
<<[[circe2d.f90]]>>=
! circe2d.f90 -- beam spectra for linear colliders and photon colliders
<<Copyleft notice>>

<<[[subroutine cir2lb]]>>

<<[[block data cir2bd]] template>>

@
<<[[subroutine cir2lb]]>>=
  subroutine cir2lb (design, roots, ierror)
   <<[[implicit none]]>>
    integer, parameter :: single = &
      & selected_real_kind (precision(1.), range(1.))
    integer, parameter :: double = &
      & selected_real_kind (precision(1._single) + 1, range(1._single) + 1)    
    character(len=*), intent(in) :: design
    real(kind=double) :: roots
    integer :: ierror
    <<[[parameter]] declarations>>
    <<[[/cir2cd/]]>>
    external cir2bd
    integer :: ib, ic, i1, i2
    integer :: loaded
    loaded = 0
    do ib = 1, bdnb
       if (design .eq. bddsgn(ib)) then
          print *, 'circe2: CIR2LB not available yet!'
          loaded = loaded + 1
       end if
    end do
    if (loaded .gt. 0) then           
       ierror = 0
    else
       write (*, '(A)') 'circe2: no matching design'
       ierror = -1
    end if
  end subroutine cir2lb

@ %def cir2lb
@
<<[[/cir2cd/]]>>=
      <<8-byte aligned part of [[/cir2cd/]]>>
      <<4-byte aligned part of [[/cir2cd/]]>>
      <<1-byte aligned part of [[/cir2cd/]]>>
<<Separator>>
@ Three designs with two energies each would be [[NBMAX = 6]], but
let's be reasonable here while we're playing:
<<[[parameter]] declarations>>=
    integer, parameter :: NBMMAX = 1
@ The actual number of parametersets:
<<4-byte aligned part of [[/cir2cd/]]>>=
    integer :: bdnb
    common /cir2cd/ bdnb
@
<<1-byte aligned part of [[/cir2cd/]]>>=
    character(len=6), dimension(NBMMAX) :: bddsgn
    common /cir2cd/ bddsgn
@
<<8-byte aligned part of [[/cir2cd/]]>>=
    real(kind=double), dimension(0:NBMAX*NBMAX,NCMAX,NBMMAX) :: bdwgt
    common /cir2cd/ bdwgt
    real(kind=double), dimension(NBMAX,NBMAX,NCMAX,NBMMAX) :: bdval
    common /cir2cd/ bdval
    real(kind=double), dimension(0:NBMAX,NCMAX,NBMMAX) :: bdxb1
    real(kind=double), dimension(0:NBMAX,NCMAX,NBMMAX) :: bdxb2
    common /cir2cd/ bdxb1, bdxb2
    real(kind=double), dimension(NCMAX,NBMMAX) :: bdlumi
    common /cir2cd/ bdlumi
    real(kind=double), dimension(0:NCMAX,NBMMAX) :: bdcwgt
    common /cir2cd/ bdcwgt
    real(kind=double), dimension(0:NBMAX,NCMAX,NBMMAX) :: bdyb1
    real(kind=double), dimension(0:NBMAX,NCMAX,NBMMAX) ::  bdyb2
    common /cir2cd/ bdyb1, bdyb2
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdalf1
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdalf2
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdxi1
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdxi2
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdeta1
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdeta2
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bda1
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bda2
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdb1
    real(kind=double), dimension(NBMAX,NCMAX,NBMMAX) :: bdb2
    common /cir2cd/ bdalf1, bdxi1, bdeta1, bda1, bdb1
    common /cir2cd/ bdalf2, bdxi2, bdeta2, bda2, bdb2
@
<<4-byte aligned part of [[/cir2cd/]]>>=
    integer, dimension(NCMAX,NBMMAX) :: bdnb1, bdnb2
    common /cir2cd/ bdnb1, bdnb2
    logical, dimension(NCMAX,NBMMAX) :: bdtria
    common /cir2cd/ bdtria
    integer, dimension(NBMMAX) :: bdnc
    common /cir2cd/ bdnc
    integer, dimension(NCMAX,NBMMAX) :: bdpid1, bdpid2
    integer, dimension(NCMAX,NBMMAX) :: bdpol1, bdpol2
    common /cir2cd/ bdpid1, bdpol1, bdpid2, bdpol2
    integer, dimension(NBMAX,NCMAX,NBMMAX) :: bdmap1, bdmap2
    common /cir2cd/ bdmap1, bdmap2
@ In real life, this will be written by [[circe2_tool]]:
<<[[block data cir2bd]] template>>=
    block data cir2bd
      <<[[implicit none]]>>
      integer, parameter :: single = &
        & selected_real_kind (precision(1.), range(1.))
      integer, parameter :: double = &
        & selected_real_kind (precision(1._single) + 1, range(1._single) + 1)    
      <<[[/cir2cm/]]>>
      <<[[/cir2cd/]]>>
      data bdnb /0/
      data bddsgn(1) /'TESLA '/
    end block data cir2bd
<<[[/cir2cm/]]>>=
      <<[[parameter]] part of [[/cir2cm/]]>>
      <<8-byte aligned part of circe2 parameters>>
      common /cir2cm/ wgt
      common /cir2cm/ val
      common /cir2cm/ xb1, xb2
      common /cir2cm/ lumi
      common /cir2cm/ cwgt
      common /cir2cm/ yb1, yb2
      common /cir2cm/ alpha1, xi1, eta1, a1, b1
      common /cir2cm/ alpha2, xi2, eta2, a2, b2
      <<4-byte aligned part of circe2 parameters>>
      common /cir2cm/ nb1, nb2
      common /cir2cm/ triang
      common /cir2cm/ nc
      common /cir2cm/ pid1, pol1, pid2, pol2
      common /cir2cm/ map1, map2
      common /cir2cm/ polspt
      save /cir2cm/
@
<<[[parameter]] part of [[/cir2cm/]]>>=
      integer, parameter :: NBMAX = 100, NCMAX = 36
      integer, parameter :: NBMMAX = 1
      integer, parameter :: POLAVG = 1, POLHEL = 2, POLGEN = 3
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Local Variables:
% mode:noweb
% noweb-doc-mode:latex-mode
% noweb-code-mode:c-mode
% indent-tabs-mode:nil
% page-delimiter:"^@ %%%.*\n"
% End:
