% $Id: postlude.nw,v 1.24 2001/10/30 11:47:54 ohl Exp $
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{Making Grids}
\label{sec:make_circe2}
\input{float.interface}
\input{float.implementation}
\input{diffmap.interface}
\input{diffmap.implementation}
\input{diffmaps.interface}
\input{diffmaps.implementation}
\input{division.interface}
\input{division.implementation}
\input{grid.interface}
\input{grid.implementation}
\input{events.interface}
\input{events.implementation}
\input{commands.interface}
\input{commands.implementation}
\input{histogram.interface}
\input{histogram.implementation}
\input{circe2_tool.implementation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection*{Identifiers}                                      %!MANUAL%
\nowebindex                                                    %!MANUAL%
\subsection*{Refinements}                                      %!MANUAL%
\nowebchunks                                                   %!MANUAL%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%!MANUAL%
\begin{raggedright}                                            %!MANUAL%
  \input{index.tex}                                            %!MANUAL%
\end{raggedright}                                              %!MANUAL%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%!MANUAL%
\section{\texttt{taorng}:
  The Portable Random Number Generator from
  The Art of Computer Programming}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User's Manual}
The second editions of volume two of Donald E.~Knuth' \textit{The Art
of Computer Programming}~\cite{Knu97} had always been celebrated as a
prime reference for random number generation. In 1996, Don
Knuth made his notes for future editions available on the internet
in the form of errata, which have in the meantime have
been incorporated in the third edition.\par
These notes contain a gem of a \emph{portable} random number
generator.  It generates 30-bit integers with the following desirable
properties
\begin{itemize}
  \item they pass all the tests from George Marsaglia's ``diehard''
    suite of tests for random number generators~\cite{Mar96}.
  \item they can be generated with portable signed 32-bit arithmetic
    (Fortran can't do unsigned arithmetic)
  \item it is faster than other lagged Fibonacci generators
  \item it can create at least $2^{30}-2$ independent sequences
\end{itemize}
@ Functions returning single reals and integers:
<<API documentation>>=
      double precision u
      integer i
      call taornu (u)
      call taorni (i)
@ Subroutines filling arrays of reals and integers:
<<API documentation>>=
      integer i(n), n
      integer u(n)
      subroutine taornv (i, n)
      subroutine taornj (u, n)
@ Subroutine for changing the seed:
<<API documentation>>=
      integer seed
      subroutine taorns (seed)
@ Subroutine for changing the luxury:
<<API documentation>>=
      integer luxury
      subroutine taornl (luxury)
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Implementation}
<<[[taorng.f90]]>>=
! $Id: postlude.nw,v 1.24 2001/10/30 11:47:54 ohl Exp $
!   Copyright (C) 1996-2011 by 
!       Wolfgang Kilian <kilian@physik.uni-siegen.de>
!       Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
!       Juergen Reuter <juergen.reuter@desy.de>
!       Christian Speckner <cnspeckn@googlemail.com>
!
!   Taorng is free software; you can redistribute it and/or modify it
!   under the terms of the GNU General Public License as published by
!   the Free Software Foundation; either version 2, or (at your option)
!   any later version.
!
!   Taorng is distributed in the hope that it will be useful, but
!   WITHOUT ANY WARRANTY; without even the implied warranty of
!   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!   GNU General Public License for more details.
!
!   You should have received a copy of the GNU General Public License
!   along with this program; if not, write to the Free Software
!   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
module tao_rng
  use kinds

  implicit none     
  private

<<[[taorng.f90]]: public>>  

contains

<<[[taorng.f90]]: subroutines>>
end module tao_rng
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{High Level Routines}
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Single Random Numbers}
@ A modulus of $2^{30}$ is the largest we can handle in \emph{portable}
(i.e.~\emph{signed}) 32-bit arithmetic
<<Modulus [[M]]>>=
    integer , parameter :: M = 2**30
@ %def M
@ A random integer $r$ with $0 \le r < 2^{30} = 1073741824$:
<<[[taorng.f90]]: public>>=
  public :: taorni
<<[[taorng.f90]]: subroutines>>=
  subroutine taorni (r)
    integer :: r
    <<Buffer>>
    <<Check magic number>>
    <<Step [[i]] and reload [[a]] iff necessary>>
    r = a(i) 
  end subroutine taorni

@ %def taorni
@ The low level routine [[taorng]] will fill an array
$a_1,\ldots,a_N$, which will be consumed and refilled like an input
buffer.  We need at least $N \ge K = 100$ for the call to [[taorng]].
Higher values don't change the results, but make [[taorng]] more
efficient (about a factor of two, asymptotically).  DEK recommends
$N \ge 1000$. 
<<Buffer>>=
    integer, parameter :: NN = 1000
    integer, dimension(NN), save :: a(NN)
    integer :: i, n
    !!! common /taornb/ a, i, n
    !!! save /taornb/
@ %def NN /taornb/
@ Increment the index [[i]] and reload the array [[a]], iff this
buffer is exhausted.  Throughout these routines, [[i]] will point to
random number that has just been consumed.  For the array filling
routines below, this is simpler than pointing to the next waiting
number. 
<<Step [[i]] and reload [[a]] iff necessary>>=
    i = i + 1
    if (i .gt. n) then
       call taorng (a, NN)
       i = 1
    end if
@ We add an integer to the common block which we can check for
initialization by filling it with an unlikely ``magic'' number.
<<Buffer>>=
    <<Magic number [[MAGIC0]]>>
    integer :: magic
    !!! common /taornb/ magic
@ Iff the magic number is not found, trigger a buffer refill.
<<Check magic number>>=
    if (magic .ne. MAGIC0) then
       n = NN
       i = n
       magic = MAGIC0
    end if
@ Incidentally, the magic number is the date on which DEK wrote down
the routines discussed below.
<<Magic number [[MAGIC0]]>>=
      integer MAGIC0
      parameter (MAGIC0 = 19950826)
@ %def MAGIC0
@ A random real $r \in [0,1)$.  This is almost identical to
[[taorni]], but we duplicate the code to avoid the function call
overhead for speed. 
<<[[taorng.f90]]: public>>=
  public :: taornu
<<[[taorng.f90]]: subroutines>>=
  subroutine taornu (r)
    real(kind=double) :: r
    <<Modulus [[M]]>>
    real(kind=double), parameter :: INVM = 1D0/M
    <<Buffer>>
    <<Check magic number>>
    <<Step [[i]] and reload [[a]] iff necessary>>
    r = INVM * a(i) 
  end subroutine taornu

@ %def taornu
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Arrays of Random Numbers}
Fill the array $v_1,\ldots,v_\nu$ with uniform deviates $v_i \in
[0,1)$.  This has to be done such that the underlying array length in
[[taorng]] is transparent to the user.  At the same time we want to
avoid the overhead of calling [[taornu]] $\nu$ times.
<<[[taorng.f90]]: public>>=
  public :: taornv                 
<<[[taorng.f90]]: subroutines>>=
  subroutine taornv (v, nu)
    real(kind=double), dimension(:) :: v
    integer :: nu
    <<Modulus [[M]]>>
    real(kind=double), parameter :: INVM = 1D0/M
    integer :: done, todo, chunk, k
    <<Buffer>>
    <<Check magic number>>
    <<Prepare array [[a]] and [[done]], [[todo]], [[chunk]]>>
    <<Get first [[chunk]] of reals>>
    do
      <<Update [[i]], [[done]] and [[todo]] and set new [[chunk]]>>
      if (chunk .le. 0) then
         exit
      else
         <<Get another [[chunk]] of reals>>
      end if
    end do
  end subroutine taornv

@ %def taornv
@ [[i]] is used as an offset into the buffer [[a]], as usual.  [[done]]
is an offset into the target.  We still have to process all [[nu]]
numbers.  The first chunk can only use what's left in the buffer.
<<Prepare array [[a]] and [[done]], [[todo]], [[chunk]]>>=
    if (i .ge. n) then
       call taorng (a, NN)
       i = 0
    endif
    done = 0
    todo = nu
    chunk = min (todo, n - i)
@
<<Get first [[chunk]] of reals>>=
    do k = 1, chunk
       v(k) = INVM * a(i+k)
    end do
@ This logic is a bit weird, but after the first chunk, [[todo]] will
either vanish (in which case we're done) or we have consumed all of
the buffer and must reload.  In any case we can pretend that the next
chunk can use the whole buffer.
<<Update [[i]], [[done]] and [[todo]] and set new [[chunk]]>>=
      i = i + chunk
      done = done + chunk
      todo = todo - chunk
      chunk = min (todo, n)
@ As just mentioned, when we get here, we have to reload.
<<Get another [[chunk]] of reals>>=
      call taorng (a, NN)
      i = 0
      do k = 1, chunk
         v(done+k) = INVM * a(k)
      end do
@ Fill the array $j_1,\ldots,j_\nu$ with random integers
$0 \le j_i < 2^{30} = 1073741824$.  Again, this has to be done such
that the underlying array length in [[taorng]] is transparent to the
user and we want to avoid the overhead of calling [[taorni]] $\nu$
times.
<<[[taorng.f90]]: public>>=
  public :: taornj
<<[[taorng.f90]]: subroutines>>=
  subroutine taornj (j, nu)
    integer, dimension(:) :: j
    integer :: nu
    integer :: done, todo, chunk, k
    <<Buffer>>
    <<Check magic number>>
    <<Prepare array [[a]] and [[done]], [[todo]], [[chunk]]>>
    <<Get first [[chunk]] of integers>>
    do 
      <<Update [[i]], [[done]] and [[todo]] and set new [[chunk]]>>
      if (chunk .le. 0) then
         exit
      else
         <<Get another [[chunk]] of integers>>
      end if
    end do
  end subroutine taornj

@ %def taornj
@
<<Get first [[chunk]] of integers>>=
      do k = 1, chunk
         j(k) = a(i+k)
      end do
@
<<Get another [[chunk]] of integers>>=
      call taorng (a, NN)
      i = 0
      do k = 1, chunk
         j(done+k) = a(k)
      end do
@
<<[[taorng.f90]]: public>>=
  public :: taornl
<<[[taorng.f90]]: subroutines>>=
  subroutine taornl (luxury)
    integer :: luxury
    <<Buffer>>
    <<Check magic number>>
    <<Set [[n]] from [[luxury]]>>
  end subroutine taornl
    
@ %def taornl
@
<<Set [[n]] from [[luxury]]>>=
    if (luxury .gt. NN) then
       print *, 'taornl: luxury ', luxury, ' too high!'
       print *, 'taornl: will use 1 random number out of ', NN, '!'
       n = 1
    else if (luxury .lt. 1) then
       print *, 'taornl: luxury ', luxury, ' invalid!'
       print *, 'taornl: will use every random number!'
       n = NN
    else
       n = NN / luxury
    end if
    i = min (i, n)
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{30-Bit Low Level Routines}
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Generation}
\begin{equation}
\label{eq:recursion}
  X_j = (X_{j-100} - X_{j-37}) \mod 2^{30}
\end{equation}
<<Lags [[K]], [[L]]>>=
      integer, parameter :: K = 100, L = 37
@ %def K L
@ Fill the array $a_1,\ldots,a_n$ with random integers $0 \le a_i < 2^{30}$.
As mentioned above, we \emph{must} have $n \ge K$, while higher values
don't change the results and make thing more efficient.  Since users
are not expected to call [[taorng]] directly, we do \emph{not} check
for $n \ge K$ and assume that the caller knows what (s)he's doing \ldots
<<[[taorng.f90]]: public>>=
  public :: taorng
<<[[taorng.f90]]: subroutines>>=
  subroutine taorng (a, n)
    integer :: n
    integer, dimension(n) :: a
    <<Lags [[K]], [[L]]>>
    <<Modulus [[M]]>>
    <<State>>
    integer :: j
    <<Load [[a]] and refresh [[ranx]]>>
  end subroutine taorng

@ %def taorng
@ First make sure that [[taorns]] has been called to initialize the
generator state:
<<Load [[a]] and refresh [[ranx]]>>=
    if (magic .ne. MAGIC0) call taorns (0)
@
<<State>>=
      <<Magic number [[MAGIC0]]>>
      integer ranx(K), magic
      common /taornc/ ranx, magic
      save /taornc/
@ %def /taornc/
@ [[ranx(1:K)]] is already set up properly:
<<Load [[a]] and refresh [[ranx]]>>=
      do 10 j = 1, K
         a(j) = ranx(j)
 10   continue
@ The remaining $n-K$ random numbers can be gotten directly from the
recursion~(\ref{eq:recursion}):
<<Load [[a]] and refresh [[ranx]]>>=
      do 11 j = K+1, n
         a(j) = a(j-K) - a(j-L)
         if (a(j) .lt. 0) a(j) = a(j) + M
 11   continue
@ Do the recursion~(\ref{eq:recursion}) $K$ more times to prepare
[[ranx(1:K)]] for the next invokation of [[taorng]].
<<Load [[a]] and refresh [[ranx]]>>=
      do 20 j = 1, L
         ranx(j) = a(n+j-K) - a(n+j-L)
         if (ranx(j) .lt. 0) ranx(j) = ranx(j) + M
 20   continue
      do 21 j = L+1, K
         ranx(j) = a(n+j-K) - ranx(j-L)
         if (ranx(j) .lt. 0) ranx(j) = ranx(j) + M
 21   continue
@ In the future, we will be able to save four of of the above 15
lines, by using Fortran90's array assignments.  While the terse syntax
might be a matter of taste, it is certainly useful for suggesting
aggressive optimizations to the compiler.   The two other loops
implement the lagged Fibonacci and \emph{can not} be replaced by array
asignments because the assignments overlap.
<<Load [[a]] and refresh [[ranx]] (Fortran90)>>=
  a(1:K) = ranx(1:K)
  do j = K+1, n
    a(j) = a(j-K) - a(j-L)
    if (a(j) < 0) a(j) = a(j) + M
  end do
  ranx(1:L) = a(n+1-K:n+L-K) - a(n+1-L:n)
  where (ranx(1:L) < 0) ranx(1:L) = ranx(1:L) + M
  do j = L+1, K
    ranx(j) = a(n+j-K) - ranx(j-L)
    if (ranx(j) < 0) ranx(j) = ranx(j) + M
  end do
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Initialization}
The non-trivial and most beautiful part is the algorithm to initialize
the random number generator state [[ranx]] with the first 100 numbers.
I haven't studied algebra over finite fields in sufficient depth to
consider the mathematics behind it straightforward.  The commentary
below is rather verbose and reflects my understanding of DEK's rather
terse remarks (solution to exercise~3.6-8~\cite{Knu97}).
<<[[taorng.f90]]: public>>=
  public :: taorns
<<[[taorng.f90]]: subroutines>>=
  subroutine taorns (seedin)
    integer, intent(in) :: seedin
    integer :: seed
    <<Lags [[K]], [[L]]>>
    <<Modulus [[M]]>>
    <<Other parameters>>
    <<State>>
    <<Local variables>>
    <<Verify [[seed]]>>
    <<Bootstrap the [[x]] buffer>>
    <<Set up [[s]] and [[t]]>>
    do
         <<$p(z)\to p(z)^2 \modpoly$>>
         <<$p(z)\to zp(z) \modpoly$>>
         <<Shift [[s]] or [[t]]>>
        if (t .le. 0) exit
    end do 
    <<Fill [[ranx]] from [[x]]>>
    magic = MAGIC0
  end subroutine taorns

@ %def taorns
@
<<Other parameters>>=
    integer, parameter :: SEEDMX = 2**30 - 3
@ %def SEEDMX
@
<<Verify [[seed]]>>=
    seed = seedin
    if ((seed .lt. 0) .or. (seed .gt. SEEDMX)) then
       print *, 'taorns: seed (', seed, ') not in [0,', SEEDMX, ']!'
       seed = mod (abs (seed), SEEDMX+1)
       print *, 'taorns: seed set to ', seed, '!'
    end if
@
<<Other parameters>>=
    integer, parameter :: TT= 70, KK = K+K-1
@ %def TT KK
@
<<Local variables>>=
    integer x(KK), j, s, t
@ Fill the array $x_1,\ldots,x_{K=100}$ with even integers, shifted
cyclically by 29 bits.
<<Bootstrap the [[x]] buffer>>=
    s = seed - mod (seed, 2) + 2
    do j = 1, K
       x(j) = s
       s = s + s
       if (s .ge. M) s = s - M + 2
    end do
    do j = K+1, KK
       x(j) = 0
    end do
@ Make $x_2$ (and only $x_2$) odd:
<<Bootstrap the [[x]] buffer>>=
    x(2) = x(2) + 1
@
<<Set up [[s]] and [[t]]>>=
    s = seed
    t = TT - 1
@ Consider the polynomial
\begin{equation}
  p(z) = \sum_{n=1}^K x_n z^{n-1} = x_{100}z^{99} + \ldots + x_2 z + x_1
\end{equation}
We have $p(z)^2 = p(z^2) \mod 2$ because cross terms have an even
coefficient and $x_n^2 = x_n \mod 2$.  Therefore we can square the
polynomial by shifting the coefficients.  The coefficients for $n>K$
will be reduced $\mod 2$ below.
<<$p(z)\to p(z)^2 \modpoly$>>=
      do j = K, 2, -1
         x(j+j-1) = x(j)
      end do
@ The coefficients of the odd powers (those with the even indices)
have not been changed yet.  Set them to a flipped version
\begin{equation}
\begin{aligned}
   x_2 	     	 & \leftarrow & \text{ even } x_{2K-1=199} \\
   x_4 	     	 & \leftarrow & \text{ even } x_{2K-3=197} \\
       	     	 & \ldots     &                            \\
   x_{K+L-1=136} & \leftarrow & \text{ even } x_{K-L+2=65}
\end{aligned}
\end{equation}
of the other coefficients with the least significant bit set to 0.
\begin{dubious}
  DEK's notes contain an (insignificant) typo here
  [[do 21 j = KK, K-L+1, -2]], because [[K]] is even and [[L]] is
  odd.  (If it is on purpose to accomodate simultaneously odd lags,
  then the C version is wrong.)
\end{dubious}
<<$p(z)\to p(z)^2 \modpoly$>>=
      do j = KK, K-L+2, -2
         x(KK-j+2) = x(j) - mod (x(j), 2)
      end do
@ Let's return to the coefficients for $n>K$ generated by the shifting
above.  Subtract $z^n(z^{100} + z^{37} + 1)$ iff the coefficient of
$z^nz^{100}$ doesn't vanish $\mod 2$ after squaring.  The coefficient
of $z^nz^{100}$ is left alone, because it doesn't belong to $p(z)$
anyway.
<<$p(z)\to p(z)^2 \modpoly$>>=
      do j = KK, K+1, -1
         if (mod (x(j), 2) .eq. 1) then
            x(j-(K-L)) = x(j-(K-L)) - x(j)
            if (x(j-(K-L)) .lt. 0) x(j-(K-L)) = x(j-(K-L)) + M
            x(j-K) = x(j-K) - x(j)
            if (x(j-K) .lt. 0) x(j-K) = x(j-K) + M
         end if
      end do
@
<<$p(z)\to zp(z) \modpoly$>>=
      if (mod (s, 2) .eq. 1) then
         do j = K, 1, -1
            x(j+1) = x(j)
         end do
         x(1) = x(K+1)
         if (mod (x(K+1), 2) .eq. 1) then
            x(L+1) = x(L+1) - x(K+1)
            if (x(L+1) .lt. 0) x(L+1) = x(L+1) + M
         end if
      end if
@
<<Shift [[s]] or [[t]]>>=
      if (s .ne. 0) then
         s = s / 2
      else
         t = t - 1
      end if
@
<<Fill [[ranx]] from [[x]]>>=
      do j = 1, L
         ranx(j+K-L) = x(j)
      end do
      do j = L+1, K
         ranx(j-L) = x(j)
      end do
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Testing}
<<[[taorng.f90]]: public>>=
  public :: taornt
<<[[taorng.f90]]: subroutines>>=
  subroutine taornt ()
    implicit none
    <<Buffer>>
    integer :: j, r
    integer, dimension(10), save :: expect = &
      (/ 640345214,  443605255,  411993687, 618952382, 123106306, &
         949854402,  429877922,  261135009, 574783260, 1043288376 /)
    write (*, 100) 'testing taorng ...'
    write (*, 100) '  call taornl (luxury=1)'
100  format (1X, A)
    call taornl (1)
    write (*, 100) '  call taorns (seed=0)'
    call taorns (0)
    <<Reset the buffer>>
    print *, '  10000 warmup calls to taorni'
    do j = 1, 10000
       call taorni (r)
    end do
    do j = 1, 10
       call taorni (r)
       if (r .eq. expect(j)) then
          write (*, 101) 10000+j, r
101        format (3X, I5, ': ', I10, ' OK.')
        else
           write (*, 102) 10000+j, r, expect(j)
102        format (3X, I5, ': ', I10, ' not OK, (expected ', I10, ')!')
         end if
      end do
      write (*, 100) 'done.'
      stop
    end subroutine taornt

@ %def taornt
@ This is crucial, in case the buffer has been used:
<<Reset the buffer>>=
      i = N
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Testing}
<<[[sample_taorng.f90]]>>=
  program circe2_taotst
    use kinds
    use tao_rng

    implicit none
    integer :: i, N, S
    real(kind=double) :: r
    real(kind=double) :: sum30
    call taornt ()
    S = 0
    N = 10000000
    sum30 = 0
    call taorns (S)
    do i = 1, N
       call taornu (r)
       sum30 = sum30 + r
    end do
    print *, 'sum30 = ', sum30
  end program circe2_taotst

@ %def sample_taorng
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{empfile}
\end{document}
\endinput
Local Variables:
mode:noweb
noweb-doc-mode:latex-mode
noweb-code-mode:f90-mode
indent-tabs-mode:nil
page-delimiter:"^@ %%%.*\n"
End:
