% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}

The interface to Recola.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola !NODEP!
 
  use kinds
<<Use strings>>
  use diagnostics
  use io_units
  use constants, only: zero
  use lorentz
  use physics_defs
  
  use sm_qcd, only: qcd_t
  use model_data, only: model_data_t

  use prc_core, only: prc_core_state_t
  use prc_core_def, only: prc_core_driver_t, prc_core_def_t
  use prc_user_defined
  use process_libraries, only: process_library_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ Returns the particle string corresponding to a pdg code used in the Recola
process definition
<<prc recola: procedures>>=
  elemental function get_recola_particle_string (pdg) result (name)
    type(string_t) :: name
    integer, intent(in) :: pdg
    select case (pdg)
    case (1)
       name = var_str ("d")
    case (-1) 
       name = var_str ("d~")
    case (2) 
       name = var_str ("u")
    case (-2)
       name = var_str ("u~")
    case (3)
       name = var_str ("s")
    case (-3)
       name = var_str ("s~")
    case (4)
       name = var_str ("c")
    case (-4)
       name = var_str ("c~")
    case (5)
       name = var_str ("b")
    case (-5)
       name = var_str ("b~")
    case (6)
       name = var_str ("t")
    case (-6)
       name = var_str ("t~")
    case (11)
       name = var_str ("e-")
    case (-11)
       name = var_str ("e+")
    case (12)
       name = var_str ("nu_e")
    case (-12)
       name = var_str ("nu_e~")
    case (13)
       name = var_str ("mu-")
    case (-13)
       name = var_str ("mu+")
    case (14)
       name = var_str ("nu_mu")
    case (-14)
       name = var_str ("nu_mu~")
    case (15)
       name = var_str ("tau-")
    case (-15)
       name = var_str ("tau+")
    case (16)
       name = var_str ("nu_tau")
    case (-16)
       name = var_str ("nu_tau~")
    case (21)
       name = var_str ("g")
    case (22)
       name = var_str ("A")
    case (23)
       name = var_str ("Z")
    case (24)
       name = var_str ("W+")
    case (-24)
       name = var_str ("W-")
    case (25)
       name = var_str ("H")
    end select
  end function get_recola_particle_string

@ %def get_recola_particle_string
@ 
<<prc recola: public>>=
  public :: create_recola_color_structures
<<prc recola: procedures>>=
  function create_recola_color_structures (col_omega) result (col_recola)
    integer, dimension(:,:), allocatable :: col_recola
    integer, dimension(:,:,:), intent(in) :: col_omega
    integer :: n_tot, n_flv
    integer :: i, j, i_flv
    integer, dimension(2) :: tuple1, tuple2
    n_tot = size (col_omega, dim=2)
    n_flv = size (col_omega, dim=3)
    allocate (col_recola (n_flv, n_tot))
    do i_flv = 1, n_flv
       col_recola (:,i_flv) = 0
       do i = 1, n_tot
          tuple1 = col_omega (:,i,i_flv)
          do j = 1, n_tot
             tuple2 = col_omega (:,j,i_flv)
             if (tuple1(1) /= 0) then
                if (tuple1(1) == -tuple2(j)) then
                   col_recola(i_flv,i) = j
                   exit
                end if 
             end if
          end do
       end do 
    end do
  end function create_recola_color_structures 

@ %def create_recola_color_structures
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
     integer :: recola_id = 0
     integer, dimension(:,:), allocatable :: color_state
     integer :: alpha_power=0, alphas_power=0
     logical :: nlo_computation = .false.
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@

<<prc recola: types>>=
  type, extends (prc_user_defined_writer_t) :: recola_writer_t
  contains
  <<prc recola: recola writer: TBP>>
  end type recola_writer_t

@ %def recola_writer_t
@
<<prc recola: types>>=
  type, extends (user_defined_state_t) :: recola_state_t
  contains
  <<prc recola: recola state: TBP>>
  end type recola_state_t

@ %def recola_state_t
@ 
<<prc recola: recola state: TBP>>=
  procedure :: write => recola_state_write
<<prc recola: procedures>>=
  subroutine recola_state_write (object, unit)
    class(recola_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine recola_state_write

@ %def recola_state_write
@

<<prc recola: recola writer: TBP>>=
  procedure, nopass :: type_name => recola_writer_type_name
<<prc recola: procedures>>=
  function recola_writer_type_name () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_writer_type_name

@ %def recola_writer_type_name
@
<<prc recola: public>>=
  public :: recola_def_t
<<prc recola: types>>=
  type, extends (user_defined_def_t) :: recola_def_t
    type(string_t) :: suffix 
  contains
  <<prc recola: recola def: TBP>>
  end type recola_def_t

@ %def recola_def_t
@ A core driver is required by design. However, it is only a dummy
because we are not going to load any external dynamical libraries.
<<prc recola: types>>=
  type, extends (user_defined_driver_t) :: recola_driver_t
  contains
  <<prc recola: recola driver: TBP>>
  end type recola_driver_t

@ %def recola_driver_t
@
<<prc recola: prc recola: TBP>>=
  procedure :: prc_recola_set_coupling_powers
<<prc recola: procedures>>=
  subroutine prc_recola_set_coupling_powers (object, alpha_power, alphas_power)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(in) :: alpha_power, alphas_power
    object%alphas_power = alphas_power
    object%alpha_power = alpha_power
    !write(*,"(A)") "RECOLA set_couplig_powers is called"
    !write(*,"(A,I2,A,I2,A,I2)") "RECOLA alpha_power:", alpha_power,", alpha_S_power",alphas_power
    
  end subroutine prc_recola_set_coupling_powers

@ %def prc_recola_set_coupling_powers
@
<<prc recola: prc recola: TBP>>=
  procedure :: set_nlo => prc_recola_set_nlo
<<prc recola: procedures>>=
  subroutine prc_recola_set_nlo (object)
    class(prc_recola_t), intent(inout) :: object
    object%nlo_computation = .true.
    write(*,"(A)") "RECOLA set_nlo is called"
    
  end subroutine prc_recola_set_nlo

@ %def prc_recola_set_nlo
@
<<prc recola: prc recola: TBP>>=
  procedure :: compute_alpha_s => prc_recola_compute_alpha_s
<<prc recola: procedures>>=
  subroutine prc_recola_compute_alpha_s (object, core_state, fac_scale)
    class(prc_recola_t), intent(inout) :: object
    class(user_defined_state_t), intent(inout) :: core_state
    real(default), intent(in) :: fac_scale
    real(default) :: alphas
    call compute_running_alphas_rcl (fac_scale,-1,2)
    call get_alphas_rcl (alphas)
    core_state%alpha_qcd = alphas
   ! write(*,"(A,F6.3)")"RECOLA Alpha strong is set to: ", alphas
  end subroutine prc_recola_compute_alpha_s

@ %def prc_recola_compute_alpha_s
@
<<prc recola: prc recola: TBP>>=
  procedure :: allocate_workspace => prc_recola_allocate_workspace
<<prc recola: procedures>>=
  subroutine prc_recola_allocate_workspace (object, core_state)
    class(prc_recola_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (recola_state_t :: core_state)
  end subroutine prc_recola_allocate_workspace

@ %def prc_recola_allocate_workspace
@
<<prc recola: prc recola: TBP>>=
  procedure :: includes_polarization => prc_recola_includes_polarization
<<prc recola: procedures>>=
  function prc_recola_includes_polarization (object) result (polarized)
    logical :: polarized
    class(prc_recola_t), intent(in) :: object
    polarized = .true.
  end function prc_recola_includes_polarization

@ %def prc_recola_includes_polarization
@
<<prc recola: prc recola: TBP>>=
  procedure :: write_name => prc_recola_write_name
<<prc recola: procedures>>=
  subroutine prc_recola_write_name (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: Recola"
  end subroutine prc_recola_write_name

@ %def prc_recola_write_name
@ Recola can compute dressed amplitudes, but it needs helicity and color
to be in its own format to do so. 
<<prc recola: prc recola: TBP>>=
  procedure :: replace_helicity_and_color_arrays => &
     prc_recola_replace_helicity_and_color_arrays
<<prc recola: procedures>>=
  subroutine prc_recola_replace_helicity_and_color_arrays (object)
    class(prc_recola_t), intent(inout) :: object
    integer, dimension(:,:), allocatable :: col_recola
    integer :: i
    deallocate (object%data%hel_state)
    call get_helicity_configurations_rcl (object%recola_id, object%data%hel_state)
    !call get_colour_configurations_rcl (object%recola_id, col_recola)
    !deallocate (object%data%col_state)
    !allocate (object%data%col_state (1, object%data%n_in + object%data%n_out, &
    !          size (col_recola, dim=1)))
    !do i = 1, size (col_recola, dim=1)
    !   object%data%col_state (1, :, i) = col_recola (i, :)
    !end do
    object%data%n_hel = size (object%data%hel_state, dim=1)
    !object%data%n_col = size (col_recola, dim=1)
  end subroutine prc_recola_replace_helicity_and_color_arrays

@ %def prc_recola_replace_helicity_and_color_arrays
@
<<prc recola: prc recola: TBP>>=
  procedure :: register_processes => prc_recola_register_processes
<<prc recola: procedures>>=
  subroutine prc_recola_register_processes (object, recola_id)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(inout) :: recola_id
    type(string_t), dimension(:), allocatable :: particle_names
    type(string_t) :: process_string
    integer :: i_flv, i_part
    integer :: n_tot
    !!! TODO (cw-2016-08-08): Include amplitude type (LO, NLO, ...)
    !!! TODO (cw-2016-08-08): Include helicities 
    write(*,"(A)") "RECOLA register_process is called"
    n_tot = object%data%n_in + object%data%n_out
    allocate (particle_names (n_tot))
    do i_flv = 1, object%data%n_flv 
       recola_id = recola_id + 1
       object%recola_id = recola_id
       particle_names = get_recola_particle_string (object%data%flv_state (:, i_flv))
       process_string = var_str ("")
       do i_part = 1, n_tot
          print *, 'Appending particle: ', char (particle_names(i_part))
          process_string = process_string // particle_names (i_part) // var_str (" ")
          if (i_part == object%data%n_in) &
             process_string = process_string // var_str ("-> ")
       end do
       write(*,"(A, I3)") "RECOLA process_id is:", object%recola_id
       print*, char (process_string)
       if (object%nlo_computation) then
           call define_process_rcl (object%recola_id, char (process_string), 'NLO')
           write(*,"(A)") "RECOLA NLO is set"
       else
           call define_process_rcl (object%recola_id, char (process_string), 'LO')
           write(*,"(A)") "RECOLA LO is set:"
       end if
       call generate_processes_rcl ()
    end do
  end subroutine prc_recola_register_processes

@ %def prc_recola_register_processes 
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    real(default), dimension(0:3, object%data%n_in + object%data%n_out) :: p_recola
    integer :: i
    logical :: new_event
    
    if (present (core_state)) then
       if (allocated (core_state)) then
          select type (core_state)
          type is (recola_state_t)
             new_event = core_state%new_kinematics
             core_state%new_kinematics = .false.
          end select
       end if
    end if
    if (new_event) then
       do i = 1, object%data%n_in + object%data%n_out
          p_recola(:, i) = p(i)%p
          write(*,"(A,I2,A,4F12.5,2x)") "RECOLA p(", i,")=",p_recola(:, i)
       end do
       call compute_process_rcl (object%recola_id, p_recola, 'LO')  
    end if
      
    call get_amplitude_rcl (object%recola_id, 0, 'LO', object%data%col_state (1, :, c), &
       object%data%hel_state (h, :), amp) 
    write(*,"(A,F9.5,1x)") "RECOLA amplitude is",amp
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@

<<prc recola: prc recola: TBP>>=
  procedure :: compute_sqme_virt => prc_recola_t_compute_sqme_virt
<<prc recola: procedures>>=
  subroutine prc_recola_t_compute_sqme_virt (object, i_flv, &
          p, ren_scale, sqme, bad_point)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), dimension(4), intent(out) :: sqme
    real(default) :: amp
    logical, intent(out) :: bad_point
    real(default), dimension(0:3, object%data%n_in + object%data%n_out) :: p_recola
    integer :: i
    
    sqme = 0
   ! write(*,"(A)") "RECOLA compute_sqme_virt routine is called"
    do i = 1, object%data%n_in + object%data%n_out
        p_recola(:, i) = p(i)%p
   !     write(*,"(A,I2,A,4F12.5,2x)") "RECOLA p(", i,")=",p_recola(:, i)
    end do
    call compute_process_rcl (object%recola_id, p_recola, 'NLO')  
      
    call get_squared_amplitude_rcl (object%recola_id, object%alphas_power, 'NLO', amp)
    
    ! call get_amplitude_rcl (object%recola_id, 0, 'LO', object%data%col_state (1, :, c), &
    !  object%data%hel_state (h, :), amp)
    
   ! write(*,"(A,F12.7,1x)") "RECOLA amplitude is calculated",amp
   ! print *, amp
   
    sqme = amp
    bad_point = .false.
  end subroutine prc_recola_t_compute_sqme_virt

@ %def prc_recola_t_compute_sqme_virt
@

<<prc recola: prc recola: TBP>>=
  procedure :: set_parameters => prc_recola_set_parameters
<<prc recola: procedures>>=
  subroutine prc_recola_set_parameters (object, qcd, model)
    class(prc_recola_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    class(model_data_t), intent(in), target, optional :: model
    object%qcd = qcd
  end subroutine prc_recola_set_parameters
  
@ %def prc_recola_set_parameters
@
<<prc recola: prc recola: TBP>>=
  procedure :: has_matrix_element => prc_recola_has_matrix_element 
<<prc recola: procedures>>=
  function prc_recola_has_matrix_element (object) result (flag)
    logical :: flag
    class(prc_recola_t), intent(in) :: object
    flag = .true.
  end function prc_recola_has_matrix_element

@ %def prc_recola_has_matrix_element
@
<<prc recola: recola def: TBP>>=
  procedure :: init => recola_def_init
<<prc recola: procedures>>=
  subroutine recola_def_init (object, basename, model_name, &
     prt_in, prt_out, nlo_type)
    class(recola_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename, model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer, intent(in) :: nlo_type
    object%basename = basename
    allocate (recola_writer_t :: object%writer)
    select case (nlo_type)
    case (BORN)
       object%suffix = '_BORN'
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    case (NLO_MISMATCH)
       object%suffix = '_MISMATCH'
    case (NLO_DGLAP)
       object%suffix = '_DGLAP'
    end select
    select type (writer => object%writer)
    class is (recola_writer_t)
       call writer%init (model_name, prt_in, prt_out)
    end select
  end subroutine recola_def_init

@ %def recola_def_init
@
<<prc recola: recola def: TBP>>=
  procedure :: allocate_driver => recola_def_allocate_driver
<<prc recola: procedures>>=
  subroutine recola_def_allocate_driver (object, driver, basename)
    class(recola_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (recola_driver_t :: driver)
  end subroutine recola_def_allocate_driver

@ %def recola_def_allocate_driver
@
<<prc recola: recola def: TBP>>=
  procedure :: read => recola_def_read
<<prc recola: procedures>>=
  subroutine recola_def_read (object, unit)
    class(recola_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_read

@ %def recola_def_read
@
<<prc recola: recola def: TBP>>=
  procedure, nopass :: type_string => recola_def_type_string
<<prc recola: procedures>>=
  function recola_def_type_string () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_def_type_string

@ %def recola_def_type_string
@  
<<prc recola: recola def: TBP>>=
  procedure :: write => recola_def_write
<<prc recola: procedures>>=
  subroutine recola_def_write (object, unit)
    class(recola_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_write

@ %def recola_def_write
@
<<prc recola: recola driver: TBP>>=
  procedure, nopass :: type_name => recola_driver_type_name
<<prc recola: procedures>>=
  function recola_driver_type_name () result (type)
    type(string_t) :: type
    type = "Recola"
  end function recola_driver_type_name

@ %def recola_driver_type_name
@
\subsection{Unit tests}
<<[[prc_recola_ut.f90]]>>=
<<File header>>

module prc_recola_ut
  use unit_tests
  use prc_recola_uti

<<Standard module head>>

<<prc recola: public tests>>

contains

<<prc recola: test driver>>

end module prc_recola_ut
@ %def prc_recola_ut
@
<<[[prc_recola_uti.f90]]>>=
<<File header>>

module prc_recola_uti

  use, intrinsic :: iso_c_binding !NODEP!
  use recola !NODEP!
  use kinds
<<Use strings>>

  use constants
  use format_utils, only: write_separator
  use numeric_utils, only: assert_equal
  use os_interface
  use particle_specifiers, only: new_prt_spec
  use prc_core_def
  use process_constants
  use process_libraries
  use prc_core

  use prc_omega
  use prc_recola, only: create_recola_color_structures
  
<<Standard module head>>

<<prc recola: test declarations>>

contains

<<prc recola: test procedures>>

<<prc recola: tests>>

end module prc_recola_uti

@ %def prc_recola_uti
@
<<prc recola: public tests>>=
  public :: prc_recola_test
<<prc recola: test driver>>=
  subroutine prc_recola_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<prc recola: execute tests>>
  end subroutine prc_recola_test
  
@ %def prc_recola_test
@
\subsubsection{Testing a fixed flavor matrix element computation}
<<prc recola: test procedures>>=
  function get_omega_parameter_array () result (par)
    real(default), dimension(25) :: par
    par = zero
    
    par(1) = 1.16637d-5 ! gf
    par(2) = 91.153480619182744_default ! mZ
    par(3) = 80.357973609877547_default ! mW
    par(4) = 125._default ! mH
    call get_alphas_rcl (par(5)) ! aplha_s
    par(12) = 173.2_default ! mt
    par(14) = 2.4942663787728243_default ! wZ
    par(15) = 2.0842989982782196_default ! wW
    par(22) = one / sqrt (sqrt (two) * par(1)) ! par%v - Higgs expectation value
    par(23) = par(3) / par(2) ! par%cw
    par(24) = sqrt (one - par(23)**2) ! par%sw
    par(25) = two * par(24) * par(3) / par(22) 
  end function get_omega_parameter_array

@ %def get_omega_parameter_array
@ 
<<prc recola: execute tests>>=
  call test (prc_recola_1, "prc_recola_1", &
       "Registering a RECOLA process and computing the amplitude", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_1
<<prc recola: tests>>=
  subroutine prc_recola_1 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    integer, dimension(:,:), allocatable :: helicities
    

    
    write (u, "(A)") "* Test output: prc_recola_1"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    counter  = 1
    call set_on_shell_scheme_rcl ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- at leading order"
    call define_process_rcl (counter,'e+ e- -> mu+ mu-','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call compute_process_rcl (1,p,'LO')
    allocate (hel_recola (4), col_recola (4))
    col_recola = [0,0,0,0]

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega1"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega1_a"), 1, data, driver) 
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       do i = 1, 6
          call get_amplitude_rcl (1, 0, 'LO', col_recola, helicities (i, :), amp_recola)
       end do
       do i = 1, 16
           call get_amplitude_rcl (1, 0, 'LO', col_recola, data%hel_state (:,i), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,4(I2),A)") "Helicity: [",data%hel_state (:,i),"]"
           call assert_equal (u, amp, amp_recola) ! , "Helicity:", data%hel_state (:,i))
       end do
       
    end select
    
    call reset_recola_rcl
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_1"

    
  end subroutine prc_recola_1

@ %def prc_recola_1
@
\subsubsection{Testing a fixed flavor matrix element computation for 2->3}
<<prc recola: execute tests>>=
  call test (prc_recola_2, "prc_recola_2", &
       "Registering a RECOLA process and computing the amplitude for 2->3 process", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_2
<<prc recola: tests>>=
  subroutine prc_recola_2 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:5)
    real(double) :: sqrts = 700._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    integer, dimension(:,:), allocatable :: helicities
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    integer :: n_allowed
    
    logical(c_bool) :: flag
    
    write (u, "(A)") "* Test output: prc_recola_2"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega for 2->3 process"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
   ! p_z_out = 90._double 
   ! p_y_out = sqrts / 10._default
   ! p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - (p_z_out/3)**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [243.49323116_double, -141.69619338_double, -108.30640321_double,  165.77353656_double]
    p(:,4) = [337.53250628_double,  143.95931207_double,  110.19717026_double, -284.71124482_double]
    p(:,5) = [118.97426257_double, -2.2631186860_double, -1.8907670459_double,  118.93770827_double]
    
   ! 11   0.0000000000E+00  0.0000000000E+00  3.5000000000E+02  3.5000000000E+02
   !-11   0.0000000000E+00  0.0000000000E+00 -3.5000000000E+02  3.5000000000E+02
   ! 13  -1.4169619338E+02 -1.0830640321E+02  1.6577353656E+02  2.4349323116E+02
   !-13   1.4395931207E+02  1.1019717026E+02 -2.8471124482E+02  3.3753250628E+02
   ! 22  -2.2631186860E+00 -1.8907670459E+00  1.1893770827E+02  1.1897426257E+02

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 5
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    call set_on_shell_scheme_rcl ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- A at leading order"
    call define_process_rcl (2,'e+ e- -> mu+ mu- A','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call compute_process_rcl (2,p,'LO')
    call get_helicity_configurations_rcl (2, helicities)
    
    allocate (hel_recola (5), col_recola (5))
    col_recola = [0,0,0,0,0]
    

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega2"))
    allocate (prt_in (2), prt_out (3))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-"), var_str("A")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega2_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 3, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega2_a"), 1, data, driver) 
    
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       do i = 1, 32
           call get_amplitude_rcl (2, 0, 'LO', col_recola, helicities (i,:), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,5(I2),A)") "O'MEGA Helicity:[", data%hel_state (:,i),"]"
           write(u,"(A,5(I2),A)") "RECOLA Helicity: [", helicities (i,:),"]"
           write(u,"(A,2(F12.7,1x),A,2(F12.7,1x))") "RECOLA:", amp_recola,", O'MEGA:", amp
           call assert_equal (u, amp, amp_recola)
       end do
       
    end select
    
    call reset_recola_rcl
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_2"
    
  end subroutine prc_recola_2
@ %def prc_recola_2
@
<<prc recola: execute tests>>=
  call test (prc_recola_3, "prc_recola_2", &
       "Registering a RECOLA process and computing the amplitude for 2->3 process", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_3
<<prc recola: tests>>=
  subroutine prc_recola_3 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_quark = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter
    real(double) :: sqme
    integer :: i
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    integer, dimension(:,:), allocatable :: helicities
    integer, dimension(:,:), allocatable :: colors, col_recola
    
    write (u, "(A)") "* Test output: prc_recola_3"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega for a colored process"
    write (u, "(A)")  
        
    p_z_in = sqrts / 2
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    call set_on_shell_scheme_rcl ()
    write (u, "(A)") "*  RECOLA: Define process u u~ -> g at leading order"
    call define_process_rcl (1, 'u u~ -> g g','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call get_helicity_configurations_rcl (1, helicities)
    call get_colour_configurations_rcl (1, colors)
    print *, 'Number of helicities: ', size (helicities, dim=1)
    do i = 1, size (helicities, dim=1)
       print *, 'hel: ', helicities (i, :)
    end do
    do i = 1, size (colors, dim=1)
       print *, 'col: ', colors (i, :)
    end do
    call compute_process_rcl (1,p,'LO')

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega3"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("g"), var_str ("g")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega3_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega3_a"), 1, data, driver) 
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       !do i = 1, 16
           !call get_amplitude_rcl (1, 0, 'LO', col_recola, data%hel_state (:,i), amp_recola)
           !amp_recola = amp_recola * cmplx (0, -1, default) 
           !call driver%get_amplitude (1, i, 1, amp)                
           !write(u,"(A,4(I2),A)") "Helicity: [",data%hel_state (:,i),"]"
           !call assert_equal (u, amp, amp_recola) ! , "Helicity:", data%hel_state (:,i))
       !end do
       col_recola = create_recola_color_structures (data%col_state)
       print *, 'Number of colors: ', data%n_col
       do i = 1, 5
          print *, 'omega color state: ', data%col_state (:,:,i)
          print *, 'reconstructed recola state: ', col_recola (i, :)
       end do 
       
    end select
    
    call reset_recola_rcl
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_3"

    
  end subroutine prc_recola_3

@ %def prc_recola_3
@
