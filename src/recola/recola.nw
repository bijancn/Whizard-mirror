% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}
\section{Recola wrappers}
\subsection{Actual Recola function}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[recola_wrapper.f90]]>>=
<<File header>>

module recola_wrapper

  use recola !NODEP!
 
  use kinds
<<Use strings>>
  use constants, only: zero
  use diagnostics, only: msg_fatal

<<Standard module head>>

<<recola wrapper: public>>

<<recola wrapper: parameters>>

contains

<<recola wrapper: procedures>>

end module recola_wrapper
@ %def recola_wrapper
@
<<recola wrapper: parameters>>=
  public :: rclwrap_is_active
<<recola wrapper: parameters>>=
  logical, parameter :: rclwrap_is_active = .true.

@ %def rclwrap_is_active
@ Returns the particle string corresponding to a pdg code used in the Recola
process definition
<<recola wrapper: public>>=
  public :: get_recola_particle_string
<<recola wrapper: procedures>>=
  elemental function get_recola_particle_string (pdg) result (name)
    type(string_t) :: name
    integer, intent(in) :: pdg
    select case (pdg)
    case (1)
       name = var_str ("d")
    case (-1) 
       name = var_str ("d~")
    case (2) 
       name = var_str ("u")
    case (-2)
       name = var_str ("u~")
    case (3)
       name = var_str ("s")
    case (-3)
       name = var_str ("s~")
    case (4)
       name = var_str ("c")
    case (-4)
       name = var_str ("c~")
    case (5)
       name = var_str ("b")
    case (-5)
       name = var_str ("b~")
    case (6)
       name = var_str ("t")
    case (-6)
       name = var_str ("t~")
    case (11)
       name = var_str ("e-")
    case (-11)
       name = var_str ("e+")
    case (12)
       name = var_str ("nu_e")
    case (-12)
       name = var_str ("nu_e~")
    case (13)
       name = var_str ("mu-")
    case (-13)
       name = var_str ("mu+")
    case (14)
       name = var_str ("nu_mu")
    case (-14)
       name = var_str ("nu_mu~")
    case (15)
       name = var_str ("tau-")
    case (-15)
       name = var_str ("tau+")
    case (16)
       name = var_str ("nu_tau")
    case (-16)
       name = var_str ("nu_tau~")
    case (21)
       name = var_str ("g")
    case (22)
       name = var_str ("A")
    case (23)
       name = var_str ("Z")
    case (24)
       name = var_str ("W+")
    case (-24)
       name = var_str ("W-")
    case (25)
       name = var_str ("H")
    end select
  end function get_recola_particle_string

@ %def get_recola_particle_string
@
<<recola wrapper: public>>=
  public :: rclwrap_define_process
<<recola wrapper: procedures>>=
  subroutine rclwrap_define_process (id, process_string, order)
    integer, intent(in) :: id
    type(string_t), intent(in) :: process_string
    character(len=*), intent(in) :: order
    call define_process_rcl (id, char (process_string), order) 
  end subroutine rclwrap_define_process 

@ %def rclwrap_define_process
@
<<recola wrapper: public>>=
  public :: rclwrap_generate_processes
<<recola wrapper: procedures>>=
  subroutine rclwrap_generate_processes ()
    call generate_processes_rcl ()
  end subroutine rclwrap_generate_processes

@ %def rclwrap_generate_processes
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_process
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_process (id, p, order, sqme)
    integer, intent(in) :: id
    real(double), intent(in), dimension(:,:) :: p
    character(len=*), intent(in) :: order
    real(double), intent(out), dimension(0:1), optional :: sqme
    call compute_process_rcl (id, p, order, sqme)
  end subroutine rclwrap_compute_process

@ %def rclwrap_compute_process
@
<<recola wrapper: public>>=
  public :: rclwrap_get_amplitude
<<recola wrapper: procedures>>= 
  subroutine rclwrap_get_amplitude (id, g_power, order, col, hel, amp) 
    integer, intent(in) :: id, g_power
    character(len=*), intent(in) :: order
    integer, dimension(:), intent(in) :: col, hel
    complex(double), intent(out) :: amp
    call get_amplitude_rcl (id, g_power, order, col, hel, amp)
  end subroutine rclwrap_get_amplitude

@ %def rclwrap_get_amplitude
@
<<recola wrapper: public>>=
  public :: rclwrap_get_squared_amplitude
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_squared_amplitude (id, alpha_power, order, sqme)
    integer, intent(in) :: id, alpha_power
    character(len=*), intent(in) :: order
    real(double), intent(out) :: sqme
    call get_squared_amplitude_rcl (id, alpha_power, order, sqme)
  end subroutine rclwrap_get_squared_amplitude

@ %def rclwrap_get_squared_amplitude
@
<<recola wrapper: public>>=
  public :: rclwrap_set_pole_mass    
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_pole_mass (pdg_id, mass, width)
    integer, intent(in) :: pdg_id
    real(double), intent(in) :: mass, width
    select case (abs(pdg_id))
    case (11)
       if (width > zero) &
          call msg_fatal ("Recola sets pole mass: Attempting to set non-zero electron width!")
       call set_pole_mass_electron_rcl (mass)
    case (13)
       call set_pole_mass_muon_rcl (mass, width)
    case (15)
       call set_pole_mass_tau_rcl (mass, width)
    case (1)
       if (width > zero) &
          call msg_fatal ("Recola sets pole mass: Attempting to set non-zero down-quark width!")
       call set_pole_mass_down_rcl (mass)
    case (2)
       if (width > zero) &
          call msg_fatal ("Recola sets pole mass: Attempting to set non-zero up-quark width!")
       call set_pole_mass_up_rcl (mass)
    case (3)
       if (width > zero) &
          call msg_fatal ("Recola sets pole mass: Attempting to set non-zero strange-quark width!")
       call set_pole_mass_strange_rcl (mass)
    case (4)
       call set_pole_mass_charm_rcl (mass, width)
    case (5)
       call set_pole_mass_bottom_rcl (mass, width)
    case (6)
       call set_pole_mass_top_rcl (mass, width)
    case (23)
       call set_pole_mass_z_rcl (mass, width)
    case (24)
       call set_pole_mass_w_rcl (mass, width)
    case (25)
       call set_pole_mass_h_rcl (mass, width)
    case default
       call msg_fatal ("Recola sets pole mass: Cannot set pole mass of particle")
    end select
  end subroutine rclwrap_set_pole_mass

@ %def rclwrap_set_pole_mass
@
<<recola wrapper: public>>=
  public :: rclwrap_use_gfermi_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_use_gfermi_scheme (gf)
    real(double), intent(in), optional :: gf
    call use_gfermi_scheme_rcl (gf)
  end subroutine rclwrap_use_gfermi_scheme

@ %def rclwrap_use_gfermi_scheme
@
<<recola wrapper: public>>=
  public :: rclwrap_set_light_fermions
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_light_fermions (m)
    real(double), intent(in) :: m
    call set_light_fermions_rcl (m)
  end subroutine rclwrap_set_light_fermions

@ %def rclwrap_set_light_fermions
@
<<recola wrapper: public>>=
  public :: rclwrap_set_light_fermion
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_light_fermion (pdg_id)
    integer, intent(in) :: pdg_id
    select case (abs(pdg_id))
    case (1)
       call set_light_down_rcl ()
    case (2)
       call set_light_up_rcl ()
    case (3)
       call set_light_strange_rcl ()
    case (4)
       call set_light_charm_rcl ()
    case (5)
       call set_light_bottom_rcl ()
    case (6)
       call set_light_top_rcl ()
    case (11)
       call set_light_electron_rcl ()
    case (13)
       call set_light_muon_rcl ()
    case (15)
       call set_light_tau_rcl ()
    end select
  end subroutine rclwrap_set_light_fermion

@ %def rclwrap_set_light_fermion
@
<<recola wrapper: public>>=
  public :: rclwrap_unset_light_fermion
<<recola wrapper: procedures>>=
  subroutine rclwrap_unset_light_fermion (pdg_id)
    integer, intent(in) :: pdg_id
    select case (abs(pdg_id))
    case (1)
       call unset_light_down_rcl ()
    case (2)
       call unset_light_up_rcl ()
    case (3)
       call unset_light_strange_rcl ()
    case (4)
       call unset_light_charm_rcl ()
    case (5)
       call unset_light_bottom_rcl ()
    case (6)
       call unset_light_top_rcl ()
    case (11)
       call unset_light_electron_rcl ()
    case (13)
       call unset_light_muon_rcl ()
    case (15)
       call unset_light_tau_rcl ()
    end select
  end subroutine rclwrap_unset_light_fermion

@ %def rclwrap_unset_light_fermion
@
<<recola wrapper: public>>=
  public :: rclwrap_set_onshell_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_onshell_scheme
    call set_on_shell_scheme_rcl ()
  end subroutine rclwrap_set_onshell_scheme

@ %def rclwrap_set_onshell_scheme
@
<<recola wrapper: public>>=
  public :: rclwrap_set_alpha_s
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_alpha_s (alpha_s, mu, nf)
    real(double), intent(in) :: alpha_s, mu
    integer, intent(in) :: nf
    call set_alphas_rcl (alpha_s, mu, nf)
  end subroutine rclwrap_set_alpha_s

@ %def rclwrap_set_alpha_s
@
<<recola wrapper: public>>=
  public :: rclwrap_get_alpha_s
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_alpha_s (alpha_s)
    real(double) :: alpha_s 
    call get_alphas_rcl (alpha_s)
  end subroutine rclwrap_get_alpha_s

@ %def rclwrap_get_alpha_s
@
<<recola wrapper: public>>=
  public :: rclwrap_get_helicity_configurations
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_helicity_configurations (id, hel)
    integer, intent(in) :: id
    integer, intent(inout), dimension(:,:), allocatable :: hel
    call get_helicity_configurations_rcl (id, hel)
  end subroutine rclwrap_get_helicity_configurations

@ %def rclwrap_get_helicity_configurations
@
<<recola wrapper: public>>=
  public :: rclwrap_get_color_configurations
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_color_configurations (id, col)
    integer, intent(in) :: id
    integer, intent(out), dimension(:,:), allocatable :: col
    call get_colour_configurations_rcl (id, col)
  end subroutine rclwrap_get_color_configurations

@ %def rclwrap_get_color_configurations
@
<<recola wrapper: public>>=
  public :: rclwrap_set_mu_uv
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_mu_uv (mu)
    real(double), intent(in) :: mu
    call set_mu_uv_rcl (mu)
  end subroutine rclwrap_set_mu_uv

@ %def rclwrap_set_mu_uv
@
<<recola wrapper: public>>=
  public :: rclwrap_set_mu_ir
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_mu_ir (mu)
    real(double), intent(in) :: mu
    call set_mu_ir_rcl (mu)
  end subroutine rclwrap_set_mu_ir

@ %def rclwrap_set_mu_ir
@
<<recola wrapper: public>>=
  public :: rclwrap_get_renormalization_scale
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_renormalization_scale (mu)
    real(double), intent(out) :: mu
    call get_renormalization_scale_rcl (mu)
  end subroutine rclwrap_get_renormalization_scale

@ %def rclwrap_get_renormalization_scale
@
<<recola wrapper: public>>=
  public :: rclwrap_get_flavor_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_flavor_scheme (nf)
    integer, intent(out) :: nf
    call get_flavour_scheme_rcl (nf) 
  end subroutine rclwrap_get_flavor_scheme

@ %def rclwrap_get_flavor_scheme
@ 
<<recola wrapper: public>>=
  public :: rclwrap_use_alpha0_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_use_alpha0_scheme (al0)
    real(double), intent(in), optional :: al0
    call use_alpha0_scheme_rcl (al0)
  end subroutine rclwrap_use_alpha0_scheme

@ %def rclwrap_use_alpha0_scheme
@
<<recola wrapper: public>>=
  public :: rclwrap_use_alphaz_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_use_alphaz_scheme (alz)
    real(double), intent(in), optional :: alz
    call use_alphaz_scheme_rcl (alz)
  end subroutine rclwrap_use_alphaz_scheme

@ %def rclwrap_use_alphaz_scheme
@
<<recola wrapper: public>>=
  public :: rclwrap_set_complex_mass_scheme
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_complex_mass_scheme ()
    call set_complex_mass_scheme_rcl ()
  end subroutine rclwrap_set_complex_mass_scheme

@ %def rclwrap_set_complex_mass_scheme
@
<<recola wrapper: public>>=
  public :: rclwrap_set_resonant_particle
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_resonant_particle (pdg_id)
    integer, intent(in) :: pdg_id
    call set_resonant_particle_rcl (char(get_recola_particle_string (pdg_id)))
  end subroutine rclwrap_set_resonant_particle

@ %def rclwrap_set_resonant_particle
@
<<recola wrapper: public>>=
  public :: rclwrap_switch_on_resonant_self_energies
<<recola wrapper: procedures>>=
  subroutine rclwrap_switch_on_resonant_self_energies ()
    call switchon_resonant_selfenergies_rcl ()
  end subroutine rclwrap_switch_on_resonant_self_energies

@ %def rclwrap_switch_on_resonant_self_energies
@
<<recola wrapper: public>>=
  public :: rclwrap_switch_off_resonant_self_energies
<<recola wrapper: procedures>>=
  subroutine rclwrap_switch_off_resonant_self_energies ()
    call switchoff_resonant_selfenergies_rcl ()
  end subroutine rclwrap_switch_off_resonant_self_energies

@ %def rclwrap_switch_off_resonant_self_energies
@
<<recola wrapper: public>>=
  public :: rclwrap_set_draw_level_branches
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_draw_level_branches (n)
    integer, intent(in) :: n
    call set_draw_level_branches_rcl (n)
  end subroutine rclwrap_set_draw_level_branches

@ %def rclwrap_set_draw_level_branches
@ 
<<recola wrapper: public>>=
  public :: rclwrap_set_print_level_amplitude
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_print_level_amplitude (n)
    integer, intent(in) :: n
    call set_print_level_amplitude_rcl (n)
  end subroutine rclwrap_set_print_level_amplitude    

@ %def rclwrap_set_print_level_amplitude
@
<<recola wrapper: public>>=
  public :: rclwrap_set_print_level_squared_amplitude
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_print_level_squared_amplitude (n)
    integer, intent(in) :: n
    call set_print_level_squared_amplitude_rcl (n)
  end subroutine rclwrap_set_print_level_squared_amplitude    

@ %def rclwrap_set_print_level_squared_amplitude
@
<<recola wrapper: public>>=
  public :: rclwrap_set_print_level_correlations
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_print_level_correlations (n)
    integer, intent(in) :: n
    call set_print_level_correlations_rcl (n)
  end subroutine rclwrap_set_print_level_correlations    

@ %def rclwrap_set_print_level_correlations
@
<<recola wrapper: public>>=
  public :: rclwrap_set_print_level_RAM
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_print_level_RAM (n)
    integer, intent(in) :: n
    call set_print_level_RAM_rcl (n)
  end subroutine rclwrap_set_print_level_RAM    

@ %def rclwrap_set_print_level_RAM
@
<<recola wrapper: public>>=
  public :: rclwrap_scale_coupling3
<<recola wrapper: procedures>>=
  subroutine rclwrap_scale_coupling3 (pdg_id1, pdg_id2, pdg_id3, factor)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3
    complex(double), intent(in) :: factor
    call scale_coupling3_rcl (factor, char(get_recola_particle_string (pdg_id1)), &
       char(get_recola_particle_string (pdg_id2)), char(get_recola_particle_string (pdg_id3)))
  end subroutine rclwrap_scale_coupling3

@ %def rclwrap_scale_coupling3
@
<<recola wrapper: public>>=
  public :: rclwrap_scale_coupling4
<<recola wrapper: procedures>>=
  subroutine rclwrap_scale_coupling4 (pdg_id1, pdg_id2, pdg_id3, pdg_id4, factor)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3, pdg_id4
    complex(double), intent(in) :: factor
    call scale_coupling4_rcl (factor, char(get_recola_particle_string (pdg_id1)), &
       char(get_recola_particle_string (pdg_id2)), char(get_recola_particle_string (pdg_id3)), &
       char(get_recola_particle_string (pdg_id4)))
  end subroutine rclwrap_scale_coupling4

@ %def rclwrap_scale_coupling4
@
<<recola wrapper: public>>=
  public :: rclwrap_switch_off_coupling3
<<recola wrapper: procedures>>=
  subroutine rclwrap_switch_off_coupling3 (pdg_id1, pdg_id2, pdg_id3)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3
    call switchoff_coupling3_rcl (char(get_recola_particle_string (pdg_id1)), &
       char(get_recola_particle_string (pdg_id2)), char(get_recola_particle_string (pdg_id3)))
  end subroutine rclwrap_switch_off_coupling3

@ %def rclwrap_switch_off_coupling3
@
<<recola wrapper: public>>=
  public :: rclwrap_switch_off_coupling4
<<recola wrapper: procedures>>=
  subroutine rclwrap_switch_off_coupling4 (pdg_id1, pdg_id2, pdg_id3, pdg_id4)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3, pdg_id4
    call switchoff_coupling4_rcl (char(get_recola_particle_string (pdg_id1)), &
       char(get_recola_particle_string (pdg_id2)), char(get_recola_particle_string (pdg_id3)), &
       char(get_recola_particle_string (pdg_id4)))
  end subroutine rclwrap_switch_off_coupling4

@ %def rclwrap_switch_off_coupling4
@
<<recola wrapper: public>>=
  public :: rclwrap_set_ifail
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_ifail (i)
    integer, intent(in) :: i
    call set_ifail_rcl (i)
  end subroutine rclwrap_set_ifail

@ %def rclwrap_set_ifail
@
<<recola wrapper: public>>=
  public :: rclwrap_get_ifail
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_ifail (i)
    integer, intent(out) :: i
    call get_ifail_rcl (i)
  end subroutine rclwrap_get_ifail

@ %def rclwrap_get_ifail
@
<<recola wrapper: public>>=
  public :: rclwrap_set_output_file
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_output_file (filename)
    character(len=*), intent(in) :: filename
    call set_output_file_rcl (filename)
  end subroutine rclwrap_set_output_file

@ %def rclwrap_set_output_file
@
<<recola wrapper: public>>=
  public :: rclwrap_set_gs_power
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_gs_power (id, gs_array)
    integer, intent(in) :: id
    integer, dimension(:,:), intent(in) :: gs_array
    call set_gs_power_rcl (id, gs_array)
  end subroutine rclwrap_set_gs_power

@ %def rclwrap_set_gs_power
@
<<recola wrapper: public>>=
  public :: rclwrap_select_gs_power_born_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_select_gs_power_born_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
    call select_gs_power_BornAmpl_rcl (id, gs_power)
 end subroutine rclwrap_select_gs_power_born_amp

@ %def rclwrap_select_gs_power_born_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_unselect_gs_power_born_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_unselect_gs_power_born_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
    call unselect_gs_power_BornAmpl_rcl (id, gs_power)
 end subroutine rclwrap_unselect_gs_power_born_amp

@ %def rclwrap_unselect_gs_power_born_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_select_gs_power_loop_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_select_gs_power_loop_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
    call select_gs_power_LoopAmpl_rcl (id, gs_power)
 end subroutine rclwrap_select_gs_power_loop_amp

@ %def rclwrap_select_gs_power_loop_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_unselect_gs_power_loop_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_unselect_gs_power_loop_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
    call unselect_gs_power_LoopAmpl_rcl (id, gs_power)
 end subroutine rclwrap_unselect_gs_power_loop_amp

@ %def rclwrap_unselect_gs_power_loop_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_select_all_gs_powers_born_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_select_all_gs_powers_born_amp (id)
    integer, intent(in) :: id
    call select_all_gs_powers_BornAmpl_rcl (id)
  end subroutine rclwrap_select_all_gs_powers_born_amp

@ %def rclwrap_select_all_gs_powers_born_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_unselect_all_gs_powers_loop_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_unselect_all_gs_powers_loop_amp (id)
    integer, intent(in) :: id
    call unselect_all_gs_powers_BornAmpl_rcl (id)
  end subroutine rclwrap_unselect_all_gs_powers_loop_amp

@ %def rclwrap_unselect_all_gs_powers_loop_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_select_all_gs_powers_loop_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_select_all_gs_powers_loop_amp (id)
    integer, intent(in) :: id
    call select_all_gs_powers_LoopAmpl_rcl (id)
  end subroutine rclwrap_select_all_gs_powers_loop_amp

@ %def rclwrap_select_all_gs_powers_loop_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_unselect_all_gs_powers_born_amp
<<recola wrapper: procedures>>=
  subroutine rclwrap_unselect_all_gs_powers_born_amp (id)
    integer, intent(in) :: id
    call unselect_all_gs_powers_LoopAmpl_rcl (id)
  end subroutine rclwrap_unselect_all_gs_powers_born_amp

@ %def rclwrap_unselect_all_gs_powers_born_amp
@
<<recola wrapper: public>>=
  public :: rclwrap_set_resonant_squared_momentum
<<recola wrapper: procedures>>=
  subroutine rclwrap_set_resonant_squared_momentum (id, i_res, p2)
    integer, intent(in) :: id, i_res
    real(double), intent(in) :: p2
    call set_resonant_squared_momentum_rcl (id, i_res, p2)
  end subroutine rclwrap_set_resonant_squared_momentum

@ %def rclwrap_set_resonant_squared_momentum
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_running_alpha_s
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_running_alpha_s (Q, nf, n_loops)
    real(double), intent(in) :: Q
    integer, intent(in) :: nf, n_loops
    call compute_running_alphas_rcl (Q, nf, n_loops)
  end subroutine rclwrap_compute_running_alpha_s

@ %def rclwrap_compute_running_alpha_s
@
<<recola wrapper: public>>=
  public :: rclwrap_rescale_process
<<recola wrapper: procedures>>=
  subroutine rclwrap_rescale_process (id, order, sqme)
    integer, intent(in) :: id
    character(len=*), intent(in) :: order
    real(double), dimension(0:1), intent(out), optional :: sqme
    call rescale_process_rcl (id, order, sqme)
  end subroutine rclwrap_rescale_process

@ %def rclwrap_rescale_process
@
<<recola wrapper: public>>=
  public :: rclwrap_get_polarized_squared_amplitude
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_polarized_squared_amplitude (id, &
     alphas_power, order, hel, sqme)
    integer, intent(in) :: id, alphas_power
    character(len=*), intent(in) :: order
    integer, dimension(:), intent(in) :: hel
    real(double), intent(out) :: sqme
    call get_polarized_squared_amplitude_rcl (id, alphas_power, &
       order, hel, sqme)
  end subroutine rclwrap_get_polarized_squared_amplitude

@ %def rclwrap_get_polarized_squared_amplitude
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_color_correlation (id, p, &
     i1, i2, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i1, i2
    real(double), intent(out), optional :: sqme
    call compute_colour_correlation_rcl (id, p, i1, i2, sqme)
  end subroutine rclwrap_compute_color_correlation

@ %def rclwrap_compute_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_all_color_correlations
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_all_color_correlations (id, p)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    call compute_all_colour_correlations_rcl (id, p)
  end subroutine rclwrap_compute_all_color_correlations

@ %def rclwrap_compute_all_color_correlations
@
<<recola wrapper: public>>=
  public :: rclwrap_rescale_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_rescale_color_correlation (id, i1, i2, sqme)
    integer, intent(in) :: id, i1, i2
    real(double), intent(out), optional :: sqme
    call rescale_colour_correlation_rcl (id, i1, i2, sqme)
  end subroutine rclwrap_rescale_color_correlation

@ %def rclwrap_rescale_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_rescale_all_color_correlations
<<recola wrapper: procedures>>=
  subroutine rclwrap_rescale_all_color_correlations (id)
    integer, intent(in) :: id
    call rescale_all_colour_correlations_rcl (id)
  end subroutine rclwrap_rescale_all_color_correlations

@ %def rclwrap_rescale_all_color_correlations
@
<<recola wrapper: public>>=
  public :: rclwrap_get_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_color_correlation (id, alphas_power, i1, i2, sqme)
    integer, intent(in) :: id, alphas_power, i1, i2
    real(double), intent(out) :: sqme
    call get_colour_correlation_rcl (id, alphas_power, i1, i2, sqme)
  end subroutine rclwrap_get_color_correlation

@ %def rclwrap_get_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_spin_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_spin_correlation (id, p, i_photon, pol, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i_photon
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
    call compute_spin_correlation_rcl (id, p, i_photon, pol, sqme)
  end subroutine rclwrap_compute_spin_correlation 

@ %def rclwrap_compute_spin_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_rescale_spin_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_rescale_spin_correlation (id, i_photon, pol, sqme)
    integer, intent(in) :: id, i_photon
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
    call rescale_spin_correlation_rcl (id, i_photon, pol, sqme)
  end subroutine rclwrap_rescale_spin_correlation

@ %def rclwrap_rescale_spin_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_get_spin_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_spin_correlation (id, alphas_power, sqme)
    integer, intent(in) :: id, alphas_power
    real(double), intent(out) :: sqme
    call get_spin_correlation_rcl (id, alphas_power, sqme)
  end subroutine rclwrap_get_spin_correlation

@ %def rclwrap_get_spin_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_compute_spin_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_compute_spin_color_correlation (id, p, &
     i_gluon, i_spectator, pol, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i_gluon, i_spectator
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
    call compute_spin_colour_correlation_rcl (id, p, &
       i_gluon, i_spectator, pol, sqme)
  end subroutine rclwrap_compute_spin_color_correlation

@ %def rclwrap_compute_spin_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_rescale_spin_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_rescale_spin_color_correlation (id, i_gluon, &
     i_spectator, pol, sqme)
    integer, intent(in) :: id, i_gluon, i_spectator
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
    call rescale_spin_colour_correlation_rcl (id, i_gluon, &
       i_spectator, pol, sqme)
  end subroutine rclwrap_rescale_spin_color_correlation

@ %def rclwrap_rescale_spin_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_get_spin_color_correlation
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_spin_color_correlation (id, alphas_power, &
     i_gluon, i_spectator, sqme)
    integer, intent(in) :: id, alphas_power, i_gluon, i_spectator
    real(double), intent(out) :: sqme
    call get_spin_colour_correlation_rcl (id, alphas_power, &
       i_gluon, i_spectator, sqme)
  end subroutine rclwrap_get_spin_color_correlation

@ %def rclwrap_get_spin_color_correlation
@
<<recola wrapper: public>>=
  public :: rclwrap_get_momenta
<<recola wrapper: procedures>>=
  subroutine rclwrap_get_momenta (id, p)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(out) :: p
    call get_momenta_rcl (id, p)
  end subroutine rclwrap_get_momenta

@ %def rclwrap_get_momenta
@
<<recola wrapper: public>>=
  public :: rclwrap_reset_recola
<<recola wrapper: procedures>>=
  subroutine rclwrap_reset_recola
    call reset_recola_rcl ()
  end subroutine rclwrap_reset_recola

@ %def rclwrap_reset_recola
@
\subsection{Recola dummies}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[recola_wrapper_dummy.f90]]>>=
<<File header>>

module recola_wrapper
 
  use kinds
<<Use strings>>

<<Standard module head>>

<<recola wrapper dummy: public>>

<<recola wrapper dummy: parameters>>

contains

<<recola wrapper dummy: procedures>>

end module recola_wrapper
@ %def recola_wrapper_dummy
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_is_active
<<recola wrapper dummy: parameters>>=
  logical, parameter :: rclwrap_is_active = .false.

@ %def rclwrap_is_active
@
<<recola wrapper dummy: public>>=
  public :: get_recola_particle_string
<<recola wrapper dummy: procedures>>=
  elemental function get_recola_particle_string (pdg) result (name)
    type(string_t) :: name
    integer, intent(in) :: pdg
    name = var_str ("")
  end function get_recola_particle_string

@ %def get_recola_paritcle_string
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_define_process
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_define_process (id, process_string, order)
    integer, intent(in) :: id
    type(string_t), intent(in) :: process_string
    character(len=*), intent(in) :: order
  end subroutine rclwrap_define_process 

@ %def rclwrap_define_process
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_generate_processes
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_generate_processes ()
  end subroutine rclwrap_generate_processes

@ %def rclwrap_generate_processes
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_process
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_process (id, p, order, sqme)
    integer, intent(in) :: id
    real(double), intent(in), dimension(:,:) :: p
    character(len=*), intent(in) :: order
    real(double), intent(out), dimension(0:1), optional :: sqme
  end subroutine rclwrap_compute_process

@ %def rclwrap_compute_process
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_amplitude
<<recola wrapper dummy: procedures>>= 
  subroutine rclwrap_get_amplitude (id, g_power, order, col, hel, amp) 
    integer, intent(in) :: id, g_power
    character(len=*), intent(in) :: order
    integer, dimension(:), intent(in) :: col, hel
    complex(double), intent(out) :: amp
  end subroutine rclwrap_get_amplitude

@ %def rclwrap_get_amplitude
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_squared_amplitude
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_squared_amplitude (id, alpha_power, order, sqme)
    integer, intent(in) :: id, alpha_power
    character(len=*), intent(in) :: order
    real(double), intent(out) :: sqme
  end subroutine rclwrap_get_squared_amplitude

@ %def rclwrap_get_squared_amplitude
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_pole_mass    
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_pole_mass (pdg_id, mass, width)
    integer, intent(in) :: pdg_id
    real(double), intent(in) :: mass, width
  end subroutine rclwrap_set_pole_mass

@ %def rclwrap_set_pole_mass
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_use_gfermi_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_use_gfermi_scheme (gf)
    real(double), intent(in), optional :: gf
  end subroutine rclwrap_use_gfermi_scheme

@ %def rclwrap_use_gfermi_scheme
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_light_fermions
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_light_fermions (m)
    real(double), intent(in) :: m
  end subroutine rclwrap_set_light_fermions

@ %def rclwrap_set_light_fermions
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_light_fermion
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_light_fermion (pdg_id)
    integer, intent(in) :: pdg_id
  end subroutine rclwrap_set_light_fermion

@ %def rclwrap_set_light_fermion
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_unset_light_fermion
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_unset_light_fermion (pdg_id)
    integer, intent(in) :: pdg_id
  end subroutine rclwrap_unset_light_fermion

@ %def rclwrap_unset_light_fermion
@ 
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_onshell_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_onshell_scheme
  end subroutine rclwrap_set_onshell_scheme

@ %def rclwrap_set_onshell_scheme
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_alpha_s
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_alpha_s (alpha_s, mu, nf)
    real(double), intent(in) :: alpha_s, mu
    integer, intent(in) :: nf
  end subroutine rclwrap_set_alpha_s

@ %def rclwrap_set_alpha_s
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_alpha_s
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_alpha_s (alpha_s)
    real(double) :: alpha_s 
  end subroutine rclwrap_get_alpha_s

@ %def rclwrap_get_alpha_s
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_helicity_configurations
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_helicity_configurations (id, hel)
    integer, intent(in) :: id
    integer, intent(inout), dimension(:,:), allocatable :: hel
  end subroutine rclwrap_get_helicity_configurations

@ %def rclwrap_get_helicity_configurations
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_color_configurations
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_color_configurations (id, col)
    integer, intent(in) :: id
    integer, intent(out), dimension(:,:), allocatable :: col
  end subroutine rclwrap_get_color_configurations

@ %def rclwrap_get_color_configurations
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_mu_uv
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_mu_uv (mu)
    real(double), intent(in) :: mu
  end subroutine rclwrap_set_mu_uv

@ %def rclwrap_set_mu_uv
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_mu_ir
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_mu_ir (mu)
    real(double), intent(in) :: mu
  end subroutine rclwrap_set_mu_ir

@ %def rclwrap_set_mu_ir
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_renormalization_scale
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_renormalization_scale (mu)
    real(double), intent(out) :: mu
  end subroutine rclwrap_get_renormalization_scale

@ %def rclwrap_get_renormalization_scale
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_flavor_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_flavor_scheme (nf)
    integer, intent(out) :: nf
  end subroutine rclwrap_get_flavor_scheme

@ %def rclwrap_get_flavor_scheme
@ 
<<recola wrapper dummy: public>>=
  public :: rclwrap_use_alpha0_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_use_alpha0_scheme (al0)
    real(double), intent(in), optional :: al0
  end subroutine rclwrap_use_alpha0_scheme

@ %def rclwrap_use_alpha0_scheme
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_use_alphaz_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_use_alphaz_scheme (alz)
    real(double), intent(in), optional :: alz
  end subroutine rclwrap_use_alphaz_scheme

@ %def rclwrap_use_alphaz_scheme
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_complex_mass_scheme
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_complex_mass_scheme ()
  end subroutine rclwrap_set_complex_mass_scheme

@ %def rclwrap_set_complex_mass_scheme
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_resonant_particle
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_resonant_particle (pdg_id)
    integer, intent(in) :: pdg_id
  end subroutine rclwrap_set_resonant_particle

@ %def rclwrap_set_resonant_particle
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_switch_on_resonant_self_energies
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_switch_on_resonant_self_energies ()
  end subroutine rclwrap_switch_on_resonant_self_energies

@ %def rclwrap_switch_on_resonant_self_energies
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_switch_off_resonant_self_energies
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_switch_off_resonant_self_energies ()
  end subroutine rclwrap_switch_off_resonant_self_energies

@ %def rclwrap_switch_off_resonant_self_energies
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_draw_level_branches
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_draw_level_branches (n)
    integer, intent(in) :: n
  end subroutine rclwrap_set_draw_level_branches

@ %def rclwrap_set_draw_level_branches
@ 
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_print_level_amplitude
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_print_level_amplitude (n)
    integer, intent(in) :: n
  end subroutine rclwrap_set_print_level_amplitude    

@ %def rclwrap_set_print_level_amplitude
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_print_level_squared_amplitude
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_print_level_squared_amplitude (n)
    integer, intent(in) :: n
  end subroutine rclwrap_set_print_level_squared_amplitude    

@ %def rclwrap_set_print_level_squared_amplitude
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_print_level_correlations
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_print_level_correlations (n)
    integer, intent(in) :: n
  end subroutine rclwrap_set_print_level_correlations    

@ %def rclwrap_set_print_level_correlations
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_print_level_RAM
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_print_level_RAM (n)
    integer, intent(in) :: n
  end subroutine rclwrap_set_print_level_RAM    

@ %def rclwrap_set_print_level_RAM
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_scale_coupling3
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_scale_coupling3 (pdg_id1, pdg_id2, pdg_id3, factor)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3
    complex(double), intent(in) :: factor
  end subroutine rclwrap_scale_coupling3

@ %def rclwrap_scale_coupling3
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_scale_coupling4
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_scale_coupling4 (pdg_id1, pdg_id2, pdg_id3, pdg_id4, factor)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3, pdg_id4
    complex(double), intent(in) :: factor
  end subroutine rclwrap_scale_coupling4

@ %def rclwrap_scale_coupling4
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_switch_off_coupling3
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_switch_off_coupling3 (pdg_id1, pdg_id2, pdg_id3)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3
  end subroutine rclwrap_switch_off_coupling3

@ %def rclwrap_switch_off_coupling3
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_switch_off_coupling4
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_switch_off_coupling4 (pdg_id1, pdg_id2, pdg_id3, pdg_id4)
    integer, intent(in) :: pdg_id1, pdg_id2, pdg_id3, pdg_id4
  end subroutine rclwrap_switch_off_coupling4

@ %def rclwrap_switch_off_coupling4
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_ifail
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_ifail (i)
    integer, intent(in) :: i
  end subroutine rclwrap_set_ifail

@ %def rclwrap_set_ifail
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_ifail
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_ifail (i)
    integer, intent(out) :: i
  end subroutine rclwrap_get_ifail

@ %def rclwrap_get_ifail
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_output_file
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_output_file (filename)
    character(len=*), intent(in) :: filename
  end subroutine rclwrap_set_output_file

@ %def rclwrap_set_output_file
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_gs_power
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_gs_power (id, gs_array)
    integer, intent(in) :: id
    integer, dimension(:,:), intent(in) :: gs_array
  end subroutine rclwrap_set_gs_power

@ %def rclwrap_set_gs_power
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_select_gs_power_born_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_select_gs_power_born_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
 end subroutine rclwrap_select_gs_power_born_amp

@ %def rclwrap_select_gs_power_born_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_unselect_gs_power_born_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_unselect_gs_power_born_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
 end subroutine rclwrap_unselect_gs_power_born_amp

@ %def rclwrap_unselect_gs_power_born_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_select_gs_power_loop_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_select_gs_power_loop_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
 end subroutine rclwrap_select_gs_power_loop_amp

@ %def rclwrap_select_gs_power_loop_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_unselect_gs_power_loop_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_unselect_gs_power_loop_amp (id, gs_power)
    integer, intent(in) :: id, gs_power
 end subroutine rclwrap_unselect_gs_power_loop_amp

@ %def rclwrap_unselect_gs_power_loop_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_select_all_gs_powers_born_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_select_all_gs_powers_born_amp (id)
    integer, intent(in) :: id
  end subroutine rclwrap_select_all_gs_powers_born_amp

@ %def rclwrap_select_all_gs_powers_born_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_unselect_all_gs_powers_loop_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_unselect_all_gs_powers_loop_amp (id)
    integer, intent(in) :: id
  end subroutine rclwrap_unselect_all_gs_powers_loop_amp

@ %def rclwrap_unselect_all_gs_powers_loop_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_select_all_gs_powers_loop_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_select_all_gs_powers_loop_amp (id)
    integer, intent(in) :: id
  end subroutine rclwrap_select_all_gs_powers_loop_amp

@ %def rclwrap_select_all_gs_powers_loop_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_unselect_all_gs_powers_born_amp
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_unselect_all_gs_powers_born_amp (id)
    integer, intent(in) :: id
  end subroutine rclwrap_unselect_all_gs_powers_born_amp

@ %def rclwrap_unselect_all_gs_powers_born_amp
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_set_resonant_squared_momentum
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_set_resonant_squared_momentum (id, i_res, p2)
    integer, intent(in) :: id, i_res
    real(double), intent(in) :: p2
  end subroutine rclwrap_set_resonant_squared_momentum

@ %def rclwrap_set_resonant_squared_momentum
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_running_alpha_s
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_running_alpha_s (Q, nf, n_loops)
    real(double), intent(in) :: Q
    integer, intent(in) :: nf, n_loops
  end subroutine rclwrap_compute_running_alpha_s

@ %def rclwrap_compute_running_alpha_s
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_rescale_process
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_rescale_process (id, order, sqme)
    integer, intent(in) :: id
    character(len=*), intent(in) :: order
    real(double), dimension(0:1), intent(out), optional :: sqme
  end subroutine rclwrap_rescale_process

@ %def rclwrap_rescale_process
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_polarized_squared_amplitude
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_polarized_squared_amplitude (id, &
     alphas_power, order, hel, sqme)
    integer, intent(in) :: id, alphas_power
    character(len=*), intent(in) :: order
    integer, dimension(:), intent(in) :: hel
    real(double), intent(out) :: sqme
  end subroutine rclwrap_get_polarized_squared_amplitude

@ %def rclwrap_get_polarized_squared_amplitude
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_color_correlation (id, p, &
     i1, i2, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i1, i2
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_compute_color_correlation

@ %def rclwrap_compute_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_all_color_correlations
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_all_color_correlations (id, p)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
  end subroutine rclwrap_compute_all_color_correlations

@ %def rclwrap_compute_all_color_correlations
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_rescale_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_rescale_color_correlation (id, i1, i2, sqme)
    integer, intent(in) :: id, i1, i2
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_rescale_color_correlation

@ %def rclwrap_rescale_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_rescale_all_color_correlations
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_rescale_all_color_correlations (id)
    integer, intent(in) :: id
  end subroutine rclwrap_rescale_all_color_correlations

@ %def rclwrap_rescale_all_color_correlations
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_color_correlation (id, alphas_power, i1, i2, sqme)
    integer, intent(in) :: id, alphas_power, i1, i2
    real(double), intent(out) :: sqme
  end subroutine rclwrap_get_color_correlation

@ %def rclwrap_get_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_spin_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_spin_correlation (id, p, i_photon, pol, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i_photon
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_compute_spin_correlation 

@ %def rclwrap_compute_spin_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_rescale_spin_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_rescale_spin_correlation (id, i_photon, pol, sqme)
    integer, intent(in) :: id, i_photon
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_rescale_spin_correlation

@ %def rclwrap_rescale_spin_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_spin_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_spin_correlation (id, alphas_power, sqme)
    integer, intent(in) :: id, alphas_power
    real(double), intent(out) :: sqme
  end subroutine rclwrap_get_spin_correlation

@ %def rclwrap_get_spin_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_compute_spin_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_compute_spin_color_correlation (id, p, &
     i_gluon, i_spectator, pol, sqme)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(in) :: p
    integer, intent(in) :: i_gluon, i_spectator
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_compute_spin_color_correlation

@ %def rclwrap_compute_spin_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_rescale_spin_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_rescale_spin_color_correlation (id, i_gluon, &
     i_spectator, pol, sqme)
    integer, intent(in) :: id, i_gluon, i_spectator
    complex(double), dimension(:), intent(in) :: pol
    real(double), intent(out), optional :: sqme
  end subroutine rclwrap_rescale_spin_color_correlation

@ %def rclwrap_rescale_spin_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_spin_color_correlation
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_spin_color_correlation (id, alphas_power, &
     i_gluon, i_spectator, sqme)
    integer, intent(in) :: id, alphas_power, i_gluon, i_spectator
    real(double), intent(out) :: sqme
  end subroutine rclwrap_get_spin_color_correlation

@ %def rclwrap_get_spin_color_correlation
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_get_momenta
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_get_momenta (id, p)
    integer, intent(in) :: id
    real(double), dimension(:,:), intent(out) :: p
  end subroutine rclwrap_get_momenta

@ %def rclwrap_get_momenta
@
<<recola wrapper dummy: public>>=
  public :: rclwrap_reset_recola
<<recola wrapper dummy: procedures>>=
  subroutine rclwrap_reset_recola
  end subroutine rclwrap_reset_recola

@ %def rclwrap_reset_recola
@
\section{Recola core}
The recola core object.
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola_wrapper !NODEP!
 
  use kinds
<<Use strings>>
  use diagnostics
  use io_units
  use constants, only: zero, twopi
  use lorentz
  use physics_defs
  
  use os_interface, only: os_data_t
  use sm_qcd, only: qcd_t
  use model_data, only: model_data_t

  use prc_core, only: prc_core_state_t
  use prc_core_def, only: prc_core_driver_t, prc_core_def_t
  use prc_user_defined
  use process_libraries, only: process_library_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ Checks the [[rclwrap_is_active]] flag and aborts the program if the dummy
is used.
<<prc recola: public>>=
  public :: abort_if_recola_not_active
<<prc recola: procedures>>=
  subroutine abort_if_recola_not_active ()
    if (.not. rclwrap_is_active) call msg_fatal ("You want to use Recola, ", &
       [var_str("but either the compiler with which Whizard has been build "), &
        var_str("is not supported by it, or you have not linked Recola "), &
        var_str("correctly to Whizard. Either reconfigure Whizard with a path to "), &
        var_str("a valid Recola installation (for details consult the manual), "), &
        var_str("or choose a different matrix-element method.")])
  end subroutine abort_if_recola_not_active

@ %def abort_if_recola_not_active
@ 
<<prc recola: public>>=
  public :: create_recola_color_structures
<<prc recola: procedures>>=
  function create_recola_color_structures (col_omega) result (col_recola)
    integer, dimension(:,:), allocatable :: col_recola
    integer, dimension(:,:,:), intent(in) :: col_omega
    integer :: n_tot, n_flv
    integer :: i, j, i_flv
    integer, dimension(2) :: tuple1, tuple2
    n_tot = size (col_omega, dim=2)
    n_flv = size (col_omega, dim=3)
    allocate (col_recola (n_flv, n_tot))
    do i_flv = 1, n_flv
       col_recola (:,i_flv) = 0
       do i = 1, n_tot
          tuple1 = col_omega (:,i,i_flv)
          do j = 1, n_tot
             tuple2 = col_omega (:,j,i_flv)
             if (tuple1(1) /= 0) then
                if (tuple1(1) == -tuple2(j)) then
                   col_recola(i_flv,i) = j
                   exit
                end if 
             end if
          end do
       end do 
    end do
  end function create_recola_color_structures 

@ %def create_recola_color_structures
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
     integer :: recola_id = 0
     integer, dimension(:,:), allocatable :: color_state
     integer :: alpha_power=0, alphas_power=0
     logical :: nlo_computation = .false.
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@

<<prc recola: types>>=
  type, extends (prc_user_defined_writer_t) :: recola_writer_t
  contains
  <<prc recola: recola writer: TBP>>
  end type recola_writer_t

@ %def recola_writer_t
@
<<prc recola: types>>=
  type, extends (user_defined_state_t) :: recola_state_t
  contains
  <<prc recola: recola state: TBP>>
  end type recola_state_t

@ %def recola_state_t
@ 
<<prc recola: recola state: TBP>>=
  procedure :: write => recola_state_write
<<prc recola: procedures>>=
  subroutine recola_state_write (object, unit)
    class(recola_state_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine recola_state_write

@ %def recola_state_write
@

<<prc recola: recola writer: TBP>>=
  procedure, nopass :: type_name => recola_writer_type_name
<<prc recola: procedures>>=
  function recola_writer_type_name () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_writer_type_name

@ %def recola_writer_type_name
@
<<prc recola: public>>=
  public :: recola_def_t
<<prc recola: types>>=
  type, extends (user_defined_def_t) :: recola_def_t
    type(string_t) :: suffix 
  contains
  <<prc recola: recola def: TBP>>
  end type recola_def_t

@ %def recola_def_t
@ A core driver is required by design. However, it is only a dummy
because we are not going to load any external dynamical libraries.
<<prc recola: types>>=
  type, extends (user_defined_driver_t) :: recola_driver_t
  contains
  <<prc recola: recola driver: TBP>>
  end type recola_driver_t

@ %def recola_driver_t
@
<<prc recola: prc recola: TBP>>=
  procedure :: prc_recola_set_coupling_powers
<<prc recola: procedures>>=
  subroutine prc_recola_set_coupling_powers (object, alpha_power, alphas_power)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(in) :: alpha_power, alphas_power
    object%alphas_power = alphas_power
    object%alpha_power = alpha_power
    
  end subroutine prc_recola_set_coupling_powers

@ %def prc_recola_set_coupling_powers
@
<<prc recola: prc recola: TBP>>=
  procedure :: set_nlo => prc_recola_set_nlo
<<prc recola: procedures>>=
  subroutine prc_recola_set_nlo (object)
    class(prc_recola_t), intent(inout) :: object
    object%nlo_computation = .true.
  end subroutine prc_recola_set_nlo

@ %def prc_recola_set_nlo
@
<<prc recola: prc recola: TBP>>=
  procedure :: compute_alpha_s => prc_recola_compute_alpha_s
<<prc recola: procedures>>=
  subroutine prc_recola_compute_alpha_s (object, core_state, fac_scale)
    class(prc_recola_t), intent(in) :: object
    class(user_defined_state_t), intent(inout) :: core_state
    real(default), intent(in) :: fac_scale
    real(default) :: alphas
    alphas = object%qcd%alpha%get (fac_scale)
    call rclwrap_set_alpha_s (alphas, fac_scale, -1)
    core_state%alpha_qcd = alphas
  end subroutine prc_recola_compute_alpha_s

@ %def prc_recola_compute_alpha_s
@
<<prc recola: prc recola: TBP>>=
  procedure :: allocate_workspace => prc_recola_allocate_workspace
<<prc recola: procedures>>=
  subroutine prc_recola_allocate_workspace (object, core_state)
    class(prc_recola_t), intent(in) :: object
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    allocate (recola_state_t :: core_state)
  end subroutine prc_recola_allocate_workspace

@ %def prc_recola_allocate_workspace
@
<<prc recola: prc recola: TBP>>=
  procedure :: includes_polarization => prc_recola_includes_polarization
<<prc recola: procedures>>=
  function prc_recola_includes_polarization (object) result (polarized)
    logical :: polarized
    class(prc_recola_t), intent(in) :: object
    polarized = .false.
  end function prc_recola_includes_polarization

@ %def prc_recola_includes_polarization
@
<<prc recola: prc recola: TBP>>=
  procedure :: write_name => prc_recola_write_name
<<prc recola: procedures>>=
  subroutine prc_recola_write_name (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u,"(1x,A)") "Core: Recola"
  end subroutine prc_recola_write_name

@ %def prc_recola_write_name
@
<<prc recola: prc recola: TBP>>=
  procedure :: create_and_load_extra_libraries => &
       prc_recola_create_and_load_extra_libraries
<<prc recola: procedures>>=
  subroutine prc_recola_create_and_load_extra_libraries &
       (core, os_data, libname, model, i_core)
     class(prc_recola_t), intent(inout) :: core
     type(os_data_t), intent(in) :: os_data
     type(string_t), intent(in) :: libname
     type(model_data_t), intent(in), target :: model
     integer, intent(in) :: i_core
     call core%set_nlo ()
     call core%register_processes (i_recola)
     call core%replace_helicity_and_color_arrays ()
  end subroutine prc_recola_create_and_load_extra_libraries

@ %def prc_recola_create_and_load_extra_libraries
@ Recola can compute dressed amplitudes, but it needs helicity and color
to be in its own format to do so. 
<<prc recola: prc recola: TBP>>=
  procedure :: replace_helicity_and_color_arrays => &
       prc_recola_replace_helicity_and_color_arrays
<<prc recola: procedures>>=
  subroutine prc_recola_replace_helicity_and_color_arrays (object)
    class(prc_recola_t), intent(inout) :: object
    integer, dimension(:,:), allocatable :: col_recola
    integer :: i
    deallocate (object%data%hel_state)
    call rclwrap_get_helicity_configurations (object%recola_id, object%data%hel_state)
    call rclwrap_get_color_configurations (object%recola_id, col_recola)
    !deallocate (object%data%col_state)
    allocate (object%color_state (object%data%n_in + object%data%n_out, &
              size (col_recola, dim=1)))
    do i = 1, size (col_recola, dim=1)
       object%color_state (:, i) = col_recola (i, :)
    end do
    object%data%n_hel = size (object%data%hel_state, dim=1)
    !object%data%n_col = size (object%data%col_state, dim=1)
  end subroutine prc_recola_replace_helicity_and_color_arrays

@ %def prc_recola_replace_helicity_and_color_arrays
@
<<prc recola: prc recola: TBP>>=
  procedure :: register_processes => prc_recola_register_processes
<<prc recola: procedures>>=
  subroutine prc_recola_register_processes (object, recola_id)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(inout) :: recola_id
    type(string_t), dimension(:), allocatable :: particle_names
    type(string_t) :: process_string
    integer :: i_flv, i_part
    integer :: n_tot
    !!! TODO (cw-2016-08-08): Include amplitude type (LO, NLO, ...)
    !!! TODO (cw-2016-08-08): Include helicities 
    write(*,"(A)") "RECOLA register_process is called"
    n_tot = object%data%n_in + object%data%n_out
    allocate (particle_names (n_tot))
    do i_flv = 1, object%data%n_flv 
       recola_id = recola_id + 1
       object%recola_id = recola_id
       particle_names = get_recola_particle_string (object%data%flv_state (:, i_flv))
       process_string = var_str ("")
       do i_part = 1, n_tot
          print *, 'Appending particle: ', char (particle_names(i_part))
          process_string = process_string // particle_names (i_part) // var_str (" ")
          if (i_part == object%data%n_in) &
             process_string = process_string // var_str ("-> ")
       end do
       write(*,"(A, I3)") "RECOLA process_id is:", object%recola_id
       print*, char (process_string)
       if (object%nlo_computation) then
           call rclwrap_define_process (object%recola_id, process_string, 'NLO')
           write(*,"(A)") "RECOLA NLO is set"
       else
           call rclwrap_define_process (object%recola_id, process_string, 'LO')
           write(*,"(A)") "RECOLA LO is set:"
       end if
       call rclwrap_generate_processes ()
    end do
  end subroutine prc_recola_register_processes

@ %def prc_recola_register_processes 
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    real(default), dimension(0:3, object%data%n_in + object%data%n_out) :: p_recola
    integer :: i
    logical :: new_event
    
    if (present (core_state)) then
       if (allocated (core_state)) then
          select type (core_state)
          type is (recola_state_t)
             new_event = core_state%new_kinematics
             core_state%new_kinematics = .false.
          end select
       end if
    end if
    if (new_event) then
       do i = 1, object%data%n_in + object%data%n_out
          p_recola(:, i) = p(i)%p
       end do
       call rclwrap_compute_process (object%recola_id, p_recola, 'LO')
    end if
      
    call rclwrap_get_amplitude (object%recola_id, 0, 'LO', object%color_state (:, c), &
       object%data%hel_state (h, :), amp)
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@
<<prc recola: prc recola: TBP>>=
  procedure :: compute_sqme_virt => prc_recola_compute_sqme_virt
<<prc recola: procedures>>=
  subroutine prc_recola_compute_sqme_virt (object, i_flv, &
          p, ren_scale, sqme, bad_point)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: i_flv
    type(vector4_t), dimension(:), intent(in) :: p
    real(default), intent(in) :: ren_scale
    real(default), dimension(4), intent(out) :: sqme
    real(default) :: amp
    logical, intent(out) :: bad_point
    real(default), dimension(0:3, object%data%n_in + object%data%n_out) :: p_recola
    integer :: i
    
    sqme = 0
    !!! Dummys for epsilon poles. I'm sure there's a function in Recola to compute this, 
    !!! but it is completely irrelevant for us so why waste speed. 
    do i = 1, object%data%n_in + object%data%n_out
        p_recola(:, i) = p(i)%p
    end do
    call rclwrap_compute_process (object%recola_id, p_recola, 'NLO')
    call rclwrap_get_squared_amplitude (object%recola_id, object%alphas_power + 1, 'NLO', sqme(3))
    
    !sqme(3) = sqme(3) / twopi

    call rclwrap_compute_process (object%recola_id, p_recola, 'LO')
    call rclwrap_get_squared_amplitude (object%recola_id, object%alphas_power, 'LO', sqme(4))

    bad_point = .false.
  end subroutine prc_recola_compute_sqme_virt

@ %def prc_recola_compute_sqme_virt
@

<<prc recola: prc recola: TBP>>=
  procedure :: set_parameters => prc_recola_set_parameters
<<prc recola: procedures>>=
  subroutine prc_recola_set_parameters (object, qcd, model)
    class(prc_recola_t), intent(inout) :: object
    type(qcd_t), intent(in) :: qcd
    class(model_data_t), intent(in), target, optional :: model
    object%qcd = qcd
    
    call rclwrap_set_pole_mass (11, model%get_real (var_str ('me')), zero)
    call rclwrap_set_pole_mass (13, model%get_real (var_str ('mmu')), zero)
    call rclwrap_set_pole_mass (15, model%get_real (var_str ('mtau')), zero)
    
    !call set_pole_mass_up_rcl (model%get_real (var_str ('mu')))
    !call set_pole_mass_down_rcl (model%get_real (var_str ('md')))
    
    call rclwrap_set_pole_mass (1, zero, zero)
    call rclwrap_set_pole_mass (2, zero, zero)
    
    call rclwrap_set_pole_mass (3, model%get_real (var_str ('ms')), zero)
    call rclwrap_set_pole_mass (4, model%get_real (var_str ('mc')), zero)
    call rclwrap_set_pole_mass (5, model%get_real (var_str ('mb')), zero)
    call rclwrap_set_pole_mass (6, model%get_real (var_str ('mtop')), &
       model%get_real (var_str ('wtop')))
    
    call rclwrap_set_pole_mass (23, model%get_real (var_str ('mZ')), model%get_real (var_str ('wZ')))
    call rclwrap_set_pole_mass (24, model%get_real (var_str ('mW')), model%get_real (var_str ('wW')))
    call rclwrap_set_pole_mass (25, model%get_real (var_str ('mH')), model%get_real (var_str ('wH')))
    
    call rclwrap_use_gfermi_scheme (model%get_real (var_str ('GF')))
    !call use_gfermi_scheme_rcl(a=ALPHA_OPENLOOPS)
    !call use_alpha0_scheme_rcl (1 / model%get_real (var_str ('alpha_em_i')))
    
    call rclwrap_set_light_fermions (0._default)
    
  end subroutine prc_recola_set_parameters
  
@ %def prc_recola_set_parameters
@
<<prc recola: prc recola: TBP>>=
  procedure :: has_matrix_element => prc_recola_has_matrix_element 
<<prc recola: procedures>>=
  function prc_recola_has_matrix_element (object) result (flag)
    logical :: flag
    class(prc_recola_t), intent(in) :: object
    flag = .true.
  end function prc_recola_has_matrix_element

@ %def prc_recola_has_matrix_element
@
<<prc recola: recola def: TBP>>=
  procedure :: init => recola_def_init
<<prc recola: procedures>>=
  subroutine recola_def_init (object, basename, model_name, &
     prt_in, prt_out, nlo_type)
    class(recola_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename, model_name
    type(string_t), dimension(:), intent(in) :: prt_in, prt_out
    integer, intent(in) :: nlo_type
    object%basename = basename
    allocate (recola_writer_t :: object%writer)
    select case (nlo_type)
    case (BORN)
       object%suffix = '_BORN'
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    case (NLO_MISMATCH)
       object%suffix = '_MISMATCH'
    case (NLO_DGLAP)
       object%suffix = '_DGLAP'
    end select
    select type (writer => object%writer)
    class is (recola_writer_t)
       call writer%init (model_name, prt_in, prt_out)
    end select
  end subroutine recola_def_init

@ %def recola_def_init
@
<<prc recola: recola def: TBP>>=
  procedure :: allocate_driver => recola_def_allocate_driver
<<prc recola: procedures>>=
  subroutine recola_def_allocate_driver (object, driver, basename)
    class(recola_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (recola_driver_t :: driver)
  end subroutine recola_def_allocate_driver

@ %def recola_def_allocate_driver
@
<<prc recola: recola def: TBP>>=
  procedure :: read => recola_def_read
<<prc recola: procedures>>=
  subroutine recola_def_read (object, unit)
    class(recola_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_read

@ %def recola_def_read
@
<<prc recola: recola def: TBP>>=
  procedure, nopass :: type_string => recola_def_type_string
<<prc recola: procedures>>=
  function recola_def_type_string () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_def_type_string

@ %def recola_def_type_string
@  
<<prc recola: recola def: TBP>>=
  procedure :: write => recola_def_write
<<prc recola: procedures>>=
  subroutine recola_def_write (object, unit)
    class(recola_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_write

@ %def recola_def_write
@
<<prc recola: recola driver: TBP>>=
  procedure, nopass :: type_name => recola_driver_type_name
<<prc recola: procedures>>=
  function recola_driver_type_name () result (type)
    type(string_t) :: type
    type = "Recola"
  end function recola_driver_type_name

@ %def recola_driver_type_name
@
\subsection{Unit tests}
<<[[prc_recola_ut.f90]]>>=
<<File header>>

module prc_recola_ut
  use unit_tests
  use prc_recola_uti

<<Standard module head>>

<<prc recola: public tests>>

contains

<<prc recola: test driver>>

end module prc_recola_ut
@ %def prc_recola_ut
@
<<[[prc_recola_uti.f90]]>>=
<<File header>>

module prc_recola_uti

  use, intrinsic :: iso_c_binding !NODEP!
  use recola !NODEP!
  use kinds
<<Use strings>>

  use constants
  use format_utils, only: write_separator
  use numeric_utils, only: assert_equal
  use os_interface
  use particle_specifiers, only: new_prt_spec
  use prc_core_def
  use process_constants
  use process_libraries
  use prc_core

  use prc_omega
  use prc_recola, only: create_recola_color_structures
  
<<Standard module head>>

<<prc recola: test declarations>>

contains

<<prc recola: test procedures>>

<<prc recola: tests>>

end module prc_recola_uti

@ %def prc_recola_uti
@
<<prc recola: public tests>>=
  public :: prc_recola_test
<<prc recola: test driver>>=
  subroutine prc_recola_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<prc recola: execute tests>>
  end subroutine prc_recola_test
  
@ %def prc_recola_test
@
\subsubsection{Testing a fixed flavor matrix element computation}
<<prc recola: test procedures>>=
  function get_omega_parameter_array () result (par)
    real(default), dimension(25) :: par
    par = zero
    
    par(1) = 1.16637d-5 ! gf
    par(2) = 91.153480619182744_default ! mZ
    par(3) = 80.357973609877547_default ! mW
    par(4) = 125._default ! mH
    call rclwrap_get_alpha_s (par(5)) ! alpha_s
    par(12) = 173.2_default ! mt
    par(14) = 2.4942663787728243_default ! wZ
    par(15) = 2.0842989982782196_default ! wW
    par(22) = one / sqrt (sqrt (two) * par(1)) ! par%v - Higgs expectation value
    par(23) = par(3) / par(2) ! par%cw
    par(24) = sqrt (one - par(23)**2) ! par%sw
    par(25) = two * par(24) * par(3) / par(22) 
  end function get_omega_parameter_array

@ %def get_omega_parameter_array
@ 
<<prc recola: execute tests>>=
  call test (prc_recola_1, "prc_recola_1", &
       "Registering a RECOLA process and computing the amplitude", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_1
<<prc recola: tests>>=
  subroutine prc_recola_1 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    integer, dimension(:,:), allocatable :: helicities
    

    
    write (u, "(A)") "* Test output: prc_recola_1"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    counter  = 1
    call rclwrap_set_on_shell_scheme ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- at leading order"
    call rclwrap_define_process (counter, 'e+ e- -> mu+ mu-', 'LO')
    write (u, "(A)") "* RECOLA: generate process"
    call rclwrap_generate_processes ()
    call rclwrap_compute_process (1, p, 'LO')
    allocate (hel_recola (4), col_recola (4))
    col_recola = [0,0,0,0]

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega1"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega1_a"), 1, data, driver) 
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       do i = 1, 6
          call rclwrap_get_amplitude (1, 0, 'LO', col_recola, helicities (i, :), amp_recola)
       end do
       do i = 1, 16
           call rclwrap_get_amplitude (1, 0, 'LO', col_recola, data%hel_state (:,i), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,4(I2),A)") "Helicity: [",data%hel_state (:,i),"]"
           call assert_equal (u, amp, amp_recola) ! , "Helicity:", data%hel_state (:,i))
       end do
       
    end select
    
    call rclwrap_reset
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_1"

    
  end subroutine prc_recola_1

@ %def prc_recola_1
@
\subsubsection{Testing a fixed flavor matrix element computation for 2->3}
<<prc recola: execute tests>>=
  call test (prc_recola_2, "prc_recola_2", &
       "Registering a RECOLA process and computing the amplitude for 2->3 process", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_2
<<prc recola: tests>>=
  subroutine prc_recola_2 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:5)
    real(double) :: sqrts = 700._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    integer, dimension(:,:), allocatable :: helicities
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    integer :: n_allowed
    
    logical(c_bool) :: flag
    
    write (u, "(A)") "* Test output: prc_recola_2"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega for 2->3 process"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
   ! p_z_out = 90._double 
   ! p_y_out = sqrts / 10._default
   ! p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - (p_z_out/3)**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [243.49323116_double, -141.69619338_double, -108.30640321_double,  165.77353656_double]
    p(:,4) = [337.53250628_double,  143.95931207_double,  110.19717026_double, -284.71124482_double]
    p(:,5) = [118.97426257_double, -2.2631186860_double, -1.8907670459_double,  118.93770827_double]
    
   ! 11   0.0000000000E+00  0.0000000000E+00  3.5000000000E+02  3.5000000000E+02
   !-11   0.0000000000E+00  0.0000000000E+00 -3.5000000000E+02  3.5000000000E+02
   ! 13  -1.4169619338E+02 -1.0830640321E+02  1.6577353656E+02  2.4349323116E+02
   !-13   1.4395931207E+02  1.1019717026E+02 -2.8471124482E+02  3.3753250628E+02
   ! 22  -2.2631186860E+00 -1.8907670459E+00  1.1893770827E+02  1.1897426257E+02

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 5
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    call rclwrap_set_on_shell_scheme ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- A at leading order"
    call rclwrap_define_process (2, 'e+ e- -> mu+ mu- A', 'LO')
    write (u, "(A)") "* RECOLA: generate process"
    call rclwrap_generate_processes ()
    call rclwrap_compute_process (2, p, 'LO')
    call rclwrap_get_helicity_configurations (2, helicities)
    
    allocate (hel_recola (5), col_recola (5))
    col_recola = [0,0,0,0,0]
    

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega2"))
    allocate (prt_in (2), prt_out (3))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-"), var_str("A")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega2_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 3, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega2_a"), 1, data, driver) 
    
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       do i = 1, 32
           call rclwrap_get_amplitude (2, 0, 'LO', col_recola, helicities (i, :), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,5(I2),A)") "O'MEGA Helicity:[", data%hel_state (:,i),"]"
           write(u,"(A,5(I2),A)") "RECOLA Helicity: [", helicities (i,:),"]"
           write(u,"(A,2(F12.7,1x),A,2(F12.7,1x))") "RECOLA:", amp_recola,", O'MEGA:", amp
           call assert_equal (u, amp, amp_recola)
       end do
       
    end select
    
    call rclwrap_reset ()
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_2"
    
  end subroutine prc_recola_2
@ %def prc_recola_2
@
<<prc recola: execute tests>>=
  call test (prc_recola_3, "prc_recola_2", &
       "Registering a RECOLA process and computing the amplitude for 2->3 process", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_3
<<prc recola: tests>>=
  subroutine prc_recola_3 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_quark = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter
    real(double) :: sqme
    integer :: i
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    integer, dimension(:,:), allocatable :: helicities
    integer, dimension(:,:), allocatable :: colors, col_recola
    
    write (u, "(A)") "* Test output: prc_recola_3"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega for a colored process"
    write (u, "(A)")  
        
    p_z_in = sqrts / 2
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    call rclwrap_set_on_shell_scheme ()
    write (u, "(A)") "*  RECOLA: Define process u u~ -> g at leading order"
    call rclwrap_define_process (1, 'u u~ -> g g', 'LO')
    write (u, "(A)") "* RECOLA: generate process"
    call rclwrap_generate_processes ()
    call rclwrap_get_helicity_configurations (1, helicities)
    call rclwrap_get_colour_configurations (1, colors)
    print *, 'Number of helicities: ', size (helicities, dim=1)
    do i = 1, size (helicities, dim=1)
       print *, 'hel: ', helicities (i, :)
    end do
    do i = 1, size (colors, dim=1)
       print *, 'col: ', colors (i, :)
    end do
    call rclwrap_compute_process (1, p, 'LO')

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega3"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("u"), var_str ("ubar")]
    prt_out = [var_str ("g"), var_str ("g")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega3_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega3_a"), 1, data, driver) 
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (get_omega_parameter_array (), 0)
       call driver%new_event (p)
       !do i = 1, 16
           !call get_amplitude_rcl (1, 0, 'LO', col_recola, data%hel_state (:,i), amp_recola)
           !amp_recola = amp_recola * cmplx (0, -1, default) 
           !call driver%get_amplitude (1, i, 1, amp)                
           !write(u,"(A,4(I2),A)") "Helicity: [",data%hel_state (:,i),"]"
           !call assert_equal (u, amp, amp_recola) ! , "Helicity:", data%hel_state (:,i))
       !end do
       col_recola = create_recola_color_structures (data%col_state)
       print *, 'Number of colors: ', data%n_col
       do i = 1, 5
          print *, 'omega color state: ', data%col_state (:,:,i)
          print *, 'reconstructed recola state: ', col_recola (i, :)
       end do 
       
    end select
    
    call rclwrap_reset ()
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_3"

    
  end subroutine prc_recola_3

@ %def prc_recola_3
@
