% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}

The interface to Recola.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola !NODEP!
 
  use kinds
<<Use strings>>
  use constants, only: zero
  use lorentz, only: vector4_t
  use physics_defs

  use prc_core, only: prc_core_state_t
  use prc_core_def, only: prc_core_driver_t, prc_core_def_t
  use prc_user_defined, only: prc_user_defined_base_t, user_defined_def_t, &
     user_defined_driver_t
  use process_libraries, only: process_library_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ Returns the particle string corresponding to a pdg code used in the Recola
process definition
<<prc recola: procedures>>=
  elemental function get_recola_particle_string (pdg) result (name)
    type(string_t) :: name
    integer, intent(in) :: pdg
    select case (pdg)
    case (1)
       name = var_str ("d")
    case (-1) 
       name = var_str ("d~")
    case (2) 
       name = var_str ("u")
    case (-2)
       name = var_str ("u~")
    case (3)
       name = var_str ("s")
    case (-3)
       name = var_str ("s~")
    case (4)
       name = var_str ("c")
    case (-4)
       name = var_str ("c~")
    case (5)
       name = var_str ("b")
    case (-5)
       name = var_str ("b~")
    case (6)
       name = var_str ("t")
    case (-6)
       name = var_str ("t~")
    case (11)
       name = var_str ("e-")
    case (-11)
       name = var_str ("e+")
    case (12)
       name = var_str ("nu_e")
    case (-12)
       name = var_str ("nu_e~")
    case (13)
       name = var_str ("mu-")
    case (-13)
       name = var_str ("mu+")
    case (14)
       name = var_str ("nu_mu")
    case (-14)
       name = var_str ("nu_mu~")
    case (15)
       name = var_str ("tau-")
    case (-15)
       name = var_str ("tau+")
    case (16)
       name = var_str ("nu_tau")
    case (-16)
       name = var_str ("nu_tau~")
    case (21)
       name = var_str ("g")
    case (22)
       name = var_str ("A")
    case (23)
       name = var_str ("Z")
    case (24)
       name = var_str ("W+")
    case (-24)
       name = var_str ("W-")
    case (25)
       name = var_str ("H")
    end select
  end function get_recola_particle_string

@ %def get_recola_particle_string
@ 
<<prc recola: public>>=
  public :: create_recola_color_structures
<<prc recola: procedures>>=
  function create_recola_color_structures (col_omega) result (col_recola)
    integer, dimension(:,:), allocatable :: col_recola
    integer, dimension(:,:,:), intent(in) :: col_omega
    integer :: n_tot, n_flv
    integer :: i, j, i_flv
    integer, dimension(2) :: tuple1, tuple2
    n_tot = size (col_omega, dim=2)
    n_flv = size (col_omega, dim=3)
    allocate (col_recola (n_flv, n_tot))
    do i_flv = 1, n_flv
       col_recola (:,i_flv) = 0
       do i = 1, n_tot
          tuple1 = col_omega (:,i,i_flv)
          do j = 1, n_tot
             tuple2 = col_omega (:,j,i_flv)
             if (tuple1(1) /= 0) then
                if (tuple1(1) == -tuple2(j)) then
                   col_recola(i_flv,i) = j
                   exit
                end if 
             end if
          end do
       end do 
    end do
  end function create_recola_color_structures 

@ %def create_recola_color_structures
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
     integer :: recola_id = 0
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@
<<prc recola: public>>=
  public :: recola_def_t
<<prc recola: types>>=
  type, extends (user_defined_def_t) :: recola_def_t
    type(string_t) :: suffix 
  contains
  <<prc recola: recola def: TBP>>
  end type recola_def_t

@ %def recola_def_t
@ A core driver is required by design. However, it is only a dummy
because we are not going to load any external dynamical libraries.
<<prc recola: types>>=
  type, extends (user_defined_driver_t) :: recola_driver_t
  contains
  <<prc recola: recola driver: TBP>>
  end type recola_driver_t

@ %def recola_driver_t
@ Recola can compute dressed amplitudes, but it needs helicity and color
to be in its own format to do so. 
<<prc recola: prc recola: TBP>>=
  procedure :: replace_helicity_and_color_arrays => &
     prc_recola_replace_helicity_and_color_arrays
<<prc recola: procedures>>=
  subroutine prc_recola_replace_helicity_and_color_arrays (object)
    class(prc_recola_t), intent(inout) :: object
    deallocate (object%data%hel_state)
    call get_helicity_configurations_rcl (object%recola_id, object%data%hel_state)
    !!! TODO (cw-2016-08-08): Adapt color array, problem: different rank
  end subroutine prc_recola_replace_helicity_and_color_arrays

@ %def prc_recola_replace_helicity_and_color_arrays
@
<<prc recola: prc recola: TBP>>=
  procedure :: register_processes => prc_recola_register_processes
<<prc recola: procedures>>=
  subroutine prc_recola_register_processes (object, recola_id)
    class(prc_recola_t), intent(inout) :: object
    integer, intent(inout) :: recola_id
    type(string_t), dimension(:), allocatable :: particle_names
    type(string_t) :: process_string
    integer :: i_flv, i_part
    integer :: n_tot
    !!! TODO (cw-2016-08-08): Include amplitude type (LO, NLO, ...)
    !!! TODO (cw-2016-08-08): Include helicities 
    n_tot = object%data%n_in + object%data%n_out
    allocate (particle_names (n_tot))
    do i_flv = 1, object%data%n_flv 
       recola_id = recola_id + 1
       object%recola_id = recola_id
       particle_names = get_recola_particle_string (object%data%flv_state (:, i_flv))
       process_string = var_str ("")
       do i_part = 1, n_tot
          print *, 'Appending particle: ', char (particle_names(i_part))
          process_string = process_string // particle_names (i_part) // var_str (" ")
          if (i_part == object%data%n_in) &
             process_string = process_string // var_str ("-> ")
       end do
       call define_process_rcl (object%recola_id, char (process_string), 'LO')
       call generate_processes_rcl ()
    end do
  end subroutine prc_recola_register_processes

@ %def prc_recola_register_processes 
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    amp = zero
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@
<<prc recola: recola def: TBP>>=
  procedure :: init => recola_def_init
<<prc recola: procedures>>=
  subroutine recola_def_init (object, basename, nlo_type)
    class(recola_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename
    integer, intent(in) :: nlo_type
    object%basename = basename
    select case (nlo_type)
    case (BORN)
       object%suffix = '_BORN'
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    case (NLO_MISMATCH)
       object%suffix = '_MISMATCH'
    case (NLO_DGLAP)
       object%suffix = '_DGLAP'
    end select
  end subroutine recola_def_init

@ %def recola_def_init
@
<<prc recola: recola def: TBP>>=
  procedure :: allocate_driver => recola_def_allocate_driver
<<prc recola: procedures>>=
  subroutine recola_def_allocate_driver (object, driver, basename)
    class(recola_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (recola_driver_t :: driver)
  end subroutine recola_def_allocate_driver

@ %def recola_def_allocate_driver
@
<<prc recola: recola def: TBP>>=
  procedure :: read => recola_def_read
<<prc recola: procedures>>=
  subroutine recola_def_read (object, unit)
    class(recola_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_read

@ %def recola_def_read
@
<<prc recola: recola def: TBP>>=
  procedure, nopass :: type_string => recola_def_type_string
<<prc recola: procedures>>=
  function recola_def_type_string () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_def_type_string

@ %def recola_def_type_string
@  
<<prc recola: recola def: TBP>>=
  procedure :: write => recola_def_write
<<prc recola: procedures>>=
  subroutine recola_def_write (object, unit)
    class(recola_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_write

@ %def recola_def_write
@
<<prc recola: recola driver: TBP>>=
  procedure, nopass :: type_name => recola_driver_type_name
<<prc recola: procedures>>=
  function recola_driver_type_name () result (type)
    type(string_t) :: type
    type = "Recola"
  end function recola_driver_type_name

@ %def recola_driver_type_name
@
\subsection{Unit tests}
<<[[prc_recola_ut.f90]]>>=
<<File header>>

module prc_recola_ut
  use unit_tests
  use prc_recola_uti

<<Standard module head>>

<<prc recola: public tests>>

contains

<<prc recola: test driver>>

end module prc_recola_ut
@ %def prc_recola_ut
@
<<[[prc_recola_uti.f90]]>>=
<<File header>>

module prc_recola_uti

  use, intrinsic :: iso_c_binding !NODEP!
  use recola !NODEP!
  use kinds
<<Use strings>>

  use constants
  use format_utils, only: write_separator
  use numeric_utils, only: assert_equal
  use os_interface
  use particle_specifiers, only: new_prt_spec
  use prc_core_def
  use process_constants
  use process_libraries
  use prc_core

  use prc_omega
  
<<Standard module head>>

<<prc recola: test declarations>>

contains

<<prc recola: tests>>

end module prc_recola_uti

@ %def prc_recola_uti
@
<<prc recola: public tests>>=
  public :: prc_recola_test
<<prc recola: test driver>>=
  subroutine prc_recola_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<prc recola: execute tests>>
  end subroutine prc_recola_test
  
@ %def prc_recola_test
@
\subsubsection{Testing a fixed flavor matrix element computation}
<<prc recola: execute tests>>=
  call test (prc_recola_1, "prc_recola_1", &
       "Registering a RECOLA process and computing the amplitude", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_1
<<prc recola: tests>>=
  subroutine prc_recola_1 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    real(default), dimension(25) :: omega_parameters
    
    omega_parameters(1:25) = zero
    
    omega_parameters(1) = 1.16637d-5 ! gf
    omega_parameters(2) = 91.153480619182744_default ! mZ
    omega_parameters(3) = 80.357973609877547_default ! mW
    omega_parameters(4) = 125._default ! mH
    call get_alphas_rcl (omega_parameters(5)) ! aplha_s
    omega_parameters(12) = 173.2_default ! mt
    omega_parameters(14) = 2.4942663787728243_default ! wZ
    omega_parameters(15) = 2.0842989982782196_default ! wW
    omega_parameters(22) = one / sqrt (sqrt (two) * omega_parameters(1)) ! par%v - Higgs expectation value
    omega_parameters(23) = omega_parameters(3) / omega_parameters(2) ! par%cw
    omega_parameters(24) = sqrt (one - omega_parameters(23)**2) ! par%sw
    omega_parameters(25) = two * omega_parameters(24) * omega_parameters(3) / omega_parameters(22) 

    
    write (u, "(A)") "* Test output: prc_recola_1"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    counter  = 1
    call set_on_shell_scheme_rcl ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- at leading order"
    call define_process_rcl (counter,'e+ e- -> mu+ mu-','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call compute_process_rcl (1,p,'LO')
    allocate (hel_recola (4), col_recola (4))
    col_recola = [0,0,0,0]

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega1"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega1_a"), 1, data, driver) 
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (omega_parameters, 0)
       call driver%new_event (p)
       do i = 1, 16
           call get_amplitude_rcl (1, 0, 'LO', col_recola, data%hel_state (:,i), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,4(I2),A)") "Helicity: [",data%hel_state (:,i),"]"
           call assert_equal (u, amp, amp_recola) ! , "Helicity:", data%hel_state (:,i))
       end do
       
    end select
    
    call reset_recola_rcl
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_1"

    
  end subroutine prc_recola_1

@ %def prc_recola_1
@
\subsubsection{Testing a fixed flavor matrix element computation for 2->3}
<<prc recola: execute tests>>=
  call test (prc_recola_2, "prc_recola_2", &
       "Registering a RECOLA process and computing the amplitude for 2->3 process", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_2
<<prc recola: tests>>=
  subroutine prc_recola_2 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:5)
    real(double) :: sqrts = 700._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    integer, dimension(:,:), allocatable :: helicities
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    real(default), dimension(25) :: omega_parameters
    
    omega_parameters(1:25) = zero
    
    omega_parameters(1) = 1.16637d-5 ! gf
    omega_parameters(2) = 91.153480619182744_default ! mZ
    omega_parameters(3) = 80.357973609877547_default ! mW
    omega_parameters(4) = 125._default ! mH
    call get_alphas_rcl (omega_parameters(5)) ! aplha_s
    omega_parameters(12) = 173.2_default ! mt
    omega_parameters(14) = 2.4942663787728243_default ! wZ
    omega_parameters(15) = 2.0842989982782196_default ! wW
    omega_parameters(22) = one / sqrt (sqrt (two) * omega_parameters(1)) ! par%v - Higgs expectation value
    omega_parameters(23) = omega_parameters(3) / omega_parameters(2) ! par%cw
    omega_parameters(24) = sqrt (one - omega_parameters(23)**2) ! par%sw
    omega_parameters(25) = two * omega_parameters(24) * omega_parameters(3) / omega_parameters(22) 

    
    write (u, "(A)") "* Test output: prc_recola_2"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega for 2->3 process"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
   ! p_z_out = 90._double 
   ! p_y_out = sqrts / 10._default
   ! p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - (p_z_out/3)**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [243.49323116_double, -141.69619338_double, -108.30640321_double,  165.77353656_double]
    p(:,4) = [337.53250628_double,  143.95931207_double,  110.19717026_double, -284.71124482_double]
    p(:,5) = [118.97426257_double, -2.2631186860_double, -1.8907670459_double,  118.93770827_double]
    
   ! 11   0.0000000000E+00  0.0000000000E+00  3.5000000000E+02  3.5000000000E+02
   !-11   0.0000000000E+00  0.0000000000E+00 -3.5000000000E+02  3.5000000000E+02
   ! 13  -1.4169619338E+02 -1.0830640321E+02  1.6577353656E+02  2.4349323116E+02
   !-13   1.4395931207E+02  1.1019717026E+02 -2.8471124482E+02  3.3753250628E+02
   ! 22  -2.2631186860E+00 -1.8907670459E+00  1.1893770827E+02  1.1897426257E+02

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 5
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    call set_on_shell_scheme_rcl ()
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- A at leading order"
    call define_process_rcl (2,'e+ e- -> mu+ mu- A','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call compute_process_rcl (2,p,'LO')
    call get_helicity_configurations_rcl (2, helicities)
    
    allocate (hel_recola (5), col_recola (5))
    col_recola = [0,0,0,0,0]
    

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega2"))
    allocate (prt_in (2), prt_out (3))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-"), var_str("A")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega2_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 3, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega2_a"), 1, data, driver) 
    
  
    select type (driver)
    type is (omega_driver_t)
       call driver%init (omega_parameters, 0)
       call driver%new_event (p)
       do i = 1, 32
           call get_amplitude_rcl (2, 0, 'LO', col_recola, helicities (i,:), amp_recola)
           amp_recola = amp_recola * cmplx (0, -1, default) 
           call driver%get_amplitude (1, i, 1, amp)                
           write(u,"(A,5(I2),A)") "O'MEGA Helicity:[", data%hel_state (:,i),"]"
           write(u,"(A,5(I2),A)") "RECOLA Helicity: [", helicities (i,:),"]"
           write(u,"(A,2(F12.7,1x),A,2(F12.7,1x))") "RECOLA:", amp_recola,", O'MEGA:", amp
           call assert_equal (u, amp, amp_recola)
       end do
       
    end select
    
    call reset_recola_rcl
    
    write (u, "(A)")
    write (u, "(A)") "* End of test output: prc_recola_2"
    
  end subroutine prc_recola_2
@ %def prc_recola_2
@
