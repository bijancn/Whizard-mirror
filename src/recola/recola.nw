% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}

The interface to Recola.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola !NODEP!
 
  use kinds
  use constants, only: zero
  use lorentz, only: vector4_t

  use prc_core, only: prc_core_state_t
  use prc_user_defined, only: prc_user_defined_base_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
  !!! Put attributes here if necessary
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    amp = zero
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@
