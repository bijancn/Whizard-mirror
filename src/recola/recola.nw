% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}

The interface to Recola.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola !NODEP!
 
  use kinds
  use constants, only: zero
  use lorentz, only: vector4_t

  use prc_core, only: prc_core_state_t
  use prc_user_defined, only: prc_user_defined_base_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
  !!! Put attributes here if necessary
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    amp = zero
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@
\subsection{Unit tests}
<<[[prc_recola_ut]]>>=
<<File header>>

module prc_recola_ut
  use unit_tests
  use prc_recola_uti

<<Standard module head>>

<<prc recola: public test>>

contains

<<prc recola: test driver>>

end module prc_recola_ut
@ %def prc_recola_ut
@
<<[[prc_recola_uti.f90]]>>=
<<File header>>

module prc_recola_uti

  use recola !NODEP!

<<Standard module head>>

<<prc recola: test declarations>>

contains

<<prc recola: tests>>

end module prc_recola_uti

@ %def prc_recola_uti
@
<<prc recola: public tests>>=
  public :: prc_recola_test
<<prc recola: test driver>>=
  subroutine prc_recola_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<prc recola: execute tests>>
  end subroutine prc_recola_test
  
@ %def prc_recola_test
@
\subsubsection{Testing a fixed flavor matrix element computation}
<<prc recola: execute tests>>=
  call test (prc_recola_1, "prc_recola_1", &
       "Registering a RECOLA process and computing the amplitude", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_1
<<prc recola: tests>>=
  subroutine prc_recola_1 (u) 
    integer, intent(in) :: u
    integer,  parameter :: dp = kind (23d0)
    real(dp)            :: p(0:3,1:4)
    real(dp)            :: sqrts = 500
    real(dp)            :: m_e = 0
    real(dp)            :: m_mu = 0
    real(dp)            :: p_x_out, p_y_out, p_z_out, p_z_in
    
    call set_output_file_rcl('out.txt')
    
    call define_process_rcl(1,'e+ e- -> mu+ mu-','LO') 
    call generate_processes_rcl
    
    p_z_in = SQRT((sqrts/2)**2-m_e**2)
    p_z_out = 0
    p_y_out = sqrts/10
    p_x_out = SQRT((sqrts/2)**2 - p_y_out**2 - p_z_out**2 - m_mu**2)
    p(:,1) = [sqrts/2,  0.00000000000d0,  0.00000000000d0,  p_z_in]
    p(:,2) = [sqrts/2,  0.00000000000d0,  0.00000000000d0, -p_z_in]
    p(:,3) = [sqrts/2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts/2, -p_x_out, -p_y_out, -p_z_out]
    
    call compute_process_rcl(1,p,'LO')
    call reset_recola_rcl
    
  end subroutine prc_recola_1
@ %def prc_recola_1
@
