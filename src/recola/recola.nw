% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: interface to Recola 1-loop library

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Recola Interface}

The interface to Recola.

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
<<[[prc_recola.f90]]>>=
<<File header>>

module prc_recola

  use recola !NODEP!
 
  use kinds
<<Use strings>>
  use constants, only: zero
  use lorentz, only: vector4_t
  use physics_defs

  use prc_core, only: prc_core_state_t
  use prc_core_def, only: prc_core_driver_t
  use prc_user_defined, only: prc_user_defined_base_t, user_defined_def_t, &
     user_defined_driver_t

<<Standard module head>>

<<prc recola: public>>

<<prc recola: parameters>>

<<prc recola: types>>

<<prc recola: interfaces>>

contains

<<prc recola: procedures>>

end module prc_recola
@ %def prc_recola
@ We create [[prc_recola_t]] as an extension of the [[prc_user_defined_base_t]],
which in turn inherits from [[prc_core_tt]]. This way, we can use a lot of the
existing interfaces in the actual code. However, we have to stick to the rules and
implement the deferred type-bound procedures of [[prc_core_t]].
<<prc recola: public>>=
  public :: prc_recola_t
<<prc recola: types>>=
  type, extends (prc_user_defined_base_t) :: prc_recola_t
  !!! Put attributes here if necessary
  contains
  <<prc recola: prc recola: TBP>>
  end type prc_recola_t

@ %def prc_recola_t
@
<<prc recola: public>>=
  public :: recola_def_t
<<prc recola: types>>=
  type, extends (user_defined_def_t) :: recola_def_t
    type(string_t) :: suffix 
  contains
  <<prc recola: recola def: TBP>>
  end type recola_def_t

@ %def recola_def_t
@ A core driver is required by design. However, it is only a dummy
because we are not going to load any external dynamical libraries.
<<prc recola: types>>=
  type, extends (user_defined_driver_t) :: recola_driver_t
  contains
  <<prc recola: recola driver: TBP>>
  end type recola_driver_t

@ %def recola_driver_t
@ Computes the amplitude as a function of the phase space point, the
flavor, helicity and color index. It is currently only used in thes form
by [[prc_omega_t]], all the other ones use different interfaces. However,
with RECOLA, we might be able to use this, too.
<<prc recola: prc recola: TBP>>=
  procedure :: compute_amplitude => prc_recola_compute_amplitude
<<prc recola: procedures>>=
  function prc_recola_compute_amplitude &
     (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, &
     core_state) result (amp)
    complex(default) :: amp
    class(prc_recola_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), intent(in), dimension(:) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: &
       core_state
    amp = zero
  end function prc_recola_compute_amplitude

@ %def prc_recola_compute_amplitude
@ Every object of the [[prc_core_t]] class has a write subroutine which
prints out information about the current state of the object.
<<prc recola: prc recola: TBP>>=
  procedure :: write => prc_recola_write
<<prc recola: procedures>>=
  subroutine prc_recola_write (object, unit)
    class(prc_recola_t), intent(in) :: object
    integer, intent(in), optional :: unit
  end subroutine prc_recola_write

@ %def prc_recola_write
@
<<prc recola: recola def: TBP>>=
  procedure :: init => recola_def_init
<<prc recola: procedures>>=
  subroutine recola_def_init (object, basename, nlo_type)
    class(recola_def_t), intent(inout) :: object
    type(string_t), intent(in) :: basename
    integer, intent(in) :: nlo_type
    object%basename = basename
    select case (nlo_type)
    case (BORN)
       object%suffix = '_BORN'
    case (NLO_REAL)
       object%suffix = '_REAL'
    case (NLO_VIRTUAL)
       object%suffix = '_LOOP'
    case (NLO_SUBTRACTION)
       object%suffix = '_SUB'
    case (NLO_MISMATCH)
       object%suffix = '_MISMATCH'
    case (NLO_DGLAP)
       object%suffix = '_DGLAP'
    end select
  end subroutine recola_def_init

@ %def recola_def_init
@
<<prc recola: recola def: TBP>>=
  procedure :: allocate_driver => recola_def_allocate_driver
<<prc recola: procedures>>=
  subroutine recola_def_allocate_driver (object, driver, basename)
    class(recola_def_t), intent(in) :: object
    class(prc_core_driver_t), intent(out), allocatable :: driver
    type(string_t), intent(in) :: basename
    if (.not. allocated (driver)) allocate (recola_driver_t :: driver)
  end subroutine recola_def_allocate_driver

@ %def recola_def_allocate_driver
@
<<prc recola: recola def: TBP>>=
  procedure :: read => recola_def_read
<<prc recola: procedures>>=
  subroutine recola_def_read (object, unit)
    class(recola_def_t), intent(out) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_read

@ %def recola_def_read
@
<<prc recola: recola def: TBP>>=
  procedure, nopass :: type_string => recola_def_type_string
<<prc recola: procedures>>=
  function recola_def_type_string () result (string)
    type(string_t) :: string
    string = "recola"
  end function recola_def_type_string

@ %def recola_def_type_string
@  
<<prc recola: recola def: TBP>>=
  procedure :: write => recola_def_write
<<prc recola: procedures>>=
  subroutine recola_def_write (object, unit)
    class(recola_def_t), intent(in) :: object
    integer, intent(in) :: unit
  end subroutine recola_def_write

@ %def recola_def_write
@
<<prc recola: recola driver: TBP>>=
  procedure, nopass :: type_name => recola_driver_type_name
<<prc recola: procedures>>=
  function recola_driver_type_name () result (type)
    type(string_t) :: type
    type = "Recola"
  end function recola_driver_type_name

@ %def recola_driver_type_name
@
\subsection{Unit tests}
<<[[prc_recola_ut.f90]]>>=
<<File header>>

module prc_recola_ut
  use unit_tests
  use prc_recola_uti

<<Standard module head>>

<<prc recola: public tests>>

contains

<<prc recola: test driver>>

end module prc_recola_ut
@ %def prc_recola_ut
@
<<[[prc_recola_uti.f90]]>>=
<<File header>>

module prc_recola_uti

  use recola !NODEP!
  use kinds
<<Use strings>>

  use format_utils, only: write_separator
  use os_interface
  use particle_specifiers, only: new_prt_spec
  use prc_core_def
  use process_constants
  use process_libraries
  use prc_core

  use prc_omega
  
<<Standard module head>>

<<prc recola: test declarations>>

contains

<<prc recola: tests>>

end module prc_recola_uti

@ %def prc_recola_uti
@
<<prc recola: public tests>>=
  public :: prc_recola_test
<<prc recola: test driver>>=
  subroutine prc_recola_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<prc recola: execute tests>>
  end subroutine prc_recola_test
  
@ %def prc_recola_test
@
\subsubsection{Testing a fixed flavor matrix element computation}
<<prc recola: execute tests>>=
  call test (prc_recola_1, "prc_recola_1", &
       "Registering a RECOLA process and computing the amplitude", &
       u, results)
<<prc recola: test declarations>>=
  public :: prc_recola_1
<<prc recola: tests>>=
  subroutine prc_recola_1 (u) 
    integer, intent(in) :: u
    real(double) :: p(0:3,1:4)
    real(double) :: sqrts = 500._double
    real(double) :: m_e = 0._double
    real(double) :: m_mu = 0._double
    real(double) :: p_x_out, p_y_out, p_z_out, p_z_in
    integer      :: h_e_p, h_e_m, h_mu_p, h_mu_m, counter

    real(double) :: sqme
    integer :: i
    integer, dimension(:), allocatable :: col_recola, hel_recola
    complex(double) :: amp_recola

    real(default), parameter :: ee = 0.3 !!! Electromagnetic coupling

    type(process_library_t) :: lib
    class(prc_core_def_t), allocatable :: def
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(os_data_t) :: os_data
    type(process_constants_t) :: data
    class(prc_core_driver_t), allocatable :: driver
    complex(default) :: amp
    
    write (u, "(A)") "* Test output: prc_recola_1"
    write (u, "(A)") "* Purpose: Test interface to RECOLA and compare matrix elements with O'Mega"
    write (u, "(A)")  
        
    p_z_in = sqrt ((sqrts / 2)**2 - m_e**2)
    p_z_out = 0._double 
    p_y_out = sqrts / 10._default
    p_x_out = sqrt ((sqrts / 2)**2 - p_y_out**2 - p_z_out**2 - m_mu**2)
    p(:,1) = [sqrts / 2,  0._double,  0._double,  p_z_in]
    p(:,2) = [sqrts / 2,  0._double,  0._double, -p_z_in]
    p(:,3) = [sqrts / 2,  p_x_out,  p_y_out,  p_z_out]
    p(:,4) = [sqrts / 2, -p_x_out, -p_y_out, -p_z_out]

    write (u, "(A)") "Use phase-space point: "
    do i = 1, 4
       write (u, "(4(F12.3,1x))") p(:,1)
    end do
    write (u, "(A)")
    call write_separator (u) 
    write (u, "(A)")
    write (u, "(A)") "* RECOLA: Evaluate process"
    counter  = 1
    write (u, "(A)") "*  RECOLA: Define process e+ e- -> mu+ mu- at leading order"
    call define_process_rcl (counter,'e+ e- -> mu+ mu-','LO')
    write (u, "(A)") "* RECOLA: generate process"
    call generate_processes_rcl ()
    call compute_process_rcl (1,p,'LO')
    do h_e_p = -1, 1, 2
        do h_e_m = -1, 1, 2
            do h_mu_p = -1, 1, 2
                do h_mu_m = -1, 1, 2
                    hel_recola = [h_e_p, h_e_m, h_mu_p, h_mu_m]
                    call get_amplitude_rcl (1, 0, 'LO', col_recola, hel_recola, amp_recola)
                    print *, 'amp - recola: ', amp_recola
                    write (u, "(A,1x,F12.3)") "Amplitude: ", amp_recola
                end do    
            end do
        end do
    end do
    write (u, "(A)") "* RECOLA: Get squared amplitude"
    call get_squared_amplitude_rcl (1,0,'LO',sqme)
    write (u, "(A,1x,F12.3)") "Result: ", sqme
    write (u, "(A)") "* RECOLA: Get amplitude h = 1, c = 1"
    allocate (hel_recola (4), col_recola (4))
    hel_recola = [1,1,1,1]; col_recola = [0,0,0,0]
    ! call get_amplitude_rcl (1, 0, 'LO', col_recola, hel_recola, amp_recola)
    ! print *, 'amp - recola: ', amp_recola
    call reset_recola_rcl ()
    

    write (u, "(A)") "* Setting up Omega to compute the same amplitude"

    call lib%init (var_str ("omega1"))
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("mu+"), var_str ("mu-")]

    allocate (omega_omega_def_t :: def)
    select type (def)
    type is (omega_omega_def_t)
       call def%init (var_str ("SM"), prt_in, prt_out)
    end select      
 
    allocate (entry)
    call entry%init (var_str ("omega1_a"), model_name = var_str ("SM"), &
       n_in = 2, n_components = 1)
    call entry%import_component (1, n_out = 2, &
         prt_in  = new_prt_spec (prt_in), & 
         prt_out = new_prt_spec (prt_out), &
         method  = var_str ("omega"), &
         variant = def)
    call lib%append (entry)

    call os_data_init (os_data)
    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    call lib%connect_process (var_str ("omega1_a"), 1, data, driver) 
    do i = 1, size (data%hel_state (1, :))
       print *, 'helicity: ', data%hel_state (:, i)
    end do

    select type (driver)
    type is (omega_driver_t)
       call driver%init ([ee, 0._default, 0._default, 0._default], 0)
       call driver%new_event (p)
       call driver%get_amplitude (1, 1, 1, amp)
    end select 
    
    print *, "amp - omega: ", amp
    write (u, "(A)") "* End of test output: prc_recola_1"
    
  end subroutine prc_recola_1
@ %def prc_recola_1
@
