% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*-
% WHIZARD code as NOWEB source: Matching and Merging
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Matching}

<<[[matching_base.f90]]>>=
<<File header>>

module matching_base

<<Use strings>>
  use diagnostics
  use sm_qcd
  use model_data
  use particles
  use variables
  use shower_base
  use processes
  use rng_base

<<Standard module head>>

<<Matching base: public>>

<<Matching base: parameters>>

<<Matching base: types>>

<<Matching base: interfaces>>

contains

<<Matching base: procedures>>

end module matching_base
@ %def matching_base
@
\section{Abstract Matching Type}
A matching will need access to the [[shower]] as well as matrix elements
that we currently get over [[process_instace]].  The [[model]] is
intended for the backup [[model_hadrons]].
<<Matching base: public>>=
  public :: matching_t
<<Matching base: types>>=
  type, abstract :: matching_t
    logical :: is_hadron_collision = .false.
    type(qcd_t), pointer :: qcd => null ()
    class(shower_base_t), pointer :: shower => null ()
    type(process_instance_t), pointer :: process_instance => null ()
    class(model_data_t), pointer :: model => null ()
    class(rng_t), allocatable :: rng
    type(string_t) :: process_name
   contains
   <<Matching base: matching: TBP>>
  end type matching_t

@ %def matching_t
@
<<Matching base: matching: TBP>>=
  procedure (matching_init), deferred :: init
<<Matching base: interfaces>>=
  abstract interface
     subroutine matching_init (matching, var_list, process_name)
       import
       class(matching_t), intent(out) :: matching
       type(var_list_t), intent(in) :: var_list
       type(string_t), intent(in) :: process_name
     end subroutine matching_init
  end interface

@ %def matching_init
@ If we use a polymorphic settings type, this boilerplate wouldn't be
necessary but then we introduce [[select type]] statements all over the place.
<<default matching init>>=
  type(var_list_t), intent(in) :: var_list
  type(string_t), intent(in) :: process_name
  call msg_debug (D_MATCHING, "matching_init")
  call matching%settings%init (var_list)
  matching%process_name = process_name
@
<<Matching base: matching: TBP>>=
  procedure (matching_write), deferred :: write
<<Matching base: interfaces>>=
  abstract interface
     subroutine matching_write (matching, unit)
       import
       class(matching_t), intent(in) :: matching
       integer, intent(in), optional :: unit
     end subroutine matching_write
  end interface

@ %def matching_write
@
<<Matching base: matching: TBP>>=
  procedure :: import_rng => matching_import_rng
<<Matching base: procedures>>=
  pure subroutine matching_import_rng (matching, rng)
    class(matching_t), intent(inout) :: matching
    class(rng_t), allocatable, intent(inout) :: rng
    call move_alloc (from = rng, to = matching%rng)
  end subroutine matching_import_rng

@ %def matching_import_rng
@
<<Matching base: matching: TBP>>=
  procedure :: connect => matching_connect
  procedure :: base_connect => matching_connect
<<Matching base: procedures>>=
  subroutine matching_connect (matching, process_instance, model, shower)
    class(matching_t), intent(inout) :: matching
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    class(shower_base_t), intent(in), target :: shower
    call msg_debug (D_MATCHING, "matching_connect")
    matching%process_instance => process_instance
    matching%model => model
    matching%shower => shower
  end subroutine matching_connect

@ %def matching_base_connect
@
<<Matching base: matching: TBP>>=
  procedure (matching_before_shower), deferred :: before_shower
<<Matching base: interfaces>>=
  abstract interface
     subroutine matching_before_shower (matching, particle_set, vetoed)
       import
       class(matching_t), intent(inout) :: matching
       type(particle_set_t), intent(inout) :: particle_set
       logical, intent(out) :: vetoed
     end subroutine matching_before_shower
  end interface

@ %def matching_before_shower
@
<<Matching base: matching: TBP>>=
  procedure (matching_after_shower), deferred :: after_shower
<<Matching base: interfaces>>=
  abstract interface
     subroutine matching_after_shower (matching, particle_set, vetoed)
       import
       class(matching_t), intent(inout) :: matching
       type(particle_set_t), intent(inout) :: particle_set
       logical, intent(out) :: vetoed
     end subroutine matching_after_shower
  end interface

@ %def matching_after_shower
@ Per default, do nothing here.
<<Matching base: matching: TBP>>=
  procedure :: prepare_for_events => matching_prepare_for_events
<<Matching base: procedures>>=
  subroutine matching_prepare_for_events (matching)
    class(matching_t), intent(inout), target :: matching
  end subroutine matching_prepare_for_events

@ %def matching_prepare_for_events
@
<<Matching base: matching: TBP>>=
  procedure :: first_event => matching_first_event
<<Matching base: procedures>>=
  subroutine matching_first_event (matching)
    class(matching_t), intent(inout), target :: matching
  end subroutine matching_first_event

@ %def matching_first_event
@
<<Matching base: matching: TBP>>=
  procedure (matching_get_method), deferred :: get_method
<<Matching base: interfaces>>=
  abstract interface
     function matching_get_method (matching) result (method)
       import
       type(string_t) :: method
       class(matching_t), intent(in) :: matching
     end function matching_get_method
  end interface

@ %def matching_after_shower
@
<<Matching base: matching: TBP>>=
  procedure :: final => matching_final
<<Matching base: procedures>>=
  subroutine matching_final (matching)
    class(matching_t), intent(in) :: matching
  end subroutine matching_final

@ %def matching_final
@
\subsection{Matching implementations}
<<Matching base: public>>=
  public :: MATCH_MLM, MATCH_CKKW, MATCH_POWHEG
<<Matching base: parameters>>=
  integer, parameter :: MATCH_MLM = 1
  integer, parameter :: MATCH_CKKW = 2
  integer, parameter :: MATCH_POWHEG = 3
  integer, parameter :: MATCH_UNDEFINED = 17
@ %def MATCH_MLM MATCH_CKKW MATCH_POWHEG MATCH_UNDEFINED
@ A dictionary
<<Matching base: public>>=
  public :: matching_method
<<Matching base: interfaces>>=
  interface matching_method
     module procedure matching_method_of_string
     module procedure matching_method_to_string
  end interface
<<Matching base: procedures>>=
  elemental function matching_method_of_string (string) result (i)
    integer :: i
    type(string_t), intent(in) :: string
    select case (char (string))
    case ("MLM")
       i = MATCH_MLM
    case ("CKKW")
       i = MATCH_CKKW
    case ("POWHEG")
       i = MATCH_POWHEG
    case default
       i = MATCH_UNDEFINED
    end select
  end function matching_method_of_string

  elemental function matching_method_to_string (i) result (string)
    type(string_t) :: string
    integer, intent(in) :: i
    select case (i)
    case (MATCH_MLM)
       string = "MLM"
    case (MATCH_CKKW)
       string = "CKKW"
    case (MATCH_POWHEG)
       string = "POWHEG"
    case default
       string = "UNDEFINED"
    end select
  end function matching_method_to_string

@ %def matching_method
@
\section{MLM Matching}
<<[[mlm_matching.f90]]>>=
<<File header>>

module mlm_matching

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use constants
  use format_utils, only: write_separator
  use diagnostics
  use file_utils
  use lorentz
  use subevents, only: PRT_OUTGOING
  use particles
  use variables
  use shower_base
  use ktclus
  use matching_base

<<Standard module head>>

<<MLM matching: public>>

<<MLM matching: types>>

contains

<<MLM matching: procedures>>

end module mlm_matching
@ %def mlm_matching
@
<<MLM matching: public>>=
  public :: mlm_matching_settings_t
<<MLM matching: types>>=
  type :: mlm_matching_settings_t
     real(default) :: mlm_Qcut_ME = one
     real(default) :: mlm_Qcut_PS = one
     real(default) :: mlm_ptmin, mlm_etamax, mlm_Rmin, mlm_Emin
     real(default) :: mlm_ETclusfactor = 0.2_default
     real(default) :: mlm_ETclusminE = five
     real(default) :: mlm_etaclusfactor = one
     real(default) :: mlm_Rclusfactor = one
     real(default) :: mlm_Eclusfactor = one
     integer :: kt_imode_hadronic = 4313
     integer :: kt_imode_leptonic = 1111
     integer :: mlm_nmaxMEjets = 0
   contains
   <<MLM matching: mlm matching settings: TBP>>
  end type mlm_matching_settings_t

@ %def mlm_matching_settings_t
@
<<MLM matching: mlm matching settings: TBP>>=
  procedure :: init => mlm_matching_settings_init
<<MLM matching: procedures>>=
  subroutine mlm_matching_settings_init (settings, var_list)
    class(mlm_matching_settings_t), intent(out) :: settings
    type(var_list_t), intent(in) :: var_list
    settings%mlm_Qcut_ME = &
         var_list%get_rval (var_str ("mlm_Qcut_ME"))
    settings%mlm_Qcut_PS = &
         var_list%get_rval (var_str ("mlm_Qcut_PS"))
    settings%mlm_ptmin = &
         var_list%get_rval (var_str ("mlm_ptmin"))
    settings%mlm_etamax = &
         var_list%get_rval (var_str ("mlm_etamax"))
    settings%mlm_Rmin = &
         var_list%get_rval (var_str ("mlm_Rmin"))
    settings%mlm_Emin = &
         var_list%get_rval (var_str ("mlm_Emin"))
    settings%mlm_nmaxMEjets = &
         var_list%get_ival (var_str ("mlm_nmaxMEjets"))

    settings%mlm_ETclusfactor = &
         var_list%get_rval (var_str ("mlm_ETclusfactor"))
    settings%mlm_ETclusminE = &
         var_list%get_rval (var_str ("mlm_ETclusminE"))
    settings%mlm_etaclusfactor = &
         var_list%get_rval (var_str ("mlm_etaclusfactor"))
    settings%mlm_Rclusfactor = &
         var_list%get_rval (var_str ("mlm_Rclusfactor"))
    settings%mlm_Eclusfactor = &
         var_list%get_rval (var_str ("mlm_Eclusfactor"))
  end subroutine mlm_matching_settings_init

@ %def mlm_matching_settings_init
@
<<MLM matching: mlm matching settings: TBP>>=
  procedure :: write => mlm_matching_settings_write
<<MLM matching: procedures>>=
  subroutine mlm_matching_settings_write (settings, unit)
    class(mlm_matching_settings_t), intent(in) :: settings
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3x,A,ES19.12)") &
         "mlm_Qcut_ME                  = ", settings%mlm_Qcut_ME
    write (u, "(3x,A,ES19.12)") &
         "mlm_Qcut_PS                  = ", settings%mlm_Qcut_PS
    write (u, "(3x,A,ES19.12)") &
         "mlm_ptmin                    = ", settings%mlm_ptmin
    write (u, "(3x,A,ES19.12)") &
         "mlm_etamax                   = ", settings%mlm_etamax
    write (u, "(3x,A,ES19.12)") &
         "mlm_Rmin                     = ", settings%mlm_Rmin
    write (u, "(3x,A,ES19.12)") &
         "mlm_Emin                     = ", settings%mlm_Emin
    write (u, "(3x,A,1x,I0)") &
         "mlm_nmaxMEjets               = ", settings%mlm_nmaxMEjets
    write (u, "(3x,A,ES19.12)") &
         "mlm_ETclusfactor  (D=0.2)    = ", settings%mlm_ETclusfactor
    write (u, "(3x,A,ES19.12)") &
         "mlm_ETclusminE    (D=5.0)    = ", settings%mlm_ETclusminE
    write (u, "(3x,A,ES19.12)") &
         "mlm_etaclusfactor (D=1.0)    = ", settings%mlm_etaClusfactor
    write (u, "(3x,A,ES19.12)") &
         "mlm_Rclusfactor   (D=1.0)    = ", settings%mlm_RClusfactor
    write (u, "(3x,A,ES19.12)") &
         "mlm_Eclusfactor   (D=1.0)    = ", settings%mlm_EClusfactor
  end subroutine mlm_matching_settings_write

@ %def mlm_matching_settings_write
@ This is a container for the (colored) parton momenta as well as the
jet momenta.
<<MLM matching: public>>=
  public :: mlm_matching_t
<<MLM matching: types>>=
  type, extends (matching_t) :: mlm_matching_t
     type(vector4_t), dimension(:), allocatable, public :: P_ME
     type(vector4_t), dimension(:), allocatable, public :: P_PS
     type(vector4_t), dimension(:), allocatable, private :: JETS_ME
     type(vector4_t), dimension(:), allocatable, private :: JETS_PS
     type(mlm_matching_settings_t) :: settings
   contains
   <<MLM matching: mlm matching: TBP>>
  end type mlm_matching_t

@ %def mlm_matching_t
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: init => mlm_matching_init
<<MLM matching: procedures>>=
  subroutine mlm_matching_init (matching, var_list, process_name)
    class(mlm_matching_t), intent(out) :: matching
  <<default matching init>>
  end subroutine mlm_matching_init

@ %def mlm_matching_init
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: write => mlm_matching_write
<<MLM matching: procedures>>=
  subroutine mlm_matching_write (matching, unit)
    class(mlm_matching_t), intent(in) :: matching
    integer, intent(in), optional :: unit
    integer :: i, u
    u = given_output_unit (unit);  if (u < 0)  return

    write (u, "(1x,A)") "MLM matching:"
    call matching%settings%write (u)
    write (u, "(3x,A)") "Momenta of ME partons:"
    if (allocated (matching%P_ME)) then
       do i = 1, size (matching%P_ME)
          write (u, "(4x)", advance = "no")
          call vector4_write (matching%P_ME(i), unit = u)
       end do
    else
       write (u, "(5x,A)")  "[empty]"
    end if
    call write_separator (u)
    write (u, "(3x,A)")  "Momenta of ME jets:"
    if (allocated (matching%JETS_ME)) then
       do i = 1, size (matching%JETS_ME)
          write (u, "(4x)", advance = "no")
          call vector4_write (matching%JETS_ME(i), unit = u)
       end do
    else
       write (u, "(5x,A)")  "[empty]"
    end if
    call write_separator (u)
    write(u, "(3x,A)")  "Momenta of shower partons:"
    if (allocated (matching%P_PS)) then
       do i = 1, size (matching%P_PS)
          write (u, "(4x)", advance = "no")
          call vector4_write (matching%P_PS(i), unit = u)
       end do
    else
       write (u, "(5x,A)")  "[empty]"
    end if
    call write_separator (u)
    write (u, "(3x,A)")  "Momenta of shower jets:"
    if (allocated (matching%JETS_PS)) then
       do i = 1, size (matching%JETS_PS)
          write (u, "(4x)", advance = "no")
          call vector4_write (matching%JETS_PS(i), unit = u)
       end do
    else
       write (u, "(5x,A)")  "[empty]"
    end if
    call write_separator (u)
  end subroutine mlm_matching_write

@ %def mlm_matching_write
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: get_method => mlm_matching_get_method
<<MLM matching: procedures>>=
  function mlm_matching_get_method (matching) result (method)
     type(string_t) :: method
     class(mlm_matching_t), intent(in) :: matching
     method = matching_method (MATCH_MLM) 
  end function mlm_matching_get_method

@ %def mlm_matching_get_method
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: before_shower => mlm_matching_before_shower
<<MLM matching: procedures>>=
  subroutine mlm_matching_before_shower &
         (matching, particle_set, vetoed)
    class(mlm_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(inout) :: particle_set
    logical, intent(out) :: vetoed
    vetoed = .false.
  end subroutine mlm_matching_before_shower

@ %def mlm_matching_before_shower
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: after_shower => mlm_matching_after_shower
<<MLM matching: procedures>>=
  subroutine mlm_matching_after_shower (matching, particle_set, vetoed)
    class(mlm_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(inout) :: particle_set
    logical, intent(out) :: vetoed
    call msg_debug (D_MATCHING, "mlm_matching_after_shower")
    call matching%shower%get_final_colored_ME_momenta (matching%P_ME)
    call matching%fill_P_PS (particle_set)
    !!! MLM stage 3 -> reconstruct and possibly reject
    call matching%apply (vetoed)
    if (allocated (matching%P_ME))  deallocate (matching%P_ME)
    if (allocated (matching%P_PS))  deallocate (matching%P_PS)
    if (allocated (matching%JETS_ME))  deallocate (matching%JETS_ME)
    if (allocated (matching%JETS_PS))  deallocate (matching%JETS_PS)
  end subroutine mlm_matching_after_shower

@ %def mlm_matching_after_shower
@ Transfer partons after parton shower to [[matching%P_PS]]
<<MLM matching: mlm matching: TBP>>=
  procedure :: fill_P_PS => mlm_matching_fill_P_PS
<<MLM matching: procedures>>=
  subroutine mlm_matching_fill_P_PS (matching, particle_set)
    class(mlm_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(in) :: particle_set
    integer :: i, j, n_jets_PS
    integer, dimension(2) :: col
    type(particle_t) :: tempprt
    real(double) :: eta
    type(vector4_t) :: p_tmp

    !!! loop over particles and extract final colored ones with eta<etamax
    n_jets_PS = 0
    do i = 1, particle_set%get_n_tot ()
       if (signal_is_pending ()) return
       tempprt = particle_set%get_particle (i)
       if (tempprt%get_status () /= PRT_OUTGOING) cycle
       col = tempprt%get_color ()
       if (all (col == 0)) cycle
! TODO: (bcn 2015-04-28) where is the corresponding part for lepton colliders?
       if (matching%is_hadron_collision) then
          p_tmp = tempprt%get_momentum ()
          if (energy (p_tmp) - longitudinal_part (p_tmp) < 1.E-10_default .or. &
               energy (p_tmp) + longitudinal_part (p_tmp) < 1.E-10_default) then
             eta = pseudorapidity (p_tmp)
          else
             eta = rapidity (p_tmp)
          end if
          if (eta > matching%settings%mlm_etaClusfactor * &
               matching%settings%mlm_etamax)  then
             if (debug_active (D_MATCHING)) then
                call msg_debug (D_MATCHING, "Rejecting this particle")
                call tempprt%write ()
             end if
             cycle
          end if
       end if
       n_jets_PS = n_jets_PS + 1
    end do

    allocate (matching%P_PS(1:n_jets_PS))
    call msg_debug (D_MATCHING, "n_jets_ps", n_jets_ps)

    j = 1
    do i = 1, particle_set%get_n_tot ()
       tempprt = particle_set%get_particle (i)
       if (tempprt%get_status () /= PRT_OUTGOING) cycle
       col = tempprt%get_color ()
       if (all(col == 0)) cycle
! TODO: (bcn 2015-04-28) where is the corresponding part for lepton colliders?
       if (matching%is_hadron_collision) then
          p_tmp = tempprt%get_momentum ()
          if (energy (p_tmp) - longitudinal_part (p_tmp) < 1.E-10_default .or. &
               energy (p_tmp) + longitudinal_part (p_tmp) < 1.E-10_default) then
             eta = pseudorapidity (p_tmp)
          else
             eta = rapidity (p_tmp)
          end if
          if (eta > matching%settings%mlm_etaClusfactor * &
               matching%settings%mlm_etamax) cycle
       end if
       matching%P_PS(j) = tempprt%get_momentum ()
       j = j + 1
    end do
  end subroutine mlm_matching_fill_P_PS

@ %def mlm_matching_fill_P_PS
@
<<MLM matching: mlm matching: TBP>>=
  procedure :: apply => mlm_matching_apply
<<MLM matching: procedures>>=
  subroutine mlm_matching_apply (matching, vetoed)
    class(mlm_matching_t), intent(inout) :: matching
    logical, intent(out) :: vetoed
    integer :: i, j
    integer :: n_jets_ME, n_jets_PS, n_jets_PS_atycut
    real(double) :: ycut
    real(double), dimension(:, :), allocatable :: PP
    real(double), dimension(:), allocatable :: Y
    real(double), dimension(:,:), allocatable :: P_JETS
    real(double), dimension(:,:), allocatable :: P_ME
    integer, dimension(:), allocatable :: JET
    integer :: NJET, NSUB
    integer :: imode
!!! TODO: (bcn 2014-03-26) Why is ECUT hard coded to 1?
!!! It is the denominator of the KT measure. Candidate for removal
    real(double) :: ECUT = 1._double
    integer :: ip1,ip2

    ! KTCLUS COMMON BLOCK
    INTEGER NMAX,NUM,HIST
    PARAMETER (NMAX=512)
    DOUBLE PRECISION P,KT,KTP,KTS,ETOT,RSQ,KTLAST
    COMMON /KTCOMM/ETOT,RSQ,P(9,NMAX),KTP(NMAX,NMAX),KTS(NMAX), &
         KT(NMAX),KTLAST(NMAX),HIST(NMAX),NUM

    vetoed = .true.
    if (signal_is_pending ())  return

    <<Set [[n_jets_ME/PS]] from [[matching]] (or equal zero)>>

    <<Jet clustering for partons after matrix element>>

    <<Jet clustering for partons after shower>>

    <<Veto: too many or not enough jets after PS>>

    <<Cluster ME jets with PS jets one at a time>>

    vetoed = .false.
999 continue
  end subroutine mlm_matching_apply

@ %def mlm_matching_apply
@
<<Set [[n_jets_ME/PS]] from [[matching]] (or equal zero)>>=
if (allocated (matching%P_ME)) then
   ! print *, "number of partons after ME: ", size(matching%P_ME)
   n_jets_ME = size (matching%P_ME)
else
   n_jets_ME = 0
end if
if (allocated (matching%p_PS)) then
   ! print *, "number of partons after PS: ", size(matching%p_PS)
   n_jets_PS = size (matching%p_PS)
else
   n_jets_PS = 0
end if
@
<<Jet clustering for partons after matrix element>>=
if (n_jets_ME > 0) then
   ycut = (matching%settings%mlm_ptmin)**2
   allocate (PP(1:4, 1:N_jets_ME))
   do i = 1, n_jets_ME
      PP(1:3,i) = matching%p_ME(i)%p(1:3)
      PP(4,i) = matching%p_ME(i)%p(0)
   end do

   <<Set [[imode]] for lepton or hadron collisions>>

   allocate (P_ME(1:4,1:n_jets_ME))
   allocate (JET(1:n_jets_ME))
   allocate (Y(1:n_jets_ME))

   if (signal_is_pending ())  return
   call KTCLUR (imode, PP, n_jets_ME, &
        dble (matching%settings%mlm_Rclusfactor * matching%settings%mlm_Rmin), ECUT, y, *999)
   call KTRECO (1, PP, n_jets_ME, ECUT, ycut, ycut, P_ME, JET, &
        NJET, NSUB, *999)

   n_jets_ME = NJET
   if (NJET > 0) then
      allocate (matching%JETS_ME (1:NJET))
      do i = 1, NJET
         matching%JETS_ME(i) = vector4_moving (REAL(P_ME(4,i), default), &
              vector3_moving([REAL(P_ME(1,i), default), &
              REAL(P_ME(2,i), default), REAL(P_ME(3,i), default)]))
      end do
   end if
   deallocate (P_ME)
   deallocate (JET)
   deallocate (Y)
   deallocate (PP)
end if
@
<<Jet clustering for partons after shower>>=
if (n_jets_PS > 0) then
   ycut = (matching%settings%mlm_ptmin + max (matching%settings%mlm_ETclusminE, &
        matching%settings%mlm_ETclusfactor * matching%settings%mlm_ptmin))**2
   allocate (PP(1:4, 1:n_jets_PS))
   do i = 1, n_jets_PS
      PP(1:3,i) = matching%p_PS(i)%p(1:3)
      PP(4,i) = matching%p_PS(i)%p(0)
   end do

   <<Set [[imode]] for lepton or hadron collisions>>

   allocate (P_JETS(1:4,1:n_jets_PS))
   allocate (JET(1:n_jets_PS))
   allocate (Y(1:n_jets_PS))

   if (signal_is_pending ()) return
   call KTCLUR (imode, PP, n_jets_PS, &
        dble (matching%settings%mlm_Rclusfactor * matching%settings%mlm_Rmin), &
        ECUT, y, *999)
   call KTRECO (1, PP, n_jets_PS, ECUT, ycut, ycut, P_JETS, JET, &
        NJET, NSUB, *999)
   n_jets_PS_atycut = NJET
   if (n_jets_ME == matching%settings%mlm_nmaxMEjets .and. NJET > 0) then
      ! print *, " resetting ycut to ", Y(matching%settings%mlm_nmaxMEjets)
      ycut = y(matching%settings%mlm_nmaxMEjets)
      call KTRECO (1, PP, n_jets_PS, ECUT, ycut, ycut, P_JETS, JET, &
           NJET, NSUB, *999)
   end if

   ! !Sample of code for a FastJet interface
   ! palg = 1d0         ! 1.0d0 = kt, 0.0d0 = Cam/Aachen, -1.0d0 = anti-kt
   ! R = 0.7_double     ! radius parameter
   ! f = 0.75_double    ! overlap threshold
   ! !call fastjetppgenkt(PP,n,R,palg,P_JETS,NJET)   ! KT-Algorithm
   ! !call fastjetsiscone(PP,n,R,f,P_JETS,NJET)      ! SiSCone-Algorithm

   if (NJET > 0) then
      allocate (matching%JETS_PS(1:NJET))
      do i = 1, NJET
         matching%JETS_PS(i) = vector4_moving (REAL(P_JETS(4,i), default), &
              vector3_moving([REAL(P_JETS(1,i), default), &
              REAL(P_JETS(2,i), default), REAL(P_JETS(3,i), default)]))
      end do
   end if

   deallocate (P_JETS)
   deallocate (JET)
   deallocate (Y)
else
   n_jets_PS_atycut = 0
end if
@
<<Set [[imode]] for lepton or hadron collisions>>=
if (matching%is_hadron_collision) then
   imode = matching%settings%kt_imode_hadronic
else
   imode = matching%settings%kt_imode_leptonic
end if
@
<<Veto: too many or not enough jets after PS>>=
if (n_jets_PS_atycut < n_jets_ME) then
   ! print *, "DISCARDING: Not enough PS jets: ", n_jets_PS_atycut
   return
end if
if (n_jets_PS_atycut > n_jets_ME .and. n_jets_ME /= matching%settings%mlm_nmaxMEjets) then
   ! print *, "DISCARDING: Too many PS jets: ", n_jets_PS_atycut
   return
end if
@
<<Cluster ME jets with PS jets one at a time>>=
if (allocated(matching%JETS_PS)) then
   ! print *, "number of jets after PS: ", size(matching%JETS_PS)
   n_jets_PS = size (matching%JETS_PS)
else
   n_jets_PS = 0
end if
if (n_jets_ME > 0 .and. n_jets_PS > 0) then
   n_jets_PS = size (matching%JETS_PS)
   if (allocated (PP))  deallocate(PP)
   allocate (PP(1:4, 1:n_jets_PS + 1))
   do i = 1, n_jets_PS
      if (signal_is_pending ()) return
      PP(1:3,i) = matching%JETS_PS(i)%p(1:3)
      PP(4,i) = matching%JETS_PS(i)%p(0)
   end do
   if (allocated (Y))  deallocate(Y)
   allocate (Y(1:n_jets_PS + 1))
   y = zero
   do i = 1, n_jets_ME
      PP(1:3,n_jets_PS + 2 - i) = matching%JETS_ME(i)%p(1:3)
      PP(4,n_jets_PS + 2 - i) = matching%JETS_ME(i)%p(0)
      !!! This makes more sense than hardcoding
      ! call KTCLUS (4313, PP, (n_jets_PS + 2 - i), 1.0_double, Y, *999)
      call KTCLUR (imode, PP, (n_jets_PS + 2 - i), &
        dble (matching%settings%mlm_Rclusfactor * matching%settings%mlm_Rmin), &
        ECUT, y, *999)
      if (0.99 * y(n_jets_PS + 1 - (i - 1)).gt.ycut) then
         ! print *, "DISCARDING: Jet ", i, " not clusterd"
         return
      end if
      !!! search for and remove PS jet clustered with ME Jet
      ip1 = HIST(n_jets_PS + 2 - i) / NMAX
      ip2 = mod(hist(n_jets_PS + 2 - i), NMAX)
      if ((ip2 /= n_jets_PS + 2 - i) .or. (ip1 <= 0)) then
         ! print *, "DISCARDING: Jet ", i, " not clustered ", ip1, ip2, &
         !      hist(n_jets_PS + 2 - i)
         return
      else
         ! print *, "PARTON clustered", ip1, ip2, hist(n_jets_PS + 2 - i)
         PP(:,IP1) = zero
         do j = IP1, n_jets_PS - i
            PP(:, j) = PP(:,j + 1)
         end do
      end if
   end do
end if
@
\section{CKKW matching}
This module contains the CKKW matching.

The type [[ckkw_pseudo_shower_weights_t]] gives the (relative) weights
for different clusterings of the final particles, as given in Eq.~(2.7) of
hep-ph/0503281v1. Each particle has a binary labelling (power of 2)
(first particle = 1, second particle = 2, third particle = 4,
...). Each recombination therefore corresponds to an integer, that is
not a power of 2. Fur multiple subsequent recombinations, no different
weights for different sequences of clustering are stored. It is
assumed that the weight of a multiply recombined state is a
combination of the states with one fewer recombination and that these
states' contributions are proportional to their weights. For a $2->n$
event, the weights array thus has the size $2^{(2 + n) - 1}$. The
[[weights_by_type]] array gives the weights depending on the type of
the particle, the first index is the same as for weights, the second
index gives the type of the new mother particle:
\begin{itemize}
  \item[0:] uncolored ($\gamma$, $Z$, $W$, Higgs)
  \item[1:] colored (quark)
  \item[2:] gluon
  \item[3:] squark
  \item[4:] gluino
\end{itemize}
[[alphaS]] gives the value for $alpha_s$ used in the generation of the
matrix element. This is needed for the reweighting using the values
for a running $alpha_s$ at the scales of the clusterings.
<<[[ckkw_matching.f90]]>>=
<<File header>>

module ckkw_matching

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use constants
  use format_utils, only: write_separator
  use diagnostics
  use physics_defs
  use lorentz
  use particles
  use rng_base
  use shower_base
  use shower_partons
  use shower_core
  use variables
  use matching_base
  use processes

<<Standard module head>>

<<CKKW matching: public>>

<<CKKW matching: types>>

contains

<<CKKW matching: procedures>>

end module ckkw_matching
@ %def ckkw_matching
@ The fundamental CKKW matching parameter are defined here:
<<CKKW matching: public>>=
  public :: ckkw_matching_settings_t
<<CKKW matching: types>>=
  type :: ckkw_matching_settings_t
     real(default) :: alphaS = 0.118_default
     real(default) :: Qmin = one
     integer :: n_max_jets = 0
   contains
   <<CKKW matching: ckkw matching settings: TBP>>
  end type ckkw_matching_settings_t

@ %def ckkw_matching_settings_t
@ This is empty for the moment.
<<CKKW matching: ckkw matching settings: TBP>>=
  procedure :: init => ckkw_matching_settings_init
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_settings_init (settings, var_list)
    class(ckkw_matching_settings_t), intent(out) :: settings
    type(var_list_t), intent(in) :: var_list
    settings%alphaS = 1.0_default
    settings%Qmin = 1.0_default
    settings%n_max_jets = 3
  end subroutine ckkw_matching_settings_init

@ %def ckkw_matching_settings_init
@
<<CKKW matching: ckkw matching settings: TBP>>=
  procedure :: write => ckkw_matching_settings_write
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_settings_write (settings, unit)
    class(ckkw_matching_settings_t), intent(in) :: settings
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1x,A)")  "CKKW matching settings:"
    call write_separator (u)
    write (u, "(3x,A,1x,ES19.12)") &
         "alphaS       = ", settings%alphaS
    write (u, "(3x,A,1x,ES19.12)") &
         "Qmin         = ", settings%Qmin
    write (u, "(3x,A,1x,I0)") &
         "n_max_jets   = ", settings%n_max_jets
  end subroutine ckkw_matching_settings_write

@ %def ckkw_matching_settings_write
@
<<CKKW matching: public>>=
  public :: ckkw_pseudo_shower_weights_t
<<CKKW matching: types>>=
  type :: ckkw_pseudo_shower_weights_t
     real(default) :: alphaS
     real(default), dimension(:), allocatable :: weights
     real(default), dimension(:,:), allocatable :: weights_by_type
   contains
  <<CKKW matching: ckkw pseudo shower weights: TBP>>
  end type ckkw_pseudo_shower_weights_t

@ %def ckkw_pseudo_shower_weights_t
@
<<CKKW matching: ckkw pseudo shower weights: TBP>>=
  procedure :: init => ckkw_pseudo_shower_weights_init
<<CKKW matching: procedures>>=
  subroutine ckkw_pseudo_shower_weights_init (weights)
    class(ckkw_pseudo_shower_weights_t), intent(out) :: weights
    weights%alphaS = zero
  end subroutine ckkw_pseudo_shower_weights_init

@ %def ckkw_pseudo_shower_weights_init
@
<<CKKW matching: ckkw pseudo shower weights: TBP>>=
  procedure :: write => ckkw_pseudo_shower_weights_write
<<CKKW matching: procedures>>=
  subroutine ckkw_pseudo_shower_weights_write (weights, unit)
    class(ckkw_pseudo_shower_weights_t), intent(in) :: weights
    integer, intent(in), optional :: unit
    integer :: s, i, u
    u = given_output_unit (unit); if (u < 0) return
    s = size (weights%weights)
    write (u, "(1x,A)")  "CKKW (pseudo) shower weights: "
    do i = 1, s
       write (u, "(3x,I0,2(ES19.12))")  i, weights%weights(i), &
            weights%weights_by_type(i,:)
    end do
    write (u, "(3x,A,1x,I0)")  "alphaS =", weights%alphaS
  end subroutine ckkw_pseudo_shower_weights_write

@ %def ckkw_pseudo_shower_weights_write
@ Generate fake ckkw weights. This can be dropped, once information
from the matrix element generation is available.
<<CKKW matching: ckkw pseudo shower weights: TBP>>=
  procedure :: fake => ckkw_pseudo_shower_weights_fake
<<CKKW matching: procedures>>=
  pure subroutine ckkw_pseudo_shower_weights_fake (weights, particle_set)
    class(ckkw_pseudo_shower_weights_t), intent(inout) :: weights
    type(particle_set_t), intent(in) :: particle_set
    integer :: i, j, n
    type(vector4_t) :: momentum
    n = 2**particle_set%n_tot
    if (allocated (weights%weights)) then
       deallocate (weights%weights)
    end if
    allocate (weights%weights (1:n))
    do i = 1, n
       momentum = vector4_null
       do j = 1, particle_set%n_tot
          if (btest (i,j-1)) then
             momentum = momentum + particle_set%prt(j)%p
          end if
       end do
       if (momentum**1 > 0.0) then
          weights%weights(i) = 1.0 / (momentum**2)
       end if
    end do
    ! equally distribute the weights by type
    if (allocated (weights%weights_by_type)) then
       deallocate (weights%weights_by_type)
    end if
    allocate (weights%weights_by_type (1:n, 0:4))
    do i = 1, n
       do j = 0, 4
          weights%weights_by_type(i,j) = 0.2 * weights%weights(i)
       end do
    end do
  end subroutine ckkw_pseudo_shower_weights_fake

@ %def ckkw_pseudo_shower_weights_fake
@
<<CKKW matching: public>>=
  public :: ckkw_matching_t
<<CKKW matching: types>>=
  type, extends (matching_t) :: ckkw_matching_t
     type(ckkw_matching_settings_t) :: settings
     type(ckkw_pseudo_shower_weights_t) :: weights
   contains
     <<CKKW matching: ckkw matching: TBP>>
  end type ckkw_matching_t

@ %def ckkw_matching_t
@
<<CKKW matching: ckkw matching: TBP>>=
  procedure :: init => ckkw_matching_init
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_init (matching, var_list, process_name)
    class(ckkw_matching_t), intent(out) :: matching
  <<default matching init>>
  end subroutine ckkw_matching_init

@ %def ckkw_matching_init
@
<<CKKW matching: ckkw matching: TBP>>=
  procedure :: write => ckkw_matching_write
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_write (matching, unit)
    class(ckkw_matching_t), intent(in) :: matching
    integer, intent(in), optional :: unit
    call matching%settings%write (unit)
    call matching%weights%write (unit)
  end subroutine ckkw_matching_write

@ %def ckkw_matching_write
@
<<CKKW matching: ckkw matching: TBP>>=
  procedure :: get_method => ckkw_matching_get_method
<<CKKW matching: procedures>>=
  function ckkw_matching_get_method (matching) result (method)
     type(string_t) :: method
     class(ckkw_matching_t), intent(in) :: matching
     method = matching_method (MATCH_CKKW) 
  end function ckkw_matching_get_method

@ %def ckkw_matching_get_method
@
<<CKKW matching: ckkw matching: TBP>>=
  procedure :: before_shower => ckkw_matching_before_shower
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_before_shower &
         (matching, particle_set, vetoed)
    class(ckkw_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(inout) :: particle_set
    logical, intent(out) :: vetoed
    call matching%weights%init ()
    call matching%weights%fake (particle_set)
    select type (shower => matching%shower)
    type is (shower_t)
       call ckkw_matching_apply (shower%partons, &
            matching%settings, &
            matching%weights, matching%rng, vetoed)
    class default
       call msg_bug ("CKKW matching only works with WHIZARD shower.")
    end select
  end subroutine ckkw_matching_before_shower

@ %def ckkw_matching_before_shower
@
<<CKKW matching: public>>=
  public :: ckkw_matching_apply
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_apply (partons, settings, weights, rng, vetoed)
    type(parton_pointer_t), dimension(:), intent(inout), allocatable :: &
         partons
    type(ckkw_matching_settings_t), intent(in) :: settings
    type(ckkw_pseudo_shower_weights_t), intent(in) :: weights
    class(rng_t), intent(inout), allocatable :: rng
    logical, intent(out) :: vetoed

    real(default), dimension(:), allocatable :: scales
    real(double) :: weight, sf
    real(default) :: rand
    integer :: i, n_partons

    if (signal_is_pending ()) return
    weight = one

    n_partons = size (partons)

    do i = 1, n_partons
       call partons(i)%p%write ()
    end do

    !!! the pseudo parton shower is already simulated by shower_add_interaction
    !!! get the respective clustering scales
    allocate (scales (1:n_partons))
    do i = 1, n_partons
       if (.not. associated (partons(i)%p)) cycle
       if (partons(i)%p%type == INTERNAL) then
          scales(i) = two * min (partons(i)%p%child1%momentum%p(0),  &
                                 partons(i)%p%child2%momentum%p(0))**2 * &
               (1.0 - (space_part (partons(i)%p%child1%momentum) * &
                space_part (partons(i)%p%child2%momentum)) / &
               (space_part (partons(i)%p%child1%momentum)**1 * &
                space_part (partons(i)%p%child2%momentum)**1))
          scales(i) = sqrt (scales(i))
          partons(i)%p%ckkwscale = scales(i)
          print *, scales(i)
       end if
    end do

    print *, " scales finished"
    !!! if (highest multiplicity) -> reweight with PDF(mu_F) / PDF(mu_cut)
    do i = 1, n_partons
       call partons(i)%p%write ()
    end do

    !!! Reweight and possibly veto the whole event

    !!! calculate the relative alpha_S weight

    !! calculate the Sudakov weights for internal lines
    !! calculate the Sudakov weights for external lines
    do i = 1, n_partons
       if (signal_is_pending ()) return
       if (.not. associated (partons(i)%p)) cycle
       if (partons(i)%p%type == INTERNAL) then
          !!! get type
          !!! check that all particles involved are colored
          if ((partons(i)%p%is_colored () .or. &
               partons(i)%p%ckkwtype > 0) .and. &
               (partons(i)%p%child1%is_colored () .or. &
               partons(i)%p%child1%ckkwtype > 0) .and. &
               (partons(i)%p%child1%is_colored () .or. &
               partons(i)%p%child1%ckkwtype > 0)) then
             print *, "reweight with alphaS(" , partons(i)%p%ckkwscale, &
                  ") for particle ", partons(i)%p%nr
             if (partons(i)%p%belongstoFSR) then
                print *, "FSR"
                weight = weight * D_alpha_s_fsr (partons(i)%p%ckkwscale**2, &
                     partons(i)%p%settings) / settings%alphas
             else
                print *, "ISR"
                weight = weight * &
                     D_alpha_s_isr (partons(i)%p%ckkwscale**2, &
                     partons(i)%p%settings) / settings%alphas
             end if
          else
             print *, "no reweight with alphaS for ", partons(i)%p%nr
          end if
          if (partons(i)%p%child1%type == INTERNAL) then
             print *, "internal line from ", &
                  partons(i)%p%child1%ckkwscale, &
                  " to ", partons(i)%p%ckkwscale, &
                  " for type ", partons(i)%p%child1%ckkwtype
             if (partons(i)%p%child1%ckkwtype == 0) then
                sf = 1.0
             else if (partons(i)%p%child1%ckkwtype == 1) then
                sf = SudakovQ (partons(i)%p%child1%ckkwscale, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFQ = ", sf
             else if (partons(i)%p%child1%ckkwtype == 2) then
                sf = SudakovG (partons(i)%p%child1%ckkwscale, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFG = ", sf
             else
                print *, "SUSY not yet implemented"
             end if
             weight = weight * min (one, sf)
          else
             print *, "external line from ", settings%Qmin, &
                  partons(i)%p%ckkwscale
             if (partons(i)%p%child1%is_quark ()) then
                sf = SudakovQ (settings%Qmin, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFQ = ", sf
             else if (partons(i)%p%child1%is_gluon ()) then
                sf = SudakovG (settings%Qmin, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFG = ", sf
             else
                print *, "not yet implemented (", &
                     partons(i)%p%child2%type, ")"
                sf = one
             end if
             weight = weight * min (one, sf)
          end if
          if (partons(i)%p%child2%type == INTERNAL) then
             print *, "internal line from ", partons(i)%p%child2%ckkwscale, &
                  " to ", partons(i)%p%ckkwscale, &
                  " for type ", partons(i)%p%child2%ckkwtype
             if (partons(i)%p%child2%ckkwtype == 0) then
                sf = 1.0
             else if (partons(i)%p%child2%ckkwtype == 1) then
                sf = SudakovQ (partons(i)%p%child2%ckkwscale, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFQ = ", sf
             else if (partons(i)%p%child2%ckkwtype == 2) then
                sf = SudakovG (partons(i)%p%child2%ckkwscale, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFG = ", sf
             else
                print *, "SUSY not yet implemented"
             end if
             weight = weight * min (one, sf)
          else
             print *, "external line from ", settings%Qmin, &
                  partons(i)%p%ckkwscale
             if (partons(i)%p%child2%is_quark ()) then
                sf = SudakovQ (settings%Qmin, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFQ = ", sf
             else if (partons(i)%p%child2%is_gluon ()) then
                sf = SudakovG (settings%Qmin, &
                     partons(i)%p%ckkwscale, &
                     partons(i)%p%settings, .true., rng)
                print *, "SFG = ", sf
             else
                print *, "not yet implemented (", &
                     partons(i)%p%child2%type, ")"
                sf = one
             end if
             weight = weight * min (one, sf)
          end if
       end if
    end do

    call rng%generate (rand)

    print *, "final weight: ", weight

    !!!!!!! WRONG
    vetoed = .false.
    ! vetoed = (rand > weight)
    if (vetoed) then
       return
    end if

    !!! finally perform the parton shower
    !!! veto emissions that are too hard

    deallocate (scales)
  end subroutine ckkw_matching_apply

@ %def ckkw_matching_apply
@
@
<<CKKW matching: ckkw matching: TBP>>=
  procedure :: after_shower => ckkw_matching_after_shower
<<CKKW matching: procedures>>=
  subroutine ckkw_matching_after_shower (matching, particle_set, vetoed)
    class(ckkw_matching_t), intent(inout) :: matching
       type(particle_set_t), intent(inout) :: particle_set
       logical, intent(out) :: vetoed
       vetoed = .false.
  end subroutine ckkw_matching_after_shower

@ %def ckkw_matching_after_shower
<<CKKW matching: procedures>>=
  function GammaQ (smallq, largeq, settings, fsr) result (gamma)
    real(default), intent(in) :: smallq, largeq
    type(shower_settings_t), intent(in) :: settings
    logical, intent(in) :: fsr
    real(default) :: gamma
    gamma = (8._default / three) / (pi * smallq)
    gamma = gamma * (log(largeq / smallq) - 0.75)
    if (fsr) then
       gamma = gamma * D_alpha_s_fsr (smallq**2, settings)
    else
       gamma = gamma * D_alpha_s_isr (smallq**2, settings)
    end if
  end function GammaQ

@ %def GammaQ
@
<<CKKW matching: procedures>>=
  function GammaG (smallq, largeq, settings, fsr) result (gamma)
    real(default), intent(in) :: smallq, largeq
    type(shower_settings_t), intent(in) :: settings
    logical, intent(in) :: fsr
    real(default) :: gamma
    gamma = 6._default / (pi * smallq)
    gamma = gamma *( log(largeq / smallq) - 11.0 / 12.0)
    if (fsr) then
       gamma = gamma * D_alpha_s_fsr (smallq**2, settings)
    else
       gamma = gamma * D_alpha_s_isr (smallq**2, settings)
    end if
  end function GammaG

@ %def GammaG
@
<<CKKW matching: procedures>>=
  function GammaF (smallq, settings, fsr) result (gamma)
    real(default), intent(in) :: smallq
    type(shower_settings_t), intent(in) :: settings
    logical, intent(in) :: fsr
    real(default) :: gamma
    gamma = number_of_flavors (smallq, settings%max_n_flavors, &
         settings%min_virtuality) / (three * pi * smallq)
    if (fsr) then
       gamma = gamma * D_alpha_s_fsr (smallq**2, settings)
    else
       gamma = gamma * D_alpha_s_isr (smallq**2, settings)
    end if
  end function GammaF

@ %def GammaF
@
<<CKKW matching: procedures>>=
  function SudakovQ (Q1, Q, settings, fsr, rng) result (sf)
    real(default), intent(in) :: Q1, Q
    type(shower_settings_t), intent(in) :: settings
    class(rng_t), intent(inout), allocatable :: rng
    logical, intent(in) :: fsr
    real(default) :: sf
    real(default) :: integral
    integer, parameter :: NTRIES = 100
    integer :: i
    real(default) :: rand
    integral = zero
    do i = 1, NTRIES
       call rng%generate (rand)
       integral = integral + GammaQ (Q1 + rand * (Q - Q1), Q, settings, fsr)
    end do
    integral = integral / NTRIES
    sf = exp (-integral)
  end function SudakovQ

@ %def SudakovQ
@
<<CKKW matching: procedures>>=
  function SudakovG (Q1, Q, settings, fsr, rng) result (sf)
    real(default), intent(in) :: Q1, Q
    type(shower_settings_t), intent(in) :: settings
    logical, intent(in) :: fsr
    real(default) :: sf
    real(default) :: integral
    class(rng_t), intent(inout), allocatable :: rng
    integer, parameter :: NTRIES = 100
    integer :: i
    real(default) :: rand
    integral = zero
    do i = 1, NTRIES
       call rng%generate (rand)
       integral = integral + &
            GammaG (Q1 + rand * (Q - Q1), Q, settings, fsr) + &
            GammaF (Q1 + rand * (Q - Q1), settings, fsr)
    end do
    integral = integral / NTRIES
    sf = exp (-integral)
  end function SudakovG

@ %def SudakovG
@
\section{POWHEG}
This module generates radiation according to the POWHEG Sudakov form factor
\begin{equation}
  \Delta^{f_b} (\Phi_n, p_\text{T}) = \prod_{\alpha_r \in \{\alpha_r |f_b \}}
                              \Delta^{f_b}_{\alpha_r} (\Phi_n,
                              p_\text{T}),
\end{equation}
with
\begin{equation}
  \Delta^{f_b}_{\alpha_r} (\Phi_n, p_\text{T}) = \exp \left\{ - \left[ \int d
  \Phi_{\text{rad}} \,\frac{R (\Phi_{n+1})}{B^{f_b} (\Phi_n)}
  \,\theta( k_\text{T} (\Phi_{n+1}) - p_\text{T}) \right]^{\bar{\bf \Phi}_n^{\alpha_r} =
  \Phi_n}_{\alpha_r} \right\}
\end{equation}

We expect that an underlying Born flavor structure $f_b$ has been
generated with a probability proportional to its contribution to the
$\tilde B$ at the given kinematic point.
<<[[powheg_matching.f90]]>>=
<<File header>>

module powheg_matching

  use, intrinsic :: iso_fortran_env

<<Use kinds>>
<<Use strings>>
  use diagnostics
  use constants, only: ZERO, ONE, TWO, FIVE
  use constants, only: TINY_07
  use constants, only: PI, TWOPI
  use unit_tests, only: nearly_equal, assert_equal
  use io_units, only: given_output_unit, free_unit
  use format_utils, only: write_separator
  use format_defs, only: FMT_16, FMT_19
  use string_utils, only: str
  use os_interface, only: os_file_exist
  use physics_defs, only: CA
  use lorentz
  use sm_qcd, only: qcd_t, alpha_qcd_from_scale_t, alpha_qcd_from_lambda_t
  use sm_physics, only: Li2
  use subevents, only: PRT_INCOMING, PRT_OUTGOING
  use colors
  use particles
  use grids
  use solver
  use rng_base
  use variables

  use nlo_data, only: compute_dalitz_bounds, FSR_SIMPLE, FSR_MASSIVE
  use phs_fks
  use matching_base
  use processes, only: pcm_instance_nlo_t
  use pcm_base, only: pcm_instance_t

<<Standard module head>>

<<POWHEG matching: public>>

<<POWHEG matching: parameters>>

<<POWHEG matching: types>>

<<POWHEG matching: interfaces>>

contains

<<POWHEG matching: procedures>>

end module powheg_matching
@ %def powheg_matching
@
\subsection{Base types for settings and data}
[[lambda]] enters for now as the lowest scale
$2 \Lambda^(5)_{\bar{\text{MS}}}$ where the radiation
$\alpha_s^\text{rad}$ is still larger than the true $\alpha_s$.
<<POWHEG matching: public>>=
  public :: powheg_settings_t
<<POWHEG matching: types>>=
  type :: powheg_settings_t
     real(default) :: pt2_min = zero
     real(default) :: lambda = zero
     integer :: n_init = 0
     integer :: size_grid_xi = 0
     integer :: size_grid_y = 0
     integer :: upper_bound_func = UBF_SIMPLE
     logical :: rebuild_grids = .false.
     logical :: test_sudakov = .false.
     logical :: singular_jacobian = .false.
  contains
   <<POWHEG matching: powheg settings: TBP>>
  end type powheg_settings_t

@ %def powheg_settings_t
@ These are the possible values for [[upper_bound_func]] and will be
used to decide which ubf object is allocated.
<<POWHEG matching: parameters>>=
  integer, parameter :: UBF_SIMPLE = 1
  integer, parameter :: UBF_EEQQ = 2
  integer, parameter :: UBF_MASSIVE = 3
@ %def UBF_SIMPLE UBF_EEQQ
@
<<POWHEG matching: powheg settings: TBP>>=
  procedure :: init => powheg_settings_init
<<POWHEG matching: procedures>>=
  subroutine powheg_settings_init (settings, var_list)
    class(powheg_settings_t), intent(out) :: settings
    type(var_list_t), intent(in) :: var_list
    settings%size_grid_xi = &
         var_list%get_ival (var_str ("powheg_grid_size_xi"))
    settings%size_grid_y = &
         var_list%get_ival (var_str ("powheg_grid_size_y"))
    settings%n_init = &
         var_list%get_ival (var_str ("powheg_grid_sampling_points"))
    settings%pt2_min = &
         var_list%get_rval (var_str ("powheg_pt_min"))**2
    settings%lambda = var_list%get_rval (var_str ("powheg_lambda"))
    settings%rebuild_grids = &
         var_list%get_lval (var_str ("?powheg_rebuild_grids"))
    settings%singular_jacobian = &
         var_list%get_lval (var_str ("?powheg_use_singular_jacobian"))
    settings%test_sudakov = &
         var_list%get_lval (var_str ("?powheg_test_sudakov"))
  end subroutine powheg_settings_init

@ %def powheg_settings_init
@
<<POWHEG matching: powheg settings: TBP>>=
  procedure :: write => powheg_settings_write
<<POWHEG matching: procedures>>=
  subroutine powheg_settings_write (powheg_settings, unit)
    class(powheg_settings_t), intent(in) :: powheg_settings
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1X,A)") "POWHEG settings:"
    write (u, "(3X,A," // FMT_16 //")") "pt2_min = ", powheg_settings%pt2_min
    write (u, "(3X,A," // FMT_16 //")") "lambda = ", powheg_settings%lambda
    write (u, "(3X,A,I12)") "n_init = ", powheg_settings%n_init
    write (u, "(3X,A,I12)") "size_grid_xi = ", powheg_settings%size_grid_xi
    write (u, "(3X,A,I12)") "size_grid_y = ", powheg_settings%size_grid_y
    write (u, "(3X,A,I12)") "upper_bound_func = ", powheg_settings%upper_bound_func
  end subroutine powheg_settings_write

@ %def powheg_settings_write
@
To be able to test the powheg class independently, we set up a type that
contains the necessary dummy information:
<<POWHEG matching: public>>=
  public :: powheg_testing_t
<<POWHEG matching: types>>=
  type :: powheg_testing_t
     integer :: n_alr, n_in, n_out_born, n_out_real
     real(default) :: sqme_born
     logical :: active = .false.
  end type powheg_testing_t

@ %def powheg_testing_t
@
<<POWHEG matching: public>>=
  public :: radiation_t
<<POWHEG matching: types>>=
  type :: radiation_t
    real(default) :: xi, y, phi, pt2
    integer :: alr
    logical :: valid = .false.
  contains
  <<POWHEG matching: radiation: TBP>>
  end type radiation_t

@ %def radiation_t
@
<<POWHEG matching: radiation: TBP>>=
  procedure :: write => radiation_write
<<POWHEG matching: procedures>>=
  subroutine radiation_write (radiation, unit)
    class(radiation_t), intent(in) :: radiation
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1X, A)") "Radiation:"
    write (u, "(3X, A," // FMT_16 // ")") "xi = ", radiation%xi
    write (u, "(3X, A," // FMT_16 // ")") "y = ", radiation%y
    write (u, "(3X, A," // FMT_16 // ")") "phi = ", radiation%phi
    write (u, "(3X, A," // FMT_16 // ")") "pt2 = ", radiation%pt2
    write (u, "(3X, A, I12)") "alr = ", radiation%alr
  end subroutine radiation_write

@ %def radiation_write
@ [[lambda2_gen]] $\neq$ [[lambda]] and is used in the upper bounding
functions.
<<POWHEG matching: public>>=
  public :: process_deps_t
<<POWHEG matching: types>>=
  type :: process_deps_t
     real(default) :: lambda2_gen, sqrts
     integer :: n_alr
     logical :: cm_frame = .true.
  contains
   <<POWHEG matching: process deps: TBP>>
  end type process_deps_t

@ %def process_deps_t
@
<<POWHEG matching: process deps: TBP>>=
  procedure :: write => process_deps_write
<<POWHEG matching: procedures>>=
  subroutine process_deps_write (process_deps, unit)
    class(process_deps_t), intent(in) :: process_deps
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1X,A)") "Process dependencies:"
    write (u, "(3X,A," // FMT_19 // ")") "lambda2_gen = ", process_deps%lambda2_gen
    write (u, "(3X,A, I12)") "n_alr = ", process_deps%n_alr
  end subroutine process_deps_write

@ %def process_deps_write
@
<<POWHEG matching: public>>=
  public :: event_deps_t
<<POWHEG matching: types>>=
  type :: event_deps_t
     real(default) :: s_hat
     type(vector4_t), dimension(:), allocatable :: p_born_cms
     type(vector4_t), dimension(:), allocatable :: p_born_lab
     type(vector4_t), dimension(:), allocatable :: p_real_cms
     type(vector4_t), dimension(:), allocatable :: p_real_lab
     real(default) :: sqme_born
  contains
   <<POWHEG matching: event deps: TBP>>
  end type event_deps_t

@ %def event_deps_t
@
<<POWHEG matching: event deps: TBP>>=
  procedure :: write => event_deps_write
<<POWHEG matching: procedures>>=
  subroutine event_deps_write (event_deps, unit)
    class(event_deps_t), intent(in) :: event_deps
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(1X,A)") "Event dependencies:"
    write (u, "(3X,A," // FMT_19 // ")") "s_hat = ", event_deps%s_hat
    write (u, "(3X,A," // FMT_19 // ")") "sqme_born = ", event_deps%sqme_born
  end subroutine event_deps_write

@ %def event_deps_write
@
<<POWHEG matching: event deps: TBP>>=
  procedure :: update => event_deps_update
<<POWHEG matching: procedures>>=
  subroutine event_deps_update (event_deps, sqme_born, p_born, lt_lab_to_cms)
    class(event_deps_t), intent(inout) :: event_deps
    real(default), intent(in) :: sqme_born
    type(vector4_t), dimension(:), intent(in) :: p_born
    type(lorentz_transformation_t), intent(in), optional :: lt_lab_to_cms
    integer :: i, n_born
    event_deps%sqme_born = sqme_born
    n_born = size (p_born)
    if (debug_active (D_MATCHING)) then
       if (n_born /= size (event_deps%p_born_lab)) then
          call msg_fatal &
               ("event_deps_update: number of born_momenta has changed")
       end if
    end if
    !!! !!! !!! Workaround for standard-semantics ifort 16.0 bug 
    if (.not. allocated (event_deps%p_born_lab)) &
       allocate (event_deps%p_born_lab (n_born))
    if (.not. allocated (event_deps%p_born_cms)) &
       allocate (event_deps%p_born_cms (n_born))
    do i = 1, n_born
       event_deps%p_born_lab(i) = p_born(i)
    end do
    call event_deps%set_cms (lt_lab_to_cms)
  end subroutine event_deps_update

@ %def event_deps_update
@ This has to be changed when we have sorted out the handling of ISR,
partonic vs hadronic cms as well as decays in POWHEG:
<<POWHEG matching: event deps: TBP>>=
  procedure :: set_cms => event_deps_set_cms
<<POWHEG matching: procedures>>=
  subroutine event_deps_set_cms (event_deps, lt_lab_to_cms)
    class(event_deps_t), intent(inout) :: event_deps
    type(lorentz_transformation_t), intent(in), optional :: lt_lab_to_cms
    associate (p => event_deps%p_born_lab)
       event_deps%s_hat = (p(1) + p(2))**2
       if (present (lt_lab_to_cms)) then
          event_deps%p_born_cms = lt_lab_to_cms * p
       else
          event_deps%p_born_cms = p
       end if
    end associate
  contains
    function compute_boost_to_cm_frame (p) result (lt)
      type(lorentz_transformation_t) :: lt
      type(vector4_t), dimension(:), intent(in) :: p
      real(default) :: E1, E2
      real(default) :: beta, beta_gamma
      E1 = p(1)%p(0); E2 = p(2)%p(0)
      beta = (E1 - E2) / (E1 + E2)
      beta_gamma = beta / sqrt (one - beta**2)
      lt = inverse (boost (beta_gamma, 3))
   end function compute_boost_to_cm_frame
  end subroutine event_deps_set_cms

@ %def event_deps_set_cms
@
<<POWHEG matching: types>>=
  type :: veto_counter_t
    integer :: n_ubf = 0
    integer :: n_first_fail = 0
    integer :: n_alpha_s = 0
    integer :: n_xi_max = 0
    integer :: n_norm = 0
    integer :: n_sqme = 0
    integer :: veto_ubf = 0
    integer :: veto_alpha_s = 0
    integer :: veto_xi_max = 0
    integer :: veto_norm = 0
    integer :: veto_sqme = 0
    integer :: n_veto_fail = 0
  contains
  <<POWHEG matching: veto counter: TBP>>
  end type veto_counter_t

@ %def veto_counter_t
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_ubf => veto_counter_record_ubf
<<POWHEG matching: procedures>>=
  pure subroutine veto_counter_record_ubf (counter, vetoed)
    class(veto_counter_t), intent(inout) :: counter
    logical, intent(in) :: vetoed
    counter%n_ubf = counter%n_ubf + 1
    if (vetoed) counter%veto_ubf = counter%veto_ubf + 1
  end subroutine veto_counter_record_ubf

@ %def veto_counter_record_ubf
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_first_fail => veto_counter_record_first_fail
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_first_fail (counter)
    class(veto_counter_t), intent(inout) :: counter
    counter%n_first_fail = counter%n_first_fail + 1
  end subroutine veto_counter_record_first_fail

@ %def veto_counter_record_first_fail
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_alpha_s => veto_counter_record_alpha_s
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_alpha_s (counter, vetoed)
    class(veto_counter_t), intent(inout) :: counter
    logical, intent(in) :: vetoed
    counter%n_alpha_s = counter%n_alpha_s + 1
    if (vetoed) counter%veto_alpha_s = counter%veto_alpha_s + 1
  end subroutine veto_counter_record_alpha_s

@ %def veto_counter_record_alpha_s
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_xi_max => veto_counter_record_xi_max
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_xi_max (counter, vetoed)
    class(veto_counter_t), intent(inout) :: counter
    logical, intent(in) :: vetoed
    counter%n_xi_max = counter%n_xi_max + 1
    if (vetoed) counter%veto_xi_max = counter%veto_xi_max + 1
  end subroutine veto_counter_record_xi_max

@ %def veto_counter_record_xi_max
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_norm => veto_counter_record_norm
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_norm (counter, vetoed)
    class(veto_counter_t), intent(inout) :: counter
    logical, intent(in) :: vetoed
    counter%n_norm = counter%n_norm + 1
    if (vetoed) counter%veto_norm = counter%veto_norm + 1
  end subroutine veto_counter_record_norm

@ %def veto_counter_record_norm
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_sqme => veto_counter_record_sqme
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_sqme (counter, vetoed)
    class(veto_counter_t), intent(inout) :: counter
    logical, intent(in) :: vetoed
    counter%n_sqme = counter%n_sqme + 1
    if (vetoed) counter%veto_sqme = counter%veto_sqme + 1
  end subroutine veto_counter_record_sqme

@ %def veto_counter_record_sqme
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: record_fail => veto_counter_record_fail
<<POWHEG matching: procedures>>=
  subroutine veto_counter_record_fail (counter)
    class(veto_counter_t), intent(inout) :: counter
    counter%n_veto_fail = counter%n_veto_fail + 1
  end subroutine veto_counter_record_fail

@ %def veto_counter_record_fail
@
<<POWHEG matching: veto counter: TBP>>=
  procedure :: write => veto_counter_write
<<POWHEG matching: procedures>>=
  subroutine veto_counter_write (counter, unit)
    class(veto_counter_t), intent(in) :: counter
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit); if (u < 0) return
    write (u, "(A,I12)") "Nr. of ubf-veto calls: ", counter%n_ubf
    write (u, "(A,I12)") "Nr. of ubf-vetos: ", counter%veto_ubf
    if (counter%n_ubf > 0) &
       write (u, "(A,F4.2)") "Fraction of vetoed points: ", &
                            one*counter%veto_ubf / counter%n_ubf
    call write_separator (u)

    write (u, "(A,I12)") "Nr. of alpha_s-veto calls: ", counter%n_alpha_s
    write (u, "(A,I12)") "Nr. of alpha_s-vetos: ", counter%veto_alpha_s
    if (counter%n_alpha_s > 0) &
       write (u, "(A,F4.2)") "Fraction of vetoed points: ", &
                            one*counter%veto_alpha_s / counter%n_alpha_s
    call write_separator (u)

    write (u, "(A,I12)") "Nr. of xi_max-veto calls: ", counter%n_xi_max
    write (u, "(A,I12)") "Nr. of xi_max-vetos: ", counter%veto_xi_max
    if (counter%n_alpha_s > 0) &
       write (u, "(A,F4.2)") "Fraction of vetoed points: ", &
                            one*counter%veto_xi_max / counter%n_xi_max
    call write_separator (u)

    write (u, "(A,I0)") "Nr. of norm-veto calls: ", counter%n_norm
    write (u, "(A,I0)") "Nr. of norm-vetos: ", counter%veto_norm
    if (counter%n_norm > 0) &
       write (u, "(A,F4.2)") "Fraction of vetoed points: ", &
                            one*counter%veto_norm / counter%n_norm
    call write_separator (u)

    write (u, "(A,I0)") "Nr. of sqme-veto calls: ", counter%n_sqme
    write (u, "(A,I0)") "Nr. of sqme-vetos: ", counter%veto_sqme
    if (counter%n_sqme > 0) &
       write (u, "(A,F4.2)") "Fraction of vetoed points: ", &
                            one*counter%veto_sqme / counter%n_sqme
    call write_separator (u)
    write (u, "(A,I0)") "Nr. of upper-bound failures: ", &
                        counter%n_veto_fail
  end subroutine veto_counter_write

@ %def veto_counter_write
@
\subsection{Upper bounding functions and [[sudakov]]s}
\subsubsection{Abstract version}
This contains the pieces that depend on the radiation region $\alpha_r$
<<POWHEG matching: public>>=
  public :: sudakov_t
<<POWHEG matching: types>>=
  type, abstract, extends (solver_function_t) :: sudakov_t
     type(process_deps_t), pointer :: process_deps => null()
     type(event_deps_t), pointer :: event_deps => null()
     type(powheg_settings_t), pointer :: powheg_settings => null()
     type(phs_fks_generator_t), pointer :: phs_fks_generator => null()
     type(qcd_t), pointer :: qcd => null()
     class(rng_t), pointer :: rng => null()
     real(default) :: xi2_max = 0
     real(default) :: norm_max = 0
     real(default) :: current_pt2_max = 0
     real(default) :: last_log = 0
     real(default) :: random = 0
     type(veto_counter_t) :: veto_counter
     integer :: associated_emitter = -1
  contains
   <<POWHEG matching: sudakov: TBP>>
  end type sudakov_t

@ %def sudakov_t
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: write => sudakov_write
<<POWHEG matching: procedures>>=
  subroutine sudakov_write (sudakov, unit)
    class(sudakov_t), intent(in) :: sudakov
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    write (u, "(3X,A," // FMT_19 // ")")  "xi2_max = ", sudakov%xi2_max
    write (u, "(3X,A," // FMT_19 // ")")  "norm_max = ", sudakov%norm_max
    write (u, "(3X,A," // FMT_19 // ")")  &
         "current_pt2_max = ", sudakov%current_pt2_max
    write (u, "(3X,A," // FMT_19 // ")")  "last_log = ", sudakov%last_log
    write (u, "(3X,A," // FMT_19 // ")")  "random = ", sudakov%random
  end subroutine sudakov_write

@ %def sudakov_write
@ To allow for arrays of this class
<<POWHEG matching: public>>=
  public :: sudakov_wrapper_t
<<POWHEG matching: types>>=
  type :: sudakov_wrapper_t
     class(sudakov_t), allocatable :: s
  end type sudakov_wrapper_t

@ %def sudakov_wrapper_t
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: init => sudakov_init
<<POWHEG matching: procedures>>=
  subroutine sudakov_init (sudakov, process_deps, event_deps, &
         powheg_settings, phs_fks_generator, qcd, rng)
    class(sudakov_t), intent(out) :: sudakov
    type(process_deps_t), target, intent(in) :: process_deps
    type(event_deps_t), target, intent(in) :: event_deps
    type(powheg_settings_t), target, intent(in) :: powheg_settings
    type(phs_fks_generator_t), target, intent(in) :: phs_fks_generator
    type(qcd_t), target, intent(in) :: qcd
    class(rng_t), target, intent(in) :: rng
    sudakov%process_deps => process_deps
    sudakov%event_deps => event_deps
    sudakov%powheg_settings => powheg_settings
    sudakov%phs_fks_generator => phs_fks_generator
    sudakov%qcd => qcd
    sudakov%rng => rng
  end subroutine sudakov_init

@ %def sudakov_init
@ This has to be done after the grids are initialized.
<<POWHEG matching: sudakov: TBP>>=
  procedure :: set_normalization => sudakov_set_normalization
<<POWHEG matching: procedures>>=
  pure subroutine sudakov_set_normalization (sudakov, norm_max)
    class(sudakov_t), intent(inout) :: sudakov
    real(default), intent(in) :: norm_max
    sudakov%norm_max = norm_max
  end subroutine sudakov_set_normalization

@ %def sudakov_set_normalization
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: update => sudakov_update
<<POWHEG matching: procedures>>=
  pure subroutine sudakov_update (sudakov, xi2_max)
    class(sudakov_t), intent(inout) :: sudakov
    real(default), intent(in) :: xi2_max
    sudakov%xi2_max = xi2_max
  end subroutine sudakov_update

@ %def sudakov_update
@ [[upper_bound_func]] does \emph{not} contain the normalization $N$
which is given by the grids. In the notation of [[1002.2581]], it is
thus $\frac 1 N U(\xi,y)$
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_upper_bound_func), deferred :: upper_bound_func
<<POWHEG matching: interfaces>>=
  abstract interface
     pure function sudakov_upper_bound_func (sudakov, xi, y, alpha_s) result (u)
       import
       real(default) :: u
       class(sudakov_t), intent(in) :: sudakov
       real(default), intent(in) :: xi, y, alpha_s
     end function sudakov_upper_bound_func
  end interface

@ %def sudakov_upper_bound_func
@ Similar to the [[upper_bound_func]], this is
$-\frac 1 N \log\Delta(p_T^2)$ where
\begin{equation}
  \Delta^{(U)} (p_T) = \exp{-\int U(\xi,y)\theta(k_T - p_T)\;d\xi dy d\phi}
\end{equation}
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_log_integrated_ubf), deferred :: log_integrated_ubf
<<POWHEG matching: interfaces>>=
  abstract interface
     pure function sudakov_log_integrated_ubf (sudakov, pt2) result (y)
       import
       real(default) :: y
       class(sudakov_t), intent(in) :: sudakov
       real(default), intent(in) :: pt2
     end function sudakov_log_integrated_ubf
  end interface

@ %def sudakov_log_integrated_ubf
@
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_generate_xi_and_y_and_phi), deferred :: generate_xi_and_y_and_phi
<<POWHEG matching: interfaces>>=
  abstract interface
     subroutine sudakov_generate_xi_and_y_and_phi (sudakov, r)
       import
       class(sudakov_t), intent(inout) :: sudakov
       type(radiation_t), intent(inout) :: r
     end subroutine sudakov_generate_xi_and_y_and_phi
  end interface

@ %def sudakov_generate_xi_and_y_and_phi
@
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_kt2), deferred :: kt2
<<POWHEG matching: interfaces>>=
  abstract interface
     function sudakov_kt2 (sudakov, xi, y) result (kt2)
       import
       real(default) :: kt2
       class(sudakov_t), intent(in) :: sudakov
       real(default), intent(in) :: xi, y
     end function sudakov_kt2
  end interface

@ %def sudakov_kt2
@
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_kt2_max), deferred :: kt2_max
<<POWHEG matching: interfaces>>=
  abstract interface
     pure function sudakov_kt2_max (sudakov, s_hat) result (kt2_max)
        import
        real(default) :: kt2_max
        class(sudakov_t), intent(in) :: sudakov
        real(default), intent(in) :: s_hat
    end function sudakov_kt2_max
  end interface

@ %def sudakov_kt2_max
@
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_reweight_ubf), deferred :: reweight_ubf
<<POWHEG matching: interfaces>>=
  abstract interface
     function sudakov_reweight_ubf (sudakov, pt2) result (accepted)
       import
       logical :: accepted
       class(sudakov_t), intent(inout) :: sudakov
       real(default), intent(in) :: pt2
    end function sudakov_reweight_ubf
  end interface

@ %def sudakov_reweight_ubf
@
<<POWHEG matching: sudakov: TBP>>=
  procedure (sudakov_reweight_xi_max), deferred :: reweight_xi_max
<<POWHEG matching: interfaces>>=
  abstract interface
     function sudakov_reweight_xi_max (sudakov, xi) result (accepted)
       import
       logical :: accepted
       class(sudakov_t), intent(in) :: sudakov
       real(default), intent(in) :: xi
     end function sudakov_reweight_xi_max
  end interface

@ %def sudakov_reweight_xi_max
@ In the generation of $p_T^2$ via [[log_integrated_ubf]], we use the
simplified version $\alpha_s^\text{rad}$ while the grids take the
improved version.
<<POWHEG matching: sudakov: TBP>>=
  procedure :: alpha_s => sudakov_alpha_s
<<POWHEG matching: procedures>>=
  function sudakov_alpha_s (sudakov, kT2, use_correct) result (a)
    real(default) :: a
    class(sudakov_t), intent(in) :: sudakov
    real(default), intent(in) :: kT2
    logical, intent(in), optional :: use_correct
    logical :: yorn
    yorn = .false.; if (present (use_correct)) yorn = use_correct
    if (yorn) then
       a = get_alpha (sudakov%qcd, kT2)
    else
       a = sudakov%alpha_s_rad (kT2)
    end if
  end function sudakov_alpha_s

@ %def sudakov_alpha_s
@ We have to solve the equation
\begin{equation*}
  \frac{\log\Delta^{(U)} (p_T)}{\log\Delta^{(U)}(p_T^{\mathrm{max}}} = \log\Delta^{(U)}(p_T) = \log r_1
\end{equation*}
iteratively for $p_T$. If the current emission is not accepted, in the next step it is 
$\log\Delta^{(U)}(p_T^{\mathrm{max}}) = \log r_1$, so that we have to solve the equation
\begin{equation*}
  \log\Delta^{(U)}(p_T) = \log r_1 + \log r_2
\end{equation*}
using the second random number $r_2$.
<<POWHEG matching: sudakov: TBP>>=
  procedure :: generate_pt2 => sudakov_generate_pt2
<<POWHEG matching: procedures>>=
  function sudakov_generate_pt2 (sudakov) result (pt2)
    real(default) :: pt2
    class(sudakov_t), intent(inout) :: sudakov
    logical :: success
    success = .false.
    if (sudakov%current_pt2_max > sudakov%powheg_settings%pt2_min) then
       call sudakov%rng%generate (sudakov%random)
       sudakov%last_log = sudakov%last_log + log(sudakov%random)
       pt2 = solve_interval (sudakov, &
            sudakov%powheg_settings%pt2_min, &
            sudakov%current_pt2_max, success, &
            0.001_default)
       !sudakov%last_log = sudakov%norm_max * sudakov%log_integrated_ubf (pt2)
              !sudakov%last_log + &
    end if
    if (.not. success) then
       pt2 = sudakov%powheg_settings%pt2_min
    end if
  end function sudakov_generate_pt2

@ %def sudakov_generate_pt2
@ This could be activated [[if (debug_active (MATCHING))]].
<<POWHEG matching: sudakov: TBP>>=
  procedure :: check_solution_interval => sudakov_check_solution_interval
<<POWHEG matching: procedures>>=
  subroutine sudakov_check_solution_interval (sudakov)
    class(sudakov_t), intent(inout) :: sudakov
    real(default) :: r
    real(default), parameter :: dr = 0.05
    real(default) :: pt2
    logical :: success
    r = 0._default
    do
       r = r+dr
       sudakov%random = r
       pt2 = solve_interval (sudakov, &
         sudakov%powheg_settings%pt2_min, &
         sudakov%current_pt2_max, success, &
         0.001_default)
      if (success) then
         print *, 'r: ', r, ' zero found'
      else
         print *, 'r: ', r, 'no zero found'
      end if
      if (r >= 1._default) exit
    end do
  end subroutine sudakov_check_solution_interval

@ %def sudakov_check_solution_interval
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: generate_emission => sudakov_generate_emission
<<POWHEG matching: procedures>>=
  subroutine sudakov_generate_emission (sudakov, r)
    class(sudakov_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    logical :: accepted
    sudakov%current_pt2_max = r%pt2
    call sudakov%generate_xi_and_y_and_phi (r)
    !sudakov%last_log = sudakov%norm_max * &
         !sudakov%log_integrated_ubf (sudakov%current_pt2_max)
    call msg_debug2 (D_MATCHING, "sudakov_generate_emission")
    call msg_debug2 (D_MATCHING, "sqrt (sudakov%current_pt2_max)", &
         sqrt (sudakov%current_pt2_max))
    call msg_debug2 (D_MATCHING, "sudakov%last_log", sudakov%last_log)
    LOOP_UNTIL_ACCEPTED: do
       if (signal_is_pending ())  return
       r%valid = .false.
       r%pt2 = sudakov%generate_pt2 ()
       call msg_debug2 (D_MATCHING, "sudakov_generate_emission: after generate_pt2")
       call msg_debug2 (D_MATCHING, "sqrt (r%pt2)", sqrt (r%pt2))
       call msg_debug2 (D_MATCHING, "sudakov%last_log", sudakov%last_log)
       if (r%pt2 <= sudakov%powheg_settings%pt2_min) then
          exit
       end if
       accepted = sudakov%reweight_ubf (r%pt2)
       call sudakov%veto_counter%record_ubf (.not. accepted)
       if (.not. accepted) then
          sudakov%current_pt2_max = r%pt2
          cycle
       end if
       accepted = sudakov%reweight_alpha_s (r%pt2)
       call sudakov%veto_counter%record_alpha_s (.not. accepted)
       if (.not. accepted) then
          sudakov%current_pt2_max = r%pt2
          cycle
       end if
       call sudakov%generate_xi_and_y_and_phi (r)
       accepted = sudakov%reweight_xi_max (r%xi)
       call sudakov%veto_counter%record_xi_max (.not. accepted)
       if (.not. accepted) then
          sudakov%current_pt2_max = r%pt2
          cycle
       end if
       if (debug_active (D_MATCHING)) then
          call assert_equal (OUTPUT_UNIT, r%pt2, &
               sudakov%kt2 (r%xi, r%y), &
               "sudakov_generate_xi_and_y_and_phi: pt2 inconsistency")
          ! for this we have to recompute z?
          !call msg_bug ()
       end if
       r%valid = .true.
       exit
    end do LOOP_UNTIL_ACCEPTED
  end subroutine sudakov_generate_emission

@ %def sudakov_generate_emission
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: evaluate => sudakov_evaluate
<<POWHEG matching: procedures>>=
  pure function sudakov_evaluate (solver_f, x) result (f)
    complex(default) :: f
    class(sudakov_t), intent(in) :: solver_f
    real(default), intent(in) :: x
    f = solver_f%last_log + solver_f%norm_max * solver_f%log_integrated_ubf (x)
    !f = log (solver_f%random) + solver_f%norm_max * solver_f%log_integrated_ubf (x) &
         !- solver_f%last_log
  end function sudakov_evaluate

@ %def sudakov_evaluate
@
\subsubsection{Simple FSR}
This corresponds to Appendix C of [[1002.2581]]
<<POWHEG matching: public>>=
  public :: sudakov_simple_fsr_t
<<POWHEG matching: types>>=
  type, extends (sudakov_t) :: sudakov_simple_fsr_t
  contains
   <<POWHEG matching: sudakov simple fsr: TBP>>
  end type sudakov_simple_fsr_t

@ %def sudakov_simple_fsr_t
@ The simplest upper bounding function for final-state radiation is
\begin{equation}
\mathtt{upper\_bound\_func} = \frac {U(\xi,y)} N
                          = \frac {\alpha_s}{\xi (1-y)}
\end{equation}
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: upper_bound_func => sudakov_simple_fsr_upper_bound_func
<<POWHEG matching: procedures>>=
  pure function sudakov_simple_fsr_upper_bound_func (sudakov, xi, y, alpha_s) result (u)
    real(default) :: u
    class(sudakov_simple_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y, alpha_s
    u = alpha_s / (xi * (1 - y))
  end function sudakov_simple_fsr_upper_bound_func

@ %def sudakov_simple_fsr_upper_bound_func
@ The above upper bounding function corresponds to the transverse momentum scale
\begin{equation}
  k_T^2 = \frac{s}{2} \xi^2 (1-y).
\end{equation}
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: kt2 => sudakov_simple_fsr_kt2
<<POWHEG matching: procedures>>=
  function sudakov_simple_fsr_kt2 (sudakov, xi, y) result (kt2)
    real(default) :: kt2
    class(sudakov_simple_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y
    kt2 = sudakov%phs_fks_generator%real_kinematics%kt2 &
          (sudakov%associated_emitter, FSR_SIMPLE, xi, y)
  end function sudakov_simple_fsr_kt2

@ %def sudakov_simple_fsr_kt2
@ For massless emitters, the upper bound on the radiated energy is
\begin{equation*}
  t_{\mathrm{max}} = \xi_{\mathrm{max}}^2 \hat{s}
\end{equation*}
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: kt2_max => sudakov_simple_fsr_kt2_max
<<POWHEG matching: procedures>>=
  pure function sudakov_simple_fsr_kt2_max (sudakov, s_hat) result (kt2_max)
     real(default) :: kt2_max
     class(sudakov_simple_fsr_t), intent(in) :: sudakov
     real(default), intent(in) :: s_hat
     kt2_max = sudakov%xi2_max * s_hat
  end function sudakov_simple_fsr_kt2_max

@ %def sudakov_simple_fsr_kt2_max
@ This is
\begin{equation}
  - \frac{\log{\Delta^{(U)}}(p_T)}{N} =
    \frac\pi{b_0} \theta\left(\xi_\text{max}^2-\frac{p_T^2}s\right)
    \left[\log{\frac{\xi^2_\text{max}s}{\Lambda^2}}
    \log{\frac{\log{{\xi^2_\text{max}s}/{\Lambda^2}}}
              {\log{p_T^2/\Lambda^2}}} -
          \log{\frac{\xi^2_\text{max}s}{p_T^2}}\right]
\end{equation}
with $p_\text{T,max}^2=\xi_\text{max}^2s$.
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: log_integrated_ubf => sudakov_simple_fsr_log_integrated_ubf
<<POWHEG matching: procedures>>=
  pure function sudakov_simple_fsr_log_integrated_ubf (sudakov, pt2) result (y)
    real(default) :: y
    class(sudakov_simple_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: pt2
    real(default) :: xm2s, xm2sl, pt2l
    logical :: within_boundaries
    within_boundaries = pt2 / sudakov%event_deps%s_hat <= sudakov%xi2_max &
         .and. pt2 >= sudakov%powheg_settings%pt2_min
    if (within_boundaries) then
       xm2s = sudakov%xi2_max * sudakov%event_deps%s_hat
       xm2sl = xm2s / sudakov%process_deps%lambda2_gen
       pt2l = pt2 / sudakov%process_deps%lambda2_gen
       y = pi / b0rad * (log (xm2sl) * &
            log (log (xm2sl) / log (pt2l)) - &
            log (xm2s / pt2))
    else
       y = 0
    end if
  end function sudakov_simple_fsr_log_integrated_ubf

@ %def sudakov_simple_fsr_log_integrated_ubf
@ No further veto needed for this upper bounding function.
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: reweight_ubf => sudakov_simple_fsr_reweight_ubf
<<POWHEG matching: procedures>>=
  function sudakov_simple_fsr_reweight_ubf (sudakov, pt2) result (accepted)
    logical :: accepted
    class(sudakov_simple_fsr_t), intent(inout) :: sudakov
    real(default), intent(in) :: pt2
    accepted = .true.
  end function sudakov_simple_fsr_reweight_ubf

@ %def sudakov_simple_fsr_reweight_ubf
@
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: reweight_xi_max => sudakov_simple_fsr_reweight_xi_max
<<POWHEG matching: procedures>>=
  function sudakov_simple_fsr_reweight_xi_max (sudakov, xi) result (accepted)
     logical :: accepted
     class(sudakov_simple_fsr_t), intent(in) :: sudakov
     real(default), intent(in) :: xi
     accepted = .true.
  end function sudakov_simple_fsr_reweight_xi_max

@ %def sudakov_simple_fsr_reweight_xi_max
@ This depends on the choice of $p_T$ and is tested in the assertion.
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: generate_xi_and_y_and_phi => sudakov_simple_fsr_generate_xi_and_y_and_phi
<<POWHEG matching: procedures>>=
  subroutine sudakov_simple_fsr_generate_xi_and_y_and_phi (sudakov, r)
    class(sudakov_simple_fsr_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    real(default) :: s
    s = sudakov%event_deps%s_hat
    call sudakov%generate_xi (r)
    r%y = one - (two * r%pt2) / (s * r%xi**2)
    call sudakov%rng%generate (sudakov%random)
    r%phi = sudakov%random * twopi
  end subroutine sudakov_simple_fsr_generate_xi_and_y_and_phi

@ %def sudakov_generate_xi_and_y_and_phi
@ Generate $\xi \in [\frac{p_\text{T}}{\sqrt{s}}, \xi_\text{max}]$
with a density $1 / \xi$
<<POWHEG matching: sudakov simple fsr: TBP>>=
  procedure :: generate_xi => sudakov_simple_fsr_generate_xi
<<POWHEG matching: procedures>>=
  subroutine sudakov_simple_fsr_generate_xi (sudakov, r)
    class(sudakov_simple_fsr_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    real(default) :: s, xi2_max
    s = sudakov%event_deps%s_hat
    xi2_max = sudakov%xi2_max
    call sudakov%rng%generate (sudakov%random)
    r%xi = exp (((one - sudakov%random) * log (r%pt2 / s) + &
         sudakov%random * log (xi2_max)) / two)
  end subroutine sudakov_simple_fsr_generate_xi

@ %def sudakov_simple_fsr_generate_xi
@
\subsubsection{Dijet production at lepton colliders}
In the POWHEG method paper, this is done for $e^+e^-\to q\bar{q}$.
There $k_\text{max}=q^0/2=\sqrt{s}/2$. We slightly extend this to
<<POWHEG matching: public>>=
  public :: sudakov_eeqq_fsr_t
<<POWHEG matching: types>>=
  type, extends (sudakov_t) :: sudakov_eeqq_fsr_t
  contains
   <<POWHEG matching: sudakov eeqq fsr: TBP>>
  end type sudakov_eeqq_fsr_t

@ %def sudakov_eeqq_fsr_t
@ This $k_T$ measure is the same as the simple FSR up to
$\mathcal{O}(\theta^4)$ when $y=\cos\theta$.
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: kt2 => sudakov_eeqq_fsr_kt2
<<POWHEG matching: procedures>>=
  function sudakov_eeqq_fsr_kt2 (sudakov, xi, y) result (kt2)
    real(default) :: kt2
    class(sudakov_eeqq_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y
    kt2 = sudakov%event_deps%s_hat / 2 * xi**2 * (1 - y**2) / 2
    ! TODO: (bcn 2015-07-13) call here phs_fks_generator%real_kinematics%kt2
  end function sudakov_eeqq_fsr_kt2

@ %def sudakov_eeqq_fsr_kt2
@ Same expression as for [[sudakov_simple_fsr_kt2_max]]
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: kt2_max => sudakov_eeqq_fsr_kt2_max
<<POWHEG matching: procedures>>=
  pure function sudakov_eeqq_fsr_kt2_max (sudakov, s_hat) result (kt2_max)
     real(default) :: kt2_max
     class(sudakov_eeqq_fsr_t), intent(in) :: sudakov
     real(default), intent(in) :: s_hat
     kt2_max = sudakov%xi2_max * s_hat
  end function sudakov_eeqq_fsr_kt2_max

@ %def sudakov_eeqq_fsr_kt2_max
@ This covers also the singularity at $(\xi,y)\to(1,-1)$ that occurs for
a massless recoiling system.
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: upper_bound_func => sudakov_eeqq_fsr_upper_bound_func
<<POWHEG matching: procedures>>=
  pure function sudakov_eeqq_fsr_upper_bound_func (sudakov, xi, y, alpha_s) result (u)
    real(default) :: u
    class(sudakov_eeqq_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y, alpha_s
    u = alpha_s / (xi * (1 - y**2))
  end function sudakov_eeqq_fsr_upper_bound_func

@ %def sudakov_eeqq_fsr_upper_bound_func
@
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: log_integrated_ubf => sudakov_eeqq_fsr_log_integrated_ubf
<<POWHEG matching: procedures>>=
  pure function sudakov_eeqq_fsr_log_integrated_ubf (sudakov, pt2) result (y)
    real(default) :: y
    class(sudakov_eeqq_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: pt2
    logical :: within_boundaries
    within_boundaries = pt2 / sudakov%event_deps%s_hat <= sudakov%xi2_max &
         .and. pt2 >= sudakov%powheg_settings%pt2_min
    if (within_boundaries) then
       !xm2s = sudakov%xi2_max * sudakov%event_deps%s_hat
       !xm2sl = xm2s / sudakov%process_deps%lambda2_gen
       !pt2l = pt2 / sudakov%process_deps%lambda2_gen
       !y = pi / b0rad * (log (xm2sl) * &
            !log (log (xm2sl) / log (pt2l)) - &
            !log (xm2s / pt2))
    else
       y = 0
    end if
  end function sudakov_eeqq_fsr_log_integrated_ubf

@ %def sudakov_eeqq_fsr_log_integrated_ubf
@
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: reweight_ubf => sudakov_eeqq_fsr_reweight_ubf
<<POWHEG matching: procedures>>=
  function sudakov_eeqq_fsr_reweight_ubf (sudakov, pt2) result (accepted)
    logical :: accepted
    class(sudakov_eeqq_fsr_t), intent(inout) :: sudakov
    real(default), intent(in) :: pt2
    accepted = .false.
  end function sudakov_eeqq_fsr_reweight_ubf

@ %def sudakov_eeqq_fsr_reweight_ubf
@
<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: reweight_xi_max => sudakov_eeqq_fsr_reweight_xi_max
<<POWHEG matching: procedures>>=
  function sudakov_eeqq_fsr_reweight_xi_max (sudakov, xi) result (accepted)
     logical :: accepted
     class(sudakov_eeqq_fsr_t), intent(in) :: sudakov
     real(default), intent(in) :: xi
     accepted = .true.
  end function sudakov_eeqq_fsr_reweight_xi_max

@ %def sudakov_eeqq_fsr_reweight_xi_max

<<POWHEG matching: sudakov eeqq fsr: TBP>>=
  procedure :: generate_xi_and_y_and_phi => sudakov_eeqq_fsr_generate_xi_and_y_and_phi
<<POWHEG matching: procedures>>=
  subroutine sudakov_eeqq_fsr_generate_xi_and_y_and_phi (sudakov, r)
    class(sudakov_eeqq_fsr_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    real(default) :: s
    s = sudakov%event_deps%s_hat
    !r%xi = sudakov%generate_xi (r)
    !r%y = one - (two * r%pt2) / (s * r%xi**2)
    call sudakov%rng%generate (sudakov%random)
    r%phi = sudakov%random * twopi
  end subroutine sudakov_eeqq_fsr_generate_xi_and_y_and_phi

@ %def sudakov_generate_xi_and_y_and_phi
@
\subsubsection{Massive FSR}
<<POWHEG matching: public>>=
  public :: sudakov_massive_fsr_t
<<POWHEG matching: types>>=
  type, extends (sudakov_t) :: sudakov_massive_fsr_t
    real(default) :: z, z1, z2 = 0._default
    real(default) :: xi_1, xi_min, xi_m = 0._default
    real(default) :: xi_max_extended = 1._default
  contains
  <<POWHEG matching: sudakov massive fsr: TBP>>
  end type sudakov_massive_fsr_t

@ %def sudakov_massive_fsr_t
@ During the radiation generation, an alternative expression for $\xi_{\mathrm{max}}$,
\begin{equation*}
  \xi_{\mathrm{max}} = 1 - \frac{(m+m_{\mathrm{rec}})^2}{q^2},
\end{equation*}
is used, which corresponds to an extenden Dalitz region. Phase space points outside of
the original Dalitz region will be vetoed afterwards.
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: compute_xi_max_extended &
     => sudakov_massive_fsr_compute_xi_max_extended
<<POWHEG matching: procedures>>=
  subroutine sudakov_massive_fsr_compute_xi_max_extended (sudakov)
     class(sudakov_massive_fsr_t), intent(inout) :: sudakov
     real(default) :: m, mrec
     real(default) :: q0
     q0 = sqrt(sudakov%event_deps%s_hat)
     associate (p => sudakov%event_deps%p_born_lab(sudakov%associated_emitter))
        m = p**1
        mrec = sqrt ((q0-p%p(0))**2 - p%p(1)**2 - p%p(2)**2 - p%p(3)**2)
     end associate
     sudakov%xi_max_extended = one - (m + mrec)**2 / q0**2
  end subroutine sudakov_massive_fsr_compute_xi_max_extended

@ %def sudakov_massive_fsr_compute_xi_max_extended
@ For massive emitters, the radiation variable $\xi$ is constructed as follows. First,
\begin{equation}
  \xi_{\mathrm{min}}(k_T^2)
      = \frac{\sqrt{k_T^2 \left(k_T^2z_2^2 + 8\bar{p}^0q(1-z_2\right)} - k_T^2z_2}{2q^2(1-z_2)}
\end{equation}
is computed. Then $\xi_1$ is computed according to the same equation with $z_2 \leftrightarrow z_1$.
Finally, $\xi$ is generated according to
\begin{equation}
  \xi = \frac{1}{q^2}\exp\left[\log\left(\xi_{\rm{min}}q^2-k_T^2\right)
        + r\log\frac{\xi_m q^2 - k_T^2}{\xi_{\rm{min}}q^2-k_T^2} + k_T^2\right],
\end{equation}
where $\xi_m = \rm{min}\left(\xi_{\rm{max}}, \xi_1\right)$.
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: generate_xi => sudakov_massive_fsr_generate_xi
<<POWHEG matching: procedures>>=
  subroutine sudakov_massive_fsr_generate_xi (sudakov, r)
    class(sudakov_massive_fsr_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    real(default) :: pt2, q0, q02
    real(default) :: E_em, xi_max
    real(default) :: xi_1, xi_min, xi_m
    pt2 = r%pt2
    E_em = energy (sudakov%event_deps%p_born_lab(sudakov%associated_emitter))
    q02 = sudakov%event_deps%s_hat; q0 = sqrt(q02)
    !xi_max = sqrt (sudakov%xi2_max)
    xi_max = sudakov%xi_max_extended
    associate (z1 => sudakov%z1, z2 => sudakov%z2)
       xi_1 = (sqrt(pt2 * (pt2*z1**2 + 8*E_em*q0*(one-z1))) - pt2*z1) / &
         (2*q02*(one-z1))
       xi_min = (sqrt(pt2 * (pt2*z2**2 + 8*E_em*q0*(one-z2))) - pt2*z2) / &
         (2*q02*(one-z2))
    end associate
    xi_m = min (xi_max, xi_1)
    call sudakov%rng%generate (sudakov%random)
    r%xi = (exp (log(xi_min*q02 - pt2) + sudakov%random * &
          log((xi_m*q02 - pt2) / (xi_min*q02 - pt2))) + pt2) / q02
  end subroutine sudakov_massive_fsr_generate_xi

@ %def sudakov_massive_fsr_generate_xi
@
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: generate_xi_and_y_and_phi => sudakov_massive_fsr_generate_xi_and_y_and_phi
<<POWHEG matching: procedures>>=
  subroutine sudakov_massive_fsr_generate_xi_and_y_and_phi (sudakov, r)
    class(sudakov_massive_fsr_t), intent(inout) :: sudakov
    type(radiation_t), intent(inout) :: r
    real(default) :: q0
    real(default) :: m2, mrec2, k0_rec_max
    real(default) :: E_em
    type(vector4_t) :: p_emitter

    q0 = sqrt (sudakov%event_deps%s_hat)
    p_emitter = sudakov%event_deps%p_born_lab(sudakov%associated_emitter)
    associate (p => p_emitter%p)
      mrec2 = (q0 - p(0))**2 - p(1)**2 - p(2)**2 - p(3)**2
      E_em = p(0)
    end associate
    m2 = p_emitter**2
    call compute_dalitz_bounds (q0, m2, mrec2, sudakov%z1, sudakov%z2, k0_rec_max)
    call sudakov%generate_xi (r)

    sudakov%z = (2*r%pt2*E_em - r%xi**2*q0**3) / (r%pt2*r%xi*q0 - r%xi**2*q0**3)
    sudakov%xi2_max = - (q0**2*sudakov%z**2 - two*q0*k0_rec_max*sudakov%z + mrec2) / &
                        (q0**2*sudakov%z*(one-sudakov%z))
    sudakov%xi2_max = sudakov%xi2_max**2
    r%y = two*(sudakov%z2-sudakov%z)/(sudakov%z2-sudakov%z1) - one
    call sudakov%rng%generate (sudakov%random)
    r%phi = sudakov%random * twopi
  end subroutine sudakov_massive_fsr_generate_xi_and_y_and_phi

@ %def sudakov_massive_fsr_generate_xi_and_y_and_phi
@ Computes the hardness scale:
\begin{equation}
  K_T^2 = \frac{\xi^2q^2(1-z)}{2\bar{p}_{\rm{em}}^0 - z\xi q}
  \label{HardnessMassiveFSR}
\end{equation}
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: kt2 => sudakov_massive_fsr_kt2
<<POWHEG matching: procedures>>=
  function sudakov_massive_fsr_kt2 (sudakov, xi, y) result (kt2)
    real(default) :: kt2
    class(sudakov_massive_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y
    kt2 = sudakov%phs_fks_generator%real_kinematics%kt2 &
          (sudakov%associated_emitter, FSR_MASSIVE, xi, y)
  end function sudakov_massive_fsr_kt2

@ %def sudakov_massive_fsr_kt2
@ For massive emitters, the upper bound on the radiated $p_T$ is
\begin{equation*}
  t_{\mathrm{max}} = \frac{\xi_{\mathrm{max}}^2q^3(1-z_2)}{2*\bar{p}^0 - z_2\xi_{\mathrm{max}}q}
\end{equation*}
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: kt2_max => sudakov_massive_fsr_kt2_max
<<POWHEG matching: procedures>>=
  pure function sudakov_massive_fsr_kt2_max (sudakov, s_hat) result (kt2_max)
     real(default) :: kt2_max
     class(sudakov_massive_fsr_t), intent(in) :: sudakov
     real(default), intent(in) :: s_hat
     real(default) :: q, E_em, xi_max, z2
     q = sqrt(s_hat)
     E_em = energy (sudakov%event_deps%p_born_lab (sudakov%associated_emitter))
     !xi_max = sqrt(sudakov%xi2_max)
     xi_max = sudakov%xi_max_extended
     z2 = sudakov%z2
     kt2_max = (xi_max**2*q**3*(one-z2)) / (2*E_em - z2*xi_max*q)
  end function sudakov_massive_fsr_kt2_max

@ %def sudakov_massive_fsr_kt2_max
@ The upper bounding function for massive emitters is (disregarding a possible factor of $\alpha_s$)
\begin{equation}
  U(\xi, y) \sim \frac{\sqrt{s}}{\bar{p}_{\rm{em}}} \frac{1}{\xi(1-z)}
  \label{UBFMassiveFSR}
\end{equation}
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: upper_bound_func => sudakov_massive_fsr_upper_bound_func
<<POWHEG matching: procedures>>=
  pure function sudakov_massive_fsr_upper_bound_func (sudakov, xi, y, alpha_s) result (u)
    real(default) :: u
    class(sudakov_massive_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi, y, alpha_s
    real(default) :: q, p_em
    q = sqrt (sudakov%event_deps%s_hat)
    p_em = space_part_norm (sudakov%event_deps%p_born_lab(sudakov%associated_emitter))
    u = alpha_s * q/p_em * one/(xi*(one-sudakov%z))
  end function sudakov_massive_fsr_upper_bound_func

@ %def sudakov_massive_fsr_upper_bound_func
@ The integrated upper-bounding function for massive final-state emitters is given by
\begin{align*}
  I(t) &= \frac{q}{\bar{p}_{\rm{em}}}\left[\log\xi\log\left[(1-z_2)\frac{q}{k_T^2}\right] +
          \frac{1}{2} \log^2\xi + G(-k_T^2,q^2,\xi) - G(2\bar{p}_{\rm{em}},-q,\xi)\right]
          ^{\rm{min}(\xi_1(k_T^2),\xi_{\rm{max}}}_{\xi_{\rm{min}}}) \\
       &+ \frac{q}{\bar{p}_{\rm{em}}} \theta (\xi_{\rm{max}} - \xi_1(k_T^2))
          \log\frac{\xi_{\rm{max}}}{\xi_1(k_T^2)}\log\frac{1-z_2}{1-z_1},
\end{align*}
where the function $G(a,b,\xi)$ is given by
\begin{equation}
  G(a,b,\xi) = \log(a+b\xi)\log\left(1-\frac{a+b\xi}{a}\right) + Li_2\left(\frac{a+b\xi}{a}\right),
  \label{GMinusMassiveFSR}
\end{equation}
for $a < 0$ and by
\begin{equation}
  G(a,b,\xi) = \log\left|\frac{b\xi}{a}\right|\log a - Li_2\left(-\frac{b\xi}{a}\right) + \frac{\pi^2}{6},
  \label{GPlusMassiveFSR}
\end{equation}
for $a > 0$.
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: log_integrated_ubf => sudakov_massive_fsr_log_integrated_ubf
<<POWHEG matching: procedures>>=
  pure function sudakov_massive_fsr_log_integrated_ubf (sudakov, pt2) result (y)
    real(default) :: y
    class(sudakov_massive_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: pt2
    real(default) :: xi, xi_max, xi_1, xi_min
    real(default) :: q0, p_em, E_em
    real(default) :: y1, y2
    q0 = sqrt (sudakov%event_deps%s_hat)
    E_em = energy (sudakov%event_deps%p_born_lab(sudakov%associated_emitter))
    p_em = space_part_norm (sudakov%event_deps%p_born_lab(sudakov%associated_emitter))
    xi_max = sudakov%xi_max_extended
    associate (z1 => sudakov%z1, z2 => sudakov%z2)
       xi_1 = (sqrt (pt2*(pt2*z1**2 + 8*E_em*q0*(one-z1))) - pt2*z1) / (2*q0**2*(one-z1))
       xi_min = (sqrt (pt2*(pt2*z2**2 + 8*E_em*q0*(one-z2))) - pt2*z2) / (2*q0**2*(one-z2))
       xi = min (xi_1, xi_max)
       y1 = log(xi)*log((one-z2)*q0/pt2) + log(xi)**2/two + G_FSR(-pt2,q0**2,xi) - G_FSR(2*E_em,-q0,xi)
       xi = xi_min
       y2 = log(xi)*log((one-z2)*q0/pt2) + log(xi)**2/two + G_FSR(-pt2,q0**2,xi) - G_FSR(2*E_em,-q0,xi)
       y = y1 - y2
       if (xi_max > xi_1) &
          y = y + log(xi_max/xi_1)*log((one-z2)/(one-z1))
       y = twopi*q0/p_em * y
    end associate
  end function sudakov_massive_fsr_log_integrated_ubf

@ %def sudakov_massive_fsr_log_integrated_ubf
@ No further ubf veto needed for now.
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: reweight_ubf => sudakov_massive_fsr_reweight_ubf
<<POWHEG matching: procedures>>=
  function sudakov_massive_fsr_reweight_ubf (sudakov, pt2) result (accepted)
    logical :: accepted
    class(sudakov_massive_fsr_t), intent(inout) :: sudakov
    real(default), intent(in) :: pt2
    accepted = .true.
  end function sudakov_massive_fsr_reweight_ubf

@ %def sudakov_massive_fsr_reweight_ubf
@
<<POWHEG matching: sudakov massive fsr: TBP>>=
  procedure :: reweight_xi_max => sudakov_massive_fsr_reweight_xi_max
<<POWHEG matching: procedures>>=
  function sudakov_massive_fsr_reweight_xi_max (sudakov, xi) result (accepted)
    logical :: accepted
    class(sudakov_massive_fsr_t), intent(in) :: sudakov
    real(default), intent(in) :: xi
    accepted = xi < sqrt (sudakov%xi2_max)
  end function sudakov_massive_fsr_reweight_xi_max

@ %def sudakov_massive_fsr_reweight_xi_max
@
\subsubsection{Auxiliary functions}
Implements the function $G(a,b,\xi)$ given in eq. (\ref{GPlusMassiveFSR}) and eq. (\ref{GMinusMassiveFSR}).
<<POWHEG matching: procedures>>=
  elemental function G_FSR (a,b,xi)
    real(default) :: G_FSR
    real(default), intent(in) :: a, b, xi
    if (a > 0) then
       G_FSR = G_FSR_Plus (a,b,xi)
    else if (a < 0) then
       G_FSR = G_FSR_Minus (a,b,xi)
    !!! a == 0 ?
    end if
  end function G_FSR

  elemental function G_FSR_Minus (a,b,xi)
    real(default) :: G_FSR_Minus
    real(default), intent(in) :: a, b, xi
    G_FSR_Minus = log(a+b*xi)*log(one - (a+b*xi)/a) + Li2((a+b*xi)/a)
  end function G_FSR_Minus

  elemental function G_FSR_Plus (a,b,xi)
    real(default) :: G_FSR_Plus
    real(default), intent(in) :: a, b, xi
    G_FSR_Plus = log(abs(b*xi/a))*log(a) - Li2(-b*xi/a) + pi**2/6
  end function G_FSR_Plus

@ %def G_FSR, G_FSR_Minus, G_FSR_Plus
@
\subsection{Main POWHEG class}
<<POWHEG matching: public>>=
  public :: powheg_matching_t
<<POWHEG matching: types>>=
  type, extends(matching_t) :: powheg_matching_t
     type(grid_t) :: grid
     type(phs_fks_generator_t) :: phs_fks_generator
     type(powheg_settings_t) :: settings
     type(powheg_testing_t) :: testing
     type(event_deps_t) :: event_deps
     type(process_deps_t) :: process_deps
     type(sudakov_wrapper_t), dimension(:), allocatable :: sudakov
     integer :: n_emissions = 0
     logical :: active = .true.
   contains
   <<POWHEG matching: powheg matching: TBP>>
  end type powheg_matching_t

@ %def powheg_matching_t
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: get_method => powheg_matching_get_method
<<POWHEG matching: procedures>>=
  function powheg_matching_get_method (matching) result (method)
     type(string_t) :: method
     class(powheg_matching_t), intent(in) :: matching
     method = matching_method (MATCH_POWHEG) 
  end function powheg_matching_get_method

@ %def powheg_matching_get_method
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: before_shower => powheg_matching_before_shower
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_before_shower &
         (matching, particle_set, vetoed)
    class(powheg_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(inout) :: particle_set
    logical, intent(out) :: vetoed
    if (signal_is_pending ())  return
    if (.not. matching%active)  return
    call matching%update (particle_set)
    if (matching%settings%test_sudakov) then
       call matching%test_sudakov ()
       stop
    end if
    call matching%generate_emission (particle_set = particle_set)
    vetoed = .false.
  end subroutine powheg_matching_before_shower

@ %def powheg_matching_before_shower
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: first_event => powheg_matching_first_event
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_first_event (matching)
    class(powheg_matching_t),  intent(inout), target :: matching
    call matching%setup_grids ()
    associate (instance => matching%process_instance)
       matching%process_deps%cm_frame = instance%is_cm_frame (1)
    end associate
  end subroutine powheg_matching_first_event

@ %def powheg_matching_first_event
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: after_shower => powheg_matching_after_shower
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_after_shower (matching, particle_set, vetoed)
    class(powheg_matching_t), intent(inout) :: matching
    type(particle_set_t), intent(inout) :: particle_set
    logical, intent(out) :: vetoed
    vetoed = .false.
  end subroutine powheg_matching_after_shower

@ %def powheg_matching_after_shower
@
\subsubsection{Output}
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: display_grid_startup_message => &
                      powheg_display_grid_startup_message
<<POWHEG matching: procedures>>=
  subroutine powheg_display_grid_startup_message (powheg)
    class(powheg_matching_t), intent(in) :: powheg
    real(default) :: points_per_cell
    write (msg_buffer, "(A,A,A)") "POWHEG: Generating grid for process '", &
                               char (powheg%process_name), "'"
    call msg_message ()
    associate (settings => powheg%settings)
       write (msg_buffer, "(A,I10)") "Number of xi-points: ", &
                                      settings%size_grid_xi
       call msg_message ()
       write (msg_buffer, "(A,I10)") "Number of y-points: ", &
                                      settings%size_grid_y
       call msg_message ()
       write (msg_buffer, "(A,I10,A)") "Using ", settings%n_init , &
                                       " sampling points"
       call msg_message ()
       points_per_cell =  settings%n_init*one / &
                          (settings%size_grid_xi * settings%size_grid_y)
       write (msg_buffer, "(A,F10.2,A)") "Average: ", points_per_cell, &
                                        " points per cell"
       call msg_message ()
       call msg_message ("Progress:")
    end associate
  end subroutine powheg_display_grid_startup_message

@ %def powheg_display_grid_startup_message
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: write => powheg_write
<<POWHEG matching: procedures>>=
  subroutine powheg_write (matching, unit)
    class(powheg_matching_t), intent(in) :: matching
    integer, intent(in), optional :: unit
    integer :: u, alr
    u = given_output_unit (unit);  if (u < 0)  return
    call write_separator (u, 2)
    write (u, "(1X,A)") "POWHEG Emission Generator"
    write (u, "(1X,A)") "Process name: " // char (matching%process_name)
    if (allocated (matching%rng)) then
       call matching%rng%write (u)
    else
       write (u, "(1X,A)") "RNG not allocated"
    end if
    if (associated (matching%qcd)) then
       call matching%qcd%write (u)
    else
       write (u, "(1X,A)") "QCD not associated"
    end if
    call matching%settings%write (u)
    call matching%event_deps%write (u)
    call matching%process_deps%write (u)
    do alr = 1, size (matching%sudakov)
       call write_separator (u)
       write (u, "(1X,A,I12,A)") "sudakov (alr = ", alr, ")"
       call matching%sudakov(alr)%s%write (u)
    end do
    call write_separator (u, 2)
  end subroutine powheg_write

@ %def powheg_write
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: final => powheg_matching_final
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_final (matching)
    class(powheg_matching_t), intent(in) :: matching
    integer :: u, alr
    type(string_t) :: filename
    u = free_unit ()
    filename = matching%process_name // "_veto.log"
    open (file=char(filename), unit=u, action='write')
    write (u, '(A)') "Summary of POWHEG veto procedure"
    do alr = 1, matching%process_deps%n_alr
       write(u,'(A,I0)') 'alr: ', alr
       call matching%sudakov(alr)%s%veto_counter%write (u)
       call write_separator (u)
    end do
    write (u,'(A,I0)') "Total number of events which radiate a gluon: ", &
                       matching%n_emissions
    close (u)
  end subroutine powheg_matching_final

@ %def powheg_matching_final
@
\subsubsection{Initialization and Finalization}
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: setup_grids => powheg_matching_setup_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_setup_grids (matching)
    class(powheg_matching_t), intent(inout), target :: matching
    call matching%prepare_for_events ()
    if (matching%requires_new_grids ()) then
       call matching%fill_grids ()
       call matching%save_grids ()
    else
       call matching%load_grids ()
    end if
    call matching%grid%compute_and_write_mean_and_max ()
    call matching%import_norms_from_grid ()
  end subroutine powheg_matching_setup_grids

@ %def powheg_matching_setup_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: setup_sudakovs => powheg_matching_setup_sudakovs
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_setup_sudakovs (powheg)
    class(powheg_matching_t), intent(inout), target :: powheg
    integer :: alr, emitter
    logical :: is_fsr, is_massive
    integer :: ubf_type
    allocate (powheg%sudakov (powheg%process_deps%n_alr))
    is_fsr = .true.
    do alr = 1, powheg%process_deps%n_alr
       if (is_fsr) then
          ubf_type = powheg%settings%upper_bound_func
          select type (pcm => powheg%process_instance%pcm)
          class is (pcm_instance_nlo_t)
             if (.not. powheg%testing%active) then
                emitter = pcm%controller%get_emitter (alr)
                is_massive = powheg%phs_fks_generator%is_massive (emitter)
             else
                emitter = 1
                is_massive = .false.
             end if
          end select
          if (is_massive) ubf_type = UBF_MASSIVE
          select case (ubf_type)
          case (UBF_SIMPLE)
             allocate (sudakov_simple_fsr_t :: powheg%sudakov(alr)%s)
          case (UBF_EEQQ)
             allocate (sudakov_eeqq_fsr_t :: powheg%sudakov(alr)%s)
          case (UBF_MASSIVE)
             allocate (sudakov_massive_fsr_t :: powheg%sudakov(alr)%s)
          case default
             call msg_fatal ("powheg_setup_sudakovs: Please choose upper bounding function!")
          end select
       else
          call msg_fatal ("powheg_setup_sudakovs: ISR not implemented yet!")
       end if

       call powheg%sudakov(alr)%s%init (powheg%process_deps, &
            powheg%event_deps, powheg%settings, &
            powheg%phs_fks_generator, powheg%qcd, powheg%rng)

       powheg%sudakov(alr)%s%associated_emitter = emitter
    end do
  end subroutine powheg_matching_setup_sudakovs

@ %def powheg_matching_setup_sudakovs
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: init => powheg_matching_init
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_init (matching, var_list, process_name)
    class(powheg_matching_t), intent(out) :: matching
  <<default matching init>>
  end subroutine powheg_matching_init

@ %def powheg_matching_init
<<POWHEG matching: powheg matching: TBP>>=
  generic :: update => update_momenta, &
                       update_particle_set
  procedure :: update_momenta => powheg_matching_update_momenta
  procedure :: update_particle_set => powheg_matching_update_particle_set
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_update_momenta (powheg, p_born)
    class(powheg_matching_t), intent(inout) :: powheg
    type(vector4_t), dimension(:), intent(in) :: p_born
    type(lorentz_transformation_t) :: lt_lab_to_cms
    
    if (.not. powheg%process_deps%cm_frame) then
       lt_lab_to_cms = inverse (powheg%process_instance%get_lorentz_transformation (1))
       call powheg%update_event_deps (powheg%process_instance%pcm, &
          p_born, lt_lab_to_cms)
    else
       call powheg%update_event_deps (powheg%process_instance%pcm, p_born)
    end if
  end subroutine powheg_matching_update_momenta

  subroutine powheg_matching_update_particle_set (powheg, particle_set)
    class(powheg_matching_t), intent(inout) :: powheg
    type(particle_set_t), intent(in) :: particle_set
    integer, dimension(:), allocatable :: indices
    logical, dimension(:), allocatable :: in_out_mask
    integer :: i
    allocate (in_out_mask (particle_set%get_n_tot()))
    do i = 1, particle_set%get_n_tot()
       in_out_mask(i) = particle_set%prt(i)%get_status () == PRT_INCOMING &
            .or. particle_set%prt(i)%get_status () == PRT_OUTGOING
    end do
    allocate (indices (size (particle_set%get_indices (in_out_mask))))
    indices = particle_set%get_indices (in_out_mask)
    call powheg%update_momenta (particle_set%get_momenta (indices))
  end subroutine powheg_matching_update_particle_set

@ %def powheg_matching_update
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: update_event_deps => powheg_matching_update_event_deps 
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_update_event_deps (powheg, pcm, p_born, lt_lab_to_cms)
    class(powheg_matching_t), intent(inout) :: powheg
    class(pcm_instance_t), intent(in) :: pcm
    type(vector4_t), dimension(:), intent(in) :: p_born
    type(lorentz_transformation_t), intent(in), optional :: lt_lab_to_cms
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. powheg%testing%active) then
          call powheg%event_deps%update &
               (pcm%collector%get_sqme_born(1), p_born, lt_lab_to_cms)
       else
          call powheg%event_deps%update &
               (powheg%testing%sqme_born, p_born, lt_lab_to_cms)
       end if
    end select
  end subroutine powheg_matching_update_event_deps

@ %def powheg_matching_update_event_deps
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: boost_preal_to_lab_frame => powheg_matching_boost_preal_to_lab_frame
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_boost_preal_to_lab_frame (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    type(lorentz_transformation_t) :: lt_cms_to_lab
    associate (event_deps => powheg%event_deps)
       if (powheg%process_deps%cm_frame) then
          event_deps%p_real_lab = event_deps%p_real_cms
       else
          lt_cms_to_lab = powheg%process_instance%get_lorentz_transformation (1)
          event_deps%p_real_lab = lt_cms_to_lab * event_deps%p_real_cms
       end if
    end associate
  end subroutine powheg_matching_boost_preal_to_lab_frame
    
@ %def powheg_matching_boost_preal_to_lab_frame
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: reweight_matrix_elements => powheg_matching_reweight_matrix_elements
<<POWHEG matching: procedures>>=
  function powheg_matching_reweight_matrix_elements (powheg, r) result (accepted)
    logical :: accepted
    class(powheg_matching_t), intent(inout) :: powheg
    type(radiation_t), intent(in) :: r
    integer :: emitter
    real(default) :: sqme_real_x_jacobian, sqme_born
    real(default) :: norm, ubf, ubound, random, weight
    real(default) :: alpha_s
    call msg_debug (D_MATCHING, "reweight_matrix_elements")
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       call powheg%rng%generate (random)
       emitter = pcm%controller%get_emitter (r%alr)
       powheg%event_deps%p_real_cms = &
            powheg%phs_fks_generator%generate_fsr_from_xi_and_y (r%xi, &
            r%y, r%phi, emitter, powheg%event_deps%p_born_cms)
       call powheg%boost_preal_to_lab_frame ()
       call powheg%copy_momenta ()
       norm = powheg%norm_from_xi_and_y (r)
       associate (s => powheg%sudakov(r%alr)%s)
         alpha_s = s%alpha_s (s%kt2 (r%xi, r%y), use_correct=.true.)
         ubf = s%upper_bound_func (r%xi, r%y, alpha_s)
         sqme_real_x_jacobian = powheg%compute_sqme_real (r%alr, alpha_s)
         sqme_born = powheg%event_deps%sqme_born
         ubound = sqme_born * ubf * norm
         weight = sqme_real_x_jacobian / ubound
         if (weight > 1) call s%veto_counter%record_fail()
         if (debug_active (D_MATCHING)) then
            if (weight < 0) call msg_warning ("R/B < 0!")
         end if
         accepted = random < weight
       end associate
       if (debug_active (D_MATCHING)) then
          print *, '  r%alr =    ',   r%alr
          print *, '  r%xi =    ', r%xi
          print *, '  r%y =    ', r%y
          print *, '  emitter =    ', emitter
          print *, '  random =    ', random
          print *, '  sqme_real_x_jacobian =    ', sqme_real_x_jacobian
          print *, '  sqme_born =    ', sqme_born
          print *, '  ubf =    ', ubf
          print *, '  norm =    ',   norm
          print *, '  ubound =    ', ubound
          print *, '  matrix element  accepted =    ', accepted
       end if
    end select
  end function powheg_matching_reweight_matrix_elements

@ %def powheg_matching_reweight_matrix_element
@
\subsubsection{Generation algorithm and grid initialization}
[[compute_sqme_real]] is the projected real matrix element
$R_{\alpha_r} = S_{\alpha_r} R$ whereby the current $\alpha_r$ is
implied by the [[emitter]].  Furthermore, it is multiplied by the
Jacobian.
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: compute_sqme_real => powheg_matching_compute_sqme_real
<<POWHEG matching: procedures>>=
  function powheg_matching_compute_sqme_real (powheg, alr, alpha_s) result (sqme)
    class(powheg_matching_t), intent(inout) :: powheg
    integer, intent(in) :: alr
    real(default), intent(in) :: alpha_s
    integer :: emitter
    real(default) :: sqme
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. powheg%testing%active) then
          associate (instance => powheg%process_instance)
            emitter = pcm%controller%get_emitter (alr)
            call instance%compute_sqme_real_rad (emitter, &
                 powheg%event_deps%p_born_lab, powheg%event_deps%p_real_lab, alpha_s)
            sqme = pcm%collector%sqme_real_per_emitter (1, emitter)
          end associate
       else
          sqme = one
       end if
    end select
  end function powheg_matching_compute_sqme_real

@ %def powheg_matching_compute_sqme_real
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: set_scale => powheg_matching_set_scale
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_set_scale (powheg, pT2)
    class(powheg_matching_t), intent(inout) :: powheg
    real(default), intent(in) :: pT2
    call powheg%process_instance%set_fac_scale (sqrt(pT2))
  end subroutine powheg_matching_set_scale

@ %def powheg_matching_set_scale
@
For each underlying Born $f_b$, there is a number of radiation regions.
A radiation region rr may correspond multiple $\alpha_r$s.  The phase
space only depends upon the radiation region kinematics rr and not on
the specific $\alpha_r$.  $\alpha_r$ can be picked in the set
$\{\alpha_r|f_b,\text{rr}\}$ proportional to their $R_{\alpha_r}$.  For
now, we simplify things though and just work with the $\alpha_r$.

The following is valid for one underlying Born.
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: fill_grids => powheg_matching_fill_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_fill_grids (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    real(default), dimension(3) :: radiation_variables
    real(default) :: f_alr, xi, y, norm, real_me, ubf
    integer :: alr
    integer :: n, n_points
    real(default) :: alpha_s
    call msg_debug (D_MATCHING, "powheg_fill_grids")
    call powheg%display_grid_startup_message()
    n_points = powheg%settings%n_init
    call msg_debug (D_MATCHING, "n_points", n_points)
    UNTIL_ACCEPTED: do
       EVALUATE_GRID_POINTS: do n = 1, n_points
          if (signal_is_pending ())  return
          call powheg%prepare_momenta_for_fill_grids (radiation_variables)
          do alr = 1, powheg%process_deps%n_alr
             call powheg%generate_xi_and_y_for_grids &
                  (radiation_variables, alr, xi, y)
             associate (s => powheg%sudakov(alr)%s)
                alpha_s = s%alpha_s (s%kt2(xi, y), use_correct=.true.)
                ubf = s%upper_bound_func (xi, y, alpha_s)
             end associate
             real_me = powheg%compute_sqme_real (alr, alpha_s)
             norm = real_me / (powheg%event_deps%sqme_born * ubf)
             f_alr = (one * alr) / powheg%process_deps%n_alr - tiny_07
             call powheg%grid%update_maxima &
                  ([radiation_variables(I_XI:I_Y), f_alr], norm)
             call msg_show_progress (n, n_points)
             if (debug2_active (D_MATCHING))  call show_vars ()
          end do
       end do EVALUATE_GRID_POINTS
       if (powheg%grid%is_non_zero_everywhere () .or. &
            n_points <= 0) then
          return
       else
          n_points = powheg%settings%n_init / 5
          write (msg_buffer, '(A,I12,A)') 'POWHEG: Number of points for grid ' // &
               'initialization was not enough. Run continues with ', &
               n_points, ' additional points to fill empty segments.'
          call msg_warning ()
       end if
    end do UNTIL_ACCEPTED

  contains

    subroutine show_vars ()
      if (norm > 1E5_default) then
         call msg_debug2 (D_MATCHING, "alr", alr)
         call msg_debug2 (D_MATCHING, "f_alr", f_alr)
         call msg_debug2 (D_MATCHING, "radiation_variables(1)", &
              radiation_variables(1))
         call msg_debug2 (D_MATCHING, "radiation_variables(2)", &
              radiation_variables(2))
         call msg_debug2 (D_MATCHING, "radiation_variables(3)", &
              radiation_variables(3))
         call msg_debug2 (D_MATCHING, "xi", xi)
         call msg_debug2 (D_MATCHING, "y", y)
         call msg_debug2 (D_MATCHING, "powheg%sudakov(alr)%s%kt2(xi,y)", &
              powheg%sudakov(alr)%s%kt2(xi,y))
         call msg_debug2 (D_MATCHING, "powheg%event_deps%sqme_born", &
              powheg%event_deps%sqme_born)
         call msg_debug2 (D_MATCHING, "alpha_s", alpha_s)
         call msg_debug2 (D_MATCHING, "real_me", real_me)
         call msg_debug2 (D_MATCHING, "ubf", ubf)
         call msg_debug2 (D_MATCHING, "norm", norm)
         call msg_debug2 (D_MATCHING, "")
      end if
    end subroutine show_vars

  end subroutine powheg_matching_fill_grids

@ %def powheg_matching_fill_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: generate_xi_and_y_for_grids => powheg_matching_generate_xi_and_y_for_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_generate_xi_and_y_for_grids (powheg, &
                                       radiation_randoms, alr, xi, y)
    class(powheg_matching_t), intent(inout) :: powheg
    integer, intent(in) :: alr
    real(default), dimension(:), intent(in) :: radiation_randoms
    real(default), intent(out) :: xi, y
    integer :: emitter
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. powheg%testing%active) then
          associate (fks => powheg%phs_fks_generator)
            emitter = pcm%controller%get_emitter (alr)
            powheg%event_deps%p_real_cms = fks%generate_fsr_from_x &
                 (radiation_randoms, emitter, powheg%event_deps%p_born_lab)
            call powheg%copy_momenta ()
            call fks%get_radiation_variables (emitter, xi, y)
          end associate
       else
          xi = radiation_randoms (I_XI)
          y = radiation_randoms (I_Y)
       end if
    end select
  end subroutine powheg_matching_generate_xi_and_y_for_grids

@ %def powheg_matching_generate_xi_and_y_for_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: prepare_momenta_for_fill_grids => powheg_matching_prepare_momenta_for_fill_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_prepare_momenta_for_fill_grids (powheg, &
                                                      radiation_randoms)
    real(default), dimension(3), intent(out) :: radiation_randoms
    class(powheg_matching_t), intent(inout) :: powheg
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. powheg%testing%active) then
          associate ( &
               fks => powheg%phs_fks_generator, &
               process => powheg%process_instance%process)
            do
               call process%generate_weighted_event (powheg%process_instance, 1)
               call powheg%update (pcm%controller%int_born%get_momenta ())
               call powheg%rng%generate (radiation_randoms)
               call fks%generate_radiation_variables &
                    (radiation_randoms, powheg%event_deps%p_born_lab)
               call powheg%update_sudakovs (fks%real_kinematics%y)
               if (powheg%above_pt2_min ()) exit
            end do
          end associate
       else
          call powheg%rng%generate (radiation_randoms)
       end if
    end select
  end subroutine powheg_matching_prepare_momenta_for_fill_grids

@ %def powheg_matching_prepare_momenta_for_fill_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: above_pt2_min => powheg_matching_above_pt2_min
<<POWHEG matching: procedures>>=
  function powheg_matching_above_pt2_min (powheg) result (above)
    logical :: above
    class(powheg_matching_t), intent(in) :: powheg
    integer :: alr, emitter
    real(default) :: xi, y
    above = .true.
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       associate (fks => powheg%phs_fks_generator)
         do alr = 1, powheg%process_deps%n_alr
            emitter = pcm%controller%get_emitter (alr)
            call fks%get_radiation_variables (emitter, xi, y)
            above = powheg%sudakov(alr)%s%kt2 (xi, y) >= powheg%settings%pt2_min
            if (.not. above) exit
         end do
       end associate
    end select
  end function powheg_matching_above_pt2_min

@ %def powheg_matching_above_pt2_min
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: update_sudakovs => powheg_matching_update_sudakovs
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_update_sudakovs (powheg, y)
    class(powheg_matching_t), intent(inout) :: powheg
    real(default), dimension(:), intent(in) :: y
    integer :: alr, emitter
    real(default) :: q0, m2, mrec2, k0_rec_max
    type(vector4_t) :: p_emitter
    do alr = 1, powheg%process_deps%n_alr
       select type (s => powheg%sudakov(alr)%s)
       type is (sudakov_massive_fsr_t)
          emitter = s%associated_emitter
          q0 = sqrt (s%event_deps%s_hat)
          p_emitter = s%event_deps%p_born_lab (emitter)
          associate (p => p_emitter%p)
             mrec2 = (q0 - p(0))**2 - p(1)**2 - p(2)**2 - p(3)**2
          end associate
          m2 = p_emitter**2
          call compute_dalitz_bounds (q0, m2, mrec2, s%z1, s%z2, k0_rec_max)
          s%z = s%z2 - (s%z2-s%z1)*(one+y(emitter))/two
       end select
    end do
  end subroutine powheg_matching_update_sudakovs

@ %def powheg_matching_update_sudakovs
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: import_norms_from_grid => powheg_matching_import_norms_from_grid
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_import_norms_from_grid (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    integer :: alr
    real(default) :: norm_max
    do alr = 1, powheg%process_deps%n_alr
       norm_max = powheg%grid%get_maximum_in_3d (alr)
       call powheg%sudakov(alr)%s%set_normalization (norm_max)
    end do
  end subroutine powheg_matching_import_norms_from_grid

@ %def powheg_matching_import_norms_from_grid
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: save_grids => powheg_matching_save_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_save_grids (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    type(string_t) :: filename, n_points
    n_points = str (powheg%settings%n_init)
    filename = powheg%process_name // "_" // n_points // "_powheg_grids.dat"
    call powheg%grid%save_to_file (char (filename))
  end subroutine powheg_matching_save_grids

@ %def powheg_matching_save_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: load_grids => powheg_matching_load_grids
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_load_grids (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    type(string_t) :: filename, n_points
    n_points = str (powheg%settings%n_init)
    filename = powheg%process_name // "_" // n_points // "_powheg_grids.dat"
    call powheg%grid%load_from_file (char (filename))
    write (msg_buffer, "(A,A,A)") "POWHEG: using grids from file '", &
                               char (filename), "'"
    call msg_message ()
  end subroutine powheg_matching_load_grids

@ %def powheg_matching_load_grids
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: requires_new_grids => powheg_matching_requires_new_grids
<<POWHEG matching: procedures>>=
  function powheg_matching_requires_new_grids (powheg) result (requires)
    logical :: requires
    class(powheg_matching_t), intent(in) :: powheg
    type(string_t) :: filename, n_points
    n_points = str (powheg%settings%n_init)
    filename = powheg%process_name // "_" // n_points // "_powheg_grids.dat"
    requires = .not. os_file_exist (filename) .or. powheg%settings%rebuild_grids
  end function powheg_matching_requires_new_grids

@ %def powheg_matching_requires_new_grids
@ By keeping the radiation with the largest [[pt2]], we are effectively
implementing the highest bid procedure. This means that we generate
values $(f_B)$
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: generate_emission => powheg_matching_generate_emission
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_generate_emission (powheg, particle_set, pt2_generated)
    class(powheg_matching_t), intent(inout) :: powheg
    type(particle_set_t), intent(inout), optional :: particle_set
    real(default), intent(out), optional :: pt2_generated
    type(radiation_t) :: r, r_max
    real(default) :: xi2_max
    integer :: alr
    logical :: accepted
    type(vector4_t), dimension(:), allocatable :: p_real_max
    if (signal_is_pending ())  return
    r_max%pt2 = zero
    r_max%alr = 0
    call msg_debug (D_MATCHING, "powheg_matching_generate_emission")
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       allocate (p_real_max (pcm%controller%get_n_particles_real ()))
       do alr = 1, powheg%process_deps%n_alr
          if (signal_is_pending ())  return
          associate (sudakov => powheg%sudakov(alr)%s)
            xi2_max = pcm%controller%get_xi_max (alr)**2
            call sudakov%update (xi2_max)
            select type (sudakov)
            type is (sudakov_massive_fsr_t)
               call sudakov%compute_xi_max_extended ()
            end select
            r%alr = alr
            r%pt2 = sudakov%kt2_max (powheg%event_deps%s_hat)
            sudakov%last_log = 0
            call msg_debug (D_MATCHING, "Starting evolution at r%pt2", r%pt2)
            PT_EVOLUTION: do
               if (signal_is_pending ())  return
               call sudakov%generate_emission (r)
               if (signal_is_pending ())  return
               if (r%valid) then
                  accepted = powheg%reweight_norm (r)
                  call sudakov%veto_counter%record_norm (.not. accepted)
                  if (.not. accepted) cycle PT_EVOLUTION
                  accepted = powheg%reweight_matrix_elements (r)
                  call sudakov%veto_counter%record_sqme (.not. accepted)
                  if (.not. accepted) cycle PT_EVOLUTION
               end if
               exit
            end do PT_EVOLUTION
            if (r%pt2 > r_max%pt2 .and. r%valid) then
               r_max = r
               p_real_max = powheg%event_deps%p_real_lab
            end if
          end associate
       end do
       if (r_max%pt2 > powheg%settings%pt2_min) then
          powheg%n_emissions = powheg%n_emissions + 1
          call powheg%set_scale (r_max%pt2)
          if (present (particle_set)) &
               call powheg%build_particle_set (particle_set, &
               powheg%event_deps%p_born_lab, &
               p_real_max, pcm%controller%get_emitter (r_max%alr))
          if (present (pt2_generated)) pt2_generated = r_max%pt2
       else
          call powheg%set_scale (powheg%settings%pt2_min)
          if (present (pt2_generated)) pt2_generated = powheg%settings%pt2_min
       end if
    end select
  end subroutine powheg_matching_generate_emission

@ %def generate_emission
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: build_particle_set => powheg_matching_build_particle_set
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_build_particle_set &
       (powheg, particle_set, p_born, p_real, emitter)
    class(powheg_matching_t), intent(inout) :: powheg
    type(particle_set_t), intent(inout) :: particle_set
    type(vector4_t), dimension(:), intent(in) :: p_born, p_real
    integer, intent(in) :: emitter
    integer, dimension(:), allocatable :: flv_radiated
    real(default) :: r_col
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       allocate (flv_radiated (size (pcm%controller%get_flv_state_real (1))))
       flv_radiated = pcm%controller%get_flv_state_real (1)
       call powheg%rng%generate (r_col)
       call particle_set%build_radiation (p_real, emitter, flv_radiated, &
            powheg%process_instance%process%get_model_ptr (), r_col)
    end select
  end subroutine powheg_matching_build_particle_set

@ %def powheg_matching_build_particle_set
@ Only massless for now
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: reweight_norm => powheg_matching_reweight_norm
<<POWHEG matching: procedures>>=
  function powheg_matching_reweight_norm (powheg, r) result (accepted)
    logical :: accepted
    class(powheg_matching_t), intent(inout) :: powheg
    type(radiation_t), intent(in) :: r
    real(default) :: random, norm_max, norm_true
    call msg_debug2 (D_MATCHING, "reweight_norm")
    call powheg%rng%generate (random)
    norm_true = powheg%norm_from_xi_and_y (r)
    norm_max = powheg%sudakov(r%alr)%s%norm_max
    accepted = random < norm_true / norm_max
    if (debug2_active (D_MATCHING)) then
       print *, '  r%alr =    ', r%alr
       print *, '  random =    ', random
       print *, '  norm_true =    ', norm_true
       print *, '  norm_max =    ', norm_max
       print *, '  norm accepted =    ', accepted
    end if
    if (debug_active (D_MATCHING)) then
       if (.not. (zero < r%xi .and. &
                  r%xi < sqrt(powheg%sudakov(r%alr)%s%xi2_max))) then
          call msg_bug ("powheg_matching_reweight_norm: xi is out of bounds")
       end if
       if (norm_true > norm_max) then
          call msg_bug ("powheg_matching_reweight_norm: norm shouldnt be larger than norm_max")
       end if
    end if
  end function powheg_matching_reweight_norm

@ %def powheg_matching_reweight_norm
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: norm_from_xi_and_y => powheg_matching_norm_from_xi_and_y
<<POWHEG matching: procedures>>=
  function powheg_matching_norm_from_xi_and_y (powheg, r) result (norm_true)
    real(default) :: norm_true
    class(powheg_matching_t), intent(inout) :: powheg
    type(radiation_t), intent(in) :: r
    real(default) :: f_alr
    real(default), dimension(2) :: rands
    real(default) :: beta
    f_alr = (one*r%alr) / powheg%process_deps%n_alr - tiny_07
    rands(I_XI) = r%xi / sqrt (powheg%sudakov(r%alr)%s%xi2_max)
    select type (s => powheg%sudakov(r%alr)%s)
    type is (sudakov_simple_fsr_t)
       rands(I_Y) = (one - r%y) / two
    type is (sudakov_massive_fsr_t)
       beta = beta_emitter (sqrt (powheg%event_deps%s_hat), &
          powheg%event_deps%p_born_lab (s%associated_emitter))
       rands(I_Y) = - log((one-r%y*beta)/(one+beta)) / log((one+beta)/(one-beta))
    end select
    norm_true = powheg%grid%get_value ([rands, f_alr])
  end function powheg_matching_norm_from_xi_and_y

@ %def powheg_matching_norm_from_xi_and_y
@
\subsection{$\alpha_s$ and its reweighting}
The main point to ensure here is that the simple fixed-flavor-1-loop
expression $\alpha_s^\text{rad}$ is larger than the more accurate
$\alpha_s$ such that we can use a reweighting veto and use
$\alpha_s^\text{rad}$ for the generation of the emission. This can be
done by setting
\begin{equation}
  \alpha_s^\text{rad}(\mu_0) = \alpha_s (\mu_0)
\end{equation}
whereby $\mu_0^2$ is the [[scale_to_relate2]] that is taken to be
$p_{T,\text{min}}^2$.
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: prepare_for_events => powheg_matching_prepare_for_events
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_prepare_for_events (matching)
    class(powheg_matching_t), intent(inout), target :: matching
    call msg_debug (D_MATCHING, "powheg_matching_prepare_for_events")
    call matching%setup_nlo_environment ()
    call matching%grid%init ([matching%settings%size_grid_xi, &
                              matching%settings%size_grid_y, &
                              matching%process_deps%n_alr])
    call matching%compute_lambda2_gen ()
    call matching%setup_sudakovs ()
  end subroutine powheg_matching_prepare_for_events

@ %def powheg_matching_prepare_for_events
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: compute_lambda2_gen => powheg_matching_compute_lambda2_gen
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_compute_lambda2_gen (matching)
    class(powheg_matching_t), intent(inout) :: matching
    real(default) :: scale_to_relate2, alpha_s
    scale_to_relate2 = matching%settings%pt2_min
    alpha_s = get_alpha (matching%qcd, scale_to_relate2)
    matching%process_deps%lambda2_gen = exp (- one / (b0rad * alpha_s)) * &
         scale_to_relate2
  end subroutine powheg_matching_compute_lambda2_gen

@ %def powheg_matching_compute_lambda2_gen
@
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: setup_nlo_environment => powheg_matching_setup_nlo_environment
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_setup_nlo_environment (matching)
    class(powheg_matching_t), intent(inout) :: matching
    integer :: n_in, n_out_born, n_out_real
    call msg_debug (D_MATCHING, "powheg_matching_setup_nlo_environment")
    select type (pcm => matching%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. matching%testing%active) then
          matching%process_deps%n_alr = pcm%controller%get_n_alr ()
          n_in = pcm%controller%particle_data%n_in
          n_out_born = pcm%controller%particle_data%n_out_born
          n_out_real = pcm%controller%particle_data%n_out_real
          matching%process_deps%sqrts = matching%process_instance%get_sqrts ()
          call pcm%controller%setup_generator &
               (matching%phs_fks_generator, &
               matching%process_deps%sqrts, &
               matching%settings%singular_jacobian)
       else
          matching%process_deps%n_alr = matching%testing%n_alr
          n_in = matching%testing%n_in
          n_out_born = matching%testing%n_out_born
          n_out_real = matching%testing%n_out_real
       end if
       allocate (matching%event_deps%p_born_lab (n_in + n_out_born))
       allocate (matching%event_deps%p_born_cms (n_in + n_out_born))
       allocate (matching%event_deps%p_real_lab (n_in + n_out_real))
       allocate (matching%event_deps%p_real_cms (n_in + n_out_real))
    end select
  end subroutine powheg_matching_setup_nlo_environment

@ %def powheg_matching_setup_nlo_environment
@ Copy momenta from [[event_deps]] to [[real_kinematics]].
So far this is only valid if the center-of-mass system is equal to
the lab frame, i.e. for FSR processes without beamstrahlung or structure functions.
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: copy_momenta => powheg_matching_copy_momenta
<<POWHEG matching: procedures>>=
  subroutine powheg_matching_copy_momenta (matching)
     class(powheg_matching_t), intent(inout) :: matching
     select type (pcm => matching%process_instance%pcm)
     class is (pcm_instance_nlo_t)
        pcm%controller%real_kinematics%p_real_cms = matching%event_deps%p_real_cms
        pcm%controller%real_kinematics%p_real_lab = matching%event_deps%p_real_lab
     end select
  end subroutine powheg_matching_copy_momenta

@ %def powheg_matching_copy_momenta
@ [[qcd%alpha%get]] should implement a variable-flavor result and
optionally return [[n_flavors]] that are active at the scale...
<<POWHEG matching: procedures>>=
  function get_alpha (qcd, scale2) result (alpha_s)
    real(default) :: alpha_s
    class(qcd_t), intent(in) :: qcd
    real(default), intent(in) :: scale2
    integer :: nf, order
    ! TODO: (bcn 2015-01-30) implement variable flavor alpha_s
    alpha_s = qcd%alpha%get (sqrt(scale2))
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_from_scale_t)
       nf = alpha%nf
       order = alpha%order
    type is (alpha_qcd_from_lambda_t)
       nf = alpha%nf
       order = alpha%order
    class default
       call msg_warning ("get_alpha: QCD type is not running!" // &
            "Assuming 5-flavors and LO (1-loop) running!")
       nf = 5
       order = 0
    end select
    if (order > 0) alpha_s = improve_nll_accuracy (alpha_s, nf)
  end function get_alpha

@ %def get_alpha
@ See Eq. (4.31) in [[0709.2092]]. Should be used everywhere in the Sudakov
exponent.
<<POWHEG matching: procedures>>=
  pure function improve_nll_accuracy (alpha_s, n_flavors) result (alpha_s_imp)
    real(default) :: alpha_s_imp
    real(default), intent(in) :: alpha_s
    integer, intent(in) :: n_flavors
      alpha_s_imp = alpha_s * (one + alpha_s / (two*pi) * &
           ((67.0_default/18 - pi**2/6) * CA - five/9 * n_flavors))
  end function improve_nll_accuracy

@ %def improve_nll_accuracy
@ This is fixed to $n_f=5$ for radiation generation. It will be
reweighted to the more precise $\alpha_s$.
<<POWHEG matching: parameters>>=
  real(default), parameter :: b0rad = (33 - 2 * 5) / (12 * pi)
@ %def b0rad
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: alpha_s_rad => sudakov_alpha_s_rad
<<POWHEG matching: procedures>>=
  elemental function sudakov_alpha_s_rad (sudakov, scale2) result (y)
    real(default) :: y
    class(sudakov_t), intent(in) :: sudakov
    real(default), intent(in) :: scale2
    y = one / (b0rad * log (scale2 / sudakov%process_deps%lambda2_gen))
  end function sudakov_alpha_s_rad

@ %def sudakov_alpha_s_rad
@
<<POWHEG matching: sudakov: TBP>>=
  procedure :: reweight_alpha_s => sudakov_reweight_alpha_s
<<POWHEG matching: procedures>>=
  function sudakov_reweight_alpha_s (sudakov, pt2) result (accepted)
    logical :: accepted
    class(sudakov_t), intent(inout) :: sudakov
    real(default), intent(in) :: pt2
    real(default) :: alpha_s_true, alpha_s_rad
    logical :: alpha_s_equal
    call msg_debug2 (D_MATCHING, "reweight_alpha_s")
    alpha_s_true = get_alpha (sudakov%qcd, pt2)
    alpha_s_rad = sudakov%alpha_s_rad (pt2)
    call sudakov%rng%generate (sudakov%random)
    alpha_s_equal = nearly_equal (alpha_s_true, alpha_s_rad)
    accepted = alpha_s_equal .or. sudakov%random < alpha_s_true / alpha_s_rad
    if (debug2_active (D_MATCHING)) then
       print *, '  sudakov%random =    ', sudakov%random
       print *, '  alpha_s_true =    ', alpha_s_true
       print *, '  alpha_s_rad =    ', alpha_s_rad
       print *, '  alpha_s accepted =    ', accepted
       if (alpha_s_rad < alpha_s_true .and. .not. alpha_s_equal) then
          print *, 'pt2 =    ', pt2
          print *, 'sudakov%process_deps%lambda2_gen =    ', &
               sudakov%process_deps%lambda2_gen
          call msg_fatal ("sudakov_reweight_alpha_s: This should never happen. &
                           &Have you chosen a running alpha_s?")
       end if
    end if
  end function sudakov_reweight_alpha_s

@ %def sudakov_reweight_alpha_s
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[powheg_matching_ut.f90]]>>=
<<File header>>

module powheg_matching_ut
  use unit_tests
  use powheg_matching_uti

<<Standard module head>>

<<POWHEG matching: public test>>

contains

<<POWHEG matching: test driver>>

end module powheg_matching_ut
@ %def powheg_matching_ut
@
<<[[powheg_matching_uti.f90]]>>=
<<File header>>

module powheg_matching_uti

<<Use kinds>>
<<Use strings>>
  use constants, only: zero, one
  use lorentz
  use physics_defs, only: LAMBDA_QCD_REF
  use sm_qcd
  use subevents, only: PRT_INCOMING, PRT_OUTGOING
  use model_data
  use particles
  use rng_base
  use variables
  use processes
  use shower_base
  use shower_core

  use powheg_matching

  use rng_base_ut, only: rng_test_factory_t

<<Standard module head>>

<<POWHEG matching: test declarations>>

contains

<<POWHEG matching: tests>>

end module powheg_matching_uti
@ %def powheg_matching_ut
@ API: driver for the unit tests below.
<<POWHEG matching: public test>>=
  public :: powheg_test
<<POWHEG matching: test driver>>=
  subroutine powheg_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<POWHEG matching: execute tests>>
  end subroutine powheg_test

@ %def powheg_test
@
\subsubsection{Initialization}
Still very basic and incomplete.
<<POWHEG matching: execute tests>>=
  call test (powheg_1, "powheg_1", &
            "Initialization", u, results)
<<POWHEG matching: test declarations>>=
  public :: powheg_1
<<POWHEG matching: tests>>=
  subroutine powheg_1 (u)
    integer, intent(in) :: u
    type(powheg_matching_t) :: powheg
    type(powheg_settings_t) :: powheg_settings
    type(powheg_testing_t) :: powheg_testing
    type(process_instance_t), target :: process_instance
    class(shower_base_t), allocatable, target :: shower
    type(model_data_t), target :: model
    type(particle_set_t) :: particle_set
    class(rng_factory_t), allocatable :: rng_factory
    class(rng_t), allocatable :: rng
    type(string_t) :: process_name
    type(vector4_t), dimension(4) :: born_momenta
    type(qcd_t), target :: qcd
    type(var_list_t) :: var_list

    allocate (shower_t :: shower)
    allocate (rng_test_factory_t :: rng_factory)
    call rng_factory%make (rng)
    allocate (alpha_qcd_from_lambda_t :: qcd%alpha)
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_from_lambda_t)
       alpha%order = 2
    end select
    process_name = "test_powheg_1"
    powheg_settings%n_init = 1000
    powheg_settings%size_grid_xi = 2
    powheg_settings%size_grid_y = 2
    powheg_settings%pt2_min = one
    powheg_settings%lambda = LAMBDA_QCD_REF
    powheg_testing%n_alr = 3
    powheg_testing%n_in = 2
    powheg_testing%n_out_born = 2
    powheg_testing%n_out_real = 3
    powheg_testing%sqme_born = one
    powheg_testing%active = .true.
    born_momenta(1) = [50._default, zero, zero, 50._default]
    born_momenta(2) = [50._default, zero, zero, - 50._default]
    born_momenta(3) = [50._default, zero, zero, 50._default]
    born_momenta(4) = [50._default, zero, zero, - 50._default]
    particle_set%n_tot = 4
    particle_set%n_in = 2
    particle_set%n_out = 2
    call particle_set%set_momenta (born_momenta)
    call particle_set%prt(1)%set_status (PRT_INCOMING)
    call particle_set%prt(2)%set_status (PRT_INCOMING)
    call particle_set%prt(3)%set_status (PRT_OUTGOING)
    call particle_set%prt(4)%set_status (PRT_OUTGOING)

    write (u, "(A)")  "* Test output: powheg_1"
    write (u, "(A)")  "*   Purpose: Initialization"
    write (u, "(A)")

    call powheg%init (var_list, process_name)
    powheg%testing = powheg_testing
    powheg%settings = powheg_settings
    powheg%qcd => qcd

    allocate (pcm_instance_nlo_t :: process_instance%pcm)
    
    call powheg%import_rng (rng)
    call powheg%connect (process_instance, model, shower)
    call powheg%prepare_for_events ()
    call powheg%update (particle_set)
    ! TODO: (bcn 2015-05-04) put this write somewhere useful
    call powheg%grid%compute_and_write_mean_and_max (u)
    !!! Needs some more thought: if we just set R = 1, B = 1 the grid
    !!! setup will fail
    !!! call powheg%generate_emission (particle_set)
    call powheg%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: powheg_1"
  end subroutine powheg_1

@ %def powheg_1
@
\subsubsection{Compare generated emission with Sudakov form factor}
This is a nontrivial test of the generation algorithm and should be
independent of the used upper bounding function (as long as all
singularities are included).
<<POWHEG matching: powheg matching: TBP>>=
  procedure :: test_sudakov => powheg_test_sudakov
<<POWHEG matching: procedures>>=
  subroutine powheg_test_sudakov (powheg)
    class(powheg_matching_t), intent(inout) :: powheg
    integer :: n_calls1, n_calls2
    integer, parameter :: n_bins = 20
    real(default) :: sqme_real_x_jacobian, sqme_born
    type(vector4_t), dimension(:), allocatable :: p_born
    real(default), dimension(3) :: random
    real(default) :: xi, y, phi
    integer :: i_call, i_bin, alr, emitter
    real(default) :: alpha_s, kT2, weight
    real(default) :: pt2_min, s, random_jacobian
    real(default), dimension(n_bins) :: histo1, histo2, histo1sq, histo2sq
    real(default), dimension(n_bins) :: tmp
    integer :: i_strip, n_in_strip, n_strips
    real(default), dimension(n_bins) :: average, average_sq, error
    real(default), dimension(n_bins) :: &
         sudakov_0, sudakov_p, sudakov_m, rel_error
    integer :: u

    p_born = powheg%event_deps%p_born_lab
    sqme_born = powheg%event_deps%sqme_born
    s = powheg%event_deps%s_hat
    pt2_min = powheg%settings%pt2_min
    n_calls1 = 100000; n_calls2 = 1000000
    histo1 = zero; histo2 = zero; histo1sq = zero; histo2sq = zero
    n_strips = 10

    call compute_integrals ()
    call generate_emissions ()
    call write_to_screen_and_file ()

  contains

  <<POWHEG matching: powheg test sudakov: procedures>>

  end subroutine powheg_test_sudakov

@ %def powheg_test_sudakov
@
<<POWHEG matching: powheg test sudakov: procedures>>=
  pure function binning (i) result (pt2)
    real(default) :: pt2
    integer, intent(in) :: i
    !pt2 = pt2_min + (s-pt2_min) * (i-1) / (n_bins-1)
    pt2 = pt2_min * exp (log (s / pt2_min) * (i-1) / (n_bins-1))
  end function

@
<<POWHEG matching: powheg test sudakov: procedures>>=
  subroutine compute_integrals ()
    write (msg_buffer, "(A)") "POWHEG: test_sudakov: Computing integrals"
    call msg_message ()
    select type (pcm => powheg%process_instance%pcm)
    class is (pcm_instance_nlo_t)
       associate (fks => powheg%phs_fks_generator)
         do i_call = 1, n_calls1
            do alr = 1, powheg%process_deps%n_alr
               call powheg%rng%generate (random)
               emitter = pcm%controller%get_emitter (alr)
               !!! The sudakov test works only with lepton collisions without beam spectria
               !!! so we can identify the cms and lab momenta.
               powheg%event_deps%p_real_cms = fks%generate_fsr_from_x (random, emitter, p_born)
               powheg%event_deps%p_real_lab = powheg%event_deps%p_real_cms
               call powheg%copy_momenta ()
               call fks%get_radiation_variables (emitter, xi, y, phi)
               kT2 = powheg%sudakov(alr)%s%kt2(xi, y)
               if (kT2 >= pt2_min .and. xi < one - tiny_07) then
                  alpha_s = get_alpha (powheg%qcd, kT2)
                  sqme_real_x_jacobian = powheg%compute_sqme_real (alr, alpha_s)
                  random_jacobian = pcm%controller%real_kinematics%jac_rand (emitter)
                  weight = sqme_real_x_jacobian * random_jacobian / sqme_born
                  do i_bin = 1, n_bins
                     if (kT2 > binning(i_bin)) then
                        histo1(i_bin) = histo1(i_bin) + weight
                        histo1sq(i_bin) = histo1sq(i_bin) + weight**2
                     end if
                  end do
               end if
               ! Do not cycle since there is a Heaviside in the exponent
            end do
            call msg_show_progress (i_call, n_calls1)
         end do
       end associate
    end select
    average = histo1 / n_calls1
    average_sq = histo1sq / n_calls1
    error = sqrt ((average_sq - average**2) / n_calls1)
    sudakov_0 = exp(-average)
    sudakov_p = exp(-(average + error))
    sudakov_m = exp(-(average - error))
    rel_error = (sudakov_0 - sudakov_p + sudakov_m - sudakov_0) / &
         (2 * sudakov_0) * 100
  end subroutine compute_integrals

@
<<POWHEG matching: powheg test sudakov: procedures>>=
  subroutine generate_emissions ()
    write (msg_buffer, "(A)") "POWHEG: test_sudakov: Generating emissions"
    call msg_message ()
    do i_strip = 1, n_strips
       tmp = 0
       n_in_strip = n_calls2 / n_strips
       do i_call = 1, n_in_strip
          if (signal_is_pending ())  return
          call powheg%generate_emission (pt2_generated = kT2)
          do i_bin = 1, n_bins
             if (kT2 > binning(i_bin)) then
                tmp(i_bin) = tmp(i_bin) + 1
             end if
          end do
       end do
       tmp = one - (one * tmp) / n_in_strip
       histo2 = histo2 + tmp
       histo2sq = histo2sq + tmp**2
       call msg_show_progress (i_strip, n_strips)
    end do
    average = histo2 / n_strips
    average_sq = histo2sq / n_strips
    error = sqrt ((average_sq - average**2) / n_strips)
  end subroutine generate_emissions

@
<<POWHEG matching: powheg test sudakov: procedures>>=
  subroutine write_to_screen_and_file ()
    u = free_unit ()
    open (file='sudakov.dat', unit=u, action='write')
    print *, 'exp(-Integrated R/B)-distribution: '
    print *, 'pT2  sudakov_+  sudakov_0  sudakov_-  rel_err[%]: '
    do i_bin = 1, n_bins
       print *, binning(i_bin), &
            sudakov_p(i_bin), sudakov_0(i_bin), sudakov_m(i_bin), &
            rel_error(i_bin)
       write (u, "(6(" // FMT_16 // ",2X))") binning(i_bin), &
            sudakov_p(i_bin), sudakov_0(i_bin), sudakov_m(i_bin), &
            average(i_bin), error(i_bin)
    end do
    close (u)
    print *, '*******************************'
    print *, 'Noemission probability: '
    do i_bin = 1, n_bins
       print *, binning (i_bin), average (i_bin), error(i_bin)
    end do
  end subroutine write_to_screen_and_file

@
