% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD code as NOWEB source: integration and process objects and such

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integration and Process Objects}

This is the central part of the \whizard\ package.  It provides the
functionality for evaluating structure functions, kinematics and matrix
elements, integration and event generation.  It combines the various
parts that deal with those tasks individually and organizes the data transfer
between them.
\begin{description}
\item[subevt\_expr]
  This enables process observables as (abstract) expressions, to be
  evaluated for each process call.
\item[parton\_states]
  A [[parton_state_t]] object represents an elementary partonic
  interaction.  There are two versions: one for the isolated
  elementary process, one for the elementary process convoluted with
  the structure-function chain.  The parton state is an effective
  state.  It needs not coincide with the seed-kinematics state which is
  used in evaluating phase space.
\item[processes]
  Here, all pieces are combined for the purpose of evaluating the
  elementary processes.  The whole algorithm is coded in terms of
  abstract data types as defined in the appropriate modules: [[prc_core]]
  for matrix-element evaluation, [[prc_core_def]] for the associated
  configuration and driver, [[sf_base]] for beams and structure-functions,
  [[phs_base]] for phase space, and [[mci_base]] for integration and event
  generation.
\item[process\_stacks]
  Process stacks collect process objects.
\end{description}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process observables}
We define an abstract [[subevt_expr_t]] object as an extension of the
[[subevt_t]] type.  The object contains a local variable list, variable
instances (as targets for pointers in the variable list), and evaluation
trees.  The evaluation trees reference both the variables and the [[subevt]].

There are two instances of the abstract type: one for process instances, one
for physical events.  Both have a common logical expression [[selection]]
which determines whether the object passes user-defined cuts.

The intention is that we fill the [[subevt_t]] base object and compute the
variables once we have evaluated a kinematical phase space point (or a
complete event).  We then evaluate the expressions and can use the results in
further calculations.

The [[process_expr_t]] extension contains furthermore scale and weight
expressions.  The [[event_expr_t]] extension contains a reweighting-factor
expression and a logical expression for event analysis.  In practice, we will
link the variable list of the [[event_obs]] object to the variable list of the
currently active [[process_obs]] object, such that the process variables are
available to both objects.  Event variables are meaningful only for physical
events.

Note that there are unit tests, but they are deferred to the
[[expr_tests]] module.
<<[[subevt_expr.f90]]>>=
<<File header>>
module subevt_expr

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use lorentz
  use subevents
  use variables
  use flavors
  use quantum_numbers
  use interactions
  use particles
  use expr_base

<<Standard module head>>

<<Subevt expr: public>>

<<Subevt expr: types>>

<<Subevt expr: interfaces>>

contains
  
<<Subevt expr: procedures>>

end module subevt_expr
@ %def subevt_expr
@
\subsection{Abstract base type}
<<Subevt expr: types>>=
  type, extends (subevt_t), abstract :: subevt_expr_t
     logical :: subevt_filled = .false.
     type(var_list_t) :: var_list
     real(default) :: sqrts_hat = 0
     integer :: n_in = 0
     integer :: n_out = 0
     integer :: n_tot = 0
     logical :: has_selection = .false.
     class(expr_t), allocatable :: selection
   contains
   <<Subevt expr: subevt expr: TBP>>
  end type subevt_expr_t
  
@ %def subevt_expr_t
@ Output: Base and extended version.  We already have a [[write]] routine for
the [[subevt_t]] parent type.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: base_write => subevt_expr_write
<<Subevt expr: procedures>>=
  subroutine subevt_expr_write (object, unit, pacified)
    class(subevt_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacified
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Local variables:"
    call write_separator (u)
    call var_list_write (object%var_list, u, follow_link=.false., &
         pacified = pacified)
    call write_separator (u)
    if (object%subevt_filled) then
       call object%subevt_t%write (u, pacified = pacified)
       if (object%has_selection) then
          call write_separator (u)
          write (u, "(1x,A)")  "Selection expression:"
          call write_separator (u)
          call object%selection%write (u)
       end if
    else
       write (u, "(1x,A)")  "subevt: [undefined]"
    end if
  end subroutine subevt_expr_write
    
@ %def subevt_expr_write   
@ Finalizer.
<<Subevt expr: subevt expr: TBP>>=
  procedure (subevt_expr_final), deferred :: final
  procedure :: base_final => subevt_expr_final
<<Subevt expr: procedures>>=
  subroutine subevt_expr_final (object)
    class(subevt_expr_t), intent(inout) :: object
    call object%var_list%final ()
    if (object%has_selection) then
       call object%selection%final ()
    end if
  end subroutine subevt_expr_final
  
@ %def subevt_expr_final
@
\subsection{Initialization}
Initialization: define local variables and establish pointers.

The common variables are [[sqrts]] (the nominal beam energy, fixed),
[[sqrts_hat]] (the actual energy), [[n_in]], [[n_out]], and [[n_tot]] for
the [[subevt]].  With the exception of [[sqrts]], all are implemented as
pointers to subobjects.
<<Subevt expr: subevt expr: TBP>>=
  procedure (subevt_expr_setup_vars), deferred :: setup_vars
  procedure :: base_setup_vars => subevt_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine subevt_expr_setup_vars (expr, sqrts)
    class(subevt_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call expr%var_list%final ()
    call var_list_append_real (expr%var_list, &
         var_str ("sqrts"), sqrts, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqrts_hat"), expr%sqrts_hat, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_in"), expr%n_in, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_out"), expr%n_out, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("n_tot"), expr%n_tot, &
         is_known = expr%subevt_filled, &
         locked = .true., verbose = .false., intrinsic = .true.)
  end subroutine subevt_expr_setup_vars
    
@ %def subevt_expr_setup_vars
@ Append the subevent expr (its base-type core) itself to the variable
list, if it is not yet present.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: setup_var_self => subevt_expr_setup_var_self
<<Subevt expr: procedures>>=
  subroutine subevt_expr_setup_var_self (expr)
    class(subevt_expr_t), intent(inout), target :: expr
    if (.not. expr%var_list%contains (var_str ("@evt"))) then
       call var_list_append_subevt_ptr &
            (expr%var_list, &
            var_str ("@evt"), expr%subevt_t, &
            is_known = expr%subevt_filled, &
            locked = .true., verbose = .false., intrinsic=.true.)
    end if
  end subroutine subevt_expr_setup_var_self
  
@ %def subevt_expr_setup_var_self
@ Link a variable list to the local one.  This could be done event by event,
but before evaluating expressions.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: link_var_list => subevt_expr_link_var_list
<<Subevt expr: procedures>>=
  subroutine subevt_expr_link_var_list (expr, var_list)
    class(subevt_expr_t), intent(inout) :: expr
    type(var_list_t), intent(in), target :: var_list
    call expr%var_list%link (var_list)
  end subroutine subevt_expr_link_var_list

@ %def subevt_expr_link_var_list
@ Compile the selection expression.  If there is no expression, the build
method won't allocate the expression object.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: setup_selection => subevt_expr_setup_selection
<<Subevt expr: procedures>>=
  subroutine subevt_expr_setup_selection (expr, ef_cuts)
    class(subevt_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_cuts
    call ef_cuts%build (expr%selection)
    if (allocated (expr%selection)) then
       call expr%setup_var_self ()
       call expr%selection%setup_lexpr (expr%var_list)
       expr%has_selection = .true.
    end if
  end subroutine subevt_expr_setup_selection

@ %def subevt_expr_setup_selection
@
\subsection{Evaluation}
Reset to initial state, i.e., mark the [[subevt]] as invalid.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: reset => subevt_expr_reset
  procedure :: base_reset => subevt_expr_reset
<<Subevt expr: procedures>>=
  subroutine subevt_expr_reset (expr)
    class(subevt_expr_t), intent(inout) :: expr
    expr%subevt_filled = .false.
  end subroutine subevt_expr_reset
  
@ %def subevt_expr_reset
@ Evaluate the selection expression and return the result.  There is also a
deferred version: this should evaluate the remaining expressions if the event
has passed.
<<Subevt expr: subevt expr: TBP>>=
  procedure :: base_evaluate => subevt_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine subevt_expr_evaluate (expr, passed)
    class(subevt_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed 
    if (expr%has_selection) then
       call expr%selection%evaluate ()
       if (expr%selection%is_known ()) then
          passed = expr%selection%get_log ()
       else
          call msg_error ("Evaluate selection expression: result undefined")
          passed = .false.
       end if
    else
       passed = .true.
    end if
  end subroutine subevt_expr_evaluate
  
@ %def subevt_expr_evaluate
@
\subsection{Implementation for partonic events}
This implementation contains the expressions that we can evaluate for the
partonic process during integration.
<<Subevt expr: public>>=
  public :: parton_expr_t
<<Subevt expr: types>>=
  type, extends (subevt_expr_t) :: parton_expr_t
     integer, dimension(:), allocatable :: i_beam
     integer, dimension(:), allocatable :: i_in
     integer, dimension(:), allocatable :: i_out
     logical :: has_scale = .false.
     logical :: has_fac_scale = .false.
     logical :: has_ren_scale = .false.
     logical :: has_weight = .false.
     class(expr_t), allocatable :: scale
     class(expr_t), allocatable :: fac_scale
     class(expr_t), allocatable :: ren_scale
     class(expr_t), allocatable :: weight
   contains
   <<Subevt expr: parton expr: TBP>>
  end type parton_expr_t
     
@ %def parton_expr_t
@ Finalizer.
<<Subevt expr: parton expr: TBP>>=
  procedure :: final => parton_expr_final
<<Subevt expr: procedures>>=
  subroutine parton_expr_final (object)
    class(parton_expr_t), intent(inout) :: object
    call object%base_final ()
    if (object%has_scale) then
       call object%scale%final ()
    end if
    if (object%has_fac_scale) then
       call object%fac_scale%final ()
    end if
    if (object%has_ren_scale) then
       call object%ren_scale%final ()
    end if
    if (object%has_weight) then
       call object%weight%final ()
    end if
  end subroutine parton_expr_final

@ %def parton_expr_final
@ Output: continue writing the active expressions, after the common selection
expression.

Note: the [[prefix]] argument is declared in the [[write]] method of the
[[subevt_t]] base type.  Here, it is unused.
<<Subevt expr: parton expr: TBP>>=
  procedure :: write => parton_expr_write
<<Subevt expr: procedures>>=
  subroutine parton_expr_write (object, unit, prefix, pacified)
    class(parton_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    character(*), intent(in), optional :: prefix
    logical, intent(in), optional :: pacified
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u, pacified = pacified)
    if (object%subevt_filled) then
       if (object%has_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Scale expression:"
          call write_separator (u)
          call object%scale%write (u)
       end if
       if (object%has_fac_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Factorization scale expression:"
          call write_separator (u)
          call object%fac_scale%write (u)
       end if
       if (object%has_ren_scale) then
          call write_separator (u)
          write (u, "(1x,A)")  "Renormalization scale expression:"
          call write_separator (u)
          call object%ren_scale%write (u)
       end if
       if (object%has_weight) then
          call write_separator (u)
          write (u, "(1x,A)")  "Weight expression:"
          call write_separator (u)
          call object%weight%write (u)
       end if
    end if
  end subroutine parton_expr_write
    
@ %def parton_expr_write
@ Define variables.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_vars => parton_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_vars (expr, sqrts)
    class(parton_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call expr%base_setup_vars (sqrts)
  end subroutine parton_expr_setup_vars

@ %def parton_expr_setup_vars
@ Compile the scale expressions.  If a pointer is disassociated, there is
no expression.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_scale => parton_expr_setup_scale
  procedure :: setup_fac_scale => parton_expr_setup_fac_scale
  procedure :: setup_ren_scale => parton_expr_setup_ren_scale
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_scale (expr, ef_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_scale
    call ef_scale%build (expr%scale)
    if (allocated (expr%scale)) then
       call expr%setup_var_self ()
       call expr%scale%setup_expr (expr%var_list)
       expr%has_scale = .true.
    end if
  end subroutine parton_expr_setup_scale

  subroutine parton_expr_setup_fac_scale (expr, ef_fac_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_fac_scale
    call ef_fac_scale%build (expr%fac_scale)
    if (allocated (expr%fac_scale)) then
       call expr%setup_var_self ()
       call expr%fac_scale%setup_expr (expr%var_list)
       expr%has_fac_scale = .true.
    end if
  end subroutine parton_expr_setup_fac_scale

  subroutine parton_expr_setup_ren_scale (expr, ef_ren_scale)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_ren_scale
    call ef_ren_scale%build (expr%ren_scale)
    if (allocated (expr%ren_scale)) then
       call expr%setup_var_self ()
       call expr%ren_scale%setup_expr (expr%var_list)
       expr%has_ren_scale = .true.
    end if
  end subroutine parton_expr_setup_ren_scale

@ %def parton_expr_setup_scale
@ %def parton_expr_setup_fac_scale
@ %def parton_expr_setup_ren_scale
@ Compile the weight expression.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_weight => parton_expr_setup_weight
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_weight (expr, ef_weight)
    class(parton_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_weight
    call ef_weight%build (expr%weight)
    if (allocated (expr%weight)) then
       call expr%setup_var_self ()
       call expr%weight%setup_expr (expr%var_list)
       expr%has_weight = .true.
    end if
  end subroutine parton_expr_setup_weight

@ %def parton_expr_setup_weight
@ Filling the partonic state consists of two parts.  The first routine
prepares the subevt without assigning momenta.  It takes the particles from an
[[interaction_t]].  It needs the indices and flavors for the beam,
incoming, and outgoing particles.

We can assume that the particle content of the subevt does not change.
Therefore, we set the event variables [[n_in]], [[n_out]], [[n_tot]] already
in this initialization step.
<<Subevt expr: parton expr: TBP>>=
  procedure :: setup_subevt => parton_expr_setup_subevt
<<Subevt expr: procedures>>=
  subroutine parton_expr_setup_subevt (expr, int, &
       i_beam, i_in, i_out, f_beam, f_in, f_out)
    class(parton_expr_t), intent(inout) :: expr
    type(interaction_t), intent(in), target :: int
    integer, dimension(:), intent(in) :: i_beam, i_in, i_out
    type(flavor_t), dimension(:), intent(in) :: f_beam, f_in, f_out
    allocate (expr%i_beam (size (i_beam)))
    allocate (expr%i_in (size (i_in)))
    allocate (expr%i_out (size (i_out)))
    expr%i_beam = i_beam
    expr%i_in = i_in
    expr%i_out = i_out
    call interaction_to_subevt (int, &
         expr%i_beam, expr%i_in, expr%i_out, expr%subevt_t)
    call subevt_set_pdg_beam     (expr%subevt_t, f_beam%get_pdg ())
    call subevt_set_pdg_incoming (expr%subevt_t, f_in%get_pdg ())
    call subevt_set_pdg_outgoing (expr%subevt_t, f_out%get_pdg ())
    call subevt_set_p2_beam     (expr%subevt_t, f_beam%get_mass () ** 2)
    call subevt_set_p2_incoming (expr%subevt_t, f_in%get_mass ()   ** 2)
    call subevt_set_p2_outgoing (expr%subevt_t, f_out%get_mass ()  ** 2)
    expr%n_in  = size (i_in)
    expr%n_out = size (i_out)
    expr%n_tot = expr%n_in + expr%n_out
  end subroutine parton_expr_setup_subevt

@ %def parton_expr_setup_subevt
@ Transfer PDG codes, masses (initalization) and momenta to a
predefined subevent.  We use the flavor assignment of the first
branch in the interaction state matrix.  Only incoming and outgoing
particles are transferred.  Switch momentum sign for incoming
particles.
<<Subevt expr: public>>=
!  public :: interaction_to_subevt
!  public :: interaction_momenta_to_subevt
<<Subevt expr: interfaces>>=
  interface interaction_momenta_to_subevt
     module procedure interaction_momenta_to_subevt_id
     module procedure interaction_momenta_to_subevt_tr
  end interface

<<Subevt expr: procedures>>=
  subroutine interaction_to_subevt (int, j_beam, j_in, j_out, subevt)
    type(interaction_t), intent(in), target :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(out) :: subevt
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: n_beam, n_in, n_out, i, j
    allocate (flv (int%get_n_tot ()))
    flv = quantum_numbers_get_flavor (int%get_quantum_numbers (1))
    n_beam = size (j_beam)
    n_in = size (j_in)
    n_out = size (j_out)
    call subevt_init (subevt, n_beam + n_in + n_out)
    do i = 1, n_beam
       j = j_beam(i)
       call subevt_set_beam (subevt, i, &
            flv(j)%get_pdg (), &
            vector4_null, &
            flv(j)%get_mass () ** 2)
    end do
    do i = 1, n_in
       j = j_in(i)
       call subevt_set_incoming (subevt, n_beam + i, &
            flv(j)%get_pdg (), &
            vector4_null, &
            flv(j)%get_mass () ** 2)
    end do
    do i = 1, n_out
       j = j_out(i)
       call subevt_set_outgoing (subevt, n_beam + n_in + i, &
            flv(j)%get_pdg (), &
            vector4_null, &
            flv(j)%get_mass () ** 2)
    end do
  end subroutine interaction_to_subevt

  subroutine interaction_momenta_to_subevt_id (int, j_beam, j_in, j_out, subevt)
    type(interaction_t), intent(in) :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(inout) :: subevt
    call subevt_set_p_beam (subevt, - int%get_momenta (j_beam))
    call subevt_set_p_incoming (subevt, - int%get_momenta (j_in))
    call subevt_set_p_outgoing (subevt, int%get_momenta (j_out))
  end subroutine interaction_momenta_to_subevt_id

  subroutine interaction_momenta_to_subevt_tr &
       (int, j_beam, j_in, j_out, lt, subevt)
    type(interaction_t), intent(in) :: int
    integer, dimension(:), intent(in) :: j_beam, j_in, j_out
    type(subevt_t), intent(inout) :: subevt
    type(lorentz_transformation_t), intent(in) :: lt
    call subevt_set_p_beam &
         (subevt, - lt * int%get_momenta (j_beam))
    call subevt_set_p_incoming &
         (subevt, - lt * int%get_momenta (j_in))
    call subevt_set_p_outgoing &
         (subevt, lt * int%get_momenta (j_out))
  end subroutine interaction_momenta_to_subevt_tr

@ %def interaction_momenta_to_subevt
@ The second part takes the momenta from the interaction object and thus
completes the subevt.  The partonic energy can then be computed.
<<Subevt expr: parton expr: TBP>>=
  procedure :: fill_subevt => parton_expr_fill_subevt
<<Subevt expr: procedures>>=
  subroutine parton_expr_fill_subevt (expr, int)
    class(parton_expr_t), intent(inout) :: expr
    type(interaction_t), intent(in), target :: int
    call interaction_momenta_to_subevt (int, &
         expr%i_beam, expr%i_in, expr%i_out, expr%subevt_t)
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%subevt_filled = .true.
  end subroutine parton_expr_fill_subevt
    
@ %def parton_expr_fill_subevt
@ Evaluate, if the event passes the selection.  For absent expressions we take
default values.
<<Subevt expr: parton expr: TBP>>=
  procedure :: evaluate => parton_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine parton_expr_evaluate &
       (expr, passed, scale, fac_scale, ren_scale, weight, scale_forced)
    class(parton_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed
    real(default), intent(out) :: scale
    real(default), intent(out) :: fac_scale
    real(default), intent(out) :: ren_scale
    real(default), intent(out) :: weight
    real(default), intent(in), allocatable, optional :: scale_forced
    logical :: force_scale
    force_scale = .false.
    if (present (scale_forced))  force_scale = allocated (scale_forced)
    call expr%base_evaluate (passed)
    if (passed) then
       if (force_scale) then
          scale = scale_forced
       else if (expr%has_scale) then
          call expr%scale%evaluate ()
          if (expr%scale%is_known ()) then
             scale = expr%scale%get_real ()
          else
             call msg_error ("Evaluate scale expression: result undefined")
             scale = 0
          end if
       else
          scale = expr%sqrts_hat
       end if
       if (force_scale) then
          fac_scale = scale_forced
       else if (expr%has_fac_scale) then
          call expr%fac_scale%evaluate ()
          if (expr%fac_scale%is_known ()) then
             fac_scale = expr%fac_scale%get_real ()
          else
             call msg_error ("Evaluate factorization scale expression: &
                  &result undefined")
             fac_scale = 0
          end if
       else
          fac_scale = scale
       end if
       if (force_scale) then
          ren_scale = scale_forced
       else if (expr%has_ren_scale) then
          call expr%ren_scale%evaluate ()
          if (expr%ren_scale%is_known ()) then
             ren_scale = expr%ren_scale%get_real ()
          else
             call msg_error ("Evaluate renormalization scale expression: &
                  &result undefined")
             ren_scale = 0
          end if
       else
          ren_scale = scale
       end if
       if (expr%has_weight) then
          call expr%weight%evaluate ()
          if (expr%weight%is_known ()) then
             weight = expr%weight%get_real ()
          else
             call msg_error ("Evaluate weight expression: result undefined")
             weight = 0
          end if
       else
          weight = 1
       end if
    end if
  end subroutine parton_expr_evaluate
  
@ %def parton_expr_evaluate
@ Return the beam/incoming parton indices.
<<Subevt expr: parton expr: TBP>>=
  procedure :: get_beam_index => parton_expr_get_beam_index
  procedure :: get_in_index => parton_expr_get_in_index
<<Subevt expr: procedures>>=
  subroutine parton_expr_get_beam_index (expr, i_beam)
    class(parton_expr_t), intent(in) :: expr
    integer, dimension(:), intent(out) :: i_beam
    i_beam = expr%i_beam
  end subroutine parton_expr_get_beam_index
  
  subroutine parton_expr_get_in_index (expr, i_in)
    class(parton_expr_t), intent(in) :: expr
    integer, dimension(:), intent(out) :: i_in
    i_in = expr%i_in
  end subroutine parton_expr_get_in_index
  
@ %def parton_expr_get_beam_index
@ %def parton_expr_get_in_index
@
\subsection{Implementation for full events}
This implementation contains the expressions that we can evaluate for the
full event.  It also contains data that pertain to the event, suitable
for communication with external event formats.  These data
simultaneously serve as pointer targets for the variable lists hidden
in the expressions (eval trees).

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.
<<Subevt expr: public>>=
  public :: event_expr_t
<<Subevt expr: types>>=
  type, extends (subevt_expr_t) :: event_expr_t
     logical :: has_reweight = .false.
     logical :: has_analysis = .false.
     class(expr_t), allocatable :: reweight
     class(expr_t), allocatable :: analysis
     logical :: has_id = .false.
     type(string_t) :: id
     logical :: has_num_id = .false.
     integer :: num_id = 0
     logical :: has_index = .false.
     integer :: index = 0
     logical :: has_sqme_ref = .false.
     real(default) :: sqme_ref = 0
     logical :: has_sqme_prc = .false.
     real(default) :: sqme_prc = 0
     logical :: has_weight_ref = .false.
     real(default) :: weight_ref = 0
     logical :: has_weight_prc = .false.
     real(default) :: weight_prc = 0
     logical :: has_excess_prc = .false.
     real(default) :: excess_prc = 0
     integer :: n_alt = 0
     logical :: has_sqme_alt = .false.
     real(default), dimension(:), allocatable :: sqme_alt
     logical :: has_weight_alt = .false.
     real(default), dimension(:), allocatable :: weight_alt
   contains
   <<Subevt expr: event expr: TBP>>
  end type event_expr_t
     
@ %def event_expr_t
@ Finalizer for the expressions.
<<Subevt expr: event expr: TBP>>=
  procedure :: final => event_expr_final
<<Subevt expr: procedures>>=
  subroutine event_expr_final (object)
    class(event_expr_t), intent(inout) :: object
    call object%base_final ()
    if (object%has_reweight) then
       call object%reweight%final ()
    end if
    if (object%has_analysis) then
       call object%analysis%final ()
    end if
  end subroutine event_expr_final

@ %def event_expr_final
@ Output: continue writing the active expressions, after the common selection
expression.

Note: the [[prefix]] argument is declared in the [[write]] method of the
[[subevt_t]] base type.  Here, it is unused.
<<Subevt expr: event expr: TBP>>=
  procedure :: write => event_expr_write
<<Subevt expr: procedures>>=
  subroutine event_expr_write (object, unit, prefix, pacified)
    class(event_expr_t), intent(in) :: object
    integer, intent(in), optional :: unit
    character(*), intent(in), optional :: prefix
    logical, intent(in), optional :: pacified
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (u, pacified = pacified)
    if (object%subevt_filled) then
       if (object%has_reweight) then
          call write_separator (u)
          write (u, "(1x,A)")  "Reweighting expression:"
          call write_separator (u)
          call object%reweight%write (u)
       end if
       if (object%has_analysis) then
          call write_separator (u)
          write (u, "(1x,A)")  "Analysis expression:"
          call write_separator (u)
          call object%analysis%write (u)
       end if
    end if
  end subroutine event_expr_write
    
@ %def event_expr_write
@ Initializer.  This is required only for the [[sqme_alt]] and
[[weight_alt]] arrays.
<<Subevt expr: event expr: TBP>>=
  procedure :: init => event_expr_init
<<Subevt expr: procedures>>=
  subroutine event_expr_init (expr, n_alt)
    class(event_expr_t), intent(out) :: expr
    integer, intent(in), optional :: n_alt
    if (present (n_alt)) then
       expr%n_alt = n_alt
       allocate (expr%sqme_alt (n_alt), source = 0._default)
       allocate (expr%weight_alt (n_alt), source = 0._default)
    end if
  end subroutine event_expr_init
  
@ %def event_expr_init
@ Define variables.  We have the variables of the base type plus
specific variables for full events.  There is the event index.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_vars => event_expr_setup_vars
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_vars (expr, sqrts)
    class(event_expr_t), intent(inout), target :: expr
    real(default), intent(in) :: sqrts
    call expr%base_setup_vars (sqrts)
    call var_list_append_string_ptr (expr%var_list, &
         var_str ("$process_id"), expr%id, &
         is_known = expr%has_id, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("process_num_id"), expr%num_id, &
         is_known = expr%has_num_id, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqme"), expr%sqme_prc, &
         is_known = expr%has_sqme_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("sqme_ref"), expr%sqme_ref, &
         is_known = expr%has_sqme_ref, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_int_ptr (expr%var_list, &
         var_str ("event_index"), expr%index, &
         is_known = expr%has_index, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_weight"), expr%weight_prc, &
         is_known = expr%has_weight_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_weight_ref"), expr%weight_ref, &
         is_known = expr%has_weight_ref, &
         locked = .true., verbose = .false., intrinsic = .true.)
    call var_list_append_real_ptr (expr%var_list, &
         var_str ("event_excess"), expr%excess_prc, &
         is_known = expr%has_excess_prc, &
         locked = .true., verbose = .false., intrinsic = .true.)
  end subroutine event_expr_setup_vars

@ %def event_expr_setup_vars
@ Compile the analysis expression.  If the pointer is disassociated, there is
no expression.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_analysis => event_expr_setup_analysis
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_analysis (expr, ef_analysis)
    class(event_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_analysis
    call ef_analysis%build (expr%analysis)
    if (allocated (expr%analysis)) then
       call expr%setup_var_self ()
       call expr%analysis%setup_lexpr (expr%var_list)
       expr%has_analysis = .true.
    end if
  end subroutine event_expr_setup_analysis

@ %def event_expr_setup_analysis
@ Compile the reweight expression.
<<Subevt expr: event expr: TBP>>=
  procedure :: setup_reweight => event_expr_setup_reweight
<<Subevt expr: procedures>>=
  subroutine event_expr_setup_reweight (expr, ef_reweight)
    class(event_expr_t), intent(inout), target :: expr
    class(expr_factory_t), intent(in) :: ef_reweight
    call ef_reweight%build (expr%reweight)
    if (allocated (expr%reweight)) then
       call expr%setup_var_self ()
       call expr%reweight%setup_expr (expr%var_list)
       expr%has_reweight = .true.
    end if
  end subroutine event_expr_setup_reweight

@ %def event_expr_setup_reweight
@ Store the string or numeric process ID.  This should be done during
initialization.
<<Subevt expr: event expr: TBP>>=
  procedure :: set_process_id => event_expr_set_process_id
  procedure :: set_process_num_id => event_expr_set_process_num_id
<<Subevt expr: procedures>>=
  subroutine event_expr_set_process_id (expr, id)
    class(event_expr_t), intent(inout) :: expr
    type(string_t), intent(in) :: id
    expr%id = id
    expr%has_id = .true.
  end subroutine event_expr_set_process_id
    
  subroutine event_expr_set_process_num_id (expr, num_id)
    class(event_expr_t), intent(inout) :: expr
    integer, intent(in) :: num_id
    expr%num_id = num_id
    expr%has_num_id = .true.
  end subroutine event_expr_set_process_num_id
    
@ %def event_expr_set_process_id
@ %def event_expr_set_process_num_id
@ Reset / set the data that pertain to a particular event.
<<Subevt expr: event expr: TBP>>=
  procedure :: reset => event_expr_reset
  procedure :: set => event_expr_set
<<Subevt expr: procedures>>=
  subroutine event_expr_reset (expr)
    class(event_expr_t), intent(inout) :: expr
    call expr%base_reset ()
    expr%has_sqme_ref = .false.
    expr%has_sqme_prc = .false.
    expr%has_sqme_alt = .false.
    expr%has_weight_ref = .false.
    expr%has_weight_prc = .false.
    expr%has_weight_alt = .false.
    expr%has_excess_prc = .false.
  end subroutine event_expr_reset
  
  subroutine event_expr_set (expr, &
       weight_ref, weight_prc, weight_alt, &
       excess_prc, &
       sqme_ref, sqme_prc, sqme_alt)
    class(event_expr_t), intent(inout) :: expr
    real(default), intent(in), optional :: weight_ref, weight_prc
    real(default), intent(in), optional :: excess_prc
    real(default), intent(in), optional :: sqme_ref, sqme_prc
    real(default), dimension(:), intent(in), optional :: sqme_alt, weight_alt
    if (present (sqme_ref)) then
       expr%has_sqme_ref = .true.
       expr%sqme_ref = sqme_ref
    end if
    if (present (sqme_prc)) then
       expr%has_sqme_prc = .true.
       expr%sqme_prc = sqme_prc
    end if 
    if (present (sqme_alt)) then
       expr%has_sqme_alt = .true.
       expr%sqme_alt = sqme_alt
    end if
    if (present (weight_ref)) then
       expr%has_weight_ref = .true.
       expr%weight_ref = weight_ref
    end if
    if (present (weight_prc)) then
       expr%has_weight_prc = .true.
       expr%weight_prc = weight_prc
    end if
    if (present (weight_alt)) then
       expr%has_weight_alt = .true.
       expr%weight_alt = weight_alt
    end if
    if (present (excess_prc)) then
       expr%has_excess_prc = .true.
       expr%excess_prc = excess_prc
    end if
  end subroutine event_expr_set
  
@ %def event_expr_reset event_expr_set
@ Fill the event expression: take the particle data and kinematics
from a [[particle_set]] object.

We allow the particle content to change for each event.  Therefore, we set the
event variables each time.

Also increment the event index; initialize it if necessary.
<<Subevt expr: event expr: TBP>>=
  procedure :: fill_subevt => event_expr_fill_subevt
<<Subevt expr: procedures>>=
  subroutine event_expr_fill_subevt (expr, particle_set)
    class(event_expr_t), intent(inout) :: expr
    type(particle_set_t), intent(in) :: particle_set
    call particle_set%to_subevt (expr%subevt_t)
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in  = subevt_get_n_in  (expr%subevt_t)
    expr%n_out = subevt_get_n_out (expr%subevt_t)
    expr%n_tot = expr%n_in + expr%n_out
    expr%subevt_filled = .true.
    if (expr%has_index) then
       expr%index = expr%index + 1
    else
       expr%index = 1
       expr%has_index = .true.
    end if
  end subroutine event_expr_fill_subevt
  
@ %def event_expr_fill_subevt
@ Evaluate, if the event passes the selection.  For absent expressions we take
default values.
<<Subevt expr: event expr: TBP>>=
  procedure :: evaluate => event_expr_evaluate
<<Subevt expr: procedures>>=
  subroutine event_expr_evaluate (expr, passed, reweight, analysis_flag)
    class(event_expr_t), intent(inout) :: expr
    logical, intent(out) :: passed
    real(default), intent(out) :: reweight
    logical, intent(out) :: analysis_flag
    call expr%base_evaluate (passed)
    if (passed) then
       if (expr%has_reweight) then
          call expr%reweight%evaluate ()
          if (expr%reweight%is_known ()) then
             reweight = expr%reweight%get_real ()
          else
             call msg_error ("Evaluate reweight expression: &
                  &result undefined")
             reweight = 0
          end if
       else
          reweight = 1
       end if
       if (expr%has_analysis) then
          call expr%analysis%evaluate ()
          if (expr%analysis%is_known ()) then
             analysis_flag = expr%analysis%get_log ()
          else
             call msg_error ("Evaluate analysis expression: &
                  &result undefined")
             analysis_flag = .false.
          end if
       else
          analysis_flag = .true.
       end if
    end if
  end subroutine event_expr_evaluate
  
@ %def event_expr_evaluate
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Parton states}
A [[parton_state_t]] object contains the effective kinematics and
dynamics of an elementary partonic interaction, with or without the
beam/structure function state included.  The type is abstract and has
two distinct extensions.  The [[isolated_state_t]] extension describes
the isolated elementary interaction where the [[int_eff]] subobject
contains the complex transition amplitude, exclusive in all quantum
numbers.  The particle content and kinematics describe the effective
partonic state.  The [[connected_state_t]] extension contains the
partonic [[subevt]] and the expressions for cuts and scales which use
it.

In the isolated state, the effective partonic interaction may either
be identical to the hard interaction, in which case it is just a
pointer to the latter.  Or it may involve a rearrangement of partons,
in which case we allocate it explicitly and flag this by
[[int_is_allocated]].

The [[trace]] evaluator contains the absolute square of the effective
transition amplitude matrix, summed over final states.  It is also summed over
initial states, depending on the the beam setup allows.  The result is used for
integration.

The [[matrix]] evaluator is the counterpart of [[trace]] which is kept
exclusive in all observable quantum numbers.  The [[flows]] evaluator is
furthermore exclusive in colors, but neglecting all color interference.  The
[[matrix]] and [[flows]] evaluators are filled only for sampling points that
become part of physical events.

Note: It would be natural to make the evaluators allocatable.
However, this causes memory corruption in gfortran 4.6.3.  The extra
[[has_XXX]] flags indicate whether evaluators are active, instead.

This module contains no unit tests.  The tests are covered by the
[[processes]] module below.
<<[[parton_states.f90]]>>=
<<File header>>
module parton_states

<<Use kinds>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use lorentz
  use subevents
  use variables
  use expr_base
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use polarizations
  use interactions
  use evaluators

  use beams
  use sf_base
  use process_constants
  use prc_core
  use subevt_expr

<<Standard module head>>

<<Parton states: public>>

<<Parton states: types>>

contains
  
<<Parton states: procedures>>

end module parton_states
@ %def parton_states
@
\subsection{Abstract base type}
The common part are the evaluators, one for the trace (summed over all
quantum numbers), one for the transition matrix (summed only over
unobservable quantum numbers), and one for the flow distribution
(transition matrix without interferences, exclusive in color flow).
<<Parton states: types>>=
  type, abstract :: parton_state_t
     logical :: has_trace = .false.
     logical :: has_matrix = .false.
     logical :: has_flows = .false.
     type(evaluator_t) :: trace
     type(evaluator_t) :: matrix
     type(evaluator_t) :: flows
   contains
   <<Parton states: parton state: TBP>>
  end type parton_state_t

@ %def parton_state_t
@ The [[isolated_state_t]] extension contains the [[sf_chain_eff]] object
and the (hard) effective interaction [[int_eff]], separately, both
implemented as a pointer.  The evaluators (trace, matrix, flows) apply
to the hard interaction only.

If the effective interaction differs from the hard interaction, the
pointer is allocated explicitly.  Analogously for [[sf_chain_eff]].
<<Parton states: public>>=
  public :: isolated_state_t
<<Parton states: types>>=
  type, extends (parton_state_t) :: isolated_state_t
     logical :: sf_chain_is_allocated = .false.
     type(sf_chain_instance_t), pointer :: sf_chain_eff => null ()
     logical :: int_is_allocated = .false.
     type(interaction_t), pointer :: int_eff => null ()
   contains
   <<Parton states: isolated state: TBP>>
  end type isolated_state_t

@ %def isolated_state_t
@ The [[connected_state_t]] extension contains all data that enable
the evaluation of observables for the effective connected state.  The
evaluators connect the (effective) structure-function chain and hard
interaction that were kept separate in the [[isolated_state_t]].

The [[flows_sf]] evaluator is an extended copy of the
structure-function 

The [[expr]] subobject consists of the [[subevt]], a simple event record,
expressions for cuts etc.\ which refer to this record, and a [[var_list]]
which contains event-specific variables, linked to the process variable
list.  Variables used within the expressions are looked up in [[var_list]].
<<Parton states: types>>=
  public :: connected_state_t
<<Parton states: types>>=
  type, extends (parton_state_t) :: connected_state_t
     type(state_flv_content_t) :: state_flv
     logical :: has_flows_sf = .false.
     type(evaluator_t) :: flows_sf
     logical :: has_expr = .false.
     type(parton_expr_t) :: expr
   contains
   <<Parton states: connected state: TBP>>
  end type connected_state_t
     
@ %def connected_state_t
@ Output: each evaluator is written only when it is active.  The
[[sf_chain]] is only written if it is explicitly allocated.
<<Parton states: parton state: TBP>>=
  procedure :: write => parton_state_write
<<Parton states: procedures>>=
  subroutine parton_state_write (state, unit, testflag)
    class(parton_state_t), intent(in) :: state
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    select type (state)
    class is (isolated_state_t)
       if (state%sf_chain_is_allocated) then
          call write_separator (u)
          call state%sf_chain_eff%write (u)
       end if
       if (state%int_is_allocated) then
          call write_separator (u)
          write (u, "(1x,A)") &
               "Effective interaction:"
          call write_separator (u)
          call state%int_eff%basic_write (u, testflag = testflag)
       end if
    class is (connected_state_t)
       if (state%has_flows_sf) then
          call write_separator (u)
          write (u, "(1x,A)") &
               "Evaluator (extension of the beam evaluator &
               &with color contractions):"
          call write_separator (u)
          call state%flows_sf%write (u, testflag = testflag)
       end if
    end select
    if (state%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (trace of the squared transition matrix):"
       call write_separator (u)
       call state%trace%write (u, testflag = testflag)
    end if
    if (state%has_matrix) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (squared transition matrix):"
       call write_separator (u)
       call state%matrix%write (u, testflag = testflag)
    end if
    if (state%has_flows) then
       call write_separator (u)
       write (u, "(1x,A)") &
            "Evaluator (squared color-flow matrix):"
       call write_separator (u)
       call state%flows%write (u, testflag = testflag)
    end if
    select type (state)
    class is (connected_state_t)
       if (state%has_expr) then
          call write_separator (u)
          call state%expr%write (u)
       end if
    end select
  end subroutine parton_state_write
    
@ %def parton_state_write
@ Finalize interaction and evaluators, but only if allocated.
<<Parton states: parton state: TBP>>=
  procedure :: final => parton_state_final
<<Parton states: procedures>>=
  subroutine parton_state_final (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_flows) then
       call state%flows%final ()
       state%has_flows = .false.
    end if
    if (state%has_matrix) then
       call state%matrix%final ()
       state%has_matrix = .false.
    end if
    if (state%has_trace) then
       call state%trace%final ()
       state%has_trace = .false.
    end if
    select type (state)
    class is (connected_state_t)
       if (state%has_flows_sf) then
          call state%flows_sf%final ()
          state%has_flows_sf = .false.
       end if
       call state%expr%final ()
    class is (isolated_state_t)
       if (state%int_is_allocated) then
          call state%int_eff%final ()
          deallocate (state%int_eff)
          state%int_is_allocated = .false.
       end if
       if (state%sf_chain_is_allocated) then
          call state%sf_chain_eff%final ()
       end if
    end select
  end subroutine parton_state_final
    
@ %def parton_state_final
@
\subsection{Common Initialization}
Initialize the isolated parton state.  In this version, the
effective structure-function chain [[sf_chain_eff]] and the effective
interaction [[int_eff]] both are trivial pointers to the seed
structure-function chain and to the hard interaction, respectively.
<<Parton states: isolated state: TBP>>=
  procedure :: init => isolated_state_init_pointers
<<Parton states: procedures>>=
  subroutine isolated_state_init_pointers (state, sf_chain, int)
    class(isolated_state_t), intent(out) :: state
    type(sf_chain_instance_t), intent(in), target :: sf_chain
    type(interaction_t), intent(in), target :: int
    state%sf_chain_eff => sf_chain
    state%int_eff => int
  end subroutine isolated_state_init_pointers
    
@ %def isolated_state_init_pointers
@ 
\subsection{Evaluator initialization: isolated state}
Create an evaluator for the trace of the squared transition matrix.
The trace goes over all outgoing quantum numbers.  Whether we trace
over incoming quantum numbers other than color, depends on the given
[[qn_mask_in]].

There are two options: explicitly computing the color factor table
([[use_cf]] false; [[nc]] defined), or taking the color factor
table from the hard matrix element data.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_trace => isolated_state_setup_square_trace
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_trace (state, core, qn_mask_in, &
       col)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    integer, dimension(:), intent(in) :: col
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask    
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      qn_mask(:data%n_in) = &
              quantum_numbers_mask (.false., .true., .false.) &
              .or. qn_mask_in
      qn_mask(data%n_in+1:) = &
           quantum_numbers_mask (.true., .true., .true.)
    if (core%use_color_factors) then
       call state%trace%init_square (state%int_eff, qn_mask, &
            col_flow_index = data%cf_index, &
            col_factor = data%color_factors, &
            col_index_hi = col, &
            nc = core%nc)
    else
       call state%trace%init_square (state%int_eff, qn_mask, nc = core%nc)
    end if
    end associate
    state%has_trace = .true.
  end subroutine isolated_state_setup_square_trace
    
@ %def isolated_state_setup_square_trace
@ Setup the evaluator for the transition matrix, exclusive in
helicities where this is requested.  

For all unstable final-state particles we keep polarization according to the
applicable decay options.  If the process is a decay itself, this applies also
to the initial state.

For all polarized final-state particles, we keep polarization including
off-diagonal entries.  We drop helicity completely for unpolarized final-state
particles.

For the initial state, if the particle has not been handled yet, we
apply the provided [[qn_mask_in]] which communicates the beam properties.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_matrix => isolated_state_setup_square_matrix
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_matrix &
       (state, core, model, qn_mask_in, col)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    integer, dimension(:), intent(in) :: col
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    logical :: helmask, helmask_hd
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      allocate (flv (data%n_flv))
      do i = 1, data%n_in + data%n_out      
         call flv%init (data%flv_state(i,:), model)
         if ((data%n_in == 1 .or. i > data%n_in) &
              .and. any (.not. flv%is_stable ())) then
            helmask = all (flv%decays_isotropically ())
            helmask_hd = all (flv%decays_diagonal ())
            qn_mask(i) = quantum_numbers_mask (.false., .true., helmask, &
                 mask_hd = helmask_hd)
         else if (i > data%n_in) then
            helmask = all (.not. flv%is_polarized ())
            qn_mask(i) = quantum_numbers_mask (.false., .true., helmask)
         else
            qn_mask(i) = quantum_numbers_mask (.false., .true., .false.) &
              .or. qn_mask_in(i)
         end if
      end do
    if (core%use_color_factors) then
       call state%matrix%init_square (state%int_eff, qn_mask, &
            col_flow_index = data%cf_index, &
            col_factor = data%color_factors, &
            col_index_hi = col, &
            nc = core%nc)
    else
       call state%matrix%init_square (state%int_eff, &
            qn_mask, &
            nc = core%nc)
    end if
    end associate
    state%has_matrix = .true.
  end subroutine isolated_state_setup_square_matrix

@ %def isolated_state_setup_square_matrix
@ This procedure initializes the evaluator that computes the
contributions to color flows, neglecting color interference.
The incoming-particle mask can be used to sum over incoming flavor.

Helicity handling: see above.
<<Parton states: isolated state: TBP>>=
  procedure :: setup_square_flows => isolated_state_setup_square_flows
<<Parton states: procedures>>=
  subroutine isolated_state_setup_square_flows (state, core, model, qn_mask_in)
    class(isolated_state_t), intent(inout), target :: state
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    type(quantum_numbers_mask_t), dimension(:), intent(in) :: qn_mask_in
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    logical :: helmask, helmask_hd
    associate (data => core%data)
      allocate (qn_mask (data%n_in + data%n_out))
      allocate (flv (data%n_flv))
      do i = 1, data%n_in + data%n_out
         call flv%init (data%flv_state(i,:), model)
         if ((data%n_in == 1 .or. i > data%n_in) &
              .and. any (.not. flv%is_stable ())) then
            helmask = all (flv%decays_isotropically ())
            helmask_hd = all (flv%decays_diagonal ())
            qn_mask(i) = quantum_numbers_mask (.false., .false., helmask, &
                 mask_hd = helmask_hd)
         else if (i > data%n_in) then
            helmask = all (.not. flv%is_polarized ())
            qn_mask(i) = quantum_numbers_mask (.false., .false., helmask)
         else
            qn_mask(i) = quantum_numbers_mask (.false., .false., .false.) &
              .or. qn_mask_in(i)
         end if
      end do
      call state%flows%init_square (state%int_eff, qn_mask, &
           expand_color_flows = .true.)
    end associate
    state%has_flows = .true.
  end subroutine isolated_state_setup_square_flows

@ %def isolated_state_setup_square_flows
@ 
\subsection{Evaluator initialization: connected state}
Setup a trace evaluator as a product of two evaluators (incoming state,
effective interaction).  In the result, all quantum numbers are summed over.

If the optional [[int]] interaction is provided, use this for the
first factor in the convolution.  Otherwise, use the final interaction
of the stored [[sf_chain]].

The [[resonant]] flag applies if we want to construct
a decay chain.  The resonance property can propagate to the final
event output.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_trace => connected_state_setup_connected_trace
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_trace &
       (state, isolated, int, resonant)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = quantum_numbers_mask (.true., .true., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
    end if
    call state%trace%init_product (src_int, isolated%trace, &
          qn_mask_conn = mask, &
          qn_mask_rest = mask, &
          connections_are_resonant = resonant)
    state%has_trace = .true.
  end subroutine connected_state_setup_connected_trace
    
@ %def connected_state_setup_connected_trace
@ Setup a matrix evaluator as a product of two evaluators (incoming
state, effective interation).  In the intermediate state, color and
helicity is summed over.  In the final state, we keep the quantum
numbers which are present in the original evaluators.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_matrix => connected_state_setup_connected_matrix
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_matrix &
       (state, isolated, int, resonant, qn_filter_conn)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_t), intent(in), optional :: qn_filter_conn
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = quantum_numbers_mask (.false., .true., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
    end if
    call state%matrix%init_product &
         (src_int, isolated%matrix, mask, &
          qn_filter_conn = qn_filter_conn, &
          connections_are_resonant = resonant)
    state%has_matrix = .true.
  end subroutine connected_state_setup_connected_matrix
  
@ %def connected_state_setup_connected_matrix
@ Setup a matrix evaluator as a product of two evaluators (incoming
state, effective interation).  In the intermediate state, only
helicity is summed over.  In the final state, we keep the quantum
numbers which are present in the original evaluators.


If the optional [[int]] interaction is provided, use this for the
first factor in the convolution.  Otherwise, use the final interaction
of the stored [[sf_chain]], after creating an intermediate interaction
that includes a correlated color state.  We assume that for a
caller-provided [[int]], this is not necessary.
<<Parton states: connected state: TBP>>=
  procedure :: setup_connected_flows => connected_state_setup_connected_flows
<<Parton states: procedures>>=
  subroutine connected_state_setup_connected_flows &
       (state, isolated, int, resonant, qn_filter_conn)
    class(connected_state_t), intent(inout), target :: state
    type(isolated_state_t), intent(in), target :: isolated
    type(interaction_t), intent(in), optional, target :: int
    logical, intent(in), optional :: resonant
    type(quantum_numbers_t), intent(in), optional :: qn_filter_conn
    type(quantum_numbers_mask_t) :: mask
    type(interaction_t), pointer :: src_int
    mask = quantum_numbers_mask (.false., .false., .true.)
    if (present (int)) then
       src_int => int
    else
       src_int => isolated%sf_chain_eff%get_out_int_ptr ()
       call state%flows_sf%init_color_contractions (src_int)
       state%has_flows_sf = .true.
       src_int => state%flows_sf%interaction_t
    end if
    call state%flows%init_product (src_int, isolated%flows, mask, &
          qn_filter_conn = qn_filter_conn, &
          connections_are_resonant = resonant)
    state%has_flows = .true.
  end subroutine connected_state_setup_connected_flows
  
@ %def connected_state_setup_connected_flows
@ Determine and store the flavor content for the connected state.
This queries the [[matrix]] evaluator component, which should hold the
requested flavor information.
<<Parton states: connected state: TBP>>=
  procedure :: setup_state_flv => connected_state_setup_state_flv
<<Parton states: procedures>>=
  subroutine connected_state_setup_state_flv (state, n_out_hard)
    class(connected_state_t), intent(inout), target :: state
    integer, intent(in) :: n_out_hard
    call interaction_get_flv_content &
         (state%matrix%interaction_t, state%state_flv, n_out_hard)
  end subroutine connected_state_setup_state_flv
  
@ %def connected_state_setup_state_flv
@ Return the current flavor state object.
<<Parton states: connected state: TBP>>=
  procedure :: get_state_flv => connected_state_get_state_flv
<<Parton states: procedures>>=
  function connected_state_get_state_flv (state) result (state_flv)
    class(connected_state_t), intent(in) :: state
    type(state_flv_content_t) :: state_flv
    state_flv = state%state_flv
  end function connected_state_get_state_flv
  
@ %def connected_state_get_state_flv
@ 
\subsection{Cuts and expressions}
Set up the [[subevt]] that corresponds to the connected interaction.
The index arrays refer to the interaction.

We assign the particles as follows: the beam particles are the first
two (decay process: one) entries in the trace evaluator.  The incoming
partons are identified by their link to the outgoing partons of the
structure-function chain.  The outgoing partons are those of the trace
evaluator, which include radiated partons during the
structure-function chain.
<<Parton states: connected state: TBP>>=
  procedure :: setup_subevt => connected_state_setup_subevt
<<Parton states: procedures>>=
  subroutine connected_state_setup_subevt (state, sf_chain, f_beam, f_in, f_out)
    class(connected_state_t), intent(inout), target :: state
    type(sf_chain_instance_t), intent(in), target :: sf_chain
    type(flavor_t), dimension(:), intent(in) :: f_beam, f_in, f_out
    integer :: n_beam, n_in, n_out, n_vir, n_tot, i, j
    integer, dimension(:), allocatable :: i_beam, i_in, i_out
    integer :: sf_out_i
    type(interaction_t), pointer :: sf_int
    sf_int => sf_chain%get_out_int_ptr ()
    n_beam = size (f_beam)
    n_in = size (f_in)
    n_out = size (f_out)
    n_vir = state%trace%get_n_vir ()
    n_tot = state%trace%get_n_tot ()
    allocate (i_beam (n_beam), i_in (n_in), i_out (n_out))
    i_beam = [(i, i = 1, n_beam)]
    do j = 1, n_in
       sf_out_i = sf_chain%get_out_i (j)
       i_in(j) = interaction_find_link &
            (state%trace%interaction_t, sf_int, sf_out_i)
    end do
    i_out = [(i, i = n_vir + 1, n_tot)]
    call state%expr%setup_subevt (state%trace%interaction_t, &
         i_beam, i_in, i_out, f_beam, f_in, f_out)
    state%has_expr = .true.
  end subroutine connected_state_setup_subevt

@ %def connected_state_setup_subevt
@ Initialize the variable list specific for this state/term.  We insert event
variables ([[sqrts_hat]]) and link the process variable list.  The variable
list acquires pointers to subobjects of [[state]], which must therefore have a
[[target]] attribute.
<<Parton states: connected state: TBP>>=
  procedure :: setup_var_list => connected_state_setup_var_list
<<Parton states: procedures>>=
  subroutine connected_state_setup_var_list (state, process_var_list, beam_data)
    class(connected_state_t), intent(inout), target :: state
    type(var_list_t), intent(in), target :: process_var_list
    type(beam_data_t), intent(in) :: beam_data
    call state%expr%setup_vars (beam_data_get_sqrts (beam_data))
    call state%expr%link_var_list (process_var_list)
  end subroutine connected_state_setup_var_list
  
@ %def connected_state_setup_var_list
@ Allocate the cut expression etc.
<<Parton states: connected state: TBP>>=
  procedure :: setup_cuts => connected_state_setup_cuts
  procedure :: setup_scale => connected_state_setup_scale
  procedure :: setup_fac_scale => connected_state_setup_fac_scale
  procedure :: setup_ren_scale => connected_state_setup_ren_scale
  procedure :: setup_weight => connected_state_setup_weight
<<Parton states: procedures>>=
  subroutine connected_state_setup_cuts (state, ef_cuts)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_cuts
    call state%expr%setup_selection (ef_cuts)
  end subroutine connected_state_setup_cuts
    
  subroutine connected_state_setup_scale (state, ef_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_scale
    call state%expr%setup_scale (ef_scale)
  end subroutine connected_state_setup_scale
    
  subroutine connected_state_setup_fac_scale (state, ef_fac_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_fac_scale
    call state%expr%setup_fac_scale (ef_fac_scale)
  end subroutine connected_state_setup_fac_scale
    
  subroutine connected_state_setup_ren_scale (state, ef_ren_scale)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_ren_scale
    call state%expr%setup_ren_scale (ef_ren_scale)
  end subroutine connected_state_setup_ren_scale
    
  subroutine connected_state_setup_weight (state, ef_weight)
    class(connected_state_t), intent(inout), target :: state
    class(expr_factory_t), intent(in) :: ef_weight
    call state%expr%setup_weight (ef_weight)
  end subroutine connected_state_setup_weight
    
@ %def connected_state_setup_expressions
@ Reset the expression object: invalidate the subevt.
<<Parton states: connected state: TBP>>=
  procedure :: reset_expressions => connected_state_reset_expressions
<<Parton states: procedures>>=
  subroutine connected_state_reset_expressions (state)
    class(connected_state_t), intent(inout) :: state
    if (state%has_expr)  call state%expr%reset ()
  end subroutine connected_state_reset_expressions
  
@ %def connected_state_reset_expressions
@ 
\subsection{Evaluation}
Transfer momenta to the trace evaluator and fill the [[subevt]] with
this effective kinematics, if applicable.

Note: we may want to apply a boost for the [[subevt]].
<<Parton states: parton state: TBP>>=
  procedure :: receive_kinematics => parton_state_receive_kinematics
<<Parton states: procedures>>=
  subroutine parton_state_receive_kinematics (state)
    class(parton_state_t), intent(inout), target :: state
    if (state%has_trace) then
       call state%trace%receive_momenta ()
       select type (state)
       class is (connected_state_t)
          if (state%has_expr) then
             call state%expr%fill_subevt (state%trace%interaction_t)
          end if
       end select
    end if
  end subroutine parton_state_receive_kinematics

@ %def parton_state_receive_kinematics
@ Recover kinematics: We assume that the trace evaluator is filled
with momenta.  Send those momenta back to the sources, then fill the
variables and subevent as above.

The incoming momenta of the connected state are not connected to the
isolated state but to the beam interaction.  Therefore, the incoming
momenta within the isolated state do not become defined, yet.
Instead, we reconstruct the beam (and ISR) momentum configuration.
<<Parton states: parton state: TBP>>=
  procedure :: send_kinematics => parton_state_send_kinematics
<<Parton states: procedures>>=
  subroutine parton_state_send_kinematics (state)
    class(parton_state_t), intent(inout), target :: state
    if (state%has_trace) then
       call interaction_send_momenta (state%trace%interaction_t)
       select type (state)
       class is (connected_state_t)
          call state%expr%fill_subevt (state%trace%interaction_t)
       end select
    end if
  end subroutine parton_state_send_kinematics

@ %def parton_state_send_kinematics
@ Evaluate the expressions.  The routine evaluates first the cut expression.
If the event passes, it evaluates the other expressions.  Where no expressions
are defined, default values are inserted.
<<Parton states: connected state: TBP>>=
  procedure :: evaluate_expressions => connected_state_evaluate_expressions
<<Parton states: procedures>>=
  subroutine connected_state_evaluate_expressions (state, passed, &
       scale, fac_scale, ren_scale, weight, scale_forced)
    class(connected_state_t), intent(inout) :: state
    logical, intent(out) :: passed
    real(default), intent(out) :: scale, fac_scale, ren_scale, weight
    real(default), intent(in), allocatable, optional :: scale_forced
    if (state%has_expr) then
       call state%expr%evaluate (passed, scale, fac_scale, ren_scale, weight, &
            scale_forced)
    end if
  end subroutine connected_state_evaluate_expressions
    
@ %def connected_state_evaluate_expressions
@ Evaluate the structure-function chain, if it is allocated
explicitly.  The argument is the factorization scale.

If the chain is merely a pointer, the chain should already be
evaluated at this point.
<<Parton states: isolated state: TBP>>=
  procedure :: evaluate_sf_chain => isolated_state_evaluate_sf_chain
<<Parton states: procedures>>=
  subroutine isolated_state_evaluate_sf_chain (state, fac_scale)
    class(isolated_state_t), intent(inout) :: state
    real(default), intent(in) :: fac_scale
    if (state%sf_chain_is_allocated) then
       call state%sf_chain_eff%evaluate (fac_scale)
    end if
  end subroutine isolated_state_evaluate_sf_chain
  
@ %def isolated_state_evaluate_sf_chain
@ Evaluate the trace. 
<<Parton states: parton state: TBP>>=
  procedure :: evaluate_trace => parton_state_evaluate_trace
<<Parton states: procedures>>=
  subroutine parton_state_evaluate_trace (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_trace) then
       call state%trace%evaluate ()
    end if
  end subroutine parton_state_evaluate_trace

@ %def parton_state_evaluate_trace
@ Evaluate the extra evaluators that we need for physical events. 
<<Parton states: parton state: TBP>>=
  procedure :: evaluate_event_data => parton_state_evaluate_event_data
<<Parton states: procedures>>=
  subroutine parton_state_evaluate_event_data (state)
    class(parton_state_t), intent(inout) :: state
    select type (state)
    type is (connected_state_t)
       if (state%has_flows_sf) then
          call state%flows_sf%receive_momenta ()
          call state%flows_sf%evaluate ()
       end if
    end select
    if (state%has_matrix) then
       call state%matrix%receive_momenta ()
       call state%matrix%evaluate ()
    end if
    if (state%has_flows) then
       call state%flows%receive_momenta ()
       call state%flows%evaluate ()
    end if
  end subroutine parton_state_evaluate_event_data

@ %def parton_state_evaluate_event_data
@ Normalize the helicity density matrix by its trace, i.e., factor out
the trace and put it into an overall normalization factor.  The trace
and flow evaluators are unchanged.
<<Parton states: parton state: TBP>>=
  procedure :: normalize_matrix_by_trace => &
       parton_state_normalize_matrix_by_trace
<<Parton states: procedures>>=
  subroutine parton_state_normalize_matrix_by_trace (state)
    class(parton_state_t), intent(inout) :: state
    if (state%has_matrix) then
       call state%matrix%normalize_by_trace ()
    end if
  end subroutine parton_state_normalize_matrix_by_trace
  
@ %def parton_state_normalize_matrix_by_trace
@
\subsection{Accessing the state}
Three functions return a pointer to the event-relevant interactions.
<<Parton states: parton state: TBP>>=
  procedure :: get_trace_int_ptr => parton_state_get_trace_int_ptr
  procedure :: get_matrix_int_ptr => parton_state_get_matrix_int_ptr
  procedure :: get_flows_int_ptr => parton_state_get_flows_int_ptr
<<Parton states: procedures>>=
  function parton_state_get_trace_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_trace) then
       ptr => state%trace%interaction_t
    else
       ptr => null ()
    end if
  end function parton_state_get_trace_int_ptr
  
  function parton_state_get_matrix_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_matrix) then
       ptr => state%matrix%interaction_t
    else
       ptr => null ()
    end if
  end function parton_state_get_matrix_int_ptr
  
  function parton_state_get_flows_int_ptr (state) result (ptr)
    class(parton_state_t), intent(in), target :: state
    type(interaction_t), pointer :: ptr
    if (state%has_flows) then
       ptr => state%flows%interaction_t
    else
       ptr => null ()
    end if
  end function parton_state_get_flows_int_ptr
  
@ %def parton_state_get_trace_int_ptr
@ %def parton_state_get_matrix_int_ptr
@ %def parton_state_get_flows_int_ptr
@ Return the indices of the beam particles and the outgoing particles within
the trace (and thus, matrix and flows) evaluator, respectively.
<<Parton states: connected state: TBP>>=
  procedure :: get_beam_index => connected_state_get_beam_index
  procedure :: get_in_index => connected_state_get_in_index
<<Parton states: procedures>>=
  subroutine connected_state_get_beam_index (state, i_beam)
    class(connected_state_t), intent(in) :: state
    integer, dimension(:), intent(out) :: i_beam
    call state%expr%get_beam_index (i_beam)
  end subroutine connected_state_get_beam_index
  
  subroutine connected_state_get_in_index (state, i_in)
    class(connected_state_t), intent(in) :: state
    integer, dimension(:), intent(out) :: i_in
    call state%expr%get_in_index (i_in)
  end subroutine connected_state_get_in_index
  
@ %def connected_state_get_beam_index
@ %def connected_state_get_in_index
@ Return the number of outgoing (hard) particles for the state.
<<Parton states: parton state: TBP>>=
  procedure :: get_n_out => parton_state_get_n_out
<<Parton states: procedures>>=
  function parton_state_get_n_out (state) result (n)
    class(parton_state_t), intent(in), target :: state
    integer :: n
    n = state%trace%get_n_out ()
  end function parton_state_get_n_out
  
@ %def parton_state_get_n_out
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process Component Management}
This module contains tools for managing and combining process
components and matrix-element code and values, acting at a level below
the actual process definition.

The types introduced here are abstract base types.
<<[[pcm_base.f90]]>>=
<<File header>>

module pcm_base

!  use kinds
!  use io_units
!<<Use strings>>

<<Standard module head>>

<<PCM base: public>>

<<PCM base: types>>

<<PCM base: interfaces>>

contains

<<PCM base: procedures>>

end module pcm_base
@ %def pcm_base
@
\subsection{Manager Configuration}
This object may holds process and method-specific data, and it should
allocate the corresponding manager instance.
<<PCM base: public>>=
  public :: pcm_t
<<PCM base: types>>=
  type, abstract :: pcm_t
   contains
   <<PCM base: pcm: TBP>>
  end type pcm_t
  
@ %def pcm_t
@ The factory method.  We use the [[inout]] intent, so calling this
again is an error.
<<PCM base: pcm: TBP>>=
  procedure(pcm_allocate_instance), deferred :: allocate_instance
<<PCM base: interfaces>>=
  abstract interface
     subroutine pcm_allocate_instance (pcm, instance)
       import
       class(pcm_t), intent(in) :: pcm
       class(pcm_instance_t), intent(inout), allocatable :: instance
     end subroutine pcm_allocate_instance
  end interface
  
@ %def pcm_allocate_instance
@
\subsection{Manager Instance}
This object deals with the actual (squared) matrix element values.
<<PCM base: public>>=
  public :: pcm_instance_t
<<PCM base: types>>=
  type, abstract :: pcm_instance_t
  end type pcm_instance_t
  
@ %def pcm_instance_t
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Elementary Processes}
This module combines hard interactions, phase space, and (for
scatterings) structure functions and interfaces them to the
integration module.

The process object implements the combination of a fixed beam and
structure-function setup with a number of elementary processes.  The
latter are called process components.  The process object
represents an entity which is supposedly observable.  It should
be meaningful to talk about the cross section of a process.  

The individual components of a process are, technically, processes
themselves, but they may have unphysical cross sections which have to
be added for a physical result.  Process components may be exclusive
tree-level elementary processes, dipole subtraction term, loop
corrections, etc.

The beam and structure function setup is common to all process
components.  Thus, there is only one instance of this part.

The process may be a scattering process or a decay process.  In the
latter case, there are no structure functions, and the beam setup
consists of a single particle.  Otherwise, the two classes are treated
on the same footing.

Once a sampling point has been chosen, a process determines a set of
partons with a correlated density matrix of quantum numbers.  In general, each
sampling point will generate, for each process component, one or more
distinct parton configurations.  This is the [[computed]] state.  The
computed state is the subject of the multi-channel integration
algorithm.

For NLO computations, it is necessary to project the computed states
onto another set of parton configurations (e.g., by recombining
certain pairs).  This is the [[observed]] state.  When computing
partonic observables, the information is taken from the observed
state.

For the purpose of event generation, we will later select one parton
configuration from the observed state and collapse the correlated
quantum state.  This configuration is then dressed by applying parton
shower, decays and hadronization.  The decay chain, in particular,
combines a scattering process with possible subsequent decay processes
on the parton level, which are full-fledged process objects themselves.
<<[[processes.f90]]>>=
<<File header>>

module processes

<<Use kinds>>
<<Use strings>>
  use constants, only: one
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use md5
  use cputime
  use os_interface
  use physics_defs
  use lorentz
  use sm_qcd
  use pdg_arrays
  use variables
  use expr_base
  use model_data
  use flavors
  use helicities
  use colors
  use quantum_numbers
  use state_matrices
  use interactions
  use particles
  use beam_structures
  use beams
  use sf_mappings
  use sf_base
  use process_constants
  use phs_base
  use rng_base
  use mci_base
  use process_libraries
  use prc_test

  use integration_results
  use prc_core
  use parton_states

  use pcm_base, only: pcm_t, pcm_instance_t
  use nlo_data, only: sqme_collector_t
  use nlo_data, only: fks_template_t
  use nlo_controller, only: nlo_controller_t

  use phs_wood, only: phs_wood_config_t, phs_wood_t
  use phs_fks, only: phs_fks_config_t, phs_fks_t
  use phs_fks, only: PHS_MODE_ADDITIONAL_PARTICLE
  use phs_fks, only: PHS_MODE_COLLINEAR_REMNANT

  use prc_gosam, only: prc_gosam_t
  use prc_openloops, only: prc_openloops_t
  use prc_omega, only: prc_omega_t
  use prc_user_defined
  use prc_threshold

  use blha_config, only: blha_master_t
  use blha_olp_interfaces, only: blha_template_t, prc_blha_t
  
<<Standard module head>>

<<Processes: public>>

<<Processes: parameters>>

<<Processes: types>>

<<Processes: process part types>>

<<Processes: process type>>

<<Processes: interfaces>>

<<Processes: test types>>

contains

<<Processes: procedures>>

<<Processes: test type procedures>>

end module processes
@ %def processes
@
\subsection{The Process Object}
A process object is the workspace for creating process instances for
event generation.  After initialization, its contents are filled by
integration passes which shape the integration grids and compute cross
sections.  Processes are set up initially from user-level
configuration data.  After calculating integrals and thus developing
integration grid data, the program may use a process
object or a copy of it for the purpose of generating events.

The process object consists of several subobjects with their specific
purposes.  The corresponding types are defined below.  (Technically,
the subobject type definitions have to come before the process type
definition, but with NOWEB magic we reverse this order here.)

The [[type]] determines whether we are considering a decay or a
scattering process.

The [[meta]] object describes the process and its environment.  All
contents become fixed when the object is initialized.

The [[config]] object holds physical and technical configuration data
that have been obtained during process initialization, and which are
common to all process components.

The individual process components are configured in the [[component]]
objects.  These objects contain more configuration parameters and
workspace, as needed for the specific process variant.

The [[term]] objects describe parton configurations which are
technically used as phase-space points.  Each process component may
split into several terms with distinct kinematics and particle
content.  Furthermore, each term may project on a different physical
state, e.g., by particle recombination.  The [[term]] object provides
the framework for this projection, for applying cuts, weight, and thus
completing the process calculation.

The [[beam_config]] object describes the incoming particles, either the
decay mother or the scattering beams.  It also contains the structure-function
information.

The [[mci_entry]] objects configure a MC input parameter set and integrator,
each.  The number of parameters depends on the process component and on the
beam and structure-function setup.

The [[pcm]] component is the process-component manager.  This
polymorphic object manages and hides the details of dealing with NLO
processes where several components have to be combined in a
non-trivial way.  It also acts as an abstract factory for the
corresponding object in [[process_instance]], which does the actual
work for this matter.
<<Processes: public>>=
  public :: process_t
<<Processes: process type>>=
  type :: process_t
     private
     type(process_metadata_t) :: &
          meta
     type(process_config_data_t) :: &
          config
     type(process_counter_t) :: &
          counter
     type(process_component_t), dimension(:), allocatable :: &
          component
     type(process_term_t), dimension(:), allocatable :: &
          term
     type(process_beam_config_t) :: &
          beam_config
     type(process_mci_entry_t), dimension(:), allocatable :: &
          mci_entry
     class(pcm_t), allocatable :: &
          pcm
   contains
   <<Processes: process: TBP>>
  end type process_t

@ %def process_t
@ 
This procedure is an important debugging and inspection tool; it is
not used during normal operation.  The process object is written
to a file (identified by unit, which may also be standard output).
Optional flags determine whether we show everything or just the
interesting parts.
<<Processes: process: TBP>>=
  procedure :: write => process_write
@ 
<<Processes: procedures>>=
  subroutine process_write (process, screen, unit, &
       show_all, show_var_list, &
       show_os_data, &
       show_rng_factory, show_model, show_expressions, &
       show_sfchain, &
       show_equivalences, show_history, show_histories, &
       show_forest, show_x, &
       show_subevt, show_evaluators, pacify)
    class(process_t), intent(in) :: process
    logical, intent(in) :: screen
    integer, intent(in), optional :: unit    
    logical, intent(in), optional :: show_all
    logical, intent(in), optional :: show_var_list
    logical, intent(in), optional :: show_os_data
    logical, intent(in), optional :: show_rng_factory
    logical, intent(in), optional :: show_model, show_expressions
    logical, intent(in), optional :: show_sfchain
    logical, intent(in), optional :: show_equivalences
    logical, intent(in), optional :: show_history, show_histories
    logical, intent(in), optional :: show_forest, show_x
    logical, intent(in), optional :: show_subevt, show_evaluators
    logical, intent(in), optional :: pacify
    logical :: all
    logical :: var_list
    logical :: counters
    logical :: os_data
    logical :: rng_factory, model, expressions
    integer :: u, i
    u = given_output_unit (unit)
    if (present (show_all)) then
       all = show_all
    else
       all = .false.
    end if
    var_list = .false.
    counters = .true.
    os_data = .false.
    model = .false.
    rng_factory = .true.
    expressions = .false.
    if (present (show_var_list)) then
       all = .false.; var_list = show_var_list
    end if
    if (present (show_os_data)) then
       all = .false.; os_data = show_os_data
    end if
    if (present (show_rng_factory)) then
       all = .false.; rng_factory = show_rng_factory
    end if
    if (present (show_model)) then
       all = .false.; model = show_model
    end if
    if (present (show_expressions)) then
       all = .false.; expressions = show_expressions
    end if
    if (all) then
       var_list = .true.
       rng_factory = .true.
       model = .true.
       expressions = .true.
    end if
    if (screen) then
       write (msg_buffer, "(A)")  repeat ("-", 72)
       call msg_message ()
    else
       call write_separator (u, 2)
    end if
    call process%meta%write (u, var_list, screen)
    if (process%meta%type == PRC_UNKNOWN) then
       call write_separator (u, 2)
       return
    else
       if (.not. screen)  call write_separator (u)
    end if
    if (screen)  return
    call process%config%write &
         (u, counters, os_data, rng_factory, model, expressions)
    call write_separator (u, 2)
    if (allocated (process%component)) then
       write (u, "(1x,A)") "Process component configuration:"
       do i = 1, size (process%component)
          call write_separator (u)
          call process%component(i)%write (u)
       end do
    else
       write (u, "(1x,A)") "Process component configuration: [undefined]"
    end if
    call write_separator (u, 2)
    if (allocated (process%term)) then
       write (u, "(1x,A)") "Process term configuration:"
       do i = 1, size (process%term)
          call write_separator (u)
          call process%term(i)%write (u)
       end do
    else
       write (u, "(1x,A)") "Process term configuration: [undefined]"
    end if
    call write_separator (u, 2)
    call process%beam_config%write (u)
    call write_separator (u, 2)
    if (allocated (process%mci_entry)) then
       write (u, "(1x,A)") "Multi-channel integrator configurations:"
       do i = 1, size (process%mci_entry)
          call write_separator (u)
          write (u, "(1x,A,I0,A)")  "MCI #", i, ":"
          call process%mci_entry(i)%write (u, pacify)
       end do
    end if
    call write_separator (u, 2)
  end subroutine process_write
      
@ %def process_write
@ Screen output.  Write a short account of the process configuration
and the current results.  The verbose version lists the components,
the short version just the results.
<<Processes: process: TBP>>=
  procedure :: show => process_show
<<Processes: procedures>>=
  subroutine process_show (object, unit, verbose)
    class(process_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: u
    logical :: verb
    u = given_output_unit (unit)
    verb = .true.;  if (present (verbose)) verb = verbose
    if (verb) then
       call object%meta%show (u, object%config%model%get_name ())
       select case (object%meta%type)
       case (PRC_DECAY)
          write (u, "(2x,A)", advance="no")  "Computed width ="
       case (PRC_SCATTERING)
          write (u, "(2x,A)", advance="no")  "Computed cross section ="
       case default;  return
       end select
    else 
       write (u, "(A)", advance="no") char (object%meta%id)
       select case (object%meta%num_id)
       case (0)
          write (u, "(':')")
       case default
          write (u, "(1x,'(',I0,')',':')") object%meta%num_id
       end select
       write (u, "(2x)", advance="no")
    end if
    write (u, "(ES14.7,1x,'+-',ES9.2)", advance="no") &
         object%get_integral_tot (), object%get_error_tot ()
    select case (object%meta%type)
    case (PRC_DECAY)
       write (u, "(1x,A)")  "GeV"
    case (PRC_SCATTERING)
       write (u, "(1x,A)")  "fb"
    case default
       write (u, *)
    end select
  end subroutine process_show
    
@ %def process_show
@ Finalizer.  Explicitly iterate over all subobjects that may contain
allocated pointers.
<<Processes: process: TBP>>=
  procedure :: final => process_final
<<Processes: procedures>>=
  subroutine process_final (process)
    class(process_t), intent(inout) :: process
    integer :: i
    call process%meta%final ()
    call process%config%final ()
    if (allocated (process%component)) then
       do i = 1, size (process%component)
          call process%component(i)%final ()
       end do
    end if
    if (allocated (process%term)) then
       do i = 1, size (process%term)
          call process%term(i)%final ()
       end do
    end if
    call process%beam_config%final ()
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          call process%mci_entry(i)%final ()
       end do
    end if
  end subroutine process_final
    
@ %def process_final
@
\subsubsection{Process setup}
Initialize a process.  We need a process library, the name of the process,
and a run ID.  The model is imported via its pointer, and the original pointer
freed.
<<Processes: process: TBP>>=
  procedure :: init => process_init
<<Processes: procedures>>=
  subroutine process_init &
       (process, proc_id, run_id, lib, os_data, qcd, rng_factory, model)
    class(process_t), intent(out) :: process
    type(string_t), intent(in) :: proc_id
    type(string_t), intent(in) :: run_id
    type(process_library_t), intent(in), target :: lib
    type(os_data_t), intent(in) :: os_data
    type(qcd_t), intent(in) :: qcd
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    class(model_data_t), intent(inout), pointer :: model
    if (.not. lib%is_active ()) then
       call msg_bug ("Process init: inactive library not handled yet")
    end if
    if (.not. lib%contains (proc_id)) then
       call msg_fatal ("Process library doesn't contain process '" &
            // char (proc_id) // "'")
       return
    end if
    associate (meta => process%meta)
      call meta%init (proc_id, run_id, lib)
      call process%config%init (meta, os_data, qcd, rng_factory, model)
      allocate (process%component (meta%n_components))
    end associate
    if (.not. lib%get_nlo_process (proc_id)) then
       allocate (pcm_default_t :: process%pcm)
    else
       allocate (pcm_nlo_t :: process%pcm)
    end if
  end subroutine process_init
  
@ %def process_init
@ Store a snapshot of the common variable list.
<<Processes: process: TBP>>=
  procedure :: set_var_list => process_set_var_list
<<Processes: procedures>>=
  subroutine process_set_var_list (process, var_list)
    class(process_t), intent(inout) :: process
    type(var_list_t), intent(in) :: var_list
    call var_list_init_snapshot &
         (process%meta%var_list, var_list, follow_link=.true.)
  end subroutine process_set_var_list
  
@ %def process_set_var_list
@ Initialize the process components, one by one, using a template for
the process core object.  The template is taken only for allocating
the correct type; the contents are set by extracting the process entry
from the library.
<<Processes: process: TBP>>=
  procedure :: init_component => process_init_component
<<Processes: procedures>>=
  subroutine process_init_component &
       (process, index, core_template, mci_template, phs_config_template, &
        fks_template, blha_template)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: index
    class(prc_core_t), intent(in), allocatable :: core_template
    class(mci_t), intent(in), allocatable :: mci_template
    class(phs_config_t), intent(in), allocatable :: phs_config_template
    type(fks_template_t), intent(in), optional :: fks_template
    type(blha_template_t), intent(inout), optional :: blha_template
    call process%component(index)%init (index, &
         process%meta, process%config, &
         core_template, mci_template, phs_config_template, &
         blha_template, fks_template)
    if (.not. process%component(index)%active) then
       call process%meta%deactivate_component(index)
    end if
  end subroutine process_init_component

@ %def process_init_component
@ Determine the process terms for each process component. 
<<Processes: process: TBP>>=
  procedure :: setup_terms => process_setup_terms
<<Processes: procedures>>=
  subroutine process_setup_terms (process)
    class(process_t), intent(inout) :: process
    class(model_data_t), pointer :: model
    integer :: i, j, k
    integer, dimension(:), allocatable :: n_entry
    integer :: n_components, n_tot
    model => process%config%model
    n_components = process%meta%n_components
    allocate (n_entry (n_components), source = 0)
    do i = 1, n_components
       associate (component => process%component(i))
         if (component%active)  n_entry(i) = component%core%get_n_terms () 
       end associate
    end do
    n_tot = sum (n_entry)
    allocate (process%term (n_tot))
    k = 0
    do i = 1, n_components
       associate (component => process%component(i))
         if (.not. component%active)  cycle
         associate (core => component%core)
           allocate (component%i_term (n_entry(i)))
           do j = 1, n_entry(i)
              component%i_term(j) = k + j
              call process%term(k+j)%init (k+j, i, j, core, model)
           end do
         end associate
       end associate
       k = k + n_entry(i)
    end do
    process%config%n_terms = n_tot
  end subroutine process_setup_terms

@ %def process_setup_terms
@ Initialize the beam setup.  This is the trivial version where the
incoming state of the matrix element coincides with the initial state
of the process.  For a scattering process, we need the c.m. energy,
all other variables are set to their default values (no polarization,
lab frame and c.m.\ frame coincide, etc.)

We assume that all components consistently describe a scattering
process, i.e., two incoming particles.

Note: The current layout of the [[beam_data_t]] record requires that the
flavor for each beam is unique.  For processes with multiple
flavors in the initial state, one has to set up beams explicitly.
This restriction could be removed by extending the code in the
[[beams]] module.
<<Processes: process: TBP>>=
  procedure :: setup_beams_sqrts => process_setup_beams_sqrts
<<Processes: procedures>>=
  subroutine process_setup_beams_sqrts (process, sqrts, beam_structure)
    class(process_t), intent(inout) :: process
    real(default), intent(in) :: sqrts
    type(beam_structure_t), intent(in), optional :: beam_structure
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_in
    integer, dimension(2) :: pdg_scattering
    type(flavor_t), dimension(2) :: flv_in
    integer :: i, i0
    allocate (pdg_in (2, process%meta%n_components))
    i0 = 0
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
          if (i0 == 0)  i0 = i
       end if
    end do
    do i = 1, process%meta%n_components
       if (.not. process%component(i)%active) then
          pdg_in(:,i) = pdg_in(:,i0)
       end if
    end do
    if (all (pdg_array_get_length (pdg_in) == 1) .and. &
         all (pdg_in(1,:) == pdg_in(1,i0)) .and. &
         all (pdg_in(2,:) == pdg_in(2,i0))) then
       pdg_scattering = pdg_array_get (pdg_in(:,i0), 1)
       call flv_in%init (pdg_scattering, process%config%model)
       call process%beam_config%init_scattering (flv_in, sqrts, beam_structure)
    else
       call msg_fatal ("Setting up process '" // char (process%meta%id) // "':", &
           [var_str ("   --------------------------------------------"), &
            var_str ("Inconsistent initial state. This happens if either "), &
            var_str ("several processes with non-matching initial states "), &
            var_str ("have been added, or for a single process with an "), &
            var_str ("initial state flavor sum. In that case, please set beams "), &
            var_str ("explicitly [singling out a flavor / structure function.]")]) 
    end if
  end subroutine process_setup_beams_sqrts

@ %def process_setup_beams_sqrts
@ This is the version that applies to decay processes.  The energy is the
particle mass, hence no extra argument.
<<Processes: process: TBP>>=
  procedure :: setup_beams_decay => process_setup_beams_decay
<<Processes: procedures>>=
  subroutine process_setup_beams_decay (process, rest_frame, beam_structure)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: rest_frame
    type(beam_structure_t), intent(in), optional :: beam_structure
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_in
    integer, dimension(1) :: pdg_decay
    type(flavor_t), dimension(1) :: flv_in
    integer :: i, i0
    allocate (pdg_in (1, process%meta%n_components))
    i0 = 0
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
          if (i0 == 0)  i0 = i
       end if
    end do
    do i = 1, process%meta%n_components
       if (.not. process%component(i)%active) then
          pdg_in(:,i) = pdg_in(:,i0)
       end if
    end do
    if (all (pdg_array_get_length (pdg_in) == 1) &
         .and. all (pdg_in(1,:) == pdg_in(1,i0))) then
       pdg_decay = pdg_array_get (pdg_in(:,i0), 1)
       call flv_in%init (pdg_decay, process%config%model)
       call process%beam_config%init_decay (flv_in, rest_frame, beam_structure)
    else
       call msg_fatal ("Setting up decay '" &
            // char (process%meta%id) // "': decaying particle not unique")
    end if
  end subroutine process_setup_beams_decay
    
@ %def process_setup_beams_decay
@ We have to make sure that the masses of the various flavors
in a given position in the particle string coincide.
<<Processes: process: TBP>>=
  procedure :: check_masses => process_check_masses
<<Processes: procedures>>=
  subroutine process_check_masses (process)
       class(process_t), intent(in) :: process
       type(flavor_t), dimension(:), allocatable :: flv
       real(default), dimension(:), allocatable :: mass
       !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
       integer :: i, j, k
       do i = 1, process%meta%n_components
          if (.not. process%component(i)%active)  cycle
          associate (data => process%component(i)%core%data)
            allocate (flv (data%n_flv), mass (data%n_flv))
            do j = 1, data%n_in + data%n_out
               call flv%init (data%flv_state(j,:), process%config%model)
               !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
               do k = 1, data%n_flv
                  mass(k) = flv(k)%get_mass ()
               end do
               !!! mass = flv%get_mass ()
               if (any (.not. nearly_equal(mass, mass(1)))) then
                  call msg_fatal ("Process '" // char (process%meta%id) // "': " &
                       // "mass values in flavor combination do not coincide. ")
               end if
            end do
            deallocate (flv, mass)
          end associate
       end do
   end subroutine process_check_masses
  
@ %def process_check_masses
@ For some structure functions we need to get the list of initial
state flavors.  This is a two-dimensional array.  The first index is
the beam index, the second index is the component index.  Each array
element is itself a PDG array object, which consists of the list of
incoming PDG values for this beam and component.
<<Processes: process: TBP>>=
  procedure :: get_pdg_in => process_get_pdg_in
<<Processes: procedures>>=
  subroutine process_get_pdg_in (process, pdg_in)
    class(process_t), intent(in) :: process
    type(pdg_array_t), dimension(:,:), allocatable, intent(out) :: pdg_in
    integer :: i
    allocate (pdg_in (process%config%n_in, process%meta%n_components))
    do i = 1, process%meta%n_components
       if (process%component(i)%active) then
          pdg_in(:,i) = process%component(i)%get_pdg_in ()
       end if
    end do    
  end subroutine process_get_pdg_in
  
@ %def process_get_pdg_in
@ Initialize from a complete beam setup.
<<Processes: process: TBP>>=
  procedure :: setup_beams_beam_structure => process_setup_beams_beam_structure
<<Processes: procedures>>=
  subroutine process_setup_beams_beam_structure &
       (process, beam_structure, sqrts, decay_rest_frame)
    class(process_t), intent(inout) :: process
    type(beam_structure_t), intent(in) :: beam_structure
    real(default), intent(in) :: sqrts
    logical, intent(in), optional :: decay_rest_frame
    if (process%get_n_in () == beam_structure%get_n_beam ()) then
       call process%beam_config%init_beam_structure &
            (beam_structure, sqrts, process%get_model_ptr (), decay_rest_frame)
    else if (beam_structure%get_n_beam () == 0) then
       call msg_fatal ("Asymmetric beams: missing beam particle specification")
    else
       call msg_fatal ("Mismatch of process and beam setup (scattering/decay)")
    end if
  end subroutine process_setup_beams_beam_structure
  
@ %def process_setup_beams_beam_structure
@ Notify the user about beam setup.
<<Processes: process: TBP>>=
  procedure :: beams_startup_message => process_beams_startup_message
<<Processes: procedures>>=     
  subroutine process_beams_startup_message (process, unit, beam_structure)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: unit
    type(beam_structure_t), intent(in), optional :: beam_structure
    call process%beam_config%startup_message (unit, beam_structure)
  end subroutine process_beams_startup_message
  
@ %def process_beams_startup_message
@ We complete the kinematics configuration after the beam setup, but before we
configure the chain of structure functions.  The reason is that we need the
total energy [[sqrts]] for the kinematics, but the structure-function setup
requires the number of channels, which depends on the kinematics
configuration.  For instance, the kinematics module may return the need for
parameterizing an s-channel resonance.
<<Processes: process: TBP>>=
  procedure :: configure_phs => process_configure_phs
<<Processes: procedures>>=
  subroutine process_configure_phs (process, rebuild, ignore_mismatch, verbose, &
                                    combined_integration)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch, verbose
    logical, intent(in), optional :: combined_integration
    real(default) :: sqrts
    integer :: i, i_born
    class(phs_config_t), allocatable :: phs_config_born
    sqrts = process%get_sqrts ()
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
!!! Not yet active          
!             call process%pcm%configure_phs (component, &
!                  sqrts, process%beam_config, &
!                  rebuild, ignore_mismatch, verbose=verbose, &
!                  combined_integration = combined_integration
!!! Old version     
            select type (pcm => process%pcm)
            type is (pcm_default_t)
               call component%configure_phs (sqrts, process%beam_config, &
                    rebuild, ignore_mismatch, verbose=verbose)
            class is (pcm_nlo_t)
               select case (component%config%get_nlo_type ())
               case (BORN, NLO_VIRTUAL, NLO_SUBTRACTION)
                  call component%configure_phs (sqrts, process%beam_config, &
                       rebuild, ignore_mismatch, verbose=verbose)
                  call check_and_extend_phs (component, combined_integration)
               case (NLO_REAL, NLO_PDF)
                  i_born = component%config%get_associated_born ()
                  call check_and_extend_phs (component, combined_integration)
                  call process%component(i_born)%extract_phs_config (phs_config_born)
                  select type (phs_config_born)
                  type is (phs_wood_config_t)
                     call  component%configure_phs (sqrts, &
                          process%beam_config, rebuild, ignore_mismatch, &
                          phs_config_born, verbose=verbose)
                  end select
                  call process%component(i_born)%restore_phs_config (phs_config_born)
               end select
            class default
               call msg_bug ("process_configure_phs: unsupported PCM type")
            end select
         end if
       end associate
    end do
  contains
    subroutine check_and_extend_phs (component, combined_integration)
      type(process_component_t), intent(inout) :: component
      logical, intent(in), optional :: combined_integration
      if (present (combined_integration)) then
         if (combined_integration) then
            select type (phs_config => component%phs_config)
            type is (phs_wood_config_t)
               call phs_config%set_extended_phs ()
               call phs_config%increase_n_par ()
            type is (phs_fks_config_t)
               call phs_config%set_extended_phs ()
            end select
         end if
      end if
    end subroutine check_and_extend_phs
  end subroutine process_configure_phs
         
@ %def process_configure_phs
@ Insert the structure-function configuration data.  First allocate the
storage, then insert data one by one.  The third procedure declares a
mapping (of the MC input parameters) for a specific channel and
structure-function combination.

We take the number of channels from the corresponding entry in the
[[config_data]] section.

Otherwise, these a simple wrapper routines.  The extra level in the
call tree may allow for simple addressing of multiple concurrent beam
configurations, not implemented currently.

If we do not want structure functions, we simply do not call those procedures.
<<Processes: process: TBP>>=
  procedure :: init_sf_chain => process_init_sf_chain
  generic :: set_sf_channel => set_sf_channel_single
  procedure :: set_sf_channel_single => process_set_sf_channel
  generic :: set_sf_channel => set_sf_channel_array
  procedure :: set_sf_channel_array => process_set_sf_channel_array
<<Processes: procedures>>=
  subroutine process_init_sf_chain (process, sf_config, sf_trace_file)
    class(process_t), intent(inout) :: process
    type(sf_config_t), dimension(:), intent(in) :: sf_config
    type(string_t), intent(in), optional :: sf_trace_file
    type(string_t) :: file
    if (present (sf_trace_file)) then
       if (sf_trace_file /= "") then
          file = sf_trace_file
       else
          file = process%get_id () // "_sftrace.dat"
       end if
       call process%beam_config%init_sf_chain (sf_config, file)
    else
       call process%beam_config%init_sf_chain (sf_config)
    end if
  end subroutine process_init_sf_chain

  subroutine process_set_sf_channel (process, c, sf_channel)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: c
    type(sf_channel_t), intent(in) :: sf_channel
    call process%beam_config%set_sf_channel (c, sf_channel)
  end subroutine process_set_sf_channel
  
  subroutine process_set_sf_channel_array (process, sf_channel)
    class(process_t), intent(inout) :: process
    type(sf_channel_t), dimension(:), intent(in) :: sf_channel
    integer :: c
    call process%beam_config%allocate_sf_channels (size (sf_channel))
    do c = 1, size (sf_channel)
       call process%beam_config%set_sf_channel (c, sf_channel(c))
    end do
  end subroutine process_set_sf_channel_array
  
@ %def process_init_sf_chain
@ %def process_set_sf_channel
@ Notify about the structure-function setup.
<<Processes: process: TBP>>=
  procedure :: sf_startup_message => process_sf_startup_message
<<Processes: procedures>>=
  subroutine process_sf_startup_message (process, sf_string, unit)
    class(process_t), intent(in) :: process
    type(string_t), intent(in) :: sf_string
    integer, intent(in), optional :: unit
    call process%beam_config%sf_startup_message (sf_string, unit)
  end subroutine process_sf_startup_message
  
@ %def process_sf_startup_message
@ As soon as both the kinematics configuration and the
structure-function setup are complete, we match parameterizations
(channels) for both.  The matching entries are (re)set in the
[[component]] phase-space configuration, while the structure-function
configuration is left intact.
<<Processes: process: TBP>>=
  procedure :: collect_channels => process_collect_channels
<<Processes: procedures>>=
  subroutine process_collect_channels (process, coll)
    class(process_t), intent(inout) :: process
    type(phs_channel_collection_t), intent(inout) :: coll
    integer :: i
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
            call component%collect_channels (coll)
         end if
       end associate
    end do
  end subroutine process_collect_channels
         
@ %def process_collect_channels
@ Independently, we should be able to check if any component doesn't
contain phase-space parameters.  Such a process can only be integrated
if there are structure functions.
<<Processes: process: TBP>>=
  procedure :: contains_trivial_component => process_contains_trivial_component
<<Processes: procedures>>=
  function process_contains_trivial_component (process) result (flag)
    class(process_t), intent(in) :: process
    logical :: flag
    integer :: i
    flag = .true.
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
         if (component%active) then
            if (component%get_n_phs_par () == 0)  return
         end if
       end associate
    end do
    flag = .false.
  end function process_contains_trivial_component
  
@ %def process_contains_trivial_component
@
<<Processes: process: TBP>>=
  procedure :: deactivate_real_component => process_deactivate_real_component
<<Processes: procedures>>=
  subroutine process_deactivate_real_component (process)
    class(process_t), intent(inout) :: process
    integer :: i
    do i = 1, process%meta%n_components
       call process%mci_entry(1)%deactivate_real_component &
          (process%component(i))
       select case (process%component(i)%component_type)
       case (COMP_REAL)
          process%component(i)%active = .false.
       end select
    end do
  end subroutine process_deactivate_real_component

@ %def process_deactivate_real_component
@
<<Processes: process: TBP>>=
  procedure :: i_mci_to_i_component => process_i_mci_to_i_component
<<Processes: procedures>>=
  function process_i_mci_to_i_component (process, i_mci) result (i_component)
     integer :: i_component
     class(process_t), intent(in) :: process
     integer, intent(in) :: i_mci
     integer :: i
     i_component = 0
     do i = 1, size (process%component)
        if (process%component(i)%i_mci == i_mci) then
           i_component = i
           return
        end if
     end do
  end function process_i_mci_to_i_component


@ %def process_i_mci_to_i_component     
@ Determine the MC parameter set structure and the MCI configuration for each
process component.  We need data from the structure-function and phase-space
setup, so those should be complete before this is called.  We also
make a random-number generator instance for each MCI group.
<<Processes: process: TBP>>=
  procedure :: setup_mci => process_setup_mci
<<Processes: procedures>>=
  subroutine process_setup_mci (process, combined_integration)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: combined_integration
    integer :: n_mci, i_mci
    integer :: i
    logical :: powheg_damping_active
    n_mci = 0
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
          if (component%needs_mci_entry () .and. &
              component%config%get_nlo_type () /= NLO_SUBTRACTION) then
            n_mci = n_mci + 1
            component%i_mci = n_mci
         end if
       end associate
    end do
    process%config%n_mci = n_mci
    if (.not. allocated (process%config%rng_factory)) &
         call msg_bug ("Process setup: rng factory not allocated")
    allocate (process%mci_entry (n_mci))
    i_mci = 0
    powheg_damping_active = &
        any (process%component%component_type == COMP_REAL_SING)
    do i = 1, process%meta%n_components
       associate (component => process%component(i))
          if (component%needs_mci_entry () .and. &
              component%config%get_nlo_type () /= NLO_SUBTRACTION) then
            i_mci = i_mci + 1
            associate (mci_entry => process%mci_entry(i_mci))
              call mci_entry%set_combined_integration (combined_integration)
              if (powheg_damping_active) then
                 if (component%component_type == COMP_REAL_FIN) then
                    mci_entry%powheg_damping_type = DAMPING_FINITE
                 else
                    mci_entry%powheg_damping_type = DAMPING_SINGULAR
                 end if
              end if

              call mci_entry%init (process%meta%type, &
                   i_mci, i, component, process%beam_config, &
                   process%config%rng_factory)
              call process%set_associated_real_component (i_mci, i)
            end associate
          end if
       end associate
    end do
    do i_mci = 1, size (process%mci_entry)
       call process%mci_entry(i_mci)%set_parameters (process%meta%var_list)
    end do
  end subroutine process_setup_mci
  
@ %def process_setup_mci
@ Set cuts.  This is a parse node, namely the right-hand side of the [[cut]]
assignment.  When creating an instance, we compile this into an evaluation
tree.  The parse node may be null.
<<Processes: process: TBP>>=
  procedure :: set_cuts => process_set_cuts
<<Processes: procedures>>=
  subroutine process_set_cuts (process, ef_cuts)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_cuts
    allocate (process%config%ef_cuts, source = ef_cuts)
  end subroutine process_set_cuts
  
@ %def process_set_cuts
@ Analogously for the other expressions.
<<Processes: process: TBP>>=
  procedure :: set_scale => process_set_scale
  procedure :: set_fac_scale => process_set_fac_scale
  procedure :: set_ren_scale => process_set_ren_scale
  procedure :: set_weight => process_set_weight
<<Processes: procedures>>=
  subroutine process_set_scale (process, ef_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_scale
    allocate (process%config%ef_scale, source = ef_scale)
  end subroutine process_set_scale
  
  subroutine process_set_fac_scale (process, ef_fac_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_fac_scale
    allocate (process%config%ef_fac_scale, source = ef_fac_scale)
  end subroutine process_set_fac_scale
  
  subroutine process_set_ren_scale (process, ef_ren_scale)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_ren_scale
    allocate (process%config%ef_ren_scale, source = ef_ren_scale)
  end subroutine process_set_ren_scale
  
  subroutine process_set_weight (process, ef_weight)
    class(process_t), intent(inout) :: process
    class(expr_factory_t), intent(in) :: ef_weight
    allocate (process%config%ef_weight, source = ef_weight)
  end subroutine process_set_weight
  
@ %def process_set_scale
@ %def process_set_fac_scale
@ %def process_set_ren_scale
@ %def process_set_weight
@
\subsubsection{MD5 sum}
The MD5 sum of the process object should reflect the state completely,
including integration results.  It is used for checking the integrity
of event files.  This global checksum includes checksums for the
various parts.  In particular, the MCI object receives a checksum that
includes the configuration of all configuration parts relevant for an
individual integration.  This checksum is used for checking the
integrity of integration grids.

We do not need MD5 sums for the process terms, since these are
generated from the component definitions.
<<Processes: process: TBP>>=
  procedure :: compute_md5sum => process_compute_md5sum
<<Processes: procedures>>=
  subroutine process_compute_md5sum (process)
    class(process_t), intent(inout) :: process
    integer :: i
    call process%config%compute_md5sum ()
    do i = 1, process%config%n_components
       associate (component => process%component(i))
         if (component%active) then
            call component%compute_md5sum ()
         end if
       end associate
    end do
    call process%beam_config%compute_md5sum ()
    do i = 1, process%config%n_mci
       call process%mci_entry(i)%compute_md5sum &
            (process%config, process%component, process%beam_config)
    end do
  end subroutine process_compute_md5sum
  
@ %def process_compute_md5sum
@
\subsubsection{Integration and event generation}
The sampler test should just evaluate the squared matrix element [[n_calls]]
times, discarding the results, and return.  This can be done before
integration, e.g., for timing estimates.
<<Processes: process: TBP>>=
  procedure :: sampler_test => process_sampler_test
<<Processes: procedures>>=
  subroutine process_sampler_test (process, instance, i_mci, n_calls)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout), target :: instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: n_calls
    call process%mci_entry(i_mci)%sampler_test (instance, n_calls)
  end subroutine process_sampler_test

@ %def process_sampler_test
@ Integrate the process, using a previously initialized process
instance.  We select one of the available MCI integrators by its index
[[i_mci]] and thus integrate over (structure functions and) phase
space for the associated (group of) process component(s).

The finalizer should be called after all integration passes have been
completed.  It will, for instance, write a summary of the integration
results.

[[integrate_dummy]] does a ``dummy'' integration in the sense that
nothing is done but just empty integration results appended.
<<Processes: process: TBP>>=
  procedure :: integrate => process_integrate
  procedure :: final_integration => process_final_integration
  procedure :: integrate_dummy => process_integrate_dummy
<<Processes: procedures>>=
  subroutine process_integrate (process, instance, i_mci, n_it, n_calls, &
       adapt_grids, adapt_weights, final, pacify)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    logical, intent(in), optional :: adapt_grids
    logical, intent(in), optional :: adapt_weights
    logical, intent(in), optional :: final, pacify
    call process%mci_entry(i_mci)%integrate (instance, n_it, n_calls, &
         adapt_grids, adapt_weights, final, pacify, i_mci)        
    call instance%display_real_kinematics (i_mci)
  end subroutine process_integrate

  subroutine process_final_integration (process, i_mci)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%final_integration ()
  end subroutine process_final_integration
  
  subroutine process_integrate_dummy (process)
    class(process_t), intent(inout) :: process
    type(integration_results_t) :: results
    integer :: u_log
    u_log = logfile_unit ()
    call results%init (process%meta%type)
    call results%display_init (process%meta%type, screen = .true., unit = u_log)
    call results%new_pass ()
    call results%record (1, 0, 0._default, 0._default, 0._default)
    call results%display_final ()
  end subroutine process_integrate_dummy
  
@ %def process_integrate
@ %def process_final_integration
@ %def process_integrate_dummy
@ Display the final results for the sum of all components.  (This is useful,
obviously, only if there is more than one component.)
<<Processes: process: TBP>>=
  procedure :: display_summed_results => process_display_summed_results
<<Processes: procedures>>=
  subroutine process_display_summed_results (process)
    class(process_t), intent(inout) :: process
    type(integration_results_t) :: results
    integer :: u_log
    u_log = logfile_unit ()
    call results%init (process%meta%type)
    call results%display_init (process%meta%type, screen = .true., unit = u_log)
    call results%new_pass ()
    call results%record (1, 0, &
         process%get_integral (), &
         process%get_error (), &
         process%get_efficiency ())
    select type (pcm => process%pcm)
    class is (pcm_nlo_t)
       if (.not. process%uses_powheg_damping_factors()) then
          call results%record_correction (process%get_correction (), &
               process%get_correction_error ())
       end if
    end select
    call results%display_final ()
  end subroutine process_display_summed_results

@ %def process_display_summed_results
@ Run LaTeX/Metapost to generate a ps/pdf file for the integration
history.  We (re)write the driver file -- just in case it has been
missed before -- then we compile it.
<<Processes: process: TBP>>=
  procedure :: display_integration_history => &
       process_display_integration_history
<<Processes: procedures>>=
  subroutine process_display_integration_history &
       (process, i_mci, filename, os_data, eff_reset)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    type(string_t), intent(in) :: filename
    type(os_data_t), intent(in) :: os_data
    logical, intent(in), optional :: eff_reset
    call integration_results_write_driver &
         (process%mci_entry(i_mci)%results, filename, eff_reset)
    call integration_results_compile_driver &
         (process%mci_entry(i_mci)%results, filename, os_data)
  end subroutine process_display_integration_history

@ %def subroutine process_display_integration_history
@ Write a complete logfile (with hardcoded name based on the process ID).
We do not write internal data.
<<Processes: process: TBP>>=
  procedure :: write_logfile => process_write_logfile
<<Processes: procedures>>=
  subroutine process_write_logfile (process, i_mci, filename)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    type(string_t), intent(in) :: filename    
    type(time_t) :: time
    integer :: unit, u
    unit = free_unit ()
    open (unit = unit, file = char (filename), action = "write", &
          status = "replace")
    u = given_output_unit (unit)
    write (u, "(A)")  repeat ("#", 79)
    call process%meta%write (u, .false., .false.)
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(3x,A,ES17.10)")  "Integral   = ", &
         process%mci_entry(i_mci)%get_integral ()
    write (u, "(3x,A,ES17.10)")  "Error      = ", &
         process%mci_entry(i_mci)%get_error ()
    write (u, "(3x,A,ES17.10)")  "Accuracy   = ", &
         process%mci_entry(i_mci)%get_accuracy ()
    write (u, "(3x,A,ES17.10)")  "Chi2       = ", &
         process%mci_entry(i_mci)%get_chi2 ()
    write (u, "(3x,A,ES17.10)")  "Efficiency = ", &
         process%mci_entry(i_mci)%get_efficiency ()
    call process%mci_entry(i_mci)%get_time (time, 10000)
    if (time%is_known ()) then
       write (u, "(3x,A,1x,A)")  "T(10k evt) = ", char (time%to_string_dhms ())
    else
       write (u, "(3x,A)")  "T(10k evt) =  [undefined]"
    end if
    call process%mci_entry(i_mci)%results%write (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%mci_entry(i_mci)%results%write_chain_weights (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%mci_entry(i_mci)%counter%write (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%mci_entry(i_mci)%mci%write_log_entry (u)
    write (u, "(A)")  repeat ("#", 79)
    call process%beam_config%data%write (u)
    write (u, "(A)")  repeat ("#", 79)
    if (allocated (process%config%ef_cuts)) then
       write (u, "(3x,A)") "Cut expression:"
       call process%config%ef_cuts%write (u)
    else
       write (u, "(3x,A)") "No cuts used."         
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_scale)) then
       write (u, "(3x,A)") "Scale expression:"
       call process%config%ef_scale%write (u)
    else
       write (u, "(3x,A)") "No scale expression was given."
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_fac_scale)) then
       write (u, "(3x,A)") "Factorization scale expression:"
       call process%config%ef_fac_scale%write (u)
    else
       write (u, "(3x,A)") "No factorization scale expression was given."       
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_ren_scale)) then
       write (u, "(3x,A)") "Renormalization scale expression:"
       call process%config%ef_ren_scale%write (u)
    else
       write (u, "(3x,A)") "No renormalization scale expression was given."
    end if
    call write_separator (u)           
    if (allocated (process%config%ef_weight)) then
       call write_separator (u)
       write (u, "(3x,A)") "Weight expression:"
       call process%config%ef_weight%write (u)
    else
       write (u, "(3x,A)") "No weight expression was given."
    end if
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(1x,A)") "Summary of quantum-number states:" 
    write (u, "(1x,A)")  " + sign: allowed and contributing"
    write (u, "(1x,A)")  " no +  : switched off at runtime"
    call process%write_state_summary (u)
    write (u, "(A)")  repeat ("#", 79)
    write (u, "(A)")  "Variable list:"
    call var_list_write (process%meta%var_list, u)
    write (u, "(A)")  repeat ("#", 79)
    close (u)
  end subroutine process_write_logfile

@ %def process_write_logfile
@ Display the quantum-number combinations of the process components, and their
current status (allowed or switched off).
<<Processes: process: TBP>>=
  procedure :: write_state_summary => process_write_state_summary
<<Processes: procedures>>=
  subroutine process_write_state_summary (process, unit)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: unit
    integer :: i, i_component, u
    u = given_output_unit (unit)
    do i = 1, size (process%term)
       call write_separator (u)
       i_component = process%term(i)%i_component
       if (i_component /= 0) then
          call process%term(i)%write_state_summary &
               (process%component(i_component)%core, unit)
       end if
    end do
  end subroutine process_write_state_summary
       
@ %def process_write_state_summary
@ Prepare event generation for the specified MCI entry.  This implies, in
particular, checking the phase-space file.
<<Processes: process: TBP>>=
  procedure :: prepare_simulation => process_prepare_simulation
<<Processes: procedures>>=
  subroutine process_prepare_simulation (process, i_mci)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%prepare_simulation ()
  end subroutine process_prepare_simulation

@ %def process_prepare_simulation
@ 
Generate a weighted event.  We select one of the available MCI
integrators by its index [[i_mci]] and thus generate an event for the
associated (group of) process component(s).  The arguments exactly
correspond to the initializer and finalizer above.

The resulting event is stored in the [[process_instance]] object,
which also holds the workspace of the integrator.

Note: The [[process]] object is declared [[intent(inout)]] because it
contains the random-number state, which changes for each event.
Otherwise, all volatile data are inside the [[instance]] object.
<<Processes: process: TBP>>=
  procedure :: generate_weighted_event => process_generate_weighted_event
  procedure :: generate_unweighted_event => process_generate_unweighted_event
<<Processes: procedures>>=
  subroutine process_generate_weighted_event (process, instance, i_mci)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%generate_weighted_event (instance)
  end subroutine process_generate_weighted_event

  subroutine process_generate_unweighted_event (process, instance, i_mci)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call process%mci_entry(i_mci)%generate_unweighted_event (instance)
  end subroutine process_generate_unweighted_event

@ %def process_generate_weighted_event
@ %def process_generate_unweighted_event
@ 
This replaces the event generation methods for the situation that the
process instance object has been filled by other means (i.e., reading
and/or recalculating its contents).  We just have to fill in missing
MCI data, especially the event weight.
<<Processes: process: TBP>>=
  procedure :: recover_event => process_recover_event
<<Processes: procedures>>=
  subroutine process_recover_event (process, instance, i_term)
    class(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    call process%mci_entry(instance%i_mci)%recover_event (instance, i_term)
  end subroutine process_recover_event

@ %def process_recover_event
@
\subsubsection{Retrieve process data}
Tell whether integral (and error) are known.
<<Processes: process: TBP>>=
  generic :: has_integral => has_integral_tot, has_integral_mci
  procedure :: has_integral_tot => process_has_integral_tot
  procedure :: has_integral_mci => process_has_integral_mci
<<Processes: procedures>>=
  function process_has_integral_mci (process, i_mci) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    logical :: flag
    flag = process%mci_entry(i_mci)%has_integral ()
  end function process_has_integral_mci

  function process_has_integral_tot (process) result (flag)
    class(process_t), intent(in) :: process
    logical :: flag
    integer :: i
    flag = .true.
    do i = 1, size (process%mci_entry)
       if (process%is_active_nlo_component (i)) &
          flag = flag .and. process%mci_entry(i)%has_integral ()
    end do
  end function process_has_integral_tot
  
@ %def process_has_integral 
@
Return the current integral and error obtained by the integrator [[i_mci]].
<<Processes: process: TBP>>=
  generic :: get_integral => get_integral_tot, get_integral_mci
  generic :: get_error => get_error_tot, get_error_mci
  generic :: get_efficiency => get_efficiency_tot, get_efficiency_mci
  procedure :: get_integral_tot => process_get_integral_tot
  procedure :: get_integral_mci => process_get_integral_mci
  procedure :: get_error_tot => process_get_error_tot
  procedure :: get_error_mci => process_get_error_mci
  procedure :: get_efficiency_tot => process_get_efficiency_tot
  procedure :: get_efficiency_mci => process_get_efficiency_mci
<<Processes: procedures>>=
  function process_get_integral_mci (process, i_mci) result (integral)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: integral
    integral = process%mci_entry(i_mci)%get_integral ()
  end function process_get_integral_mci
  
  function process_get_error_mci (process, i_mci) result (error)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: error
    error = process%mci_entry(i_mci)%get_error ()
  end function process_get_error_mci
  
  function process_get_efficiency_mci (process, i_mci) result (efficiency)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    real(default) :: efficiency
    efficiency = process%mci_entry(i_mci)%get_efficiency ()
  end function process_get_efficiency_mci
  
  function process_get_integral_tot (process) result (integral)
    class(process_t), intent(in) :: process
    real(default) :: integral
    integer :: i
    integral = 0
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          if (process%is_active_nlo_component(i)) &
               integral = integral + process%mci_entry(i)%get_integral ()
       end do
    end if
  end function process_get_integral_tot
  
  function process_get_error_tot (process) result (error)
    class(process_t), intent(in) :: process
    real(default) :: error
    real(default) :: variance
    integer :: i
    variance = 0
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          if (process%is_active_nlo_component(i)) &
               variance = variance + process%mci_entry(i)%get_error () ** 2
       end do
    end if
    error = sqrt (variance)
  end function process_get_error_tot
  
  function process_get_efficiency_tot (process) result (efficiency)
    class(process_t), intent(in) :: process
    real(default) :: efficiency
    real(default) :: den, eff, int
    integer :: i
    den = 0
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          if (process%is_active_nlo_component(i)) then
             int = process%get_integral (i)
             if (int > 0) then
                eff = process%mci_entry(i)%get_efficiency ()
                if (eff > 0) then
                   den = den + int / eff
                else
                   efficiency = 0
                   return
                end if
             end if
          end if
       end do
    end if
    if (den > 0) then
       efficiency = process%get_integral () / den
    else
       efficiency = 0
    end if
  end function process_get_efficiency_tot
  
@ %def process_get_integral process_get_efficiency
<<Processes: process: TBP>>=
  procedure :: get_correction => process_get_correction
  procedure :: get_correction_error => process_get_correction_error
<<Processes: procedures>>=
  function process_get_correction (process) result (ratio)
    class(process_t), intent(in) :: process
    real(default) :: ratio
    real(default) :: int_real, int_virt, int_born
    int_born = process%mci_entry(1)%get_integral ()
    int_real = process%mci_entry(2)%get_integral ()
    int_virt = process%mci_entry(3)%get_integral ()
    ratio = (int_real + int_virt) / int_born
  end function process_get_correction

  function process_get_correction_error (process) result (error)
    class(process_t), intent(in) :: process
    real(default) :: error
    real(default) :: int_born, int_real, int_virt
    real(default) :: err_born, err_real, err_virt
    real(default) :: err2
    int_born = process%mci_entry(1)%get_integral ()
    int_real = process%mci_entry(2)%get_integral ()
    int_virt = process%mci_entry(3)%get_integral ()
    err_born = process%mci_entry(1)%get_error ()
    err_real = process%mci_entry(2)%get_error ()
    err_virt = process%mci_entry(3)%get_error ()
    err2 = (int_real + int_virt)**2 / int_born**4 * err_born**2 &
             + (err_real**2 + err_virt**2) / int_born**2
    error = sqrt (err2)
  end function process_get_correction_error

@ %def process_get_correction process_get_correction_error
@
<<Processes: process: TBP>>=
  procedure :: component_reset_helicity => process_component_reset_helicity
<<Processes: procedures>>=
  subroutine process_component_reset_helicity(proc, i)
    class(process_t), intent(inout) :: proc
    integer, intent(in) :: i
    select type (core => proc%component(i)%core)
      type is (prc_omega_t)
        call core%reset_helicity_selection ()
    end select
    if (i == 2) then
      select type (core_sub_born => proc%component(i)%core_sub_born)
      type is (prc_omega_t)
         call core_sub_born%reset_helicity_selection ()
      end select
    end if
  end subroutine process_component_reset_helicity

@ %def process_component_reset_helicity
@
<<Processes: process: TBP>>=
  procedure :: is_nlo_calculation => process_is_nlo_calculation
<<Processes: procedures>>=
  function process_is_nlo_calculation (process) result (nlo)
    class(process_t), intent(in) :: process
    logical :: nlo
    select type (pcm => process%pcm)
    class is (pcm_nlo_t)
       nlo = .true.
    class default
       nlo = .false.
    end select
  end function process_is_nlo_calculation

@ %def process_is_nlo_calculation
@ Return nlo data of a process component
<<Processes: process: TBP>>=
  procedure :: get_component_nlo_type => process_get_component_nlo_type
<<Processes: procedures>>=
  function process_get_component_nlo_type (process, i_component) &
           result (nlo_type)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    integer :: nlo_type
    nlo_type = process%component(i_component)%config%get_nlo_type ()
  end function process_get_component_nlo_type

<<Processes: process: TBP>>=
  procedure :: get_component_associated_born &
            => process_get_component_associated_born
<<Processes: procedures>>=
  function process_get_component_associated_born (process, i_component) &
           result (i_born)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    integer :: i_born
    i_born = process%component(i_component)%config%get_associated_born ()
  end function process_get_component_associated_born

@ %def process_get_component_associated_born
@
<<Processes: process: TBP>>=
  procedure :: get_n_allowed_born => process_get_n_allowed_born
<<Processes: procedures>>=
  function process_get_n_allowed_born (process, i_born) result (n_born)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_born
    integer :: n_born
    n_born = process%term(i_born)%n_allowed

  end function process_get_n_allowed_born

@ %def process_get_n_allowed_born
@ 
<<Processes: process: TBP>>=
  procedure :: is_active_nlo_component => process_is_active_nlo_component 
<<Processes: procedures>>=
  function process_is_active_nlo_component (process, i_component) &
           result (active)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    logical :: active
    associate (component => process%component(i_component))
       active = component%config%is_active_nlo_component () &
                .and. component%component_type <= COMP_MASTER
    end associate
  end function process_is_active_nlo_component

@ %def process_get_component_nlo_type, process_get_component_associated_born
@ %def process_is_active_nlo_component
@
<<Processes: process: TBP>>=
  procedure :: uses_powheg_damping_factors => process_uses_powheg_damping_factors
<<Processes: procedures>>=
  function process_uses_powheg_damping_factors (process) result (val)
     logical :: val
     class(process_t), intent(in) :: process
     val = any (process%mci_entry%powheg_damping_type /= DAMPING_NONE)
  end function process_uses_powheg_damping_factors

@ %def process_uses_powheg_damping_factors 
@ Return the MD5 sums that summarize the process component
definitions.  These values should be independent of parameters, beam
details, expressions, etc.  They can be used for checking the
integrity of a process when reusing an old event file.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_prc => process_get_md5sum_prc
<<Processes: procedures>>=
  function process_get_md5sum_prc (process, i_component) result (md5sum)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    character(32) :: md5sum
    if (process%component(i_component)%active) then
       md5sum = process%component(i_component)%config%get_md5sum ()
    else
       md5sum = ""
    end if
  end function process_get_md5sum_prc
    
@ %def process_get_md5sum_prc
@ Return the MD5 sums that summarize the state of the MCI integrators.
These values should encode all process data, integration and phase
space configuration, etc., and the integration results.  They can thus
be used for checking the integrity of an event-generation setup when
reusing an old event file.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_mci => process_get_md5sum_mci
<<Processes: procedures>>=
  function process_get_md5sum_mci (process, i_mci) result (md5sum)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    character(32) :: md5sum
    md5sum = process%mci_entry(i_mci)%get_md5sum ()
  end function process_get_md5sum_mci
    
@ %def process_get_md5sum_mci
@ Return the MD5 sum of the process configuration.  This should encode
the process setup, data, and expressions, but no integration results.
<<Processes: process: TBP>>=
  procedure :: get_md5sum_cfg => process_get_md5sum_cfg
<<Processes: procedures>>=
  function process_get_md5sum_cfg (process) result (md5sum)
    class(process_t), intent(in) :: process
    character(32) :: md5sum
    md5sum = process%config%md5sum
  end function process_get_md5sum_cfg

@ %def process_get_md5sum_cfg
@ 
\subsection{Metadata}
This information describes the process and its environment.  It is
fixed upon initialization.

The [[id]] string is the name of the process object, as given by the
user.  The matrix element generator will use this string for naming
Fortran procedures and types, so it should qualify as a Fortran name.

The [[num_id]] is meaningful if nonzero.  It is used for communication
with external programs or file standards which do not support string IDs.

The [[run_id]] string distinguishes among several runs for the same
process.  It identifies process instances with respect to adapted
integration grids and similar run-specific data.  The run ID is kept
when copying processes for creating instances, however, so it does not
distinguish event samples. 

The [[var_list]] is a snapshot of the variable list, taken at the
point where the process was initialized.

The [[lib]] pointer accesses the process library where the process
definition and the process driver are located.

The [[lib_index]] is the index of entry in the process library that
corresponds to the current process.

The [[component_id]] array identifies the individual process components.

The [[component_description]] is an array of human-readable strings
that characterize the process components, for instance [[a, b => c, d]].

The [[active]] mask array marks those components which are active.  The others
are skipped.
<<Processes: process part types>>=
  type :: process_metadata_t
     private
     integer :: type = PRC_UNKNOWN
     type(string_t) :: id
     integer :: num_id = 0
     type(string_t) :: run_id
     type(var_list_t) :: var_list
     type(process_library_t), pointer :: lib => null ()
     integer :: lib_index = 0
     integer :: n_components = 0
     type(string_t), dimension(:), allocatable :: component_id
     type(string_t), dimension(:), allocatable :: component_description
     logical, dimension(:), allocatable :: active
   contains
   <<Processes: process metadata: TBP>>
  end type process_metadata_t

@ %def process_metadata_t
@ The local var list is a snapshot and needs a finalizer.
<<Processes: process metadata: TBP>>=
  procedure :: final => process_metadata_final
<<Processes: procedures>>=
  subroutine process_metadata_final (meta)
    class(process_metadata_t), intent(inout) :: meta
    call meta%var_list%final (follow_link=.true.)
  end subroutine process_metadata_final
  
@ %def process_metadata_final
@ Output: ID and run ID.
We write the variable list only upon request.
<<Processes: process metadata: TBP>>=
  procedure :: write => process_metadata_write
<<Processes: procedures>>=
  subroutine process_metadata_write (meta, u, var_list, screen)
    class(process_metadata_t), intent(in) :: meta
    integer, intent(in) :: u
    logical, intent(in) :: var_list, screen    
    integer :: i
    select case (meta%type)
    case (PRC_UNKNOWN)
       if (screen) then
          write (msg_buffer, "(A)") "Process [undefined]"
       else
          write (u, "(1x,A)") "Process [undefined]"
       end if
       return
    case (PRC_DECAY)
       if (screen) then
          write (msg_buffer, "(A,1x,A,A,A)") "Process [decay]:", & 
               "'", char (meta%id), "'"
       else
          write (u, "(1x,A)", advance="no") "Process [decay]:"
       end if
    case (PRC_SCATTERING)
       if (screen) then
          write (msg_buffer, "(A,1x,A,A,A)") "Process [scattering]:", &
               "'", char (meta%id), "'"
       else
          write (u, "(1x,A)", advance="no") "Process [scattering]:"
       end if
    case default
       call msg_bug ("process_write: undefined process type")
    end select    
    if (screen)  then
       call msg_message ()
    else
       write (u, "(1x,A,A,A)") "'", char (meta%id), "'"
    end if
    if (meta%num_id /= 0) then
       if (screen) then
          write (msg_buffer, "(2x,A,I0)") "ID (num)      = ", meta%num_id
          call msg_message ()
       else
          write (u, "(3x,A,I0)") "ID (num)      = ", meta%num_id            
       end if
    end if
    if (screen) then
       if (meta%run_id /= "") then
          write (msg_buffer, "(2x,A,A,A)") "Run ID        = '", &
               char (meta%run_id), "'"
          call msg_message ()
       end if
    else
       write (u, "(3x,A,A,A)") "Run ID        = '", char (meta%run_id), "'"       
    end if
    if (associated (meta%lib)) then
       if (screen) then
          write (msg_buffer, "(2x,A,A,A)")  "Library name  = '", &
               char (meta%lib%get_name ()), "'"
          call msg_message ()
       else          
          write (u, "(3x,A,A,A)")  "Library name  = '", &
               char (meta%lib%get_name ()), "'"          
       end if
    else
       if (screen) then
          write (msg_buffer, "(2x,A)")  "Library name  = [not associated]"
          call msg_message ()
       else
          write (u, "(3x,A)")  "Library name  = [not associated]"
       end if
    end if
    if (screen) then
       write (msg_buffer, "(2x,A,I0)")  "Process index = ", meta%lib_index
       call msg_message ()
    else
       write (u, "(3x,A,I0)")  "Process index = ", meta%lib_index
    end if
    if (allocated (meta%component_id)) then
       if (screen) then
          if (any (meta%active)) then
             write (msg_buffer, "(2x,A)")  "Process components:"
          else
             write (msg_buffer, "(2x,A)")  "Process components: [none]"
          end if
          call msg_message ()
       else
          write (u, "(3x,A)")  "Process components:"
       end if
       do i = 1, size (meta%component_id)
          if (.not. meta%active(i))  cycle
          if (screen) then
             write (msg_buffer, "(4x,I0,9A)")  i, ": '", &
                  char (meta%component_id (i)), "':   ", &
                  char (meta%component_description (i))
             call msg_message ()
          else
             write (u, "(5x,I0,9A)")  i, ": '", &
                  char (meta%component_id (i)), "':   ", &
                  char (meta%component_description (i))             
          end if
       end do
    end if
    if (screen) then
       write (msg_buffer, "(A)")  repeat ("-", 72)
       call msg_message ()
    else
       call write_separator (u)       
    end if
    if (screen)  return
    if (var_list) then
       write (u, "(1x,A)")  "Variable list:"
       call write_separator (u)
       call var_list_write (meta%var_list, u)
    else
       write (u, "(1x,A)")  "Variable list: [not shown]"
    end if
  end subroutine process_metadata_write

@ %def process_metadata_write 
@ Short output: list components.
<<Processes: process metadata: TBP>>=
  procedure :: show => process_metadata_show
<<Processes: procedures>>=
  subroutine process_metadata_show (meta, u, model_name)
    class(process_metadata_t), intent(in) :: meta
    integer, intent(in) :: u
    type(string_t), intent(in) :: model_name
    integer :: i
    select case (meta%type)
    case (PRC_UNKNOWN)
       write (u, "(A)") "Process: [undefined]"
       return
    case default
       write (u, "(A)", advance="no") "Process:"
    end select
    write (u, "(1x,A)", advance="no") char (meta%id)
    select case (meta%num_id)
    case (0)
    case default
       write (u, "(1x,'(',I0,')')", advance="no") meta%num_id
    end select
    select case (char (model_name))
    case ("")
    case default
       write (u, "(1x,'[',A,']')", advance="no")  char (model_name)
    end select
    write (u, *)
    if (allocated (meta%component_id)) then
       do i = 1, size (meta%component_id)
          if (meta%active(i)) then
             write (u, "(2x,I0,':',1x,A)")  i, &
                  char (meta%component_description (i))
          end if
       end do
    end if
  end subroutine process_metadata_show

@ %def process_metadata_show 
@ Initialize.
<<Processes: process metadata: TBP>>=
  procedure :: init => process_metadata_init
<<Processes: procedures>>=
  subroutine process_metadata_init (meta, id, run_id, lib)
    class(process_metadata_t), intent(out) :: meta
    type(string_t), intent(in) :: id
    type(string_t), intent(in) :: run_id
    type(process_library_t), intent(in), target :: lib
    select case (lib%get_n_in (id))
    case (1);  meta%type = PRC_DECAY
    case (2);  meta%type = PRC_SCATTERING
    case default
       call msg_bug ("Process '" // char (id) // "': impossible n_in")
    end select
    meta%id = id
    meta%run_id = run_id
    meta%lib => lib
    meta%lib_index = lib%get_entry_index (id)
    meta%num_id = lib%get_num_id (id)
    call lib%get_component_list (id, meta%component_id)
    meta%n_components = size (meta%component_id)
    call lib%get_component_description_list (id, meta%component_description)
    allocate (meta%active (meta%n_components), source = .true.)
  end subroutine process_metadata_init
  
@ %def process_metadata_init
@ Mark a component as inactive.
<<Processes: process metadata: TBP>>=
  procedure :: deactivate_component => process_metadata_deactivate_component
<<Processes: procedures>>=
  subroutine process_metadata_deactivate_component (meta, i)
    class(process_metadata_t), intent(inout) :: meta
    integer, intent(in) :: i
    call msg_message ("Process component '" &
         // char (meta%component_id(i)) // "': matrix element vanishes")
    meta%active(i) = .false.
  end subroutine process_metadata_deactivate_component
  
@ %def process_metadata_deactivate_component
@
\subsection{Generic Configuration Data}
This information concerns physical and technical properties of the
process.  It is fixed upon initialization, using data from the
process specification and the variable list.

The number [[n_in]] is the number of incoming beam particles,
simultaneously the number of incoming partons, 1 for a decay and 2 for
a scattering process. (The number of outgoing partons may depend on
the process component.)

The number [[n_components]] is the number of components that constitute
the current process.

The number [[n_terms]] is the number of distinct contributions to the
scattering matrix that constitute the current process.  Each component
may generate several terms.

The number [[n_mci]] is the number of independent MC
integration configurations that this process uses.  Distinct process
components that share a MCI configuration may be combined pointwise.
(Nevertheless, a given MC variable set may correspond to several
``nearby'' kinematical configurations.)  This is also the number of
distinct sampling-function results that this process can generate.
Process components that use distinct variable sets are added only once
after an integration pass has completed.

The [[model]] pointer identifies the physics model and its
parameters.  This is a pointer to an external object.

The [[rng_factory]] component spawns independent random-number generators for
use in integration, event generation, and event postprocessing.

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions for evaluating cuts and scales.  The
workspaces for evaluating those expressions are set up in the
[[effective_state]] subobjects.  Note that these are really pointers,
so the actual nodes are not stored inside the process object.

The [[md5sum]] is taken and used to verify the process configuration
when re-reading data from file.
<<Processes: process part types>>=
  type :: process_config_data_t
     private
     integer :: n_in = 0
     integer :: n_components = 0
     integer :: n_terms = 0
     integer :: n_mci = 0
     type(os_data_t) :: os_data
     class(rng_factory_t), allocatable :: rng_factory
     type(string_t) :: model_name
     class(model_data_t), pointer :: model => null ()
     type(qcd_t) :: qcd
     class(expr_factory_t), allocatable :: ef_cuts
     class(expr_factory_t), allocatable :: ef_scale
     class(expr_factory_t), allocatable :: ef_fac_scale
     class(expr_factory_t), allocatable :: ef_ren_scale
     class(expr_factory_t), allocatable :: ef_weight
     character(32) :: md5sum = ""
   contains
   <<Processes: process config data: TBP>>
  end type process_config_data_t

@ %def process_config_data_t
@ Here, we may compress the expressions for cuts etc.
<<Processes: process config data: TBP>>=
  procedure :: write => process_config_data_write
<<Processes: procedures>>=
  subroutine process_config_data_write (config, u, &
       counters, os_data, rng_factory, model, expressions)
    class(process_config_data_t), intent(in) :: config
    integer, intent(in) :: u
    logical, intent(in) :: counters
    logical, intent(in) :: os_data
    logical, intent(in) :: rng_factory
    logical, intent(in) :: model
    logical, intent(in) :: expressions
    write (u, "(1x,A)") "Configuration data:"
    if (counters) then
       write (u, "(3x,A,I0)") "Number of incoming particles = ", &
            config%n_in
       write (u, "(3x,A,I0)") "Number of process components = ", &
            config%n_components
       write (u, "(3x,A,I0)") "Number of process terms      = ", &
            config%n_terms
       write (u, "(3x,A,I0)") "Number of MCI configurations = ", &
            config%n_mci
    end if
    if (os_data) then
       call os_data_write (config%os_data, u)
    end if
    if (associated (config%model)) then
       write (u, "(3x,A,A)")  "Model = ", char (config%model_name)
       if (model) then
          call write_separator (u)
          call config%model%write (u)
          call write_separator (u)
       end if
    else
       write (u, "(3x,A,A,A)")  "Model = ", char (config%model_name), &
            " [not associated]"
    end if
    call config%qcd%write (u, show_md5sum = .false.)
    if (rng_factory) then
       if (allocated (config%rng_factory)) then
          write (u, "(2x)", advance = "no")
          call config%rng_factory%write (u)
       end if
    end if
    call write_separator (u)
    if (expressions) then
       if (allocated (config%ef_cuts)) then
          call write_separator (u)
          write (u, "(3x,A)") "Cut expression:"
          call config%ef_cuts%write (u)
       end if
       if (allocated (config%ef_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Scale expression:"
          call config%ef_scale%write (u)
       end if
       if (allocated (config%ef_fac_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Factorization scale expression:"
          call config%ef_fac_scale%write (u)
       end if
       if (allocated (config%ef_ren_scale)) then
          call write_separator (u)
          write (u, "(3x,A)") "Renormalization scale expression:"
          call config%ef_ren_scale%write (u)
       end if
       if (allocated (config%ef_weight)) then
          call write_separator (u)
          write (u, "(3x,A)") "Weight expression:"
          call config%ef_weight%write (u)
       end if
    else
       call write_separator (u)
       write (u, "(3x,A)") "Expressions (cut, scales, weight): [not shown]"
    end if
    if (config%md5sum /= "") then
       call write_separator (u)
       write (u, "(3x,A,A,A)")  "MD5 sum (config)  = '", config%md5sum, "'"
    end if
  end subroutine process_config_data_write
       
@ %def process_config_data_write
@ Initialize.  We use information from the process metadata and from
the process library, given the process ID.  We also store the
currently active OS data set.

The model that we import here should be an instance of the global model.  If we
create the instance outside, we can make it an extension of the basic
[[model_data_t]].  This will allow us to synchronize the variable list with
the model.  Using a pointer instead of an allocatable, we can guarantee the
[[target]] attribute.

The RNG factory object is imported by moving the allocation.
<<Processes: process config data: TBP>>=
  procedure :: init => process_config_data_init
<<Processes: procedures>>=
  subroutine process_config_data_init &
       (config, meta, os_data, qcd, rng_factory, model)
    class(process_config_data_t), intent(out) :: config
    type(process_metadata_t), intent(in) :: meta
    type(os_data_t), intent(in) :: os_data
    type(qcd_t), intent(in) :: qcd
    class(rng_factory_t), intent(inout), allocatable :: rng_factory
    class(model_data_t), intent(inout), pointer :: model
    config%n_in = meta%lib%get_n_in (meta%id)
    config%n_components = size (meta%component_id)
    config%os_data = os_data
    config%qcd = qcd
    call move_alloc (from = rng_factory, to = config%rng_factory)
    config%model_name = model%get_name ()
    config%model => model
    model => null ()
  end subroutine process_config_data_init

@ %def process_config_data_init
@ Since the captured model is a separate object allocated via a
pointer, we need a finalizer.
<<Processes: process config data: TBP>>=
  procedure :: final => process_config_data_final
<<Processes: procedures>>=
  subroutine process_config_data_final (config)
    class(process_config_data_t), intent(inout) :: config
    if (associated (config%model)) then
       call config%model%final ()
       deallocate (config%model)
    end if
  end subroutine process_config_data_final
  
@ %def process_config_data_final
@ Compute the MD5 sum of the configuration data.  This encodes, in
particular, the model and the expressions for cut, scales, weight,
etc.  It should not contain the IDs and number of components, etc.,
since the MD5 sum should be useful for integrating individual
components.

This is done only once.  If the MD5 sum is nonempty, the calculation
is skipped.
<<Processes: process config data: TBP>>=
  procedure :: compute_md5sum => process_config_data_compute_md5sum
<<Processes: procedures>>=
  subroutine process_config_data_compute_md5sum (config)
    class(process_config_data_t), intent(inout) :: config
    integer :: u
    if (config%md5sum == "") then
       u = free_unit ()
       open (u, status = "scratch", action = "readwrite")
       call config%write (u, counters = .false., os_data = .false., &
            rng_factory = .false., model = .true., expressions = .true.)
       rewind (u)
       config%md5sum = md5sum (u)
       close (u)
    end if
  end subroutine process_config_data_compute_md5sum
  
@ %def process_config_data_compute_md5sum
@
\subsection{Beam configuration}
The object [[data]] holds all details about the initial beam
configuration.  The allocatable array [[sf]] holds the structure-function
configuration blocks.  There are [[n_strfun]] entries in the
structure-function chain (not counting the initial beam object).  We
maintain [[n_channel]] independent parameterizations of this chain.
If this is greater than zero, we need a multi-channel sampling
algorithm, where for each point one channel is selected to generate
kinematics.

The number of parameters that are required for generating a
structure-function chain is [[n_sfpar]].

The flag [[azimuthal_dependence]] tells whether the process setup is
symmetric about the beam axis in the c.m.\ system.  This implies that
there is no transversal beam polarization.  The flag [[lab_is_cm_frame]] is
obvious.
<<Processes: process part types>>=
  type :: process_beam_config_t
     private
     type(beam_data_t) :: data
     integer :: n_strfun = 0
     integer :: n_channel = 1
     integer :: n_sfpar = 0
     type(sf_config_t), dimension(:), allocatable :: sf
     type(sf_channel_t), dimension(:), allocatable :: sf_channel
     logical :: azimuthal_dependence = .false.
     logical :: lab_is_cm_frame = .true.
     character(32) :: md5sum = ""
     logical :: sf_trace = .false.
     type(string_t) :: sf_trace_file
   contains
   <<Processes: process beam config: TBP>>
  end type process_beam_config_t

@ %def process_beam_config_t
@ Here we write beam data only if they are actually used.
<<Processes: process beam config: TBP>>=
  procedure :: write => process_beam_config_write
<<Processes: procedures>>=
  subroutine process_beam_config_write (object, u)
    class(process_beam_config_t), intent(in) :: object
    integer, intent(in) :: u
    integer :: i, c
    call object%data%write (u)
    if (object%data%initialized) then
       write (u, "(3x,A,L1)")  "Azimuthal dependence    = ", &
            object%azimuthal_dependence
       write (u, "(3x,A,L1)")  "Lab frame is c.m. frame = ", &
            object%lab_is_cm_frame
       if (object%md5sum /= "") then
          write (u, "(3x,A,A,A)")  "MD5 sum (beams/strf) = '", &
               object%md5sum, "'"
       end if
       if (allocated (object%sf)) then
          do i = 1, size (object%sf)
             call object%sf(i)%write (u)
          end do
          if (any_sf_channel_has_mapping (object%sf_channel)) then
             write (u, "(1x,A,L1)")  "Structure-function mappings per channel:"
             do c = 1, object%n_channel
                write (u, "(3x,I0,':')", advance="no")  c
                call object%sf_channel(c)%write (u)
             end do
          end if
       end if
    end if
  end subroutine process_beam_config_write
  
@ %def process_beam_config_write
@ The beam data have a finalizer.  We assume that there is none for the
structure-function data.
<<Processes: process beam config: TBP>>=
  procedure :: final => process_beam_config_final
<<Processes: procedures>>=
  subroutine process_beam_config_final (object)
    class(process_beam_config_t), intent(inout) :: object
    call beam_data_final (object%data)
  end subroutine process_beam_config_final

@ %def process_beam_config_final
@ Initialize the beam setup with a given beam structure object.
<<Processes: process beam config: TBP>>=
  procedure :: init_beam_structure => process_beam_config_init_beam_structure
<<Processes: procedures>>=
  subroutine process_beam_config_init_beam_structure &
       (beam_config, beam_structure, sqrts, model, decay_rest_frame)
    class(process_beam_config_t), intent(out) :: beam_config
    type(beam_structure_t), intent(in) :: beam_structure
    logical, intent(in), optional :: decay_rest_frame
    real(default), intent(in) :: sqrts
    class(model_data_t), intent(in), target :: model
    call beam_data_init_structure (beam_config%data, &
         beam_structure, sqrts, model, decay_rest_frame)
    beam_config%lab_is_cm_frame = beam_data_cm_frame (beam_config%data)
  end subroutine process_beam_config_init_beam_structure
  
@ %def process_beam_config_init_beam_structure
@ Initialize the beam setup for a scattering process with specified
flavor combination, other properties taken from the beam structure
object (if any).
<<Processes: process beam config: TBP>>=
  procedure :: init_scattering => process_beam_config_init_scattering
<<Processes: procedures>>=
  subroutine process_beam_config_init_scattering &
       (beam_config, flv_in, sqrts, beam_structure)
    class(process_beam_config_t), intent(out) :: beam_config
    type(flavor_t), dimension(2), intent(in) :: flv_in
    real(default), intent(in) :: sqrts
    type(beam_structure_t), intent(in), optional :: beam_structure
    if (present (beam_structure)) then
       if (beam_structure%polarized ()) then
          call beam_data_init_sqrts (beam_config%data, sqrts, flv_in, &
               beam_structure%get_smatrix (), beam_structure%get_pol_f ())
       else
          call beam_data_init_sqrts (beam_config%data, sqrts, flv_in)
       end if
    else
       call beam_data_init_sqrts (beam_config%data, sqrts, flv_in)
    end if
  end subroutine process_beam_config_init_scattering
    
@ %def process_beam_config_init_scattering    
@ Initialize the beam setup for a decay process with specified flavor,
other properties taken from the beam structure object (if present).

For a cascade decay, we set
[[rest_frame]] to false, indicating a event-wise varying momentum.
The beam data itself are initialized for the particle at rest.
<<Processes: process beam config: TBP>>=
  procedure :: init_decay => process_beam_config_init_decay
<<Processes: procedures>>=
  subroutine process_beam_config_init_decay &
       (beam_config, flv_in, rest_frame, beam_structure)
    class(process_beam_config_t), intent(out) :: beam_config
    type(flavor_t), dimension(1), intent(in) :: flv_in
    logical, intent(in), optional :: rest_frame
    type(beam_structure_t), intent(in), optional :: beam_structure
    if (present (beam_structure)) then
       if (beam_structure%polarized ()) then
          call beam_data_init_decay (beam_config%data, flv_in, &
               beam_structure%get_smatrix (), beam_structure%get_pol_f (), &
               rest_frame = rest_frame)
       else
          call beam_data_init_decay (beam_config%data, flv_in, &
               rest_frame = rest_frame)
       end if
    else
       call beam_data_init_decay (beam_config%data, flv_in, &
            rest_frame = rest_frame)
    end if 
    beam_config%lab_is_cm_frame = beam_data_cm_frame (beam_config%data)
  end subroutine process_beam_config_init_decay
    
@ %def process_beam_config_init_decay
@ Print an informative message.
<<Processes: process beam config: TBP>>=
  procedure :: startup_message => process_beam_config_startup_message
<<Processes: procedures>>=
  subroutine process_beam_config_startup_message &
       (beam_config, unit, beam_structure)
    class(process_beam_config_t), intent(in) :: beam_config
    integer, intent(in), optional :: unit
    type(beam_structure_t), intent(in), optional :: beam_structure
    integer :: u
    u = free_unit ()
    open (u, status="scratch", action="readwrite")
    if (present (beam_structure)) then
       call beam_structure%write (u)
    end if
    call beam_data_write (beam_config%data, u)
    rewind (u)
    do
       read (u, "(1x,A)", end=1)  msg_buffer
       call msg_message ()
    end do
1   continue
    close (u)
  end subroutine process_beam_config_startup_message

@ %def process_beam_config_startup_message
@ Allocate the structure-function array.
<<Processes: process beam config: TBP>>=
  procedure :: init_sf_chain => process_beam_config_init_sf_chain
<<Processes: procedures>>=
  subroutine process_beam_config_init_sf_chain &
       (beam_config, sf_config, sf_trace_file)
    class(process_beam_config_t), intent(inout) :: beam_config
    type(sf_config_t), dimension(:), intent(in) :: sf_config
    type(string_t), intent(in), optional :: sf_trace_file
    integer :: i
    beam_config%n_strfun = size (sf_config)
    allocate (beam_config%sf (beam_config%n_strfun))
    do i = 1, beam_config%n_strfun
       associate (sf => sf_config(i))
         call beam_config%sf(i)%init (sf%i, sf%data)
         if (.not. sf%data%is_generator ()) then
            beam_config%n_sfpar = beam_config%n_sfpar + sf%data%get_n_par ()
         end if
       end associate
    end do
    if (present (sf_trace_file)) then
       beam_config%sf_trace = .true.
       beam_config%sf_trace_file = sf_trace_file
    end if
  end subroutine process_beam_config_init_sf_chain

@ %def process_beam_config_init_sf_chain
@ Allocate the structure-function mapping channel array, given the
requested number of channels.
<<Processes: process beam config: TBP>>=
  procedure :: allocate_sf_channels => process_beam_config_allocate_sf_channels
<<Processes: procedures>>=
  subroutine process_beam_config_allocate_sf_channels (beam_config, n_channel)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer, intent(in) :: n_channel
    beam_config%n_channel = n_channel
    call allocate_sf_channels (beam_config%sf_channel, &
         n_channel = n_channel, &
         n_strfun = beam_config%n_strfun)
  end subroutine process_beam_config_allocate_sf_channels
    
@ %def process_beam_config_allocate_sf_channels
@ Set a structure-function mapping channel for an array of
structure-function entries, for a single channel.  (The default is no mapping.)
<<Processes: process beam config: TBP>>=
  procedure :: set_sf_channel => process_beam_config_set_sf_channel
<<Processes: procedures>>=
  subroutine process_beam_config_set_sf_channel (beam_config, c, sf_channel)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer, intent(in) :: c
    type(sf_channel_t), intent(in) :: sf_channel
    beam_config%sf_channel(c) = sf_channel
  end subroutine process_beam_config_set_sf_channel
  
@ %def process_beam_config_set_sf_channel
@ Print an informative startup message.
<<Processes: process beam config: TBP>>=
  procedure :: sf_startup_message => process_beam_config_sf_startup_message
<<Processes: procedures>>=
  subroutine process_beam_config_sf_startup_message &
       (beam_config, sf_string, unit)
    class(process_beam_config_t), intent(in) :: beam_config
    type(string_t), intent(in) :: sf_string
    integer, intent(in), optional :: unit
    if (beam_config%n_strfun > 0) then
       call msg_message ("Beam structure: " // char (sf_string), unit = unit)
       write (msg_buffer, "(A,3(1x,I0,1x,A))") &
            "Beam structure:", &
            beam_config%n_channel, "channels,", &
            beam_config%n_sfpar, "dimensions"
       call msg_message (unit = unit)
       if (beam_config%sf_trace) then
          call msg_message ("Beam structure: tracing &
               &values in '" // char (beam_config%sf_trace_file) // "'")
       end if
    end if
  end subroutine process_beam_config_sf_startup_message
    
@ %def process_beam_config_startup_message
@ Return the PDF set currently in use, if any.  This should be unique,
so we scan the structure functions until we get a nonzero number.

(This implies that if the PDF set is not unique (e.g., proton and
photon structure used together), this doesn't work correctly.)
<<Processes: process beam config: TBP>>=
  procedure :: get_pdf_set => process_beam_config_get_pdf_set
<<Processes: procedures>>=
  function process_beam_config_get_pdf_set (beam_config) result (pdf_set)
    class(process_beam_config_t), intent(in) :: beam_config
    integer :: pdf_set
    integer :: i
    if (allocated (beam_config%sf)) then
       do i = 1, size (beam_config%sf)
          pdf_set = beam_config%sf(i)%get_pdf_set ()
          if (pdf_set /= 0)  return
       end do
    else
       pdf_set = 0
    end if
  end function process_beam_config_get_pdf_set
  
@ %def process_beam_config_get_pdf_set
@ Compute the MD5 sum for the complete beam setup.  We rely on the
default output of [[write]] to contain all relevant data.

This is done only once, when the MD5 sum is still empty.
<<Processes: process beam config: TBP>>=
  procedure :: compute_md5sum => process_beam_config_compute_md5sum
<<Processes: procedures>>=
  subroutine process_beam_config_compute_md5sum (beam_config)
    class(process_beam_config_t), intent(inout) :: beam_config
    integer :: u
    if (beam_config%md5sum == "") then
       u = free_unit ()
       open (u, status = "scratch", action = "readwrite")
       call beam_config%write (u)
       rewind (u)
       beam_config%md5sum = md5sum (u)
       close (u)
    end if
  end subroutine process_beam_config_compute_md5sum

@ %def process_beam_config_compute_md5sum
@
\subsubsection{Process call statistics}
This object can record process calls, categorized by evaluation
status.  It is a part of the [[mci_entry]] component below.
<<Processes: types>>=
  type :: process_counter_t
     integer :: total = 0
     integer :: failed_kinematics = 0
     integer :: failed_cuts = 0
     integer :: passed = 0
     integer :: evaluated = 0
     integer :: complete = 0
   contains
   <<Processes: process counter: TBP>>
  end type process_counter_t
  
@ %def process_counter_t
@ Here are the corresponding numeric codes:
<<Processes: parameters>>=
  integer, parameter, public :: STAT_UNDEFINED = 0
  integer, parameter, public :: STAT_INITIAL = 1
  integer, parameter, public :: STAT_ACTIVATED = 2
  integer, parameter, public :: STAT_BEAM_MOMENTA = 3
  integer, parameter, public :: STAT_FAILED_KINEMATICS = 4
  integer, parameter, public :: STAT_SEED_KINEMATICS = 5
  integer, parameter, public :: STAT_HARD_KINEMATICS = 6
  integer, parameter, public :: STAT_EFF_KINEMATICS = 7
  integer, parameter, public :: STAT_FAILED_CUTS = 8
  integer, parameter, public :: STAT_PASSED_CUTS = 9
  integer, parameter, public :: STAT_EVALUATED_TRACE = 10
  integer, parameter, public :: STAT_EVENT_COMPLETE = 11

  integer, parameter, public :: COMP_DEFAULT = 0
  integer, parameter, public :: COMP_REAL_FIN = 1
  integer, parameter, public :: COMP_MASTER = 2
  integer, parameter, public :: COMP_VIRT = 3
  integer, parameter, public :: COMP_REAL = 4
  integer, parameter, public :: COMP_REAL_SING = 5
  integer, parameter, public :: COMP_PDF = 6
  integer, parameter, public :: COMP_SUB = 7

  integer, parameter :: DAMPING_NONE = 0
  integer, parameter :: DAMPING_SINGULAR = 1
  integer, parameter :: DAMPING_FINITE = 2
  
@ %def STAT_UNDEFINED STAT_INITIAL STAT_ACTIVATED 
@ %def STAT_BEAM_MOMENTA STAT_FAILED_KINEMATICS
@ %def STAT_SEED_KINEMATICS STAT_HARD_KINEMATICS STAT_EFF_KINEMATICS
@ %def STAT_EVALUATED_TRACE STAT_EVENT_COMPLETE
@ Output.
<<Processes: process counter: TBP>>=
  procedure :: write => process_counter_write
<<Processes: procedures>>=
  subroutine process_counter_write (object, unit)
    class(process_counter_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (object%total > 0) then
       write (u, "(1x,A)")  "Call statistics (current run):"
       write (u, "(3x,A,I0)")  "total       = ", object%total
       write (u, "(3x,A,I0)")  "failed kin. = ", object%failed_kinematics
       write (u, "(3x,A,I0)")  "failed cuts = ", object%failed_cuts
       write (u, "(3x,A,I0)")  "passed cuts = ", object%passed
       write (u, "(3x,A,I0)")  "evaluated   = ", object%evaluated
    else
       write (u, "(1x,A)")  "Call statistics (current run): [no calls]"
    end if
  end subroutine process_counter_write
    
@ %def process_counter_write
@ Reset.  Just enforce default initialization.
<<Processes: process counter: TBP>>=
  procedure :: reset => process_counter_reset
<<Processes: procedures>>=
  subroutine process_counter_reset (counter)
    class(process_counter_t), intent(out) :: counter
  end subroutine process_counter_reset

@ %def process_counter_reset
@ We record an event according to the lowest status code greater or
equal to the actual status.  This is actually done by the process
instance; the process object just copies the instance counter.
<<Processes: process counter: TBP>>=
  procedure :: record => process_counter_record
<<Processes: procedures>>=
  subroutine process_counter_record (counter, status)
    class(process_counter_t), intent(inout) :: counter
    integer, intent(in) :: status
    if (status <= STAT_FAILED_KINEMATICS) then
       counter%failed_kinematics = counter%failed_kinematics + 1
    else if (status <= STAT_FAILED_CUTS) then
       counter%failed_cuts = counter%failed_cuts + 1
    else if (status <= STAT_PASSED_CUTS) then
       counter%passed = counter%passed + 1
    else
       counter%evaluated = counter%evaluated + 1
    end if
    counter%total = counter%total + 1
  end subroutine process_counter_record
       
@ %def process_counter_record
@
\subsection{Multi-channel integration}
The [[process_mci_entry_t]] block contains, for each process component that is
integrated independently, the configuration data for its MC input parameters.
Each input parameter set is handled by a [[mci_t]] integrator.

The MC input parameter set is broken down into the parameters required by the
structure-function chain and the parameters required by the phase space of the
elementary process.

The MD5 sum collects all information about the associated processes
that may affect the integration.  It does not contain the MCI object
itself or integration results.

MC integration is organized in passes.  Each pass may consist of
several iterations, and for each iteration there is a number of
calls.  We store explicitly the values that apply to the current
pass.  Previous values are archived in the [[results]] object.

The [[counter]] receives the counter statistics from the associated
process instance, for diagnostics.

The [[results]] object records results, broken down in passes and iterations.
<<Processes: process part types>>=
  type :: process_mci_entry_t
     integer :: i_mci = 0
     integer, dimension(:), allocatable :: i_component
     integer :: process_type = PRC_UNKNOWN
     integer :: n_par = 0
     integer :: n_par_sf = 0
     integer :: n_par_phs = 0
     character(32) :: md5sum = ""
     integer :: pass = 0
     integer :: n_it = 0
     integer :: n_calls = 0
     logical :: activate_timer = .false.
     real(default) :: error_threshold = 0
     class(mci_t), allocatable :: mci
     type(process_counter_t) :: counter
     type(integration_results_t) :: results
     logical :: negative_weights
     logical :: combined_integration = .false.
     integer :: powheg_damping_type = DAMPING_NONE
     integer :: associated_real_component = 0
   contains
   <<Processes: process mci entry: TBP>>
  end type process_mci_entry_t

@ %def process_mci_entry_t
@ Finalizer for the [[mci]] component.
<<Processes: process mci entry: TBP>>=
  procedure :: final => process_mci_entry_final
<<Processes: procedures>>=
  subroutine process_mci_entry_final (object)
    class(process_mci_entry_t), intent(inout) :: object
    if (allocated (object%mci))  call object%mci%final ()
  end subroutine process_mci_entry_final
  
@ %def process_mci_entry_final
@ Output.  Write pass/iteration information only if set (the pass
index is nonzero).  Write the MCI block only if it exists (for some
self-tests it does not).  Write results only if there are any.
<<Processes: process mci entry: TBP>>=
  procedure :: write => process_mci_entry_write
<<Processes: procedures>>=
  subroutine process_mci_entry_write (object, unit, pacify)
    class(process_mci_entry_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,I0)")  "Associated components = ", object%i_component
    write (u, "(3x,A,I0)")  "MC input parameters   = ", object%n_par
    write (u, "(3x,A,I0)")  "MC parameters (SF)    = ", object%n_par_sf
    write (u, "(3x,A,I0)")  "MC parameters (PHS)   = ", object%n_par_phs
    if (object%pass > 0) then
       write (u, "(3x,A,I0)")  "Current pass          = ", object%pass
       write (u, "(3x,A,I0)")  "Number of iterations  = ", object%n_it
       write (u, "(3x,A,I0)")  "Number of calls       = ", object%n_calls
    end if
    if (object%md5sum /= "") then
       write (u, "(3x,A,A,A)") "MD5 sum (components)  = '", object%md5sum, "'"
    end if
    if (allocated (object%mci)) then
       call object%mci%write (u)
    end if
    call object%counter%write (u)
    if (object%results%exist ()) then
       call object%results%write (u, suppress = pacify)
       call object%results%write_chain_weights (u)
    end if
  end subroutine process_mci_entry_write
       
@ %def process_mci_entry_write
@ Write the weights that are assigned to the chains of channels (call groves in
the [[wood]] phase-space implementation.  This depends on the implementation
and is delegated to the [[mci]] component.
<<XXX Processes: process mci entry: TBP>>=
  procedure :: write_chain_weights => process_mci_entry_write_chain_weights
<<XXX Processes: procedures>>=
  subroutine process_mci_entry_write_chain_weights (mci_entry, unit)
    class(process_mci_entry_t), intent(in) :: mci_entry
    integer, intent(in), optional :: unit
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%write_chain_weights (unit)
    end if
  end subroutine process_mci_entry_write_chain_weights
       
@ %def process_mci_entry_write_chain_weights
@ Initialize.  From the existing configuration, we obtain the number of
channels and the number of parameters, separately for the structure-function
chain and for the associated process component.  We assume that the
phase-space object has already been configured.

The allocation of the MCI integrator with the appropriate concrete type is the
duty of the process core.

We assume that there is only one component associated with a MCI entry.  This
restriction should be relaxed.
<<Processes: process mci entry: TBP>>=
  procedure :: init => process_mci_entry_init
<<Processes: procedures>>=
  subroutine process_mci_entry_init (mci_entry, &
       process_type, i_mci, i_component, component,&
       beam_config, rng_factory)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    integer, intent(in) :: process_type
    integer, intent(in) :: i_mci
    integer, intent(in) :: i_component
    type(process_component_t), intent(in), target :: component
    type(process_beam_config_t), intent(in) :: beam_config
    class(rng_factory_t), intent(inout) :: rng_factory
    class(rng_t), allocatable :: rng
    associate (phs_config => component%phs_config)
      mci_entry%i_mci = i_mci
      call mci_entry%create_component_list (i_component, component)
      mci_entry%n_par_sf = beam_config%n_sfpar
      mci_entry%n_par_phs = phs_config%get_n_par () 
      mci_entry%n_par = mci_entry%n_par_sf + mci_entry%n_par_phs
      mci_entry%process_type = process_type
      if (allocated (component%mci_template)) then
         allocate (mci_entry%mci, source=component%mci_template)
         call mci_entry%mci%record_index (mci_entry%i_mci)
         call mci_entry%mci%set_dimensions &
              (mci_entry%n_par, phs_config%get_n_channel ())
         call mci_entry%mci%declare_flat_dimensions &
              (phs_config%get_flat_dimensions ())
         if (phs_config%provides_equivalences) then
            call mci_entry%mci%declare_equivalences &
                 (phs_config%channel, mci_entry%n_par_sf)
         end if
         if (phs_config%provides_chains) then
            call mci_entry%mci%declare_chains (phs_config%chain)
         end if
         call rng_factory%make (rng)
         call mci_entry%mci%import_rng (rng)
      end if
    end associate
    call mci_entry%results%init (process_type)
  end subroutine process_mci_entry_init
  
@ %def process_mci_entry_init
@
<<Processes: process mci entry: TBP>>=
  procedure :: create_component_list => &
                     process_mci_entry_create_component_list
<<Processes: procedures>>=
  subroutine process_mci_entry_create_component_list (mci_entry, &
                                     i_component, component)
    class (process_mci_entry_t), intent(inout) :: mci_entry
    integer, intent(in) :: i_component
    type(process_component_t), intent(in), target :: component
    integer, dimension(:), allocatable :: i_list
    integer, save :: i_rfin_offset = 0
    if (mci_entry%combined_integration) then
      select case (mci_entry%powheg_damping_type)
      case (DAMPING_NONE)
         i_list = component%config%get_association_list ()
         allocate (mci_entry%i_component (size (i_list)))
         mci_entry%i_component = i_list
      case (DAMPING_SINGULAR)
         i_list = component%config%get_association_list &
           (ASSOCIATED_REAL_FIN)
         allocate (mci_entry%i_component (size(i_list)))
         mci_entry%i_component = i_list
      case (DAMPING_FINITE)
         allocate (mci_entry%i_component (1))
         mci_entry%i_component(1) = &
            component%config%get_associated_real_fin () &
          + i_rfin_offset 
         i_rfin_offset = i_rfin_offset + 1
      end select
    else
      allocate (mci_entry%i_component (1))
      mci_entry%i_component(1) = i_component
    end if
  end subroutine process_mci_entry_create_component_list

@ %def process_mci_entry_create_component_list
@
<<Processes: process mci entry: TBP>>=
  procedure :: deactivate_real_component => &
     process_mci_entry_deactivate_real_component 
<<Processes: procedures>>=
  subroutine process_mci_entry_deactivate_real_component (mci_entry, component)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_component_t), intent(in), target :: component
    integer, dimension(:), allocatable :: i_list
    if (allocated (mci_entry%i_component)) then
       deallocate (mci_entry%i_component)
       allocate (mci_entry%i_component (2))
       ! TODO: (cw 2015-07-30) beware the intel
       i_list = component%config%get_association_list ()
       mci_entry%i_component(1) = i_list(1)
       mci_entry%i_component(2) = i_list(3)
    else
       call msg_fatal ("Trying to reset deallocated component list")
    end if
  end subroutine process_mci_entry_deactivate_real_component 

@ %def process_mci_entry_deactivate_real_component
@ 
<<Processes: process mci entry: TBP>>=
  procedure :: set_combined_integration => &
                     process_mci_entry_set_combined_integration
<<Processes: procedures>>=
  subroutine process_mci_entry_set_combined_integration (mci_entry, value)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    logical, intent(in), optional :: value
    if (present (value)) &
       mci_entry%combined_integration = value
  end subroutine process_mci_entry_set_combined_integration

@ %def process_mci_entry_set_combined_integration
@
<<Processes: process mci entry: TBP>>=
  procedure :: set_associated_real_component &
      => process_mci_entry_set_associated_real_component
<<Processes: procedures>>=
  subroutine process_mci_entry_set_associated_real_component (mci_entry, i)
     class(process_mci_entry_t), intent(inout) :: mci_entry
     integer, intent(in) :: i
     mci_entry%associated_real_component = i
  end subroutine process_mci_entry_set_associated_real_component

@ %def process_mci_entry_set_associated_real_component 
@ Set some additional parameters.
<<Processes: process mci entry: TBP>>=
  procedure :: set_parameters => process_mci_entry_set_parameters
<<Processes: procedures>>=
  subroutine process_mci_entry_set_parameters (mci_entry, var_list)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(var_list_t), intent(in) :: var_list
    real(default) :: error_threshold
    error_threshold = &
         var_list%get_rval (var_str ("error_threshold"))
    mci_entry%activate_timer = &
         var_list%get_lval (var_str ("?integration_timer"))
    call mci_entry%results%set_error_threshold (error_threshold)
  end subroutine process_mci_entry_set_parameters
  
@ %def process_mci_entry_set_parameters
@ Compute a MD5 sum that summarizes all information that could
influence integration results, for the associated process components.
We take the process-configuration MD5 sum which represents parameters,
cuts, etc., the MD5 sums for the process component definitions and
their phase space objects (which should be configured), and the beam
configuration MD5 sum.  (The QCD setup is included in the process
configuration data MD5 sum.)

Done only once, when the MD5 sum is still empty.
<<Processes: process mci entry: TBP>>=
  procedure :: compute_md5sum => process_mci_entry_compute_md5sum
<<Processes: procedures>>=
  subroutine process_mci_entry_compute_md5sum (mci_entry, &
       config, component, beam_config)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_config_data_t), intent(in) :: config
    type(process_component_t), dimension(:), intent(in) :: component
    type(process_beam_config_t), intent(in) :: beam_config
    type(string_t) :: buffer
    integer :: i
    if (mci_entry%md5sum == "") then
       buffer = config%md5sum // beam_config%md5sum
       do i = 1, size (component)
          if (component(i)%active) then
             buffer = buffer // component(i)%config%get_md5sum () &
                  // component(i)%md5sum_phs
          end if
       end do
       mci_entry%md5sum = md5sum (char (buffer))
    end if
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%set_md5sum (mci_entry%md5sum)
    end if
  end subroutine process_mci_entry_compute_md5sum
  
@ %def process_mci_entry_compute_md5sum
@ Test the MCI sampler by calling it a given number of time, discarding the
results.  The instance should be initialized.

The [[mci_entry]] is [[intent(inout)]] because the integrator contains
the random-number state.
<<Processes: process mci entry: TBP>>=
  procedure :: sampler_test => process_mci_entry_sampler_test
<<Processes: procedures>>=
  subroutine process_mci_entry_sampler_test (mci_entry, instance, n_calls)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout), target :: instance
    integer, intent(in) :: n_calls
    call instance%choose_mci (mci_entry%i_mci)
    call instance%reset_counter ()
    call mci_entry%mci%sampler_test (instance, n_calls)
    mci_entry%counter = instance%get_counter ()
  end subroutine process_mci_entry_sampler_test

@ %def process_mci_entry_sampler_test
@ Integrate.  The instance should be initialized.

The [[integrate]] method counts as an integration pass; the pass count is
increased by one.  We transfer the pass parameters (number of iterations and
number of calls) to the actual integration routine.

The [[mci_entry]] is [[intent(inout)]] because the integrator contains
the random-number state.

Note: The results are written to screen and to logfile.  This behavior
is hardcoded.
<<Processes: process mci entry: TBP>>=
  procedure :: integrate => process_mci_entry_integrate
  procedure :: final_integration => process_mci_entry_final_integration
<<Processes: procedures>>=
  subroutine process_mci_entry_integrate (mci_entry, instance, n_it, n_calls, &
       adapt_grids, adapt_weights, final, pacify, &
       i_component)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: n_it
    integer, intent(in) :: n_calls
    logical, intent(in), optional :: adapt_grids
    logical, intent(in), optional :: adapt_weights
    logical, intent(in), optional :: final, pacify
    integer, intent(in), optional :: i_component
    integer :: u_log
    integer :: nlo_type
    if (present (i_component)) then
      if (associated (instance%component(i_component)%config)) then
        nlo_type = instance%component(i_component)%config%config%get_nlo_type ()
      end if
    else
      nlo_type = BORN
    end if
    u_log = logfile_unit ()
    call instance%choose_mci (mci_entry%i_mci)
    call instance%reset_counter ()
    mci_entry%pass = mci_entry%pass + 1
    mci_entry%n_it = n_it
    mci_entry%n_calls = n_calls
    if (mci_entry%pass == 1)  &
         call mci_entry%mci%startup_message (n_calls = n_calls)
    call mci_entry%mci%set_timer (active = mci_entry%activate_timer)
    call mci_entry%results%display_init &
         (mci_entry%process_type, screen = .true., unit = u_log)
    call mci_entry%results%new_pass ()
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      select case (nlo_type)
      case (NLO_VIRTUAL, NLO_REAL, NLO_PDF)
         mci_instance%negative_weights = .true.
      end select
      call mci_entry%mci%add_pass (adapt_grids, adapt_weights, final)
      call mci_entry%mci%start_timer ()
      call mci_entry%mci%integrate (mci_instance, instance, n_it, &
           n_calls, mci_entry%results, pacify = pacify)
      call mci_entry%mci%stop_timer ()
      if (signal_is_pending ())  return
    end associate
    mci_entry%counter = instance%get_counter ()
    call mci_entry%results%display_pass (pacify)
  end subroutine process_mci_entry_integrate

  subroutine process_mci_entry_final_integration (mci_entry)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    call mci_entry%results%display_final ()
    call mci_entry%time_message ()
  end subroutine process_mci_entry_final_integration

@ %def process_mci_entry_integrate
@ %def process_mci_entry_final_integration
@ If appropriate, issue an informative message about the expected time
for an event sample.
<<Processes: process mci entry: TBP>>=
  procedure :: get_time => process_mci_entry_get_time
  procedure :: time_message => process_mci_entry_time_message
<<Processes: procedures>>=
  subroutine process_mci_entry_get_time (mci_entry, time, sample)
    class(process_mci_entry_t), intent(in) :: mci_entry
    type(time_t), intent(out) :: time
    integer, intent(in) :: sample
    real(default) :: time_last_pass, efficiency, calls
    time_last_pass = mci_entry%mci%get_time ()
    calls = mci_entry%results%get_n_calls ()
    efficiency = mci_entry%mci%get_efficiency ()
    if (time_last_pass > 0 .and. calls > 0 .and. efficiency > 0) then
       time = nint (time_last_pass / calls / efficiency * sample)
    end if
  end subroutine process_mci_entry_get_time   

  subroutine process_mci_entry_time_message (mci_entry)
    class(process_mci_entry_t), intent(in) :: mci_entry
    type(time_t) :: time
    integer :: sample
    sample = 10000
    call mci_entry%get_time (time, sample)
    if (time%is_known ()) then
       call msg_message ("Time estimate for generating 10000 events: " &
            // char (time%to_string_dhms ()))
    end if
  end subroutine process_mci_entry_time_message
  
@ %def process_mci_entry_time_message
@ Prepare event generation.  (For the test integrator, this does nothing.  It
is relevant for the VAMP integrator.)
<<Processes: process mci entry: TBP>>=
  procedure :: prepare_simulation => process_mci_entry_prepare_simulation
<<Processes: procedures>>=
  subroutine process_mci_entry_prepare_simulation (mci_entry)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    call mci_entry%mci%prepare_simulation ()
  end subroutine process_mci_entry_prepare_simulation

@ %def process_mci_entry_prepare_simulation
@ Generate an event.  The instance should be initialized,
otherwise event generation is directed by the [[mci]] integrator
subobject.  The integrator instance is contained in a [[mci_work]]
subobject of the process instance, which simultaneously serves as the
sampler object.  (We avoid the anti-aliasing rules if we assume that
the sampling itself does not involve the integrator instance contained in the
process instance.)

Regarding weighted events, we only take events which are valid, which
means that they have valid kinematics and have passed cuts.
Therefore, we have a rejection loop.  For unweighted events, the
unweighting routine should already take care of this.
<<Processes: process mci entry: TBP>>=
  procedure :: generate_weighted_event => &
       process_mci_entry_generate_weighted_event
  procedure :: generate_unweighted_event => &
       process_mci_entry_generate_unweighted_event
  procedure :: recover_event => process_mci_entry_recover_event
<<Processes: procedures>>=
  subroutine process_mci_entry_generate_weighted_event (mci_entry, instance)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    call instance%choose_mci (mci_entry%i_mci)
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      REJECTION: do
         call mci_entry%mci%generate_weighted_event (mci_instance, instance)
         if (signal_is_pending ())  return
         if (instance%is_valid ())  exit REJECTION
      end do REJECTION
    end associate
  end subroutine process_mci_entry_generate_weighted_event
  
  subroutine process_mci_entry_generate_unweighted_event (mci_entry, instance)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    call instance%choose_mci (mci_entry%i_mci)
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      call mci_entry%mci%generate_unweighted_event (mci_instance, instance)
    end associate
  end subroutine process_mci_entry_generate_unweighted_event
  
  subroutine process_mci_entry_recover_event (mci_entry, instance, i_term)
    class(process_mci_entry_t), intent(inout) :: mci_entry
    type(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: channel
    mci_entry%i_mci = instance%i_mci
    channel = instance%get_channel ()
    associate (mci_instance => instance%mci_work(mci_entry%i_mci)%mci)
      call mci_instance%fetch (instance, channel)
    end associate
  end subroutine process_mci_entry_recover_event
  
@ %def process_mci_entry_generate_weighted_event
@ %def process_mci_entry_generate_unweighted_event
@ %def process_mci_entry_recover_event
@ Extract results.
<<Processes: process mci entry: TBP>>=
  procedure :: has_integral => process_mci_entry_has_integral
  procedure :: get_integral => process_mci_entry_get_integral
  procedure :: get_error => process_mci_entry_get_error  
  procedure :: get_accuracy => process_mci_entry_get_accuracy
  procedure :: get_chi2 => process_mci_entry_get_chi2
  procedure :: get_efficiency => process_mci_entry_get_efficiency
<<Processes: procedures>>=
  function process_mci_entry_has_integral (mci_entry) result (flag)
    class(process_mci_entry_t), intent(in) :: mci_entry
    logical :: flag
    flag = mci_entry%results%exist ()
  end function process_mci_entry_has_integral
    
  function process_mci_entry_get_integral (mci_entry) result (integral)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: integral
    integral = mci_entry%results%get_integral ()
  end function process_mci_entry_get_integral

  function process_mci_entry_get_error (mci_entry) result (error)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: error
    error = mci_entry%results%get_error ()
  end function process_mci_entry_get_error
  
  function process_mci_entry_get_accuracy (mci_entry) result (accuracy)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: accuracy
    accuracy = mci_entry%results%get_accuracy ()
  end function process_mci_entry_get_accuracy
  
  function process_mci_entry_get_chi2 (mci_entry) result (chi2)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: chi2
    chi2 = mci_entry%results%get_chi2 ()
  end function process_mci_entry_get_chi2

  function process_mci_entry_get_efficiency (mci_entry) result (efficiency)
    class(process_mci_entry_t), intent(in) :: mci_entry
    real(default) :: efficiency
    efficiency = mci_entry%results%get_efficiency ()
  end function process_mci_entry_get_efficiency  
  
@ %def process_mci_entry_get_integral process_mci_entry_get_error
@ %def process_mci_entry_get_accuracy process_mci_entry_get_chi2
@ %def process_mci_entry_get_efficiency
@ Return the MCI checksum.  This may be the one used for
configuration, but may also incorporate results, if they change the
state of the integrator (adaptation).
<<Processes: process mci entry: TBP>>=
  procedure :: get_md5sum => process_mci_entry_get_md5sum
<<Processes: procedures>>=
  function process_mci_entry_get_md5sum (entry) result (md5sum)
    class(process_mci_entry_t), intent(in) :: entry
    character(32) :: md5sum
    md5sum = entry%mci%get_md5sum ()
  end function process_mci_entry_get_md5sum
  
@ %def process_mci_entry_get_md5sum
@
\subsection{Process Components}
A process component is an individual contribution to a process
(scattering or decay) which needs not be physical.  The sum over all
components should be physical.

The [[index]] indentifies this component within its parent process.

The actual process component is stored in the [[core]] subobject.  We
use a polymorphic subobject instead of an extension of
[[process_component_t]], because the individual entries in the array
of process components can have different types.  In short,
[[process_component_t]] is a wrapper for the actual process variants.

If the [[active]] flag is false, we should skip this component.  This happens
if the associated process has vanishing matrix element.

The index array [[i_term]] points to the individual terms generated by
this component.  The indices refer to the parent process.

The index [[i_mci]] is the index of the MC integrator and parameter set which
are associated to this process component.
<<Processes: process part types>>=
  type :: process_component_t
     private
     type(process_component_def_t), pointer :: config => null ()
     integer :: index = 0
     class(prc_core_t), allocatable :: core
     class(prc_core_t), pointer :: core_sub_born
     logical :: active = .false.
     class(mci_t), allocatable :: mci_template
     integer, dimension(:), allocatable :: i_term
     integer :: i_mci = 0
     class(phs_config_t), allocatable :: phs_config
     character(32) :: md5sum_phs = ""
     type(fks_template_t) :: fks_template
     integer :: component_type = COMP_DEFAULT
   contains
   <<Processes: process component: TBP>>
  end type process_component_t

@ %def process_component_t
@ Finalizer.  The MCI template may (potentially) need a finalizer.  The process
configuration finalizer may include closing an open scratch file.
<<Processes: process component: TBP>>=
  procedure :: final => process_component_final
<<Processes: procedures>>=
  subroutine process_component_final (object)
    class(process_component_t), intent(inout) :: object
    if (allocated (object%mci_template)) then
       call object%mci_template%final ()
    end if
    if (allocated (object%phs_config)) then
       call object%phs_config%final ()
    end if
  end subroutine process_component_final
  
@ %def process_component_final
@ The meaning of [[verbose]] depends on the process variant.
<<Processes: process component: TBP>>=
  procedure :: write => process_component_write
<<Processes: procedures>>=
  subroutine process_component_write (object, unit)
    class(process_component_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (allocated (object%core)) then
       write (u, "(1x,A,I0)")  "Component #", object%index
       if (associated (object%config)) then
          call object%config%write (u)
          if (object%md5sum_phs /= "") then
             write (u, "(3x,A,A,A)")  "MD5 sum (phs)       = '", &
                  object%md5sum_phs, "'"
          end if
       end if
       write (u, "(1x,A)") "Process core:"
       call object%core%write (u)
    else
       write (u, "(1x,A)") "Process component: [not allocated]"
    end if
    if (.not. object%active) then
       write (u, "(1x,A)") "[Inactive]"
       return
    end if
    write (u, "(1x,A)") "Referenced data:"
    if (allocated (object%i_term)) then
       write (u, "(3x,A,999(1x,I0))") "Terms                    =", &
            object%i_term
    else
       write (u, "(3x,A)") "Terms                    = [undefined]"
    end if
    if (object%i_mci /= 0) then
       write (u, "(3x,A,I0)") "MC dataset               = ", object%i_mci
    else
       write (u, "(3x,A)") "MC dataset               = [undefined]"
    end if
    if (allocated (object%phs_config)) then
       call object%phs_config%write (u)
    end if
  end subroutine process_component_write

@ %def process_component_write
@ Initialize the component.
<<Processes: process component: TBP>>=
  procedure :: init => process_component_init
<<Processes: procedures>>=
  subroutine process_component_init (component, &
       i_component, meta, config, &
       core_template, mci_template, phs_config_template, &
       blha_template, fks_template)
    class(process_component_t), intent(out) :: component
    integer, intent(in) :: i_component
    type(process_metadata_t), intent(in) :: meta
    type(process_config_data_t), intent(in) :: config
    class(prc_core_t), intent(in), allocatable :: core_template
    class(mci_t), intent(in), allocatable :: mci_template
    class(phs_config_t), intent(in), allocatable :: phs_config_template
    type(blha_template_t), intent(inout), optional :: blha_template
    type(fks_template_t), intent(in), optional :: fks_template

    component%index = i_component
    component%config => meta%lib%get_component_def_ptr (meta%id, i_component)
    allocate (component%core, source=core_template)
    call component%core%init (component%config%get_core_def_ptr (), &
         meta%lib, meta%id, i_component)
    if (present (fks_template)) then
      component%fks_template = fks_template
    end if
    select type (core => component%core)
    class is (prc_blha_t)
      if (present (blha_template)) then
        call core%init_blha (blha_template)
      else
        call msg_bug ("process_component_init: BLHA core cannot be initialized - &
                       & missing template")
      end if
      call core%init_driver (config%os_data)
!      call core%set_initialized ()
    end select
    component%active = component%core%has_matrix_element ()
    if (component%active) then
       if (allocated (mci_template)) &
            allocate (component%mci_template, source=mci_template)
       allocate (component%phs_config, source=phs_config_template)
       call component%phs_config%init (component%core%data, config%model)
    end if
  end subroutine process_component_init

@ %def process_component_init
@ Finalize the phase-space configuration. 
<<Processes: process component: TBP>>=
  procedure :: configure_phs => process_component_configure_phs
<<Processes: procedures>>=
  subroutine process_component_configure_phs &
       (component, sqrts, beam_config, rebuild, &
        ignore_mismatch, phs_config, verbose)
    class(process_component_t), intent(inout) :: component
    real(default), intent(in) :: sqrts
    type(process_beam_config_t), intent(in) :: beam_config
    logical, intent(in), optional :: rebuild
    logical, intent(in), optional :: ignore_mismatch
    type(phs_wood_config_t), intent(in), optional, target :: phs_config
    logical, intent(in), optional :: verbose
    logical :: no_strfun, verb
    integer :: nlo_type
    no_strfun = beam_config%n_strfun == 0
    verb = .true.;  if (present (verbose))  verb = verbose
    nlo_type = component%config%get_nlo_type ()
    if (present (phs_config)) then
       select type (config => component%phs_config)
       type is (phs_fks_config_t)
          call config%set_born_config (phs_config)
          call config%set_mode (nlo_type)
       end select
    end if
    call component%phs_config%configure (sqrts, &
         azimuthal_dependence = beam_config%azimuthal_dependence, &
         sqrts_fixed = no_strfun, &
         cm_frame = beam_config%lab_is_cm_frame .and. no_strfun, &
         rebuild = rebuild, ignore_mismatch = ignore_mismatch, &
         nlo_type = nlo_type)
    if (verb)  call component%phs_config%startup_message ()
  end subroutine process_component_configure_phs
    
@ %def process_component_configure_phs
@ 
<<Processes: process component: TBP>>=
  procedure :: increase_phs_par => process_component_increase_phs_par
<<Processes: procedures>>=
  subroutine process_component_increase_phs_par (component)
    class(process_component_t), intent(inout) :: component
    select type (phs_config => component%phs_config)
    type is (phs_wood_config_t)
       call phs_config%increase_n_par ()
    end select
  end subroutine process_component_increase_phs_par

@ %def process_component_increase_phs_par 
@ The process component possesses two MD5 sums: the checksum of the
component definition, which should be available when the component is
initialized, and the phase-space MD5 sum, which is available after
configuration.
<<Processes: process component: TBP>>=
  procedure :: compute_md5sum => process_component_compute_md5sum
<<Processes: procedures>>=
  subroutine process_component_compute_md5sum (component)
    class(process_component_t), intent(inout) :: component
    component%md5sum_phs = component%phs_config%get_md5sum ()
  end subroutine process_component_compute_md5sum
  
@ %def process_component_compute_md5sum
@ Match phase-space channels with structure-function channels, where
applicable.

This calls a method of the [[phs_config]] phase-space implementation.
<<Processes: process component: TBP>>=
  procedure :: collect_channels => process_component_collect_channels
<<Processes: procedures>>=
  subroutine process_component_collect_channels (component, coll)
    class(process_component_t), intent(inout) :: component
    type(phs_channel_collection_t), intent(inout) :: coll
    call component%phs_config%collect_channels (coll)
  end subroutine process_component_collect_channels
    
@ %def process_component_collect_channels
@ Return the number of phase-space parameters.
<<Processes: process component: TBP>>=
  procedure :: get_n_phs_par => process_component_get_n_phs_par
<<Processes: procedures>>=
  function process_component_get_n_phs_par (component) result (n_par)
    class(process_component_t), intent(in) :: component
    integer :: n_par
    n_par = component%phs_config%get_n_par ()
  end function process_component_get_n_phs_par
    
@ %def process_component_get_n_phs_par
@ Return the incoming flavor combination as an array of PDG arrays,
one for a decay or two for a scattering process.
<<Processes: process component: TBP>>=
  procedure :: get_pdg_in => process_component_get_pdg_in
<<Processes: procedures>>=
  function process_component_get_pdg_in (component) result (pdg_in)
    class(process_component_t), intent(in) :: component
    type(pdg_array_t), dimension(:), allocatable :: pdg_in
    type(pdg_array_t) :: pdg_tmp
    integer :: i
    associate (data => component%core%data)
      allocate (pdg_in (data%n_in))
      do i = 1, data%n_in
         pdg_tmp = data%flv_state(i,:)
         pdg_in(i) = sort_abs (pdg_tmp, unique = .true.)
      end do
    end associate
  end function process_component_get_pdg_in
  
@ %def process_component_get_pdg_in
@
<<Processes: process component: TBP>>=
  procedure :: extract_phs_config => process_component_extract_phs_config
  procedure :: restore_phs_config => process_component_restore_phs_config
<<Processes: procedures>>=
  subroutine process_component_extract_phs_config (component, phs_config)
    class(process_component_t), intent(inout) :: component
    class(phs_config_t), intent(inout), allocatable :: phs_config
    call move_alloc (from = component%phs_config, to = phs_config)
  end subroutine process_component_extract_phs_config

  subroutine process_component_restore_phs_config (component, phs_config)
    class(process_component_t), intent(inout) :: component
    class(phs_config_t), intent(inout), allocatable :: phs_config
    call move_alloc (from = phs_config, to = component%phs_config)
  end subroutine process_component_restore_phs_config

@ %def process_component_fill_constants
@
\subsection{Process terms}
For straightforward tree-level calculations, each process component
corresponds to a unique elementary interaction.  However, in the case
of NLO calculations with subtraction terms, a process component may
split into several separate contributions to the scattering, which are
qualified by interactions with distinct kinematics and particle
content.  We represent their configuration as [[process_term_t]]
objects, the actual instances will be introduced below as
[[term_instance_t]].  In any case, the process term contains an
elementary interaction with a definite quantum-number and momentum
content.

The index [[i_term_global]] identifies the term relative to the
process.

The index [[i_component]] identifies the process component which
generates this term, relative to the parent process.

The index [[i_term]] identifies the term relative to the process
component (not the process).

The [[data]] subobject holds all process constants.

The number of allowed flavor/helicity/color combinations is stored as
[[n_allowed]].  This is the total number of independent entries in the
density matrix.  For each combination, the index of the flavor,
helicity, and color state is stored in the arrays [[flv]], [[hel]],
and [[col]], respectively.

The flag [[rearrange]] is true if we need to rearrange the particles of the
hard interaction, to obtain the effective parton state.

The interaction [[int]] holds the quantum state for the (resolved) hard
interaction, the parent-child relations of the particles, and their momenta.
The momenta are not filled yet; this is postponed to copies of [[int]] which
go into the process instances.

If recombination is in effect, we should allocate [[int_eff]] to describe the
rearranged partonic state.

This type is public only for use in a unit test.
<<Processes: public>>=
  public :: process_term_t
<<Processes: process part types>>=
  type :: process_term_t
     integer :: i_term_global = 0
     integer :: i_component = 0
     integer :: i_term = 0
     integer :: n_allowed = 0
     integer :: n_allowed_sub_born = 0
     type(process_constants_t) :: data
     real(default) :: alpha_s = 0
     integer, dimension(:), allocatable :: flv, hel, col
     logical :: rearrange = .false.
     type(interaction_t) :: int
     type(interaction_t), pointer :: int_eff => null ()
   contains
   <<Processes: process term: TBP>>
  end type process_term_t
  
@ %def process_term_t
@ For the output, we skip the process constants and the tables of
allowed quantum numbers.  Those can also be read off from the
interaction object.
<<Processes: process term: TBP>>=
  procedure :: write => process_term_write
<<Processes: procedures>>=
  subroutine process_term_write (term, unit)
    class(process_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A,I0)")  "Term #", term%i_term_global
    write (u, "(3x,A,I0)")  "Process component index      = ", &
         term%i_component
    write (u, "(3x,A,I0)")  "Term index w.r.t. component  = ", &
         term%i_term
    write (u, "(3x,A,L1)")  "Rearrange partons            = ", &
         term%rearrange
    call write_separator (u)
    write (u, "(1x,A)")  "Hard interaction:"
    call write_separator (u)
    call term%int%basic_write (u)
    if (term%rearrange) then
       call write_separator (u)
       write (u, "(1x,A)")  "Rearranged hard interaction:"
       call write_separator (u)
       call term%int_eff%basic_write (u)
    end if
  end subroutine process_term_write
     
@ %def process_term_write
@ Write an account of all quantum number states and their current status.
<<Processes: process term: TBP>>=
  procedure :: write_state_summary => process_term_write_state_summary
<<Processes: procedures>>=
  subroutine process_term_write_state_summary (term, core, unit)
    class(process_term_t), intent(in) :: term
    class(prc_core_t), intent(in) :: core
    integer, intent(in), optional :: unit
    integer :: u, i, f, h, c
    type(state_iterator_t) :: it
    character :: sgn
    u = given_output_unit (unit)
    write (u, "(1x,A,I0)")  "Term #", term%i_term_global
    call it%init (term%int%get_state_matrix_ptr ())
    do while (it%is_valid ())
       i = it%get_me_index ()
       f = term%flv(i)
       h = term%hel(i)
       c = term%col(i)
       if (core%is_allowed (term%i_term, f, h, c)) then
          sgn = "+"
       else
          sgn = " "
       end if
       write (u, "(1x,A1,1x,I0,2x)", advance="no")  sgn, i
       call quantum_numbers_write (it%get_quantum_numbers (), u)
       write (u, *)
       call it%advance ()
    end do
  end subroutine process_term_write_state_summary
  
@ %def process_term_write_state_summary
@ Finalizer: the [[int]] and potentially [[int_eff]] components have a
finalizer that we must call.
<<Processes: process term: TBP>>=
  procedure :: final => process_term_final
<<Processes: procedures>>=
  subroutine process_term_final (term)
    class(process_term_t), intent(inout) :: term
    call term%int%final ()
    if (term%rearrange) then
       call term%int_eff%final ()
       deallocate (term%int_eff)
    end if
  end subroutine process_term_final

@ %def process_term_final
@ Initialize the term.  We copy the process constants from the [[core]]
object and set up the [[int]] hard interaction accordingly.

The [[alpha_s]] value is useful for writing external event records.  This is
the constant value which may be overridden by a event-specific running value.
If the model does not contain the strong coupling, the value is zero.

The [[rearrange]] part is commented out; this or something equivalent
could become relevant for NLO algorithms.
<<Processes: process term: TBP>>=
  procedure :: init => process_term_init
<<Processes: procedures>>=
  subroutine process_term_init &
       (term, i_term_global, i_component, i_term, core, model)
    class(process_term_t), intent(inout), target :: term
    integer, intent(in) :: i_term_global
    integer, intent(in) :: i_component
    integer, intent(in) :: i_term
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    class(modelpar_data_t), pointer :: alpha_s_ptr
!    type(var_list_t), pointer :: var_list
    term%i_term_global = i_term_global
    term%i_component = i_component
    term%i_term = i_term
    call core%get_constants (term%data, i_term)
!    var_list => model%get_var_list_ptr ()
!    if (var_list%contains (var_str ("alphas"))) then
!       term%alpha_s = var_list%get_rval (var_list, var_str ("alphas"))
!    else
!       term%alpha_s = -1
!    end if
    alpha_s_ptr => model%get_par_data_ptr (var_str ("alphas"))
    if (associated (alpha_s_ptr)) then
       term%alpha_s = alpha_s_ptr%get_real ()
    else
       term%alpha_s = -1
    end if

    call term%setup_interaction (core, model)
!     if (term%rearrange) then
!       call term%setup_effective_interaction (core, term%int, term%int_eff)
!     end if
  end subroutine process_term_init
    
@ %def process_term_init
@ We fetch the process constants which determine the quantum numbers and
use those to create the interaction.  The interaction contains
incoming and outgoing particles, no virtuals.  The incoming particles
are parents of the outgoing ones.

Keeping previous \whizard\ conventions, we invert the color assignment
(but not flavor or helicity) for the incoming particles.  When the
color-flow square matrix is evaluated, this inversion is done again,
so in the color-flow sequence we get the color assignments of the
matrix element.
<<Processes: process term: TBP>>=
  procedure :: setup_interaction => process_term_setup_interaction
<<Processes: procedures>>=
  subroutine process_term_setup_interaction (term, core, model)
    class(process_term_t), intent(inout) :: term
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    integer :: n_tot
    type(flavor_t), dimension(:), allocatable :: flv
    type(color_t), dimension(:), allocatable :: col
    type(helicity_t), dimension(:), allocatable :: hel
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    integer :: i, n, f, h, c
    associate (data => term%data)
      n_tot = data%n_in + data%n_out
      n = 0
      do f = 1, data%n_flv
         do h = 1, data%n_hel
            do c = 1, data%n_col
               if (core%is_allowed (term%i_term, f, h, c))  n = n + 1
            end do
         end do
      end do
      allocate (term%flv (n), term%col (n), term%hel (n))
      term%n_allowed = n
      allocate (flv (n_tot), col (n_tot), hel (n_tot))
      allocate (qn (n_tot))
      call term%int%basic_init &
           (data%n_in, 0, data%n_out, set_relations=.true.)
      i = 0
      do f = 1, data%n_flv
         do h = 1, data%n_hel
            do c = 1, data%n_col
               if (core%is_allowed (term%i_term, f, h, c)) then
                  i = i + 1
                  term%flv(i) = f
                  term%hel(i) = h
                  term%col(i) = c
                  call flv%init (data%flv_state(:,f), model)
                  call color_init_from_array (col, &
                       data%col_state(:,:,c), &
                       data%ghost_flag(:,c))
                  call col(:data%n_in)%invert ()
                  call hel%init (data%hel_state(:,h))
                  call qn%init (flv, col, hel)
                  call term%int%add_state (qn)
               end if
            end do
         end do
      end do
      call term%int%freeze ()
    end associate
  end subroutine process_term_setup_interaction
  
@ %def process_term_setup_interaction
@
<<Processes: process term: TBP>>=
  procedure :: fetch_constants => process_term_fetch_process_constants
<<Processes: procedures>>= 
   subroutine process_term_fetch_process_constants &
       (term, prc_constants)
    class(process_term_t), intent(inout) :: term
    type(process_constants_t), intent(out) :: prc_constants
    prc_constants = term%data
  end subroutine process_term_fetch_process_constants

@ %def process_term_fetch_process_constants
@
\subsection{Process component manager}
This is the configuration object which has the duty of allocating the
corresponding instance.  The default version is trivial.
<<Processes: types>>=
  type, extends (pcm_t) :: pcm_default_t
   contains
   <<Processes: pcm default: TBP>>
  end type pcm_default_t
  
@ %def pcm_default_t
<<Processes: pcm default: TBP>>=
  procedure :: allocate_instance => pcm_default_allocate_instance
<<Processes: procedures>>=
  subroutine pcm_default_allocate_instance (pcm, instance)
    class(pcm_default_t), intent(in) :: pcm
    class(pcm_instance_t), intent(inout), allocatable :: instance
    allocate (pcm_instance_default_t :: instance)
  end subroutine pcm_default_allocate_instance
    
@ %def pcm_default_allocate_instance
<<Processes: types>>=
  type, extends (pcm_instance_t) :: pcm_instance_default_t
  end type pcm_instance_default_t
  
@ %def pcm_instance_default_t
@
\subsection{Default Iterations}
If the user does not specify the passes and iterations for
integration, we should be able to give reasonable defaults.  These
depend on the process, therefore we implement the following procedures
as methods of the process object.  The algorithm is not very
sophisticated yet, it may be improved by looking at the process in
more detail.

We investigate only the first process component, assuming that it
characterizes the complexity of the process reasonable well.

The number of passes is limited to two: one for adaption, one for
integration.
<<Processes: process: TBP>>=
  procedure :: get_n_pass_default => process_get_n_pass_default
  procedure :: adapt_grids_default => process_adapt_grids_default
  procedure :: adapt_weights_default => process_adapt_weights_default
<<Processes: procedures>>=
  function process_get_n_pass_default (process) result (n_pass)
    class(process_t), intent(in) :: process
    integer :: n_pass
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       n_pass = 1
    case default
       n_pass = 2
    end select
  end function process_get_n_pass_default
  
  function process_adapt_grids_default (process, pass) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    logical :: flag
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       flag = .false.
    case default
       select case (pass)
       case (1);  flag = .true.
       case (2);  flag = .false.
       case default
          call msg_bug ("adapt grids default: impossible pass index")
       end select
    end select
  end function process_adapt_grids_default
  
  function process_adapt_weights_default (process, pass) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    logical :: flag
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (n_eff)
    case (1)
       flag = .false.
    case default
       select case (pass)
       case (1);  flag = .true.
       case (2);  flag = .false.
       case default
          call msg_bug ("adapt weights default: impossible pass index")
       end select
    end select
  end function process_adapt_weights_default
  
@ %def process_get_n_pass_default
@ %def process_adapt_grids_default
@ %def process_adapt_weights_default
@ The number of iterations and calls per iteration depends on the
number of outgoing particles.
<<Processes: process: TBP>>=
  procedure :: get_n_it_default => process_get_n_it_default
  procedure :: get_n_calls_default => process_get_n_calls_default
<<Processes: procedures>>=
  function process_get_n_it_default (process, pass) result (n_it)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    integer :: n_it
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (pass)
    case (1)
       select case (n_eff)
       case (1);   n_it = 1
       case (2);   n_it = 3
       case (3);   n_it = 5
       case (4:5); n_it = 10
       case (6);   n_it = 15
       case (7:);  n_it = 20
       end select
    case (2)
       select case (n_eff)
       case (:3);   n_it = 3
       case (4:);   n_it = 5
       end select
    end select
  end function process_get_n_it_default
  
  function process_get_n_calls_default (process, pass) result (n_calls)
    class(process_t), intent(in) :: process
    integer, intent(in) :: pass
    integer :: n_calls
    integer :: n_eff
    type(process_component_def_t), pointer :: config
    config => process%component(1)%config
    n_eff = config%get_n_tot () - 2
    select case (pass)
    case (1)
       select case (n_eff)
       case (1);   n_calls =   100
       case (2);   n_calls =  1000
       case (3);   n_calls =  5000
       case (4);   n_calls = 10000
       case (5);   n_calls = 20000
       case (6:);  n_calls = 50000
       end select
    case (2)
       select case (n_eff)
       case (:3);  n_calls =  10000
       case (4);   n_calls =  20000
       case (5);   n_calls =  50000
       case (6);   n_calls = 100000
       case (7:);  n_calls = 200000
       end select
    end select
  end function process_get_n_calls_default
  
@ %def process_get_n_it_default
@ %def process_get_n_calls_default
@ 
\subsection{Constant process data}
The following methods return basic process data that stay constant
after initialization.

The process and IDs.
<<Processes: process: TBP>>=
  procedure :: get_id => process_get_id
  procedure :: get_num_id => process_get_num_id
  procedure :: get_run_id => process_get_run_id
  procedure :: get_library_name => process_get_library_name
<<Processes: procedures>>=
  function process_get_id (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%id
  end function process_get_id

  function process_get_num_id (process) result (id)
    class(process_t), intent(in) :: process
    integer :: id
    id = process%meta%num_id
  end function process_get_num_id

  function process_get_run_id (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%run_id
  end function process_get_run_id

  function process_get_library_name (process) result (id)
    class(process_t), intent(in) :: process
    type(string_t) :: id
    id = process%meta%lib%get_name ()
  end function process_get_library_name

@ %def process_get_id process_get_num_id 
@ %def process_get_run_id process_get_library_name
@ The number of incoming particles.
<<Processes: process: TBP>>=
  procedure :: get_n_in => process_get_n_in
<<Processes: procedures>>=
  function process_get_n_in (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_in
  end function process_get_n_in
    
@ %def process_get_n_in
@ The number of MCI data sets.
<<Processes: process: TBP>>=
  procedure :: get_n_mci => process_get_n_mci
<<Processes: procedures>>=
  function process_get_n_mci (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_mci
  end function process_get_n_mci
    
@ %def process_get_n_mci
@ The number of process components, total.
<<Processes: process: TBP>>=
  procedure :: get_n_components => process_get_n_components
<<Processes: procedures>>=
  function process_get_n_components (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%meta%n_components
  end function process_get_n_components
    
@ %def process_get_n_components
@ The number of process terms, total.
<<Processes: process: TBP>>=
  procedure :: get_n_terms => process_get_n_terms
<<Processes: procedures>>=
  function process_get_n_terms (process) result (n)
    class(process_t), intent(in) :: process
    integer :: n
    n = process%config%n_terms
  end function process_get_n_terms
    
@ %def process_get_n_terms
@ Return the indices of the components that belong to a
specific MCI entry.
<<Processes: process: TBP>>=
  procedure :: get_i_component => process_get_i_component
<<Processes: procedures>>=
  subroutine process_get_i_component (process, i_mci, i_component)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_mci
    integer, dimension(:), intent(out), allocatable :: i_component
    associate (mci_entry => process%mci_entry(i_mci))
      allocate (i_component (size (mci_entry%i_component)))
      i_component = mci_entry%i_component
    end associate
  end subroutine process_get_i_component

@ %def process_get_i_component
@ Return the ID of a specific component.
<<Processes: process: TBP>>=
  procedure :: get_component_id => process_get_component_id
<<Processes: procedures>>=
  function process_get_component_id (process, i_component) result (id)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    type(string_t) :: id
    id = process%meta%component_id(i_component)
  end function process_get_component_id
    
@ %def process_get_component_id
@ Return a pointer to the definition of a specific component.
<<Processes: process: TBP>>=
  procedure :: get_component_def_ptr => process_get_component_def_ptr
<<Processes: procedures>>=
  function process_get_component_def_ptr (process, i_component) result (ptr)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i_component
    type(process_component_def_t), pointer :: ptr
    ptr => process%meta%lib%get_component_def_ptr (process%meta%id, i_component)
  end function process_get_component_def_ptr
  
@ %def process_get_component_def_ptr
@ These procedures extract and restore (by transferring the
allocation) the process core.  This is useful for changing process
parameters from outside this module.
<<Processes: process: TBP>>=
  procedure :: extract_component_core => process_extract_component_core
  procedure :: restore_component_core => process_restore_component_core
<<Processes: procedures>>=
  subroutine process_extract_component_core (process, i_component, core)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_component
    class(prc_core_t), intent(inout), allocatable :: core
    call move_alloc (from = process%component(i_component)%core, to = core)
  end subroutine process_extract_component_core
    
  subroutine process_restore_component_core (process, i_component, core)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_component
    class(prc_core_t), intent(inout), allocatable :: core
    call move_alloc (from = core, to = process%component(i_component)%core)
  end subroutine process_restore_component_core
    
@ %def process_extract_component_core
@ %def process_restore_component_core
@ The block of process constants.
<<Processes: process: TBP>>=
  procedure :: get_constants => process_get_constants
<<Processes: procedures>>=
  function process_get_constants (process, i) result (data)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i
    type(process_constants_t) :: data
    data = process%component(i)%core%data
  end function process_get_constants
  
@ %def process_get_constants
@ Return the set of outgoing flavors that are associated with a particular
term. We deduce this from the effective interaction.
<<Processes: process: TBP>>=
  procedure :: get_term_flv_out => process_get_term_flv_out
<<Processes: procedures>>=
  subroutine process_get_term_flv_out (process, i_term, flv)
    class(process_t), intent(in), target :: process
    integer, intent(in) :: i_term
    type(flavor_t), dimension(:,:), allocatable, intent(out) :: flv
    type(interaction_t), pointer :: int
    int => process%term(i_term)%int_eff
    if (.not. associated (int))  int => process%term(i_term)%int
    call interaction_get_flv_out (int, flv)
  end subroutine process_get_term_flv_out

@ %def process_get_term_flv_out
@ Return true if there is any unstable particle in any of the process
terms.  We decide this based on the provided model instance, not the
one that is stored in the process object.
<<Processes: process: TBP>>=
  procedure :: contains_unstable => process_contains_unstable
<<Processes: procedures>>=
  function process_contains_unstable (process, model) result (flag)
    class(process_t), intent(in) :: process
    class(model_data_t), intent(in), target :: model
    logical :: flag
    integer :: i_term
    type(flavor_t), dimension(:,:), allocatable :: flv
    flag = .false.
    do i_term = 1, process%get_n_terms ()
       call process%get_term_flv_out (i_term, flv)
       call flv%set_model (model)
       flag = .not. all (flv%is_stable ())
       deallocate (flv)
       if (flag)  return
    end do
  end function process_contains_unstable
    
@ %def process_contains_unstable
@ The nominal process energy.
<<Processes: process: TBP>>=
  procedure :: get_sqrts => process_get_sqrts
<<Processes: procedures>>=
  function process_get_sqrts (process) result (sqrts)
    class(process_t), intent(in) :: process
    real(default) :: sqrts
    sqrts = beam_data_get_sqrts (process%beam_config%data)
  end function process_get_sqrts
  
@ %def process_get_sqrts
<<Processes: process: TBP>>=
  procedure :: has_matrix_element => process_has_matrix_element
<<Processes: procedures>>=
  function process_has_matrix_element (process, i) result (flag)
    class(process_t), intent(in) :: process
    integer, intent(in), optional :: i
    logical :: flag
    if (present (i)) then
       flag = process%component(i)%active
    else
       flag = any (process%component%active)
    end if
  end function process_has_matrix_element
  
@ %def process_has_matrix_element
@ Pointer to the beam data object.
<<Processes: process: TBP>>=
  procedure :: get_beam_data_ptr => process_get_beam_data_ptr
<<Processes: procedures>>=
  function process_get_beam_data_ptr (process) result (beam_data)
    class(process_t), intent(in), target :: process
    type(beam_data_t), pointer :: beam_data
    beam_data => process%beam_config%data
  end function process_get_beam_data_ptr

@ %def process_get_beam_data_ptr
@ Return true if lab and c.m.\ frame coincide for this process.
<<Processes: process: TBP>>=
  procedure :: cm_frame => process_cm_frame
<<Processes: procedures>>=
  function process_cm_frame (process) result (flag)
    class(process_t), intent(in), target :: process
    logical :: flag
    type(beam_data_t), pointer :: beam_data
    beam_data => process%beam_config%data
    flag = beam_data_cm_frame (beam_data)
  end function process_cm_frame
  
@ %def process_cm_frame
@ Get the PDF set currently in use, if any.
<<Processes: process: TBP>>=
  procedure :: get_pdf_set => process_get_pdf_set
<<Processes: procedures>>=
  function process_get_pdf_set (process) result (pdf_set)
    class(process_t), intent(in) :: process
    integer :: pdf_set
    pdf_set = process%beam_config%get_pdf_set ()
  end function process_get_pdf_set
  
@ %def process_get_pdf_set
@ Pointer to the process variable list.
<<Processes: process: TBP>>=
  procedure :: get_var_list_ptr => process_get_var_list_ptr
<<Processes: procedures>>=
  function process_get_var_list_ptr (process) result (ptr)
    class(process_t), intent(in), target :: process
    type(var_list_t), pointer :: ptr
    ptr => process%meta%var_list
  end function process_get_var_list_ptr
  
@ %def process_get_var_list_ptr
@ Pointer to the common model.
<<Processes: process: TBP>>=
  procedure :: get_model_ptr => process_get_model_ptr
<<Processes: procedures>>=
  function process_get_model_ptr (process) result (ptr)
    class(process_t), intent(in) :: process
    class(model_data_t), pointer :: ptr
    ptr => process%config%model
  end function process_get_model_ptr
  
@ %def process_get_model_ptr
@ Use the embedded RNG factory to spawn a new random-number generator
instance.  (This modifies the state of the factory.)
<<Processes: process: TBP>>=
  procedure :: make_rng => process_make_rng
<<Processes: procedures>>=
  subroutine process_make_rng (process, rng)
    class(process_t), intent(inout) :: process
    class(rng_t), intent(out), allocatable :: rng
    if (allocated (process%config%rng_factory)) then
       call process%config%rng_factory%make (rng)
    else
       call msg_bug ("Process: make rng: factory not allocated")
    end if
  end subroutine process_make_rng
  
@ %def process_make_rng
@
\subsection{Compute an amplitude}
Each process variant should allow for computing an amplitude value
directly, without generating a process instance. 

The process component is selected by the index [[i]].  The term within the
process component is selected by [[j]].  The momentum
combination is transferred as the array [[p]].  The function sets the specific
quantum state via the indices of a flavor [[f]], helicity [[h]], and color
[[c]] combination.  Each index refers to the list of flavor, helicity, and
color states, respectively, as stored in the process data.

Optionally, we may set factorization and renormalization scale.  If unset, the
partonic c.m.\ energy is inserted.

The function checks arguments for validity.
For invalid arguments (quantum states), we return zero.
<<Processes: process: TBP>>=
  procedure :: compute_amplitude => process_compute_amplitude
<<Processes: procedures>>=
  function process_compute_amplitude &
       (process, i, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced) &
       result (amp)
    class(process_t), intent(in) :: process
    integer, intent(in) :: i, j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in), optional :: fac_scale, ren_scale
    real(default), intent(in), allocatable, optional :: alpha_qcd_forced
    real(default) :: fscale, rscale
    real(default), allocatable :: aqcd_forced
    complex(default) :: amp
    amp = 0
    if (0 < i .and. i <= process%meta%n_components) then
       if (process%component(i)%active) then
          associate (data => process%component(i)%core%data)
            if (size (p) == data%n_in + data%n_out &
                 .and. 0 < f .and. f <= data%n_flv &
                 .and. 0 < h .and. h <= data%n_hel &
                 .and. 0 < c .and. c <= data%n_col) then
               if (present (fac_scale)) then
                  fscale = fac_scale
               else
                  fscale = sum (p(data%n_in+1:)) ** 1
               end if
               if (present (ren_scale)) then
                  rscale = ren_scale
               else
                  rscale = fscale
               end if
               if (present (alpha_qcd_forced)) then
                  if (allocated (alpha_qcd_forced)) &
                       allocate (aqcd_forced, source = alpha_qcd_forced)
               end if
               amp = process%component(i)%core%compute_amplitude &
                    (j, p, f, h, c, fscale, rscale, aqcd_forced)
            end if
          end associate
       else
          amp = 0
       end if
    end if
  end function process_compute_amplitude

@ %def process_compute_amplitude
@ 
\subsubsection{Auxiliary}
<<Processes: process: TBP>>=
  procedure :: set_component_type => process_set_component_type
<<Processes: procedures>>=
  subroutine process_set_component_type (process, i_component, i_type)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: i_component, i_type
    process%component(i_component)%component_type = i_type
  end subroutine process_set_component_type

@ %def process_set_component_type
@
<<Processes: process: TBP>>=
  procedure :: set_associated_real_component => process_set_associated_real_component
<<Processes: procedures>>=
  subroutine process_set_associated_real_component (process, i_mci, i_component)
     class(process_t), intent(inout) :: process
     integer, intent(in) :: i_mci, i_component
     process%mci_entry(i_mci)%associated_real_component = i_component
  end subroutine process_set_associated_real_component

@ %def process_set_associated_real_component
@
<<Processes: process: TBP>>=
  procedure :: get_associated_real_component => process_get_associated_real_component
<<Processes: procedures>>=
  function process_get_associated_real_component (process, i_mci) result (i_component)
     integer :: i_component
     class(process_t), intent(in) :: process
     integer, intent(in) :: i_mci
     i_component = process%mci_entry(i_mci)%associated_real_component
  end function process_get_associated_real_component

@ %def process_get_associated_real_component
@ This is for suppression of numerical noise in the integration results
stored in the [[process_mci_entry]] type. As the error and efficiency
enter the MD5 sum, we recompute it. 
<<Processes: process: TBP>>=
  procedure :: pacify => process_pacify
<<Processes: procedures>>=
  subroutine process_pacify (process, efficiency_reset, error_reset)
    class(process_t), intent(inout) :: process
    logical, intent(in), optional :: efficiency_reset, error_reset
    logical :: eff_reset, err_reset
    integer :: i
    eff_reset = .false.
    err_reset = .false.
    if (present (efficiency_reset))  eff_reset = efficiency_reset
    if (present (error_reset))  err_reset = error_reset
    if (allocated (process%mci_entry)) then
       do i = 1, size (process%mci_entry)
          call process%mci_entry(i)%results%pacify (efficiency_reset)
          if (allocated (process%mci_entry(i)%mci)) then
             associate (mci => process%mci_entry(i)%mci)
               if (process%mci_entry(i)%mci%error_known &
                    .and. err_reset) &
                    mci%error = 0
               if (process%mci_entry(i)%mci%efficiency_known &
                    .and. eff_reset)  &
                    mci%efficiency = 1             
               call mci%pacify (efficiency_reset, error_reset)
               call mci%compute_md5sum ()
             end associate
          end if
       end do
    end if
  end subroutine process_pacify

@ %def process_pacify
@
The following methods are used only in the unit tests; the access process
internals directly that would otherwise be hidden.
@
\subsection{Process instances}
<<Processes: process: TBP>>=
  procedure :: test_allocate_sf_channels
  procedure :: test_set_component_sf_channel
  procedure :: test_get_mci_ptr
<<Processes: procedures>>=
  subroutine test_allocate_sf_channels (process, n)
    class(process_t), intent(inout) :: process
    integer, intent(in) :: n
    call process%beam_config%allocate_sf_channels (n)
  end subroutine test_allocate_sf_channels
    
  subroutine test_set_component_sf_channel (process, c)
    class(process_t), intent(inout) :: process
    integer, dimension(:), intent(in) :: c
    call process%component(1)%phs_config%set_sf_channel (c)
  end subroutine test_set_component_sf_channel
    
  subroutine test_get_mci_ptr (process, mci)
    class(process_t), intent(in), target :: process
    class(mci_t), intent(out), pointer :: mci
    mci => process%mci_entry(1)%mci
  end subroutine test_get_mci_ptr

@ %def test_allocate_sf_channels
@ %def test_set_component_sf_channel
@ %def test_get_mci_ptr
@
\subsubsection{Kinematics instance}
In this data type we combine all objects (instances) necessary for
generating (or recovering) a kinematical configuration.  The
components work together as an implementation of multi-channel phase
space.

[[sf_chain]] is an instance of the structure-function chain.  It is
used both for generating kinematics and, after the proper scale has
been determined, evaluating the structure function entries.

[[phs]] is an instance of the phase space for the elementary process.

The array [[f]] contains the products of the Jacobians that originate
from parameter mappings in the structure-function chain or in the
phase space.  We allocate this explicitly if either [[sf_chain]] or
[[phs]] are explicitly allocated, otherwise we can take over a pointer.

All components are implemented as pointers to (anonymous) targets.
For each component, there is a flag that tells whether this component
is to be regarded as a proper component (`owned' by the object) or as
a pointer.
<<Processes: types>>=
  type :: kinematics_t
     integer :: n_in = 0
     integer :: n_channel = 0
     integer :: selected_channel = 0
     type(sf_chain_instance_t), pointer :: sf_chain => null ()
     class(phs_t), pointer :: phs => null ()
     real(default), dimension(:), pointer :: f => null ()
     real(default) :: phs_factor
     logical :: sf_chain_allocated = .false.
     logical :: phs_allocated = .false.
     logical :: f_allocated = .false.
     integer :: nlo_type
     integer :: emitter
   contains
   <<Processes: kinematics: TBP>>
  end type kinematics_t

@ %def kinematics_t
@ Output.  Show only those components which are marked as owned.
<<Processes: kinematics: TBP>>=
  procedure :: write => kinematics_write
<<Processes: procedures>>=
  subroutine kinematics_write (object, unit)
    class(kinematics_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, c
    u = given_output_unit (unit)
    if (object%f_allocated) then
       write (u, "(1x,A)")  "Flux * PHS volume:"
       write (u, "(2x,ES19.12)")  object%phs_factor
       write (u, "(1x,A)")  "Jacobian factors per channel:"
       do c = 1, size (object%f)
          write (u, "(3x,I0,':',1x,ES13.7)", advance="no")  c, object%f(c)
          if (c == object%selected_channel) then
             write (u, "(1x,A)")  "[selected]"
          else
             write (u, *)
          end if
       end do
    end if
    if (object%sf_chain_allocated) then
       call write_separator (u)
       call object%sf_chain%write (u)
    end if
    if (object%phs_allocated) then
       call write_separator (u)
       call object%phs%write (u)
    end if
  end subroutine kinematics_write
    
@ %def kinematics_write
@ Finalizer.  Delete only those components which are marked as owned.
<<Processes: kinematics: TBP>>=
  procedure :: final => kinematics_final
<<Processes: procedures>>=
  subroutine kinematics_final (object)
    class(kinematics_t), intent(inout) :: object
    if (object%sf_chain_allocated) then
       call object%sf_chain%final ()
       deallocate (object%sf_chain)
       object%sf_chain_allocated = .false.
    end if
    if (object%phs_allocated) then
       call object%phs%final ()
       deallocate (object%phs)
       object%phs_allocated = .false.
    end if
    if (object%f_allocated) then
       deallocate (object%f)
       object%f_allocated = .false.
    end if
  end subroutine kinematics_final
  
@ %def kinematics_final
@ Set the flags indicating whether the phase space shall be set up for the calculation of the real contribution. For this case, also set the emitter.
<<Processes: kinematics: TBP>>=
  procedure :: set_nlo_info => kinematics_set_nlo_info
<<Processes: procedures>>=
  subroutine kinematics_set_nlo_info (k, nlo_type, emitter)
    class(kinematics_t), intent(inout) :: k
    integer, intent(in) :: nlo_type
    integer, intent(in), optional :: emitter
    k%nlo_type = nlo_type
    if (present (emitter)) then
      k%emitter = emitter
    end if
  end subroutine kinematics_set_nlo_info

@ %def kinematics_set_nlo_info
@ Allocate the structure-function chain instance, initialize it as a
copy of the [[sf_chain]] template, and prepare it for evaluation.

The [[sf_chain]] remains a target because the (usually constant) beam momenta
are taken from there.
<<Processes: kinematics: TBP>>=
  procedure :: init_sf_chain => kinematics_init_sf_chain
<<Processes: procedures>>=
  subroutine kinematics_init_sf_chain (k, core, sf_chain, config, core_state)
    class(kinematics_t), intent(inout) :: k
    class(prc_core_t), intent(in) :: core
    type(sf_chain_t), intent(in), target :: sf_chain
    type(process_beam_config_t), intent(in) :: config
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_strfun, n_channel
    integer :: c
    k%n_in = beam_data_get_n_in (config%data)
    n_strfun = config%n_strfun
    n_channel = config%n_channel
    allocate (k%sf_chain)
    k%sf_chain_allocated = .true.
    call core%init_sf_chain (k%sf_chain, sf_chain, n_channel, core_state)
    if (n_strfun /= 0) then
       do c = 1, n_channel
          call k%sf_chain%set_channel (c, config%sf_channel(c))
       end do
    end if
    call k%sf_chain%link_interactions ()
    call k%sf_chain%exchange_mask ()
    call k%sf_chain%init_evaluators ()
  end subroutine kinematics_init_sf_chain

@ %def kinematics_init_sf_chain
@ Allocate and initialize the phase-space part and the array of
Jacobian factors.
<<Processes: kinematics: TBP>>=
  procedure :: init_phs => kinematics_init_phs
<<Processes: procedures>>=
  subroutine kinematics_init_phs (k, config)
    class(kinematics_t), intent(inout) :: k
    class(phs_config_t), intent(in), target :: config
    k%n_channel = config%get_n_channel ()
    call config%allocate_instance (k%phs)
    call k%phs%init (config)
    k%phs_allocated = .true.
    allocate (k%f (k%n_channel))
    k%f = 0
    k%f_allocated = .true.
  end subroutine kinematics_init_phs
    
@ %def kinematics_init_phs
@ Initialize the kinematics in form of simple pointers.  In essence,
this is a shallow copy, but we have to set the flags correctly to
indicate this fact.
<<Processes: kinematics: TBP>>=
  procedure :: init_ptr => kinematics_init_ptr
<<Processes: procedures>>=
  subroutine kinematics_init_ptr (k, k_in)
    class(kinematics_t), intent(out) :: k
    type(kinematics_t), intent(in) :: k_in
    k%n_in = k_in%n_in
    k%n_channel = k_in%n_channel
    k%sf_chain => k_in%sf_chain
    k%phs => k_in%phs
    k%f => k_in%f
  end subroutine kinematics_init_ptr
  
@ %def kinematics_init_ptr
@ Generate kinematics, given a phase-space channel and a MC
parameter set. The main result is the momentum array [[p]], but we
also fill the momentum entries in the structure-function chain and the
Jacobian-factor array [[f]].  Regarding phase space, We fill only the
parameter arrays for the selected channel.
<<Processes: kinematics: TBP>>=
  procedure :: compute_selected_channel => kinematics_compute_selected_channel
<<Processes: procedures>>=
  subroutine kinematics_compute_selected_channel &
       (k, mci_work, phs_channel, p, success, nlo_controller)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    type(vector4_t), dimension(:), intent(out) :: p
    logical, intent(out) :: success
    type(nlo_controller_t), intent(inout), optional :: nlo_controller
    integer :: sf_channel
    k%selected_channel = phs_channel
    sf_channel = k%phs%config%get_sf_channel (phs_channel)
    call k%sf_chain%compute_kinematics (sf_channel, mci_work%get_x_strfun ())
    call k%sf_chain%get_out_momenta (p(1:k%n_in))
    call k%phs%set_incoming_momenta (p(1:k%n_in))
    call k%phs%compute_flux ()
    call k%phs%select_channel (phs_channel)
    call k%phs%evaluate_selected_channel &
           (phs_channel, mci_work%get_x_process ())

    select type (phs => k%phs)
    type is (phs_fks_t)
      if (phs%q_defined) then
         call phs%get_born_momenta (p)
         k%phs_factor = phs%get_overall_factor ()
         success = .true.
      else
         k%phs_factor = 0
         success = .false.
      end if
    class default
      if (phs%q_defined) then
         call k%phs%get_outgoing_momenta (p(k%n_in+1:))
         k%phs_factor = k%phs%get_overall_factor ()
         success = .true.
      else
         k%phs_factor = 0
         success = .false.
      end if
    end select
  end subroutine kinematics_compute_selected_channel
  
@ %def kinematics_compute_selected_channel
@ Complete kinematics by filling the non-selected phase-space parameter
arrays.
<<Processes: kinematics: TBP>>=
  procedure :: compute_other_channels => kinematics_compute_other_channels
<<Processes: procedures>>=
  subroutine kinematics_compute_other_channels (k, mci_work, phs_channel)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    integer :: c, c_sf
    call k%phs%evaluate_other_channels (phs_channel)
    do c = 1, k%n_channel
       c_sf = k%phs%config%get_sf_channel (c)
       k%f(c) = k%sf_chain%get_f (c_sf) * k%phs%get_f (c)
    end do
  end subroutine kinematics_compute_other_channels
  
@ %def kinematics_compute_other_channels
@ Just fetch the outgoing momenta of the [[sf_chain]] subobject, which
become the incoming (seed) momenta of the hard interaction.

This is a stripped down-version of the above which we use when
recovering kinematics.  Momenta are known, but no MC parameters yet.

(We do not use the [[get_out_momenta]] method of the chain, since this
relies on the structure-function interactions, which are not necessary
filled here.  We do rely on the momenta of the last evaluator in the
chain, however.)
<<Processes: kinematics: TBP>>=
  procedure :: get_incoming_momenta => kinematics_get_incoming_momenta
<<Processes: procedures>>=
  subroutine kinematics_get_incoming_momenta (k, p)
    class(kinematics_t), intent(in) :: k
    type(vector4_t), dimension(:), intent(out) :: p
    type(interaction_t), pointer :: int
    integer :: i
    int => k%sf_chain%get_out_int_ptr ()
    do i = 1, k%n_in
       p(i) = int%get_momentum (k%sf_chain%get_out_i (i))
    end do
  end subroutine kinematics_get_incoming_momenta
  
@ %def kinematics_get_incoming_momenta
@ This inverts the remainder of the above [[compute]] method.  We know
the momenta and recover the rest, as far as needed.  If we select a
channel, we can complete the inversion and reconstruct the 
MC parameter set.
<<Processes: kinematics: TBP>>=
  procedure :: recover_mcpar => kinematics_recover_mcpar
<<Processes: procedures>>=
  subroutine kinematics_recover_mcpar (k, mci_work, phs_channel, p)
    class(kinematics_t), intent(inout) :: k
    type(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: phs_channel
    type(vector4_t), dimension(:), intent(in) :: p
    integer :: c, c_sf
    real(default), dimension(:), allocatable :: x_sf, x_phs
    c = phs_channel
    c_sf = k%phs%config%get_sf_channel (c)
    k%selected_channel = c
    call k%sf_chain%recover_kinematics (c_sf)
    call k%phs%set_incoming_momenta (p(1:k%n_in))
    call k%phs%compute_flux ()
    call k%phs%set_outgoing_momenta (p(k%n_in+1:))
    call k%phs%inverse ()
    do c = 1, k%n_channel
       c_sf = k%phs%config%get_sf_channel (c)
       k%f(c) = k%sf_chain%get_f (c_sf) * k%phs%get_f (c)
    end do
    k%phs_factor = k%phs%get_overall_factor ()
    c = phs_channel
    c_sf = k%phs%config%get_sf_channel (c)
    allocate (x_sf (k%sf_chain%config%get_n_bound ()))
    allocate (x_phs (k%phs%config%get_n_par ()))
    call k%phs%select_channel (c)
    call k%sf_chain%get_mcpar (c_sf, x_sf)
    call k%phs%get_mcpar (c, x_phs)
    call mci_work%set_x_strfun (x_sf)
    call mci_work%set_x_process (x_phs)
  end subroutine kinematics_recover_mcpar

@ %def kinematics_recover_mcpar
@ Retrieve the MC input parameter array for a specific channel.  We assume
that the kinematics is complete, so this is known for all channels.
<<Processes: kinematics: TBP>>=
  procedure :: get_mcpar => kinematics_get_mcpar
<<Processes: procedures>>=
  subroutine kinematics_get_mcpar (k, phs_channel, r)
    class(kinematics_t), intent(in) :: k
    integer, intent(in) :: phs_channel
    real(default), dimension(:), intent(out) :: r
    integer :: sf_channel, n_par_sf, n_par_phs
    sf_channel = k%phs%config%get_sf_channel (phs_channel)
    n_par_phs = k%phs%config%get_n_par ()
    n_par_sf = k%sf_chain%config%get_n_bound ()
    if (n_par_sf > 0) then
       call k%sf_chain%get_mcpar (sf_channel, r(1:n_par_sf))
    end if
    if (n_par_phs > 0) then
       call k%phs%get_mcpar (phs_channel, r(n_par_sf+1:))
    end if
  end subroutine kinematics_get_mcpar
  
@ %def kinematics_get_mcpar
@ Evaluate the structure function chain, assuming that kinematics is known.

The status must be precisely [[SF_DONE_KINEMATICS]].  We thus avoid
evaluating the chain twice via different pointers to the same target.
<<Processes: kinematics: TBP>>=
  procedure :: evaluate_sf_chain => kinematics_evaluate_sf_chain
<<Processes: procedures>>=
  subroutine kinematics_evaluate_sf_chain (k, fac_scale)
    class(kinematics_t), intent(inout) :: k
    real(default), intent(in) :: fac_scale
    select case (k%sf_chain%get_status ())
    case (SF_DONE_KINEMATICS)
       call k%sf_chain%evaluate (fac_scale)
    end select
  end subroutine kinematics_evaluate_sf_chain
  
@ %def kinematics_evaluate_sf_chain
@ Recover beam momenta, i.e., return the beam momenta stored in the
current [[sf_chain]] to their source.  This is a side effect.
<<Processes: kinematics: TBP>>=
  procedure :: return_beam_momenta => kinematics_return_beam_momenta
<<Processes: procedures>>=
  subroutine kinematics_return_beam_momenta (k)
    class(kinematics_t), intent(in) :: k
    call k%sf_chain%return_beam_momenta ()
  end subroutine kinematics_return_beam_momenta
  
@ %def kinematics_return_beam_momenta
@
\subsubsection{Process component instance}
The actual calculation of a sampling point is done from here.

The [[config]] pointer accesses the corresponding
configuration in the [[process]] object.

The [[active]] flag indicates that we are currently computing this
component, together with all other components that share the same MC
parameter set.  Inactive components are using a different MC parameter
set and are not in use for this sampling point.

The [[k_seed]] subobject contains the kinematics (structure-function
chain, phase space, etc.) that implements the `seed' configuration of
momenta.  This version of the process kinematics is accessed by the MCI
setup.

[[p_seed]] is the array of momenta that we compute from the MC input
parameters, via the [[k_seed]] subobject.  Depending on the process
variant, these may or may not coincide with the momenta that enter the
process terms associated to this component.

The [[core_state]] object can be used for storing intermediate results.  Its precise
type and contents depend on the process variant.
<<Processes: types>>=
  type :: component_instance_t
     type(process_component_t), pointer :: config => null ()
     logical :: active = .false.
     type(kinematics_t) :: k_seed
     type(vector4_t), dimension(:), allocatable :: p_seed
     logical :: sqme_known = .false.
     real(default) :: sqme = 0
     class(prc_core_state_t), allocatable :: core_state
     type(nlo_controller_t), pointer :: nlo_controller => null ()
     integer :: nlo_type = BORN
   contains
   <<Processes: component instance: TBP>>
  end type component_instance_t
  
@ %def component_instance_t
@ In the header, fetch the component index from the configuration record.
[[process_component_t]] configuration block.

We write the [[sf_chain]] subobject only upon request, since its instances
appear elsewhere.
<<Processes: component instance: TBP>>=
  procedure :: write => component_instance_write
<<Processes: procedures>>=
  subroutine component_instance_write (object, unit, testflag)
    class(component_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    if (object%active) then
       if (associated (object%config)) then
          write (u, "(1x,A,I0)")  "Component #", object%config%index
       else
          write (u, "(1x,A)")  "Component [undefined]"
       end if
    else
       write (u, "(1x,A,I0,A)")  "Component #", object%config%index, &
            " [inactive]"
    end if
    if (allocated (object%p_seed)) then
       write (u, "(1x,A)")  "Seed momenta:"
       do i = 1, size (object%p_seed)
          call vector4_write (object%p_seed(i), u, testflag = testflag)
       end do
    end if
    write (u, "(1x,A)")  "Squared matrix element:"
    if (object%sqme_known) then
       write (u, "(2x,ES19.12)")  object%sqme
    else
       write (u, "(2x,A)")  "[undefined]"
    end if
    call object%k_seed%write (u)
    if (allocated (object%core_state)) then
       call write_separator (u)
       call object%core_state%write (u)
    end if
  end subroutine component_instance_write
    
@ %def component_instance_write
@ Finalizer
<<Processes: component instance: TBP>>=
  procedure :: final => component_instance_final
<<Processes: procedures>>=
  subroutine component_instance_final (object)
    class(component_instance_t), intent(inout) :: object
    call object%k_seed%final ()
  end subroutine component_instance_final
  
@ %def component_instance_final
@ Initialize: associate the configuration pointer.  Also initialize the
process workspace, if there is anything to do.  This initialization is a
matter of the process core.
<<Processes: component instance: TBP>>=
  procedure :: init => component_instance_init
<<Processes: procedures>>=
  subroutine component_instance_init (component, config)
    class(component_instance_t), intent(out) :: component
    type(process_component_t), intent(in), target :: config
    integer :: nlo_type
    integer :: n_in, n_tot
    component%config => config
    nlo_type = component%config%config%get_nlo_type ()
    component%nlo_type = nlo_type
    associate (core => component%config%core)
      n_in = core%data%n_in
      n_tot = n_in + core%data%n_out
      select case (nlo_type)
      case (NLO_REAL)
        allocate (component%p_seed (n_tot-1))
      case (BORN, NLO_VIRTUAL, NLO_PDF)
        allocate (component%p_seed (n_tot))
      end select
      call core%allocate_workspace (component%core_state)
    end associate
  end subroutine component_instance_init

@ %def component_instance_init
@ Initialize the seed-kinematics configuration.  All subobjects are
allocated explicitly.
<<Processes: component instance: TBP>>=
  procedure :: setup_kinematics => component_instance_setup_kinematics
<<Processes: procedures>>=
  subroutine component_instance_setup_kinematics (component, sf_chain, config, &
                                                  combined_integration)
    class(component_instance_t), intent(inout) :: component
    type(sf_chain_t), intent(in), target :: sf_chain
    type(process_beam_config_t), intent(in) :: config
    logical, intent(in), optional :: combined_integration
    integer :: nlo_type
    nlo_type = component%config%config%get_nlo_type ()
    if (present (combined_integration)) then
       if (combined_integration) then
          select type (phs_config => component%config%phs_config)
          type is (phs_wood_config_t)
             call phs_config%set_extended_phs ()
          end select
       end if
    end if
    call component%k_seed%init_sf_chain &
         (component%config%core, sf_chain, config, component%core_state)
    call component%k_seed%init_phs (component%config%phs_config)
    call component%k_seed%set_nlo_info (nlo_type)
  end subroutine component_instance_setup_kinematics

@ %def component_instance_setup_kinematics
@
<<Processes: component instance: TBP>>=
  procedure :: setup_fks_kinematics => component_instance_setup_fks_kinematics
<<Processes: procedures>>=
  subroutine component_instance_setup_fks_kinematics (component, var_list)
    class(component_instance_t), intent(inout), target :: component
    type(var_list_t), intent(in) :: var_list
    logical :: singular_jacobian
    singular_jacobian = var_list%get_lval (var_str ("?powheg_use_singular_jacobian"))
    select type (phs => component%k_seed%phs)
    type is (phs_fks_t)
       call component%nlo_controller%setup_generator &
            (phs%generator, phs%config%sqrts, singular_jacobian)
    class default 
       call msg_fatal ("Phase space should be an FKS phase space!")
    end select
  end subroutine component_instance_setup_fks_kinematics

@ %def component_instance_setup_fks_kinematics 
@ Setup seed kinematics, starting from the MC parameter set given as
argument.  As a result, the [[k_seed]] kinematics object is evaluated
(except for the structure-function matrix-element evaluation, which we
postpone until we know the factorization scale), and we have a valid
[[p_seed]] momentum array.
<<Processes: component instance: TBP>>=
  procedure :: compute_seed_kinematics => &
       component_instance_compute_seed_kinematics
<<Processes: procedures>>=
  subroutine component_instance_compute_seed_kinematics &
       (component, mci_work, phs_channel, success)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    logical, intent(out) :: success
    integer :: sf_channel
    select type (phs => component%k_seed%phs)
    type is (phs_fks_t)
       call component%k_seed%compute_selected_channel &
            (mci_work, phs_channel, component%p_seed, success, &
            component%nlo_controller)
       sf_channel = component%k_seed%phs%config%get_sf_channel (phs_channel)
       call component%nlo_controller%sf_born%compute_kinematics (sf_channel, mci_work%get_x_strfun ())
       call component%nlo_controller%int_born%set_momenta &
            (component%p_seed)
    class default
       call component%k_seed%compute_selected_channel &
            (mci_work, phs_channel, component%p_seed, success)
    end select
  end subroutine component_instance_compute_seed_kinematics
    
@ %def component_instance_compute_seed_kinematics
@ Inverse: recover missing parts of the kinematics, given a complete
set of seed momenta.  Select a channel and reconstruct the MC parameter set.
<<Processes: component instance: TBP>>=
  procedure :: recover_mcpar => component_instance_recover_mcpar
<<Processes: procedures>>=
  subroutine component_instance_recover_mcpar (component, mci_work, phs_channel)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: phs_channel
    call component%k_seed%recover_mcpar &
         (mci_work, phs_channel, component%p_seed)
  end subroutine component_instance_recover_mcpar
  
@ %def component_instance_recover
@ Compute the momenta in the hard interactions, one for each term that
constitutes this process component.  In simple cases this amounts to
just copying momenta.  In more advanced cases, we may generate
distinct sets of momenta from the seed kinematics.

The interactions in the term instances are accessed individually.  We may
choose to calculate all terms at once together with the seed kinematics, use
[[component%core_state]] for storage, and just fill the interactions here.
<<Processes: component instance: TBP>>=
  procedure :: compute_hard_kinematics => &
       component_instance_compute_hard_kinematics
<<Processes: procedures>>=
  subroutine component_instance_compute_hard_kinematics &
       (component, term, skip_term, real_phsp)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), dimension(:), intent(inout) :: term
    integer, intent(in), optional :: skip_term
    logical, intent(in), optional :: real_phsp
    integer :: j, i
    associate (core => component%config%core)
      associate (i_term => component%config%i_term)
        if (allocated (component%core_state)) then
           call component%core_state%reset_new_kinematics ()
        end if
        do j = 1, size (i_term)
           i = i_term(j)
           if (present (skip_term)) then
              if (i == skip_term)  cycle
           end if
           if (present (real_phsp)) then
             if (real_phsp) then
               call core%compute_hard_kinematics &
                     (component%p_seed, i, term(i)%nlo_controller%int_born, &
                     component%core_state)
             else 
               call core%compute_hard_kinematics &
                     (component%p_seed, i, term(i)%int_hard, &
                     component%core_state)
             end if
          else
             call core%compute_hard_kinematics & 
                 (component%p_seed, i, term(i)%int_hard, component%core_state)
          end if
        end do
      end associate
    end associate
  end subroutine component_instance_compute_hard_kinematics
    
@ %def component_instance_compute_hard_kinematics
@ Here, we invert this.  We fetch the incoming momenta which reside
in the appropriate [[sf_chain]] object, stored within the [[k_seed]]
subobject.  On the other hand, we have the outgoing momenta of the
effective interaction.  We rely on the process core to compute the
remaining seed momenta and to fill the momenta within the hard
interaction.  (The latter is trivial if hard and effective interaction
coincide.)

After this is done, the incoming momenta in the trace evaluator that
corresponds to the hard (effective) interaction, are still
left undefined.  We remedy this by calling [[receive_kinematics]] once.
<<Processes: component instance: TBP>>=
  procedure :: recover_seed_kinematics => &
       component_instance_recover_seed_kinematics
<<Processes: procedures>>=
  subroutine component_instance_recover_seed_kinematics (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), intent(inout) :: term
    integer :: n_in
    n_in = component%k_seed%n_in
    call component%k_seed%get_incoming_momenta (component%p_seed(1:n_in))
    associate (core => component%config%core)
      call core%recover_kinematics &
           (component%p_seed, term%int_hard, term%isolated%int_eff, &
           component%core_state)
      call term%isolated%receive_kinematics ()
    end associate
  end subroutine component_instance_recover_seed_kinematics
  
@ %def component_instance_recover_seed_kinematics
@ Compute the integration parameters for all channels except the selected
one.
<<Processes: component instance: TBP>>=
  procedure :: compute_other_channels => &
       component_instance_compute_other_channels
<<Processes: procedures>>=
  subroutine component_instance_compute_other_channels &
       (component, mci_work, phs_channel)
    class(component_instance_t), intent(inout), target :: component
    type(mci_work_t), intent(in) :: mci_work
    integer, intent(in) :: phs_channel
    call component%k_seed%compute_other_channels (mci_work, phs_channel)
  end subroutine component_instance_compute_other_channels
    
@ %def component_instance_compute_other_channels
@ Recover beam momenta, i.e., return the beam momenta as currently
stored in the kinematics subobject to their source.  This is a side effect.
<<Processes: component instance: TBP>>=
  procedure :: return_beam_momenta => component_instance_return_beam_momenta
<<Processes: procedures>>=
  subroutine component_instance_return_beam_momenta (component)
    class(component_instance_t), intent(in) :: component
    call component%k_seed%return_beam_momenta ()
  end subroutine component_instance_return_beam_momenta
    
@ %def component_instance_return_beam_momenta
@
<<Processes: component instance: TBP>>=
  procedure :: supply_damping_factor => component_instance_supply_damping_factor
<<Processes: procedures>>=
  subroutine component_instance_supply_damping_factor (component, sqme)
    class(component_instance_t), intent(in) :: component
    real(default), intent(inout) :: sqme
    real(default) :: E_gluon
    integer :: nlegs
    associate (nlo_controller => component%nlo_controller)
       nlegs = nlo_controller%particle_data%n_in + nlo_controller%particle_data%n_out_real
       E_gluon = nlo_controller%real_kinematics%p_real_lab(nlegs)%p(0)
       select case (component%config%component_type)
       case (COMP_REAL_FIN)
          sqme = sqme * (one - nlo_controller%powheg_damping%get_f (E_gluon))
       case (COMP_REAL_SING)
          sqme = sqme * nlo_controller%powheg_damping%get_f (E_gluon)
       end select
    end associate
  end subroutine component_instance_supply_damping_factor

@ %def component_instance_supply_damping_factor
@
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme_born => component_instance_evaluate_sqme_born
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme_born (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), intent(inout), target :: term
    real(default) :: sqme, sqme_blha
    integer :: n_flv, i_flv
    logical :: bad_point
    if (term%nlo_type == NLO_VIRTUAL) return
    i_flv = 1
    sqme = 0._default
    if (term%nlo_type == NLO_REAL) then
       select type (core => component%config%core_sub_born)
       class is (prc_blha_t)
          call core%update_alpha_s (component%core_state, term%fac_scale)
          call core%compute_sqme_born (i_flv, &
             term%nlo_controller%int_born%get_momenta (), term%ren_scale, &
             sqme, bad_point)
       class default
          sqme = real (term%connected%trace%get_matrix_element (1))
       end select
    else 
       select type (core => component%config%core)
       class is (prc_blha_t)
          n_flv = term%config%data%n_flv
          do i_flv = 1, n_flv
             call core%compute_sqme_born (i_flv, term%int_hard%get_momenta (), &
                term%ren_scale, sqme_blha, bad_point)
                sqme = sqme + sqme_blha
          end do
       class is (prc_user_defined_base_t)
          n_flv = term%config%data%n_flv
          do i_flv = 1, n_flv
             call core%update_alpha_s (component%core_state, term%fac_scale)
             sqme = sqme + core%compute_sqme (i_flv, term%int_hard%get_momenta ())
          end do
       class default
          sqme = real (term%connected%trace%get_matrix_element (1))
       end select
    end if
    component%sqme = sqme * term%weight
  end subroutine component_instance_evaluate_sqme_born    

@ %def component_instance_evaluate_sqme_born
@ Evaluate the trace of the transition matrix, convoluted with the initial
state, and summed over all terms.  The trace evaluators of the
individual terms have only a single matrix element. We implicitly drop the
imaginary part of the terms, which should be zero anyway.
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme => component_instance_evaluate_sqme
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), dimension(:), intent(inout), target :: term
    integer :: j, i

    component%sqme = 0
    call reset_nlo_components (component)
    associate (i_term => component%config%i_term)
      do j = 1, size (i_term)
         i = i_term(j)
         if (term(i)%passed) then
            call component%evaluate_sqme_born (term(i))
            call associate_sqme_born (component, component%sqme*term(i)%weight, 1)
            call component%evaluate_sqme_real (term(i))
            call component%evaluate_sqme_virt (term(i))
            call component%evaluate_sqme_pdf (term(i))
         end if
      end do
    end associate
    component%sqme_known = .true.
  end subroutine component_instance_evaluate_sqme
  
@ %def component_instance_evaluate_sqme
@
<<Processes: procedures>>=
  subroutine reset_nlo_components (component)
     type(component_instance_t), intent(inout) :: component
     select case (component%config%config%get_nlo_type ())
     case (NLO_REAL, NLO_VIRTUAL, NLO_PDF)
        associate (collector => component%nlo_controller%sqme_collector)
           collector%sqme_real_non_sub = 0
        end associate
     end select
  end subroutine reset_nlo_components

@ %def reset_nlo_components
@
<<Processes: procedures>>=
  subroutine associate_sqme_born (component, summand, i)
     type(component_instance_t), intent(inout) :: component
     real(default), intent(in) :: summand
     integer, intent(in) :: i
     select case (component%config%config%get_nlo_type ())
     case (NLO_REAL, NLO_PDF)
        if (debug_active (D_SUBTRACTION)) &
           call msg_debug (D_SUBTRACTION, "Associate Born matrix element", i)
        component%nlo_controller%sqme_collector%sqme_born_list(i) = summand
     end select
  end subroutine associate_sqme_born

@ Perform the matrix-element-evaluation if the component is flagged as virtual
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme_virt => component_instance_evaluate_sqme_virt
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme_virt (component, term)
     class(component_instance_t), intent(inout) :: component
     type(term_instance_t), intent(inout) :: term
     real(default), dimension(4) :: sqme_virt 
     integer :: i_flv
     logical :: bad_point

     if (term%nlo_type /= NLO_VIRTUAL) return
     associate (nlo_controller => component%nlo_controller)

        if (debug_active (D_VIRTUAL)) then
           call msg_debug (D_VIRTUAL, "Evaluating virtual-subtracted matrix elements")
           print *, 'alpha_s: ', component%config%core%get_alpha_s (component%core_state)
           print *, 'ren_scale: ', term%ren_scale
           print *, 'fac_scale: ', term%fac_scale
        end if

        call nlo_controller%set_alpha_s_born &
                  (component%config%core%get_alpha_s (component%core_state))
        call nlo_controller%virtual_terms%set_ren_scale &
                   (term%int_hard%get_momenta (), term%ren_scale) 
        call nlo_controller%virtual_terms%set_fac_scale &
                   (term%int_hard%get_momenta (), term%fac_scale)
        select type (core => component%config%core)
        class is (prc_blha_t)
           do i_flv = 1, core%get_nflv()
              if (debug_active (D_VIRTUAL)) call msg_debug (D_VIRTUAL, "i_flv", i_flv)
              call core%update_alpha_s (component%core_state, term%fac_scale)
              call core%compute_sqme_virt (i_flv, &
                         term%int_hard%get_momenta (), &
                         term%ren_scale, &
                         sqme_virt, bad_point)

              if (debug_active (D_VIRTUAL)) then
                 call msg_debug (D_VIRTUAL, "OLP output: ")
                 print *, sqme_virt
              end if

              if (.not. nlo_controller%use_internal_color_correlations) &
                 call core%compute_sqme_cc (i_flv, &
                           term%int_hard%get_momenta (), &
                           term%ren_scale, &
                           born_cc = nlo_controller%sqme_collector%sqme_born_cc (:,:,i_flv), &
                           bad_point = bad_point)
              call nlo_controller%virtual_terms%set_vfin (sqme_virt(3))
              call nlo_controller%virtual_terms%set_bad_point (bad_point)
              nlo_controller%sqme_collector%sqme_born_list (i_flv) = sqme_virt (4)             
              nlo_controller%sqme_collector%sqme_virt_list (i_flv) = &
                  nlo_controller%compute_virt (i_flv, term%int_hard) * term%weight
           end do
        end select
        component%sqme = component%sqme + sum (nlo_controller%sqme_collector%sqme_virt_list)
     end associate
  end subroutine component_instance_evaluate_sqme_virt

@ %def component_instance_evaluate_sqme_virt
@ Perform the matrix-element evaluation if the component is flagged as pdf
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme_pdf => component_instance_evaluate_sqme_pdf 
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme_pdf (component, term)
    class(component_instance_t), intent(inout) :: component
    type(term_instance_t), intent(inout) :: term
    if (term%nlo_type /= NLO_PDF) return
    associate (nlo_controller => component%nlo_controller)
       if (.not. nlo_controller%pdf_subtraction_is_required ()) then
          component%sqme = 0._default
          return
       end if
       call nlo_controller%set_alpha_s_born &
                 (component%config%core%get_alpha_s (component%core_state))
       call nlo_controller%evaluate_pdf_subtraction (component%sqme)
    end associate
  end subroutine component_instance_evaluate_sqme_pdf

@ %def component_instance_evaluate_sqme_pdf
@ Perform the matrix-element evaluation if the component is flagged as real
<<Processes: component instance: TBP>>=
  procedure :: evaluate_sqme_real => component_instance_evaluate_sqme_real
<<Processes: procedures>>=
  subroutine component_instance_evaluate_sqme_real (component, term)
     class(component_instance_t), intent(inout) :: component
     type(term_instance_t), intent(inout), target :: term
     type(vector4_t), dimension(:), allocatable :: p_real
     integer :: i_flv, i_flv_born
     logical :: bad_point

     if (term%nlo_type /= NLO_REAL) return
     if (component%config%component_type == COMP_REAL_FIN) &
        call component%nlo_controller%disable_subtraction ()
     allocate (p_real &
          (1:size(term%nlo_controller%get_momenta (born_phsp = .false.))))
     p_real = term%nlo_controller%get_momenta (born_phsp = .false.)
     i_flv = term%nlo_controller%active_flavor_structure_real
     select type (core => component%config%core)
     type is (prc_omega_t)
        component%nlo_controller%sqme_collector%sqme_real_non_sub (i_flv) = &
             real (term%connected_real%trace%get_matrix_element (1))
     class is (prc_blha_t)
           call core%update_alpha_s (component%core_state, term%fac_scale)
           call core%compute_sqme_real (i_flv, p_real, 0._default, &
                component%nlo_controller%sqme_collector%sqme_real_non_sub(i_flv), &
                bad_point)
     end select 
     call component%supply_damping_factor (component%nlo_controller%sqme_collector%sqme_real_non_sub (i_flv))
     if (debug_active (D_SUBTRACTION)) &
        call msg_debug (D_SUBTRACTION, "non-subtracted real matrix element", &
                  component%nlo_controller%sqme_collector%sqme_real_non_sub(i_flv))
     !!! Get the necessary subtraction matrix elements.
     associate (nlo_controller => component%nlo_controller)
       if (nlo_controller%is_subtraction_active ()) then
          associate (collector => nlo_controller%sqme_collector)
            do i_flv = 1, nlo_controller%get_n_flv_born ()
               i_flv_born = term%nlo_controller%reg_data%underlying_borns (i_flv)
               select type (core_born => component%config%core_sub_born)
               class is (prc_blha_t)
                  if (.not. nlo_controller%use_internal_color_correlations) then
                     call core_born%update_alpha_s (component%core_state, term%fac_scale)
                     call core_born%compute_sqme_cc (i_flv, &
                             nlo_controller%int_born%get_momenta (), &
                             0._default, &
                             collector%sqme_born_list (i_flv_born), &
                             collector%sqme_born_cc (:,:,i_flv_born), &
                             bad_point)
                  else
                  !!! Implementation for color-correlations using color_data
                  end if
               type is (prc_omega_t)
                  collector%sqme_born_cc (:,:,i_flv_born) = collector%sqme_born_list (i_flv_born) * &
                       nlo_controller%color_data%beta_ij (:,:,i_flv_born)
               end select

               if (nlo_controller%requires_spin_correlation (i_flv)) then
                  select type (core_born => component%config%core_sub_born)
                  type is (prc_omega_t)
                     call msg_fatal ("Computation of spin-correlated matrix elements not possible with O'Mega!")
                  type is (prc_gosam_t)
                     call core_born%update_alpha_s (component%core_state, term%fac_scale)
                     call core_born%compute_sqme_sc (i_flv_born, &
                        nlo_controller%get_active_emitter(), &
                        nlo_controller%int_born%get_momenta(), &
                        0._default, collector%sqme_born_sc(i_flv_born), bad_point)
                  type is (prc_openloops_t) 
                     call core_born%update_alpha_s (component%core_state, term%fac_scale)
                     call nlo_controller%compute_k_perp ()
                     call core_born%compute_sqme_sc (i_flv_born, &
                        nlo_controller%get_active_emitter(), &
                        nlo_controller%int_born%get_momenta(), &
                        0._default, nlo_controller%get_k_perp(), &
                        collector%sqme_born_sc(i_flv_born), bad_point)
                  end select
               end if
            end do
          end associate
       end if
       call nlo_controller%set_alpha_s_born &
            (component%config%core%get_alpha_s (component%core_state))
       nlo_controller%sqme_collector%current_sqme_real = &
            nlo_controller%compute_sqme_real_fin (term%weight, p_real) 
     end associate
  end subroutine component_instance_evaluate_sqme_real

@ %def subroutine component_instance_evaluate_sqme_real
@ Get nlo-type and emitter of the component.
<<Processes: component instance: TBP>>=
  procedure :: get_nlo_type => component_instance_get_nlo_type
<<Processes: procedures>>=
  elemental function component_instance_get_nlo_type (component) &
       result (nlo_type)
    class(component_instance_t), intent(in) :: component
    integer :: nlo_type
    nlo_type = component%nlo_type
  end function component_instance_get_nlo_type

@ %def component_instance_get_nlo_type
@
<<Processes: component instance: TBP>>=
  procedure :: get_component_type => &
                   component_instance_get_component_type
<<Processes: procedures>>=
  function component_instance_get_component_type (component) result (val)
    class(component_instance_t), intent(in) :: component
    integer :: val
    val = component%config%component_type
  end function component_instance_get_component_type

@ %def component_instance_get_component_type
@
<<Processes: component instance: TBP>>=
  procedure :: set_component_type => &
                   component_instance_set_component_type
<<Processes: procedures>>=
  subroutine component_instance_set_component_type (component, val)
    class(component_instance_t), intent(in) :: component
    integer, intent(in) :: val
    component%config%component_type = val
  end subroutine component_instance_set_component_type

@ %def component_instance_set_component_type
@
<<Processes: process component: TBP>>=
  procedure :: needs_mci_entry => process_component_needs_mci_entry
<<Processes: procedures>>=
  function process_component_needs_mci_entry (component) result (value)
    class(process_component_t), intent(in) :: component
    logical :: value
    value = component%active .and. component%core%needs_mcset () &
            .and. component%component_type <= COMP_MASTER 
  end function process_component_needs_mci_entry

@ %def process_component_needs_mci_entry
@
\subsubsection{Term instance}
A [[term_instance_t]] object contains all data that describe a term.  Each
process component consists of one or more distinct terms which may differ in
kinematics, but whose squared transition matrices have to be added pointwise.

The [[active]] flag is set when this term is connected to an active
process component.  Inactive terms are skipped for kinematics and evaluation.

The [[k_term]] object is the instance of the kinematics setup
(structure-function chain, phase space, etc.) that applies
specifically to this term.  In ordinary cases, it consists of straight
pointers to the seed kinematics.

The [[amp]] array stores the amplitude values when we get them from evaluating
the associated matrix-element code.

The [[int_hard]] interaction describes the elementary hard process.
It receives the momenta and the amplitude entries for each sampling point.

The [[isolated]] object holds the effective parton state for the
elementary interaction.  The amplitude entries are
computed from [[int_hard]].  

The [[connected]] evaluator set
convolutes this scattering matrix with the beam (and possibly
structure-function) density matrix.

The [[checked]] flag is set once we have applied cuts on this term.
The result of this is stored in the [[passed]] flag.  Once the term
has passed cuts, we calculate the various scale and weight expressions.
<<Processes: types>>=
  type :: term_instance_t
     type(process_term_t), pointer :: config => null ()
     logical :: active = .false.
     type(kinematics_t) :: k_term
     complex(default), dimension(:), allocatable :: amp
     type(interaction_t) :: int_hard
     type(interaction_t) :: int_hard_real
     type(isolated_state_t) :: isolated
     type(connected_state_t) :: connected
     type(isolated_state_t) :: isolated_real
     type(connected_state_t) :: connected_real
     logical :: checked = .false.
     logical :: passed = .false.
     real(default) :: scale = 0
     real(default) :: fac_scale = 0
     real(default) :: ren_scale = 0
     real(default), allocatable :: alpha_qcd_forced
     real(default) :: weight = 1
     type(vector4_t), dimension(:), allocatable :: p_hard
     type(nlo_controller_t), pointer :: nlo_controller => null ()
     integer :: nlo_type = BORN
   contains
   <<Processes: term instance: TBP>>
  end type term_instance_t
  
@ %def term_instance_t
@
<<Processes: term instance: TBP>>=
  procedure :: write => term_instance_write
<<Processes: procedures>>=
  subroutine term_instance_write (term, unit, show_eff_state, testflag)
    class(term_instance_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_eff_state
    logical, intent(in), optional :: testflag 
    integer :: u
    logical :: state
    u = given_output_unit (unit)
    state = .true.;  if (present (show_eff_state))  state = show_eff_state
    if (term%active) then
       if (associated (term%config)) then
          write (u, "(1x,A,I0,A,I0,A)")  "Term #", term%config%i_term, &
               " (component #", term%config%i_component, ")"
       else
          write (u, "(1x,A)")  "Term [undefined]"
       end if
    else
       write (u, "(1x,A,I0,A)")  "Term #", term%config%i_term, &
            " [inactive]"
    end if
    if (term%checked) then
       write (u, "(3x,A,L1)")      "passed cuts           = ", term%passed
    end if
    if (term%passed) then
       write (u, "(3x,A,ES19.12)")  "overall scale         = ", term%scale
       write (u, "(3x,A,ES19.12)")  "factorization scale   = ", term%fac_scale
       write (u, "(3x,A,ES19.12)")  "renormalization scale = ", term%ren_scale
       if (allocated (term%alpha_qcd_forced)) then
          write (u, "(3x,A,ES19.12)")  "alpha(QCD) forced     = ", &
               term%alpha_qcd_forced
       end if
       write (u, "(3x,A,ES19.12)")  "reweighting factor    = ", term%weight
    end if
    call term%k_term%write (u)
    call write_separator (u)
    write (u, "(1x,A)")  "Amplitude (transition matrix of the &
         &hard interaction):"
    call write_separator (u)
    call term%int_hard%basic_write (u, testflag = testflag)
    if (state .and. term%isolated%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)")  "Evaluators for the hard interaction:"
       call term%isolated%write (u, testflag = testflag)
    end if
    if (state .and. term%connected%has_trace) then
       call write_separator (u)
       write (u, "(1x,A)")  "Evaluators for the connected process:"
       call term%connected%write (u, testflag = testflag)
    end if
  end subroutine term_instance_write
    
@ %def term_instance_write
@ The interactions and evaluators must be finalized.
<<Processes: term instance: TBP>>=
  procedure :: final => term_instance_final
<<Processes: procedures>>=
  subroutine term_instance_final (term)
    class(term_instance_t), intent(inout) :: term
    call term%k_term%final ()
    call term%connected%final ()
    call term%isolated%final ()
    call term%int_hard%final ()
    select case (term%nlo_type)
    case (NLO_REAL)
      call term%connected_real%final ()
      call term%isolated_real%final ()
      call term%int_hard_real%final ()
    end select
  end subroutine term_instance_final
  
@ %def term_instance_final
@ For initialization, we make use of defined assignment for the
[[interaction_t]] type.  This creates a deep copy.

The hard interaction (incoming momenta) is linked to the structure
function instance.  In the isolated state, we either set pointers to
both, or we create modified copies ([[rearrange]]) as effective
structure-function chain and interaction, respectively.

Finally, we set up the [[subevt]] component that will be used for
evaluating observables, collecting particles from the trace evaluator
in the effective connected state.  Their quantum numbers must be
determined by following back source links and set explicitly, since
they are already eliminated in that trace.

The [[rearrange]] parts are still commented out; they could become
relevant for a NLO algorithm.
<<Processes: term instance: TBP>>=
  procedure :: init => term_instance_init
<<Processes: procedures>>=
  subroutine term_instance_init (term, &
       config, k_seed, beam_config, core, process_var_list, &
       nlo_controller, nlo_type)
    class(term_instance_t), intent(inout), target :: term
    type(process_term_t), intent(in), target :: config
    type(kinematics_t), intent(in) :: k_seed
    type(process_beam_config_t), intent(in) :: beam_config
    type(interaction_t), pointer :: sf_chain_int
    type(interaction_t), pointer :: src_int
    class(prc_core_t), intent(in) :: core
    type(var_list_t), intent(in), target :: process_var_list
    type(nlo_controller_t), intent(inout), pointer :: nlo_controller
    integer, intent(in) :: nlo_type
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    type(state_matrix_t), pointer :: state_matrix
    type(flavor_t), dimension(:), allocatable :: flv_int, flv_src, f_in, f_out
    type(flavor_t), dimension(:), allocatable :: f_out_real
    integer :: n_in, n_vir, n_out, n_tot
    !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
    integer :: i, j, k
    integer :: i_component
    type(quantum_numbers_t), dimension(:), allocatable :: qn
    type(interaction_t), pointer, save :: int_sav 
    type(sf_chain_instance_t), pointer, save :: sf_sav
    integer, dimension(:), allocatable, save :: col_sav
    class(prc_core_t), save, allocatable :: core_sav

    term%config => config
    term%nlo_controller => nlo_controller
    if (config%rearrange) then
       ! rearrangement of seed to hard kinematics not implemented yet
       ! allocate k_term distinct from k_seed as needed.
    else
       ! here, k_term trivially accesses k_seed via pointers
       call term%k_term%init_ptr (k_seed)
    end if
    allocate (term%amp (config%n_allowed))
    term%int_hard = config%int
    allocate (term%p_hard (term%int_hard%get_n_tot ()))
    sf_chain_int => term%k_term%sf_chain%get_out_int_ptr ()
    n_in = term%int_hard%get_n_in ()
    do j = 1, n_in
       i = term%k_term%sf_chain%get_out_i (j)
       call term%int_hard%set_source_link (j, sf_chain_int, i)
    end do
    if (config%rearrange) then
       ! rearrangement hard to effective kinematics not implemented yet
       ! should use term%config%int_eff as template
       ! allocate distinct sf_chain in term%connected as needed
    else
      select type (phs => term%k_term%phs)
        type is (phs_wood_t)
          ! here, int_hard and sf_chain are trivially accessed via pointers
          call term%isolated%init (term%k_term%sf_chain, term%int_hard)
          int_sav => term%int_hard
          sf_sav => term%k_term%sf_chain
        type is (phs_fks_t)
          select case (phs%mode)
          case (PHS_MODE_ADDITIONAL_PARTICLE)
             term%nlo_controller%int_born = int_sav
             term%nlo_controller%sf_born => sf_sav
             do j = 1, n_in
                i = term%nlo_controller%sf_born%get_out_i (j)
                call term%nlo_controller%int_born%set_source_link &
                   (j, term%nlo_controller%sf_born%get_out_int_ptr (), i)
             end do
             call term%isolated%init (term%nlo_controller%sf_born, &
                                      term%nlo_controller%int_born)
             call term%setup_real_interaction (term%int_hard)
          case (PHS_MODE_COLLINEAR_REMNANT)
             call term%isolated%init (term%k_term%sf_chain, term%int_hard)
          end select
        class default
          call term%isolated%init (term%k_term%sf_chain, term%int_hard)
      end select
    end if
    allocate (mask_in (n_in))
    mask_in = term%k_term%sf_chain%get_out_mask ()
    select type (phs => term%k_term%phs)
      type is (phs_wood_t)
      call term%isolated%setup_square_trace (core, mask_in, term%config%col)
      if (.not. allocated (col_sav)) then
        allocate (col_sav (size (term%config%col)))
        col_sav = term%config%col
      end if
      !!!select type (core)
      !!!type is (prc_omega_t)
      !!!  core_sav = core
      !!!end select
      if (.not. allocated (core_sav)) allocate (core_sav, source=core)
      type is (phs_fks_t)
        select case (phs%mode)
        case (PHS_MODE_ADDITIONAL_PARTICLE)
           mask_in = sf_sav%get_out_mask ()
           call term%isolated%setup_square_trace (core_sav, mask_in, col_sav)
           call term%init_states (core)
        case (PHS_MODE_COLLINEAR_REMNANT)
           call term%isolated%setup_square_trace (core, mask_in, term%config%col)
        end select      
      class default
        call term%isolated%setup_square_trace (core, mask_in, term%config%col)
    end select
    call term%connected%setup_connected_trace (term%isolated)
    associate (int_eff => term%isolated%int_eff)
      state_matrix => int_eff%get_state_matrix_ptr ()
      n_tot = int_eff%get_n_tot  ()
      !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug      
      allocate (flv_int (n_tot), qn (n_tot))
      qn = state_matrix%get_quantum_numbers (1)
      do k = 1, n_tot
         flv_int(k) = quantum_numbers_get_flavor (qn (k))
      end do
      deallocate (qn)
      !!! flv_int = quantum_numbers_get_flavor &
      !!!      (state_matrix%get_quantum_numbers (1))      
      allocate (f_in (n_in))
      f_in = flv_int(1:n_in)
      deallocate (flv_int)
    end associate
    n_in = term%connected%trace%get_n_in ()
    n_vir = term%connected%trace%get_n_vir ()
    n_out = term%connected%trace%get_n_out ()
    allocate (f_out (n_out))
    do j = 1, n_out
       call term%connected%trace%find_source &
            (n_in + n_vir + j, src_int, i)
       if (associated (src_int)) then
          state_matrix => src_int%get_state_matrix_ptr ()
          !!! !!! !!! Workaround for ifort 16.0 standard-semantics bug
          n_tot = src_int%get_n_tot ()
          allocate (flv_src (n_tot), qn (n_tot))
          qn = state_matrix%get_quantum_numbers (1)
          do k = 1, n_tot
             flv_src(k) = quantum_numbers_get_flavor (qn (k))
          end do
          deallocate (qn)
          !!! flv_src = quantum_numbers_get_flavor &
          !!!      (state_matrix%get_quantum_numbers (1))          
          f_out(j) = flv_src(i)
          deallocate (flv_src)
       end if
    end do

    call term%connected%setup_subevt (term%isolated%sf_chain_eff, &
         beam_config%data%flv, f_in, f_out)
    call term%connected%setup_var_list &
         (process_var_list, beam_config%data)

    term%nlo_type = nlo_type
    select case (term%nlo_type)
    case (NLO_REAL)
       allocate (f_out_real (n_out+1))
       f_out_real (1:n_out) = f_out
       f_out_real (n_out+1) = term%nlo_controller%reg_data%flv_extra
       call term%connected_real%setup_subevt &
            (term%isolated_real%sf_chain_eff, &
            beam_config%data%flv, f_in, f_out_real)
       call term%connected_real%setup_var_list &
            (process_var_list, beam_config%data)
    end select

  end subroutine term_instance_init

@ %def term_instance_init
@ Set up the state objects.
<<Processes: term instance: TBP>>=
  procedure :: init_states => term_instance_init_states
<<Processes: procedures>>=
  subroutine term_instance_init_states (term, core)
    class(term_instance_t), intent(inout), target :: term
    class(prc_core_t), intent(in) :: core
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    allocate (mask_in(1:size(term%k_term%sf_chain%get_out_mask ())))
    mask_in = term%k_term%sf_chain%get_out_mask ()
    call term%isolated_real%init (term%k_term%sf_chain, term%int_hard_real)
    call term%isolated_real%setup_square_trace (core, mask_in, term%config%col)
    call term%connected_real%setup_connected_trace (term%isolated_real) 
  end subroutine term_instance_init_states

@ %def term_instance_init_states 
@ For initializing the expressions, we need the local variable list and the
parse trees.
<<Processes: term instance: TBP>>=
  procedure :: setup_expressions => term_instance_setup_expressions
<<Processes: procedures>>=
  subroutine term_instance_setup_expressions (term, meta, config)
    class(term_instance_t), intent(inout), target :: term
    type(process_metadata_t), intent(in), target :: meta
    type(process_config_data_t), intent(in) :: config
    if (allocated (config%ef_cuts)) &
         call term%connected%setup_cuts (config%ef_cuts)
    if (allocated (config%ef_scale)) &
         call term%connected%setup_scale (config%ef_scale)
    if (allocated (config%ef_fac_scale)) &
         call term%connected%setup_fac_scale (config%ef_fac_scale)
    if (allocated (config%ef_ren_scale)) &
         call term%connected%setup_ren_scale (config%ef_ren_scale)
    if (allocated (config%ef_weight)) &
         call term%connected%setup_weight (config%ef_weight)
    select case (term%nlo_type)
    case (NLO_REAL)
       call term%setup_expressions_real (meta, config)
    end select
  end subroutine term_instance_setup_expressions
    
@ %def term_instance_setup_expressions
@
<<Processes: term instance: TBP>>=
  procedure :: setup_expressions_real => term_instance_setup_expressions_real
<<Processes: procedures>>=
  subroutine term_instance_setup_expressions_real (term, meta, config)
    class(term_instance_t), intent(inout), target :: term
    type(process_metadata_t), intent(in), target :: meta
    type(process_config_data_t), intent(in) :: config
    if (allocated (config%ef_cuts)) &
         call term%connected_real%setup_cuts (config%ef_cuts)
    if (allocated (config%ef_scale)) &
         call term%connected_real%setup_scale (config%ef_scale)
    if (allocated (config%ef_fac_scale)) &
         call term%connected_real%setup_fac_scale (config%ef_fac_scale)
    if (allocated (config%ef_ren_scale)) &
         call term%connected_real%setup_ren_scale (config%ef_ren_scale)
    if (allocated (config%ef_weight)) &
         call term%connected_real%setup_weight (config%ef_weight)
  end subroutine term_instance_setup_expressions_real

@ %def term_instance_setup_expressions_real
@ Prepare the extra evaluators that we need for processing events.

The quantum numbers mask of the incoming particle
<<Processes: term instance: TBP>>=
  procedure :: setup_event_data => term_instance_setup_event_data
<<Processes: procedures>>=
  subroutine term_instance_setup_event_data (term, core, model)
    class(term_instance_t), intent(inout), target :: term
    class(prc_core_t), intent(in) :: core
    class(model_data_t), intent(in), target :: model
    integer :: n_in
    type(quantum_numbers_mask_t), dimension(:), allocatable :: mask_in
    n_in = term%int_hard%get_n_in ()
    allocate (mask_in (n_in))
    mask_in = term%k_term%sf_chain%get_out_mask ()
    select case (term%nlo_type)
    case (BORN, NLO_VIRTUAL, NLO_PDF)
      call term%isolated%setup_square_matrix (core, model, mask_in, &
         term%config%col)
      call term%isolated%setup_square_flows (core, model, mask_in)
      call term%connected%setup_connected_matrix (term%isolated)
      call term%connected%setup_connected_flows (term%isolated)
      call term%connected%setup_state_flv (term%isolated%get_n_out ())
    case (NLO_REAL)
      call term%isolated_real%setup_square_matrix (core, model, mask_in, &
               term%config%col)
      call term%isolated_real%setup_square_flows (core, model, mask_in)
      call term%connected_real%setup_connected_matrix &
                (term%isolated_real)
      call term%connected_real%setup_connected_flows &
                (term%isolated_real)
      call term%connected_real%setup_state_flv (term%isolated_real%get_n_out ())
    end select
 end subroutine term_instance_setup_event_data
    
@ %def term_instance_setup_event_data
@ Associate the hard real interaction.
<<Processes: term instance: TBP>>=
  procedure :: setup_real_interaction => term_instance_setup_real_interaction
<<Processes: procedures>>=
  subroutine term_instance_setup_real_interaction (term, int)
    class(term_instance_t), intent(inout) :: term
    type(interaction_t), intent(in) :: int
    term%int_hard_real = int
  end subroutine term_instance_setup_real_interaction

@ %def term_instance_setup_real_interaction    
@
<<Processes: term instance: TBP>>=
  procedure :: evaluate_real_phase_space => term_instance_evaluate_real_phase_space
<<Processes: procedures>>=
  subroutine term_instance_evaluate_real_phase_space (term)
    class(term_instance_t), intent(inout) :: term
    integer :: emitter
    type(vector4_t), dimension(:), allocatable :: p_born
    type(vector4_t), dimension(:), allocatable :: p_real
    
    emitter = term%nlo_controller%get_active_emitter ()
    allocate (p_born(1:size(term%nlo_controller%int_born%get_momenta ())))
    p_born = term%nlo_controller%int_born%get_momenta ()
    select type (phs => term%k_term%phs)
    type is (phs_fks_t)
       if (emitter > 2) then
          call phs%generate_fsr (emitter, p_born, p_real)
       else
          call phs%generate_isr (p_born, p_real)
       end if
       if (debug_active (D_SUBTRACTION)) call debug_message_phase_space
    class default 
       call msg_fatal ("Evaluate real interaction: Phase space not of FKS-type!")
    end select

    call term%int_hard_real%set_momenta (p_real)

    call term%isolated_real%receive_kinematics ()
    call term%connected_real%receive_kinematics ()

    call term%connected_real%evaluate_expressions (term%passed, &
         term%scale, term%fac_scale, term%ren_scale, term%weight)
  contains
    subroutine debug_message_phase_space ()
       call msg_debug (D_SUBTRACTION, "Generated real phase space")
       call msg_debug (D_SUBTRACTION, "Born phase space:")
       call vector4_write_set (p_born, show_mass = .true.)
       call msg_debug (D_SUBTRACTION, "emitter", emitter)
       call msg_debug (D_SUBTRACTION, "Real phase space:") 
       call vector4_write_set (p_real, show_mass = .true.)
    end subroutine debug_message_phase_space

  end subroutine term_instance_evaluate_real_phase_space

@ %def term_instance_evaluate_real_phase_space
@ Reset the term instance: clear the parton-state expressions and deactivate.
<<Processes: term instance: TBP>>=
  procedure :: reset => term_instance_reset
<<Processes: procedures>>=
  subroutine term_instance_reset (term)
    class(term_instance_t), intent(inout) :: term
    call term%connected%reset_expressions ()
    if (allocated (term%alpha_qcd_forced))  deallocate (term%alpha_qcd_forced)
    term%active = .false.
  end subroutine term_instance_reset
  
@ %def term_instance_reset
@ Force an $\alpha_s$ value that should be used in the matrix-element
calculation. 
<<Processes: term instance: TBP>>=
  procedure :: set_alpha_qcd_forced => term_instance_set_alpha_qcd_forced
<<Processes: procedures>>=
  subroutine term_instance_set_alpha_qcd_forced (term, alpha_qcd)
    class(term_instance_t), intent(inout) :: term
    real(default), intent(in) :: alpha_qcd
    if (allocated (term%alpha_qcd_forced)) then
       term%alpha_qcd_forced = alpha_qcd
    else
       allocate (term%alpha_qcd_forced, source = alpha_qcd)
    end if
  end subroutine term_instance_set_alpha_qcd_forced
  
@ %def term_instance_set_alpha_qcd_forced
@ Complete the kinematics computation for the effective parton states.

We assume that the [[compute_hard_kinematics]] method of the process
component instance has already been called, so the [[int_hard]]
contains the correct hard kinematics.  The duty of this procedure is
first to compute the effective kinematics and store this in the
[[int_eff]] effective interaction inside the [[isolated]] parton
state.  The effective kinematics may differ from the kinematics in the hard
interaction.  It may involve parton recombination or parton splitting.
The [[rearrange_partons]] method is responsible for this part.  

We may also call a method to compute the effective structure-function
chain at this point.  This is not implemented yet.

In the simple case that no rearrangement is necessary, as indicated by
the [[rearrange]] flag, the effective interaction is a pointer to the
hard interaction, and we can skip the rearrangement method.  Similarly
for the effective structure-function chain.  (If we have an algorithm
that uses rarrangement, it should evaluate [[k_term]] explicitly.)

The final step of kinematics setup is to transfer the effective
kinematics to the evaluators and to the [[subevt]].
<<Processes: term instance: TBP>>=
  procedure :: compute_eff_kinematics => &
       term_instance_compute_eff_kinematics
<<Processes: procedures>>=
  subroutine term_instance_compute_eff_kinematics (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    integer :: i_component, i_term
    term%checked = .false.
    term%passed = .false.
    if (term%config%rearrange) then
       ! should evaluate k_term first if allocated separately, not impl. yet
       i_component = term%config%i_component
       i_term = term%config%i_term
      associate (core => component(i_component)%config%core)
         select case (term%nlo_type)
         case (BORN, NLO_VIRTUAL, NLO_PDF)
           call core%compute_eff_kinematics &
              (i_term, term%int_hard, term%isolated%int_eff, &
              component(i_component)%core_state)
         case (NLO_REAL)
           call component(i_component)%config%core_sub_born%compute_eff_kinematics & 
                (i_term, term%nlo_controller%int_born, term%isolated%int_eff, &
                component(i_component)%core_state)
         end select
        select case (term%nlo_type)
        case (NLO_REAL)
          call core%compute_eff_kinematics &
                (i_term, term%int_hard_real, term%isolated_real%int_eff, &
                 component(i_component)%core_state)
        end select
      end associate
    end if
    call term%isolated%receive_kinematics ()
    call term%connected%receive_kinematics ()
  end subroutine term_instance_compute_eff_kinematics
    
@ %def term_instance_compute_eff_kinematics
@ Inverse.  Reconstruct the connected state from the momenta in the
trace evaluator (which we assume to be set), then reconstruct the
isolated state as far as possible.  The second part finalizes the
momentum configuration, using the incoming seed momenta
<<Processes: term instance: TBP>>=
  procedure :: recover_hard_kinematics => &
       term_instance_recover_hard_kinematics
<<Processes: procedures>>=
  subroutine term_instance_recover_hard_kinematics (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    term%checked = .false.
    term%passed = .false.
    call term%connected%send_kinematics ()
    call term%isolated%send_kinematics ()
  end subroutine term_instance_recover_hard_kinematics

@ %def term_instance_recover_hard_kinematics
@ Check the term whether it passes cuts and, if successful, evaluate
scales and weights.  The factorization scale is also given to the term
kinematics, enabling structure-function evaluation.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_expressions => &
       term_instance_evaluate_expressions
<<Processes: procedures>>=
  subroutine term_instance_evaluate_expressions (term, scale_forced)
    class(term_instance_t), intent(inout) :: term
    real(default), intent(in), allocatable, optional :: scale_forced
    call term%connected%evaluate_expressions (term%passed, &
         term%scale, term%fac_scale, term%ren_scale, term%weight, &
         scale_forced)
    term%checked = .true.
  end subroutine term_instance_evaluate_expressions
       
@ %def term_instance_evaluate_expressions
@ Evaluate the trace: first evaluate the hard interaction, then the trace
evaluator.  We use the [[evaluate_interaction]] method of the process
component which generated this term.  The [[subevt]] and cut expressions are
not yet filled.

The [[component]] argument is intent(inout) because the [[compute_amplitude]]
method may modify the [[core_state]] workspace object.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_interaction => term_instance_evaluate_interaction
<<Processes: procedures>>=
  subroutine term_instance_evaluate_interaction (term, component)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), dimension(:), intent(inout) :: component
    integer :: i_component, i_term, i
    i_component = term%config%i_component
    i_term = term%config%i_term
    term%p_hard = term%int_hard%get_momenta ()
    select case (term%nlo_type)
    case (BORN, NLO_VIRTUAL, NLO_PDF)
       associate (core => component(i_component)%config%core)
          do i = 1, term%config%n_allowed
             term%amp(i) = core%compute_amplitude (i_term, term%p_hard, &
                term%config%flv(i), term%config%hel(i), term%config%col(i), &
                term%fac_scale, term%ren_scale, term%alpha_qcd_forced, &
                component(i_component)%core_state)
          end do
          call term%int_hard%set_matrix_element (term%amp)
          if (associated (term%nlo_controller)) call term%nlo_controller%set_fac_scale (term%fac_scale)
       end associate 
    case (NLO_REAL)
       call term%evaluate_real_phase_space
       call term%evaluate_interaction_real (component(i_component), i_term)
    end select  
  end subroutine term_instance_evaluate_interaction
  
@ %def term_instance_evaluate_interaction
@ Evaluate the trace.  First evaluate the
structure-function chain (i.e., the density matrix of the incoming
partons).  Do this twice, in case the sf-chain instances within
[[k_term]] and [[isolated]] differ.  Next, evaluate the hard
interaction, then compute the convolution with the initial state.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_trace => term_instance_evaluate_trace
<<Processes: procedures>>=
  subroutine term_instance_evaluate_trace (term)
    class(term_instance_t), intent(inout) :: term
    call term%k_term%evaluate_sf_chain (term%fac_scale)
    select case (term%nlo_type)
    case (NLO_REAL)
      call term%nlo_controller%sf_born%evaluate (term%fac_scale)
      call term%isolated_real%evaluate_trace ()
      call term%connected_real%evaluate_trace ()
    end select
    call term%isolated%evaluate_sf_chain (term%fac_scale)
    call term%isolated%evaluate_trace ()
    call term%connected%evaluate_trace ()
  end subroutine term_instance_evaluate_trace
  
@ %def term_instance_evaluate_trace
@ Evaluate the extra data that we need for processing the object as a
physical event.
<<Processes: term instance: TBP>>=
  procedure :: evaluate_event_data => term_instance_evaluate_event_data
<<Processes: procedures>>=
  subroutine term_instance_evaluate_event_data (term)
    class(term_instance_t), intent(inout) :: term
    select case (term%nlo_type)
    case (BORN, NLO_VIRTUAL, NLO_PDF)
      call term%isolated%evaluate_event_data ()
      call term%connected%evaluate_event_data ()
    case (NLO_REAL)
      call term%isolated_real%evaluate_event_data ()
      call term%connected_real%evaluate_event_data ()
    end select
  end subroutine term_instance_evaluate_event_data
  
@ %def term_instance_evaluate_event_data
@ Evaluate interaction for an $N+1$-particle phase space
<<Processes: term instance: TBP>>=
  procedure :: evaluate_interaction_real &
               => term_instance_evaluate_interaction_real
<<Processes: procedures>>=
  subroutine term_instance_evaluate_interaction_real (term, component, i_term)
     class(term_instance_t), intent(inout) :: term
     type(component_instance_t), intent(inout) :: component
     integer, intent(in) :: i_term
     integer :: i
     integer :: i_flv_real, i_flv_born
    
     i_flv_real = term%nlo_controller%active_flavor_structure_real
     i_flv_born = term%nlo_controller%reg_data%underlying_borns (i_flv_real)
     if (debug_active (D_SUBTRACTION)) &
         call msg_debug (D_SUBTRACTION, "underlying Born: ", i_flv_born)
     call term%nlo_controller%set_fac_scale (term%fac_scale)
     if (term%passed) then
        if (i_flv_real == 1) call component%core_state%reset_new_kinematics ()
        select type (core => component%config%core)
        type is (prc_omega_t)
           do i = 1, term%config%n_allowed
              if (term%config%flv(i) == i_flv_real) then
                 term%amp(i) = core%compute_amplitude (i_term, &
                    term%int_hard_real%get_momenta (), &
                    term%config%flv(i), term%config%hel(i), term%config%col(i), &
                    term%fac_scale, term%ren_scale, term%alpha_qcd_forced, &
                    component%core_state)
              else
                 term%amp(i) = 0
              end if
           end do
        class is (prc_blha_t)
           call core%update_alpha_s (component%core_state, term%fac_scale)
           term%amp = 0._default
        end select
        call term%int_hard_real%set_matrix_element (term%amp)
        if (i_flv_born == 1) call component%core_state%reset_new_kinematics ()
        select type (core_sub_born => component%config%core_sub_born)
        type is (prc_omega_t)
           do i = 1, term%nlo_controller%n_allowed_born
              if (term%nlo_controller%get_flv_born(i) == i_flv_born) then
                 term%nlo_controller%amp_born(i) = &
                      core_sub_born%compute_amplitude (i_term, &
                      term%nlo_controller%int_born%get_momenta (), &
                      term%nlo_controller%get_flv_born(i), &
                      term%nlo_controller%get_hel_born(i), &
                      term%nlo_controller%get_col_born(i), &
                      term%fac_scale, term%ren_scale, &
                      term%alpha_qcd_forced, &
                      component%core_state)
              else
                 term%nlo_controller%amp_born(i) = 0
              end if
           end do
        class is (prc_blha_t)
           call core_sub_born%update_alpha_s &
                (component%core_state, term%fac_scale)
           term%nlo_controller%amp_born = 0._default
        class default
           call msg_fatal ("Invalid core type set up for subtraction matrix elements")
        end select 
        call term%nlo_controller%int_born%set_matrix_element &
             (term%nlo_controller%amp_born) 
     end if
  end subroutine term_instance_evaluate_interaction_real

@ %def term_instance_evaluate_interaction_real
<<Processes: term instance: TBP>>=
  procedure :: evaluate_interaction_real_rad => &
                        term_instance_evaluate_interaction_real_rad
<<Processes: procedures>>=
  subroutine term_instance_evaluate_interaction_real_rad (term, &
                          component, p_born, p_real, i_term, alpha_s_external)
    class(term_instance_t), intent(inout) :: term
    type(component_instance_t), intent(inout) :: component
    type(vector4_t), intent(in), dimension(:) :: p_born, p_real
    integer, intent(in) :: i_term
    real(default), intent(in), optional :: alpha_s_external
    integer :: i
    real(default), allocatable :: alpha_qcd_forced

    call term%nlo_controller%int_born%set_momenta (p_born)
    call term%int_hard_real%set_momenta (p_real)

    call term%isolated_real%receive_kinematics ()
    call term%connected_real%receive_kinematics ()
    
    call term%connected_real%evaluate_expressions (term%passed, &
         term%scale, term%fac_scale, term%ren_scale, term%weight)

    call component%core_state%reset_new_kinematics ()
    select type (core => component%config%core)
    type is (prc_omega_t)
       if (present (alpha_s_external)) then
          allocate (alpha_qcd_forced, source = alpha_s_external)
       else
          if (allocated (term%alpha_qcd_forced)) &
             allocate (alpha_qcd_forced, source = term%alpha_qcd_forced)
       end if
       do i = 1, term%config%n_allowed
          term%amp(i) = core%compute_amplitude (i_term, &
             term%int_hard_real%get_momenta (), &
             term%config%flv(i), term%config%hel(i), term%config%col(i), &
             term%fac_scale, term%ren_scale, alpha_qcd_forced, &
             component%core_state)
       end do
    class is (prc_blha_t)
       call core%update_alpha_s (component%core_state, term%fac_scale)
       term%amp = 0._default
    end select
    call term%int_hard_real%set_matrix_element (term%amp)
    call component%core_state%reset_new_kinematics ()
    select type (core_sub_born => component%config%core_sub_born)
    type is (prc_omega_t)
       do i = 1, term%nlo_controller%n_allowed_born
          term%nlo_controller%amp_born(i) = core_sub_born%compute_amplitude (i_term, &
              term%nlo_controller%int_born%get_momenta (), &
              term%nlo_controller%get_flv_born(i), term%nlo_controller%get_hel_born(i), &
              term%nlo_controller%get_col_born(i), term%fac_scale, term%ren_scale, &
              alpha_qcd_forced, component%core_state)
       end do
    class is (prc_blha_t)
       term%nlo_controller%amp_born = 0._default
       call core_sub_born%update_alpha_s (component%core_state, term%fac_scale)
    end select 
    call term%nlo_controller%int_born%set_matrix_element &
         (term%nlo_controller%amp_born) 
  end subroutine term_instance_evaluate_interaction_real_rad

@ %def term_instance_evaluate_interaction_real_rad
@
<<Processes: term instance: TBP>>=
  procedure :: set_fac_scale => term_instance_set_fac_scale
<<Processes: procedures>>=
  subroutine term_instance_set_fac_scale (term, fac_scale)
    class(term_instance_t), intent(inout) :: term
    real(default), intent(in) :: fac_scale
    term%fac_scale = fac_scale
  end subroutine term_instance_set_fac_scale

@ %def term_instance_set_fac_scale
@ Return data that might be useful for external processing.  The
factorization scale:
<<Processes: term instance: TBP>>=
  procedure :: get_fac_scale => term_instance_get_fac_scale
<<Processes: procedures>>=
  function term_instance_get_fac_scale (term) result (fac_scale)
    class(term_instance_t), intent(in) :: term
    real(default) :: fac_scale
    fac_scale = term%fac_scale
  end function term_instance_get_fac_scale
  
@ %def term_instance_get_fac_scale
@ We take the strong coupling from the process core.  The value is calculated
when a new event is requested, so we should call it only after the event has
been evaluated.  If it is not available there (a negative number is returned),
we take the value stored in the term configuration, which should be determined
by the model.  If the model does not provide a value, the result is zero.
<<Processes: term instance: TBP>>=
  procedure :: get_alpha_s => term_instance_get_alpha_s
<<Processes: procedures>>=
  function term_instance_get_alpha_s (term, component) result (alpha_s)
    class(term_instance_t), intent(in) :: term
    type(component_instance_t), dimension(:), intent(in) :: component
    real(default) :: alpha_s
    integer :: i_component
    i_component = term%config%i_component
    associate (core => component(i_component)%config%core)
      alpha_s = core%get_alpha_s (component(i_component)%core_state)
    end associate
    if (alpha_s < 0)  alpha_s = term%config%alpha_s
  end function term_instance_get_alpha_s
  
@ %def term_instance_get_alpha_s
@
\subsubsection{MC parameter set and MCI instance}
For each process component that is associated with a multi-channel integration
(MCI) object, the [[mci_work_t]] object contains the currently active
parameter set.  It also holds the implementation of the [[mci_instance_t]]
that the integrator needs for doing its work.
<<Processes: types>>=
  type :: mci_work_t
     type(process_mci_entry_t), pointer :: config => null ()
     real(default), dimension(:), allocatable :: x
     class(mci_instance_t), pointer :: mci => null ()
     type(process_counter_t) :: counter
   contains
   <<Processes: mci work: TBP>>
  end type mci_work_t

@ %def mci_work_t
@ First write configuration data, then the current values.
<<Processes: mci work: TBP>>=
  procedure :: write => mci_work_write
<<Processes: procedures>>=
  subroutine mci_work_write (mci_work, unit, testflag)
    class(mci_work_t), intent(in) :: mci_work
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A,I0,A)")  "Active MCI instance #", &
         mci_work%config%i_mci, " ="
    write (u, "(2x)", advance="no")
    do i = 1, mci_work%config%n_par
       write (u, "(1x,F7.5)", advance="no")  mci_work%x(i)
       if (i == mci_work%config%n_par_sf) &
            write (u, "(1x,'|')", advance="no")
    end do
    write (u, *)
    if (associated (mci_work%mci)) then
       call mci_work%mci%write (u, pacify = testflag)
       call mci_work%counter%write (u)
    end if
  end subroutine mci_work_write
         
@ %def mci_work_write
@ The [[mci]] component may require finalization.
<<Processes: mci work: TBP>>=
  procedure :: final => mci_work_final
<<Processes: procedures>>=
  subroutine mci_work_final (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    if (associated (mci_work%mci)) then
       call mci_work%mci%final ()
       deallocate (mci_work%mci)
    end if
  end subroutine mci_work_final
  
@ %def mci_work_final
@ Initialize with the maximum length that we will need.  Contents are
not initialized.

The integrator inside the [[mci_entry]] object is responsible for
allocating and initializing its own instance, which is referred to by
a pointer in the [[mci_work]] object.
<<Processes: mci work: TBP>>=
  procedure :: init => mci_work_init
<<Processes: procedures>>=
  subroutine mci_work_init (mci_work, mci_entry)
    class(mci_work_t), intent(out) :: mci_work
    type(process_mci_entry_t), intent(in), target :: mci_entry
    mci_work%config => mci_entry
    allocate (mci_work%x (mci_entry%n_par))
    if (allocated (mci_entry%mci)) then
       call mci_entry%mci%allocate_instance (mci_work%mci)
       call mci_work%mci%init (mci_entry%mci)
    end if
  end subroutine mci_work_init
  
@ %def mci_work_init
@ Set parameters explicitly, either all at once, or separately for the
structure-function and process parts.
<<Processes: mci work: TBP>>=
  procedure :: set => mci_work_set
  procedure :: set_x_strfun => mci_work_set_x_strfun
  procedure :: set_x_process => mci_work_set_x_process
<<Processes: procedures>>=
  subroutine mci_work_set (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x = x
  end subroutine mci_work_set
    
  subroutine mci_work_set_x_strfun (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x(1 : mci_work%config%n_par_sf) = x
  end subroutine mci_work_set_x_strfun
    
  subroutine mci_work_set_x_process (mci_work, x)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), dimension(:), intent(in) :: x
    mci_work%x(mci_work%config%n_par_sf + 1 : mci_work%config%n_par) = x
  end subroutine mci_work_set_x_process
    
@ %def mci_work_set
@ %def mci_work_set_x_strfun
@ %def mci_work_set_x_process
@ Return the array of active components, i.e., those that correspond
to the currently selected MC parameter set.
<<Processes: mci work: TBP>>=
  procedure :: get_active_components => mci_work_get_active_components
<<Processes: procedures>>=
  function mci_work_get_active_components (mci_work) result (i_component)
    class(mci_work_t), intent(in) :: mci_work
    integer, dimension(:), allocatable :: i_component
    allocate (i_component (size (mci_work%config%i_component)))
    i_component = mci_work%config%i_component
  end function mci_work_get_active_components

@ %def mci_work_get_active_components
@ Return the active parameters as a simple array with correct length.
Do this separately for the structure-function parameters and the
process parameters.
<<Processes: mci work: TBP>>=
  procedure :: get_x_strfun => mci_work_get_x_strfun
  procedure :: get_x_process => mci_work_get_x_process
<<Processes: procedures>>=
  function mci_work_get_x_strfun (mci_work) result (x)
    class(mci_work_t), intent(in) :: mci_work
    real(default), dimension(mci_work%config%n_par_sf) :: x
    x = mci_work%x(1 : mci_work%config%n_par_sf)
  end function mci_work_get_x_strfun

  function mci_work_get_x_process (mci_work) result (x)
    class(mci_work_t), intent(in) :: mci_work
    real(default), dimension(mci_work%config%n_par_phs) :: x
    x = mci_work%x(mci_work%config%n_par_sf + 1 : mci_work%config%n_par)
  end function mci_work_get_x_process

@ %def mci_work_get_x_strfun
@ %def mci_work_get_x_process
@ Initialize and finalize event generation for the specified MCI
entry.  This also resets the counter.
<<Processes: mci work: TBP>>=
  procedure :: init_simulation => mci_work_init_simulation
  procedure :: final_simulation => mci_work_final_simulation
<<Processes: procedures>>=
  subroutine mci_work_init_simulation (mci_work, safety_factor)
    class(mci_work_t), intent(inout) :: mci_work
    real(default), intent(in), optional :: safety_factor
    call mci_work%mci%init_simulation (safety_factor)
    call mci_work%counter%reset ()
  end subroutine mci_work_init_simulation

  subroutine mci_work_final_simulation (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    call mci_work%mci%final_simulation ()
  end subroutine mci_work_final_simulation

@ %def mci_work_init_simulation
@ %def mci_work_final_simulation
@ Counter.
<<Processes: mci work: TBP>>=
  procedure :: reset_counter => mci_work_reset_counter
  procedure :: record_call => mci_work_record_call
  procedure :: get_counter => mci_work_get_counter
<<Processes: procedures>>=
  subroutine mci_work_reset_counter (mci_work)
    class(mci_work_t), intent(inout) :: mci_work
    call mci_work%counter%reset ()
  end subroutine mci_work_reset_counter
  
  subroutine mci_work_record_call (mci_work, status)
    class(mci_work_t), intent(inout) :: mci_work
    integer, intent(in) :: status
    call mci_work%counter%record (status)
  end subroutine mci_work_record_call
    
  function mci_work_get_counter (mci_work) result (counter)
    class(mci_work_t), intent(in) :: mci_work
    type(process_counter_t) :: counter
    counter = mci_work%counter
  end function mci_work_get_counter
  
@ %def mci_work_reset_counter
@ %def mci_work_record_call
@ %def mci_work_get_counter
@ 
\subsubsection{The process instance}
A process instance contains all process data that depend on the
sampling point and thus change often.  In essence, it is an event
record at the elementary (parton) level.  We do not call it such, to
avoid confusion with the actual event records.  If decays are
involved, the latter are compositions of several elementary processes
(i.e., their instances).

We implement the process instance as an extension of the
[[mci_sampler_t]] that we need for computing integrals and generate
events.

The base type contains: the [[integrand]], the [[selected_channel]],
the two-dimensional array [[x]] of parameters, and the one-dimensional
array [[f]] of Jacobians.  These subobjects are public and used for
communicating with the multi-channel integrator.

The [[process]] pointer accesses the process of which this record is
an instance.  It is required whenever the calculation needs invariant
configuration data, therefore the process should stay in memory for
the whole lifetime of its instances.

The [[evaluation_status]] code is used to check the current status.
In particular, failure at various stages is recorded there.

The [[count]] object records process evaluations, broken down
according to status.

The [[sqme]] value is the single real number that results from
evaluating and tracing the kinematics and matrix elements.  This
is the number that is handed over to an integration routine.

The [[weight]] value is the event weight.  It is defined when an event
has been generated from the process instance, either weighted or
unweighted.  The value is the [[sqme]] value times Jacobian weights
from the integration, or unity, respectively.

The [[i_mci]] index chooses a subset of components that are associated with
a common parameter set and integrator, i.e., that are added coherently.

The [[sf_chain]] subobject is a realization of the beam and
structure-function configuration in the [[process]] object.  It is not
used for calculation directly but serves as the template for the
sf-chain instances that are contained in the [[component]] objects.

The [[component]] subobjects determine the state of each component.

The [[term]] subobjects are workspace for evaluating kinematics,
matrix elements, cuts etc.

The [[mci_work]] subobject contains the array of real input parameters (random
numbers) that generates the kinematical point.  It also contains the workspace
for the MC integrators.  The active entry of the [[mci_work]] array is
selected by the [[i_mci]] index above.
<<Processes: public>>=
  public :: process_instance_t
<<Processes: types>>=
  type, extends (mci_sampler_t) :: process_instance_t
     type(process_t), pointer :: process => null ()
     integer :: evaluation_status = STAT_UNDEFINED
     real(default) :: sqme = 0
     real(default), dimension(:,:), allocatable :: sqme_real
     real(default) :: weight = 0
     real(default) :: excess = 0
     integer :: i_mci = 0
     integer :: selected_channel = 0
     type(sf_chain_t) :: sf_chain
     type(component_instance_t), dimension(:), allocatable :: component
     type(term_instance_t), dimension(:), allocatable :: term
     type(mci_work_t), dimension(:), allocatable :: mci_work
     class(pcm_instance_t), allocatable :: pcm
!     class(pcm_instance_t), allocatable :: sqme_collector
!     type(nlo_controller_t), pointer :: nlo_controller => null()
!     logical :: collect_matrix_elements = .false.
!     integer :: active_real_component = 1
   contains
   <<Processes: process instance: TBP>>
  end type process_instance_t
     
@ %def process_instance
@ The output routine contains a header with the most relevant
information about the process, copied from
[[process_metadata_write]].  We mark the active components by an asterisk.

The next section is the MC parameter input.  The following sections
are written only if the evaluation status is beyond setting the
parameters, or if the [[verbose]] option is set.
<<Processes: process instance: TBP>>=
  procedure :: write_header => process_instance_write_header
  procedure :: write => process_instance_write
<<Processes: procedures>>=
  subroutine process_instance_write_header (object, unit, testflag)
    class(process_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    if (associated (object%process)) then
       associate (meta => object%process%meta)
         select case (meta%type)
         case (PRC_UNKNOWN)
            write (u, "(1x,A)") "Process instance [undefined]"
            return
         case (PRC_DECAY)
            write (u, "(1x,A)", advance="no") "Process instance [decay]:"
         case (PRC_SCATTERING)
            write (u, "(1x,A)", advance="no") "Process instance [scattering]:"
         case default
            call msg_bug ("process_instance_write: undefined process type")
         end select
         write (u, "(1x,A,A,A)") "'", char (meta%id), "'"
         write (u, "(3x,A,A,A)") "Run ID = '", char (meta%run_id), "'"
         if (allocated (meta%component_id)) then
            write (u, "(3x,A)")  "Process components:"
            do i = 1, size (meta%component_id)
               if (object%component(i)%active) then
                  write (u, "(3x,'*')", advance="no")
               else
                  write (u, "(4x)", advance="no")
               end if
               write (u, "(1x,I0,9A)")  i, ": '", &
                    char (meta%component_id (i)), "':   ", &
                    char (meta%component_description (i))
            end do
         end if
       end associate
    else
       write (u, "(1x,A)") "Process instance [undefined process]"
       return
    end if
    write (u, "(3x,A)", advance = "no")  "status = "
    select case (object%evaluation_status)
    case (STAT_INITIAL);            write (u, "(A)")  "initialized"
    case (STAT_ACTIVATED);          write (u, "(A)")  "activated"
    case (STAT_BEAM_MOMENTA);       write (u, "(A)")  "beam momenta set"
    case (STAT_FAILED_KINEMATICS);  write (u, "(A)")  "failed kinematics"
    case (STAT_SEED_KINEMATICS);    write (u, "(A)")  "seed kinematics"
    case (STAT_HARD_KINEMATICS);    write (u, "(A)")  "hard kinematics"
    case (STAT_EFF_KINEMATICS);     write (u, "(A)")  "effective kinematics"
    case (STAT_FAILED_CUTS);        write (u, "(A)")  "failed cuts"
    case (STAT_PASSED_CUTS);        write (u, "(A)")  "passed cuts"
    case (STAT_EVALUATED_TRACE);    write (u, "(A)")  "evaluated trace"
       call write_separator (u)
       write (u, "(3x,A,ES19.12)")  "sqme   = ", object%sqme
    case (STAT_EVENT_COMPLETE);   write (u, "(A)")  "event complete"
       call write_separator (u)
       write (u, "(3x,A,ES19.12)")  "sqme   = ", object%sqme
       write (u, "(3x,A,ES19.12)")  "weight = ", object%weight
       if (.not. vanishes (object%excess)) &
            write (u, "(3x,A,ES19.12)")  "excess = ", object%excess
    case default;                 write (u, "(A)")  "undefined"
    end select
    if (object%i_mci /= 0) then
       call write_separator (u)
       call object%mci_work(object%i_mci)%write (u, testflag)
    end if
    call write_separator (u, 2)
  end subroutine process_instance_write_header

  subroutine process_instance_write (object, unit, testflag)
    class(process_instance_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u, i
    u = given_output_unit (unit)
    call object%write_header (u)
    if (object%evaluation_status >= STAT_BEAM_MOMENTA) then
       call object%sf_chain%write (u)
       call write_separator (u, 2)
       if (object%evaluation_status >= STAT_SEED_KINEMATICS) then
          write (u, "(1x,A)") "Active components:"
          do i = 1, size (object%component)
             if (object%component(i)%active) then
                call write_separator (u)
                call object%component(i)%write (u, testflag)
             end if
          end do
          if (object%evaluation_status >= STAT_HARD_KINEMATICS) then
             call write_separator (u, 2)
             write (u, "(1x,A)") "Active terms:"
             if (any (object%term%active)) then
                do i = 1, size (object%term)
                   if (object%term(i)%active) then
                      call write_separator (u)
                      call object%term(i)%write (u, &
                           show_eff_state = &
                           object%evaluation_status >= STAT_EFF_KINEMATICS, &
                           testflag = testflag)
                   end if
                end do
             end if
          end if
          call write_separator (u, 2)
       end if
    end if
  end subroutine process_instance_write

@ %def process_instance_write_header
@ %def process_instance_write
@ Finalize all subobjects that may contain allocated pointers.
<<Processes: process instance: TBP>>=
  procedure :: final => process_instance_final
<<Processes: procedures>>=
  subroutine process_instance_final (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i
    if (allocated (instance%mci_work)) then
       do i = 1, size (instance%mci_work)
          call instance%mci_work(i)%final ()
       end do
    end if
    call instance%sf_chain%final ()
    if (allocated (instance%component)) then
       do i = 1, size (instance%component)
          call instance%component(i)%final ()
       end do
    end if
    if (allocated (instance%term)) then
       do i = 1, size (instance%term)
          call instance%term(i)%final ()
       end do
    end if
    instance%evaluation_status = STAT_UNDEFINED
  end subroutine process_instance_final

@ %def process_instance_final
@ Revert the process instance to initial state.  We do not deallocate
anything, just reset the state index and deactivate all components and
terms.

We do not reset the choice of the MCI set [[i_mci]] unless this is
required explicitly.
<<Processes: process instance: TBP>>=
  procedure :: reset => process_instance_reset
<<Processes: procedures>>=
  subroutine process_instance_reset (instance, reset_mci)
    class(process_instance_t), intent(inout) :: instance
    logical, intent(in), optional :: reset_mci
    integer :: i
    instance%component%active = .false.
    do i = 1, size (instance%term)
       call instance%term(i)%reset ()
    end do
    instance%term%checked = .false.
    instance%term%passed = .false.
    if (present (reset_mci)) then
       if (reset_mci)  instance%i_mci = 0
    end if
    instance%selected_channel = 0
    instance%evaluation_status = STAT_INITIAL
  end subroutine process_instance_reset
  
@ %def process_instance_reset
@ Activate the components and terms that correspond to a currently
selected MCI parameter set.
<<Processes: process instance: TBP>>=
  procedure :: activate => process_instance_activate
<<Processes: procedures>>=
  subroutine process_instance_activate (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i, j
    associate (mci_work => instance%mci_work(instance%i_mci))
      instance%component(mci_work%get_active_components ())%active &
           = .true.
      do i = 1, size (instance%component)
         associate (component => instance%component(i))
           if (component%active) then
              do j = 1, size (component%config%i_term)
                 instance%term(component%config%i_term(j))%active &
                      = .true.
              end do
           end if
         end associate
      end do
    end associate
    instance%evaluation_status = STAT_ACTIVATED
  end subroutine process_instance_activate
  
@ %def process_instance_activate
@
<<Processes: process instance: TBP>>=
  procedure :: disable_virtual_components => &
               process_instance_disable_virtual_components
<<Processes: procedures>>=
  subroutine process_instance_disable_virtual_components (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i
    select type (pcm => instance%pcm)
    class is (pcm_instance_nlo_t)
       if (.not. pcm%collect_matrix_elements) &
            call msg_fatal ("Sqme collector must be allocated to prepare for&
            &component selection")
       do i = 1, size (instance%component)
          associate (component => instance%component(i))
            if (component%config%component_type == COMP_VIRT) then
               component%active = .false.
               instance%term(component%config%i_term)%active = .false.
            end if
          end associate
       end do
    end select
  end subroutine process_instance_disable_virtual_components
          
@ %def process_instance_disable_virtual_components
@ Initialization connects the instance with a process.  All initial
information is transferred from the process object.  The process
object contains templates for the interaction subobjects (beam and
term), but no evaluators.  The initialization routine
creates evaluators for the matrix element trace, other evaluators
are left untouched.

The [[instance]] object must have the [[target]] attribute (also in
any caller) since the initialization routine assigns various pointers
to subobject of [[instance]].
<<Processes: process instance: TBP>>=
  procedure :: init => process_instance_init
<<Processes: procedures>>=
  subroutine process_instance_init (instance, process, &
       cc_flag, combined_integration)
    class(process_instance_t), intent(out), target :: instance
    type(process_t), intent(inout), target :: process
    logical, intent(in), optional :: cc_flag
    logical, intent(in), optional :: combined_integration
    integer :: i, i_component

    instance%process => process
    call instance%setup_sf_chain (process%beam_config)

    allocate (instance%mci_work (process%config%n_mci))
    do i = 1, size (instance%mci_work)
       call instance%mci_work(i)%init (process%mci_entry(i))
    end do

    allocate (instance%component (process%config%n_components))
    do i = 1, size (instance%component)
       if (process%component(i)%active) then
          associate (component => instance%component(i))
            call component%init (process%component(i))
          end associate
       end if
    end do

    call instance%process%pcm%allocate_instance (instance%pcm)
    if (.not. instance%has_nlo_component ()) then
       do i = 1, size (instance%component)
          if (process%component(i)%active) then
             associate (component => instance%component(i))
               call component%setup_kinematics &
                    (instance%sf_chain, process%beam_config, &
                    combined_integration)
             end associate
          end if
       end do
    else
       call instance%init_nlo_configuration &
            (cc_flag, combined_integration)
    end if

    allocate (instance%term (process%config%n_terms))
    do i = 1, size (instance%term)
       associate (term => instance%term(i))
         i_component = process%term(i)%i_component
         if (i_component /= 0) then
            associate (component => instance%component(i_component))
              call term%init (process%term(i), &
                   component%k_seed, &
                   process%beam_config, &
                   process%component(i_component)%core, &
                   process%meta%var_list, &
                   component%nlo_controller, &
                   component%config%config%get_nlo_type ())
              call term%setup_expressions &
                   (process%meta, process%config)
           end associate
         end if
       end associate
    end do

    instance%evaluation_status = STAT_INITIAL
  end subroutine process_instance_init
  
@ %def process_instance_init
@ All the NLO-specific initialization.
<<Processes: process instance: TBP>>=
  procedure :: init_nlo_configuration => &
       process_instance_init_nlo_configuration
<<Processes: procedures>>=
  subroutine process_instance_init_nlo_configuration &
       (instance, cc_flag, combined_integration)
    class(process_instance_t), intent(inout), target :: instance
    logical, intent(in), optional :: cc_flag
    logical, intent(in), optional :: combined_integration
    type(process_t), pointer :: process
    integer :: i, i_component
    type(process_constants_t), dimension(2), save :: prc_constants
    integer :: nlo_type
    integer :: i_born, i_real
    logical :: use_internal_cc, use_internal_sc

    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       pcm%controller%sqme_collector => pcm%collector

       process => instance%process
       do i_component = 1, size (instance%component)
          if (process%component(i_component)%active) then
             associate (component => instance%component(i_component))
               nlo_type = component%config%config%get_nlo_type ()
               component%nlo_controller => pcm%controller
               select case (nlo_type)
               case (BORN)
               case (NLO_REAL)
                  i_born = component%config%config%get_associated_born ()
                  call process%term(i_born)%fetch_constants &
                       (prc_constants(1))
                  call process%term(i_component)%fetch_constants &
                       (prc_constants(2))
                  if (present (cc_flag)) then
                     use_internal_cc = cc_flag
                     use_internal_sc = .false.
                  else
                     use_internal_cc = .true.
                     use_internal_sc = .false.
                  end if
                  component%nlo_type = NLO_REAL
                  associate (nlo_controller => component%nlo_controller)
                    if (nlo_controller%needs_initialization) then
                       call component%nlo_controller%set_internal_procedures &
                            (use_internal_cc, use_internal_sc)
                       process%component(i_component)%fks_template%id = &
                            prc_constants(1)%id
                       call component%nlo_controller%init (prc_constants, &
                            process%component(i_component)%fks_template, &
                            process%config%model)
                       call component%nlo_controller%set_flv_born &
                            (process%term(i_born)%flv)
                       call component%nlo_controller%set_col_born &
                            (process%term(i_born)%col)
                       call component%nlo_controller%set_hel_born &
                            (process%term(i_born)%hel)
                       allocate (instance%sqme_real &
                            (component%nlo_controller%reg_data%n_flv_real, &
                            size (component%nlo_controller%reg_data%regions)))
                       call component%nlo_controller%init_born_amps &
                            (process%get_n_allowed_born (i_born))
                       nlo_controller%needs_initialization = .false.
                    end if
                  end associate
               case (NLO_VIRTUAL)
                  i_born = component%config%config%get_associated_born ()
                  i_real = i_born + process%config%n_components / 3
                  component%nlo_type = NLO_VIRTUAL
                  call component%nlo_controller%init_virtual ()
               case (NLO_PDF)
                  i_born = component%config%config%get_associated_born ()
                  component%nlo_type = NLO_PDF
                  call component%nlo_controller%init_pdf_subtraction ()
               case (NLO_SUBTRACTION)
                  component%nlo_type = NLO_SUBTRACTION
               end select
               call component%setup_kinematics &
                    (instance%sf_chain, process%beam_config, &
                    combined_integration)
               if (nlo_type == NLO_REAL .or. nlo_type == NLO_PDF) &
                    call component%setup_fks_kinematics (process%meta%var_list)
             end associate
          end if
       end do

       if (present (combined_integration)) then
          if (combined_integration) then
             pcm%collect_matrix_elements = .true.
          end if
       end if
       
    end select

  end subroutine process_instance_init_nlo_configuration
  
@ %def process_instance_init_nlo_configuration
@ Subroutine of the initialization above: initialize the beam and
structure-function chain template.  We establish pointers to the
configuration data, so [[beam_config]] must have a [[target]]
attribute.

The resulting chain is not used directly for calculation.  It will
acquire instances which are stored in the process-component instance
objects.
<<Processes: process instance: TBP>>=
  procedure :: setup_sf_chain => process_instance_setup_sf_chain
<<Processes: procedures>>=
  subroutine process_instance_setup_sf_chain (instance, config)
    class(process_instance_t), intent(inout) :: instance
    type(process_beam_config_t), intent(in), target :: config
    integer :: n_strfun
    n_strfun = config%n_strfun
    if (n_strfun /= 0) then
       call instance%sf_chain%init (config%data, config%sf)
    else
       call instance%sf_chain%init (config%data)
    end if
    if (config%sf_trace) then
       call instance%sf_chain%setup_tracing (config%sf_trace_file)
    end if
  end subroutine process_instance_setup_sf_chain
    
@ %def process_instance_setup_sf_chain
@ This initialization routine should be called only for process
instances which we intend as a source for physical events.  It
initializes the evaluators in the parton states of the terms.  They
describe the (semi-)exclusive transition matrix and the distribution
of color flow for the partonic process, convoluted with the beam and
structure-function chain.

If the model is not provided explicitly, we may use the model instance that
belongs to the process.  However, an explicit model allows us to override
particle settings.
<<Processes: process instance: TBP>>=
  procedure :: setup_event_data => process_instance_setup_event_data
<<Processes: procedures>>=
  subroutine process_instance_setup_event_data (instance, model)
    class(process_instance_t), intent(inout), target :: instance
    class(model_data_t), intent(in), optional, target :: model
    class(model_data_t), pointer :: current_model
    integer :: i, i_component
    if (present (model)) then
       current_model => model
    else
       current_model => instance%process%config%model
    end if
    do i = 1, size (instance%term)
       associate (term => instance%term(i))
         if (associated (term%config)) then
            i_component = term%config%i_component
            associate (component => instance%process%component(i_component))
              call term%setup_event_data (component%core, current_model)
            end associate
         end if
       end associate
    end do
  end subroutine process_instance_setup_event_data

@ %def process_instance_setup_event_data
@ Choose a MC parameter set and the corresponding integrator. 
The choice persists beyond calls of the [[reset]] method above.  This method
is automatically called here.
<<Processes: process instance: TBP>>=
  procedure :: choose_mci => process_instance_choose_mci
<<Processes: procedures>>=
  subroutine process_instance_choose_mci (instance, i_mci)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    instance%i_mci = i_mci
    call instance%reset ()
  end subroutine process_instance_choose_mci
    
@ %def process_instance_choose_mci
@ Explicitly set a MC parameter set.  Works only if we are in initial
state.  We assume that the length of the parameter set is correct.  

After setting the parameters, activate the components and terms that
correspond to the chosen MC parameter set.
<<Processes: process instance: TBP>>=
  procedure :: set_mcpar => process_instance_set_mcpar
<<Processes: procedures>>=
  subroutine process_instance_set_mcpar (instance, x)
    class(process_instance_t), intent(inout) :: instance
    real(default), dimension(:), intent(in) :: x
    if (instance%evaluation_status == STAT_INITIAL) then
       associate (mci_work => instance%mci_work(instance%i_mci))
         call mci_work%set (x)
       end associate
       call instance%activate ()
    end if
  end subroutine process_instance_set_mcpar

@ %def process_instance_set_mcpar
@ Receive the beam momentum/momenta from a source interaction.  This
applies to a cascade decay process instance, where the `beam' momentum
varies event by event.

The master beam momentum array is contained in the main structure
function chain subobject [[sf_chain]].  The sf-chain instance that
reside in the components will take their beam momenta from there.

The procedure transforms the instance status into
[[STAT_BEAM_MOMENTA]].  For process instance with fixed beam, this
intermediate status is skipped.
<<Processes: process instance: TBP>>=
  procedure :: receive_beam_momenta => process_instance_receive_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_receive_beam_momenta (instance)
    class(process_instance_t), intent(inout) :: instance
    if (instance%evaluation_status >= STAT_INITIAL) then
       call instance%sf_chain%receive_beam_momenta ()
       instance%evaluation_status = STAT_BEAM_MOMENTA
    end if
  end subroutine process_instance_receive_beam_momenta
    
@ %def process_instance_receive_beam_momenta
@ Set the beam momentum/momenta explicitly.  Otherwise, analogous to
the previous procedure.
<<Processes: process instance: TBP>>=
  procedure :: set_beam_momenta => process_instance_set_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_set_beam_momenta (instance, p)
    class(process_instance_t), intent(inout) :: instance
    type(vector4_t), dimension(:), intent(in) :: p
    if (instance%evaluation_status >= STAT_INITIAL) then
       call instance%sf_chain%set_beam_momenta (p)
       instance%evaluation_status = STAT_BEAM_MOMENTA
    end if
  end subroutine process_instance_set_beam_momenta
    
@ %def process_instance_set_beam_momenta
@ Recover the initial beam momenta (those in the [[sf_chain]]
component), given a valid (recovered) [[sf_chain_instance]] in one of
the active components.  We need to do this only if the lab frame is
not the c.m.\ frame, otherwise those beams would be fixed anyway.
<<Processes: process instance: TBP>>=
  procedure :: recover_beam_momenta => process_instance_recover_beam_momenta
<<Processes: procedures>>=
  subroutine process_instance_recover_beam_momenta (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: i
    if (.not. instance%process%beam_config%lab_is_cm_frame) then
       if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
          i = instance%term(i_term)%config%i_component
          call instance%component(i)%return_beam_momenta ()
       end if
    end if
  end subroutine process_instance_recover_beam_momenta

@ %def process_instance_recover_beam_momenta
@ Explicitly choose MC integration channel.  We assume here that the channel
count is identical for all active components.
<<Processes: process instance: TBP>>=
  procedure :: select_channel => process_instance_select_channel
<<Processes: procedures>>=
  subroutine process_instance_select_channel (instance, channel)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    instance%selected_channel = channel
  end subroutine process_instance_select_channel
  
@ %def process_instance_select_channel
@ First step of process evaluation: set up seed kinematics.  That is, for each
active process component, compute a momentum array from the MC input
parameters.

If [[skip_term]] is set, we skip the component that accesses this
term.  We can assume that the associated data have already been
recovered, and we are just computing the rest.
<<Processes: process instance: TBP>>=
  procedure :: compute_seed_kinematics => &
       process_instance_compute_seed_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_seed_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: channel, skip_component, i
    logical :: success
    channel = instance%selected_channel
    if (channel == 0) then
       call msg_bug ("Compute seed kinematics: undefined integration channel")
    end if
    if (present (skip_term)) then
       skip_component = instance%term(skip_term)%config%i_component
    else
       skip_component = 0
    end if
    if (instance%evaluation_status >= STAT_ACTIVATED) then
       success = .true.
       do i = 1, size (instance%component)
          if (i == skip_component)  cycle
          if (instance%component(i)%active) then
             call instance%component(i)%compute_seed_kinematics &
                  (instance%mci_work(instance%i_mci), channel, success)
             if (.not. success)  exit
          end if
       end do
       if (success) then
          instance%evaluation_status = STAT_SEED_KINEMATICS
       else
          instance%evaluation_status = STAT_FAILED_KINEMATICS
       end if
    end if
    associate (mci_work => instance%mci_work(instance%i_mci))
       if (mci_work%config%combined_integration) then
          select type (pcm => instance%pcm)
          class is (pcm_instance_nlo_t)
             call pcm%controller%set_x_rad (mci_work%get_x_process ())
          end select
       end if
    end associate
  end subroutine process_instance_compute_seed_kinematics

@ %def process_instance_compute_seed_kinematics
@ Inverse: recover missing parts of the kinematics from the momentum
configuration, which we know for a single term and component.   Given
a channel, reconstruct the MC parameter set.
<<Processes: process instance: TBP>>=
  procedure :: recover_mcpar => process_instance_recover_mcpar
<<Processes: procedures>>=
  subroutine process_instance_recover_mcpar (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: channel
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       channel = instance%selected_channel
       if (channel == 0) then
          call msg_bug ("Recover MC parameters: undefined integration channel")
       end if
       i = instance%term(i_term)%config%i_component
       call instance%component(i)%recover_mcpar &
                  (instance%mci_work(instance%i_mci), channel)
    end if
  end subroutine process_instance_recover_mcpar

@ %def process_instance_recover_mcpar
@ Second step of process evaluation: compute all momenta, for all active
components, from the seed kinematics.
<<Processes: process instance: TBP>>=
  procedure :: compute_hard_kinematics => &
       process_instance_compute_hard_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_hard_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: i
    logical :: real_phsp
    if (instance%evaluation_status >= STAT_SEED_KINEMATICS) then
       do i = 1, size (instance%component)
          if (instance%component(i)%active) then
            select case (instance%component(i)%config%config%get_nlo_type())
            case (BORN, NLO_VIRTUAL, NLO_PDF)
              real_phsp = .false.
            case (NLO_REAL)
              real_phsp = .true.
            end select
              call instance%component(i)% &
                  compute_hard_kinematics (instance%term, skip_term, real_phsp)
          end if
       end do
       instance%evaluation_status = STAT_HARD_KINEMATICS
    end if
  end subroutine process_instance_compute_hard_kinematics

@ %def process_instance_setup_compute_hard_kinematics
@ Inverse: recover seed kinematics.  We know the beam momentum
configuration and the outgoing momenta of the effective interaction,
for one specific term.
<<Processes: process instance: TBP>>=
  procedure :: recover_seed_kinematics => &
       process_instance_recover_seed_kinematics
<<Processes: procedures>>=
  subroutine process_instance_recover_seed_kinematics (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       associate (i_component => instance%term(i_term)%config%i_component)
         call instance%component(i_component)% &
              recover_seed_kinematics (instance%term(i_term))
       end associate
    end if
  end subroutine process_instance_recover_seed_kinematics
  
@ %def process_instance_recover_seed_kinematics
@ Third step of process evaluation: compute the effective momentum
configurations, for all active terms, from the hard kinematics.
<<Processes: process instance: TBP>>=
  procedure :: compute_eff_kinematics => &
       process_instance_compute_eff_kinematics
<<Processes: procedures>>=
  subroutine process_instance_compute_eff_kinematics (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: i
    if (instance%evaluation_status >= STAT_HARD_KINEMATICS) then
       do i = 1, size (instance%term)
          if (present (skip_term)) then
             if (i == skip_term)  cycle
          end if
          if (instance%term(i)%active) then
             call instance%term(i)% &
                  compute_eff_kinematics (instance%component)
          end if
       end do
       instance%evaluation_status = STAT_EFF_KINEMATICS
    end if
  end subroutine process_instance_compute_eff_kinematics

@ %def process_instance_setup_compute_eff_kinematics
@ Inverse: recover the hard kinematics from effective kinematics for
one term, then compute effective kinematics for the other terms.
<<Processes: process instance: TBP>>=
  procedure :: recover_hard_kinematics => &
       process_instance_recover_hard_kinematics
<<Processes: procedures>>=
  subroutine process_instance_recover_hard_kinematics (instance, i_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       call instance%term(i_term)%recover_hard_kinematics (instance%component)
       do i = 1, size (instance%term)
          if (i /= i_term) then
             if (instance%term(i)%active) then
                call instance%term(i)% &
                     compute_eff_kinematics (instance%component)
             end if
          end if
       end do
       instance%evaluation_status = STAT_EFF_KINEMATICS
    end if
  end subroutine process_instance_recover_hard_kinematics
       
@ %def recover_hard_kinematics
@ Fourth step of process evaluation: check cuts for all terms.  Where
sucessful, compute any scales and weights.  Otherwise, deactive the term.
If any of the terms has passed, set the state to [[STAT_PASSED_CUTS]].

The argument [[scale_forced]], if present, will override the scale calculation
in the term expressions.
<<Processes: process instance: TBP>>=
  procedure :: evaluate_expressions => &
       process_instance_evaluate_expressions
<<Processes: procedures>>=
  subroutine process_instance_evaluate_expressions (instance, scale_forced)
    class(process_instance_t), intent(inout) :: instance
    real(default), intent(in), allocatable, optional :: scale_forced
    integer :: i
    if (instance%evaluation_status >= STAT_EFF_KINEMATICS) then
       do i = 1, size (instance%term)
          if (instance%term(i)%active) then
             call instance%term(i)%evaluate_expressions (scale_forced)
          end if
       end do
       if (any (instance%term%passed)) then
          instance%evaluation_status = STAT_PASSED_CUTS
       else
          instance%evaluation_status = STAT_FAILED_CUTS
       end if
    end if
  end subroutine process_instance_evaluate_expressions

@ %def process_instance_evaluate_expressions
@ Fifth step of process evaluation: fill the parameters for the non-selected
,channels, that have not been used for seeding.  We should do this after
evaluating cuts, since we may save some expensive calculations if the phase
space point fails the cuts.

If [[skip_term]] is set, we skip the component that accesses this
term.  We can assume that the associated data have already been
recovered, and we are just computing the rest.
<<Processes: process instance: TBP>>=
  procedure :: compute_other_channels => &
       process_instance_compute_other_channels
<<Processes: procedures>>=
  subroutine process_instance_compute_other_channels (instance, skip_term)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in), optional :: skip_term
    integer :: channel, skip_component, i
    channel = instance%selected_channel
    if (channel == 0) then
       call msg_bug ("Compute other channels: undefined integration channel")
    end if
    if (present (skip_term)) then
       skip_component = instance%term(skip_term)%config%i_component
    else
       skip_component = 0
    end if
    if (instance%evaluation_status >= STAT_PASSED_CUTS) then
       do i = 1, size (instance%component)
          if (i == skip_component)  cycle
          if (instance%component(i)%active) then
             call instance%component(i)%compute_other_channels &
                  (instance%mci_work(instance%i_mci), channel)
          end if
       end do
    end if
  end subroutine process_instance_compute_other_channels

@ %def process_instance_compute_other_channels
@ Sixth step of process evaluation: evaluate the matrix elements, and compute
the trace (summed over quantum numbers) for all terms.  Finally, sum up the
terms, iterating over all active process components.
<<Processes: process instance: TBP>>=
  procedure :: evaluate_trace => process_instance_evaluate_trace
<<Processes: procedures>>=
  subroutine process_instance_evaluate_trace (instance)
    class(process_instance_t), intent(inout) :: instance
    integer :: i, i_real
    instance%sqme = 0
    i_real = 0
    if (instance%evaluation_status >= STAT_PASSED_CUTS) then
       do i = 1, size (instance%term)
          associate (term => instance%term(i))
            if (term%active .and. term%passed) then
              select case (term%nlo_type)
              case (NLO_REAL)
                 select type (pcm => instance%pcm)
                 class is (pcm_instance_nlo_t)
                    if (.not. pcm%collect_matrix_elements) then
                       if (debug_active (D_SUBTRACTION)) &
                            call msg_debug (D_SUBTRACTION, "Evaluate real trace")
                       call instance%evaluate_trace_real (term, i)
                    else
                       i_real = i
                    end if
                 end select
              case (BORN, NLO_VIRTUAL, NLO_PDF)
                 call term%evaluate_interaction (instance%component)
                 call term%evaluate_trace ()
              end select
            end if
          end associate
       end do
       do i = 1, size (instance%component)
          associate (component => instance%component(i))
            if (component%active) then
              select case (component%config%config%get_nlo_type())
              case (BORN, NLO_VIRTUAL, NLO_PDF)
                call component%evaluate_sqme (instance%term)
                instance%sqme = instance%sqme + component%sqme
                instance%evaluation_status = STAT_EVALUATED_TRACE
              end select
            end if
          end associate
       end do
       select type (pcm => instance%pcm)
       class is (pcm_instance_nlo_t)
          if (pcm%collect_matrix_elements .and. i_real > 0) &
               call instance%evaluate_trace_real (instance%term(i_real), i_real)
       end select
    else
       ! failed kinematics, failed cuts: set sqme to zero
       instance%sqme = 0
    end if
  end subroutine process_instance_evaluate_trace

@ %def process_instance_evaluate_trace
@ Final step of process evaluation: evaluate the matrix elements, and compute
the trace (summed over quantum numbers) for all terms.  Finally, sum up the
terms, iterating over all active process components.

If [[weight]] is provided, we already know the kinematical event
weight (the MCI weight which depends on the kinematics sampling
algorithm, but not on the matrix element), so we do not need to take
it from the MCI record.
<<Processes: process instance: TBP>>=
  procedure :: evaluate_event_data => process_instance_evaluate_event_data
<<Processes: procedures>>=
  subroutine process_instance_evaluate_event_data (instance, weight)
    class(process_instance_t), intent(inout) :: instance
    real(default), intent(in), optional :: weight
    integer :: i
    if (instance%evaluation_status >= STAT_EVALUATED_TRACE) then
       do i = 1, size (instance%term)
          associate (term => instance%term(i))
            if (term%active .and. term%passed) then
               call term%evaluate_event_data ()
            end if
          end associate
       end do
       if (present (weight)) then
          instance%weight = weight
       else
          instance%weight = &
               instance%mci_work(instance%i_mci)%mci%get_event_weight ()
          instance%excess = &
               instance%mci_work(instance%i_mci)%mci%get_event_excess ()
       end if
       instance%evaluation_status = STAT_EVENT_COMPLETE
    else
       ! failed kinematics etc.: set weight to zero
       instance%weight = 0
    end if
  end subroutine process_instance_evaluate_event_data

@ %def process_instance_evaluate_event_data
@ For the real part of the process evaluation at NLO, trace evaluation is a 
  bit more intricate because the phase-spaces for different emitters might
  be treated differently by cuts. A phase-space point is discarded if it fails
  the cuts for at least one emitter. 
<<Processes: process instance: TBP>>=
  procedure :: evaluate_trace_real => process_instance_evaluate_trace_real
<<Processes: procedures>>=
  subroutine process_instance_evaluate_trace_real (instance, term, i)
     class(process_instance_t), intent(inout) :: instance
     type(term_instance_t), intent(inout) :: term
     integer, intent(in) :: i
     integer :: j, ireg, i_flv_real, i_flv_born
     integer :: nlegs
     integer :: fixed_emitter
     real(default) :: sqme_born
     call msg_debug (D_SUBTRACTION, "process_instance_evaluate_trace_real")

     select type (pcm => instance%pcm)
     type is (pcm_instance_nlo_t)
        nlegs = term%nlo_controller%reg_data%nlegs_real
        ireg = 1
        instance%sqme_real = 0

        fixed_emitter = instance%get_fixed_emitter (i)

        if (debug_active (D_SUBTRACTION)) then
           call msg_debug (D_SUBTRACTION, "Loop over emitters: ") 
           print *, term%nlo_controller%reg_data%emitters
        end if
        
        do j = 0, nlegs
           if (fixed_emitter >= 0 .and. j /= fixed_emitter) cycle
           if (any (term%nlo_controller%reg_data%emitters == j)) then
              if (debug_active (D_SUBTRACTION)) call msg_debug (D_SUBTRACTION, "active emitter", j)
              call term%nlo_controller%set_active_emitter (j)
              call term%evaluate_real_phase_space ()
              do i_flv_real = 1, term%nlo_controller%reg_data%n_flv_real
                 i_flv_born = term%nlo_controller%reg_data%underlying_borns (i_flv_real) 
                 if (debug_active (D_SUBTRACTION)) &
                      call msg_debug (D_SUBTRACTION, "active real flavor", i_flv_real)
                 term%nlo_controller%active_flavor_structure_real = i_flv_real
                 call term%evaluate_interaction_real (instance%component(i), i)
                 if (.not. term%passed) then
                    !!! Cuts failed, leave subroutine
                    instance%evaluation_status = STAT_FAILED_CUTS
                    instance%sqme_real = 0
                    return
                 end if
                 call term%evaluate_trace ()
                 if (instance%component(i)%active) then
                    associate (component => instance%component(i))
                      if (.not. pcm%collect_matrix_elements) then
                         call component%evaluate_sqme_born (term)
                         sqme_born = component%sqme
                         if (debug_active (D_SUBTRACTION)) &
                              call msg_debug (D_SUBTRACTION, "sqme_born", sqme_born)
                      else
                         sqme_born = pcm%collector%sqme_born_list (i_flv_born)
                      end if
                      call associate_sqme_born (component, sqme_born*term%weight, i_flv_born)
                      call component%evaluate_sqme_real (term)
                      instance%sqme_real(i_flv_real, ireg) = &
                           pcm%collector%current_sqme_real
                      if (pcm%collect_matrix_elements) then
                         pcm%collector%sqme_real_per_emitter(i_flv_real,j) = &
                              pcm%collector%current_sqme_real 
                      end if
                    end associate
                 end if
              end do
              ireg = ireg + 1 
           end if
        end do
        instance%sqme = instance%sqme + sum (instance%sqme_real)
        if (pcm%collect_matrix_elements) then
           pcm%collector%sqme_real_sum = sum (instance%sqme_real)
        end if
        instance%evaluation_status = STAT_EVALUATED_TRACE  
     end select
  end subroutine process_instance_evaluate_trace_real

@ %def process_instance_evaluate_trace_real
<<Processes: process instance: TBP>>=
  procedure :: evaluate_trace_real_rad => process_instance_evaluate_trace_real_rad
<<Processes: procedures>>=
  subroutine process_instance_evaluate_trace_real_rad (instance, term, i)
    class(process_instance_t), intent(inout) :: instance
    type(term_instance_t), intent(inout) :: term
    integer, intent(in) :: i
    integer :: emitter
    call msg_debug (D_SUBTRACTION, "process_instance_evaluate_trace_real_rad")
    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       term%nlo_controller%active_flavor_structure_real = 1
       call term%evaluate_trace ()
       emitter = term%nlo_controller%active_emitter
       associate (component => instance%component(i))
         call component%evaluate_sqme_real (term)
         pcm%collector%sqme_real_per_emitter (1, emitter) = &
              pcm%collector%current_sqme_real
       end associate
    end select
  end subroutine process_instance_evaluate_trace_real_rad
    
@ %def process_instance_evaluate_trace_real_rad
@ Computes the real-emission matrix element for externally supplied momenta. Also, 
e.g. for Powheg, there is the possibility to supply an external $\alpha_s$
<<Processes: process instance: TBP>>=
  procedure :: compute_sqme_real_rad => process_instance_compute_sqme_real_rad
<<Processes: procedures>>=
  subroutine process_instance_compute_sqme_real_rad &
       (instance, emitter, p_born, p_real, alpha_s_external)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: emitter
    type(vector4_t), intent(in), dimension(:) :: p_born 
    type(vector4_t), intent(in), dimension(:) :: p_real
    real(default), intent(in), optional :: alpha_s_external
    integer :: i_real
    
    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       if (.not. pcm%collect_matrix_elements) &
            call msg_fatal ("Compute radiation matrix elements: " // &
            "Sqme collector must be allocated!")
       call pcm%controller%set_active_emitter (emitter)
       call pcm%controller%disable_subtraction () 
       associate (config => instance%component(pcm%active_real_component)%config)
         select case (config%component_type)
         case (COMP_MASTER)
            i_real = config%config%get_associated_real ()
            if (i_real == 0) i_real = config%config%get_associated_real_sing ()
         case (COMP_REAL_FIN)
            i_real = config%config%get_associated_real_fin ()
         end select
       end associate
       
       associate (term => instance%term(i_real))
         call term%evaluate_interaction_real_rad (instance%component(i_real), &
              p_born, p_real, i_real, alpha_s_external)
         call instance%evaluate_trace_real_rad (term, i_real)
       end associate
       associate (component => instance%component(i_real))
         call component%supply_damping_factor (component%sqme)
       end associate
    end select
  end subroutine process_instance_compute_sqme_real_rad

@ %def process_instance_compute_sqme_real_rad
@
<<Processes: process instance: TBP>>=
  procedure :: compute_sqme_real_sub => process_instance_compute_sqme_real_sub
<<Processes: procedures>>=
  subroutine process_instance_compute_sqme_real_sub &
       (instance, emitter, p_born, p_real, alpha_s_external)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: emitter
    type(vector4_t), intent(in), dimension(:) :: p_born
    type(vector4_t), intent(in), dimension(:) :: p_real
    real(default), intent(in), optional :: alpha_s_external
    integer :: i_real

    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       call pcm%controller%set_active_emitter (emitter)
       call pcm%controller%disable_sqme_np1 ()
       i_real = instance%component(1)%config%config%get_associated_real ()

       associate (term => instance%term(i_real))
         call term%evaluate_interaction_real_rad (instance%component(i_real), &
              p_born, p_real, i_real, alpha_s_external)
         call instance%evaluate_trace_real_rad (term, i_real)
       end associate
    end select
  end subroutine process_instance_compute_sqme_real_sub

@ %def process_instance_compute_sqme_real_sub
@ Get the hadronic center-of-mass energy
<<Processes: process instance: TBP>>=
  procedure :: get_sqrts => process_instance_get_sqrts
<<Processes: procedures>>=
  function process_instance_get_sqrts (process_instance) result (sqrts)
    class(process_instance_t), intent(in) :: process_instance
    real(default) :: sqrts
    sqrts = process_instance%process%get_sqrts ()
  end function process_instance_get_sqrts

@ %def process_instance_get_sqrts
@ 
<<Processes: process instance: TBP>>=
  procedure :: get_matrix_elements => process_instance_get_matrix_elements
<<Processes: procedures>>=
  subroutine process_instance_get_matrix_elements &
       (instance, i_born, i_real, sqme_born, sqme_real)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_born, i_real
    real(default), intent(out) :: sqme_born, sqme_real
    integer :: emitter
    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       emitter = pcm%controller%active_emitter 
       sqme_born = pcm%collector%sqme_born_list (i_born)
       sqme_real = pcm%collector%sqme_real_per_emitter (i_real, emitter)
    end select
  end subroutine process_instance_get_matrix_elements

@ %def process_instance_get_matrix_elements
@
@ For unweighted event generation, we should reset the reported event
weight to unity (signed) or zero.  The latter case is appropriate for
an event which failed for whatever reason.
<<Processes: process instance: TBP>>=
  procedure :: normalize_weight => process_instance_normalize_weight
<<Processes: procedures>>=
  subroutine process_instance_normalize_weight (instance)
    class(process_instance_t), intent(inout) :: instance
    if (.not. vanishes (instance%weight)) then
       instance%weight = sign (1._default, instance%weight)
    end if
  end subroutine process_instance_normalize_weight
  
@ %def process_instance_normalize_weight
@ This is a convenience routine that performs the computations of the
steps 1 to 5 in a single step.  The arguments are the input for
[[set_mcpar]].  After this, the evaluation status should be either
[[STAT_FAILED_KINEMATICS]], [[STAT_FAILED_CUTS]] or [[STAT_EVALUATED_TRACE]].

Before calling this, we should call [[choose_mci]].
<<Processes: process instance: TBP>>=
  procedure :: evaluate_sqme => process_instance_evaluate_sqme
<<Processes: procedures>>=
  subroutine process_instance_evaluate_sqme (instance, channel, x)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    real(default), dimension(:), intent(in) :: x
    call instance%reset ()
    call instance%set_mcpar (x)
    call instance%select_channel (channel)
    call instance%compute_seed_kinematics ()
    call instance%compute_hard_kinematics ()
    call instance%compute_eff_kinematics ()
    call instance%evaluate_expressions ()
    call instance%compute_other_channels ()
    call instance%evaluate_trace ()
    select type (pcm => instance%pcm)
    type is (pcm_instance_nlo_t)
       if (pcm%collect_matrix_elements) then
          instance%sqme = pcm%collector%get_sqme_sum ()
       end if
    end select
  end subroutine process_instance_evaluate_sqme
  
@ %def process_instance_evaluate_sqme
@ This is the inverse.  Assuming that the final trace evaluator
contains a valid momentum configuration, recover kinematics
and recalculate the matrix elements and their trace.

To be precise, we first recover kinematics for the given term and
associated component, then recalculate from that all other terms and
active components.  The [[channel]] is not really required to obtain
the matrix element, but it allows us to reconstruct the exact MC
parameter set that corresponds to the given phase space point.

Before calling this, we should call [[choose_mci]].
<<Processes: process instance: TBP>>=
  procedure :: recover => process_instance_recover
<<Processes: procedures>>=
  subroutine process_instance_recover &
       (instance, channel, i_term, update_sqme, scale_forced)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    integer, intent(in) :: i_term
    logical, intent(in) :: update_sqme
    real(default), intent(in), allocatable, optional :: scale_forced
    call instance%activate ()
    instance%evaluation_status = STAT_EFF_KINEMATICS
    call instance%recover_hard_kinematics (i_term)
    call instance%recover_seed_kinematics (i_term)
    call instance%select_channel (channel)
    call instance%recover_mcpar (i_term)
    call instance%recover_beam_momenta (i_term)
    call instance%compute_seed_kinematics (i_term)
    call instance%compute_hard_kinematics (i_term)
    call instance%compute_eff_kinematics (i_term)
    call instance%compute_other_channels (i_term)
    call instance%evaluate_expressions (scale_forced)
    if (update_sqme)  call instance%evaluate_trace ()
  end subroutine process_instance_recover
  
@ %def process_instance_recover
@ The [[evaluate]] method is required by the [[sampler_t]] base type of which
the process instance is an extension.

The requirement is that after the process instance is evaluated, the
integrand, the selected channel, the $x$ array, and the $f$ Jacobian array are
exposed by the [[sampler_t]] object.
<<Processes: process instance: TBP>>=
  procedure :: evaluate => process_instance_evaluate
<<Processes: procedures>>=
  subroutine process_instance_evaluate (sampler, c, x_in, val, x, f)
    class(process_instance_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call sampler%evaluate_sqme (c, x_in)
    if (sampler%is_valid ())  call sampler%fetch (val, x, f)
    call sampler%record_call ()
  end subroutine process_instance_evaluate

@ %def process_instance_evaluate
@ The phase-space point is valid if the event has valid kinematics and
has passed the cuts.
<<Processes: process instance: TBP>>=
  procedure :: is_valid => process_instance_is_valid
<<Processes: procedures>>=
  function process_instance_is_valid (sampler) result (valid)
    class(process_instance_t), intent(in) :: sampler
    logical :: valid
    valid = sampler%evaluation_status >= STAT_PASSED_CUTS
  end function process_instance_is_valid
  
@ %def process_instance_is_valid
@ The [[rebuild]] method should rebuild the kinematics section out of
the [[x_in]] parameter set.  The integrand value [[val]] should not be
computed, but is provided as input.
<<Processes: process instance: TBP>>=
  procedure :: rebuild => process_instance_rebuild
<<Processes: procedures>>=
  subroutine process_instance_rebuild (sampler, c, x_in, val, x, f)
    class(process_instance_t), intent(inout) :: sampler
    integer, intent(in) :: c
    real(default), dimension(:), intent(in) :: x_in
    real(default), intent(in) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    call msg_bug ("process_instance_rebuild not implemented yet")
    x = 0
    f = 0
  end subroutine process_instance_rebuild

@ %def process_instance_rebuild
@ This is another method required by the [[sampler_t]] base type:
fetch the data that are relevant for the MCI record.
<<Processes: process instance: TBP>>=
  procedure :: fetch => process_instance_fetch
<<Processes: procedures>>=
  subroutine process_instance_fetch (sampler, val, x, f)
    class(process_instance_t), intent(in) :: sampler
    real(default), intent(out) :: val
    real(default), dimension(:,:), intent(out) :: x
    real(default), dimension(:), intent(out) :: f
    integer :: i, cc
    integer :: n_channel
    val = 0
    FIND_COMPONENT: do i = 1, size (sampler%component)
       associate (component => sampler%component(i))
         if (component%active) then
            associate (k => component%k_seed)
              n_channel = k%n_channel
              do cc = 1, n_channel
                 call k%get_mcpar (cc, x(:,cc))
              end do
              f = k%f
              val = sampler%sqme * k%phs_factor
            end associate
            exit FIND_COMPONENT
         end if
       end associate
    end do FIND_COMPONENT
  end subroutine process_instance_fetch
  
@ %def process_instance_fetch
@ Initialize and finalize event generation for the specified MCI
entry.
<<Processes: process instance: TBP>>=
  procedure :: init_simulation => process_instance_init_simulation
  procedure :: final_simulation => process_instance_final_simulation
<<Processes: procedures>>=
  subroutine process_instance_init_simulation (instance, i_mci, safety_factor)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    real(default), intent(in), optional :: safety_factor
    call instance%mci_work(i_mci)%init_simulation (safety_factor)
  end subroutine process_instance_init_simulation

  subroutine process_instance_final_simulation (instance, i_mci)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_mci
    call instance%mci_work(i_mci)%final_simulation ()
  end subroutine process_instance_final_simulation

@ %def process_instance_init_simulation
@ %def process_instance_final_simulation
@ 
\subsection{Accessing the process instance}
Once the seed kinematics is complete, we can retrieve the MC input parameters
for all channels, not just the seed channel.

Note: We choose the first active component.  This makes sense only if the seed
kinematics is identical for all active components.
<<Processes: process instance: TBP>>=
  procedure :: get_mcpar => process_instance_get_mcpar
<<Processes: procedures>>=
  subroutine process_instance_get_mcpar (instance, channel, x)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: channel
    real(default), dimension(:), intent(out) :: x
    integer :: i
    if (instance%evaluation_status >= STAT_SEED_KINEMATICS) then
       do i = 1, size (instance%component)
          if (instance%component(i)%active) then
             call instance%component(i)%k_seed%get_mcpar (channel, x)
             return
          end if
       end do
       call msg_bug ("Process instance: get_mcpar: no active channels")
    else
       call msg_bug ("Process instance: get_mcpar: no seed kinematics")
    end if
  end subroutine process_instance_get_mcpar

@ %def process_instance_get_mcpar
@ Return true if the [[sqme]] value is known.  This also implies that the
event is kinematically valid and has passed all cuts.
<<Processes: process instance: TBP>>=
  procedure :: has_evaluated_trace => process_instance_has_evaluated_trace
<<Processes: procedures>>=
  function process_instance_has_evaluated_trace (instance) result (flag)
    class(process_instance_t), intent(in) :: instance
    logical :: flag
    flag = instance%evaluation_status >= STAT_EVALUATED_TRACE
  end function process_instance_has_evaluated_trace
  
@ %def process_instance_has_evaluated_trace
@ Return true if the event is complete.  In particular, the event must
be kinematically valid, passed all cuts, and the event data have been
computed.
<<Processes: process instance: TBP>>=
  procedure :: is_complete_event => process_instance_is_complete_event
<<Processes: procedures>>=
  function process_instance_is_complete_event (instance) result (flag)
    class(process_instance_t), intent(in) :: instance
    logical :: flag
    flag = instance%evaluation_status >= STAT_EVENT_COMPLETE
  end function process_instance_is_complete_event
  
@ %def process_instance_is_complete_event
@ Select a term for the process instance which is to provide the event
record.

Note: this should be done using random numbers and applying probabilities for
the various terms and components that belong to the selected MCI group.  The
current implementation simply selects the first term for the first active
component.
<<Processes: process instance: TBP>>=
  procedure :: select_i_term => process_instance_select_i_term
<<Processes: procedures>>=
  subroutine process_instance_select_i_term (instance, i_term)
    class(process_instance_t), intent(in) :: instance
    integer, intent(out) :: i_term
    integer :: i_mci, i_component
    i_mci = instance%i_mci
    i_component = instance%process%mci_entry(i_mci)%i_component(1)
    i_term = instance%process%component(i_component)%i_term(1)
  end subroutine process_instance_select_i_term
    
@ %def process_instance_select_i_term
@ Return pointer to the master beam interaction.
<<Processes: process instance: TBP>>=
  procedure :: get_beam_int_ptr => process_instance_get_beam_int_ptr
<<Processes: procedures>>=
  function process_instance_get_beam_int_ptr (instance) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    type(interaction_t), pointer :: ptr
    ptr => instance%sf_chain%get_beam_int_ptr ()
  end function process_instance_get_beam_int_ptr
  
@ %def process_instance_get_beam_int_ptr
@ Return pointers to the matrix and flows interactions, given a term index.
<<Processes: process instance: TBP>>=
  procedure :: get_trace_int_ptr => process_instance_get_trace_int_ptr
  procedure :: get_matrix_int_ptr => process_instance_get_matrix_int_ptr
  procedure :: get_flows_int_ptr => process_instance_get_flows_int_ptr
<<Processes: procedures>>=
  function process_instance_get_trace_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    ptr => instance%term(i_term)%connected%get_trace_int_ptr ()
  end function process_instance_get_trace_int_ptr
  
  function process_instance_get_matrix_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    select case (instance%term(i_term)%nlo_type)
    case (BORN, NLO_VIRTUAL, NLO_PDF)
      ptr => instance%term(i_term)%connected%get_matrix_int_ptr ()
    case (NLO_REAL)
      ptr => instance%term(i_term)%connected_real%get_matrix_int_ptr ()
    end select
  end function process_instance_get_matrix_int_ptr
  
  function process_instance_get_flows_int_ptr (instance, i_term) result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: ptr
    select case (instance%term(i_term)%nlo_type)
    case (BORN, NLO_VIRTUAL, NLO_PDF)
      ptr => instance%term(i_term)%connected%get_flows_int_ptr ()
    case (NLO_REAL)
      ptr => instance%term(i_term)%connected_real%get_flows_int_ptr ()
    end select
  end function process_instance_get_flows_int_ptr
  
@ %def process_instance_get_trace_int_ptr
@ %def process_instance_get_matrix_int_ptr
@ %def process_instance_get_flows_int_ptr
@ Return the complete account of flavor combinations in the underlying
interaction object, including beams, radiation, and hard interaction.
<<Processes: process instance: TBP>>=
  procedure :: get_state_flv => process_instance_get_state_flv
<<Processes: procedures>>=
  function process_instance_get_state_flv (instance, i_term) result (state_flv)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    type(state_flv_content_t) :: state_flv
    state_flv = instance%term(i_term)%connected%get_state_flv ()
  end function process_instance_get_state_flv
  
@ %def process_get_term_state_flv
@ Return pointers to the parton states of a selected term.
<<Processes: process instance: TBP>>=
  procedure :: get_isolated_state_ptr => &
       process_instance_get_isolated_state_ptr
  procedure :: get_connected_state_ptr => &
       process_instance_get_connected_state_ptr
<<Processes: procedures>>=
  function process_instance_get_isolated_state_ptr (instance, i_term) &
       result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(isolated_state_t), pointer :: ptr
    ptr => instance%term(i_term)%isolated
  end function process_instance_get_isolated_state_ptr
  
  function process_instance_get_connected_state_ptr (instance, i_term) &
       result (ptr)
    class(process_instance_t), intent(in), target :: instance
    integer, intent(in) :: i_term
    type(connected_state_t), pointer :: ptr
    ptr => instance%term(i_term)%connected
  end function process_instance_get_connected_state_ptr
  
@ %def process_instance_get_isolated_state_ptr
@ %def process_instance_get_connected_state_ptr
@ Return the indices of the beam particles and incoming partons within the
currently active state matrix, respectively.
<<Processes: process instance: TBP>>=
  procedure :: get_beam_index => process_instance_get_beam_index
  procedure :: get_in_index => process_instance_get_in_index
<<Processes: procedures>>=
  subroutine process_instance_get_beam_index (instance, i_term, i_beam)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    integer, dimension(:), intent(out) :: i_beam
    call instance%term(i_term)%connected%get_beam_index (i_beam)
  end subroutine process_instance_get_beam_index
  
  subroutine process_instance_get_in_index (instance, i_term, i_in)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    integer, dimension(:), intent(out) :: i_in
    call instance%term(i_term)%connected%get_in_index (i_in)
  end subroutine process_instance_get_in_index
  
@ %def process_instance_get_beam_index
@ %def process_instance_get_in_index
@ Return squared matrix element and event weight, and event weight
excess where applicable.
<<Processes: process instance: TBP>>=
  procedure :: get_sqme => process_instance_get_sqme
  procedure :: get_weight => process_instance_get_weight
  procedure :: get_excess => process_instance_get_excess
<<Processes: procedures>>=
  function process_instance_get_sqme (instance) result (sqme)
    class(process_instance_t), intent(in) :: instance
    real(default) :: sqme
    if (instance%evaluation_status >= STAT_EVALUATED_TRACE) then
       sqme = instance%sqme
    else
       sqme = 0
    end if
  end function process_instance_get_sqme
  
  function process_instance_get_weight (instance) result (weight)
    class(process_instance_t), intent(in) :: instance
    real(default) :: weight
    if (instance%evaluation_status >= STAT_EVENT_COMPLETE) then
       weight = instance%weight
    else
       weight = 0
    end if
  end function process_instance_get_weight
  
  function process_instance_get_excess (instance) result (excess)
    class(process_instance_t), intent(in) :: instance
    real(default) :: excess
    if (instance%evaluation_status >= STAT_EVENT_COMPLETE) then
       excess = instance%excess
    else
       excess = 0
    end if
  end function process_instance_get_excess
  
@ %def process_instance_get_sqme
@ %def process_instance_get_weight
@ %def process_instance_get_excess
@ Return the currently selected MCI channel.
<<Processes: process instance: TBP>>=
  procedure :: get_channel => process_instance_get_channel
<<Processes: procedures>>=
  function process_instance_get_channel (instance) result (channel)
    class(process_instance_t), intent(in) :: instance
    integer :: channel
    channel = instance%selected_channel
  end function process_instance_get_channel

@ %def process_instance_get_channel
@
<<Processes: process instance: TBP>>=
  procedure :: set_fac_scale => process_instance_set_fac_scale
<<Processes: procedures>>=
  subroutine process_instance_set_fac_scale (instance, fac_scale)
    class(process_instance_t), intent(inout) :: instance
    real(default), intent(in) :: fac_scale
    integer :: i_term
    i_term = 1
    call instance%term(i_term)%set_fac_scale (fac_scale)
  end subroutine process_instance_set_fac_scale

@ %def process_instance_set_fac_scale
@ Return factorization scale and strong coupling.  We have to select a
term instance.
<<Processes: process instance: TBP>>=
  procedure :: get_fac_scale => process_instance_get_fac_scale
  procedure :: get_alpha_s => process_instance_get_alpha_s
<<Processes: procedures>>=
  function process_instance_get_fac_scale (instance, i_term) result (fac_scale)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    real(default) :: fac_scale
    fac_scale = instance%term(i_term)%get_fac_scale ()
  end function process_instance_get_fac_scale
  
  function process_instance_get_alpha_s (instance, i_term) result (alpha_s)
    class(process_instance_t), intent(in) :: instance
    integer, intent(in) :: i_term
    real(default) :: alpha_s
    alpha_s = instance%term(i_term)%get_alpha_s (instance%component)
  end function process_instance_get_alpha_s
  
@ %def process_instance_get_fac_scale
@ %def process_instance_get_alpha_s
@ Counter.
<<Processes: process instance: TBP>>=
  procedure :: reset_counter => process_instance_reset_counter
  procedure :: record_call => process_instance_record_call
  procedure :: get_counter => process_instance_get_counter
<<Processes: procedures>>=
  subroutine process_instance_reset_counter (process_instance)
    class(process_instance_t), intent(inout) :: process_instance
    call process_instance%mci_work(process_instance%i_mci)%reset_counter ()
  end subroutine process_instance_reset_counter
  
  subroutine process_instance_record_call (process_instance)
    class(process_instance_t), intent(inout) :: process_instance
    call process_instance%mci_work(process_instance%i_mci)%record_call &
         (process_instance%evaluation_status)
  end subroutine process_instance_record_call
    
  function process_instance_get_counter (process_instance) result (counter)
    class(process_instance_t), intent(in) :: process_instance
    type(process_counter_t) :: counter
    counter = process_instance%mci_work(process_instance%i_mci)%get_counter ()
  end function process_instance_get_counter
  
@ %def process_instance_reset_counter
@ %def process_instance_record_call
@ %def process_instance_get_counter
@
\subsection{NLO Stuff}
[This should eventually be moved to a separate module.]

The NLO-aware version of the process-component manager.

This is the configuration object, which has the duty of allocating the
corresponding instance.  This is the nontrivial NLO version.
<<Processes: types>>=
  type, extends (pcm_t) :: pcm_nlo_t
   contains
   <<Processes: pcm nlo: TBP>>
  end type pcm_nlo_t
  
@ %def pcm_nlo_t 
<<Processes: pcm nlo: TBP>>=
  procedure :: allocate_instance => pcm_nlo_allocate_instance
<<Processes: procedures>>=
  subroutine pcm_nlo_allocate_instance (pcm, instance)
    class(pcm_nlo_t), intent(in) :: pcm
    class(pcm_instance_t), intent(inout), allocatable :: instance
    allocate (pcm_instance_nlo_t :: instance)
  end subroutine pcm_nlo_allocate_instance
    
@ %def pcm_nlo_allocate_instance
@
As a first implementation, it acts as a wrapper for the NLO controller
object and the squared matrix-element collector.
<<Processes: public>>=
  public :: pcm_instance_nlo_t
<<Processes: types>>=
  type, extends (pcm_instance_t) :: pcm_instance_nlo_t
     type(nlo_controller_t) :: controller
     logical :: collect_matrix_elements = .false.
     type(sqme_collector_t) :: collector
     integer :: active_real_component = 1
  end type pcm_instance_nlo_t

@ %def pcm_instance_nlo_t
@
\subsection{Particle sets}
Here we provide two procedures that convert the process instance
from/to a particle set.  The conversion applies to the trace evaluator
which has no quantum-number information, thus it involves only the
momenta and the parent-child relations.  We keep virtual particles.

Nevertheless, it is possible to reconstruct the complete structure
from a particle set.  The reconstruction implies a re-evaluation of
the structure function and matrix-element codes.

The [[i_term]] index is needed for both input and output, to select
among different active trace evaluators.

In both cases, the [[instance]] object must be properly initialized.

NB: The [[recover_beams]] option should be used only when the particle
set originates from an external event file, and the user has asked for
it.  It should be switched off when reading from raw event file.
<<Processes: process instance: TBP>>=
  procedure :: get_trace => process_instance_get_trace
  procedure :: set_trace => process_instance_set_trace
<<Processes: procedures>>=
  subroutine process_instance_get_trace (instance, pset, i_term)
    class(process_instance_t), intent(in), target :: instance
    type(particle_set_t), intent(out) :: pset
    integer, intent(in) :: i_term
    type(interaction_t), pointer :: int
    logical :: ok
    int => instance%get_trace_int_ptr (i_term)
    call pset%init (ok, int, int, FM_IGNORE_HELICITY, &
         [0._default, 0._default], .false., .true.)
  end subroutine process_instance_get_trace
    
  subroutine process_instance_set_trace &
       (instance, pset, i_term, recover_beams, check_match)
    class(process_instance_t), intent(inout), target :: instance
    type(particle_set_t), intent(in) :: pset
    integer, intent(in) :: i_term
    logical, intent(in), optional :: recover_beams, check_match
    type(interaction_t), pointer :: int
    integer :: n_in
    int => instance%get_trace_int_ptr (i_term)
    n_in = instance%process%get_n_in ()
    call pset%fill_interaction (int, n_in, &
         recover_beams = recover_beams, &
         check_match = check_match, &
         state_flv = instance%get_state_flv (i_term))
  end subroutine process_instance_set_trace

@ %def process_instance_get_trace
@ %def process_instance_set_trace
@ This procedure allows us to override any QCD setting of the WHIZARD process
and directly set the coupling value that comes together with a particle set.
<<Processes: process instance: TBP>>=
  procedure :: set_alpha_qcd_forced => process_instance_set_alpha_qcd_forced
<<Processes: procedures>>=
  subroutine process_instance_set_alpha_qcd_forced (instance, i_term, alpha_qcd)
    class(process_instance_t), intent(inout) :: instance
    integer, intent(in) :: i_term
    real(default), intent(in) :: alpha_qcd
    call instance%term(i_term)%set_alpha_qcd_forced (alpha_qcd)
  end subroutine process_instance_set_alpha_qcd_forced
  
@ %def process_instance_set_alpha_qcd_forced
@
<<Processes: process instance: TBP>>=
  procedure :: display_real_kinematics => &
       process_instance_display_real_kinematics
<<Processes: procedures>>=
  subroutine process_instance_display_real_kinematics (instance, i)
     class(process_instance_t), intent(in) :: instance
     integer, intent(in) :: i
     if (associated (instance%term(i)%nlo_controller)) then
        if (instance%term(i)%nlo_controller%counter_active) &
            call instance%term(i)%nlo_controller%counter%display ()
     end if
  end subroutine process_instance_display_real_kinematics

@ %def process_instance_display_real_kinematics
@
<<Processes: process instance: TBP>>=
  procedure :: has_nlo_component => process_instance_has_nlo_component
<<Processes: procedures>>=
  function process_instance_has_nlo_component (instance) result (nlo)
    class(process_instance_t), intent(in) :: instance
    logical :: nlo
    nlo = instance%process%is_nlo_calculation ()
  end function process_instance_has_nlo_component

@ %def process_instance_has_nlo_component
@
<<Processes: process instance: TBP>>=
  procedure :: has_blha_component => process_instance_has_blha_component
<<Processes: procedures>>=
  function process_instance_has_blha_component (instance) result (val)
    logical :: val
    class(process_instance_t), intent(in) :: instance
    integer :: i
    val = .false.
    do i = 1, size (instance%component)
       if (.not. associated (instance%component(i)%config)) cycle
       select type (core => instance%component(i)%config%core)
       class is (prc_blha_t)
          val = .true.
          exit
       end select
    end do
  end function process_instance_has_blha_component

@ %def process_instance_has_nlo_component
@
<<Processes: process instance: TBP>>=
  procedure :: get_fixed_emitter => process_instance_get_fixed_emitter
<<Processes: procedures>>=
  function process_instance_get_fixed_emitter (instance, i) result (emitter)
     integer :: emitter
     class(process_instance_t), intent(in) :: instance
     integer, intent(in) :: i
     emitter = instance%component(i)%config%config%get_fixed_emitter ()
  end function process_instance_get_fixed_emitter

@ %def process_instance_get_fixed_emitter
@
<<Processes: process instance: TBP>>=
  procedure :: create_blha_interface => process_instance_create_blha_interface
<<Processes: procedures>>=
  subroutine process_instance_create_blha_interface (instance)
    class(process_instance_t), intent(inout) :: instance
    logical :: use_external_borns
    logical :: use_external_real_trees
    logical :: use_external_loops
    logical :: use_external_correlations
    integer :: alpha_power, alphas_power
    integer, dimension(:,:), allocatable :: flv_born, flv_real
    integer :: i
    integer :: n_in
    type(blha_master_t) :: blha_master
    type(string_t) :: born_me_method
    type(string_t) :: real_tree_me_method
    type(string_t) :: loop_me_method
    type(string_t) :: correlation_me_method

    associate (process => instance%process)
       associate (var_list => process%meta%var_list)
          born_me_method = var_list%get_sval (var_str ("$born_me_method"))
          real_tree_me_method = var_list%get_sval (var_str ("$real_tree_me_method"))
          loop_me_method = var_list%get_sval (var_str ("$loop_me_method"))
          correlation_me_method = var_list%get_sval (var_str ("$correlation_me_method"))
          alpha_power = var_list%get_ival (&
                                           var_str ('alpha_power'))
          alphas_power = var_list%get_ival (&
                                           var_str ('alphas_power'))
       end associate
       do i = 1, size (process%term)
          if (instance%component(i)%nlo_type == BORN) then
             flv_born = process%term(i)%data%flv_state
             n_in = process%term(i)%data%n_in
          else if (instance%component(i)%nlo_type == NLO_REAL) then
             flv_real = process%term(i)%data%flv_state
             n_in = process%term(i)%data%n_in
          end if
       end do
       use_external_borns = born_me_method /= 'omega'
       use_external_real_trees = real_tree_me_method /= 'omega'
       use_external_loops = loop_me_method /= 'omega'
       use_external_correlations = correlation_me_method /= 'omega'

       select case (char (loop_me_method))
       case ('gosam')
          call blha_master%set_gosam (1)
       case ('openloops')
          call blha_master%set_openloops (1)
       end select
       select case (char (correlation_me_method))
       case ('gosam')
          call blha_master%set_gosam (2)
       case ('openloops')
          call blha_master%set_openloops (2)
       end select
       select case (char (real_tree_me_method))
       case ('gosam')
          call blha_master%set_gosam (3)
       case ('openloops')
          call blha_master%set_openloops (3)
       end select
       select case (char (born_me_method))
       case ('gosam')
          call blha_master%set_gosam (4)
       case ('openloops')
          call blha_master%set_openloops (4)
       end select

       call blha_master%init (process%meta%id, process%config%model, &
                              n_in, size (flv_born,1)-n_in, &
                              use_external_borns, use_external_loops, &
                              use_external_correlations, use_external_real_trees, &
                              alpha_power, alphas_power, &
                              flv_born, flv_real)
       call blha_master%generate (process%meta%id)
    end associate 
  end subroutine process_instance_create_blha_interface 

@ %def process_instance_create_blha_interface
@
<<Processes: process instance: TBP>>=
  procedure :: load_blha_libraries => process_instance_load_blha_libraries
<<Processes: procedures>>=
  subroutine process_instance_load_blha_libraries (instance, os_data)
    class(process_instance_t), intent(inout), target :: instance
    type(os_data_t), intent(in) :: os_data
    type(string_t) :: libname
    integer :: i
    type(process_component_t), pointer :: component_config => null ()
    select type (pcm => instance%pcm)
    class is (pcm_instance_nlo_t)
       do i = 1, size (instance%component)
          component_config => instance%component(i)%config
          if (associated (component_config)) then
             if (.not. component_config%active) cycle
             select type (core => component_config%core)
             type is (prc_gosam_t)
                libname = instance%process%get_library_name ()
                call core%prepare_library (os_data, libname)
                call core%start ()
                call core%read_contract_file (instance%process%term(i)%data%flv_state)
                call core%set_particle_properties (instance%process%config%model)
                call core%set_alpha_qed (instance%process%config%model)
                call core%print_parameter_file ()
             type is (prc_openloops_t)
                call core%set_n_external (pcm%controller%get_n_particles ())
                call core%prepare_library (os_data, instance%process%config%model, &
                     instance%process%meta%var_list)
                call core%start ()
                call core%read_contract_file (instance%process%term(i)%data%flv_state)
                call core%print_parameter_file ()
             end select
          end if
       end do
       nullify (component_config)
    end select
  end subroutine process_instance_load_blha_libraries

@ %def process_instance_load_blha_libraries
@
The [[pacify]] subroutine has the purpose of setting numbers to zero
which are (by comparing with a [[tolerance]] parameter) considered
equivalent with zero.  We do this in some unit tests.  Here, we a
apply this to the phase space subobject of the process instance.
<<Processes: public>>=
  public :: pacify
<<Processes: interfaces>>=
  interface pacify
     module procedure pacify_process_instance
  end interface pacify
  
<<Processes: procedures>>=
  subroutine pacify_process_instance (instance)
    type(process_instance_t), intent(inout) :: instance
    integer :: i
    do i = 1, size (instance%component)
       call pacify (instance%component(i)%k_seed%phs)
    end do
  end subroutine pacify_process_instance
    
@ %def pacify
@
<<Processes: public>>=
  public :: setup_nlo_component_cores
<<Processes: procedures>>=
  subroutine setup_nlo_component_cores (process)
    type(process_t), intent(inout), target :: process
    integer :: i_sub
    integer :: n_components, i_component
    n_components = process%get_n_components ()

    do i_component = 1, n_components
       select case (process%get_component_nlo_type (i_component))
       case (NLO_SUBTRACTION)
          i_sub = i_component
          exit
       end select
    end do

    do i_component = 1, n_components
       select case (process%get_component_nlo_type (i_component))
       case (NLO_REAL, NLO_VIRTUAL)
          associate (component => process%component (i_component))
             component%core_sub_born => process%component(i_sub)%core 
          end associate
       end select
    end do
  end subroutine setup_nlo_component_cores

@ %def setup_nlo_component_cores
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[processes_ut.f90]]>>=
<<File header>>

module processes_ut
  use unit_tests
  use processes_uti
  
<<Standard module head>>

<<Processes: public test>>

<<Processes: public test auxiliary>>

contains
  
<<Processes: test driver>>

end module processes_ut
@ %def processes_ut
@
<<[[processes_uti.f90]]>>=
<<File header>>

module processes_uti

<<Use kinds>>
<<Use strings>>
  use format_utils, only: write_separator
  use constants, only: TWOPI4
  use physics_defs, only: CONV
  use os_interface
  use sm_qcd
  use lorentz
  use pdg_arrays
  use model_data
  use flavors
  use interactions, only: reset_interaction_counter
  use particles
  use rng_base
  use mci_base
  use mci_midpoint
  use sf_mappings
  use sf_base
  use phs_base
  use phs_single
  use process_constants
  use prc_core
  use prc_test, only: prc_test_create_library
  use process_libraries

  use processes

  use rng_base_ut, only: rng_test_factory_t
  use sf_base_ut, only: sf_test_data_t
  use mci_base_ut, only: mci_test_t
  use phs_base_ut, only: phs_test_config_t

<<Standard module head>>

<<Processes: public test auxiliary>>

<<Processes: test declarations>>

contains

<<Processes: tests>>

<<Processes: test auxiliary>>

end module processes_uti
  
@ %def processes_uti
@ API: driver for the unit tests below.
<<Processes: public test>>=
  public :: processes_test
<<Processes: test driver>>=
  subroutine processes_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Processes: execute tests>>
  end subroutine processes_test
  
@ %def processes_test
@
\subsubsection{Test process type}
For the following tests, we define a simple implementation of the abstract
[[prc_core_t]], designed such as to complement the [[prc_test_t]]
process definition type.

Note that it is not given that the actual process is defined as
[[prc_test_t]] type.  We enforce this by calling
[[prc_test_create_library]].  The driver component in the process core
will then become of type [[prc_test_t]].
<<Processes: public>>=
  public :: test_t
<<Processes: test types>>=
  type, extends (prc_core_t) :: test_t
   contains
     procedure :: write => test_write
     procedure :: needs_mcset => test_needs_mcset
     procedure :: get_n_terms => test_get_n_terms
     procedure :: is_allowed => test_is_allowed
     procedure :: compute_hard_kinematics => test_compute_hard_kinematics
     procedure :: compute_eff_kinematics => test_compute_eff_kinematics
     procedure :: recover_kinematics => test_recover_kinematics
     procedure :: compute_amplitude => test_compute_amplitude
  end type test_t

@ %def test_t
<<Processes: test type procedures>>=
  subroutine test_write (object, unit)
    class(test_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "test type implementing prc_test"
  end subroutine test_write
  
@ %def test_write
@ This process type always needs a MC parameter set and a
single term.  This only state is always allowed.
<<Processes: test type procedures>>=
  function test_needs_mcset (object) result (flag)
    class(test_t), intent(in) :: object
    logical :: flag
    flag = .true.
  end function test_needs_mcset
  
  function test_get_n_terms (object) result (n)
    class(test_t), intent(in) :: object
    integer :: n
    n = 1
  end function test_get_n_terms
  
  function test_is_allowed (object, i_term, f, h, c) result (flag)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term, f, h, c
    logical :: flag
    flag = .true.
  end function test_is_allowed
  
@ %def test_needs_mcset
@ %def test_get_n_terms
@ %def test_is_allowed
@ Transfer the generated momenta directly to the hard interaction in
the (only) term.  We assume that everything has been set up correctly,
so the array fits.
<<Processes: test type procedures>>=
  subroutine test_compute_hard_kinematics &
       (object, p_seed, i_term, int_hard, core_state)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(in) :: p_seed
    integer, intent(in) :: i_term
    type(interaction_t), intent(inout) :: int_hard
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    call int_hard%set_momenta (p_seed)
  end subroutine test_compute_hard_kinematics
  
@ %def test_compute_hard_kinematics
@ This procedure is not called for [[test_t]], just a placeholder.
<<Processes: test type procedures>>=
  subroutine test_compute_eff_kinematics &
       (object, i_term, int_hard, int_eff, core_state)
    class(test_t), intent(in) :: object
    integer, intent(in) :: i_term
    type(interaction_t), intent(in) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
  end subroutine test_compute_eff_kinematics
  
@ %def test_compute_eff_kinematics
@ Transfer the incoming momenta of [[p_seed]] directly to the
effective interaction, and vice versa for the outgoing momenta.

[[int_hard]] is left untouched since [[int_eff]] is an alias (via
pointer) to it.
<<Processes: test type procedures>>=
  subroutine test_recover_kinematics &
       (object, p_seed, int_hard, int_eff, core_state)
    class(test_t), intent(in) :: object
    type(vector4_t), dimension(:), intent(inout) :: p_seed
    type(interaction_t), intent(inout) :: int_hard
    type(interaction_t), intent(inout) :: int_eff
    class(prc_core_state_t), intent(inout), allocatable :: core_state
    integer :: n_in
    n_in = int_eff%get_n_in ()
    call int_eff%set_momenta (p_seed(1:n_in), outgoing = .false.)
    p_seed(n_in+1:) = int_eff%get_momenta (outgoing = .true.)
  end subroutine test_recover_kinematics
    
@ %def test_recover_kinematics
@ Compute the amplitude.  The driver ignores all quantum numbers and,
in fact, returns a constant.  Nevertheless, we properly transfer the
momentum vectors.
<<Processes: test type procedures>>=
  function test_compute_amplitude &
       (object, j, p, f, h, c, fac_scale, ren_scale, alpha_qcd_forced, core_state) &
       result (amp)
    class(test_t), intent(in) :: object
    integer, intent(in) :: j
    type(vector4_t), dimension(:), intent(in) :: p
    integer, intent(in) :: f, h, c
    real(default), intent(in) :: fac_scale, ren_scale
    real(default), intent(in), allocatable :: alpha_qcd_forced
    class(prc_core_state_t), intent(inout), allocatable, optional :: core_state
    complex(default) :: amp
    real(default), dimension(:,:), allocatable :: parray
    integer :: i, n_tot
    select type (driver => object%driver)
    type is (prc_test_t)
       if (driver%scattering) then
          n_tot = 4
       else
          n_tot = 3
       end if
       allocate (parray (0:3,n_tot))
       forall (i = 1:n_tot)  parray(:,i) = vector4_get_components (p(i))
       amp = driver%get_amplitude (parray)
    end select
  end function test_compute_amplitude
    
@ %def test_compute_amplitude
@
\subsubsection{Write an empty process object}
The most trivial test is to write an uninitialized process object.
<<Processes: execute tests>>=
  call test (processes_1, "processes_1", &
       "write an empty process object", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_1
<<Processes: tests>>=
  subroutine processes_1 (u)
    integer, intent(in) :: u
    type(process_t) :: process

    write (u, "(A)")  "* Test output: processes_1"
    write (u, "(A)")  "*   Purpose: display an empty process object"
    write (u, "(A)")

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_1"
    
  end subroutine processes_1
  
@ %def processes_1
@
\subsubsection{Initialize a process object}
Initialize a process and display it.
<<Processes: execute tests>>=
  call test (processes_2, "processes_2", &
       "initialize a simple process object", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_2
<<Processes: tests>>=
  subroutine processes_2 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template

    write (u, "(A)")  "* Test output: processes_2"
    write (u, "(A)")  "*   Purpose: initialize a simple process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes2"
    procname = libname
    run_id = "run2"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    call process%setup_mci ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_2"
    
  end subroutine processes_2
  
@ %def processes_2
@
\subsubsection{Compute a trivial matrix element}
Initialize a process, retrieve some information and compute a matrix
element.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Processes: execute tests>>=
  call test (processes_3, "processes_3", &
       "retrieve a trivial matrix element", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_3
<<Processes: tests>>=
  subroutine processes_3 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_constants_t) :: data
    type(vector4_t), dimension(:), allocatable :: p

    write (u, "(A)")  "* Test output: processes_3"
    write (u, "(A)")  "*   Purpose: create a process &
         &and compute a matrix element"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes3"
    procname = libname
    run_id = "run3"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t)
       call mci_template%set_dimensions (2, 2)
       call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Return the number of process components"
    write (u, "(A)")

    write (u, "(A,I0)")  "n_components = ", process%get_n_components ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Return the number of flavor states"
    write (u, "(A)")

    data = process%get_constants (1)
    
    write (u, "(A,I0)")  "n_flv(1) = ", data%n_flv
    
    write (u, "(A)")
    write (u, "(A)")  "* Return the first flavor state"
    write (u, "(A)")

    write (u, "(A,4(1x,I0))")  "flv_state(1) =", data%flv_state (:,1)

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics &
         &[arbitrary, the matrix element is constant]"
    
    allocate (p (4))

    write (u, "(A)")
    write (u, "(A)")  "* Retrieve the matrix element"
    write (u, "(A)")

    write (u, "(A,F5.3,' + ',F5.3,' I')")  "me (1, p, 1, 1, 1) = ", &
         process%compute_amplitude (1, 1, p, 1, 1, 1)
    

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_3"
    
  end subroutine processes_3
  
@ %def processes_3
@
\subsubsection{Generate a process instance}
Initialize a process and process instance, choose a sampling point and
fill the process instance.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Processes: execute tests>>=
  call test (processes_4, "processes_4", &
       "create and fill a process instance (partonic event)", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_4
<<Processes: tests>>=
  subroutine processes_4 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_4"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes4"
    procname = libname
    run_id = "run4"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model) 
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call pset%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)

    call process_instance%activate ()
    process_instance%evaluation_status = STAT_EFF_KINEMATICS
    call process_instance%recover_hard_kinematics (i_term = 1)
    call process_instance%recover_seed_kinematics (i_term = 1)
    call process_instance%select_channel (1)
    call process_instance%recover_mcpar (i_term = 1)

    call process_instance%compute_seed_kinematics (skip_term = 1)
    call process_instance%compute_hard_kinematics (skip_term = 1)
    call process_instance%compute_eff_kinematics (skip_term = 1)

    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels (skip_term = 1)
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call pset%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_4"
    
  end subroutine processes_4
  
@ %def processes_4
@
\subsubsection{Structure function configuration}
Configure structure functions (multi-channel) in a process object.
<<Processes: execute tests>>=
  call test (processes_7, "processes_7", &
       "process configuration with structure functions", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_7
<<Processes: tests>>=
  subroutine processes_7 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t), dimension(2) :: sf_channel

    write (u, "(A)")  "* Test output: processes_7"
    write (u, "(A)")  "*   Purpose: initialize a process with &
         &structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes7"
    procname = libname
    run_id = "run7"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       model => process%get_model_ptr ()
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)

    call process%test_allocate_sf_channels (3)

    call sf_channel(1)%init (2)
    call sf_channel(1)%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel(1))
    
    call sf_channel(2)%init (2)
    call sf_channel(2)%set_s_mapping ([1,2])
    call process%set_sf_channel (3, sf_channel(2))
    
    call process%setup_mci ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_7"
    
  end subroutine processes_7
  
@ %def processes_7
@
\subsubsection{Evaluating a process with structure function}
Configure structure functions (single-channel) in a process object,
create an instance, compute kinematics and evaluate.

Note the order of operations when setting up structure functions and
phase space.  The beams are first, they determine the [[sqrts]] value.
We can also set up the chain of structure functions.  We then
configure the phase space.  From this, we can obtain information about
special configurations (resonances, etc.), which we need for
allocating the possible structure-function channels (parameterizations
and mappings).  Finally, we match phase-space channels onto
structure-function channels.

In the current example, this matching is trivial; we only have one
structure-function channel.
<<Processes: execute tests>>=
  call test (processes_8, "processes_8", &
       "process evaluation with structure functions", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_8
<<Processes: tests>>=
  subroutine processes_8 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t) :: sf_channel
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_8"
    write (u, "(A)")  "*   Purpose: evaluate a process with &
         &structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes8"
    procname = libname
    run_id = "run8"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)

    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       model => process%get_model_ptr ()
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)
    
    call process%configure_phs ()
    
    call process%test_allocate_sf_channels (1)

    call sf_channel%init (2)
    call sf_channel%activate_mapping ([1,2])
    call process%set_sf_channel (1, sf_channel)
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_mci ()
    call process%setup_terms ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Set up kinematics and evaluate"
    write (u, "(A)")

    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, &
         [0.8_default, 0.8_default, 0.1_default, 0.2_default])
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call pset%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)
    call process_instance%recover &
         (channel = 1, i_term = 1, update_sqme = .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call pset%final ()

    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_8"
    
  end subroutine processes_8
  
@ %def processes_8
@
\subsubsection{Multi-channel phase space and structure function}
This is an extension of the previous example.  This time, we have two
distinct structure-function channels which are matched to the two
distinct phase-space channels.
<<Processes: execute tests>>=
  call test (processes_9, "processes_9", &
       "multichannel kinematics and structure functions", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_9
<<Processes: tests>>=
  subroutine processes_9 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t) :: sf_channel
    real(default), dimension(4) :: x_saved
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_9"
    write (u, "(A)")  "*   Purpose: evaluate a process with &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes9"
    procname = libname
    run_id = "run9"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)

    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       model => process%get_model_ptr ()
       call data%init (model, pdg_in)
    end select

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)
    
    call process%configure_phs ()
    
    call process%test_allocate_sf_channels (2)

    call sf_channel%init (2)
    call process%set_sf_channel (1, sf_channel)
    
    call sf_channel%init (2)
    call sf_channel%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel)
    
    call process%test_set_component_sf_channel ([1, 2])

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_mci ()
    call process%setup_terms ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Set up kinematics in channel 1 and evaluate"
    write (u, "(A)")

    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, &
         [0.8_default, 0.8_default, 0.1_default, 0.2_default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extract MC input parameters"
    write (u, "(A)")
    
    write (u, "(A)")  "Channel 1:"
    call process_instance%get_mcpar (1, x_saved)
    write (u, "(2x,9(1x,F7.5))")  x_saved

    write (u, "(A)")  "Channel 2:"
    call process_instance%get_mcpar (2, x_saved)
    write (u, "(2x,9(1x,F7.5))")  x_saved

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics in channel 2 and evaluate"
    write (u, "(A)")

    call process_instance%evaluate_sqme (2, x_saved)
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance for channel 2"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)
    call process_instance%recover &
         (channel = 2, i_term = 1, update_sqme = .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call pset%final ()

    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_9"
    
  end subroutine processes_9
  
@ %def processes_9
@
\subsubsection{Event generation}
Activate the MC integrator for the process object and use it to
generate a single event.  Note that the test integrator does not
require integration in preparation for generating events.
<<Processes: execute tests>>=
  call test (processes_10, "processes_10", &
       "event generation", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_10
<<Processes: tests>>=
  subroutine processes_10 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(mci_t), pointer :: mci
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_10"
    write (u, "(A)")  "*   Purpose: generate events for a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes10"
    procname = libname
    run_id = "run10"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t);  call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Generate weighted event"
    write (u, "(A)")

    call process%test_get_mci_ptr (mci)
    select type (mci)
    type is (mci_test_t)
       ! This ensures that the next 'random' numbers are 0.3, 0.5, 0.7
       call mci%rng%init (3)
       ! Include the constant PHS factor in the stored maximum of the integrand
       call mci%set_max_factor (conv * twopi4 &
            / (2 * sqrt (lambda (sqrts **2, 125._default**2, 125._default**2))))
    end select

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate unweighted event"
    write (u, "(A)")

    call process%generate_unweighted_event (process_instance, 1)
    call process%test_get_mci_ptr (mci)
    select type (mci)
    type is (mci_test_t)
       write (u, "(A,I0)")  " Success in try ", mci%tries
       write (u, "(A)")
    end select
    
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_10"
    
  end subroutine processes_10
  
@ %def processes_10
@
\subsubsection{Integration}
Activate the MC integrator for the process object and use it to
integrate over phase space.
<<Processes: execute tests>>=
  call test (processes_11, "processes_11", &
       "integration", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_11
<<Processes: tests>>=
  subroutine processes_11 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_11"
    write (u, "(A)")  "*   Purpose: integrate a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes11"
    procname = libname
    run_id = "run11"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t)
       call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Integrate with default test parameters"
    write (u, "(A)")

    call process%integrate (process_instance, 1, n_it=1, n_calls=10000)
    call process%final_integration (1)
    
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A,ES13.7)")  " Integral divided by phs factor = ", &
         process%get_integral (1) &
         / process_instance%component(1)%k_seed%phs_factor

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_11"
    
  end subroutine processes_11
  
@ %def processes_11
@
\subsubsection{Complete events}
For the purpose of simplifying further tests, we implement a
convenience routine that initializes a process and prepares a single
event.  This is a wrapup of the test [[processes_10]].

The procedure is re-exported by the [[processes_ut]] module.
<<Processes: public test auxiliary>>=
  public :: prepare_test_process
<<Processes: test auxiliary>>=
  subroutine prepare_test_process (process, process_instance, model)
    type(process_t), intent(out), target :: process
    type(process_instance_t), intent(out), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: process_model
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(mci_t), pointer :: mci
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    libname = "processes_test"
    procname = libname
    run_id = "run_test"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call reset_interaction_counter ()
    allocate (process_model)
    call process_model%init (model%get_name (), &
         model%get_n_real (), &
         model%get_n_complex (), &
         model%get_n_field (), &
         model%get_n_vtx ())
    call process_model%copy_from (model)
    call process%init (procname, run_id, &
         lib, os_data, qcd, rng_factory, process_model)
    allocate (test_t :: core_template)
    allocate (mci_test_t :: mci_template)
    select type (mci_template)
    type is (mci_test_t);  call mci_template%set_divisions (100)
    end select
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()
    call process_instance%init (process)
    call process%test_get_mci_ptr (mci)
    select type (mci)
    type is (mci_test_t)
       ! This ensures that the next 'random' numbers are 0.3, 0.5, 0.7
       call mci%rng%init (3)
       ! Include the constant PHS factor in the stored maximum of the integrand
       call mci%set_max_factor (conv * twopi4 &
            / (2 * sqrt (lambda (sqrts **2, 125._default**2, 125._default**2))))
    end select
  end subroutine prepare_test_process

@ %def prepare_test_process
@ Here we do the cleanup of the process and process instance emitted
by the previous routine.
<<Processes: public>>=
  public :: cleanup_test_process
<<Processes: procedures>>=
  subroutine cleanup_test_process (process, process_instance)
    type(process_t), intent(inout) :: process
    type(process_instance_t), intent(inout) :: process_instance
    call process_instance%final ()
    call process%final ()
  end subroutine cleanup_test_process
    
@ %def cleanup_test_process
@ 
This is the actual test.  Prepare the test process and event, fill
all evaluators, and display the results.  Use a particle set as
temporary storage, read kinematics and recalculate the event.
<<Processes: execute tests>>=
  call test (processes_12, "processes_12", &
       "event post-processing", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_12
<<Processes: tests>>=
  subroutine processes_12 (u)
    integer, intent(in) :: u
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: processes_12"
    write (u, "(A)")  "*   Purpose: generate a complete partonic event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Build and initialize process and process instance &
         &and generate event"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    call process%prepare_simulation (1)
    call process_instance%init_simulation (1)
    call process%generate_weighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)

    call process_instance%final_simulation (1)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Recover kinematics and recalculate"
    write (u, "(A)")

    call reset_interaction_counter (2)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)
    call process_instance%recover &
         (channel = 1, i_term = 1, update_sqme = .true.)

    call process%recover_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    call process_instance%write (u)
    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_12"
    
  end subroutine processes_12
  
@ %def processes_12
@
\subsubsection{Colored interaction}
This test specifically checks the transformation of process data
(flavor, helicity, and color) into an interaction in a process term.

We use the [[test_t]] process core (which has no nontrivial
particles), but call only the [[is_allowed]] method, which always
returns true.
<<Processes: execute tests>>=
  call test (processes_13, "processes_13", &
       "colored interaction", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_13
<<Processes: tests>>=
  subroutine processes_13 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
    type(process_term_t) :: term
    class(prc_core_t), allocatable :: core
    
    write (u, "(A)")  "* Test output: processes_13"
    write (u, "(A)")  "*   Purpose: initialized a colored interaction"
    write (u, "(A)")

    write (u, "(A)")  "* Set up a process constants block"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_sm_test ()
!    call model_list%read_model (var_str ("QCD"), var_str ("QCD.mdl"), &
!         os_data, model)
    allocate (test_t :: core)

    associate (data => term%data)
      data%n_in = 2
      data%n_out = 3
      data%n_flv = 2
      data%n_hel = 2
      data%n_col = 2
      data%n_cin = 2

      allocate (data%flv_state (5, 2))
      data%flv_state (:,1) = [ 1, 21, 1, 21, 21]
      data%flv_state (:,2) = [ 2, 21, 2, 21, 21]

      allocate (data%hel_state (5, 2))
      data%hel_state (:,1) = [1, 1, 1, 1, 0]
      data%hel_state (:,2) = [1,-1, 1,-1, 0]

      allocate (data%col_state (2, 5, 2))
      data%col_state (:,:,1) = &
           reshape ([[1, 0], [2,-1], [3, 0], [2,-3], [0,0]], [2,5])
      data%col_state (:,:,2) = &
           reshape ([[1, 0], [2,-3], [3, 0], [2,-1], [0,0]], [2,5])

      allocate (data%ghost_flag (5, 2))
      data%ghost_flag(1:4,:) = .false.
      data%ghost_flag(5,:) = .true.
     
    end associate
    
    write (u, "(A)")  "* Set up the interaction"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    call term%setup_interaction (core, model)
    call term%int%basic_write (u)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_13"
  end subroutine processes_13
    
@ %def processes_13
@
\subsubsection{MD5 sums}
Configure a process with structure functions (multi-channel) and
compute MD5 sums
<<Processes: execute tests>>=
  call test (processes_14, "processes_14", &
       "process configuration and MD5 sum", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_14
<<Processes: tests>>=
  subroutine processes_14 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(pdg_array_t) :: pdg_in
    class(sf_data_t), allocatable, target :: data
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_channel_t), dimension(3) :: sf_channel

    write (u, "(A)")  "* Test output: processes_14"
    write (u, "(A)")  "*   Purpose: initialize a process with &
         &structure functions"
    write (u, "(A)")  "*            and compute MD5 sum"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes7"
    procname = libname
    run_id = "run7"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)
    call lib%compute_md5sum ()
    
    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Set beam, structure functions, and mappings"
    write (u, "(A)")

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    
    pdg_in = 25
    allocate (sf_test_data_t :: data)
    select type (data)
    type is (sf_test_data_t)
       model => process%get_model_ptr ()
       call data%init (model, pdg_in)
    end select

    call process%test_allocate_sf_channels (3)

    allocate (sf_config (2))
    call sf_config(1)%init ([1], data)
    call sf_config(2)%init ([2], data)
    call process%init_sf_chain (sf_config)
    deallocate (sf_config)

    call sf_channel(1)%init (2)
    call process%set_sf_channel (1, sf_channel(1))

    call sf_channel(2)%init (2)
    call sf_channel(2)%activate_mapping ([1,2])
    call process%set_sf_channel (2, sf_channel(2))
    
    call sf_channel(3)%init (2)
    call sf_channel(3)%set_s_mapping ([1,2])
    call process%set_sf_channel (3, sf_channel(3))
    
    call process%setup_mci ()

    call process%compute_md5sum ()

    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call process%final ()
    deallocate (process)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_14"
    
  end subroutine processes_14
  
@ %def processes_14
@
\subsubsection{Decay Process Evaluation}
Initialize an evaluate a decay process.
<<Processes: execute tests>>=
  call test (processes_15, "processes_15", &
       "decay process", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_15
<<Processes: tests>>=
  subroutine processes_15 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset

    write (u, "(A)")  "* Test output: processes_15"
    write (u, "(A)")  "*   Purpose: initialize a decay process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes15"
    procname = libname
    run_id = "run15"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)

    allocate (model)
    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    call process%setup_beams_decay ()
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call pset%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)
    call process_instance%recover (1, 1, .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call pset%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_15"
    
  end subroutine processes_15
  
@ %def processes_15
@
\subsubsection{Integration: decay}
Activate the MC integrator for the decay object and use it to
integrate over phase space.
<<Processes: execute tests>>=
  call test (processes_16, "processes_16", &
       "decay integration", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_16
<<Processes: tests>>=
  subroutine processes_16 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_16"
    write (u, "(A)")  "*   Purpose: integrate a process without &
         &structure functions"
    write (u, "(A)")  "*            in a multi-channel configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Build and initialize a process object"
    write (u, "(A)")

    libname = "processes16"
    procname = libname
    run_id = "run16"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)

    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")

    call process%setup_beams_decay ()
    call process%configure_phs ()

    call process%setup_mci ()
    
    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")  "* Integrate with default test parameters"
    write (u, "(A)")

    call process%integrate (process_instance, 1, n_it=1, n_calls=10000)
    call process%final_integration (1)
    
    call process%write (.false., u)

    write (u, "(A)")
    write (u, "(A,ES13.7)")  " Integral divided by phs factor = ", &
         process%get_integral (1) &
         / process_instance%component(1)%k_seed%phs_factor

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_16"
    
  end subroutine processes_16
  
@ %def processes_16
@
\subsubsection{Decay Process Evaluation}
Initialize an evaluate a decay process for a moving particle.
<<Processes: execute tests>>=
  call test (processes_17, "processes_17", &
       "decay of moving particle", &
       u, results)
<<Processes: test declarations>>=
  public :: processes_17
<<Processes: tests>>=
  subroutine processes_17 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: pset
    type(flavor_t) :: flv_beam
    real(default) :: m, p, E

    write (u, "(A)")  "* Test output: processes_17"
    write (u, "(A)")  "*   Purpose: initialize a decay process object"
    write (u, "(A)")

    write (u, "(A)")  "* Build and load a test library with one process"
    write (u, "(A)")

    libname = "processes17"
    procname = libname
    run_id = "run17"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)

    call prc_test_create_library (libname, lib, scattering = .false., &
         decay = .true.)

    write (u, "(A)")  "* Initialize a process object"
    write (u, "(A)")

    allocate (model)
    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    allocate (process)
    call process%init (procname, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    call process%setup_beams_decay (rest_frame = .false.)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization"
    write (u, "(A)")

    call process%setup_terms ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set parent momentum and random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])

    model => process%get_model_ptr ()
    call flv_beam%init (25, model)
    m = flv_beam%get_mass ()
    p = 3 * m / 4
    E = sqrt (m**2 + p**2)
    call process_instance%set_beam_momenta ([vector4_moving (E, p, 3)])
     
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Set up hard kinematics"
    write (u, "(A)")
  
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()

    write (u, "(A)")  "* Evaluate matrix element and square"
    write (u, "(A)")
  
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()
    call process_instance%write (u)

    call process_instance%get_trace (pset, 1)
    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Particle content:"
    write (u, "(A)")
    
    call write_separator (u)
    call pset%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recover process instance"
    write (u, "(A)")

    call reset_interaction_counter (3)

    allocate (process_instance)
    call process_instance%init (process)

    call process_instance%choose_mci (1)
    call process_instance%set_trace (pset, 1, check_match = .false.)
    call process_instance%recover (1, 1, .true.)
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call pset%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_17"
    
  end subroutine processes_17
  
@ %def processes_17
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process Stacks}

For storing and handling multiple processes, we define process stacks.
These are ordinary stacks where new process entries are pushed onto
the top.  We allow for multiple entries with identical process ID, but
distinct run ID.

The implementation is essentially identical to the [[prclib_stacks]] module
above.  Unfortunately, Fortran supports no generic programming, so we do not
make use of this fact.

When searching for a specific process ID, we will get (a pointer to)
the topmost process entry with that ID on the stack, which was entered
last.  Usually, this is the best version of the process (in terms of
integral, etc.)  Thus the stack terminology makes sense.
<<[[process_stacks.f90]]>>=
<<File header>>

module process_stacks
  
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use os_interface
  use sm_qcd
  use model_data
  use rng_base
  use variables
  use observables
  use process_libraries
  use processes

<<Standard module head>>

<<Process stacks: public>>

<<Process stacks: types>>

contains
  
<<Process stacks: procedures>>

end module process_stacks
@ %def process_stacks
@
\subsection{The process entry type}
A process entry is a process object, augmented by a pointer to the
next entry.  We do not need specific methods, all relevant methods are
inherited.

On higher level, processes should be prepared as process entry objects.
<<Process stacks: public>>=
  public :: process_entry_t
<<Process stacks: types>>=
  type, extends (process_t) :: process_entry_t
     type(process_entry_t), pointer :: next => null ()
  end type process_entry_t

@ %def process_entry_t
@
\subsection{The process stack type}
For easy conversion and lookup it is useful to store the filling
number in the object.  The content is stored as a linked list.

The [[var_list]] component stores process-specific results, so they
can be retrieved as (pseudo) variables.

The process stack can be linked to another one.  This allows us to
work with stacks of local scope.
<<Process stacks: public>>=
  public :: process_stack_t
<<Process stacks: types>>=
  type :: process_stack_t
     integer :: n = 0
     type(process_entry_t), pointer :: first => null ()
     type(var_list_t), pointer :: var_list => null ()
     type(process_stack_t), pointer :: next => null ()
   contains
   <<Process stacks: process stack: TBP>>
  end type process_stack_t
  
@ %def process_stack_t
@ Finalize partly: deallocate the process stack and variable list
entries, but keep the variable list as an empty object.  This way, the
variable list links are kept.
<<Process stacks: process stack: TBP>>=
  procedure :: clear => process_stack_clear
<<Process stacks: procedures>>=
  subroutine process_stack_clear (stack)
    class(process_stack_t), intent(inout) :: stack
    type(process_entry_t), pointer :: process
    if (associated (stack%var_list)) then
       call stack%var_list%final ()
    end if
    do while (associated (stack%first))
       process => stack%first
       stack%first => process%next
       call process%final ()
       deallocate (process)
    end do
    stack%n = 0
  end subroutine process_stack_clear
  
@ %def process_stack_clear
@ Finalizer.  Clear and deallocate the variable list.
<<Process stacks: process stack: TBP>>=
  procedure :: final => process_stack_final
<<Process stacks: procedures>>=
  subroutine process_stack_final (object)
    class(process_stack_t), intent(inout) :: object
    call object%clear ()
    if (associated (object%var_list)) then
       deallocate (object%var_list)
    end if
  end subroutine process_stack_final
  
@ %def process_stack_final
@ Output.  The processes on the stack will be ordered LIFO, i.e.,
backwards.
<<Process stacks: process stack: TBP>>=
  procedure :: write => process_stack_write
<<Process stacks: procedures>>=
  recursive subroutine process_stack_write (object, unit, pacify)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: pacify
    type(process_entry_t), pointer :: process
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    select case (object%n)
    case (0)
       write (u, "(1x,A)")  "Process stack: [empty]"
       call write_separator (u, 2)
    case default
       write (u, "(1x,A)")  "Process stack:"
       process => object%first
       do while (associated (process))
          call process%write (.false., u, pacify = pacify)
          process => process%next
       end do
    end select
    if (associated (object%next)) then
       write (u, "(1x,A)")  "[Processes from context environment:]"
       call object%next%write (u, pacify)
    end if
  end subroutine process_stack_write

@ %def process_stack_write
@ The variable list is printed by a separate routine, since
it should be linked to the global variable list, anyway.
<<Process stacks: process stack: TBP>>=
  procedure :: write_var_list => process_stack_write_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_write_var_list (object, unit)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    if (associated (object%var_list)) then
       call var_list_write (object%var_list, unit)
    end if
  end subroutine process_stack_write_var_list

@ %def process_stack_write_var_list
@ Short output.
<<Process stacks: process stack: TBP>>=
  procedure :: show => process_stack_show
<<Process stacks: procedures>>=
  recursive subroutine process_stack_show (object, unit)
    class(process_stack_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(process_entry_t), pointer :: process
    integer :: u
    u = given_output_unit (unit)
    select case (object%n)
    case (0)
    case default
       process => object%first
       do while (associated (process))
          call process%show (u, verbose=.false.)
          process => process%next
       end do
    end select
    if (associated (object%next))  call object%next%show ()
  end subroutine process_stack_show

@ %def process_stack_show
@
\subsection{Link}
Link the current process stack to a global one.
<<Process stacks: process stack: TBP>>=
  procedure :: link => process_stack_link
<<Process stacks: procedures>>=
  subroutine process_stack_link (local_stack, global_stack)
    class(process_stack_t), intent(inout) :: local_stack
    type(process_stack_t), intent(in), target :: global_stack
    local_stack%next => global_stack
  end subroutine process_stack_link

@ %def process_stack_link
@ Initialize the process variable list and link the main variable list
to it.
<<Process stacks: process stack: TBP>>=
  procedure :: init_var_list => process_stack_init_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_init_var_list (stack, var_list)
    class(process_stack_t), intent(inout) :: stack
    type(var_list_t), intent(inout), optional :: var_list
    allocate (stack%var_list)
    if (present (var_list))  call var_list%link (stack%var_list)
  end subroutine process_stack_init_var_list
  
@ %def process_stack_init_var_list
@ Link the process variable list to a global
variable list.
<<Process stacks: process stack: TBP>>=
  procedure :: link_var_list => process_stack_link_var_list
<<Process stacks: procedures>>=
  subroutine process_stack_link_var_list (stack, var_list)
    class(process_stack_t), intent(inout) :: stack
    type(var_list_t), intent(in), target :: var_list
    call stack%var_list%link (var_list)
  end subroutine process_stack_link_var_list
  
@ %def process_stack_link_var_list
@
\subsection{Push}
We take a process pointer and push it onto the stack.  The previous
pointer is nullified.  Subsequently, the process is `owned' by the
stack and will be finalized when the stack is deleted.
<<Process stacks: process stack: TBP>>=
  procedure :: push => process_stack_push
<<Process stacks: procedures>>=
  subroutine process_stack_push (stack, process)
    class(process_stack_t), intent(inout) :: stack
    type(process_entry_t), intent(inout), pointer :: process
    process%next => stack%first
    stack%first => process
    process => null ()
    stack%n = stack%n + 1
  end subroutine process_stack_push
  
@ %def process_stack_push
@ Initialize process variables for a given process ID, without setting
values.
<<Process stacks: process stack: TBP>>=
  procedure :: init_result_vars => process_stack_init_result_vars
<<Process stacks: procedures>>=
  subroutine process_stack_init_result_vars (stack, id)
    class(process_stack_t), intent(inout) :: stack
    type(string_t), intent(in) :: id
    call var_list_init_num_id (stack%var_list, id)
    call var_list_init_process_results (stack%var_list, id)
  end subroutine process_stack_init_result_vars
  
@ %def process_stack_init_result_vars
@ Fill process variables with values.  This is executed after the
integration pass.

Note: We set only integral and error.  With multiple MCI records
possible, the results for [[n_calls]], [[chi2]] etc. are not
necessarily unique.  (We might set the efficiency, though.)
<<Process stacks: process stack: TBP>>=
  procedure :: fill_result_vars => process_stack_fill_result_vars
<<Process stacks: procedures>>=
  subroutine process_stack_fill_result_vars (stack, id)
    class(process_stack_t), intent(inout) :: stack
    type(string_t), intent(in) :: id
    type(process_t), pointer :: process
    process => stack%get_process_ptr (id)
    if (associated (process)) then
       call var_list_init_num_id (stack%var_list, id, process%get_num_id ())
       if (process%has_integral ()) then
          call var_list_init_process_results (stack%var_list, id, &
               integral = process%get_integral (), &
               error = process%get_error ())
       end if
    else
       call msg_bug ("process_stack_fill_result_vars: unknown process ID")
    end if
  end subroutine process_stack_fill_result_vars

@ %def process_stack_fill_result_vars
@
\subsection{Data Access}
Tell if a process exists.
<<Process stacks: process stack: TBP>>=
  procedure :: exists => process_stack_exists
<<Process stacks: procedures>>=
  function process_stack_exists (stack, id) result (flag)
    class(process_stack_t), intent(in) :: stack
    type(string_t), intent(in) :: id
    logical :: flag
    type(process_t), pointer :: process
    process => stack%get_process_ptr (id)
    flag = associated (process)
  end function process_stack_exists

@ %def process_stack_exists
@ Return a pointer to a process with specific ID.  Look also at a
linked stack, if necessary.
<<Process stacks: process stack: TBP>>=
  procedure :: get_process_ptr => process_stack_get_process_ptr
<<Process stacks: procedures>>=
  recursive function process_stack_get_process_ptr (stack, id) result (ptr)
    class(process_stack_t), intent(in) :: stack
    type(string_t), intent(in) :: id
    type(process_t), pointer :: ptr
    type(process_entry_t), pointer :: entry
    ptr => null ()
    entry => stack%first
    do while (associated (entry))
       if (entry%get_id () == id) then
          ptr => entry%process_t
          return
       end if
       entry => entry%next
    end do
    if (associated (stack%next))  ptr => stack%next%get_process_ptr (id)
  end function process_stack_get_process_ptr

@ %def process_stack_get_process_ptr
@
\subsection{Unit tests}
Test module, followed by the corresponding implementation module.
<<[[process_stacks_ut.f90]]>>=
<<File header>>

module process_stacks_ut
  use unit_tests
  use process_stacks_uti
  
<<Standard module head>>

<<Process stacks: public test>>

contains
  
<<Process stacks: test driver>>

end module process_stacks_ut
@ %def process_stacks_ut
@
<<[[process_stacks_uti.f90]]>>=
<<File header>>

module process_stacks_uti

<<Use strings>>
  use os_interface
  use sm_qcd
  use model_data
  use process_libraries
  use rng_base
  use prc_test, only: prc_test_create_library
  use processes
  use processes_ut, only: prepare_test_process
  
  use process_stacks

  use rng_base_ut, only: rng_test_factory_t

<<Standard module head>>

<<Process stacks: test declarations>>

contains

<<Process stacks: tests>>

end module process_stacks_uti
  
@ %def process_stacks_uti
@ API: driver for the unit tests below.
<<Process stacks: public test>>=
  public :: process_stacks_test
<<Process stacks: test driver>>=
  subroutine process_stacks_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Process stacks: execute tests>>
  end subroutine process_stacks_test
  
@ %def process_stacks_test
@
\subsubsection{Write an empty process stack}
The most trivial test is to write an uninitialized process stack.
<<Process stacks: execute tests>>=
  call test (process_stacks_1, "process_stacks_1", &
       "write an empty process stack", &
       u, results)
<<Process stacks: test declarations>>=
  public :: process_stacks_1
<<Process stacks: tests>>=
  subroutine process_stacks_1 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack

    write (u, "(A)")  "* Test output: process_stacks_1"
    write (u, "(A)")  "*   Purpose: display an empty process stack"
    write (u, "(A)")

    call stack%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_1"
    
  end subroutine process_stacks_1
  
@ %def process_stacks_1
@
\subsubsection{Fill a process stack}
Fill a process stack with two (identical) processes.
<<Process stacks: execute tests>>=
  call test (process_stacks_2, "process_stacks_2", &
       "fill a process stack", &
       u, results)
<<Process stacks: test declarations>>=
  public :: process_stacks_2
<<Process stacks: tests>>=
  subroutine process_stacks_2 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_entry_t), pointer :: process => null ()

    write (u, "(A)")  "* Test output: process_stacks_2"
    write (u, "(A)")  "*   Purpose: fill a process stack"
    write (u, "(A)")

    write (u, "(A)")  "* Build, initialize and store two test processes"
    write (u, "(A)")

    libname = "process_stacks2"
    procname = libname
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    allocate (model)
    call model%init_test ()

    allocate (process)
    run_id = "run1"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 
    call stack%push (process)
    
    allocate (model)
    call model%init_test ()

    allocate (process)
    run_id = "run2"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 
    call stack%push (process)
    
    call stack%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_2"
    
  end subroutine process_stacks_2
  
@ %def process_stacks_2
@
\subsubsection{Fill a process stack}
Fill a process stack with two (identical) processes.
<<Process stacks: execute tests>>=
  call test (process_stacks_3, "process_stacks_3", &
       "process variables", &
       u, results)
<<Process stacks: test declarations>>=
  public :: process_stacks_3
<<Process stacks: tests>>=
  subroutine process_stacks_3 (u)
    integer, intent(in) :: u
    type(process_stack_t) :: stack
    type(model_data_t), target :: model
    type(string_t) :: procname
    type(process_entry_t), pointer :: process => null ()
    type(process_instance_t), target :: process_instance

    write (u, "(A)")  "* Test output: process_stacks_3"
    write (u, "(A)")  "*   Purpose: setup process variables"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    procname = "processes_test"
    call model%init_test ()

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    call stack%init_var_list ()
    call stack%init_result_vars (procname)
    call stack%write_var_list (u)

    write (u, "(A)")
    write (u, "(A)")  "* Build and integrate a test process"
    write (u, "(A)")

    allocate (process)
    call prepare_test_process (process%process_t, process_instance, model)
    call process%integrate (process_instance, 1, 1, 1000)
    call process_instance%final ()
    call process%final_integration (1)
    call stack%push (process)
    
    write (u, "(A)")  "* Fill process variables"
    write (u, "(A)")

    call stack%fill_result_vars (procname)
    call stack%write_var_list (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack%final ()

    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_3"
    
  end subroutine process_stacks_3
  
@ %def process_stacks_3
@
\subsubsection{Linked a process stack}
Fill two process stack, linked to each other.
<<Process stacks: execute tests>>=
  call test (process_stacks_4, "process_stacks_4", &
       "linked stacks", &
       u, results)
<<Process stacks: test declarations>>=
  public :: process_stacks_4
<<Process stacks: tests>>=
  subroutine process_stacks_4 (u)
    integer, intent(in) :: u
    type(process_library_t), target :: lib
    type(process_stack_t), target :: stack1, stack2
    class(model_data_t), pointer :: model
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(process_entry_t), pointer :: process => null ()

    write (u, "(A)")  "* Test output: process_stacks_4"
    write (u, "(A)")  "*   Purpose: link process stacks"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    libname = "process_stacks_4_lib"
    procname = "process_stacks_4a"

    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)

    write (u, "(A)")  "* Initialize first process"
    write (u, "(A)")

    call prc_test_create_library (procname, lib)

    allocate (model)
    call model%init_test ()

    allocate (process)
    run_id = "run1"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 
    call stack1%push (process)
    
    write (u, "(A)")  "* Initialize second process"
    write (u, "(A)")

    call stack2%link (stack1)

    procname = "process_stacks_4b"
    call prc_test_create_library (procname, lib)

    allocate (model)
    call model%init_test ()

    allocate (process)
    run_id = "run2"
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 
    call stack2%push (process)
    
    write (u, "(A)")  "* Show linked stacks"
    write (u, "(A)")

    call stack2%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call stack2%final ()
    call stack1%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_stacks_4"
    
  end subroutine process_stacks_4
  
@ %def process_stacks_4
@
