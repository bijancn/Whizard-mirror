% -*- ess-noweb-default-code-mode: f90-mode; noweb-default-code-mode: f90-mode; -*- 
% WHIZARD main code as NOWEB source

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Event Implementation}

With a process object and the associated methods at hand, we can
generate events for elementary processes and, by subsequent
transformation, for complete physical processes.

We have the following modules:
\begin{description}
\item[event\_transforms]
  Abstract base type for transforming a physical process with process
  instance and included evaluators, etc., into a new
  object.  The following modules extend this base type.
\item[decays]
  Combine the elementary process with elementary decay processes and
  thus transform the elementary event into a decayed event, still at
  the parton level.
\item[showers]
  Create QED/QCD showers out of the partons that are emitted by
  elementary processes.  This should be interleaved with showering of
  radiated particles (structure functions) and multiple interactions.
\item[hadrons]
  (not implemented yet) Apply hadronization to the partonic events,
  interleaved with hadron decays.  (The current setup relies on
  hadronizing partonic events externally.)
\item[events]
  Combine all pieces to generate full events.
\item[eio\_raw]
  Raw I/O for complete events.
\end{description}

@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Abstract Event Transforms}
<<[[event_transforms.f90]]>>=
<<File header>>

module event_transforms

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use model_data
  use state_matrices
  use interactions
  use particles
  use subevents
  use process_libraries
  use prc_core
  use prc_test
  use rng_base
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use processes
  use process_stacks
  use powheg
  
<<Standard module head>>

<<Event transforms: public>>

<<Event transforms: types>>

<<Event transforms: interfaces>>

contains

<<Event transforms: procedures>>

<<Event transforms: tests>>

end module event_transforms

@ %def event_transforms
@
\subsection{Abstract base type}
Essentially, all methods are abstract, but some get minimal base
versions.  We know that there will be a random-number generator at top
level, and that we will relate to an elementary process.

The model is stored separately.  It may contain modified setting that differ
from the model instance stored in the process object.

Each event transform contains a particle set that it can fill for
further use.  There is a flag that indicates this.

We will collect event transforms in a list, therefore we include
[[previous]] and [[next]] pointers.
<<Event transforms: public>>=
  public :: evt_t
<<Event transforms: types>>=
  type, abstract :: evt_t
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: process_instance => null ()
     class(model_data_t), pointer :: model => null ()
     class(rng_t), allocatable :: rng
     integer :: rejection_count = 0
     logical :: particle_set_exists = .false.
     type(particle_set_t) :: particle_set
     class(evt_t), pointer :: previous => null ()
     class(evt_t), pointer :: next => null ()
   contains
   <<Event transforms: evt: TBP>>
  end type evt_t
  
@ %def evt_t
@ Finalizer.  In any case, we finalize the r.n.g.  The process
instance is a pointer and should not be finalized here.
<<Event transforms: evt: TBP>>=
  procedure :: final => evt_final
  procedure :: base_final => evt_final
<<Event transforms: procedures>>=
  subroutine evt_final (object)
    class(evt_t), intent(inout) :: object
    if (allocated (object%rng))  call object%rng%final ()
    if (object%particle_set_exists) &
         call object%particle_set%final ()
  end subroutine evt_final
  
@ %def evt_final
@ Output.  We can print r.n.g. info.
<<Event transforms: evt: TBP>>=
  procedure :: base_write => evt_write
<<Event transforms: procedures>>=
  subroutine evt_write (object, unit, verbose, testflag)
    class(evt_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%process)) then
       write (u, "(3x,A,A,A)")   "Associated process: '", &
            char (object%process%get_id ()), "'"
    end if
    if (allocated (object%rng)) then
       call object%rng%write (u, 1)
       write (u, "(3x,A,I0)")  "Number of tries = ", object%rejection_count
    end if
    if (object%particle_set_exists) then
       call write_separator (u)
       call object%particle_set%write (u, testflag)
    end if
  end subroutine evt_write
  
@ %def evt_write
@ Connect the transform with a process instance (and thus with the
associated process).  Use this to allocate the master random-number
generator.

This is not an initializer; we may initialize the transform by
implementation-specific methods.
<<Event transforms: evt: TBP>>=
  procedure :: connect => evt_connect
  procedure :: base_connect => evt_connect
<<Event transforms: procedures>>=
  subroutine evt_connect (evt, process_instance, model, process_stack)
    class(evt_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    evt%process => process_instance%process
    evt%process_instance => process_instance
    evt%model => model
    call evt%process%make_rng (evt%rng)
  end subroutine evt_connect
  
@ %def evt_connect
@ Reset internal state.
<<Event transforms: evt: TBP>>=
  procedure :: reset => evt_reset
  procedure :: base_reset => evt_reset
<<Event transforms: procedures>>=
  subroutine evt_reset (evt)
    class(evt_t), intent(inout) :: evt
    evt%rejection_count = 0
    evt%particle_set_exists = .false.
  end subroutine evt_reset
  
@ %def evt_reset
@ Prepare for a new event: reset internal state, if necessary.  We
provide MCI and term index of the parent process.
<<Event transforms: evt: TBP>>=
  procedure (evt_prepare_new_event), deferred :: prepare_new_event
<<Event transforms: interfaces>>=
  interface
     subroutine evt_prepare_new_event (evt, i_mci, i_term)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: i_mci, i_term
     end subroutine evt_prepare_new_event
  end interface
       
@ %def evt_prepare_new_event
@ Generate a weighted event, using a valid initiator event in the
process instance, and the random-number generator.  The returned event
probability should be a number between zero and one that we can use for
rejection.
<<Event transforms: evt: TBP>>=
  procedure (evt_generate_weighted), deferred :: generate_weighted
<<Event transforms: interfaces>>=
  abstract interface
     subroutine evt_generate_weighted (evt, probability)
       import
       class(evt_t), intent(inout) :: evt
       real(default), intent(out) :: probability
     end subroutine evt_generate_weighted
  end interface
  
@ %def evt_generate_weighted
@ The unweighted event generation routine is actually implemented.  It
uses the random-number generator for simple rejection.  Of course, the
implementation may override this and implement a different way of
generating an unweighted event.
<<Event transforms: evt: TBP>>=
  procedure :: generate_unweighted => evt_generate_unweighted
  procedure :: base_generate_unweighted => evt_generate_unweighted
<<Event transforms: procedures>>=
  subroutine evt_generate_unweighted (evt)
    class(evt_t), intent(inout) :: evt
    real(default) :: p, x
    evt%rejection_count = 0
    REJECTION: do
       evt%rejection_count = evt%rejection_count + 1
       call evt%generate_weighted (p)
       if (signal_is_pending ())  return
       call evt%rng%generate (x)
       if (x < p)  exit REJECTION
    end do REJECTION
  end subroutine evt_generate_unweighted
    
@ %def evt_generate_unweighted
@ Make a particle set.  This should take the most recent evaluator (or
whatever stores the event), factorize the density matrix if necessary,
and store as a particle set.

If applicable, the factorization should make use of the
[[factorization_mode]] and [[keep_correlations]] settings.

The values [[r]], if set, should control the factorization in more
detail, e.g., bypassing the random-number generator.
<<Event transforms: evt: TBP>>=
  procedure (evt_make_particle_set), deferred :: make_particle_set
<<Event transforms: interfaces>>=
  interface
     subroutine evt_make_particle_set &
          (evt, factorization_mode, keep_correlations, r)
       import
       class(evt_t), intent(inout) :: evt
       integer, intent(in) :: factorization_mode
       logical, intent(in) :: keep_correlations
       real(default), dimension(:), intent(in), optional :: r
     end subroutine evt_make_particle_set
  end interface
       
@ %def evt_make_particle_set
@ Copy an existing particle set into the event record.  This bypasses
all methods to evaluate the internal state, but may be sufficient for
further processing.
<<Event transforms: evt: TBP>>=
  procedure :: set_particle_set => evt_set_particle_set
<<Event transforms: procedures>>=
  subroutine evt_set_particle_set (evt, particle_set, i_mci, i_term)
    class(evt_t), intent(inout) :: evt
    type(particle_set_t), intent(in) :: particle_set
    integer, intent(in) :: i_term, i_mci
    call evt%prepare_new_event (i_mci, i_term)
    evt%particle_set = particle_set
    evt%particle_set_exists = .true.
  end subroutine evt_set_particle_set
    
@ %def evt_set_particle_set
@ This procedure can help in the previous task, if the particles are
available in the form of an interaction object.  (We need two
interactions, one with color summed over, and one with the probability
distributed among flows.)

We use the two values from the random number generator for factorizing
the state.  For testing purposes, we can provide those numbers explicitly.
<<Event transforms: evt: TBP>>=
  procedure :: factorize_interactions => evt_factorize_interactions
<<Event transforms: procedures>>=
  subroutine evt_factorize_interactions &
       (evt, int_matrix, int_flows, factorization_mode, keep_correlations, r)
    class(evt_t), intent(inout) :: evt
    type(interaction_t), intent(in), target :: int_matrix, int_flows
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    real(default), dimension(2) :: x
    if (present (r)) then
       if (size (r) == 2) then
          x = r
       else
          call msg_bug ("event factorization: size of r array must be 2")
       end if
    else
       call evt%rng%generate (x)
    end if
    call evt%particle_set%init (evt%particle_set_exists, &
         int_matrix, int_flows, factorization_mode, x, &
         keep_correlations, keep_virtual=.true.)
    evt%particle_set_exists = .true.
  end subroutine evt_factorize_interactions
  
@ %def evt_factorize_interactions
@ Mark the incoming particles as incoming in the particle set.  This
is necessary because in the interaction objects they are usually
marked as virtual.

In the inquiry functions we set the term index to one; the indices of
beams and incoming particles should be identical for all process
terms.

We use the initial elementary process for obtaining the indices.
Thus, we implicitly assume that the beam and incoming indices stay the
same across event transforms.  If this is not true for a transform
(say, MPI), it should override this method.
<<Event transforms: evt: TBP>>=
  procedure :: tag_incoming => evt_tag_incoming
<<Event transforms: procedures>>=
  subroutine evt_tag_incoming (evt)
    class(evt_t), intent(inout) :: evt
    integer :: i_term, n_in
    integer, dimension(:), allocatable :: beam_index, in_index
    n_in = evt%process%get_n_in ()
    i_term = 1
    allocate (beam_index (n_in))
    call evt%process_instance%get_beam_index (i_term, beam_index)
    call evt%particle_set%reset_status (beam_index, PRT_BEAM)
    allocate (in_index (n_in))
    call evt%process_instance%get_in_index (i_term, in_index)
    call evt%particle_set%reset_status (in_index, PRT_INCOMING)
  end subroutine evt_tag_incoming

@ %def evt_tag_incoming
@
\subsection{Implementation: Trivial transform}
This transform contains just a pointer to process and process
instance.  The [[generate]] methods do nothing.
<<Event transforms: public>>=
  public :: evt_trivial_t
<<Event transforms: types>>=
  type, extends (evt_t) :: evt_trivial_t
   contains
   <<Event transforms: evt trivial: TBP>>
  end type evt_trivial_t

@ %def evt_trivial_t
@ The finalizer is trivial.  Some output:
<<Event transforms: evt trivial: TBP>>=
  procedure :: write => evt_trivial_write
<<Event transforms: procedures>>=
  subroutine evt_trivial_write (object, unit, verbose, testflag)
    class(evt_trivial_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose, testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: trivial (hard process)"
    call write_separator (u)
    call object%base_write (u, testflag = testflag)
  end subroutine evt_trivial_write
  
@ %def evt_trivial_write
@ Nothing to do here:
<<Event transforms: evt trivial: TBP>>=
  procedure :: prepare_new_event => evt_trivial_prepare_new_event
<<Event transforms: procedures>>=
  subroutine evt_trivial_prepare_new_event (evt, i_mci, i_term)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_trivial_prepare_new_event
  
@ %def evt_trivial_prepare_new_event
@ The weighted generator is, surprisingly, trivial.
<<Event transforms: evt trivial: TBP>>=
  procedure :: generate_weighted => evt_trivial_generate_weighted
<<Event transforms: procedures>>=
  subroutine evt_trivial_generate_weighted (evt, probability)
    class(evt_trivial_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    probability = 1
  end subroutine evt_trivial_generate_weighted
    
@ %def evt_trivial_generate_weighted
@ This routine makes a particle set, using the associated process
instance as-is.
<<Event transforms: evt trivial: TBP>>=
  procedure :: make_particle_set => evt_trivial_make_particle_set
<<Event transforms: procedures>>=
  subroutine evt_trivial_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_trivial_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    integer :: i_term
    type(interaction_t), pointer :: int_matrix, int_flows
    if (evt%process_instance%is_complete_event ()) then
       call evt%process_instance%select_i_term (i_term)
       int_matrix => evt%process_instance%get_matrix_int_ptr (i_term)
       int_flows  => evt%process_instance%get_flows_int_ptr (i_term)
       call evt%factorize_interactions (int_matrix, int_flows, &
            factorization_mode, keep_correlations, r)
       call evt%tag_incoming ()
    else
       call msg_bug ("Event factorization: event is incomplete")
    end if
  end subroutine evt_trivial_make_particle_set
    
@ %def event_trivial_make_particle_set
@
\subsection{Unit tests}
<<Event transforms: public>>=
  public :: event_transforms_test
<<Event transforms: tests>>=
  subroutine event_transforms_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event transforms: execute tests>>
  end subroutine event_transforms_test
  
@ %def event_transforms_test
@
\subsubsection{Test trivial event transform}
The trivial transform, as an instance of the abstract transform, does
nothing but to trigger event generation for an elementary process.
<<Event transforms: execute tests>>=
  call test (event_transforms_1, "event_transforms_1", &
       "trivial event transform", &
       u, results)
<<Event transforms: tests>>=
  subroutine event_transforms_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: libname, procname1, run_id
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(evt_t), allocatable :: evt
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: event_transforms_1"
    write (u, "(A)")  "*   Purpose: handle trivial transform"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)

    libname = "event_transforms_1_lib"
    procname1 = "event_transforms_1_p"
    run_id = "event_transforms_1"

    call prc_test_create_library (libname, lib, &
         scattering = .true., procname1 = procname1)
    call reset_interaction_counter ()

    allocate (model)
    call model%init_test ()

    allocate (process)
    call process%init &
         (procname1, run_id, lib, os_data, qcd, rng_factory, model)
    
    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()

    allocate (process_instance)
    call process_instance%init (process)
    call process%integrate (process_instance, 1, n_it=1, n_calls=100)
    call process%final_integration (1)
    call process_instance%final ()
    deallocate (process_instance)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")  "* Initialize trivial event transform"
    write (u, "(A)")

    allocate (evt_trivial_t :: evt)
    model => process%get_model_ptr ()
    call evt%connect (process_instance, model)
    
    write (u, "(A)")  "* Generate event and subsequent transform"
    write (u, "(A)")
    
    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()
    
    call evt%prepare_new_event (1, 1)
    call evt%generate_unweighted ()

    select type (evt)
    type is (evt_trivial_t)
       call write_separator (u, 2)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Obtain particle set"
    write (u, "(A)")
    
    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    
    call evt%make_particle_set (factorization_mode, keep_correlations)

    select type (evt)
    type is (evt_trivial_t)
       call write_separator (u, 2)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_transforms_1"
    
  end subroutine event_transforms_1
  
@ %def event_transforms_1
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Hadronization interface}
<<[[hadrons.f90]]>>=
<<File header>>

module hadrons
    
<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use diagnostics
  use sm_qcd
  use particles
  use model_data
  use models
  use hep_common
  use event_transforms
  use shower_base
  use shower_pythia6
  
<<Standard module head>>

<<Hadrons: public>>

<<Hadrons: types>>

<<Hadrons: interfaces>>

contains
  
<<Hadrons: procedures>>  

end module hadrons
@ %def hadrons 
@
\subsection{Abstract Hadronization Type}
<<Hadrons: types>>=
  type, abstract :: hadrons_base_t
   contains
   <<Hadrons: hadrons base: TBP>>
  end type hadrons_base_t

@ %def hadrons_base_t
@
<<Hadrons: hadrons base: TBP>>=
  procedure (hadrons_init), deferred :: init
<<Hadrons: interfaces>>=
  abstract interface
    subroutine hadrons_init (hadrons)
      import
      class(hadrons_base_t), intent(out) :: hadrons
    end subroutine hadrons_init
   end interface

@ %def hadrons_init
@
<<Hadrons: hadrons base: TBP>>=
  procedure (hadrons_hadronize), deferred :: hadronize
<<Hadrons: interfaces>>=
  abstract interface
     subroutine hadrons_hadronize &
          (hadrons, pset, settings, model, model_hadrons, valid)
       import
       class(hadrons_base_t), intent(inout) :: hadrons
       type(particle_set_t), intent(inout) :: pset
       type(shower_settings_t), intent(inout) :: settings
       class(model_data_t), intent(in), target :: model
       class(model_data_t), intent(in), target :: model_hadrons
       logical, intent(inout) :: valid
     end subroutine hadrons_hadronize
  end interface
@ %def hadrons_hadronize
@
\subsection{PYTHIA6 Hadronization Type}
Hadronization via PYTHIA6 is at the moment the only option for
hadronization within \whizard.
<<Hadrons: types>>=
  type, extends (hadrons_base_t) :: hadrons_pythia6_t
   contains
   <<Hadrons: hadrons PYTHIA6: TBP>>
  end type hadrons_pythia6_t

@ %def hadrons_pythia6_t
<<Hadrons: hadrons PYTHIA6: TBP>>=
  procedure :: init => hadrons_pythia6_init
<<Hadrons: procedures>>=
  subroutine hadrons_pythia6_init (hadrons)
    class(hadrons_pythia6_t), intent(out) :: hadrons
    call msg_message &
         ("Using PYTHIA6 interface for hadronization and decays")
  end subroutine hadrons_pythia6_init
  
@ %def hadrons_pythia6_init
@ This is the actual hadronization done via PYTHIA6.
<<Hadrons: hadrons PYTHIA6: TBP>>=
  procedure :: hadronize => hadrons_pythia6_hadronize
<<Hadrons: procedures>>=  
  subroutine hadrons_pythia6_hadronize &
       (hadrons, pset, settings, model, model_hadrons, valid)
    class(hadrons_pythia6_t), intent(inout) :: hadrons
    type(particle_set_t), intent(inout) :: pset
    type(shower_settings_t), intent(inout) :: settings
    class(model_data_t), intent(in), target :: model
    class(model_data_t), intent(in), target :: model_hadrons
    logical, intent(inout) :: valid
    !! Assume that the event record is still in the PYTHIA COMMON BLOCKS
    !! transferred there by one of the shower routines
    call apply_hadronization_pythia6 (pset, settings, &
         model, model_hadrons, valid)
  end subroutine hadrons_pythia6_hadronize
  
@ %def hadrons_pythia6_hadronize
@
\subsection{Hadronization Event Transform}
This is the type for the hadronization event transform.  It does not
depend on the specific hadronization implementation of
[[hadrons_base_t]].
<<Hadrons: public>>=
  public :: evt_hadrons_t
<<Hadrons: types>>=
  type, extends (evt_t) :: evt_hadrons_t
     class(hadrons_base_t), allocatable :: hadrons
     type(shower_settings_t) :: settings
     type(model_t), pointer :: model_hadrons => null()
     type(qcd_t), pointer :: qcd_t => null()
   contains
   <<Hadrons: evt hadrons: TBP>>
  end type evt_hadrons_t

@ %def evt_hadrons_t
@ Output.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: write => evt_hadrons_write
<<Hadrons: procedures>>=
  subroutine evt_hadrons_write (object, unit, testflag)
    class(evt_hadrons_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: hadronization"
    call write_separator (u)
    call object%base_write (u, testflag = testflag)
    call write_separator (u)
    call object%settings%write (u)
  end subroutine evt_hadrons_write
    
@ %def evt_hadrons_write
@ Here we take the particle set from the previous event transform
(assuming that there is always one) and apply the hadronization.  The
result is stored in the event transform of the current object.  We
always return a probability of unity as we don't have the analytic
weight of the hadronization.  Invalid or vetoed events have to be
discarded by the caller which is why we mark the particle set as
invalid.  
<<Hadrons: evt hadrons: TBP>>=
  procedure :: generate_weighted => evt_hadrons_generate_weighted
<<Hadrons: procedures>>=
  subroutine evt_hadrons_generate_weighted (evt, probability)
    class(evt_hadrons_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    logical :: valid
    valid = .true.
    if (evt%previous%particle_set_exists) then
       evt%particle_set = evt%previous%particle_set
       if (evt%settings%hadronization_active) then
          call assure_heprup (evt%particle_set)
       end if
       call evt%hadrons%hadronize (evt%particle_set, evt%settings, &
            evt%model, evt%model_hadrons, valid)  
       probability = 1
       evt%particle_set_exists = valid
    else
       call msg_bug ("Hadrons: input particle set does not exist")
    end if
  end subroutine evt_hadrons_generate_weighted

@ %def evt_hadrons_generate_weighted
@ The particle set was already made by the routine above (or the event was
vetoed).  So we do nothing here.  The factorization parameters are irrelevant.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: make_particle_set => evt_hadrons_make_particle_set
<<Hadrons: procedures>>=
  subroutine evt_hadrons_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
  end subroutine evt_hadrons_make_particle_set

@ %def event_hadrons_make_particle_set
@ Prepare: nothing to do here.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: prepare_new_event => evt_hadrons_prepare_new_event
<<Hadrons: procedures>>=
  subroutine evt_hadrons_prepare_new_event (evt, i_mci, i_term)
    class(evt_hadrons_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
  end subroutine evt_hadrons_prepare_new_event

@ %def evt_hadrons_prepare_new_event
@ Initialize the parameters.  The [[model_hadrons]] is supposed to be
the SM variant that contains all hadrons that may be generated in the
shower.
<<Hadrons: evt hadrons: TBP>>=
  procedure :: init => evt_hadrons_init
<<Hadrons: procedures>>=
  subroutine evt_hadrons_init (evt, settings, model_hadrons, method)
    class(evt_hadrons_t), intent(out) :: evt
    type(shower_settings_t), intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    type(string_t), intent(in) :: method
    evt%settings = settings
    evt%model_hadrons => model_hadrons
    select case (char (method))
    case ("PYTHIA6")
       allocate (hadrons_pythia6_t :: evt%hadrons)
    case default
       call msg_fatal ("Hadronization method " // char (method) // &
            " not implemented.")
    end select
    call evt%hadrons%init ()
  end subroutine evt_hadrons_init
  
@ %def evt_hadrons_init
@
<<Hadrons: procedures>>=
    subroutine apply_hadronization_pythia6 &
         (particle_set, settings, model, model_hadrons, valid)
      type(particle_set_t), intent(inout) :: particle_set
      type(shower_settings_t), intent(in) :: settings
      class(model_data_t), intent(in), target :: model
      class(model_data_t), intent(in), target :: model_hadrons
      logical, intent(inout) :: valid
      integer :: u_W2P, u_P2W
      logical :: pygive_not_set_by_shower
      character(len=10) :: buffer
      logical, parameter :: debug = .false., to_file = .false.
      if (.not. settings%hadronization_active)  return
      if (.not. valid) return
      if (signal_is_pending ()) return          

      u_W2P = free_unit ()
      if (debug) then
         open (unit=u_W2P, status="replace", file="whizardout.lhe", &
              action="readwrite") 
      else
         open (unit=u_W2P, status="scratch", action="readwrite")
      end if
      call w2p_write_lhef_event (u_W2P)
      rewind (u_W2P)
      write (buffer, "(I10)")  u_W2P
      call PYGIVE ("MSTP(161)=" // buffer)  !!! Unit for PYUPIN (LHA)
      call PYGIVE ("MSTP(162)=" // buffer)  !!! Unit for PYUPEV (LHA)

      !!! Assume that the event is still present in the PYTHIA common blocks
      ! call pygive ("MSTP(61)=0")  ! switch off ISR
      ! call pygive ("MSTP(71)=0")  ! switch off FSR

      pygive_not_set_by_shower = .not. (settings%ps_use_PYTHIA6_shower &
           .and. (settings%ps_isr_active .or. settings%ps_fsr_active))
      if (pygive_not_set_by_shower) then
         call pythia6_set_verbose (settings%ps_PYTHIA_verbose)
         call pythia6_set_config (settings%ps_PYTHIA_PYGIVE)
      end if

      call PYGIVE ("MSTP(111)=1") !!! switch on hadronization
      if (signal_is_pending ()) return          
      
      call PYEXEC

      if (pythia6_get_error () > 0) then
         call pythia6_set_error (0)
         close (u_W2P)
         valid = .false.
      else
         !!! convert back
         u_P2W = free_unit ()
         write (buffer, "(I10)")  u_P2W
         call PYGIVE ("MSTP(163)=" // buffer)
         if (debug .and. to_file) then
            open (unit=u_P2W, file="pythiaout2.lhe", status="replace", &
                 action="readwrite")  
         else            
            open (unit=u_P2W, status="scratch", action="readwrite")
         end if
         !!! convert pythia /PYJETS/ to lhef given in MSTU(163)=u1
         call pylheo
         !!! read and add lhef from u_P2W
         call combine_lhef_with_particle_set &
              (particle_set, u_P2W, model, model_hadrons)
         close (u_W2P)
         close (u_P2W)
         valid = .true.
      end if
    end subroutine apply_hadronization_pythia6
  
@ %def apply_hadronization_pythia6
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Decays}
<<[[decays.f90]]>>=
<<File header>>

module decays

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_indent, write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use sm_qcd
  use flavors
  use helicities
  use quantum_numbers
  use state_matrices
  use interactions
  use evaluators
  use variables
  use model_data
  use rng_base
  use selectors
  use prc_core
  use prc_test
  use process_libraries
  use mci_base
  use mci_midpoint
  use phs_base
  use phs_single
  use parton_states
  use processes
  use process_stacks
  use event_transforms
  
<<Standard module head>>

<<Decays: public>>

<<Decays: types>>

<<Decays: interfaces>>

contains

<<Decays: procedures>>

<<Decays: tests>>

end module decays

@ %def decays
@
\subsection{Final-State Particle Configuration}
A final-state particle may be either stable or unstable.  Here is an
empty abstract type as the parent of both, with holds just the flavor
information.
<<Decays: types>>=
  type, abstract :: any_config_t
   contains
   <<Decays: any config: TBP>>
  end type any_config_t

@ %def any_config_t
@ Finalizer, depends on the implementation.
<<Decays: any config: TBP>>=
  procedure (any_config_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_config_final (object)
       import
       class(any_config_t), intent(inout) :: object
     end subroutine any_config_final
  end interface
  
@ %def any_config_final
@ The output is also deferred:
<<Decays: any config: TBP>>=
  procedure (any_config_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_config_write (object, unit, indent, verbose)
       import
       class(any_config_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
       logical, intent(in), optional :: verbose
     end subroutine any_config_write
  end interface

@ %def any_config_write
@ This is a container for a stable or unstable particle configurator.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_config_t
     class(any_config_t), allocatable :: c
  end type particle_config_t
  
@ %def particle_config_t
@
\subsection{Final-State Particle}
In theory, for the particle instance we only need to consider the
unstable case.  However, it is more straightforward to treat
configuration and instance on the same footing, and to introduce a
wrapper for particle objects as above.  This also works
around a compiler bug in gfortran.
<<Decays: types>>=
  type, abstract :: any_t
   contains
   <<Decays: any: TBP>>
  end type any_t
  
@ %def any_t
@ Finalizer, depends on the implementation.
<<Decays: any: TBP>>=
  procedure (any_final), deferred :: final
<<Decays: interfaces>>=
  interface
     subroutine any_final (object)
       import
       class(any_t), intent(inout) :: object
     end subroutine any_final
  end interface
  
@ %def any_final
@ The output is also deferred:
<<Decays: any: TBP>>=
  procedure (any_write), deferred :: write
<<Decays: interfaces>>=
  interface
     subroutine any_write (object, unit, indent)
       import
       class(any_t), intent(in) :: object
       integer, intent(in), optional :: unit, indent
     end subroutine any_write
  end interface

@ %def any_write
@ This is a container for a stable or unstable outgoing particle.
We need this wrapper for preparing arrays that mix stable and unstable
particles.
<<Decays: types>>=
  type :: particle_out_t
     class(any_t), allocatable :: c
  end type particle_out_t
  
@ %def particle_config_t
@ 
\subsection{Decay Term Configuration}
A decay term is a distinct final state, corresponding to a process
term.  Each decay process may give rise to several terms with,
possibly, differing flavor content.
<<Decays: types>>=
  type :: decay_term_config_t
     type(particle_config_t), dimension(:), allocatable :: prt
   contains
   <<Decays: decay term config: TBP>>
  end type decay_term_config_t
  
@ %def decay_term_config_t
@ Finalizer, recursive.
<<Decays: decay term config: TBP>>=
  procedure :: final => decay_term_config_final
<<Decays: procedures>>=
  recursive subroutine decay_term_config_final (object)
    class(decay_term_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%prt)) then
       do i = 1, size (object%prt)
          if (allocated (object%prt(i)%c))  call object%prt(i)%c%final ()
       end do
    end if
  end subroutine decay_term_config_final
  
@ %def decay_term_config_final
@ Output, with optional indentation
<<Decays: decay term config: TBP>>=
  procedure :: write => decay_term_config_write
<<Decays: procedures>>=
  recursive subroutine decay_term_config_write (object, unit, indent, verbose)
    class(decay_term_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, j, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,A)", advance="no")  "Final state:"
    do i = 1, size (object%prt)
       select type (prt_config => object%prt(i)%c)
       type is (stable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv(1)%get_name ())
          do j = 2, size (prt_config%flv)
             write (u, "(':',A)", advance="no") &
                  char (prt_config%flv(j)%get_name ())
          end do
       type is (unstable_config_t)
          write (u, "(1x,A)", advance="no") &
               char (prt_config%flv%get_name ())
       end select
    end do
    write (u, *)
    if (verb) then
       do i = 1, size (object%prt)
          call object%prt(i)%c%write (u, ind)
       end do
    end if
  end subroutine decay_term_config_write

@ %def decay_term_config_write
@ Initialize, given a set of flavors.  For each flavor, we must indicate
whether the particle is stable.  The second index of the flavor array runs
over alternatives for each decay product; alternatives are allowed only if the
decay product is itself stable.
<<Decays: decay term config: TBP>>=
  procedure :: init => decay_term_config_init
<<Decays: procedures>>=
  recursive subroutine decay_term_config_init &
       (term, flv, stable, model, process_stack)
    class(decay_term_config_t), intent(out) :: term
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t), dimension(:), allocatable :: decay
    integer :: i
    allocate (term%prt (size (flv, 1)))
    do i = 1, size (flv, 1)
       associate (prt => term%prt(i))
         if (stable(i)) then
            allocate (stable_config_t :: prt%c)
         else
            allocate (unstable_config_t :: prt%c)
         end if
         select type (prt_config => prt%c)
         type is (stable_config_t)
            call prt_config%init (flv(i,:))
         type is (unstable_config_t)
            if (all (flv(i,:) == flv(i,1))) then
               call prt_config%init (flv(i,1))
               call flv(i,1)%get_decays (decay)
               call prt_config%init_decays (decay, model, process_stack)
            else
               call prt_config%write ()
               call msg_fatal ("Decay configuration: &
                    &unstable product must be unique")
            end if
         end select
       end associate
    end do
  end subroutine decay_term_config_init
  
@ %def decay_term_config_init
@ Recursively compute widths and branching ratios for all unstable particles.
<<Decays: decay term config: TBP>>=
  procedure :: compute => decay_term_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_term_config_compute (term)
    class(decay_term_config_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%prt)
       select type (unstable_config => term%prt(i)%c)
       type is (unstable_config_t)
          call unstable_config%compute ()
       end select
    end do
  end subroutine decay_term_config_compute
  
@ %def decay_term_config_compute
@
\subsection{Decay Term}
A decay term instance is selected when we generate an event for the associated
process instance.  When evaluated, it triggers further decays down the chain.

Only unstable products are allocated as child particles.
<<Decays: types>>=
  type :: decay_term_t
     type(decay_term_config_t), pointer :: config => null ()
     type(particle_out_t), dimension(:), allocatable :: particle_out
   contains
   <<Decays: decay term: TBP>>
  end type decay_term_t

@ %def decay_term_t
@ Finalizer.
<<Decays: decay term: TBP>>=
  procedure :: final => decay_term_final
<<Decays: procedures>>=
  recursive subroutine decay_term_final (object)
    class(decay_term_t), intent(inout) :: object
    integer :: i
    if (allocated (object%particle_out)) then
       do i = 1, size (object%particle_out)
          call object%particle_out(i)%c%final ()
       end do
    end if
  end subroutine decay_term_final
  
@ %def decay_term_final
@ Output.
<<Decays: decay term: TBP>>=
  procedure :: write => decay_term_write
<<Decays: procedures>>=
  recursive subroutine decay_term_write (object, unit, indent)
    class(decay_term_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: i, u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose = .false.)
    do i = 1, size (object%particle_out)
       call object%particle_out(i)%c%write (u, ind)
    end do
  end subroutine decay_term_write

@ %def decay_term_write
@ Recursively write the embedded process instances.
<<Decays: decay term: TBP>>=
  procedure :: write_process_instances => decay_term_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_term_write_process_instances (term, unit, verbose)
    class(decay_term_t), intent(in) :: term
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%write_process_instances (unit, verbose)
       end select
    end do
  end subroutine decay_term_write_process_instances
  
@ %def decay_term_write_process_instances
@ Initialization, using the configuration object.  We allocate
particle objects in parallel to the particle configuration objects
which we use to initialize them, one at a time.
<<Decays: decay term: TBP>>=
  procedure :: init => decay_term_init
<<Decays: procedures>>=
  recursive subroutine decay_term_init (term, config)
    class(decay_term_t), intent(out) :: term
    type(decay_term_config_t), intent(in), target :: config
    integer :: i
    term%config => config
    allocate (term%particle_out (size (config%prt)))
    do i = 1, size (config%prt)
       select type (prt_config => config%prt(i)%c)
       type is (stable_config_t)
          allocate (stable_t :: term%particle_out(i)%c)
          select type (stable => term%particle_out(i)%c)
          type is (stable_t)
             call stable%init (prt_config)
          end select
       type is (unstable_config_t)
          allocate (unstable_t :: term%particle_out(i)%c)
          select type (unstable => term%particle_out(i)%c)
          type is (unstable_t)
             call unstable%init (prt_config)
          end select
       end select
    end do
  end subroutine decay_term_init

@ %def decay_term_init
@ Implement a RNG instance, spawned by the process object.
<<Decays: decay term: TBP>>=
  procedure :: make_rng => decay_term_make_rng
<<Decays: procedures>>=
  subroutine decay_term_make_rng (term, process)
    class(decay_term_t), intent(inout) :: term
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call process%make_rng (rng)
          call unstable%import_rng (rng)
       end select
    end do
  end subroutine decay_term_make_rng
    
@ %def decay_term_make_rng
@ Link the interactions for unstable decay products to the
interaction of the parent process.
<<Decays: decay term: TBP>>=
  procedure :: link_interactions => decay_term_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_term_link_interactions (term, trace)
    class(decay_term_t), intent(inout) :: term
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%link_interactions (i, trace)
       end select
    end do
  end subroutine decay_term_link_interactions
  
@ %def decay_term_link_interactions
@ Recursively generate a decay chain, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: select_chain => decay_term_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_term_select_chain (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%select_chain ()
       end select
    end do
  end subroutine decay_term_select_chain

@ %def decay_term_select_chain
@ Recursively generate a decay event, for each of the unstable
particles in the final state.
<<Decays: decay term: TBP>>=
  procedure :: generate => decay_term_generate
<<Decays: procedures>>=
  recursive subroutine decay_term_generate (term)
    class(decay_term_t), intent(inout) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          call unstable%generate ()
       end select
    end do
  end subroutine decay_term_generate

@ %def decay_term_generate
@
\subsection{Decay Root Configuration}
At the root of a decay chain, there is a parent process.  The decay root
stores a pointer to the parent process and the set of decay configurations.
<<Decays: types>>=
  type :: decay_root_config_t
     type(string_t) :: process_id
     type(process_t), pointer :: process => null ()
     class(model_data_t), pointer :: model => null ()
     type(decay_term_config_t), dimension(:), allocatable :: term_config
   contains
   <<Decays: decay root config: TBP>>
  end type decay_root_config_t
  
@ %def decay_root_config_t
@ The finalizer is recursive since there may be cascade decays.
<<Decays: decay root config: TBP>>=
  procedure :: final => decay_root_config_final
<<Decays: procedures>>=
  recursive subroutine decay_root_config_final (object)
    class(decay_root_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%final ()
       end do
    end if
  end subroutine decay_root_config_final
  
@ %def decay_root_config_final
@ The output routine is also recursive, and it contains an adjustable
indentation.
<<Decays: decay root config: TBP>>=
  procedure :: write => decay_root_config_write
  procedure :: write_header => decay_root_config_write_header
  procedure :: write_terms => decay_root_config_write_terms
<<Decays: procedures>>=
  recursive subroutine decay_root_config_write (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Final-state decay tree:"
    call object%write_header (unit, indent)
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_root_config_write

  subroutine decay_root_config_write_header (object, unit, indent)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    if (associated (object%process)) then
       write (u, 3)  "process ID      =", char (object%process_id), "*"
    else
       write (u, 3)  "process ID      =", char (object%process_id)
    end if
3   format (3x,A,2(1x,A))
  end subroutine decay_root_config_write_header
    
  recursive subroutine decay_root_config_write_terms &
       (object, unit, indent, verbose)
    class(decay_root_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: i, u, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    if (verb .and. allocated (object%term_config)) then
       do i = 1, size (object%term_config)
          call object%term_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine decay_root_config_write_terms
    
@ %def decay_root_config_write
@ Initialize for a named process and (optionally) a pre-determined
number of terms.
<<Decays: decay root config: TBP>>=
  procedure :: init => decay_root_config_init
<<Decays: procedures>>=
  subroutine decay_root_config_init (decay, model, process_id, n_terms)
    class(decay_root_config_t), intent(out) :: decay
    class(model_data_t), intent(in), target :: model
    type(string_t), intent(in) :: process_id
    integer, intent(in), optional :: n_terms
    decay%model => model
    decay%process_id = process_id
    if (present (n_terms)) then
       allocate (decay%term_config (n_terms))
    end if
  end subroutine decay_root_config_init
       
@ %def decay_root_config_init
@ Declare a decay term, given an array of flavors.
<<Decays: decay root config: TBP>>=
  procedure :: init_term => decay_root_config_init_term
<<Decays: procedures>>=
  recursive subroutine decay_root_config_init_term &
       (decay, i, flv, stable, model, process_stack)
    class(decay_root_config_t), intent(inout) :: decay
    integer, intent(in) :: i
    type(flavor_t), dimension(:,:), intent(in) :: flv
    logical, dimension(:), intent(in) :: stable
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call decay%term_config(i)%init (flv, stable, model, process_stack)
  end subroutine decay_root_config_init_term
  
@ %def decay_root_config_init_term
@ Connect the decay root configuration with a process object (which should
represent the parent process).  This includes initialization, therefore
intent(out).

The flavor state is retrieved from the process term object.  However, we have
to be careful: the flavor object points to the model instance that is stored
in the process object.  This model instance may not contain the current
setting for unstable particles and decay.  Therefore, we assign the model
directly.

If the [[process_instance]] argument is provided, we use this for the
flavor state.  This applies to the decay root only, where the process
can be entangled with a beam setup, and the latter contains beam
remnants as further outgoing particles.  These must be included in the
set of outgoing flavors, since the decay application is also done on
the connected state.

Infer stability from the particle properties, using the first row in the set
of flavor states.  For unstable particles, we look for decays,
recursively, available from the process stack (if present).
<<Decays: decay root config: TBP>>=
  procedure :: connect => decay_root_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_root_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_root_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    type(connected_state_t), pointer :: connected_state
    type(interaction_t), pointer :: int
    type(flavor_t), dimension(:,:), allocatable :: flv
    logical, dimension(:), allocatable :: stable
    integer :: i
    call decay%init (model, process%get_id (), process%get_n_terms ())
    do i = 1, size (decay%term_config)
       if (present (process_instance)) then
          connected_state => process_instance%get_connected_state_ptr (i)
          int => connected_state%get_matrix_int_ptr ()
          call interaction_get_flv_out (int, flv)
       else
          call process%get_term_flv_out (i, flv)
       end if
       call flv%set_model (model)
       allocate (stable (size (flv, 1)))
       stable = flv(:,1)%is_stable ()
       call decay%init_term (i, flv, stable, model, process_stack)
       deallocate (flv, stable)
    end do
    decay%process => process
  end subroutine decay_root_config_connect

@ %def decay_root_config_connect
@ Recursively compute widths, errors, and branching ratios.
<<Decays: decay root config: TBP>>=
  procedure :: compute => decay_root_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_root_config_compute (decay)
    class(decay_root_config_t), intent(inout) :: decay
    integer :: i
    do i = 1, size (decay%term_config)
       call decay%term_config(i)%compute ()
    end do
  end subroutine decay_root_config_compute
  
@ %def decay_root_config_compute
@
\subsection{Decay Root Instance}
This is the common parent type for decay and decay root.  The process instance
points to the parent process.  The model pointer is separate because particle
settings may be updated w.r.t.\ the parent process object.
<<Decays: types>>=
  type, abstract :: decay_gen_t
     type(decay_term_t), dimension(:), allocatable :: term
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
   contains
   <<Decays: decay gen: TBP>>
  end type decay_gen_t
  
@ %def decay_gen_t
@
The decay root represents the parent process.  When an event is generated, the
generator selects the term to which the decay chain applies (if possible).

The process instance is just a pointer.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_root_t
     type(decay_root_config_t), pointer :: config => null ()
   contains
   <<Decays: decay root: TBP>>
  end type decay_root_t
  
@ %def decay_root_t
@ The finalizer has to recursively finalize the terms, but we can skip the
process instance which is not explicitly allocated.
<<Decays: decay gen: TBP>>=
  procedure :: base_final => decay_gen_final
<<Decays: procedures>>=
  recursive subroutine decay_gen_final (object)
    class(decay_gen_t), intent(inout) :: object
    integer :: i
    if (allocated (object%term)) then
       do i = 1, size (object%term)
          call object%term(i)%final ()
       end do
    end if
  end subroutine decay_gen_final    
  
@ %def decay_gen_final
@ No extra finalization for the decay root.
<<Decays: decay root: TBP>>=
  procedure :: final => decay_root_final
<<Decays: procedures>>=
  subroutine decay_root_final (object)
    class(decay_root_t), intent(inout) :: object
    call object%base_final ()
  end subroutine decay_root_final    
  
@ %def decay_gen_final
@ Output.
<<Decays: decay root: TBP>>=
  procedure :: write => decay_root_write
<<Decays: procedures>>=
  subroutine decay_root_write (object, unit)
    class(decay_root_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    if (associated (object%config)) then
       call object%config%write (unit, verbose = .false.)
    else
       write (u, "(1x,A)")  "Final-state decay tree: [not configured]"
    end if
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_root_write

@ %def decay_root_write
@ Write the process instances, recursively.
<<Decays: decay gen: TBP>>=
  procedure :: write_process_instances => decay_gen_write_process_instances
<<Decays: procedures>>=
  recursive subroutine decay_gen_write_process_instances (decay, unit, verbose)
    class(decay_gen_t), intent(in) :: decay
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    logical :: verb
    verb = .true.;  if (present (verbose))  verb = verbose
    if (associated (decay%process_instance)) then
       if (verb) then
          call decay%process_instance%write (unit)
       else
          call decay%process_instance%write_header (unit)
       end if
    end if
    if (decay%selected_term > 0) then
       call decay%term(decay%selected_term)%write_process_instances (unit, verb)
    end if
  end subroutine decay_gen_write_process_instances
    
@ %def decay_gen_write_process_instances
@ Generic initializer.  All can be done recursively.
<<Decays: decay gen: TBP>>=
  procedure :: base_init => decay_gen_init
<<Decays: procedures>>=
  recursive subroutine decay_gen_init (decay, term_config)
    class(decay_gen_t), intent(out) :: decay
    type(decay_term_config_t), dimension(:), intent(in), target :: term_config
    integer :: i
    allocate (decay%term (size (term_config)))
    do i = 1, size (decay%term)
       call decay%term(i)%init (term_config(i))
    end do
  end subroutine decay_gen_init

@ %def decay_gen_init
@ Specific initializer.  We assign the configuration object, which should
correspond to a completely initialized decay configuration tree.  We
also connect to an existing process instance.  Then, we recursively
link the child interactions to the parent process.
<<Decays: decay root: TBP>>=
  procedure :: init => decay_root_init
<<Decays: procedures>>=
  subroutine decay_root_init (decay_root, config, process_instance)
    class(decay_root_t), intent(out) :: decay_root
    type(decay_root_config_t), intent(in), target :: config
    type(process_instance_t), intent(in), target :: process_instance
    call decay_root%base_init (config%term_config)
    decay_root%config => config
    decay_root%process_instance => process_instance
    call decay_root%make_term_rng (config%process)
    call decay_root%link_term_interactions ()
  end subroutine decay_root_init

@ %def decay_root_init
@ Implement random-number generators for unstable decay selection in
all terms.  This is not recursive.

We also make use of the fact that [[process]] is a pointer; the (state
of the RNG factory inside the) target process will be modified by the
rng-spawning method, but not the pointer.
<<Decays: decay gen: TBP>>=
  procedure :: make_term_rng => decay_gen_make_term_rng
<<Decays: procedures>>=
  subroutine decay_gen_make_term_rng (decay, process)
    class(decay_gen_t), intent(inout) :: decay
    type(process_t), intent(in), pointer :: process
    integer :: i
    do i = 1, size (decay%term)
       call decay%term(i)%make_rng (process)
    end do
  end subroutine decay_gen_make_term_rng
    
@ %def decay_gen_make_term_rng
@ Recursively link interactions of the enclosed decay terms to the
corresponding terms in the current process instance.

Note: A bug in nagfor requires the extra [[i_term]] variable.
<<Decays: decay gen: TBP>>=
  procedure :: link_term_interactions => decay_gen_link_term_interactions
<<Decays: procedures>>=
  recursive subroutine decay_gen_link_term_interactions (decay)
    class(decay_gen_t), intent(inout) :: decay
    integer :: i, i_term
    type(interaction_t), pointer :: trace
    associate (instance => decay%process_instance)
      do i = 1, size (decay%term)
         i_term = i
         trace => instance%get_trace_int_ptr (i_term)
         call decay%term(i_term)%link_interactions (trace)
      end do
    end associate
  end subroutine decay_gen_link_term_interactions

@ %def decay_gen_link_term_interactions
@ Select a decay chain: decay modes and process components.
<<Decays: decay root: TBP>>=
  procedure :: select_chain => decay_root_select_chain
<<Decays: procedures>>=
  subroutine decay_root_select_chain (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    if (decay_root%selected_term > 0) then
       call decay_root%term(decay_root%selected_term)%select_chain ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_select_chain

@ %def decay_root_select_chain
@ Generate a decay tree, i.e., for the selected term in the parent
process, recursively generate a decay event for all unstable
particles.

Factor out the trace of the connected state of the parent process.
This trace should not be taken into account for unweighting the decay
chain, since it was already used for unweighting the parent event, or
it determines the overall event weight.
<<Decays: decay root: TBP>>=
  procedure :: generate => decay_root_generate
<<Decays: procedures>>=
  subroutine decay_root_generate (decay_root)
    class(decay_root_t), intent(inout) :: decay_root
    type(connected_state_t), pointer :: connected_state
    if (decay_root%selected_term > 0) then
       connected_state => decay_root%process_instance%get_connected_state_ptr &
            (decay_root%selected_term)
       call connected_state%normalize_matrix_by_trace ()
       call decay_root%term(decay_root%selected_term)%generate ()
    else
       call msg_bug ("Decays: no term selected for parent process")
    end if
  end subroutine decay_root_generate

@ %def decay_root_generate
@
\subsection{Decay Configuration}
A decay configuration describes a distinct decay mode of a particle.  Each
decay mode may include several terms, which correspond to the terms in the
associated process.  In addition to the base type, the decay configuration
object contains the integral of the parent process and the selector for the
MCI group inside this process.

The flavor component should be identical to the flavor component of the parent
particle ([[unstable]] object).
<<Decays: types>>=
  type, extends (decay_root_config_t) :: decay_config_t
     type(flavor_t) :: flv
     real(default) :: weight = 0
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: mci_selector
   contains
   <<Decays: decay config: TBP>>
  end type decay_config_t
  
@ %def decay_config_t
@ The output routine extends the decay-root writer by listing numerical
component values.
<<Decays: decay config: TBP>>=
  procedure :: write => decay_config_write
<<Decays: procedures>>=
  recursive subroutine decay_config_write (object, unit, indent, verbose)
    class(decay_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,A)")  "Decay:"
    call object%write_header (unit, indent)
    call write_indent (u, ind)
    write (u, 2)  "branching ratio =", object%weight * 100
    call write_indent (u, ind)
    write (u, 1)  "partial width   =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs)     =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel)     =", object%rel_error
1   format (3x,A,ES19.12)
2   format (3x,A,F11.6,1x,'%')
    call object%write_terms (unit, indent, verbose)
  end subroutine decay_config_write
    
@ %def decay_config_write
@ Connect a decay configuration with a process object (which should
represent the decay).  This includes initialization, therefore
intent(out).  We first connect the process itself, then do initializations
that are specific for this decay.

Infer stability from the particle properties, using the first row in the set
of flavor states.  Once we can deal with predetermined decay chains, they
should be used instead.
<<Decays: decay config: TBP>>=
  procedure :: connect => decay_config_connect
<<Decays: procedures>>=
  recursive subroutine decay_config_connect &
       (decay, process, model, process_stack, process_instance)
    class(decay_config_t), intent(out) :: decay
    type(process_t), intent(in), target :: process
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(process_instance_t), intent(in), optional, target :: process_instance
    real(default), dimension(:), allocatable :: integral_mci
    integer :: i, n_mci
    call decay%decay_root_config_t%connect (process, model, process_stack)
    decay%integral = process%get_integral ()
    decay%abs_error = process%get_error ()
    if (process%cm_frame ()) then
       call msg_fatal ("Decay process " // char (process%get_id ()) &
            // ": unusable because rest frame is fixed.")
    end if
    n_mci = process%get_n_mci ()
    allocate (integral_mci (n_mci))
    do i = 1, n_mci
       integral_mci(i) = process%get_integral_mci (i)
    end do
    call decay%mci_selector%init (integral_mci)
  end subroutine decay_config_connect

@ %def decay_config_connect
@ Set the flavor entry, which repeats the flavor of the parent unstable
particle.
<<Decays: decay config: TBP>>=
  procedure :: set_flv => decay_config_set_flv
<<Decays: procedures>>=
  subroutine decay_config_set_flv (decay, flv)
    class(decay_config_t), intent(inout) :: decay
    type(flavor_t), intent(in) :: flv
    decay%flv = flv
  end subroutine decay_config_set_flv
  
@ %def decay_config_set_flv
@ Compute embedded branchings and the relative error.  This method does not
apply to the decay root.
<<Decays: decay config: TBP>>=
  procedure :: compute => decay_config_compute
<<Decays: procedures>>=
  recursive subroutine decay_config_compute (decay)
    class(decay_config_t), intent(inout) :: decay
    call decay%decay_root_config_t%compute ()
    if (decay%integral /= 0) then
       decay%rel_error = decay%abs_error / decay%integral
    else
       decay%rel_error = 0
    end if
  end subroutine decay_config_compute
  
@ %def decay_config_compute
@
\subsection{Decay Instance}
The decay contains a collection of terms.  One of them is selected when the
decay is evaluated.  This is similar to the decay root, but we implement it
independently.

The process instance object is allocated via a pointer, so it automatically
behaves as a target.
<<Decays: types>>=
  type, extends (decay_gen_t) :: decay_t
     type(decay_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
   contains
   <<Decays: decay: TBP>>
  end type decay_t
     
@ %def decay_t
@ The finalizer is recursive.
<<Decays: decay: TBP>>=
  procedure :: final => decay_final
<<Decays: procedures>>=
  recursive subroutine decay_final (object)
    class(decay_t), intent(inout) :: object
    integer :: i
    call object%base_final ()
    do i = 1, object%config%process%get_n_mci ()
       call object%process_instance%final_simulation (i)
    end do
    call object%process_instance%final ()
    deallocate (object%process_instance)
  end subroutine decay_final
  
@ %def decay_final
@ Output.
<<Decays: decay: TBP>>=
  procedure :: write => decay_write
<<Decays: procedures>>=
  recursive subroutine decay_write (object, unit, indent, recursive)
    class(decay_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent, recursive
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (unit, indent, verbose = .false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 1)
    end if
    call write_indent (u, ind)
    if (object%selected_mci > 0) then
       write (u, "(3x,A,I0)")  "Selected MCI    = ", object%selected_mci
    else
       write (u, "(3x,A)")  "Selected MCI    = [undefined]"
    end if
    call write_indent (u, ind)
    if (object%selected_term > 0) then
       write (u, "(3x,A,I0)")  "Selected term   = ", object%selected_term
       call object%term(object%selected_term)%write (u, ind + 1)
    else
       write (u, "(3x,A)")  "Selected term   = [undefined]"
    end if
  end subroutine decay_write

@ %def decay_write
@ Initializer.  Base initialization is done recursively.  Then, we
prepare the current process instance and allocate a random-number
generator for term selection.  For all unstable particles, we also
allocate a r.n.g. as spawned by the current process.
<<Decays: decay: TBP>>=
  procedure :: init => decay_init
<<Decays: procedures>>=
  recursive subroutine decay_init (decay, config)
    class(decay_t), intent(out) :: decay
    type(decay_config_t), intent(in), target :: config
    integer :: i
    call decay%base_init (config%term_config)
    decay%config => config
    allocate (decay%process_instance)
    call decay%process_instance%init (decay%config%process)
    call decay%process_instance%setup_event_data (decay%config%model)
    do i = 1, decay%config%process%get_n_mci ()
       call decay%process_instance%init_simulation (i)
    end do
    call decay%config%process%make_rng (decay%rng)
    call decay%make_term_rng (decay%config%process)
  end subroutine decay_init

@ %def decay_init
@ Link interactions to the parent process.  [[i_prt]] is the index of
the current outgoing particle in the parent interaction, for which we
take the trace evaluator.  We link it to the beam particle in the beam
interaction of the decay process instance.  Then, repeat the procedure
for the outgoing particles.
<<Decays: decay: TBP>>=
  procedure :: link_interactions => decay_link_interactions
<<Decays: procedures>>=
  recursive subroutine decay_link_interactions (decay, i_prt, trace)
    class(decay_t), intent(inout) :: decay
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    type(interaction_t), pointer :: beam_int
    integer :: n_in, n_vir
    beam_int => decay%process_instance%get_beam_int_ptr ()
    n_in = trace%get_n_in ()
    n_vir = trace%get_n_vir ()
    call interaction_set_source_link (beam_int, 1, trace, &
         n_in + n_vir + i_prt)
    call decay%link_term_interactions ()
  end subroutine decay_link_interactions
    
@ %def decay_link_interactions
@ Determine a decay chain.  For each unstable particle we select one
of the possible decay modes, and for each decay process we select one
of the possible decay MCI components, calling the random-number
generators.  We do not generate momenta, yet.
<<Decays: decay: TBP>>=
  procedure :: select_chain => decay_select_chain
<<Decays: procedures>>=
  recursive subroutine decay_select_chain (decay)
    class(decay_t), intent(inout) :: decay
    real(default) :: x
    integer :: i
    call decay%rng%generate (x)
    decay%selected_mci = decay%config%mci_selector%select (x)
    call decay%process_instance%choose_mci (decay%selected_mci)
    call decay%process_instance%select_i_term (decay%selected_term)
    do i = 1, size (decay%term)
       call decay%term(i)%select_chain ()
    end do
  end subroutine decay_select_chain
  
@ %def decay_select_chain
@ Generate a decay.  We first receive the beam momenta from the parent
process (assuming that this is properly linked), then call the
associated process object for a new event.

Factor out the trace of the helicity density matrix of the isolated
state (the one that will be used for the decay chain).  The trace is
taken into account for unweighting the individual decay event and
should therefore be ignored for unweighting the correlated decay
chain afterwards.
<<Decays: decay: TBP>>=
  procedure :: generate => decay_generate
<<Decays: procedures>>=
  recursive subroutine decay_generate (decay)
    class(decay_t), intent(inout) :: decay
    type(isolated_state_t), pointer :: isolated_state
    integer :: i
    call decay%process_instance%receive_beam_momenta ()
    call decay%config%process%generate_unweighted_event &
         (decay%process_instance, decay%selected_mci)
    if (signal_is_pending ())  return
    call decay%process_instance%evaluate_event_data ()
    isolated_state => &
         decay%process_instance%get_isolated_state_ptr (decay%selected_term)
    call isolated_state%normalize_matrix_by_trace ()
    do i = 1, size (decay%term)
       call decay%term(i)%generate ()
       if (signal_is_pending ())  return
    end do
  end subroutine decay_generate
    
@ %def decay_generate
@
\subsection{Stable Particles}
This is a stable particle.  The flavor can be ambiguous (e.g., partons).
<<Decays: types>>=
  type, extends (any_config_t) :: stable_config_t
     type(flavor_t), dimension(:), allocatable :: flv
   contains
   <<Decays: stable config: TBP>>
  end type stable_config_t

@ %def stable_config_t
@ The finalizer is empty:
<<Decays: stable config: TBP>>=
  procedure :: final => stable_config_final
<<Decays: procedures>>=
  subroutine stable_config_final (object)
    class(stable_config_t), intent(inout) :: object
  end subroutine stable_config_final
  
@ %def stable_config_final
@ Output.
<<Decays: stable config: TBP>>=
  procedure :: write => stable_config_write
<<Decays: procedures>>=
  recursive subroutine stable_config_write (object, unit, indent, verbose)
    class(stable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A)", advance = "no")  "Stable:"
    write (u, "(1x,A)", advance = "no")  char (object%flv(1)%get_name ())
    do i = 2, size (object%flv)
       write (u, "(':',A)", advance = "no") &
            char (object%flv(i)%get_name ())
    end do
    write (u, *)
  end subroutine stable_config_write
  
@ %def stable_config_write
@ Initializer.  We are presented with an array of flavors, but there may be
double entries which we remove, so we store only the distinct flavors.
<<Decays: stable config: TBP>>=
  procedure :: init => stable_config_init
<<Decays: procedures>>=
  subroutine stable_config_init (config, flv)
    class(stable_config_t), intent(out) :: config
    type(flavor_t), dimension(:), intent(in) :: flv
    integer, dimension (size (flv)) :: pdg
    logical, dimension (size (flv)) :: mask
    integer :: i
    pdg = flv%get_pdg ()
    mask(1) = .true.
    forall (i = 2 : size (pdg))
       mask(i) = all (pdg(i) /= pdg(1:i-1))
    end forall
    allocate (config%flv (count (mask)))
    config%flv = pack (flv, mask)
  end subroutine stable_config_init
  
@ %def stable_config_init
@ Here is the corresponding object instance.  Except for the pointer
to the configuration, there is no content.
<<Decays: types>>=
  type, extends (any_t) :: stable_t
     type(stable_config_t), pointer :: config => null ()
   contains
   <<Decays: stable: TBP>>
  end type stable_t

@ %def stable_t
@ The finalizer does nothing.
<<Decays: stable: TBP>>=
  procedure :: final => stable_final
<<Decays: procedures>>=
  subroutine stable_final (object)
    class(stable_t), intent(inout) :: object
  end subroutine stable_final

@ %def stable_final
@ We can delegate output to the configuration object.
<<Decays: stable: TBP>>=
  procedure :: write => stable_write
<<Decays: procedures>>=
  subroutine stable_write (object, unit, indent)
    class(stable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    call object%config%write (unit, indent)
  end subroutine stable_write
  
@ %def stable_write
@ Initializer: just assign the configuration.
<<Decays: stable: TBP>>=
  procedure :: init => stable_init
<<Decays: procedures>>=
  subroutine stable_init (stable, config)
    class(stable_t), intent(out) :: stable
    type(stable_config_t), intent(in), target :: config
    stable%config => config
  end subroutine stable_init
  
@ %def stable_init
@
\subsection{Unstable Particles}
A branching configuration enables us to select among distinct decay
modes of a particle.  We store the particle flavor (with its implicit
link to a model), an array of decay configurations, and a selector object.

The total width, absolute and relative error are stored as
[[integral]], [[abs_error]], and [[rel_error]], respectively.

The flavor must be unique in this case.
<<Decays: types>>=
  type, extends (any_config_t) :: unstable_config_t
     type(flavor_t) :: flv
     real(default) :: integral = 0
     real(default) :: abs_error = 0
     real(default) :: rel_error = 0
     type(selector_t) :: selector
     type(decay_config_t), dimension(:), allocatable :: decay_config
   contains
   <<Decays: unstable config: TBP>>
  end type unstable_config_t
  
@ %def unstable_config_t
@ Finalizer.  The branching configuration can be a recursive structure.
<<Decays: unstable config: TBP>>=
  procedure :: final => unstable_config_final
<<Decays: procedures>>=
  recursive subroutine unstable_config_final (object)
    class(unstable_config_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%final ()
       end do
    end if
  end subroutine unstable_config_final

@ %def unstable_config_final
@ Output.  Since this may be recursive, we include indentation.
<<Decays: unstable config: TBP>>=
  procedure :: write => unstable_config_write
<<Decays: procedures>>=
  recursive subroutine unstable_config_write (object, unit, indent, verbose)
    class(unstable_config_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    logical, intent(in), optional :: verbose
    integer :: u, i, ind
    logical :: verb
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    verb = .true.;  if (present (verbose))  verb = verbose
    call write_indent (u, ind)
    write (u, "(1x,'+',1x,A,1x,A)")  "Unstable:", &
         char (object%flv%get_name ())
    call write_indent (u, ind)
    write (u, 1)  "total width =", object%integral
    call write_indent (u, ind)
    write (u, 1)  "error (abs) =", object%abs_error
    call write_indent (u, ind)
    write (u, 1)  "error (rel) =", object%rel_error
1   format (5x,A,ES19.12)
    if (verb .and. allocated (object%decay_config)) then
       do i = 1, size (object%decay_config)
          call object%decay_config(i)%write (u, ind + 1)
       end do
    end if
  end subroutine unstable_config_write
  
@ %def unstable_config_write
@ Initializer.  For the unstable particle, the flavor is unique.
<<Decays: unstable config: TBP>>=
  procedure :: init => unstable_config_init
<<Decays: procedures>>=
  subroutine unstable_config_init (config, flv)
    class(unstable_config_t), intent(out) :: config
    type(flavor_t), intent(in) :: flv
    config%flv = flv
  end subroutine unstable_config_init
  
@ %def unstable_config_init
@ Further initialization: determine the number of decay modes.  We can assume
that the flavor of the particle has been set already.

If the process stack is given, we can delve recursively into actually
assigning decay processes.  Otherwise, we just initialize with decay
process names.
<<Decays: unstable config: TBP>>=
  procedure :: init_decays => unstable_config_init_decays
<<Decays: procedures>>=
  recursive subroutine unstable_config_init_decays &
       (unstable, decay_id, model, process_stack)
    class(unstable_config_t), intent(inout) :: unstable
    type(string_t), dimension(:), intent(in) :: decay_id
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    integer :: i
    allocate (unstable%decay_config (size (decay_id)))
    do i = 1, size (decay_id)
       associate (decay => unstable%decay_config(i))
         if (present (process_stack)) then
            call decay%connect (process_stack%get_process_ptr (decay_id(i)), &
                 model, process_stack)
         else
            call decay%init (model, decay_id(i))
         end if
         call decay%set_flv (unstable%flv)
       end associate
    end do
  end subroutine unstable_config_init_decays
  
@ %def unstable_config_init
@ Compute the total width and branching ratios, initializing the decay
selector.
<<Decays: unstable config: TBP>>=
  procedure :: compute => unstable_config_compute
<<Decays: procedures>>=
  recursive subroutine unstable_config_compute (unstable)
    class(unstable_config_t), intent(inout) :: unstable
    integer :: i
    do i = 1, size (unstable%decay_config)
       call unstable%decay_config(i)%compute ()
    end do
    unstable%integral = sum (unstable%decay_config%integral)
    if (unstable%integral <= 0) then
       call unstable%write ()
       call msg_fatal ("Decay configuration: computed total width is zero")
    end if
    unstable%abs_error = sqrt (sum (unstable%decay_config%abs_error ** 2))
    unstable%rel_error = unstable%abs_error / unstable%integral
    call unstable%selector%init (unstable%decay_config%integral)
    do i = 1, size (unstable%decay_config)
       unstable%decay_config(i)%weight &
            = unstable%selector%get_weight (i)
    end do
  end subroutine unstable_config_compute
    
@ %def unstable_config_compute
@
Now we define the instance of an unstable particle.
<<Decays: types>>=
  type, extends (any_t) :: unstable_t
     type(unstable_config_t), pointer :: config => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_decay = 0
     type(decay_t), dimension(:), allocatable :: decay
   contains
   <<Decays: unstable: TBP>>
  end type unstable_t
  
@ %def unstable_t
@ Recursive finalizer.
<<Decays: unstable: TBP>>=
  procedure :: final => unstable_final
<<Decays: procedures>>=
  recursive subroutine unstable_final (object)
    class(unstable_t), intent(inout) :: object
    integer :: i
    if (allocated (object%decay)) then
       do i = 1, size (object%decay)
          call object%decay(i)%final ()
       end do
    end if
  end subroutine unstable_final
  
@ %def unstable_final
@ Output.
<<Decays: unstable: TBP>>=
  procedure :: write => unstable_write
<<Decays: procedures>>=
  recursive subroutine unstable_write (object, unit, indent)
    class(unstable_t), intent(in) :: object
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call object%config%write (u, ind, verbose=.false.)
    if (allocated (object%rng)) then
       call object%rng%write (u, ind + 2)
    end if
    call write_indent (u, ind)
    if (object%selected_decay > 0) then
       write (u, "(5x,A,I0)") "Sel. decay  = ", object%selected_decay
       call object%decay(object%selected_decay)%write (u, ind + 1)
    else
       write (u, "(5x,A)")  "Sel. decay  = [undefined]"
    end if
  end subroutine unstable_write
    
@ %def unstable_write
@ Write the embedded process instances.
<<Decays: unstable: TBP>>=
  procedure :: write_process_instances => unstable_write_process_instances
<<Decays: procedures>>=
  recursive subroutine unstable_write_process_instances &
       (unstable, unit, verbose)
    class(unstable_t), intent(in) :: unstable
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    if (unstable%selected_decay > 0) then
       call unstable%decay(unstable%selected_decay)% &
            write_process_instances (unit, verbose)
    end if
  end subroutine unstable_write_process_instances
  
@ %def unstable_write_process_instances
@ Initialization, using the configuration object.
<<Decays: unstable: TBP>>=
  procedure :: init => unstable_init
<<Decays: procedures>>=
  recursive subroutine unstable_init (unstable, config)
    class(unstable_t), intent(out) :: unstable
    type(unstable_config_t), intent(in), target :: config
    integer :: i
    unstable%config => config
    allocate (unstable%decay (size (config%decay_config)))
    do i = 1, size (config%decay_config)
       call unstable%decay(i)%init (config%decay_config(i))
    end do
  end subroutine unstable_init
  
@ %def unstable_init
@ Recursively link interactions to the parent process.  [[i_prt]] is
the index of the current outgoing particle in the parent interaction.
<<Decays: unstable: TBP>>=
  procedure :: link_interactions => unstable_link_interactions
<<Decays: procedures>>=
  recursive subroutine unstable_link_interactions (unstable, i_prt, trace)
    class(unstable_t), intent(inout) :: unstable
    integer, intent(in) :: i_prt
    type(interaction_t), intent(in), target :: trace
    integer :: i
    do i = 1, size (unstable%decay)
       call unstable%decay(i)%link_interactions (i_prt, trace)
    end do
  end subroutine unstable_link_interactions
    
@ %def unstable_link_interactions
@ Import the random-number generator state.
<<Decays: unstable: TBP>>=
  procedure :: import_rng => unstable_import_rng
<<Decays: procedures>>=
  subroutine unstable_import_rng (unstable, rng)
    class(unstable_t), intent(inout) :: unstable
    class(rng_t), intent(inout), allocatable :: rng
    call move_alloc (from = rng, to = unstable%rng)
  end subroutine unstable_import_rng
  
@ %def unstable_import_rng
@ Generate a decay chain.  First select a decay mode, then call the
[[select_chain]] method of the selected mode.
<<Decays: unstable: TBP>>=
  procedure :: select_chain => unstable_select_chain
<<Decays: procedures>>=
  recursive subroutine unstable_select_chain (unstable)
    class(unstable_t), intent(inout) :: unstable
    real(default) :: x
    call unstable%rng%generate (x)
    unstable%selected_decay = unstable%config%selector%select (x)
    call unstable%decay(unstable%selected_decay)%select_chain ()
  end subroutine unstable_select_chain
    
@ %def unstable_select_chain
@ Generate a decay event.
<<Decays: unstable: TBP>>=
  procedure :: generate => unstable_generate
<<Decays: procedures>>=
  recursive subroutine unstable_generate (unstable)
    class(unstable_t), intent(inout) :: unstable
    call unstable%decay(unstable%selected_decay)%generate ()
  end subroutine unstable_generate
    
@ %def unstable_generate
@
\subsection{Decay Chain}
While the decay configuration tree and the decay tree are static
entities (during a simulation run), the decay chain is dynamically
generated for each event.  The reason is that with the possibility of
several decay modes for each particle, and several terms for each
process, the total number of distinct decay chains is not under control.

Each entry in the decay chain is a connected parton state.  The origin
of the chain is a connected state in the parent process (not part of
the chain itself).  For each decay, mode and term chosen, we convolute
this with the isolated (!) state of the current decay, to generate a
new connected state.  We accumulate this chain by recursively
traversing the allocated decay tree.  Whenever a particle decays, it
becomes virtual and is replaced by its decay product, while all other
particles stay in the parton state as spectators.

Technically, we implement the decay chain as a stack structure and
include information from the associated decay object for easier
debugging.  This is a decay chain entry:
<<Decays: types>>=
  type, extends (connected_state_t) :: decay_chain_entry_t
     integer :: index = 0
     type(decay_config_t), pointer :: config => null ()
     integer :: selected_mci = 0
     integer :: selected_term = 0
     type(decay_chain_entry_t), pointer :: previous => null ()
  end type decay_chain_entry_t
     
@ %def decay_chain_entry_t
@ This is the complete chain; we need just a pointer to the last
entry.  We also include a pointer to the master process instance,
which serves as the seed for the decay chain.  

The evaluator [[correlated_trace]] traces over all quantum numbers
for the final spin-correlated (but color-summed) evaluator of the
decay chain.  This allows us to compute the probability for a momentum
configuration, given that all individual density matrices (of the
initial process and the subsequent decays) have been normalized to one.

Note: This trace is summed over color, so color is treated exactly
when computing spin correlations.  However, we do not keep
non-diagonal color correlations.  When an event is accepted, we
compute probabilities for all color states and can choose one of them.
<<Decays: types>>=
  type :: decay_chain_t
     type(process_instance_t), pointer :: process_instance => null ()
     integer :: selected_term = 0
     type(evaluator_t) :: correlated_trace
     type(decay_chain_entry_t), pointer :: last => null ()
   contains
   <<Decays: decay chain: TBP>>
  end type decay_chain_t
  
@ %def decay_chain_t
@ The finalizer recursively deletes and deallocates the entries.
<<Decays: decay chain: TBP>>=
  procedure :: final => decay_chain_final
<<Decays: procedures>>=
  subroutine decay_chain_final (object)
    class(decay_chain_t), intent(inout) :: object
    type(decay_chain_entry_t), pointer :: entry
    do while (associated (object%last))
       entry => object%last
       object%last => entry%previous
       call entry%final ()
       deallocate (entry)
    end do
    call evaluator_final (object%correlated_trace)
  end subroutine decay_chain_final
  
@ %def decay_chain_final
@ Doing output recursively allows us to display the chain in
chronological order.
<<Decays: decay chain: TBP>>=
  procedure :: write => decay_chain_write
<<Decays: procedures>>=
  subroutine decay_chain_write (object, unit)
    class(decay_chain_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Decay chain:"
    call write_entries (object%last)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Evaluator (correlated trace of the decay chain):"
    call write_separator (u)
    call object%correlated_trace%write (u)
    call write_separator (u, 2)
  contains
    recursive subroutine write_entries (entry)
      type(decay_chain_entry_t), intent(in), pointer :: entry
      if (associated (entry)) then
         call write_entries (entry%previous)
         call write_separator (u, 2)
         write (u, "(1x,A,I0)")  "Decay #", entry%index
         call entry%config%write_header (u)
         write (u, "(3x,A,I0)")  "Selected MCI    = ", entry%selected_mci
         write (u, "(3x,A,I0)")  "Selected term   = ", entry%selected_term
         call entry%config%term_config(entry%selected_term)%write (u, indent=1)
         call entry%write (u)
      end if
    end subroutine write_entries
  end subroutine decay_chain_write
    
@ %def decay_chain_write
@
Build a decay chain, recursively following the selected decays and
terms in a decay tree.  Before start, we finalize the chain, deleting
any previous contents.
<<Decays: decay chain: TBP>>=
  procedure :: build => decay_chain_build
<<Decays: procedures>>=
  subroutine decay_chain_build (chain, decay_root)
    class(decay_chain_t), intent(inout), target :: chain
    type(decay_root_t), intent(in) :: decay_root
    type(quantum_numbers_mask_t), dimension(:), allocatable :: qn_mask
    type(interaction_t), pointer :: int_last_decay
    call chain%final ()
    if (decay_root%selected_term > 0) then
       chain%process_instance => decay_root%process_instance
       chain%selected_term = decay_root%selected_term
       call chain%build_term_entries (decay_root%term(decay_root%selected_term))
    end if
    int_last_decay => chain%last%get_matrix_int_ptr ()
    allocate (qn_mask (int_last_decay%get_n_tot ()))
    call qn_mask%init (mask_f = .true., mask_c = .true., mask_h = .true.)
    call evaluator_init_qn_sum (chain%correlated_trace, int_last_decay, qn_mask)
  end subroutine decay_chain_build
    
@ %def decay_chain_build
@ Build the entries that correspond to a decay term.  We have to scan
all unstable particles.
<<Decays: decay chain: TBP>>=
  procedure :: build_term_entries => decay_chain_build_term_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_term_entries (chain, term)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_term_t), intent(in) :: term
    integer :: i
    do i = 1, size (term%particle_out)
       select type (unstable => term%particle_out(i)%c)
       type is (unstable_t)
          if (unstable%selected_decay > 0) then
             call chain%build_decay_entries &
                  (unstable%decay(unstable%selected_decay))
          end if
       end select
    end do
  end subroutine decay_chain_build_term_entries
  
@ %def decay_chain_build_term_entries
@ Build the entries that correspond to a specific decay.  The
decay term should have been determined, so we allocate a decay chain
entry and fill it, then proceed to child decays.

For the first entry, we convolute the connected state of the parent process
instance with the isolated state of the current
decay (which does not contain an extra beam entry for the parent).
For subsequent entries, we take the previous entry as first factor.

In principle, each chain entry (as a parton state) is capable of
holding a subevent object and associated expressions.  We currently do
not make use of that feature.

Before generating the decays, factor out the trace of the helicity
density matrix of the parent parton state.  This trace has
been used for unweighting the original event (unweighted case) or it
determines the overall weight, so it should not be taken into account
in the decay chain generation.
<<Decays: decay chain: TBP>>=
  procedure :: build_decay_entries => decay_chain_build_decay_entries
<<Decays: procedures>>=
  recursive subroutine decay_chain_build_decay_entries (chain, decay)
    class(decay_chain_t), intent(inout) :: chain
    type(decay_t), intent(in) :: decay
    type(decay_chain_entry_t), pointer :: entry
    type(connected_state_t), pointer :: previous_state
    type(isolated_state_t), pointer :: current_decay
    type(helicity_t) :: hel
    type(quantum_numbers_t) :: qn_filter_conn
    allocate (entry)
    if (associated (chain%last)) then
       entry%previous => chain%last
       entry%index = entry%previous%index + 1
       previous_state => entry%previous%connected_state_t
    else
       entry%index = 1
       previous_state => &
            chain%process_instance%get_connected_state_ptr (chain%selected_term)
    end if
    entry%config => decay%config
    entry%selected_mci = decay%selected_mci
    entry%selected_term = decay%selected_term
    current_decay => decay%process_instance%get_isolated_state_ptr &
         (decay%selected_term)
    call entry%setup_connected_trace &
         (current_decay, previous_state%get_trace_int_ptr (), resonant=.true.)
    if (entry%config%flv%has_decay_helicity ()) then
       call hel%init (entry%config%flv%get_decay_helicity ())
       call qn_filter_conn%init (hel)
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true., qn_filter_conn = qn_filter_conn)
    else
       call entry%setup_connected_matrix &
            (current_decay, previous_state%get_matrix_int_ptr (), &
            resonant=.true.)
       call entry%setup_connected_flows &
            (current_decay, previous_state%get_flows_int_ptr (), &
            resonant=.true.)
    end if
    chain%last => entry
    call chain%build_term_entries (decay%term(decay%selected_term))
  end subroutine decay_chain_build_decay_entries
    
@ %def decay_chain_build_decay_entries
@ Recursively fill the decay chain with momenta and evaluate the
matrix elements.  Since all evaluators should have correct source
entries at this point, momenta are automatically retrieved from the
appropriate process instance.


Like we did above for the parent process, factor out the trace for
each subsequent decay (the helicity density matrix in the isolated
state, which is taken for the convolution).
<<Decays: decay chain: TBP>>=
  procedure :: evaluate => decay_chain_evaluate
<<Decays: procedures>>=
  subroutine decay_chain_evaluate (chain)
    class(decay_chain_t), intent(inout) :: chain
    call evaluate (chain%last)
    call evaluator_receive_momenta (chain%correlated_trace)
    call chain%correlated_trace%evaluate ()
  contains
    recursive subroutine evaluate (entry)
      type(decay_chain_entry_t), intent(inout), pointer :: entry
      if (associated (entry)) then
         call evaluate (entry%previous)
         call entry%receive_kinematics ()
         call entry%evaluate_trace ()
         call entry%evaluate_event_data ()
      end if
    end subroutine evaluate
  end subroutine decay_chain_evaluate
  
@ %def decay_chain_evaluate
@ Return the probability of a decay chain.  This is given as the trace
of the density matrix with intermediate helicity correlations,
normalized by the product of the uncorrelated density matrix traces.  This
works only if an event has been evaluated and the [[correlated_trace]]
evaluator is filled.  By definition, this evaluator has only one
matrix element, and this must be real.
<<Decays: decay chain: TBP>>=
  procedure :: get_probability => decay_chain_get_probability
<<Decays: procedures>>=
  function decay_chain_get_probability (chain) result (x)
    class(decay_chain_t), intent(in) :: chain
    real(default) :: x
    x = evaluator_get_matrix_element (chain%correlated_trace, 1)
  end function decay_chain_get_probability
  
@ %def decay_chain_get_probability
@
\subsection{Decay as Event Transform}
The [[evt_decay]] object combines decay configuration, decay tree, and
chain in a single object, as an implementation of the [[evt]] (event
transform) abstract type.
<<Decays: public>>=
  public :: evt_decay_t
<<Decays: types>>=
  type, extends (evt_t) :: evt_decay_t
     type(decay_root_config_t) :: decay_root_config
     type(decay_root_t) :: decay_root
     type(decay_chain_t) :: decay_chain
   contains
   <<Decays: evt decay: TBP>>
  end type evt_decay_t
  
@ %def evt_decay_t
@ Output.  We display the currently selected decay tree, which
includes configuration data, and the decay chain, i.e., the evaluators.
<<Decays: evt decay: TBP>>=
  procedure :: write => evt_decay_write
<<Decays: procedures>>=
  subroutine evt_decay_write (object, unit, &
       show_decay_tree, &
       show_processes, &
       verbose)
    class(evt_decay_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_decay_tree, show_processes, verbose
    logical :: dec, prc, verb
    integer :: u
    u = given_output_unit (unit)
    dec = .true.;  if (present (show_decay_tree))  dec = show_decay_tree
    prc = .false.;  if (present (show_processes))  prc = show_processes
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: partonic decays"
    call write_separator (u, 2)
    call object%base_write (u)
    if (dec) then
       call write_separator (u)
       call object%decay_root%write (u)
       if (verb) then
          call object%decay_chain%write (u)
       end if
       if (prc) then
          call object%decay_root%write_process_instances (u, verb)
       end if
    else
       call write_separator (u, 2)
    end if
  end subroutine evt_decay_write
    
@ %def evt_decay_write
@ Connect with a process instance and process.  This initializes the
decay configuration.  The process stack is used to look for process
objects that implement daughter decays.

When all processes are assigned, configure the decay tree instance, using the
decay tree configuration.  First obtain the branching ratios, then allocate
the decay tree.  This is done once for all events.
<<Decays: evt decay: TBP>>=
  procedure :: connect => evt_decay_connect
<<Decays: procedures>>=
  subroutine evt_decay_connect (evt, process_instance, model, process_stack)
    class(evt_decay_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model)
    call evt%decay_root_config%connect (process_instance%process, &
         model, process_stack, process_instance)
    call evt%decay_root_config%compute ()
    call evt%decay_root%init (evt%decay_root_config, evt%process_instance)
  end subroutine evt_decay_connect
  
@ %def evt_decay_connect
@ Prepare a new event: Select a decay chain and build the corresponding chain
object.
<<Decays: evt decay: TBP>>=
  procedure :: prepare_new_event => evt_decay_prepare_new_event
<<Decays: procedures>>=
  subroutine evt_decay_prepare_new_event (evt, i_mci, i_term)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    evt%decay_root%selected_mci = i_mci
    evt%decay_root%selected_term = i_term
    call evt%decay_root%select_chain ()
    call evt%decay_chain%build (evt%decay_root)
  end subroutine evt_decay_prepare_new_event
  
@ %def evt_decay_prepare_new_event
@ Generate a weighted event and assign the resulting weight
(probability).  We use a chain initialized by the preceding
subroutine, fill it with momenta and evaluate.
<<Decays: evt decay: TBP>>=
  procedure :: generate_weighted => evt_decay_generate_weighted
<<Decays: procedures>>=
  subroutine evt_decay_generate_weighted (evt, probability)
    class(evt_decay_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    call evt%decay_root%generate ()
    if (signal_is_pending ())  return
    call evt%decay_chain%evaluate ()
    probability = evt%decay_chain%get_probability ()
  end subroutine evt_decay_generate_weighted
  
@ %def evt_decay_generate_weighted
@ To create a usable event, we have to transform the interaction into a
particle set; this requires factorization for the correlated density matrix,
according to the factorization mode.
<<Decays: evt decay: TBP>>=
  procedure :: make_particle_set => evt_decay_make_particle_set
<<Decays: procedures>>=
  subroutine evt_decay_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_decay_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
    type(interaction_t), pointer :: int_matrix, int_flows
    type(decay_chain_entry_t), pointer :: last_entry
    last_entry => evt%decay_chain%last
    int_matrix => last_entry%get_matrix_int_ptr ()
    int_flows  => last_entry%get_flows_int_ptr ()
    call evt%factorize_interactions (int_matrix, int_flows, &
         factorization_mode, keep_correlations, r)
    call evt%tag_incoming ()
  end subroutine evt_decay_make_particle_set
    
@ %def event_decay_make_particle_set
@
Eliminate numerical noise for the associated process instances.
<<Decays: public>>=
  public :: pacify
<<Decays: interfaces>>=
  interface pacify
     module procedure pacify_decay
  end interface pacify
<<Decays: procedures>>=
  subroutine pacify_decay (evt)
    class(evt_decay_t), intent(inout) :: evt
    call pacify_decay_gen (evt%decay_root)
  contains
    recursive subroutine pacify_decay_gen (decay)
      class(decay_gen_t), intent(inout) :: decay
      if (associated (decay%process_instance)) then
         call pacify (decay%process_instance)
      end if
      if (decay%selected_term > 0) then
         call pacify_term (decay%term(decay%selected_term))
      end if
    end subroutine pacify_decay_gen
    recursive subroutine pacify_term (term)
      class(decay_term_t), intent(inout) :: term
      integer :: i
      do i = 1, size (term%particle_out)
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t);  call pacify_unstable (unstable)
         end select
      end do
    end subroutine pacify_term
    recursive subroutine pacify_unstable (unstable)
      class(unstable_t), intent(inout) :: unstable
      if (unstable%selected_decay > 0) then
         call pacify_decay_gen (unstable%decay(unstable%selected_decay))
      end if
    end subroutine pacify_unstable
  end subroutine pacify_decay
  
@ %def pacify
@
\subsection{Unit tests}
<<Decays: public>>=
  public :: decays_test
<<Decays: tests>>=
  subroutine decays_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Decays: execute tests>>
  end subroutine decays_test
  
@ %def decays_test
@
\subsubsection{Testbed}
As a variation of the [[prepare_test_process]] routine used elsewhere, we
define here a routine that creates two processes (scattering $ss\to ss$ and
decay $s\to f\bar f$), compiles and integrates them and prepares for event
generation. 
<<Decays: public>>=
  public :: prepare_testbed
<<Decays: tests>>=
  subroutine prepare_testbed &
       (lib, process_stack, prefix, os_data, &
        scattering, decay, decay_rest_frame)
    type(process_library_t), intent(out), target :: lib
    type(process_stack_t), intent(out) :: process_stack
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: scattering, decay
    logical, intent(in), optional :: decay_rest_frame

    type(model_data_t), target :: model
    class(model_data_t), pointer :: model_copy
    type(string_t) :: libname, procname1, procname2, run_id
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(process_entry_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    type(field_data_t), pointer :: field_data
    real(default) :: sqrts

    libname = prefix // "_lib"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    run_id = prefix

    call model%init_test ()
    call model%set_par (var_str ("ff"), 0.4_default)
    call model%set_par (var_str ("mf"), &
         model%get_real (var_str ("ff")) * model%get_real (var_str ("ms")))

    if (scattering .and. decay) then
       field_data => model%get_field_ptr (25)
       call field_data%set (p_is_stable = .false.)
    end if
    
    call prc_test_create_library (libname, lib, &
         scattering = .true., decay = .true., &
         procname1 = procname1, procname2 = procname2)

    call reset_interaction_counter ()

    allocate (test_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    if (scattering) then

       allocate (rng_test_factory_t :: rng_factory)
       allocate (model_copy)
       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname1, &
            run_id, lib, os_data, qcd, rng_factory, model_copy)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       sqrts = 1000
       call process%setup_beams_sqrts (sqrts)
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
    if (decay) then
       allocate (rng_test_factory_t :: rng_factory)
       allocate (model_copy)
       call model_copy%init (model%get_name (), &
            model%get_n_real (), &
            model%get_n_complex (), &
            model%get_n_field (), &
            model%get_n_vtx ())
       call model_copy%copy_from (model)

       allocate (process)
       call process%init (procname2, &
            run_id, lib, os_data, qcd, rng_factory, model_copy)
       call process%init_component &
            (1, core_template, mci_template, phs_config_template)
       if (present (decay_rest_frame)) then
          call process%setup_beams_decay (rest_frame = decay_rest_frame)
       else
          call process%setup_beams_decay (rest_frame = .not. scattering)
       end if
       call process%configure_phs ()
       call process%setup_mci ()
       call process%setup_terms ()

       allocate (process_instance)
       call process_instance%init (process%process_t)
       call process%integrate (process_instance, 1, n_it=1, n_calls=100)
       call process%final_integration (1)
       call process_instance%final ()
       deallocate (process_instance)

       call process%prepare_simulation (1)
       call process_stack%push (process)
    end if
    
    call model%final ()

  end subroutine prepare_testbed

@ %def prepare_testbed
@
\subsubsection{Simple decay configuration}
We define a branching configuration with two decay modes.  We set the
integral values by hand, so we do not need to evaluate processes, yet.
<<Decays: execute tests>>=
  call test (decays_1, "decays_1", &
       "branching and decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(model_data_t), target :: model
!    type(model_t), pointer :: model
!    type(model_list_t) :: model_list
    type(flavor_t) :: flv_h
    type(flavor_t), dimension(2,1) :: flv_hbb, flv_hgg
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_1"
    write (u, "(A)")  "*   Purpose: Set up branching and decay configuration"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call os_data_init (os_data)
    call model%init_sm_test ()
!    call model_list%read_model (var_str ("SM"), &
!         var_str ("SM.mdl"), os_data, model)

    call flv_h%init (25, model)
    call flv_hbb(:,1)%init ([5, -5], model)
    call flv_hgg(:,1)%init ([22, 22], model)

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call unstable%init_decays ([var_str ("h_bb"), var_str ("h_gg")], model)
    
    associate (decay => unstable%decay_config(1))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hbb, stable = [.true., .true.], model=model)
      decay%integral = 1.234e-3_default
      decay%abs_error = decay%integral * .02_default
    end associate
    
    associate (decay => unstable%decay_config(2))
      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hgg, stable = [.true., .true.], model=model)
      decay%integral = 3.085e-4_default
      decay%abs_error = decay%integral * .08_default
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_1"
    
  end subroutine decays_1
  
@ %def decays_1
@
\subsubsection{Cascade decay configuration}
We define a branching configuration with one decay, which is followed
by another branching.
<<Decays: execute tests>>=
  call test (decays_2, "decays_2", &
       "cascade decay configuration", &
       u, results)
<<Decays: tests>>=
  subroutine decays_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
!    type(model_t), pointer :: model
!    type(model_list_t) :: model_list
    type(model_data_t), target :: model
    type(flavor_t) :: flv_h, flv_wp, flv_wm
    type(flavor_t), dimension(2,1) :: flv_hww, flv_wud, flv_wen
    type(unstable_config_t), allocatable :: unstable
    type(string_t), dimension(:), allocatable :: decay

    write (u, "(A)")  "* Test output: decays_2"
    write (u, "(A)")  "*   Purpose: Set up cascade branching"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

!    call syntax_model_file_init ()
    call os_data_init (os_data)
!    call model_list%read_model (var_str ("SM"), &
!         var_str ("SM.mdl"), os_data, model)
    call model%init_sm_test ()

    call model%set_unstable (25, [var_str ("h_ww")])
    call model%set_unstable (24, [var_str ("w_ud"), var_str ("w_en")])

    call flv_h%init (25, model)
    call flv_hww(:,1)%init ([24, -24], model)
    call flv_wp%init (24, model)
    call flv_wm%init (-24, model)
    call flv_wud(:,1)%init ([2, -1], model)
    call flv_wen(:,1)%init ([-11, 12], model)
    

    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    unstable%flv = flv_h
    call unstable%flv%get_decays (decay)
    call unstable%init_decays (decay, model)
    
    associate (decay => unstable%decay_config(1))

      decay%integral = 1.e-3_default
      decay%abs_error = decay%integral * .01_default

      allocate (decay%term_config (1))
      call decay%init_term (1, flv_hww, stable = [.false., .true.], model=model)

      select type (w => decay%term_config(1)%prt(1)%c)
      type is (unstable_config_t)

         associate (w_decay => w%decay_config(1))
           w_decay%integral = 2._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wud, stable = [.true., .true.], &
                model=model)
         end associate
         associate (w_decay => w%decay_config(2))
           w_decay%integral = 1._default
           allocate (w_decay%term_config (1))
           call w_decay%init_term (1, flv_wen, stable = [.true., .true.], &
                model=model)
         end associate
         call w%compute ()

      end select
      
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call model%final ()
!    call model_list%final ()
!    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_2"
    
  end subroutine decays_2
  
@ %def decays_2
@
\subsubsection{Decay and Process Object}
We define a branching configuration with one decay and connect this
with an actual process object.
<<Decays: execute tests>>=
  call test (decays_3, "decays_3", &
       "associate process", &
       u, results)
<<Decays: tests>>=
  subroutine decays_3 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix
    type(string_t) :: procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable :: unstable

    write (u, "(A)")  "* Test output: decays_3"
    write (u, "(A)")  "*   Purpose: Connect a decay configuration &
         &with a process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and integrate process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_3"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame=.false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call process%write (.false., u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Set up branching and decay"
    write (u, "(A)")

    allocate (unstable)
    call unstable%flv%init (25, model)
    call unstable%init_decays ([procname2], model)
    
    write (u, "(A)")  "* Connect decay with process object"
    write (u, "(A)")

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()
    call unstable%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call unstable%final ()
    call process_stack%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_3"
    
  end subroutine decays_3

@ %def decays_3
@
\subsubsection{Decay and Process Object}
Building upon the previous test, we set up a decay instance and generate a
decay event.
<<Decays: execute tests>>=
  call test (decays_4, "decays_4", &
       "decay instance", &
       u, results)
<<Decays: tests>>=
  subroutine decays_4 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname2
    class(rng_t), allocatable :: rng
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(unstable_config_t), allocatable, target :: unstable
    type(unstable_t), allocatable :: instance

    write (u, "(A)")  "* Test output: decays_4"
    write (u, "(A)")  "*   Purpose: Create a decay process and evaluate &
         &an instance"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment, process, &
         &and decay configuration"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_4"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true., decay_rest_frame = .false.)

    procname2 = prefix // "_d"
    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()

    allocate (unstable)
    call unstable%flv%init (25, model)
    call unstable%init_decays ([procname2], model)
    
    call model%set_unstable (25, [procname2])

    associate (decay => unstable%decay_config(1))
      call decay%connect (process, model)
    end associate
    
    call unstable%compute ()

    allocate (rng_test_t :: rng)

    allocate (instance)
    call instance%init (unstable)
    call instance%import_rng (rng)

    call instance%select_chain ()
    call instance%generate ()
    call instance%write (u)

    write (u, *)
    call instance%write_process_instances (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call instance%final ()
    call process_stack%final ()
    call unstable%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_4"
    
  end subroutine decays_4

@ %def decays_4
@
\subsubsection{Decay with Parent Process}
We define a scattering process $ss\to ss$ and subsequent decays $s\to f\bar
f$.
<<Decays: execute tests>>=
  call test (decays_5, "decays_5", &
       "parent process and decay", &
       u, results)
<<Decays: tests>>=
  subroutine decays_5 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(decay_root_config_t), target :: decay_root_config
    type(decay_root_t) :: decay_root
    type(decay_chain_t) :: decay_chain
    integer :: i

    write (u, "(A)")  "* Test output: decays_5"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_5"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize decay tree configuration"
    write (u, "(A)")

    call decay_root_config%connect (process, model, process_stack)
    call decay_root_config%compute ()
    call decay_root_config%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay tree"

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    call decay_root%init (decay_root_config, process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain"
    write (u, "(A)")

    decay_root%selected_mci = 1
    !!! Not yet implemented; there is only one term anyway:
    ! call process_instance%select_i_term (decay_root%selected_term)
    decay_root%selected_term = 1
    call decay_root%select_chain ()

    call decay_chain%build (decay_root)
    
    call decay_root%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call process%generate_unweighted_event (process_instance, &
         decay_root%selected_mci)
    call process_instance%evaluate_event_data ()
    
    call decay_root%generate ()
    
    associate (term => decay_root%term(1))
      do i = 1, 2
         select type (unstable => term%particle_out(i)%c)
         type is (unstable_t)
            associate (decay => unstable%decay(1))
              call pacify (decay%process_instance)
            end associate
         end select
      end do
    end associate
    
    write (u, "(A)")  "* Process instances"
    write (u, "(A)")
    
    call decay_root%write_process_instances (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay chain"
    write (u, "(A)")
    
    call decay_chain%evaluate ()
    call decay_chain%write (u)

    write (u, *)
    write (u, "(A,ES19.12)")  "chain probability =", &
         decay_chain%get_probability ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call decay_chain%final ()
    call decay_root%final ()
    call decay_root_config%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_5"
    
  end subroutine decays_5

@ %def decays_5
@
\subsubsection{Decay as Event Transform}
Again, we define a scattering process $ss\to ss$ and subsequent decays
$s\to f\bar f$.
<<Decays: execute tests>>=
  call test (decays_6, "decays_6", &
       "evt_decay object", &
       u, results)
<<Decays: tests>>=
  subroutine decays_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(process_library_t), target :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(evt_decay_t), target :: evt_decay
    integer :: factorization_mode
    logical :: keep_correlations

    write (u, "(A)")  "* Test output: decays_6"
    write (u, "(A)")  "*   Purpose: Handle a process with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment and parent process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "decays_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize decay object"

    call evt_decay%connect (process_instance, model, process_stack)

    write (u, "(A)")
    write (u, "(A)")  "* Generate scattering event"

    call process%generate_unweighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Select decay chain and generate event"
    write (u, "(A)")

    call evt_decay%prepare_new_event (1, 1)
    call evt_decay%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_decay%make_particle_set (factorization_mode, keep_correlations)

    call evt_decay%write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_decay%final ()
    call process_instance%final ()
    deallocate (process_instance)
    
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: decays_6"
    
  end subroutine decays_6

@ %def decays_6
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Shower}
We might use matrix elements of LO and NLO to increase the accuracy of
the shower in the sense of matching as well as merging.
<<[[shower.f90]]>>=
<<File header>>

module shower

<<Use kinds with double>>
<<Use strings>>
  use io_units
  use constants, only: pi, twopi, zero
  use format_utils, only: write_separator
  use string_utils
  use unit_tests
  use system_defs, only: LF
  use os_interface
  use diagnostics
  use lorentz
  use system_dependencies, only: LHAPDF5_AVAILABLE, LHAPDF6_AVAILABLE
  use lhapdf !NODEP!
  use pdf_builtin !NODEP!
  
  use shower_base
  use shower_partons
  use shower_core
  use shower_pythia6
  use mlm_matching
  use ckkw_base
  use ckkw_matching
  use powheg
  
  use sm_qcd
  use particles
  use state_matrices, only: FM_IGNORE_HELICITY
  use model_data
  use variables
  use beam_structures
  use process_libraries
  use rng_base
  use mci_base
  use phs_base

  use event_transforms
  use models
  use hep_common
  use processes
  use process_stacks
  use rng_tao
  use mci_midpoint
  use phs_single
  use prc_core
  use prc_omega

<<Standard module head>>

<<Shower: public>>

<<Shower: parameters>>

<<Shower: types>>

contains

<<Shower: procedures>>

<<Shower: tests>>

end module shower
@ %def shower
@
\subsection{Configuration Parameters}
[[POWHEG_TESTING]] allows to disable the parton shower for validation
and testing of the POWHEG procedure.
<<Shower: parameters>>=
  logical, parameter :: DEBUG_SHOWER = .false.
  logical, parameter :: POWHEG_TESTING = .false.
  logical, parameter :: TEST_SUDAKOV = .false.
  logical, parameter :: TO_FILE = .false.

@ %def DEBUG_SHOWER POWHEG_TESTING TO_FILE
@
\subsection{Event Transform}
The event transforms can do more than mere showering.  Especially, it
may reweight showered events to fixed-order matrix elements.  The
[[model_hadrons]] is supposed to be the SM variant that contains all
hadrons that can be generated in the shower.
<<Shower: public>>=
  public :: evt_shower_t
<<Shower: types>>=
  type, extends (evt_t) :: evt_shower_t
     type(shower_settings_t) :: settings
     class(shower_base_t), allocatable :: shower
     type(model_t), pointer :: model_hadrons => null ()
     type(powheg_t) :: powheg
     class(matching_settings_t), allocatable :: matching_settings
     class(matching_data_t), allocatable :: data
     type(qcd_t), pointer :: qcd => null()
     type(pdf_data_t) :: pdf_data     
     type(os_data_t) :: os_data     
   contains
   <<Shower: evt shower: TBP>>
  end type evt_shower_t
  
@ %def evt_shower_t
@ Output.
<<Shower: evt shower: TBP>>=
  procedure :: write => evt_shower_write
<<Shower: procedures>>=
  subroutine evt_shower_write (object, unit, testflag)
    class(evt_shower_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: testflag
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Event transform: shower"
    call write_separator (u)
    call object%base_write (u, testflag = testflag)
    call write_separator (u)
    call object%settings%write (u)
  end subroutine evt_shower_write
    
@ %def evt_shower_write
<<Shower: evt shower: TBP>>=
  procedure :: connect => evt_shower_connect
<<Shower: procedures>>=
  subroutine evt_shower_connect &
       (evt, process_instance, model, process_stack)
    class(evt_shower_t), intent(inout), target :: evt
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    call evt%base_connect (process_instance, model, process_stack)
    call evt%make_rng (evt%process)
    if (evt%settings%powheg_matching) then
       call evt%powheg%connect (process_instance)
       call evt%powheg%setup_grids ()
    end if
  end subroutine evt_shower_connect

@ %def evt_shower_connect
@ Initialize the event transformation. This will be executed once
during dispatching. The [[model_hadrons]] is supposed to be the SM
variant that contains all hadrons that may be generated in the
shower. 
<<Shower: evt shower: TBP>>=
  procedure :: init => evt_shower_init
<<Shower: procedures>>=
  subroutine evt_shower_init &
       (evt, settings, model_hadrons, os_data, powheg)
    class(evt_shower_t), intent(out) :: evt
    type(shower_settings_t), intent(in) :: settings
    type(model_t), intent(in), target :: model_hadrons
    type(os_data_t), intent(in) :: os_data    
    type(powheg_t), intent(in), optional :: powheg
    evt%settings = settings
    evt%os_data = os_data
    evt%model_hadrons => model_hadrons
    if (present (powheg))  evt%powheg = powheg
  end subroutine evt_shower_init
  
@ %def evt_shower_init
@ Create RNG instances, spawned by the process object.
<<Shower: evt shower: TBP>>=
  procedure :: make_rng => evt_shower_make_rng
<<Shower: procedures>>=
  subroutine evt_shower_make_rng (evt, process)
    class(evt_shower_t), intent(inout) :: evt
    type(process_t), intent(inout) :: process
    class(rng_t), allocatable :: rng
    call process%make_rng (rng)
    call evt%shower%import_rng (rng)
    if (evt%settings%powheg_matching) then
       call process%make_rng (rng)
       call evt%powheg%import_rng (rng)
    end if
  end subroutine evt_shower_make_rng

@ %def evt_shower_make_rng
@ Use the process and beam structure to determine PDF parameters.  Will
be performed during dispatching.
<<Shower: evt shower: TBP>>=
  procedure :: setup_pdf => evt_shower_setup_pdf
<<Shower: procedures>>=
  subroutine evt_shower_setup_pdf (evt, process, beam_structure, lhapdf_member)
    class(evt_shower_t), intent(inout) :: evt
    type(process_t), intent(in) :: process
    type(beam_structure_t), intent(in) :: beam_structure
    integer, intent(in) :: lhapdf_member
    real(default) :: xmin, xmax, q2min, q2max
    if (beam_structure%contains ("lhapdf")) then
       if (LHAPDF6_AVAILABLE) then
          evt%pdf_data%type = STRF_LHAPDF6
       else if (LHAPDF5_AVAILABLE) then
          evt%pdf_data%type = STRF_LHAPDF5
       end if
       evt%pdf_data%set = process%get_pdf_set ()
       write (msg_buffer, "(A,I0)")  "Shower: interfacing LHAPDF set #", &
            evt%pdf_data%set
       call msg_message ()
    else if (beam_structure%contains ("pdf_builtin")) then
       evt%pdf_data%type = STRF_PDF_BUILTIN
       evt%pdf_data%set = process%get_pdf_set ()
       write (msg_buffer, "(A,I0)")  "Shower: interfacing PDF builtin set #", &
            evt%pdf_data%set
       call msg_message ()
    end if
    select case (evt%pdf_data%type)
    case (STRF_LHAPDF6)
       evt%pdf_data%xmin = evt%pdf_data%pdf%getxmin ()
       evt%pdf_data%xmax = evt%pdf_data%pdf%getxmax ()
       evt%pdf_data%qmin = sqrt(evt%pdf_data%pdf%getq2min ())
       evt%pdf_data%qmax = sqrt(evt%pdf_data%pdf%getq2max ())
    case (STRF_LHAPDF5)
       if (LHAPDF5_AVAILABLE) then
          call GetXminM (1, lhapdf_member, xmin)
          call GetXmaxM (1, lhapdf_member, xmax)
          call GetQ2minM (1, lhapdf_member, q2min)
          call GetQ2maxM (1, lhapdf_member, q2max)
          evt%pdf_data%xmin = xmin
          evt%pdf_data%xmax = xmax
          evt%pdf_data%qmin = sqrt(q2min)
          evt%pdf_data%qmax = sqrt(q2max)
       end if
    end select
  end subroutine evt_shower_setup_pdf
    
@ %def evt_shower_setup_pdf
@ Things we want to do for a new event before the whole event
transformation chain is evaluated.
<<Shower: evt shower: TBP>>=
  procedure :: prepare_new_event => evt_shower_prepare_new_event
<<Shower: procedures>>=
  subroutine evt_shower_prepare_new_event (evt, i_mci, i_term)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: i_mci, i_term
    call evt%reset ()
    if (.not. evt%settings%active .or. signal_is_pending ()) then
       return
    end if
    if (DEBUG_SHOWER) call evt%settings%write ()    
  end subroutine evt_shower_prepare_new_event

@ %def evt_shower_prepare_new_event
@ Here we take the particle set from the previous event transform
(assuming that there is always one) and apply the shower algorithm.  The
result is stored in the event transform of the current object.  We
always return a probability of unity as we don't have the analytic
weight of the combination of shower, MLM matching and hadronization.  A
subdivision into multiple event transformations is under construction.
Invalid or vetoed events have to be discarded by the caller which is why
we mark the particle set as invalid. This procedure directly takes the 
(MLM) matching into account.
<<Shower: evt shower: TBP>>=
  procedure :: generate_weighted => evt_shower_generate_weighted
<<Shower: procedures>>=
  subroutine evt_shower_generate_weighted (evt, probability)
    class(evt_shower_t), intent(inout) :: evt
    real(default), intent(out) :: probability
    logical :: valid, vetoed
    logical, save :: matching_disabled = .false.    
    integer :: i
    type(particle_t), dimension(1:2) :: prt_in    
    real(kind=double) :: pdftest    
    valid = .true.
    vetoed = .false.
    if (evt%previous%particle_set_exists) then
       if (DEBUG_SHOWER)  print *, "Shower: Generate weighted event"       
       evt%particle_set = evt%previous%particle_set
       if (evt%settings%powheg_matching) then
          if (DEBUG_SHOWER) call evt%particle_set%write ()
          call evt%powheg%update (evt%particle_set)
          if (TEST_SUDAKOV) then
             call evt%powheg%test_sudakov ()
             stop
          end if
          call evt%powheg%generate_emission (particle_set = evt%particle_set)
          if (DEBUG_SHOWER) call evt%powheg%write ()
       end if       
       if (evt%settings%ps_use_PYTHIA6_shower .or. &
           evt%settings%hadronization_active) then
          call assure_heprup (evt%particle_set)
       end if
       if (evt%settings%ckkw_matching) then
          select type (data => evt%data)
          type is (ckkw_matching_data_t)
             call ckkw_pseudo_shower_weights_init (data%ckkw_weights)
             call ckkw_fake_pseudo_shower_weights (evt%matching_settings, &
                  data%ckkw_weights, evt%particle_set)
          end select
       end if
       if (evt%settings%ps_fsr_active .or. &
            evt%settings%ps_isr_active .or. &
            evt%settings%hadronization_active .or. &
            evt%settings%mlm_matching .and. &
            .not. POWHEG_TESTING) then
          do i = 1, 2
             prt_in(i) = evt%particle_set%get_particle (i)
          end do
          ! ensure that lhapdf is initialized
          if (evt%pdf_data%type .eq. STRF_LHAPDF5) then
             if (evt%settings%ps_isr_active .and. &
                  (all (abs (prt_in%get_pdg ()) >= 1000))) then
                call GetQ2max (0, pdftest)
                if (pdftest < epsilon(pdftest)) then
                   call msg_fatal ("ISR QCD shower enabled, but LHAPDF not" // &
                        "initialized," // LF // "     aborting simulation")
                   return
                end if
             end if
          else if (evt%pdf_data%type == STRF_PDF_BUILTIN) then
             if (evt%settings%ps_use_PYTHIA6_shower) then
                call msg_fatal ("Builtin PDFs cannot be used for PYTHIA showers," &
                     // LF // "     aborting simulation")
                return
             end if
          end if
          if (DEBUG_SHOWER)  print *, "Shower: beam checks for mlm_matching"
          if (.not. matching_disabled .and. allocated (evt%data)) then
             !!! Check if the beams are hadrons
             if (all (abs (prt_in%get_pdg ()) <= 18)) then
                evt%data%is_hadron_collision = .false.
             else if (all (abs (prt_in%get_pdg ()) >= 1000)) then
                evt%data%is_hadron_collision = .true.
             else 
                call msg_error (" Matching didn't recognize beams setup," // &
                     LF // "     disabling matching")
                matching_disabled = .true.
                return
             end if
          end if              
          call evt%shower%generate_emissions (evt%particle_set, &
               evt%settings, evt%model, evt%model_hadrons, evt%os_data, &
               evt%matching_settings, evt%data, valid, vetoed)
          if (evt%settings%mlm_matching .and. &
               (.not. matching_disabled)) then
             !!! MLM stage 2 -> PS jets and momenta
             select type (data => evt%data)
             type is (mlm_matching_data_t)
                select type (ms => evt%matching_settings)
                type is (mlm_matching_settings_t)
                   call matching_transfer_PS (data, evt%particle_set, ms)
                   !!! MLM stage 3 -> reconstruct and possibly reject
                   call mlm_matching_apply (data, ms, vetoed)
                   call mlm_matching_data_final (data)
                end select
             end select
          end if
          if (DEBUG_SHOWER)  print *, "SHOWER+MATCHING finished"          
       end if          
       if (DEBUG_SHOWER) then
          print *, "Shower: obtained particle set after SHOWER"
          call evt%particle_set%write ()
       end if       
       probability = 1
       if (valid .and. .not. vetoed) then
          evt%particle_set_exists = .true.
       else
          evt%particle_set_exists = .false.
       end if
    else
       call msg_bug ("Shower: input particle set does not exist")
    end if
  end subroutine evt_shower_generate_weighted

@ %def evt_shower_generate_weighted
@ Here we fill the particle set with the partons from the shower. The
particle set was already made by the routine above (or the event was
vetoed).  So we do nothing here.  The factorization parameters are
irrelevant.  
<<Shower: evt shower: TBP>>=
  procedure :: make_particle_set => evt_shower_make_particle_set
<<Shower: procedures>>=
  subroutine evt_shower_make_particle_set &
       (evt, factorization_mode, keep_correlations, r)
    class(evt_shower_t), intent(inout) :: evt
    integer, intent(in) :: factorization_mode
    logical, intent(in) :: keep_correlations
    real(default), dimension(:), intent(in), optional :: r
  end subroutine evt_shower_make_particle_set

@ %def event_shower_make_particle_set
@
<<Shower: evt shower: TBP>>=
  procedure :: final => evt_shower_final
<<Shower: procedures>>=
  subroutine evt_shower_final (object)
    class(evt_shower_t), intent(inout) :: object
    integer :: i
    if (object%settings%powheg_matching) &
         call object%powheg%write_statistics ()
  end subroutine evt_shower_final

@ %def evt_shower_final
@
\subsubsection{Matching functions}
@ Generate fake ckkw weights. This can be dropped, once information
from the matrix element generation is available.
<<Shower: public>>=
  public :: ckkw_fake_pseudo_shower_weights
<<Shower: procedures>>=
  subroutine ckkw_fake_pseudo_shower_weights &
       (settings, &
        ckkw_pseudo_shower_weights, particle_set)
    class(matching_settings_t), intent(inout) :: settings
    type(ckkw_pseudo_shower_weights_t), intent(inout) :: &
         ckkw_pseudo_shower_weights
    type(particle_set_t), intent(in) :: particle_set
    type(particle_t) :: prt
    integer :: i, j
    integer :: n
    type(vector4_t) :: momentum

    select type (settings)
    type is (ckkw_matching_settings_t)    
       settings%alphaS = 1.0_default
       settings%Qmin = 1.0_default
       settings%n_max_jets = 3
    class default
       call msg_fatal ("CKKW matching called with wrong data.")
    end select
       
    n = 2**particle_set%get_n_tot()
    if (allocated (ckkw_pseudo_shower_weights%weights)) then 
       deallocate (ckkw_pseudo_shower_weights%weights)
    end if
    allocate (ckkw_pseudo_shower_weights%weights (1:n))
    do i = 1, n
       momentum = vector4_null
       do j = 1, particle_set%get_n_tot ()
          if (btest (i,j-1)) then
             prt = particle_set%get_particle (j) 
             momentum = momentum + prt%get_momentum ()
          end if
       end do
       if (momentum**1 > 0.0) then
          ckkw_pseudo_shower_weights%weights(i) = 1.0 / (momentum**2)
       end if
    end do
    ! equally distribute the weights by type
    if (allocated (ckkw_pseudo_shower_weights%weights_by_type)) then
       deallocate (ckkw_pseudo_shower_weights%weights_by_type)
    end if
    allocate (ckkw_pseudo_shower_weights%weights_by_type (1:n, 0:4))
    do i = 1, n
       do j = 0, 4
          ckkw_pseudo_shower_weights%weights_by_type(i,j) = &
               0.2 * ckkw_pseudo_shower_weights%weights(i)
       end do
    end do
  end subroutine ckkw_fake_pseudo_shower_weights
  
@ %def ckkw_fake_pseudo_shower_weights
@
\subsection{Unit Tests}
<<Shower: public>>=
  public :: shower_test
<<Shower: tests>>=
  subroutine shower_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Shower: execute tests>>
  end subroutine shower_test
  
@ %def shower_test
@
\subsubsection{Testbed}
This sequence sets up a two-jet process, ready for generating events.
<<Shower: tests>>=
<<setup testbed>>
@
<<setup testbed>>=
  subroutine setup_testbed &
       (prefix, os_data, lib, model_list, process, process_instance)
    type(string_t), intent(in) :: prefix
    type(os_data_t), intent(out) :: os_data
    type(process_library_t), intent(out), target :: lib
    type(model_list_t), intent(out) :: model_list
    class(model_data_t), pointer :: model
    type(model_t), pointer :: model_tmp
    type(process_t), target, intent(out) :: process
    type(process_instance_t), target, intent(out) :: process_instance
    type(var_list_t), pointer :: model_vars
    type(string_t) :: model_name, libname, procname, run_id
    type(process_def_entry_t), pointer :: entry
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts

    model_name = "SM"
    libname = prefix // "_lib"
    procname = prefix // "p"
    run_id = "1"
    
    call os_data_init (os_data)
    allocate (rng_tao_factory_t :: rng_factory)
    allocate (model_tmp)
    call model_list%read_model (model_name, model_name // ".mdl", &
         os_data, model_tmp)
    model_vars => model_tmp%get_var_list_ptr ()
    call var_list_set_real (model_vars, var_str ("me"), 0._default, &
         is_known = .true.)
    model => model_tmp

    call lib%init (libname)

    allocate (prt_in (2), source = [var_str ("e-"), var_str ("e+")])
    allocate (prt_out (2), source = [var_str ("d"), var_str ("dbar")])

    allocate (entry)
    call entry%init (procname, model, n_in = 2, n_components = 1)
    call omega_make_process_component (entry, 1, &
         model_name, prt_in, prt_out, &
         report_progress=.true.)
    call lib%append (entry)

    call lib%configure (os_data)
    call lib%write_makefile (os_data, force = .true.)
    call lib%clean (os_data, distclean = .false.)
    call lib%write_driver (force = .true.)
    call lib%load (os_data)
    
    call process%init (procname, run_id, lib, os_data, &
         qcd, rng_factory, model)
    
    allocate (prc_omega_t :: core_template)
    allocate (mci_midpoint_t :: mci_template)
    allocate (phs_single_config_t :: phs_config_template)

    model => process%get_model_ptr ()

    select type (core_template)
    type is (prc_omega_t)
       call core_template%set_parameters (model = model)
    end select
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()
    call process%setup_terms ()
    
    call process_instance%init (process)
    call process%integrate (process_instance, 1, 1, 1000)
    call process%final_integration (1)

    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)
    call process%generate_weighted_event (process_instance, 1)
    call process_instance%evaluate_event_data ()

  end subroutine setup_testbed

@ %def setup_testbed
@
\subsubsection{Trivial Test}
We generate a two-jet event and shower it using default settings, i.e.
in disabled mode.
<<Shower: execute tests>>=
  call test (shower_1, "shower_1", &
       "disabled shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_1 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    class(model_data_t), pointer :: model
    type(model_t), pointer :: model_hadrons
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    type(pdf_data_t) :: pdf_data
    integer :: factorization_mode
    logical :: keep_correlations
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_1"
    write (u, "(A)")  "*   Purpose: Two-jet event with disabled shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_1"), &
         os_data, lib, model_list, process, process_instance)

    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    model => process%get_model_ptr ()
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (evt_shower%settings, pdf_data)
       call evt_shower%connect (process_instance, model)		
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_1"
    
  end subroutine shower_1
  
@ %def shower_1
@
\subsubsection{FSR Shower}
We generate a two-jet event and shower it with the Whizard FSR shower.
<<Shower: execute tests>>=
  call test (shower_2, "shower_2", &
       "final-state shower", &
       u, results)
<<Shower: tests>>=
  subroutine shower_2 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    type(process_library_t), target :: lib
    type(model_list_t) :: model_list
    type(model_t), pointer :: model_hadrons
    class(model_data_t), pointer :: model
    type(process_t), target :: process
    type(process_instance_t), target :: process_instance
    integer :: factorization_mode
    logical :: keep_correlations
    type(pdf_data_t) :: pdf_data
    class(evt_t), allocatable, target :: evt_trivial
    class(evt_t), allocatable, target :: evt_shower
    type(shower_settings_t) :: settings

    write (u, "(A)")  "* Test output: shower_2"
    write (u, "(A)")  "*   Purpose: Two-jet event with FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize environment"
    write (u, "(A)")

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model_list%read_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"), &
         os_data, model_hadrons)
    call setup_testbed (var_str ("shower_2"), &
         os_data, lib, model_list, process, process_instance)
    model => process%get_model_ptr ()
    
    write (u, "(A)")  "* Set up trivial transform"
    write (u, "(A)")
    
    allocate (evt_trivial_t :: evt_trivial)
    call evt_trivial%connect (process_instance, model)
    call evt_trivial%prepare_new_event (1, 1)
    call evt_trivial%generate_unweighted ()

    factorization_mode = FM_IGNORE_HELICITY
    keep_correlations = .false.
    call evt_trivial%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_trivial)
    type is (evt_trivial_t)
       call evt_trivial%write (u)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Set up shower event transform"
    write (u, "(A)")

    settings%ps_fsr_active = .true.

    allocate (evt_shower_t :: evt_shower)
    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%init (settings, model_hadrons, os_data)
       allocate (shower_t :: evt_shower%shower)
       call evt_shower%shower%init (evt_shower%settings, pdf_data)
       call evt_shower%connect (process_instance, model)       
    end select

    evt_trivial%next => evt_shower
    evt_shower%previous => evt_trivial

    call evt_shower%prepare_new_event (1, 1)
    call evt_shower%generate_unweighted ()
    call evt_shower%make_particle_set (factorization_mode, keep_correlations)

    select type (evt_shower)
    type is (evt_shower_t)
       call evt_shower%write (u, testflag = .true.)
       call write_separator (u, 2)
    end select

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call evt_shower%final ()
    call evt_trivial%final ()
    call process_instance%final ()
    call process%final ()
    call lib%final ()
    call model_hadrons%final ()
    deallocate (model_hadrons)
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: shower_2"
    
  end subroutine shower_2
  
@ %def shower_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Complete Events}

This module combines hard processes with decay chains, shower, and
hadronization (not implemented yet) to complete events.  It also
manages the input and output of event records in various formats.
<<[[events.f90]]>>=
<<File header>>

module events
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use format_defs, only: FMT_12
  use unit_tests
  use diagnostics
  use os_interface
  use subevents
  use variables
  use expr_base
  use model_data
  use state_matrices
  use particles
  use interactions
  use subevt_expr
  use rng_base
  use process_libraries
  use processes
  use process_stacks
  use event_base
  use event_transforms
  use decays
  use shower

<<Standard module head>>

<<Events: public>>

<<Events: types>>

<<Events: interfaces>>

contains
  
<<Events: procedures>>

<<Events: tests>>

end module events
@ %def events
@
\subsection{Event configuration}
The parameters govern the transformation of an event to a particle set.

The [[safety_factor]] reduces the acceptance probability for
unweighting.  If greater than one, excess events become less likely,
but the reweighting efficiency also drops.

The [[sigma]] and [[n]] values, if nontrivial, allow for reweighting
the events according to the requested [[norm_mode]].

Various [[parse_node_t]] objects are taken from the SINDARIN input.
They encode expressions that apply to the current event.  The
workspaces for evaluating those expressions are set up in the
[[event_expr_t]] objects.  Note that these are really pointers,
so the actual nodes are not stored inside the event object.
<<Events: types>>=
  type :: event_config_t
     logical :: unweighted = .false.
     integer :: norm_mode = NORM_UNDEFINED
     integer :: factorization_mode = FM_IGNORE_HELICITY
     logical :: keep_correlations = .false.
     real(default) :: sigma = 1
     integer :: n = 1
     real(default) :: safety_factor = 1
     class(expr_factory_t), allocatable :: ef_selection
     class(expr_factory_t), allocatable :: ef_reweight
     class(expr_factory_t), allocatable :: ef_analysis
   contains
   <<Events: event config: TBP>>
  end type event_config_t

@ %def event_config_t
@ Output.
<<Events: event config: TBP>>=
  procedure :: write => event_config_write
<<Events: procedures>>=
  subroutine event_config_write (object, unit, show_expressions)
    class(event_config_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_expressions
    integer :: u
    u = given_output_unit (unit)
    write (u, "(3x,A,L1)")  "Unweighted         = ", object%unweighted
    write (u, "(3x,A,A)")   "Normalization      = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A)", advance="no")  "Helicity handling  = "
    select case (object%factorization_mode)
    case (FM_IGNORE_HELICITY)
       write (u, "(A)")  "drop"
    case (FM_SELECT_HELICITY)
       write (u, "(A)")  "select"
    case (FM_FACTOR_HELICITY)
       write (u, "(A)")  "factorize"
    end select
    write (u, "(3x,A,L1)")  "Keep correlations  = ", object%keep_correlations
    if (object%safety_factor /= 1) then
       write (u, "(3x,A," // FMT_12 // ")")  &
            "Safety factor      = ", object%safety_factor
    end if
    if (present (show_expressions)) then
       if (show_expressions) then
          if (allocated (object%ef_selection)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event selection expression:"
             call object%ef_selection%write (u)
          end if
          if (allocated (object%ef_reweight)) then
             call write_separator (u)
             write (u, "(3x,A)") "Event reweighting expression:"
             call object%ef_reweight%write (u)
          end if
          if (allocated (object%ef_analysis)) then
             call write_separator (u)
             write (u, "(3x,A)") "Analysis expression:"
             call object%ef_analysis%write (u)
          end if
       end if
    end if
  end subroutine event_config_write
  
@ %def event_config_write
@
\subsection{The event type}
This is the concrete implementation of the [[generic_event_t]] core
that is defined above in the [[event_base]] module.  The core manages
the main (dressed) particle set pointer and the current values for
weights and sqme.  The implementation adds configuration data,
expressions, process references, and event transforms.

Each event refers to a single elementary process.  This process may be
dressed by a shower, a decay chain etc.  We maintain pointers to a
process instance.

A list of event transforms (class [[evt_t]]) transform the connected
interactions of the process instance into the final particle set.  In
this list, the first transform is always the trivial one, which just
factorizes the process instance.  Subsequent transforms may apply
decays, etc.  The [[particle_set]] pointer identifies the particle set
that we want to be analyzed and returned by the event, usually the
last one.

Squared matrix element and weight values: when reading events from
file, the [[ref]] value is the number in the file, while the [[prc]]
value is the number that we calculate from the momenta in the file,
possibly with different parameters.  When generating events the first
time, or if we do not recalculate, the numbers should coincide.
Furthermore, the array of [[alt]] values is copied from an array of
alternative event records.  These values should represent calculated
values.

The [[sqme]] and [[weight]] values mirror corresponding values in the
[[expr]] subobject.  The idea is that when generating or reading
events, the event record is filled first, then the [[expr]] object
acquires copies.  These copies are used for writing events and as targets
for pointer variables in the analysis expression.

All data that involve user-provided expressions (selection, reweighting,
analysis) are handled by the [[expr]] subobject.  In particular, evaluating
the event-selection expression sets the [[passed]] flag.  Furthermore,
the [[expr]] subobject collects data that can be used in the analysis
and should be written to file, including copies of [[sqme]] and [[weight]].
<<Events: public>>=
  public :: event_t
<<Events: types>>=
  type, extends (generic_event_t) :: event_t
     type(event_config_t) :: config
     type(process_t), pointer :: process => null ()
     type(process_instance_t), pointer :: instance => null ()
     class(rng_t), allocatable :: rng
     integer :: selected_i_mci = 0
     integer :: selected_i_term = 0
     integer :: selected_channel = 0
     logical :: is_complete = .false.
     class(evt_t), pointer :: transform_first => null ()
     class(evt_t), pointer :: transform_last => null ()
     type(event_expr_t) :: expr
     logical :: selection_evaluated = .false.
     logical :: passed = .false.
     real(default), allocatable :: alpha_qcd_forced
     real(default), allocatable :: scale_forced
     real(default) :: reweight = 1
     logical :: analysis_flag = .false.
   contains
   <<Events: event: TBP>>
  end type event_t

@ %def event_t
@ Finalizer: the list of event transforms is deleted iteratively.
<<Events: event: TBP>>=
  procedure :: final => event_final
<<Events: procedures>>=
  subroutine event_final (object)
    class(event_t), intent(inout) :: object
    class(evt_t), pointer :: evt
    if (allocated (object%rng))  call object%rng%final ()
    call object%expr%final ()
    do while (associated (object%transform_first))
       evt => object%transform_first
       object%transform_first => evt%next
       call evt%final ()
       deallocate (evt)
    end do
  end subroutine event_final
    
@ %def event_final
@ Output.

Particle set: this is a pointer to one of the event transforms, so it
should suffice to print the latter.
<<Events: event: TBP>>=
  procedure :: write => event_write
<<Events: procedures>>=
  subroutine event_write (object, unit, show_process, show_transforms, &
       show_decay, verbose, testflag)
    class(event_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: show_process, show_transforms, show_decay
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    logical :: prc, trans, dec, verb
    class(evt_t), pointer :: evt
    integer :: u, i
    u = given_output_unit (unit)
    prc = .true.;  if (present (show_process))  prc = show_process
    trans = .true.;  if (present (show_transforms))  trans = show_transforms
    dec = .true.;  if (present (show_decay))  dec = show_decay
    verb = .false.;  if (present (verbose))  verb = verbose
    call write_separator (u, 2)
    if (object%is_complete) then
       write (u, "(1x,A)")  "Event"
    else
       write (u, "(1x,A)")  "Event [incomplete]"
    end if
    call write_separator (u)
    call object%config%write (u)
    if (object%sqme_ref_is_known () .or. object%weight_ref_is_known ()) then
       call write_separator (u)
    end if
    if (object%sqme_ref_is_known ()) then
       write (u, "(3x,A,ES19.12)") &
            "Squared matrix el. = ", object%get_sqme_ref ()
       if (object%sqme_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A,ES19.12,1x,I0)")  &
                  "alternate sqme   = ", object%get_sqme_alt(i), i
          end do
       end if
    end if
    if (object%weight_ref_is_known ()) then
       write (u, "(3x,A,ES19.12)") &
            "Event weight       = ", object%get_weight_ref ()
       if (object%weight_alt_is_known ()) then
          do i = 1, object%get_n_alt ()
             write (u, "(5x,A,ES19.12,1x,I0)")  &
                  "alternate weight = ", object%get_weight_alt(i), i
          end do
       end if
    end if
    if (object%selected_i_mci /= 0) then
       call write_separator (u)
       write (u, "(3x,A,I0)")  "Selected MCI group = ", object%selected_i_mci
       write (u, "(3x,A,I0)")  "Selected term      = ", object%selected_i_term
       write (u, "(3x,A,I0)")  "Selected channel   = ", object%selected_channel
    end if
    if (object%selection_evaluated) then
       call write_separator (u)
       write (u, "(3x,A,L1)")  "Passed selection   = ", object%passed
       if (object%passed) then
          write (u, "(3x,A,ES19.12)") &
               "Reweighting factor = ", object%reweight
          write (u, "(3x,A,L1)") &
               "Analysis flag      = ", object%analysis_flag
       end if
    end if
    if (associated (object%instance)) then
       if (prc) then
          if (verb) then
             call object%instance%write (u, testflag)
          else
             call object%instance%write_header (u)
          end if
       end if
       if (trans) then
          evt => object%transform_first
          do while (associated (evt))
             select type (evt)
             type is (evt_trivial_t)
                call evt%write (u, verbose = verbose, testflag = testflag)
             type is (evt_decay_t)
                call evt%write (u, show_decay_tree = dec, &
                     show_processes = dec .and. verb, verbose = verb)
             type is (evt_shower_t)
                call evt%write (u)
             end select
             call write_separator (u, 2)
             evt => evt%next
          end do
       else
          call write_separator (u, 2)
       end if
       if (object%expr%subevt_filled) then
          call object%expr%write (u, pacified = testflag)
          call write_separator (u, 2)
       end if
    else
       call write_separator (u, 2)
       write (u, "(1x,A)")  "Process instance: [undefined]"
       call write_separator (u, 2)
    end if
  end subroutine event_write

@ %def event_write
@
\subsection{Initialization}
Initialize: set configuration parameters, using a variable list.  We
do not call this [[init]], because this method name will be used by a type
extension.

The default normalization is [[NORM_SIGMA]], since the default
generation mode is weighted.

For unweighted events, we may want to a apply a safety factor to event
rejection.  (By default, this factor is unity and can be ignored.)

We also allocate the trivial event transform, which is always the
first one.
<<Events: event: TBP>>=
  procedure :: basic_init => event_init
<<Events: procedures>>=
  subroutine event_init (event, var_list, n_alt)
    class(event_t), intent(out) :: event
    type(var_list_t), intent(in), optional :: var_list
    integer, intent(in), optional :: n_alt
    type(string_t) :: norm_string
    logical :: polarized_events
    if (present (n_alt)) then
       call event%base_init (n_alt)
       call event%expr%init (n_alt)
    else
       call event%base_init (0)
    end if
    if (present (var_list)) then
       event%config%unweighted = var_list%get_lval (&
            var_str ("?unweighted"))
       norm_string = var_list%get_sval (&
            var_str ("$sample_normalization"))
       event%config%norm_mode = &
            event_normalization_mode (norm_string, event%config%unweighted)
       polarized_events = &
            var_list%get_lval (var_str ("?polarized_events"))
       if (polarized_events) then
          event%config%factorization_mode = FM_SELECT_HELICITY
       else
          event%config%factorization_mode = FM_IGNORE_HELICITY
       end if
       if (event%config%unweighted) then
          event%config%safety_factor = var_list%get_rval (&
               var_str ("safety_factor"))
       end if
    else
       event%config%norm_mode = NORM_SIGMA
    end if
    allocate (evt_trivial_t :: event%transform_first)
    event%transform_last => event%transform_first
  end subroutine event_init
    
@ %def event_init
@ Set the [[sigma]] and [[n]] values in the configuration record that
determine non-standard event normalizations.  If these numbers are not
set explicitly, the default value for both is unity, and event
renormalization has no effect.
<<Events: event: TBP>>=
  procedure :: set_sigma => event_set_sigma
  procedure :: set_n => event_set_n
<<Events: procedures>>=
  elemental subroutine event_set_sigma (event, sigma)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: sigma
    event%config%sigma = sigma
  end subroutine event_set_sigma

  elemental subroutine event_set_n (event, n)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: n
    event%config%n = n
  end subroutine event_set_n
  
@ %def event_set_n
@ Append an event transform (decays, etc.).  The transform is not yet
connected to a process.  The transform is then considered to belong to
the event object, and will be finalized together with it.  The
original pointer is removed.

We can assume that the trivial transform is already present in the
event object, at least.
<<Events: event: TBP>>=
  procedure :: import_transform => event_import_transform
<<Events: procedures>>=
  subroutine event_import_transform (event, evt)
    class(event_t), intent(inout) :: event
    class(evt_t), intent(inout), pointer :: evt
    event%transform_last%next => evt
    evt%previous => event%transform_last
    event%transform_last => evt
    evt => null ()
  end subroutine event_import_transform
    
@ %def event_import_transform
@
We link the event to an existing process instance.  This
includes the variable list, which is linked to the process variable
list.  Note that this is not necessarily identical to the variable
list used for event initialization.

The variable list will contain pointers to [[event]] subobjects, therefore the
[[target]] attribute.

Once we have a process connected, we can use it to obtain an event
generator instance.

The model and process stack may be needed by event transforms.  The
current model setting may be different from the model in the process
(regarding unstable particles, etc.).  The process stack can be used
for assigning extra processes that we need for the event transforms.
<<Events: event: TBP>>=
  procedure :: connect => event_connect
<<Events: procedures>>=
  subroutine event_connect (event, process_instance, model, process_stack)
    class(event_t), intent(inout), target :: event
    type(process_instance_t), intent(in), target :: process_instance
    class(model_data_t), intent(in), target :: model
    type(process_stack_t), intent(in), optional :: process_stack
    type(string_t) :: id
    integer :: num_id
    class(evt_t), pointer :: evt
    event%process => process_instance%process
    event%instance => process_instance
    id = event%process%get_id ()
    if (id /= "")  call event%expr%set_process_id (id)
    num_id = event%process%get_num_id ()
    if (num_id /= 0)  call event%expr%set_process_num_id (num_id)
    call event%expr%setup_vars (event%process%get_sqrts ())
    call event%expr%link_var_list (event%process%get_var_list_ptr ())
    call event%process%make_rng (event%rng)
    evt => event%transform_first
    do while (associated (evt))
       call evt%connect (process_instance, model, process_stack)
       evt => evt%next
    end do
  end subroutine event_connect

@ %def event_connect
@ Set the parse nodes for the associated expressions, individually.  The
parse-node pointers may be null.
<<Events: event: TBP>>=
  procedure :: set_selection => event_set_selection
  procedure :: set_reweight => event_set_reweight
  procedure :: set_analysis => event_set_analysis
<<Events: procedures>>=
  subroutine event_set_selection (event, ef_selection)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_selection
    allocate (event%config%ef_selection, source = ef_selection)
  end subroutine event_set_selection

  subroutine event_set_reweight (event, ef_reweight)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_reweight
    allocate (event%config%ef_reweight, source = ef_reweight)
  end subroutine event_set_reweight

  subroutine event_set_analysis (event, ef_analysis)
    class(event_t), intent(inout) :: event
    class(expr_factory_t), intent(in) :: ef_analysis
    allocate (event%config%ef_analysis, source = ef_analysis)
  end subroutine event_set_analysis
  
@ %def event_set_selection
@ %def event_set_reweight
@ %def event_set_analysis
@ Create evaluation trees from the parse trees.  The [[target]] attribute is
required because the expressions contain pointers to event subobjects.
<<Events: event: TBP>>=
  procedure :: setup_expressions => event_setup_expressions
<<Events: procedures>>=
  subroutine event_setup_expressions (event)
    class(event_t), intent(inout), target :: event
    call event%expr%setup_selection (event%config%ef_selection)
    call event%expr%setup_analysis (event%config%ef_analysis)
    call event%expr%setup_reweight (event%config%ef_reweight)
  end subroutine event_setup_expressions
  
@ %def event_setup_expressions
@
\subsection{Evaluation}
To fill the [[particle_set]], i.e., the event record proper, we have
to apply all event transforms in order.  The last transform should
fill its associated particle set, factorizing the state matrix
according to the current settings.  There are several parameters
in the event configuration that control this.

We always fill the particle set for the first transform (the hard
process) and the last transform, if different from the first (the
fully dressed process).

Each event transform is an event generator of its own.  We choose to
generate an \emph{unweighted} event for each of them, even if the master
event is assumed to be weighted.  Thus, the overall event weight is
the one of the hard process only.  (There may be more options in future
extensions.)

We can generate the two random numbers that the factorization needs.
For testing purpose, we allow for providing them explicitly, as an option.
<<Events: event: TBP>>=
  procedure :: evaluate_transforms => event_evaluate_transforms
<<Events: procedures>>=
  subroutine event_evaluate_transforms (event, r)
    class(event_t), intent(inout) :: event
    real(default), dimension(:), intent(in), optional :: r
    class(evt_t), pointer :: evt
    integer :: i_term
    call event%discard_particle_set ()
    call event%check ()
    if (event%instance%is_complete_event ()) then
       call event%instance%select_i_term (i_term)
       event%selected_i_term = i_term
       evt => event%transform_first
       do while (associated (evt))
          call evt%prepare_new_event &
               (event%selected_i_mci, event%selected_i_term)
          evt => evt%next
       end do
       evt => event%transform_first
       do while (associated (evt))
          call evt%generate_unweighted ()
          if (signal_is_pending ())  return
          call evt%make_particle_set (event%config%factorization_mode, &
               event%config%keep_correlations)
          if (signal_is_pending ())  return
          if (.not. evt%particle_set_exists) exit
          evt => evt%next
       end do
       evt => event%transform_last
       if (associated (evt) .and. evt%particle_set_exists) then
          call event%link_particle_set (evt%particle_set)
       end if
    end if
  end subroutine event_evaluate_transforms
    
@ %def event_evaluate_transforms
@
Evaluate the event-related expressions, given a valid
[[particle_set]].  If [[update_sqme]] is set, we use the process
instance for the [[sqme_prc]] value.  The [[sqme_ref]] value is
always taken from the event record.

Note: without the explicit [[particle_set]] pointer, some gfortran 4.8
version corrupts its memory.
<<Events: event: TBP>>=
  procedure :: evaluate_expressions => event_evaluate_expressions
<<Events: procedures>>=
  subroutine event_evaluate_expressions (event)
    class(event_t), intent(inout) :: event
    type(particle_set_t), pointer :: particle_set
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       call event%expr%fill_subevt (particle_set)
    end if
    if (event%weight_ref_is_known ()) then
       call event%expr%set (weight_ref = event%get_weight_ref ())
    end if
    if (event%weight_prc_is_known ()) then
       call event%expr%set (weight_prc = event%get_weight_prc ())
    end if
    if (event%excess_prc_is_known ()) then
       call event%expr%set (excess_prc = event%get_excess_prc ())
    end if
    if (event%sqme_ref_is_known ()) then
       call event%expr%set (sqme_ref = event%get_sqme_ref ())
    end if
    if (event%sqme_prc_is_known ()) then
       call event%expr%set (sqme_prc = event%get_sqme_prc ())
    end if
    if (event%has_valid_particle_set ()) then
       call event%expr%evaluate &
            (event%passed, event%reweight, event%analysis_flag)
       event%selection_evaluated = .true.
    end if
  end subroutine event_evaluate_expressions
  
@ %def event_evaluate_expressions
@ Report the result of the [[selection]] evaluation.
<<Events: event: TBP>>=
  procedure :: passed_selection => event_passed_selection
<<Events: procedures>>=
  function event_passed_selection (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    flag = event%passed
  end function event_passed_selection
  
@ %def event_passed_selection
@ Set alternate sqme and weight arrays.  This should be merged with
the previous routine, if the expressions are allowed to refer to these
values.
<<Events: event: TBP>>=
  procedure :: store_alt_values => event_store_alt_values
<<Events: procedures>>=
  subroutine event_store_alt_values (event)
    class(event_t), intent(inout) :: event
    if (event%weight_alt_is_known ()) then
       call event%expr%set (weight_alt = event%get_weight_alt ())
    end if
    if (event%sqme_alt_is_known ()) then
       call event%expr%set (sqme_alt = event%get_sqme_alt ())
    end if
  end subroutine event_store_alt_values
  
@ %def event_store_alt_values
@
\subsection{Reset to empty state}
Applying this, current event contents are marked as incomplete but
are not deleted.  In particular, the initialization is kept.
<<Events: event: TBP>>=
  procedure :: reset => event_reset
<<Events: procedures>>=
  subroutine event_reset (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%base_reset ()
    event%selected_i_mci = 0
    event%selected_i_term = 0
    event%selected_channel = 0
    event%is_complete = .false.
    call event%expr%reset ()
    event%selection_evaluated = .false.
    event%passed = .false.
    event%analysis_flag = .false.
    if (associated (event%instance)) then
       call event%instance%reset (reset_mci = .true.)
    end if
    if (allocated (event%alpha_qcd_forced))  deallocate (event%alpha_qcd_forced)
    if (allocated (event%scale_forced))  deallocate (event%scale_forced)
    evt => event%transform_first
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_reset
  
@ %def event_reset
@
\subsection{Squared Matrix Element and Weight}
Transfer the result of the process instance calculation to the
event record header.
<<Events: event: TBP>>=
  procedure :: import_instance_results => event_import_instance_results
<<Events: procedures>>=
  subroutine event_import_instance_results (event)
    class(event_t), intent(inout) :: event
    if (associated (event%instance)) then
       if (event%instance%has_evaluated_trace ()) then
          call event%set ( &
               sqme_prc = event%instance%get_sqme (), &
               weight_prc = event%instance%get_weight (), &
               excess_prc = event%instance%get_excess () &
               )
       end if
    end if
  end subroutine event_import_instance_results
  
@ %def event_import_instance_results
@ Duplicate the instance result / the reference result in the event
record.
<<Events: event: TBP>>=
  procedure :: accept_sqme_ref => event_accept_sqme_ref
  procedure :: accept_sqme_prc => event_accept_sqme_prc
  procedure :: accept_weight_ref => event_accept_weight_ref
  procedure :: accept_weight_prc => event_accept_weight_prc
<<Events: procedures>>=
  subroutine event_accept_sqme_ref (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_ref_is_known ()) then
       call event%set (sqme_prc = event%get_sqme_ref ())
    end if
  end subroutine event_accept_sqme_ref
  
  subroutine event_accept_sqme_prc (event)
    class(event_t), intent(inout) :: event
    if (event%sqme_prc_is_known ()) then
       call event%set (sqme_ref = event%get_sqme_prc ())
    end if
  end subroutine event_accept_sqme_prc
  
  subroutine event_accept_weight_ref (event)
    class(event_t), intent(inout) :: event
    if (event%weight_ref_is_known ()) then
       call event%set (weight_prc = event%get_weight_ref ())
    end if
  end subroutine event_accept_weight_ref
  
  subroutine event_accept_weight_prc (event)
    class(event_t), intent(inout) :: event
    if (event%weight_prc_is_known ()) then
       call event%set (weight_ref = event%get_weight_prc ())
    end if
  end subroutine event_accept_weight_prc
  
@ %def event_accept_sqme_ref
@ %def event_accept_sqme_prc
@ %def event_accept_weight_ref
@ %def event_accept_weight_prc
@ Update the weight normalization, just after generation.  Unweighted
and weighted events are generated with a different default
normalization.  The intended normalization is stored in the
configuration record.
<<Events: event: TBP>>=
  procedure :: update_normalization => event_update_normalization
<<Events: procedures>>=
  subroutine event_update_normalization (event, mode_ref)
    class(event_t), intent(inout) :: event
    integer, intent(in), optional :: mode_ref
    integer :: mode_old
    real(default) :: weight, excess
    if (present (mode_ref)) then
       mode_old = mode_ref
    else if (event%config%unweighted) then
       mode_old = NORM_UNIT
    else
       mode_old = NORM_SIGMA
    end if
    weight = event%get_weight_prc ()
    call event_normalization_update (weight, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_weight_prc (weight)
    excess = event%get_excess_prc ()
    call event_normalization_update (excess, &
         event%config%sigma, event%config%n, &
         mode_new = event%config%norm_mode, &
         mode_old = mode_old)
    call event%set_excess_prc (excess)
  end subroutine event_update_normalization
  
@ %def event_update_normalization
@
The event is complete if it has a particle set plus valid entries for
the sqme and weight values.
<<Events: event: TBP>>=
  procedure :: check => event_check
<<Events: procedures>>=
  subroutine event_check (event)
    class(event_t), intent(inout) :: event
    event%is_complete = event%has_valid_particle_set () &
         .and. event%sqme_ref_is_known () &
         .and. event%sqme_prc_is_known () &
         .and. event%weight_ref_is_known () &
         .and. event%weight_prc_is_known ()
    if (event%get_n_alt () /= 0) then
       event%is_complete = event%is_complete &
            .and. event%sqme_alt_is_known () &
            .and. event%weight_alt_is_known ()
    end if
  end subroutine event_check
  
@ %def event_check
@ 
@
\subsection{Generation}
Assuming that we have a valid process associated to the event, we
generate an event.  We complete the event data, then factorize the
spin density matrix and transfer it to the particle set.

When done, we retrieve squared matrix element and weight.  In case of
explicit generation, the reference values coincide with the process
values, so we [[accept]] the latter.

The explicit random number argument [[r]] should be generated by a
random-number generator.  It is taken for the factorization algorithm,
bypassing the event-specific random-number generator.  This is useful
for deterministic testing.
<<Events: event: TBP>>=
  procedure :: generate => event_generate
<<Events: procedures>>=
  subroutine event_generate (event, i_mci, r)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci
    real(default), dimension(:), intent(in), optional :: r
    call event%reset ()
    event%selected_i_mci = i_mci
    if (event%config%unweighted) then
       call event%process%generate_unweighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
       call event%instance%normalize_weight ()
    else
       call event%process%generate_weighted_event (event%instance, i_mci)
       if (signal_is_pending ()) return
       call event%instance%evaluate_event_data ()
    end if
    event%selected_channel = event%instance%get_channel ()
    call event%import_instance_results ()
    call event%accept_sqme_prc ()
    call event%update_normalization ()
    call event%accept_weight_prc ()
    call event%evaluate_transforms (r)
    if (signal_is_pending ())  return
    call event%check ()
  end subroutine event_generate
  
@ %def event_generate
@ Get a copy of the particle set belonging to the hard process.
<<Events: event: TBP>>=
  procedure :: get_hard_particle_set => event_get_hard_particle_set
<<Events: procedures>>=
  subroutine event_get_hard_particle_set (event, pset)
    class(event_t), intent(in) :: event
    type(particle_set_t), intent(out) :: pset
    class(evt_t), pointer :: evt
    evt => event%transform_first
    pset = evt%particle_set
  end subroutine event_get_hard_particle_set
    
@ %def event_get_hard_particle_set
@
\subsection{Recovering an event}
Select MC group, term, and integration channel.
<<Events: event: TBP>>=
  procedure :: select => event_select
<<Events: procedures>>=
  subroutine event_select (event, i_mci, i_term, channel)
    class(event_t), intent(inout) :: event
    integer, intent(in) :: i_mci, i_term, channel
    if (associated (event%instance)) then
       event%selected_i_mci = i_mci
       event%selected_i_term = i_term
       event%selected_channel = channel
    else
       call msg_bug ("Event: select term: process instance undefined")
    end if
  end subroutine event_select

@ %def event_select
@ 
Copy a particle set into the event record.

We deliberately use the first (the trivial) transform for this, i.e.,
the hard process.  The event reader may either read in the transformed
event separately, or apply all event
transforms to the hard particle set to (re)generate a fully dressed
event.

Since this makes all subsequent event transforms invalid, we call
[[reset]] on them.
<<Events: event: TBP>>=
  procedure :: set_hard_particle_set => event_set_hard_particle_set
<<Events: procedures>>=
  subroutine event_set_hard_particle_set (event, particle_set)
    class(event_t), intent(inout) :: event
    type(particle_set_t), intent(in) :: particle_set
    class(evt_t), pointer :: evt
    evt => event%transform_first
    call evt%set_particle_set (particle_set, &
         event%selected_i_mci, event%selected_i_term)
    call event%link_particle_set (evt%particle_set)
    evt => evt%next
    do while (associated (evt))
       call evt%reset ()
       evt => evt%next
    end do
  end subroutine event_set_hard_particle_set

@ %def event_set_hard_particle_set
@
Set the $\alpha_s$ value that should be used in a recalculation.  This should
be called only if we explicitly want to override the QCD setting of the
process core.
<<Events: event: TBP>>=
  procedure :: set_alpha_qcd_forced => event_set_alpha_qcd_forced
<<Events: procedures>>=
  subroutine event_set_alpha_qcd_forced (event, alpha_qcd)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: alpha_qcd
    if (allocated (event%alpha_qcd_forced)) then
       event%alpha_qcd_forced = alpha_qcd
    else
       allocate (event%alpha_qcd_forced, source = alpha_qcd)
    end if
  end subroutine event_set_alpha_qcd_forced
  
@ %def event_set_alpha_qcd_forced
@
Analogously, for the common scale.  This forces also renormalization and
factorization scale.
<<Events: event: TBP>>=
  procedure :: set_scale_forced => event_set_scale_forced
<<Events: procedures>>=
  subroutine event_set_scale_forced (event, scale)
    class(event_t), intent(inout) :: event
    real(default), intent(in) :: scale
    if (allocated (event%scale_forced)) then
       event%scale_forced = scale
    else
       allocate (event%scale_forced, source = scale)
    end if
  end subroutine event_set_scale_forced
  
@ %def event_set_scale_forced
@
Here we try to recover an event from the [[particle_set]] subobject
and recalculate the structure functions and matrix elements.  We
have the appropriate [[process]] object and an initialized
[[process_instance]] at hand, so beam and configuration data are
known.  From the [[particle_set]], we get the momenta.

The quantum-number information may be incomplete, e.g., helicity
information may be partial or absent.  We recover the event just from
the momentum configuration.

We do not transfer the matrix element from the process instance to the
event record, as we do when generating an event.  The event record may
contain the matrix element as read from file, and the current
calculation may use different parameters.  We thus can compare old and
new values.

The event [[weight]] may also be known already.  If yes, we pass it to the
[[evaluate_event_data]] procedure.  It should already be normalized.  If we
have an [[weight_factor]] value, we obtain the event weight by multiplying the
computed [[sqme]] by this factor.  Otherwise, we make use of the MCI setup
(which should be valid then) to compute the event weight, and we should
normalize the result just as when generating events.

Evaluating event expressions must also be done separately.
<<Events: event: TBP>>=
  procedure :: recalculate => event_recalculate
<<Events: procedures>>=
  subroutine event_recalculate &
       (event, update_sqme, weight_factor, recover_beams)
    class(event_t), intent(inout) :: event
    logical, intent(in) :: update_sqme
    real(default), intent(in), optional :: weight_factor
    logical, intent(in), optional :: recover_beams
    type(particle_set_t), pointer :: particle_set
    integer :: i_mci, i_term, channel
    if (event%has_valid_particle_set ()) then
       particle_set => event%get_particle_set_ptr ()
       i_mci = event%selected_i_mci
       i_term = event%selected_i_term
       channel = event%selected_channel
       if (i_mci == 0 .or. i_term == 0 .or. channel == 0) then
          call msg_bug ("Event: recalculate: undefined selection parameters")
       end if
       call event%instance%choose_mci (i_mci)
       call event%instance%set_trace (particle_set, i_term, recover_beams)
       if (allocated (event%alpha_qcd_forced)) then
          call event%instance%set_alpha_qcd_forced &
               (i_term, event%alpha_qcd_forced)
       end if
       call event%instance%recover (channel, i_term, update_sqme, &
            event%scale_forced) 
       if (signal_is_pending ())  return
       if (update_sqme .and. present (weight_factor)) then
          call event%instance%evaluate_event_data &
               (weight = event%instance%get_sqme () * weight_factor)
       else if (event%weight_ref_is_known ()) then
          call event%instance%evaluate_event_data &
               (weight = event%get_weight_ref ())
       else
          call event%process%recover_event (event%instance, i_term)
          if (signal_is_pending ())  return
          call event%instance%evaluate_event_data ()
          if (event%config%unweighted) then
             call event%instance%normalize_weight ()
          end if
       end if
       if (signal_is_pending ())  return
       if (update_sqme) then
          call event%import_instance_results ()
       else
          call event%accept_sqme_ref ()
          call event%accept_weight_ref ()
       end if
    else
       call msg_bug ("Event: can't recalculate, particle set is undefined")
    end if
  end subroutine event_recalculate
  
@ %def event_recalculate
@
\subsection{Access content}
Pointer to the associated process object (the associated model).
<<Events: event: TBP>>=
  procedure :: get_process_ptr => event_get_process_ptr
  procedure :: get_process_instance_ptr => event_get_process_instance_ptr
  procedure :: get_model_ptr => event_get_model_ptr
<<Events: procedures>>=
  function event_get_process_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_t), pointer :: ptr
    ptr => event%process
  end function event_get_process_ptr

  function event_get_process_instance_ptr (event) result (ptr)
    class(event_t), intent(in) :: event
    type(process_instance_t), pointer :: ptr
    ptr => event%instance
  end function event_get_process_instance_ptr

  function event_get_model_ptr (event) result (model)
    class(event_t), intent(in) :: event
    class(model_data_t), pointer :: model
    model => event%process%get_model_ptr ()
  end function event_get_model_ptr

@ %def event_get_process_ptr
@ %def event_get_process_instance_ptr
@ %def event_get_model_ptr
@ Return the current values of indices: the MCI group of components, the term
index (different terms corresponding, potentially, to different effective
kinematics), and the MC integration channel.  The [[i_mci]] call is delegated
to the current process instance.
<<Events: event: TBP>>=
  procedure :: get_i_mci => event_get_i_mci
  procedure :: get_i_term => event_get_i_term
  procedure :: get_channel => event_get_channel
<<Events: procedures>>=
  function event_get_i_mci (event) result (i_mci)
    class(event_t), intent(in) :: event
    integer :: i_mci
    i_mci = event%selected_i_mci
  end function event_get_i_mci
  
  function event_get_i_term (event) result (i_term)
    class(event_t), intent(in) :: event
    integer :: i_term
    i_term = event%selected_i_term
  end function event_get_i_term
  
  function event_get_channel (event) result (channel)
    class(event_t), intent(in) :: event
    integer :: channel
    channel = event%selected_channel
  end function event_get_channel
  
@ %def event_get_i_mci
@ %def event_get_i_term
@ %def event_get_channel
@ This flag tells us whether the event consists just of a hard process
(i.e., holds at most the first, trivial transform), or is a dressed
events with additional transforms.
<<Events: event: TBP>>=
  procedure :: has_transform => event_has_transform
<<Events: procedures>>=
  function event_has_transform (event) result (flag)
    class(event_t), intent(in) :: event
    logical :: flag
    if (associated (event%transform_first)) then
       flag = associated (event%transform_first%next)
    else
       flag = .false.
    end if
  end function event_has_transform
  
@ %def event_has_transform
@ Return the currently selected normalization mode, or alternate
normalization mode.
<<Events: event: TBP>>=
  procedure :: get_norm_mode => event_get_norm_mode
<<Events: procedures>>=
  elemental function event_get_norm_mode (event) result (norm_mode)
    class(event_t), intent(in) :: event
    integer :: norm_mode
    norm_mode = event%config%norm_mode
  end function event_get_norm_mode
  
@ %def event_get_norm_mode
@ Return the kinematical weight, defined as the ratio of event weight
and squared matrix element.
<<Events: event: TBP>>=
  procedure :: get_kinematical_weight => event_get_kinematical_weight
<<Events: procedures>>=
  function event_get_kinematical_weight (event) result (f)
    class(event_t), intent(in) :: event
    real(default) :: f
    if (event%sqme_ref_is_known () .and. event%weight_ref_is_known () &
         .and. event%get_sqme_ref () /= 0) then
       f = event%get_weight_ref () / event%get_sqme_ref ()
    else
       f = 0
    end if
  end function event_get_kinematical_weight
    
@ %def event_get_kinematical_weight
@ Return data used by external event formats.
<<Events: event: TBP>>=
  procedure :: get_index => event_get_index
  procedure :: get_fac_scale => event_get_fac_scale
  procedure :: get_alpha_s => event_get_alpha_s
<<Events: procedures>>=
  function event_get_index (event) result (index)
    class(event_t), intent(in) :: event
    integer :: index
    index = event%expr%index
  end function event_get_index
    
  function event_get_fac_scale (event) result (fac_scale)
    class(event_t), intent(in) :: event
    real(default) :: fac_scale
    fac_scale = event%instance%get_fac_scale (event%selected_i_term)
  end function event_get_fac_scale
    
  function event_get_alpha_s (event) result (alpha_s)
    class(event_t), intent(in) :: event
    real(default) :: alpha_s
    alpha_s = event%instance%get_alpha_s (event%selected_i_term)
  end function event_get_alpha_s
    
@ %def event_get_index
@ %def event_get_fac_scale
@ %def event_get_alpha_s
@
Eliminate numerical noise in the [[subevt]] expression and in the event
transforms (which includes associated process instances).
<<Events: public>>=
  public :: pacify
<<Events: interfaces>>=
  interface pacify
     module procedure pacify_event
  end interface pacify
<<Events: procedures>>=
  subroutine pacify_event (event)
    class(event_t), intent(inout) :: event
    class(evt_t), pointer :: evt
    call event%pacify_particle_set ()
    if (event%expr%subevt_filled)  call pacify (event%expr)
    evt => event%transform_first
    do while (associated (evt))
       select type (evt)
       type is (evt_decay_t);  call pacify (evt)
       end select
       evt => evt%next
    end do
  end subroutine pacify_event
  
@ %def pacify
@
\subsection{Unit tests}
<<Events: public>>=
  public :: events_test
<<Events: tests>>=
  subroutine events_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Events: execute tests>>
  end subroutine events_test
  
@ %def events_test
@
\subsubsection{Empty event record}
<<Events: execute tests>>=
  call test (events_1, "events_1", &
       "empty event record", &
       u, results)
<<Events: tests>>=
  subroutine events_1 (u)
    integer, intent(in) :: u
    type(event_t), target :: event

    write (u, "(A)")  "* Test output: events_1"
    write (u, "(A)")  "*   Purpose: display an empty event object"
    write (u, "(A)")

    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_1"
    
  end subroutine events_1
  
@ %def events_1
@
\subsubsection{Simple event}
<<Events: execute tests>>=
  call test (events_2, "events_2", &
       "generate event", &
       u, results)
<<Events: tests>>=
  subroutine events_2 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_2"
    write (u, "(A)")  "*   Purpose: generate and display an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event"

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process%generate_weighted_event (process_instance, 1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_2"
    
  end subroutine events_2
  
@ %def events_2
@
\subsubsection{Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event from that.

Note: The extra [[particle_set_ptr]] auxiliary is a workaround for
memory corruption in gfortran 4.7.
<<Events: execute tests>>=
  call test (events_4, "events_4", &
       "recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_4 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    type(particle_set_t), pointer :: particle_set_ptr
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_4"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set_ptr => event%get_particle_set_ptr ()
    particle_set = particle_set_ptr

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .true.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Transfer sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%accept_sqme_prc ()
    call event%accept_weight_prc ()
    call event%check ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Reset contents"
    write (u, "(A)")

    call event%reset ()
    event%transform_first%particle_set_exists = .false.
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_4"
    
  end subroutine events_4
  
@ %def events_4
@
\subsubsection{Partially Recovering an event}
Generate an event and store the particle set.  Then reset the event
record, recall the particle set, and recover the event as far as possible
without recomputing the squared matrix element.
<<Events: execute tests>>=
  call test (events_5, "events_5", &
       "partially recover event", &
       u, results)
<<Events: tests>>=
  subroutine events_5 (u)
    integer, intent(in) :: u
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(particle_set_t) :: particle_set
    type(particle_set_t), pointer :: particle_set_ptr
    real(default) :: sqme, weight
    type(model_data_t), target :: model

    write (u, "(A)")  "* Test output: events_5"
    write (u, "(A)")  "*   Purpose: generate and recover an event"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event and save particle set"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)
    
    particle_set_ptr => event%get_particle_set_ptr ()
    particle_set = particle_set_ptr
    sqme = event%get_sqme_ref ()
    weight = event%get_weight_ref ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    write (u, "(A)")
    write (u, "(A)")  "* Recover event from particle set"
    write (u, "(A)")
    
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call event%select (1, 1, 1)
    call event%set_hard_particle_set (particle_set)
    call event%recalculate (update_sqme = .false.)
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Manually set sqme and evaluate expressions"
    write (u, "(A)")
    
    call event%set (sqme_ref = sqme, weight_ref = weight)
    call event%accept_sqme_ref ()
    call event%accept_weight_ref ()
    call event%evaluate_expressions ()
    call event%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call particle_set%final ()

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
!    call model_list%final ()
!    call syntax_model_file_final ()
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_5"
    
  end subroutine events_5
  
@ %def events_5
@
\subsubsection{Decays}
Generate an event with subsequent decays.
<<Events: execute tests>>=
  call test (events_6, "events_6", &
       "decays", &
       u, results)
<<Events: tests>>=
  subroutine events_6 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname1, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    class(evt_t), pointer :: evt_decay
    type(event_t), allocatable, target :: event
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_6"
    write (u, "(A)")  "*   Purpose: generate an event with subsequent decays"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process and decay"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "events_6"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.true., decay=.true.)

    write (u, "(A)")  "* Initialize decay process"

    process => process_stack%get_process_ptr (procname1)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    call process_instance%init_simulation (1)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event transform: decay"

    allocate (evt_decay_t :: evt_decay)
    call evt_decay%connect (process_instance, model, process_stack)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object"
    write (u, "(A)")

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, model)
    call event%import_transform (evt_decay)
    
    call event%write (u, show_decay = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call process_instance%final ()
    deallocate (process_instance)

    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_6"
    
  end subroutine events_6
  
@ %def events_6
@
\subsubsection{Decays}
Generate a decay event with varying options.
<<Events: execute tests>>=
  call test (events_7, "events_7", &
       "decay options", &
       u, results)
<<Events: tests>>=
  subroutine events_7 (u)
    integer, intent(in) :: u
    type(os_data_t) :: os_data
    class(model_data_t), pointer :: model
    type(string_t) :: prefix, procname2
    type(process_library_t), target :: lib
    type(process_stack_t) :: process_stack
    type(process_t), pointer :: process
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: events_7"
    write (u, "(A)")  "*   Purpose: check decay options"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare test process"
    write (u, "(A)")

    call os_data_init (os_data)

    prefix = "events_7"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (lib, process_stack, prefix, os_data, &
         scattering=.false., decay=.true.)

    write (u, "(A)")  "* Generate decay event, default options"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2])

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, helicity-diagonal decay"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], diagonal = .true.)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Generate decay event, isotropic decay, &
         &polarized final state"
    write (u, "(A)")

    process => process_stack%get_process_ptr (procname2)
    model => process%get_model_ptr ()
    call model%set_unstable (25, [procname2], isotropic = .true.)
    call model%set_polarized (6)
    call model%set_polarized (-6)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data (model)
    call process_instance%init_simulation (1)

    call process%generate_weighted_event (process_instance, 1)
    call process_instance%write (u)

    call process_instance%final ()
    deallocate (process_instance)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_stack%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_7"
    
  end subroutine events_7
  
@ %def events_7
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Raw Event I/O}
The raw format is for internal use only.  All data are stored
unformatted, so they can be efficiently be re-read on the same
machine, but not necessarily on another machine.

This module explicitly depends on the [[events]] module which provides the
concrete implementation of [[event_base]].  The other I/O formats
access only the methods that are defined in [[event_base]].
<<[[eio_raw.f90]]>>=
<<File header>>

module eio_raw
  
  use kinds
  use io_units
<<Use strings>>
  use unit_tests
  use diagnostics

  use lorentz
  use variables
  use model_data
  use particles
  use event_base
  use eio_data
  use eio_base
  use events

<<Standard module head>>

<<EIO raw: public>>

<<EIO raw: parameters>>

<<EIO raw: types>>

contains
  
<<EIO raw: procedures>>

<<EIO raw: tests>>

end module eio_raw
@ %def eio_raw
@
\subsection{File Format Version}
This is the current default file version. 
<<EIO raw: parameters>>=
  integer, parameter :: CURRENT_FILE_VERSION = 2

@ %def CURRENT_FILE_VERSION
@ The user may change this number; this should force some
compatibility mode for reading and writing.  In any case, the file
version stored in a event file that we read has to match the expected
file version.

History of version numbers:
\begin{enumerate}
\item
  Format for WHIZARD 2.2.0 to 2.2.3.  No version number stored in the raw file.
\item
  Format from 2.2.4 on.  File contains version number.  The file
  contains the transformed particle set (if applicable) after the
  hard-process particle set.
\end{enumerate}
@
\subsection{Type}
Note the file version number.  The default may be reset during
initialization, which should enforce some compatibility mode.
<<EIO raw: public>>=
  public :: eio_raw_t
<<EIO raw: types>>=
  type, extends (eio_t) :: eio_raw_t
     logical :: reading = .false.
     logical :: writing = .false.
     integer :: unit = 0
     integer :: norm_mode = NORM_UNDEFINED
     real(default) :: sigma = 1
     integer :: n = 1
     integer :: n_alt = 0
     logical :: check = .false.
     integer :: file_version = CURRENT_FILE_VERSION
   contains
   <<EIO raw: eio raw: TBP>>
  end type eio_raw_t
  
@ %def eio_raw_t
@ Output.  This is not the actual event format, but a readable account
of the current object status.
<<EIO raw: eio raw: TBP>>=
  procedure :: write => eio_raw_write
<<EIO raw: procedures>>=
  subroutine eio_raw_write (object, unit)
    class(eio_raw_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Raw event stream:"
    write (u, "(3x,A,L1)")  "Check MD5 sum     = ", object%check
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alternate weights = ", object%n_alt
    end if
    if (object%reading) then
       write (u, "(3x,A,A)")  "Reading from file = ", char (object%filename)
    else if (object%writing) then
       write (u, "(3x,A,A)")  "Writing to file   = ", char (object%filename)
    else
       write (u, "(3x,A)")  "[closed]"
    end if
  end subroutine eio_raw_write
  
@ %def eio_raw_write
@ Finalizer: close any open file.
<<EIO raw: eio raw: TBP>>=
  procedure :: final => eio_raw_final
<<EIO raw: procedures>>=
  subroutine eio_raw_final (object)
    class(eio_raw_t), intent(inout) :: object
    if (object%reading .or. object%writing) then
       write (msg_buffer, "(A,A,A)")  "Events: closing raw file '", &
            char (object%filename), "'"
       call msg_message ()
       close (object%unit)
       object%reading = .false.
       object%writing = .false.
    end if
  end subroutine eio_raw_final
  
@ %def eio_raw_final
@ Set the [[check]] flag which determines whether we compare checksums on input.
<<EIO raw: eio raw: TBP>>=
  procedure :: set_parameters => eio_raw_set_parameters
<<EIO raw: procedures>>=
  subroutine eio_raw_set_parameters (eio, check, version_string, extension)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(in), optional :: check
    type(string_t), intent(in), optional :: version_string
    type(string_t), intent(in), optional :: extension 
    if (present (check))  eio%check = check
    if (present (version_string)) then
       select case (char (version_string))
       case ("", "2.2.4")
          eio%file_version = CURRENT_FILE_VERSION
       case ("2.2")
          eio%file_version = 1
       case default
          call msg_fatal ("Raw event I/O: unsupported version '" &
               // char (version_string) // "'")
          eio%file_version = 0
       end select
    end if
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
  end subroutine eio_raw_set_parameters
    
@ %def eio_raw_set_parameters
@ Initialize event writing.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_out => eio_raw_init_out
<<EIO raw: procedures>>=
  subroutine eio_raw_init_out (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(in), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i
    if (present (extension)) then
       eio%extension  = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    write (msg_buffer, "(A,A,A)")  "Events: writing to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%writing = .true.
    if (present (data)) then
       md5sum_prc = data%md5sum_prc
       md5sum_cfg = data%md5sum_cfg
       eio%norm_mode = data%norm_mode
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
       eio%n_alt = data%n_alt
       if (eio%n_alt > 0) then
          !!! !!! !!! Workaround for gfortran 5.0 ICE
          allocate (md5sum_alt (data%n_alt))
          md5sum_alt = data%md5sum_alt
          !!! allocate (md5sum_alt (data%n_alt), source = data%md5sum_alt) 
       end if
    else
       md5sum_prc = ""
       md5sum_cfg = ""
    end if
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", status = "replace")
    select case (eio%file_version)
    case (2:);  write (eio%unit)  eio%file_version
    end select
    write (eio%unit)  md5sum_prc
    write (eio%unit)  md5sum_cfg
    write (eio%unit)  eio%norm_mode
    write (eio%unit)  eio%n_alt
    do i = 1, eio%n_alt
       write (eio%unit)  md5sum_alt(i)
    end do
    if (present (success))  success = .true.
  end subroutine eio_raw_init_out
    
@ %def eio_raw_init_out
@ Initialize event reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: init_in => eio_raw_init_in
<<EIO raw: procedures>>=
  subroutine eio_raw_init_in (eio, sample, data, success, extension)
    class(eio_raw_t), intent(inout) :: eio
    type(string_t), intent(in) :: sample
    type(event_sample_data_t), intent(inout), optional :: data
    logical, intent(out), optional :: success
    type(string_t), intent(in), optional :: extension
    character(32) :: md5sum_prc, md5sum_cfg
    character(32), dimension(:), allocatable :: md5sum_alt
    integer :: i, file_version
    if (present (success))  success = .true.
    if (present (extension)) then
       eio%extension = extension
    else
       eio%extension = "evx"
    end if
    eio%filename = sample // "." // eio%extension
    eio%unit = free_unit ()
    if (present (data)) then
       eio%sigma = data%total_cross_section
       eio%n = data%n_evt
    end if
    write (msg_buffer, "(A,A,A)")  "Events: reading from raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    eio%reading = .true.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "read", status = "old")
    select case (eio%file_version)
    case (2:);  read (eio%unit)  file_version
    case default;  file_version = 1
    end select
    if (file_version /= eio%file_version) then
       call msg_error ("Reading event file: raw-file version mismatch.")
       if (present (success))  success = .false.
       return
    else if (file_version /= CURRENT_FILE_VERSION) then
       call msg_warning ("Reading event file: compatibility mode.")
    end if
    read (eio%unit)  md5sum_prc
    read (eio%unit)  md5sum_cfg
    read (eio%unit)  eio%norm_mode
    read (eio%unit)  eio%n_alt
    if (present (data)) then
       if (eio%n_alt /= data%n_alt) then
          if (present (success))  success = .false. !
          return
       end if
    end if
    allocate (md5sum_alt (eio%n_alt))
    do i = 1, eio%n_alt
       read (eio%unit)  md5sum_alt(i)
    end do
    if (present (success)) then
       if (present (data)) then
          if (eio%check) then
             if (data%md5sum_prc /= "") then
                success = success .and. md5sum_prc == data%md5sum_prc
             end if
             if (data%md5sum_cfg /= "") then
                success = success .and. md5sum_cfg == data%md5sum_cfg
             end if
             do i = 1, eio%n_alt
                if (data%md5sum_alt(i) /= "") then
                   success = success .and. md5sum_alt(i) == data%md5sum_alt(i)
                end if
             end do
          else
             call msg_warning ("Reading event file: MD5 sum check disabled")
          end if
       end if
    end if
  end subroutine eio_raw_init_in
    
@ %def eio_raw_init_in
@ Switch from input to output: reopen the file for reading.
<<EIO raw: eio raw: TBP>>=
  procedure :: switch_inout => eio_raw_switch_inout
<<EIO raw: procedures>>=
  subroutine eio_raw_switch_inout (eio, success)
    class(eio_raw_t), intent(inout) :: eio
    logical, intent(out), optional :: success
    write (msg_buffer, "(A,A,A)")  "Events: appending to raw file '", &
         char (eio%filename), "'"
    call msg_message ()
    close (eio%unit, status = "keep")
    eio%reading = .false.
    open (eio%unit, file = char (eio%filename), form = "unformatted", &
         action = "write", position = "append", status = "old")
    eio%writing = .true.
    if (present (success))  success = .true.
  end subroutine eio_raw_switch_inout
  
@ %def eio_raw_switch_inout
@ Output an event.  Write first the event indices, then weight and
squared matrix element, then the particle set.

We always write the particle set of the hard process.  (Note: this
should be reconsidered.)  We do make a physical copy.

On output, we write the [[prc]] values for weight and sqme, since
these are the values just computed.  On input, we store the values as
[[ref]] values.  The caller can then decide whether to recompute
values and thus obtain distinct [[prc]] values, or just accept them.

The [[passed]] flag is not written.  This allow us to apply different
selection criteria upon rereading.
<<EIO raw: eio raw: TBP>>=
  procedure :: output => eio_raw_output
<<EIO raw: procedures>>=
  subroutine eio_raw_output (eio, event, i_prc, reading, passed, pacify)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(in), target :: event
    logical, intent(in), optional :: reading, passed, pacify
    integer, intent(in) :: i_prc
    type(particle_set_t), pointer :: pset
    integer :: i
    if (eio%writing) then
       if (event%has_valid_particle_set ()) then
          select type (event)
          type is (event_t)
             write (eio%unit)  i_prc
             write (eio%unit)  event%get_i_mci ()
             write (eio%unit)  event%get_i_term ()
             write (eio%unit)  event%get_channel ()
             write (eio%unit)  event%expr%weight_prc
             write (eio%unit)  event%expr%excess_prc
             write (eio%unit)  event%expr%sqme_prc
             do i = 1, eio%n_alt
                write (eio%unit)  event%expr%weight_alt(i)
                write (eio%unit)  event%expr%sqme_alt(i)
             end do
             allocate (pset)
             call event%get_hard_particle_set (pset)
             call pset%write_raw (eio%unit)
             call pset%final ()
             deallocate (pset)
             select case (eio%file_version)
             case (2:)
                if (event%has_transform ()) then
                   write (eio%unit)  .true.
                   pset => event%get_particle_set_ptr ()
                   call pset%write_raw (eio%unit)
                else
                   write (eio%unit)  .false.
                end if
             end select
          class default
             call msg_bug ("Event: write raw: defined only for full event_t")
          end select
       else
          call msg_bug ("Event: write raw: particle set is undefined")
       end if
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for writing")
    end if
  end subroutine eio_raw_output

@ %def eio_raw_output
@ Input an event.

Note: the particle set is physically copied.  If there is a
performance issue, we might choose to pointer-assign it instead, with
a different version of [[event%set_hard_particle_set]].
<<EIO raw: eio raw: TBP>>=
  procedure :: input_i_prc => eio_raw_input_i_prc
  procedure :: input_event => eio_raw_input_event
<<EIO raw: procedures>>=
  subroutine eio_raw_input_i_prc (eio, i_prc, iostat)
    class(eio_raw_t), intent(inout) :: eio
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    if (eio%reading) then
       read (eio%unit, iostat = iostat)  i_prc
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_i_prc

  subroutine eio_raw_input_event (eio, event, iostat)
    class(eio_raw_t), intent(inout) :: eio
    class(generic_event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    integer :: i_mci, i_term, channel, i
    real(default) :: weight, excess, sqme
    real(default), dimension(:), allocatable :: weight_alt, sqme_alt
    logical :: has_transform
    type(particle_set_t), pointer :: pset
    class(model_data_t), pointer :: model
    if (eio%reading) then
       select type (event)
       type is (event_t)
          read (eio%unit, iostat = iostat)  i_mci
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  i_term
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  channel
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  weight
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  excess
          if (iostat /= 0)  return
          read (eio%unit, iostat = iostat)  sqme
          if (iostat /= 0)  return
          call event%reset ()
          call event%select (i_mci, i_term, channel)
          if (eio%norm_mode /= NORM_UNDEFINED) then
             call event_normalization_update (weight, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
             call event_normalization_update (excess, &
                  eio%sigma, eio%n, event%get_norm_mode (), eio%norm_mode)
          end if
          call event%set (sqme_ref = sqme, weight_ref = weight, &
               excess_prc = excess)
          if (eio%n_alt /= 0) then
             allocate (sqme_alt (eio%n_alt), weight_alt (eio%n_alt))
             do i = 1, eio%n_alt
                read (eio%unit, iostat = iostat)  weight_alt(i)
                if (iostat /= 0)  return
                read (eio%unit, iostat = iostat)  sqme_alt(i)
                if (iostat /= 0)  return
             end do
             call event%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
          end if
          model => null ()
          if (associated (event%process)) then
             model => event%process%get_model_ptr ()
          end if
          allocate (pset)
          call pset%read_raw (eio%unit, iostat)
          if (iostat /= 0)  return
          if (associated (model))  call pset%set_model (model)
          call event%set_hard_particle_set (pset)
          call pset%final ()
          deallocate (pset)
          select case (eio%file_version)
          case (2:)
             read (eio%unit, iostat = iostat)  has_transform
             if (iostat /= 0)  return
             if (has_transform) then
                allocate (pset)
                call pset%read_raw (eio%unit, iostat)
                if (iostat /= 0)  return
                if (associated (model)) &
                     call pset%set_model (model)
                call event%link_particle_set (pset)
             end if
          end select
       class default
          call msg_bug ("Event: read raw: defined only for full event_t")
       end select
    else
       call eio%write ()
       call msg_fatal ("Raw event file is not open for reading")
    end if
  end subroutine eio_raw_input_event

@ %def eio_raw_input_i_prc
@ %def eio_raw_input_event
@
\subsection{Unit tests}
<<EIO raw: public>>=
  public :: eio_raw_test
<<EIO raw: tests>>=
  subroutine eio_raw_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<EIO raw: execute tests>>
  end subroutine eio_raw_test
  
@ %def eio_raw_test 
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_1, "eio_raw_1", &
       "read and write event contents", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_1 (u)
    use processes
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_1"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize test process"
 
    call model%init_test ()

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()
 
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_1"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate and append another event"
    write (u, "(A)")
    
    call eio%switch_inout ()
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 5)
    call eio%write (u)
    call eio%final ()
    
    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events"
    write (u, "(A)")
    
    call eio%init_in (sample)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/1):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/1):", iostat
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc/2):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event/2):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_1"
    
  end subroutine eio_raw_1
  
@ %def eio_raw_1
@
\subsubsection{Test I/O methods}
We test the implementation of all I/O methods.
<<EIO raw: execute tests>>=
  call test (eio_raw_2, "eio_raw_2", &
       "handle multiple weights", &
       u, results)
<<EIO raw: tests>>=
  subroutine eio_raw_2 (u)
    use processes
    integer, intent(in) :: u
    type(model_data_t), target :: model
    type(var_list_t) :: var_list
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(event_sample_data_t) :: data
    class(eio_t), allocatable :: eio
    integer :: i_prc, iostat
    type(string_t) :: sample

    write (u, "(A)")  "* Test output: eio_raw_2"
    write (u, "(A)")  "*   Purpose: generate and read/write an event"
    write (u, "(A)")  "*            with multiple weights"
    write (u, "(A)")

    call model%init_test ()

    write (u, "(A)")  "* Initialize test process"
 
    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()
 
    call data%init (n_proc = 1, n_alt = 2)

    call var_list_append_log (var_list, var_str ("?unweighted"), .false., &
         intrinsic = .true.)
    call var_list_append_string (var_list, var_str ("$sample_normalization"), &
         var_str ("auto"), intrinsic = .true.)
    call var_list_append_real (var_list, var_str ("safety_factor"), &
         1._default, intrinsic = .true.)

    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate and write an event"
    write (u, "(A)")
 
    sample = "eio_raw_2"
 
    allocate (eio_raw_t :: eio)
    
    call eio%init_out (sample, data)
    call event%generate (1, [0._default, 0._default])
    call event%evaluate_expressions ()
    call event%set (sqme_alt = [2._default, 3._default])
    call event%set (weight_alt = &
         [2 * event%get_weight_ref (), 3 * event%get_weight_ref ()])
    call event%store_alt_values ()
    call event%check ()

    call event%write (u)
    write (u, "(A)")

    call eio%output (event, i_prc = 42)
    call eio%write (u)
    call eio%final ()

    call event%final ()
    deallocate (event)
    call process_instance%final ()
    deallocate (process_instance)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event"
    write (u, "(A)")
    
    call eio%init_in (sample, data)

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%setup_event_data ()
    allocate (event)
    call event%basic_init (var_list, n_alt = 2)
    call event%connect (process_instance, process%get_model_ptr ())
    
    call eio%input_i_prc (i_prc, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (i_prc):", iostat
    call eio%input_event (event, iostat)
    if (iostat /= 0)  write (u, "(A,I0)")  "I/O error (event):", iostat
    call eio%write (u)
    
    write (u, "(A)")
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
 
    call eio%final ()
    deallocate (eio)
 
    call event%final ()
    deallocate (event)
 
    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)
    
    call model%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: eio_raw_2"
    
  end subroutine eio_raw_2
  
@ %def eio_raw_2
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Integration and simulation}

This layer of modules is just below the top-level API.  We lay out specific
data types for integration and simulation and implement the corresponding
algorithms as methods acting on them.  This helps to keep the command-level
implementation concise and simple.

Generic modules for connecting Sindarin with \whizard:
\begin{description}
\item[user\_files]
  Manage files that are accessed by user-written Sindarin code.
\item[rt\_data]
  The main runtime data block, giving access to all features of
  \whizard via contained data structures or pointers.
\item[dispatch]
  Dynamic dispatch for various \whizard\ objects that have multiple
  implementations.  The dispatcher uses data from the [[rt_data]]
  block to decide which path to follow.
\end{description}

More specific modules, the workhorses of \whizard.  These modules use
[[rt_data]] components and the dispatcher.  They define dedicated
object types for bundling lower-level data and procedures that together
provide the desired functionality.
\begin{description}
\item[process\_configurations]
  Interpret process definitions to generate matrix-element
  objects and external code.
\item[compilations]
  Compile, link and access external matrix-element code.
\item[integrations]
  Manage integration runs.
\item[event\_streams]
  Manage external event I/O.
\item[simulations]
  Manage simulation runs.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User-controlled File I/O}

The SINDARIN language includes commands that write output to file (input may
be added later).  We identify files by their name, and manage the unit
internally.  We need procedures for opening, closing, and printing files.

<<[[user_files.f90]]>>=
<<File header>>

module user_files

<<Use strings>>
  use io_units
  use diagnostics
  use ifiles
  use analysis

<<Standard module head>>

<<User files: public>>

<<User files: types>>

<<User files: interfaces>>

contains

<<User files: procedures>>

end module user_files
@ %def user_files
@
\subsection{The file type}
This is a type that describes an open user file and its properties.  The entry
is part of a doubly-linked list.
<<User files: types>>=
  type :: file_t
     private
     type(string_t) :: name
     integer :: unit = -1
     logical :: reading = .false.
     logical :: writing = .false.
     type(file_t), pointer :: prev => null ()
     type(file_t), pointer :: next => null ()
  end type file_t

@ %def file_t
@ The initializer opens the file.
<<User files: procedures>>=
  subroutine file_init (file, name, action, status, position)
    type(file_t), intent(out) :: file
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action, status, position
    file%unit = free_unit ()
    file%name = name
    open (unit = file%unit, file = char (file%name), &
          action = action, status = status, position = position)
    select case (action)
    case ("read")
       file%reading = .true.
    case ("write")
       file%writing = .true.
    case ("readwrite")
       file%reading = .true.    
       file%writing = .true.    
    end select
  end subroutine file_init

@ %def file_init
@ The finalizer closes it.
<<User files: procedures>>=
  subroutine file_final (file)
    type(file_t), intent(inout) :: file
    close (unit = file%unit)
    file%unit = -1
  end subroutine file_final

@ %def file_init
@ Check if a file is open with correct status.
<<User files: procedures>>=
  function file_is_open (file, action) result (flag)
    logical :: flag
    type(file_t), intent(in) :: file
    character(*), intent(in) :: action
    select case (action)
    case ("read")
       flag = file%reading
    case ("write")
       flag = file%writing
    case ("readwrite")
       flag = file%reading .and. file%writing
    case default
       call msg_bug ("Checking file '" // char (file%name) &
            // "': illegal action specifier")
    end select
  end function file_is_open

@ %def file_is_open
@ Write to the file.  Error if in wrong mode.  If there is no string, just
write an empty record.  If there is a string, respect the [[advancing]]
option.
<<User files: procedures>>=
  subroutine file_write_string (file, string, advancing)
    type(file_t), intent(in) :: file
    type(string_t), intent(in), optional :: string
    logical, intent(in), optional :: advancing
    if (file%writing) then
       if (present (string)) then
          if (present (advancing)) then
             if (advancing) then
                write (file%unit, "(A)")  char (string)
             else
                write (file%unit, "(A)", advance="no")  char (string)
             end if
          else
             write (file%unit, "(A)")  char (string)
          end if
       else
          write (file%unit, *)
       end if
    else
       call msg_error ("Writing to file: File '" // char (file%name) &
            // "' is not open for writing.")
    end if
  end subroutine file_write_string

@ %def file_write
@ Write a whole ifile, line by line.
<<User files: procedures>>=
  subroutine file_write_ifile (file, ifile)
    type(file_t), intent(in) :: file
    type(ifile_t), intent(in) :: ifile
    type(line_p) :: line
    call line_init (line, ifile)
    do while (line_is_associated (line))
       call file_write_string (file, line_get_string_advance (line))
    end do
  end subroutine file_write_ifile

@ %def file_write_ifile
@ Write an analysis object (or all objects) to an open file.
<<User files: procedures>>=
  subroutine file_write_analysis (file, tag)
    type(file_t), intent(in) :: file
    type(string_t), intent(in), optional :: tag
    if (file%writing) then
       if (present (tag)) then
          call analysis_write (tag, unit = file%unit)
       else
          call analysis_write (unit = file%unit)
       end if
    else
       call msg_error ("Writing analysis to file: File '" // char (file%name) &
            // "' is not open for writing.")
    end if
  end subroutine file_write_analysis

@ %def file_write_analysis
@
\subsection{The file list}
We maintain a list of all open files and their attributes.  The list must be
doubly-linked because we may delete entries.
<<User files: public>>=
  public :: file_list_t
<<User files: types>>=
  type :: file_list_t
     type(file_t), pointer :: first => null ()
     type(file_t), pointer :: last => null ()
  end type file_list_t

@ %def file_list_t
@ There is no initialization routine, but a finalizer which deletes all:
<<User files: public>>=
  public :: file_list_final
<<User files: procedures>>=
  subroutine file_list_final (file_list)
    type(file_list_t), intent(inout) :: file_list
    type(file_t), pointer :: current
    do while (associated (file_list%first))
       current => file_list%first
       file_list%first => current%next
       call file_final (current)
       deallocate (current)
    end do
    file_list%last => null ()
  end subroutine file_list_final

@ %def file_list_final
@ Find an entry in the list.  Return null pointer on failure.
<<User files: procedures>>=
  function file_list_get_file_ptr (file_list, name) result (current)
    type(file_t), pointer :: current
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    current => file_list%first
    do while (associated (current))
       if (current%name == name)  return
       current => current%next
    end do
  end function file_list_get_file_ptr

@ %def file_list_get_file_ptr
@ Check if a file is open, public version:
<<User files: public>>=
  public :: file_list_is_open
<<User files: procedures>>=
  function file_list_is_open (file_list, name, action) result (flag)
    logical :: flag
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       flag = file_is_open (current, action)
    else
       flag = .false.
    end if
  end function file_list_is_open

@ %def file_list_is_open
@ Append a new file entry, i.e., open this file.  Error if it is
already open.
<<User files: public>>=
  public :: file_list_open
<<User files: procedures>>=
  subroutine file_list_open (file_list, name, action, status, position)
    type(file_list_t), intent(inout) :: file_list
    type(string_t), intent(in) :: name
    character(len=*), intent(in) :: action, status, position
    type(file_t), pointer :: current
    if (.not. associated (file_list_get_file_ptr (file_list, name))) then
       allocate (current)
       call msg_message ("Opening file '" // char (name) // "' for output")
       call file_init (current, name, action, status, position)
       if (associated (file_list%last)) then
          file_list%last%next => current
          current%prev => file_list%last
       else
          file_list%first => current
       end if
       file_list%last => current
    else
       call msg_error ("Opening file: File '" // char (name) &
            // "' is already open.")
    end if
  end subroutine file_list_open

@ %def file_list_open
@ Delete a file entry, i.e., close this file.  Error if it is not open.
<<User files: public>>=
  public :: file_list_close
<<User files: procedures>>=
  subroutine file_list_close (file_list, name)
    type(file_list_t), intent(inout) :: file_list
    type(string_t), intent(in) :: name
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       if (associated (current%prev)) then
          current%prev%next => current%next
       else
          file_list%first => current%next
       end if
       if (associated (current%next)) then
          current%next%prev => current%prev
       else
          file_list%last => current%prev
       end if
       call msg_message ("Closing file '" // char (name) // "' for output")
       call file_final (current)
       deallocate (current)
    else
       call msg_error ("Closing file: File '" // char (name) &
            // "' is not open.")
    end if
  end subroutine file_list_close

@ %def file_list_close
@ Write a string to file.  Error if it is not open.
<<User files: public>>=
  public :: file_list_write
<<User files: interfaces>>=
  interface file_list_write
     module procedure file_list_write_string
     module procedure file_list_write_ifile
  end interface
<<User files: procedures>>=
  subroutine file_list_write_string (file_list, name, string, advancing)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: string
    logical, intent(in), optional :: advancing
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       call file_write_string (current, string, advancing)
    else
       call msg_error ("Writing to file: File '" // char (name) &
            // "'is not open.")
    end if
  end subroutine file_list_write_string

  subroutine file_list_write_ifile (file_list, name, ifile)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(ifile_t), intent(in) :: ifile
    type(line_p) :: line
    type(file_t), pointer :: current
    current => file_list_get_file_ptr (file_list, name)
    if (associated (current)) then
       call file_write_ifile (current, ifile)
    else
       call msg_error ("Writing to file: File '" // char (name) &
            // "'is not open.")
    end if
  end subroutine file_list_write_ifile

@ %def file_list_write
@ Write an analysis object or all objects to data file.  Error if it is not
open.  If the file name is empty, write to standard output.
<<User files: public>>=
  public :: file_list_write_analysis
<<User files: procedures>>=
  subroutine file_list_write_analysis (file_list, name, tag)
    type(file_list_t), intent(in) :: file_list
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: tag
    type(file_t), pointer :: current
    if (name == "") then
       if (present (tag)) then
          call analysis_write (tag)
       else
          call analysis_write
       end if
    else
       current => file_list_get_file_ptr (file_list, name)
       if (associated (current)) then
          call file_write_analysis (current, tag)
       else
          call msg_error ("Writing analysis to file: File '" // char (name) &
               // "' is not open.")
       end if
    end if
  end subroutine file_list_write_analysis

@ %def file_list_write_analysis
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Runtime data}

<<[[rt_data.f90]]>>=
<<File header>>

module rt_data

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use system_dependencies
  use diagnostics
  use pdf_builtin !NODEP!
  use sf_lhapdf !NODEP!
  use os_interface
  use ifiles
  use lexers
  use parser
  use models
  use flavors
  use jets
  use subevents
  use pdg_arrays
  use variables
  use eval_trees
  use polarizations
  use beams
  use process_libraries
  use prclib_stacks
  use prc_core
  use beam_structures
  use user_files
  use process_stacks
  use iterations
  use physics_defs

<<Standard module head>>

<<RT data: public>>

<<RT data: types>>

contains

<<RT data: procedures>>

<<RT data: tests>>

end module rt_data
@ %def rt_data
@
\subsection{Strategy for models and variables}
The program manages its data via a main [[rt_data_t]] object.  During program
flow, various commands create and use local [[rt_data_t]] objects.  Those
transient blocks contain either pointers to global object or local copies
which are deleted after use.

Each [[rt_data_t]] object contains a variable list component.  This lists
holds (local copies of) all kinds of intrinsic or user-defined variables.  The
variable list is linked to the variable list contained in the local process
library.  This, in turn, is linked to the variable list of the [[rt_data_t]]
context, and so on.  

A variable lookup will thus be recursively delegated to the linked variable
lists, until a match is found.  When modifying a variable which is not yet
local, the program creates a local copy and uses this afterwards.  Thus, when
the local [[rt_data_t]] object is deleted, the context value is recovered.

Models are kept in a model list which is separate from the variable list.
Otherwise, they are treated in a similar manner: the local list is linked to
the context model list.  Model lookup is thus recursively delegated.  When a
model or any part of it is modified, the model is copied to the local
[[rt_data_t]] object, so the context model is not modified.  Commands such as
[[integrate]] will create their own copy of the current model (and of the
current variable list) at the point where they are executed.

When a model is encountered for the first time, it is read from file.  The
reading is automatically delegated to the global context.  Thus, this master
copy survives until the main [[rt_data_t]] object is deleted, at program
completion.

If there is a currently active model, its variable list is linked to the main
variable list.  Variable lookups will then start from the model variable
list.  When the current model is switched, the new active model will get this
link instead.  Consequently, a change to the current model is kept as long as
this model has a local copy; it survives local model switches.  On the other
hand, a parameter change in the current model doesn't affect any other model,
even if the parameter name is identical.
@
\subsection{Container for parse nodes}
The runtime data set contains a bunch of parse nodes (chunks of code
that have not been compiled into evaluation trees but saved for later
use).  We collect them here.

This implementation has the useful effect that an assignment between two
objects of this type will establish a pointer-target relationship for
all components.
<<RT data: types>>=
  type :: rt_parse_nodes_t
     type(parse_node_t), pointer :: cuts_lexpr => null ()
     type(parse_node_t), pointer :: scale_expr => null ()     
     type(parse_node_t), pointer :: fac_scale_expr => null ()
     type(parse_node_t), pointer :: ren_scale_expr => null ()     
     type(parse_node_t), pointer :: weight_expr => null ()
     type(parse_node_t), pointer :: selection_lexpr => null ()
     type(parse_node_t), pointer :: reweight_expr => null ()
     type(parse_node_t), pointer :: analysis_lexpr => null ()
     type(parse_node_p), dimension(:), allocatable :: alt_setup
   contains
   <<RT data: rt parse nodes: TBP>>
  end type rt_parse_nodes_t
     
@ %def rt_parse_nodes_t
@ Clear individual components.  The parse nodes are nullified.  No
finalization needed since the pointer targets are part of the global
parse tree.
<<RT data: rt parse nodes: TBP>>=
  procedure :: clear => rt_parse_nodes_clear
<<RT data: procedures>>=
  subroutine rt_parse_nodes_clear (rt_pn, name)
    class(rt_parse_nodes_t), intent(inout) :: rt_pn
    type(string_t), intent(in) :: name
    select case (char (name))
    case ("cuts")
       rt_pn%cuts_lexpr => null ()
    case ("scale")
       rt_pn%scale_expr => null ()
    case ("factorization_scale")
       rt_pn%fac_scale_expr => null ()
    case ("renormalization_scale")
       rt_pn%ren_scale_expr => null ()
    case ("weight")
       rt_pn%weight_expr => null ()
    case ("selection")
       rt_pn%selection_lexpr => null ()
    case ("reweight")
       rt_pn%reweight_expr => null ()
    case ("analysis")
       rt_pn%analysis_lexpr => null ()
    end select
  end subroutine rt_parse_nodes_clear
  
@ %def rt_parse_nodes_clear
@ Output for the parse nodes.
<<RT data: rt parse nodes: TBP>>=
  procedure :: write => rt_parse_nodes_write
<<RT data: procedures>>=
  subroutine rt_parse_nodes_write (object, unit)
    class(rt_parse_nodes_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    call wrt ("Cuts", object%cuts_lexpr)
    call write_separator (u)
    call wrt ("Scale", object%scale_expr)
    call write_separator (u)
    call wrt ("Factorization scale", object%fac_scale_expr)
    call write_separator (u)
    call wrt ("Renormalization scale", object%ren_scale_expr)
    call write_separator (u)
    call wrt ("Weight", object%weight_expr)
    call write_separator (u, 2)
    call wrt ("Event selection", object%selection_lexpr)
    call write_separator (u)
    call wrt ("Event reweighting factor", object%reweight_expr)
    call write_separator (u)
    call wrt ("Event analysis", object%analysis_lexpr)
    if (allocated (object%alt_setup)) then
       call write_separator (u, 2)
       write (u, "(1x,A,':')")  "Alternative setups"
       do i = 1, size (object%alt_setup)
          call write_separator (u)
          call wrt ("Commands", object%alt_setup(i)%ptr)
       end do
    end if
  contains
    subroutine wrt (title, pn)
      character(*), intent(in) :: title
      type(parse_node_t), intent(in), pointer :: pn
      if (associated (pn)) then
         write (u, "(1x,A,':')")  title
         call write_separator (u)
         call parse_node_write_rec (pn, u)
      else
         write (u, "(1x,A,':',1x,A)")  title, "[undefined]"
      end if
    end subroutine wrt
  end subroutine rt_parse_nodes_write
    
@ %def rt_parse_nodes_write
@ Screen output for individual components.  (This should eventually be more
condensed, currently we print the internal representation tree.)
<<RT data: rt parse nodes: TBP>>=
  procedure :: show => rt_parse_nodes_show
<<RT data: procedures>>=
  subroutine rt_parse_nodes_show (rt_pn, name, unit)
    class(rt_parse_nodes_t), intent(in) :: rt_pn
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: unit
    type(parse_node_t), pointer :: pn
    integer :: u
    u = given_output_unit (unit)
    select case (char (name))
    case ("cuts")
       pn => rt_pn%cuts_lexpr
    case ("scale")
       pn => rt_pn%scale_expr
    case ("factorization_scale")
       pn => rt_pn%fac_scale_expr
    case ("renormalization_scale")
       pn => rt_pn%ren_scale_expr
    case ("weight")
       pn => rt_pn%weight_expr
    case ("selection")
       pn => rt_pn%selection_lexpr
    case ("reweight")
       pn => rt_pn%reweight_expr
    case ("analysis")
       pn => rt_pn%analysis_lexpr
    end select
    if (associated (pn)) then
       write (u, "(A,1x,A,1x,A)")  "Expression:", char (name), "(parse tree):"
       call parse_node_write_rec (pn, u)
    else
       write (u, "(A,1x,A,A)")  "Expression:", char (name), ": [undefined]"
    end if
  end subroutine rt_parse_nodes_show
  
@ %def rt_parse_nodes_show
@
\subsection{The data type}
This is a big data container which contains everything that is used and
modified during the command flow.  A local copy of this can be used to
temporarily override defaults.  The data set is transparent.
<<RT data: public>>=
  public :: rt_data_t
<<RT data: types>>=
  type :: rt_data_t
     type(lexer_t), pointer :: lexer => null ()
     type(rt_data_t), pointer :: context => null ()
     type(var_list_t) :: var_list
     type(iterations_list_t) :: it_list
     type(os_data_t) :: os_data
     type(model_list_t) :: model_list
     type(model_t), pointer :: model => null ()
     logical :: model_is_copy = .false.
     type(model_t), pointer :: preload_model => null ()
     type(model_t), pointer :: fallback_model => null ()
     type(model_t), pointer :: radiation_model => null ()
     type(prclib_stack_t) :: prclib_stack
     type(process_library_t), pointer :: prclib => null ()
     type(beam_structure_t) :: beam_structure
     type(rt_parse_nodes_t) :: pn
     type(process_stack_t) :: process_stack
     type(string_t), dimension(:), allocatable :: sample_fmt
     type(file_list_t), pointer :: out_files => null ()
     logical :: quit = .false.
     integer :: quit_code = 0
     type(string_t) :: logfile 
     logical :: nlo_calculation = .false.
     logical, dimension(3) :: active_nlo_components
   contains
   <<RT data: rt data: TBP>>
  end type rt_data_t

@ %def rt_data_t
@
\subsection{Output}
<<RT data: rt data: TBP>>=
  procedure :: write => rt_data_write
<<RT data: procedures>>=
  subroutine rt_data_write (object, unit, vars, pacify)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    type(string_t), dimension(:), intent(in), optional :: vars
    logical, intent(in), optional :: pacify
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A)")  "Runtime data:"
    if (present (vars)) then
       if (size (vars) /= 0) then
          call write_separator (u, 2)
          write (u, "(1x,A)")  "Selected variables:"
          call write_separator (u)
          call object%write_vars (u, vars)
       end if
    else
       call write_separator (u, 2)
       if (associated (object%model)) then
          call object%model%write_var_list (u, follow_link=.true.)
       else
          call var_list_write (object%var_list, u, follow_link=.true.)
       end if
    end if
    if (object%it_list%get_n_pass () > 0) then
       call write_separator (u, 2)
       write (u, "(1x)", advance="no")
       call object%it_list%write (u)
    end if
    if (associated (object%model)) then
       call write_separator (u, 2)
       call object%model%write (u)
    end if
    call object%prclib_stack%write (u)
    call object%beam_structure%write (u)
    call write_separator (u, 2)
    call object%pn%write (u)
    if (allocated (object%sample_fmt)) then
       call write_separator (u)
       write (u, "(1x,A)", advance="no")  "Event sample formats = "
       do i = 1, size (object%sample_fmt)
          if (i > 1)  write (u, "(A,1x)", advance="no")  ","
          write (u, "(A)", advance="no")  char (object%sample_fmt(i))
       end do
       write (u, "(A)")
    end if
    call object%process_stack%write (u, pacify)
    write (u, "(1x,A,1x,L1)")  "quit     :", object%quit
    write (u, "(1x,A,1x,I0)")  "quit_code:", object%quit_code
    call write_separator (u, 2)
    write (u, "(1x,A,1x,A)")   "Logfile  :", "'" // trim (char (object%logfile)) // "'"
    call write_separator (u, 2)
  end subroutine rt_data_write
  
@ %def rt_data_write
@ Write only selected variables.
<<RT data: rt data: TBP>>=
  procedure :: write_vars => rt_data_write_vars
<<RT data: procedures>>=
  subroutine rt_data_write_vars (object, unit, vars)
    class(rt_data_t), intent(in), target :: object
    integer, intent(in), optional :: unit
    type(string_t), dimension(:), intent(in), optional :: vars
    type(var_list_t), pointer :: var_list
    integer :: u, i
    u = given_output_unit (unit)
    if (present (vars)) then
       var_list => object%get_var_list_ptr ()
       do i = 1, size (vars)
          associate (var => vars(i))
            if (var_list%contains (var, follow_link=.true.)) then
               call var_list_write_var (var_list, var, unit = u, &
                    follow_link = .true.)
            end if
          end associate
       end do
    end if
  end subroutine rt_data_write_vars
  
@ %def rt_data_write_vars
@ Write only the model list.
<<RT data: rt data: TBP>>=
  procedure :: write_model_list => rt_data_write_model_list
<<RT data: procedures>>=
  subroutine rt_data_write_model_list (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%model_list%write (u)
  end subroutine rt_data_write_model_list

@ %def rt_data_write_model_list
@ Write only the library stack.
<<RT data: rt data: TBP>>=
  procedure :: write_libraries => rt_data_write_libraries
<<RT data: procedures>>=
  subroutine rt_data_write_libraries (object, unit, libpath)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: libpath
    integer :: u
    u = given_output_unit (unit)
    call object%prclib_stack%write (u, libpath)
  end subroutine rt_data_write_libraries

@ %def rt_data_write_libraries
@ Write only the beam data.
<<RT data: rt data: TBP>>=
  procedure :: write_beams => rt_data_write_beams
<<RT data: procedures>>=
  subroutine rt_data_write_beams (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call object%beam_structure%write (u)
    call write_separator (u, 2)
  end subroutine rt_data_write_beams

@ %def rt_data_write_beams
@ Write only the process and event expressions.
<<RT data: rt data: TBP>>=
  procedure :: write_expr => rt_data_write_expr
<<RT data: procedures>>=
  subroutine rt_data_write_expr (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call write_separator (u, 2)
    call object%pn%write (u)
    call write_separator (u, 2)
  end subroutine rt_data_write_expr
  
@ %def rt_data_write_expr
@ Write only the process stack.
<<RT data: rt data: TBP>>=
  procedure :: write_process_stack => rt_data_write_process_stack
<<RT data: procedures>>=
  subroutine rt_data_write_process_stack (object, unit)
    class(rt_data_t), intent(in) :: object
    integer, intent(in), optional :: unit
    call object%process_stack%write (unit)
  end subroutine rt_data_write_process_stack
  
@ %def rt_data_write_process_stack
@
\subsection{Clear}
The [[clear]] command can remove the contents of various subobjects.
The objects themselves should stay.
<<RT data: rt data: TBP>>=
  procedure :: clear_beams => rt_data_clear_beams
<<RT data: procedures>>=
  subroutine rt_data_clear_beams (global)
    class(rt_data_t), intent(inout) :: global
    call global%beam_structure%final_sf ()
    call global%beam_structure%final_pol ()
    call global%beam_structure%final_mom ()
  end subroutine rt_data_clear_beams
  
@ %def rt_data_clear_beams
@ 
\subsection{Initialization}
Initialize runtime data.  This defines special variables such as
[[sqrts]], and should be done only for the instance that is actually
global.   Local copies will inherit the special variables.

We link the global variable list to the process stack variable list,
so the latter is always available (and kept global).
<<RT data: rt data: TBP>>=
  procedure :: global_init => rt_data_global_init
<<RT data: procedures>>=
  subroutine rt_data_global_init (global, paths, logfile)
    class(rt_data_t), intent(out), target :: global
    type(paths_t), intent(in), optional :: paths
    type(string_t), intent(in), optional :: logfile
    logical, target, save :: known = .true.
    integer :: seed
    real(default), parameter :: real_specimen = 1.
    call os_data_init (global%os_data, paths)
    if (present (logfile)) then
       global%logfile = logfile
    else
       global%logfile = ""
    end if
    allocate (global%out_files)
    call system_clock (seed)
    call var_list_append_log_ptr &
         (global%var_list, var_str ("?logging"), logging, known, &
         intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("seed"), seed, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$model_name"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("process_num_id"), &
         intrinsic=.true.)	  
    call var_list_append_string &
         (global%var_list, var_str ("$method"), var_str ("omega"), &
         intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?report_progress"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$restrictions"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$omega_flags"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?read_color_factors"), .true., &
          intrinsic=.true.)
!!! JRR: WK please check (#529)    
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_cut"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_event_shape"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_obs1"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_obs2"), var_str (""), &
!           intrinsic=.true.)	  
!     call var_list_append_string &
!          (global%var_list, var_str ("$user_procs_sf"), var_str (""), &
!           intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_input"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_spectrum"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?slha_read_decays"), .false., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$library_name"), &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("sqrts"), &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("luminosity"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?sf_trace"), .false., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sf_trace_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?sf_allow_s_mapping"), .true., &
          intrinsic=.true.)
    if (present (paths)) then
       call var_list_append_string &
            (global%var_list, var_str ("$lhapdf_dir"), paths%lhapdfdir, &
             intrinsic=.true.)
    else
       call var_list_append_string &
            (global%var_list, var_str ("$lhapdf_dir"), var_str(""), &
             intrinsic=.true.)
    end if 
    call var_list_append_string &
         (global%var_list, var_str ("$lhapdf_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$lhapdf_photon_file"), var_str (""), &
          intrinsic=.true.)    
    call var_list_append_int &
         (global%var_list, var_str ("lhapdf_member"), 0, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("lhapdf_photon_scheme"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?hoppet_b_matching"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_alpha"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_q_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("isr_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("isr_order"), 3, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?isr_recoil"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_alpha"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_x_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_q_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_e_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("epa_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?epa_recoil"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_x_min"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_pt_max"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("ewa_mass"), 0._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ewa_keep_momentum"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?ewa_keep_energy"), .false., &
          intrinsic=.true.)	  	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_photon1"), .false., &
          intrinsic=.true.)	
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_photon2"), .false., &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_sqrts"), &
          intrinsic=.true.)    	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_generate"), .true., &
          intrinsic=.true.)	    	  
    call var_list_append_log &
         (global%var_list, var_str ("?circe1_map"), .true., &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_mapping_slope"), 2._default, &
          intrinsic=.true.)	
    call var_list_append_real &
         (global%var_list, var_str ("circe1_eps"), 1e-5_default, &
          intrinsic=.true.)	 	  
    call var_list_append_int &
         (global%var_list, var_str ("circe1_ver"), 0, intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("circe1_rev"), 0, intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$circe1_acc"), var_str ("SBAND"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("circe1_chat"), 0, intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?circe2_polarized"), .true., &
          intrinsic=.true.)	 	  
    call var_list_append_string &    
         (global%var_list, var_str ("$circe2_file"), &
          intrinsic=.true.)	 
    call var_list_append_string &    
         (global%var_list, var_str ("$circe2_design"), var_str ("*"), &
          intrinsic=.true.)	 	  
    call var_list_append_string &    
         (global%var_list, var_str ("$beam_events_file"), &
          intrinsic=.true.)	 
    call var_list_append_log &
         (global%var_list, var_str ("?beam_events_warn_eof"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?energy_scan_normalize"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_is_fixed"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_lhapdf"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_pdf_builtin"), .false., &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("alpha_s_order"), 0, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("alpha_s_nf"), 5, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_mz"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?alpha_s_from_lambda_qcd"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("lambda_qcd"), 200.e-3_default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?fatal_beam_decay"), .true., &
          intrinsic=.true.)          
    call var_list_append_log &
         (global%var_list, var_str ("?helicity_selection_active"), .true., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("helicity_selection_threshold"), &
          1E10_default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("helicity_selection_cutoff"), 1000, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$rng_method"), var_str ("tao"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$integration_method"), var_str ("vamp"), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("threshold_calls"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_calls_per_channel"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_calls_per_bin"), 10, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("min_bins"), 3, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("max_bins"), 20, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?stratified"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?use_vamp_equivalences"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_verbose"), .false., &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_global"), &
         .true., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_global_verbose"), &
         .false., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_channels"), &
         .false., intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vamp_history_channels_verbose"), &
         .false., intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("channel_weights_power"), 0.25_default, &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$phs_method"), var_str ("default"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vis_channels"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?check_phs_file"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$phs_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_only"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_threshold_s"), 50._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_threshold_t"), 100._default, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("phs_off_shell"), 2, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("phs_t_channel"), 6, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_e_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_m_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("phs_q_scale"), 10._default, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_keep_nonresonant"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_step_mapping"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_step_mapping_exp"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?phs_s_mapping"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$run_id"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("n_calls_test"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?integration_timer"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?check_grid_file"), .true., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("accuracy_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("error_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("relative_error_goal"), 0._default, &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("error_threshold"), &
         0._default, intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?vis_history"), .true., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?diags"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?diags_color"), .false., &
          intrinsic=.true.)    
    call var_list_append_log &
         (global%var_list, var_str ("?check_event_file"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$event_file_version"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("n_events"), 0, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?unweighted"), .true., &
          intrinsic=.true.)	  
    call var_list_append_real &
         (global%var_list, var_str ("safety_factor"), 1._default, &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?negative_weights"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?keep_beams"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?keep_remnants"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?recover_beams"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?update_event"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?update_sqme"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?update_weight"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?use_alpha_s_from_file"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?use_scale_from_file"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?allow_decays"), .true., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?auto_decays"), .false., &
          intrinsic=.true.)	  
    call var_list_append_int &
         (global%var_list, var_str ("auto_decays_multiplicity"), 2, &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?auto_decays_radiative"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?decay_rest_frame"), .false., &
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?isotropic_decay"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?diagonal_decay"), .false., &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("decay_helicity"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sample"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$sample_normalization"), var_str ("auto"),&
          intrinsic=.true.)	  
    call var_list_append_log &
         (global%var_list, var_str ("?sample_pacify"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?sample_select"), .true., &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_max_tries"), 10000, &
         intrinsic = .true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_split_n_evt"), 0, &
         intrinsic = .true.)
    call var_list_append_int &
         (global%var_list, var_str ("sample_split_index"), 0, &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$rescan_input_format"), var_str ("raw"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?read_raw"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?write_raw"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_raw"), var_str ("evx"), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_default"), var_str ("evt"), &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$debug_extension"), var_str ("debug"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_process"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_transforms"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_decay"), .true., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?debug_verbose"), .true., &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepevt"), var_str ("hepevt"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_ascii_short"), &
          var_str ("short.evt"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_ascii_long"), &
          var_str ("long.evt"), intrinsic=.true.)	 
    call var_list_append_string &
         (global%var_list, var_str ("$extension_athena"), &
          var_str ("athena.evt"), intrinsic=.true.) 
    call var_list_append_string &
          (global%var_list, var_str ("$extension_mokka"), &
           var_str ("mokka.evt"), intrinsic=.true.) 	  
    call var_list_append_string &
         (global%var_list, var_str ("$lhef_version"), var_str ("2.0"), &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$lhef_extension"), var_str ("lhe"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_prc"), .true., &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_ref"), .false., &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?lhef_write_sqme_alt"), .true., &
         intrinsic = .true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lha"), var_str ("lha"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepmc"), var_str ("hepmc"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lcio"), var_str ("slcio"), &
          intrinsic=.true.)    
    call var_list_append_string &
         (global%var_list, var_str ("$extension_stdhep"), var_str ("hep"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_stdhep_up"), &
          var_str ("up.hep"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_hepevt_verb"), &
          var_str ("hepevt.verb"), intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$extension_lha_verb"), &
          var_str ("lha.verb"), intrinsic=.true.)
    call var_list_append_int (global%var_list, &
         var_str ("n_bins"), 20, &
         intrinsic=.true.)
    call var_list_append_log (global%var_list, &
         var_str ("?normalize_bins"), .false., &
         intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$obs_label"), var_str (""), &
         intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$obs_unit"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$title"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$description"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$x_label"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string (global%var_list, &
         var_str ("$y_label"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("graph_width_mm"), 130, &
          intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("graph_height_mm"), 90, &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?y_log"), .false., &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?x_log"), .false., &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("x_min"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("x_max"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("y_min"),  &
          intrinsic=.true.)
    call var_list_append_real &
         (global%var_list, var_str ("y_max"),  &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$gmlcode_bg"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$gmlcode_fg"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_histogram"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_base"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_piecewise"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?fill_curve"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_curve"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_errors"), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?draw_symbols"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$fill_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$draw_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$err_options"), &
          intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$symbol"), &
          intrinsic=.true.)
    call var_list_append_log (global%var_list, &
         var_str ("?analysis_file_only"), .false., &
         intrinsic=.true.)
    call var_list_append_real (global%var_list, &
         var_str ("tolerance"), 0._default, &
          intrinsic=.true.)
    call var_list_append_int (global%var_list, &
         var_str ("checkpoint"), 0, &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?pacify"), .false., &
         intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$out_file"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?out_advance"), .true., &
          intrinsic=.true.)
!!! JRR: WK please check (#542)    
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_custom"), .false., &
!           intrinsic=.true.)
!     call var_list_append_string &
!          (global%var_list, var_str ("$out_comment"), var_str ("# "), &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_header"), .true., &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_yerr"), .true., &
!           intrinsic=.true.)
!     call var_list_append_log &
!          (global%var_list, var_str ("?out_xerr"), .true., &
!           intrinsic=.true.)
    call var_list_append_int (global%var_list, var_str ("real_range"), &
         range (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, var_str ("real_precision"), &
         precision (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_real (global%var_list, var_str ("real_epsilon"), &
         epsilon (real_specimen), intrinsic = .true., locked = .true.)
    call var_list_append_real (global%var_list, var_str ("real_tiny"), &
         tiny (real_specimen), intrinsic = .true., locked = .true.)
    !!! FastJet parameters
    call var_list_append_int (global%var_list, &
         var_str ("kt_algorithm"), &
         kt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("cambridge_algorithm"), &
         cambridge_algorithm, intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("antikt_algorithm"), &
         antikt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("genkt_algorithm"), &
         genkt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("cambridge_for_passive_algorithm"), &
         cambridge_for_passive_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("genkt_for_passive_algorithm"), &
         genkt_for_passive_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ee_kt_algorithm"), &
         ee_kt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ee_genkt_algorithm"), &
         ee_genkt_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("plugin_algorithm"), &
         plugin_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("undefined_jet_algorithm"), &
         undefined_jet_algorithm, &
         intrinsic = .true., locked = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("jet_algorithm"), undefined_jet_algorithm, &
         intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("jet_r"), 0._default, &
         intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?polarized_events"), .false., &
            intrinsic=.true.)
    !!! Default settings for shower
    call var_list_append_log &
         (global%var_list, var_str ("?allow_shower"), .true., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_fsr_active"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_use_PYTHIA6_shower"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_PYTHIA_verbose"), .false., &
            intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$ps_PYTHIA_PYGIVE"), var_str (""), &
          intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_active"), .false., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_mass_cutoff"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_fsr_lambda"), 0.29_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, &
         var_str ("ps_isr_lambda"), 0.29_default, intrinsic = .true.)
    call var_list_append_int (global%var_list, &
         var_str ("ps_max_n_flavors"), 5, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_alpha_s_running"), .true., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_fsr_alpha_s_running"), .true., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str ("ps_fixed_alpha_s"), &
         0._default, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_pt_ordered"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ps_isr_angular_ordered"), .true., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_primordial_kt_width"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_primordial_kt_cutoff"), 5._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_z_cutoff"), 0.999_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_minenergy"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("ps_isr_tscalefactor"), 1._default, intrinsic = .true.)
    call var_list_append_log (global%var_list, var_str &
         ("?ps_isr_only_onshell_emitted_partons"), .false., intrinsic=.true.)
    !!! Default settings for hadronization
    call var_list_append_log &
         (global%var_list, var_str ("?allow_hadronization"), .true., &
            intrinsic=.true.)    
    call var_list_append_log &
         (global%var_list, var_str ("?hadronization_active"), .false., &
            intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$hadronization_method"), &
         var_str ("PYTHIA6"), intrinsic = .true.)
    !!! Setting for mlm matching
    call var_list_append_log &
         (global%var_list, var_str ("?mlm_matching"), .false., &
            intrinsic=.true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Qcut_ME"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Qcut_PS"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ptmin"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_etamax"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Rmin"), 0._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Emin"), 0._default, intrinsic = .true.)
    call var_list_append_int (global%var_list, var_str &
         ("mlm_nmaxMEjets"), 0, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ETclusfactor"), 0.2_default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_ETclusminE"), 5._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_etaclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Rclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_real (global%var_list, var_str &
         ("mlm_Eclusfactor"), 1._default, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?ckkw_matching"), .false., &
            intrinsic=.true.)
    call var_list_append_log &
        (global%var_list, var_str ("?powheg_matching"), &
         .false., intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?muli_active"), .false., &
            intrinsic=.true.)
    call var_list_append_string &
         (global%var_list, var_str ("$pdf_builtin_set"), var_str ("CTEQ6L"), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?omega_openmp"), &
         openmp_is_active (), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?openmp_is_active"), &
         openmp_is_active (), &
         locked=.true., intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("openmp_num_threads_default"), &
         openmp_get_default_max_threads (), &
         locked=.true., intrinsic=.true.)
    call var_list_append_int &
         (global%var_list, var_str ("openmp_num_threads"), &        
         openmp_get_max_threads (), &
         intrinsic=.true.)
    call var_list_append_log &
         (global%var_list, var_str ("?openmp_logging"), &
         .true., intrinsic=.true.)    
    call var_list_append_string &
       (global%var_list, var_str ("$loop_me_method"), &
        var_str ("gosam"), intrinsic = .true.)
    call var_list_append_string &
       (global%var_list, var_str ("$correlation_me_method"), &
        var_str ("omega"), intrinsic = .true.)
    call var_list_append_string &
       (global%var_list, var_str ("$real_tree_me_method"), &
        var_str ("omega"), intrinsic = .true.)
    call var_list_append_real &
        (global%var_list, var_str ("fks_dij_exp1"), &
         1._default, intrinsic = .true.)
    call var_list_append_real &
        (global%var_list, var_str ("fks_dij_exp2"), &
         1._default, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("fks_mapping_type"), &
         1, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("alpha_power"), &
         2, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("alphas_power"), &
         0, intrinsic = .true.)
    call var_list_append_log &
        (global%var_list, var_str ("?powheg_use_singular_jacobian"), &
         .false., intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("powheg_grid_size_xi"), &
         5, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("powheg_grid_size_y"), &
         5, intrinsic = .true.)
    call var_list_append_int &
        (global%var_list, var_str ("powheg_grid_sampling_points"), &
         500000, intrinsic = .true.)
    call var_list_append_real &
         (global%var_list, var_str ("powheg_pt_min"), &
          1._default, intrinsic = .true.)
    call var_list_append_real &
         (global%var_list, var_str ("powheg_lambda"), &
          LAMBDA_QCD_REF, intrinsic = .true.)
    call var_list_append_log &
         (global%var_list, var_str ("?powheg_rebuild_grids"), &
          .false., intrinsic = .true.)
    call var_list_append_log &
        (global%var_list, var_str ("?combined_nlo_integration"), &
         .false., intrinsic = .true.)
    call global%init_pointer_variables ()
    call global%process_stack%init_var_list (global%var_list)
  end subroutine rt_data_global_init

@ %def rt_data_global_init
@ 
\subsection{Local copies}
This is done at compile time when a local copy of runtime data is
needed: Link the variable list and initialize all derived parameters.
This allows for synchronizing them with local variable changes without
affecting global data.

Also re-initialize pointer variables, so they point to local copies of
their targets.
<<RT data: rt data: TBP>>=
  procedure :: local_init => rt_data_local_init
<<RT data: procedures>>=
  subroutine rt_data_local_init (local, global, env)
    class(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(in), target :: global
    integer, intent(in), optional :: env
    local%context => global
    call local%process_stack%link (global%process_stack)
    call local%process_stack%init_var_list (local%var_list)
    call local%process_stack%link_var_list (global%var_list)
    call var_list_append_string &
         (local%var_list, var_str ("$model_name"), var_str (""), &
          intrinsic=.true.)
    call local%init_pointer_variables ()
    local%fallback_model => global%fallback_model
    local%radiation_model => global%radiation_model
    local%os_data = global%os_data
    local%logfile = global%logfile
    call local%model_list%link (global%model_list)
    local%model => global%model
    if (associated (local%model)) then
       call local%model%link_var_list (local%var_list)
    end if
  end subroutine rt_data_local_init

@ %def rt_data_local_init
@ These variables point to objects which get local copies:
<<RT data: rt data: TBP>>=
  procedure :: init_pointer_variables => rt_data_init_pointer_variables
<<RT data: procedures>>=
  subroutine rt_data_init_pointer_variables (local)
    class(rt_data_t), intent(inout), target :: local
    logical, target, save :: known = .true.
    call var_list_append_string_ptr &
         (local%var_list, var_str ("$fc"), local%os_data%fc, known, &
          intrinsic=.true.)
    call var_list_append_string_ptr &
         (local%var_list, var_str ("$fcflags"), local%os_data%fcflags, known, &
         intrinsic=.true.)
  end subroutine rt_data_init_pointer_variables

@ %def rt_data_init_pointer_variables
@ This is done at execution time: Copy data, transfer pointers.
[[local]] has intent(inout) because its local variable list has
already been prepared by the previous routine.

To be pedantic, the local pointers to model and library should point
to the entries in the local copies.  (However, as long as these are
just shallow copies with identical content, this is actually
irrelevant.)

The process library and process stacks behave as global objects.  The
copies of the process library and process stacks should be shallow
copies, so the contents stay identical.  Since objects may be pushed
on the stack in the local environment, upon restoring the global
environment, we should reverse the assignment.  Then the added stack
elements will end up on the global stack.  (This should be
reconsidered in a parallel environment.)
<<RT data: rt data: TBP>>=
  procedure :: activate => rt_data_activate
<<RT data: procedures>>=
  subroutine rt_data_activate (local)
    class(rt_data_t), intent(inout), target :: local
    class(rt_data_t), pointer :: global
    global => local%context
    if (associated (global)) then
       local%lexer => global%lexer
       call global%copy_globals (local)
       local%os_data = global%os_data
       local%logfile = global%logfile
       if (associated (global%prclib)) then
          local%prclib => &
               local%prclib_stack%get_library_ptr (global%prclib%get_name ())
       end if
       call local%import_values ()
       call local%process_stack%link (global%process_stack)
       local%it_list = global%it_list
       local%beam_structure = global%beam_structure
       local%pn = global%pn
       if (allocated (local%sample_fmt))  deallocate (local%sample_fmt)
       if (allocated (global%sample_fmt)) then
          allocate (local%sample_fmt (size (global%sample_fmt)), &
               source = global%sample_fmt)
       end if
       local%out_files => global%out_files
       local%model => global%model
       local%model_is_copy = .false.
    else if (.not. associated (local%model)) then
       local%model => local%preload_model
       local%model_is_copy = .false.
    end if
    if (associated (local%model)) then
       call local%model%link_var_list (local%var_list)
       call var_list_set_string (local%var_list, var_str ("$model_name"), &
            local%model%get_name (), is_known = .true.)
    else
       call var_list_set_string (local%var_list, var_str ("$model_name"), &
            var_str (""), is_known = .false.)
    end if
  end subroutine rt_data_activate

@ %def rt_data_activate
@ Restore the previous state of data, without actually finalizing the local
environment.  We also clear the local process stack.  Some local modifications
(model list and process library stack) are communicated to the global context,
if there is any. 

If the [[keep_local]] flag is set, we want to retain current settings in
the local environment.  In particular, we create an instance of the currently
selected model (which thus becomes separated from the model library!).
The local variables are also kept.
<<RT data: rt data: TBP>>=
  procedure :: deactivate => rt_data_deactivate
<<RT data: procedures>>=
  subroutine rt_data_deactivate (local, global, keep_local)
    class(rt_data_t), intent(inout), target :: local
    class(rt_data_t), intent(inout), optional, target :: global
    logical, intent(in), optional :: keep_local
    type(string_t) :: global_model, local_model
    logical :: same_model, delete
    delete = .true.;  if (present (keep_local))  delete = .not. keep_local
    if (present (global)) then
       if (associated (global%model) .and. associated (local%model)) then 
          global_model = global%model%get_name ()
          local_model = local%model%get_name ()
          same_model = global_model == local_model
       else
          same_model = .false.
       end if
       if (delete) then
          call local%process_stack%clear ()
          call local%unselect_model ()
          call local%unset_values ()
       else if (associated (local%model)) then
          call local%ensure_model_copy ()
       end if
       if (.not. same_model .and. global_model /= "") then
          call msg_message ("Restoring model '" // char (global_model) // "'")
       end if
       if (associated (global%model)) then
          call global%model%link_var_list (global%var_list)
       end if
       call global%restore_globals (local)
    else
       call local%unselect_model ()
    end if
  end subroutine rt_data_deactivate

@ %def rt_data_deactivate
@ This imports the global objects for which local modifications
should be kept.  Currently, this is only the process library stack.
<<RT data: rt data: TBP>>=
  procedure :: copy_globals => rt_data_copy_globals
<<RT data: procedures>>=
  subroutine rt_data_copy_globals (global, local)
    class(rt_data_t), intent(in) :: global
    class(rt_data_t), intent(inout) :: local
    local%prclib_stack = global%prclib_stack
  end subroutine rt_data_copy_globals
 
@ %def rt_data_copy_globals
@ This restores global objects, for which local modifications
should be kept.
<<RT data: rt data: TBP>>=
  procedure :: restore_globals => rt_data_restore_globals
<<RT data: procedures>>=
  subroutine rt_data_restore_globals (global, local)
    class(rt_data_t), intent(inout) :: global
    class(rt_data_t), intent(in) :: local
    global%prclib_stack = local%prclib_stack
  end subroutine rt_data_restore_globals
 
@ %def rt_data_restore_globals
@ 
\subsection{Finalization}
Finalizer for the variable list and the structure-function list.
This is done only for the global RT dataset; local copies contain
pointers to this and do not need a finalizer.
<<RT data: rt data: TBP>>=
  procedure :: final => rt_data_global_final
<<RT data: procedures>>=
  subroutine rt_data_global_final (global)
    class(rt_data_t), intent(inout) :: global
    call global%process_stack%final ()
    call global%prclib_stack%final ()
!    call global%delete_model_copy ()
    call global%model_list%final ()
    call global%var_list%final (follow_link=.false.)
    if (associated (global%out_files)) then
       call file_list_final (global%out_files)
       deallocate (global%out_files)
    end if
  end subroutine rt_data_global_final

@ %def rt_data_global_final
@ The local copy needs a finalizer for the variable list, which consists
of local copies.  This finalizer is called only when the local
environment is finally discarded.  (Note that the process stack should
already have been cleared after execution, which can occur many times
for the same local environment.)
<<RT data: rt data: TBP>>=
  procedure :: local_final => rt_data_local_final
<<RT data: procedures>>=
  subroutine rt_data_local_final (local)
    class(rt_data_t), intent(inout) :: local
    call local%process_stack%clear ()
!    call local%delete_model_copy ()
    call local%model_list%final ()
    call local%var_list%final (follow_link=.false.)
  end subroutine rt_data_local_final

@ %def rt_data_local_final
@
\subsection{Model Management}
Read a model, so it becomes available for activation.  No variables or model
copies, this is just initialization.

If this is a local environment, the model will be automatically read into the
global context.
<<RT data: rt data: TBP>>=
  procedure :: read_model => rt_data_read_model
<<RT data: procedures>>=
  subroutine rt_data_read_model (global, name, model)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    type(model_t), pointer, intent(out) :: model
    type(string_t) :: filename
    filename = name // ".mdl"
    call global%model_list%read_model &
         (name, filename, global%os_data, model)
  end subroutine rt_data_read_model
    
@ %def rt_data_read_model 
@ Initialize the fallback model.  This model is used
whenever the current model does not describe all physical particles
(hadrons, mainly).  It is not supposed to be modified, and the pointer
should remain linked to this model.
<<RT data: rt data: TBP>>=
  procedure :: init_fallback_model => rt_data_init_fallback_model
<<RT data: procedures>>=
  subroutine rt_data_init_fallback_model (global, name, filename)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name, filename
    call global%model_list%read_model &
         (name, filename, global%os_data, global%fallback_model)
  end subroutine rt_data_init_fallback_model
  
@ %def rt_data_init_fallback_model
@ Initialize the radiation model.  This model is used by a
radiation-generator algorithm which is part of the NLO machinery.  It is not
supposed to be modified, and the pointer 
should remain linked to this model.
<<RT data: rt data: TBP>>=
  procedure :: init_radiation_model => rt_data_init_radiation_model
<<RT data: procedures>>=
  subroutine rt_data_init_radiation_model (global, name, filename)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name, filename
    call global%model_list%read_model &
         (name, filename, global%os_data, global%radiation_model)
  end subroutine rt_data_init_radiation_model
  
@ %def rt_data_init_radiation_model
@
Activate a model: assign the current-model pointer and set the model name in
the variable list.  If necessary, read the model from file.  Link the global
variable list to the model variable list.
<<RT data: rt data: TBP>>=
  procedure :: select_model => rt_data_select_model
<<RT data: procedures>>=
  subroutine rt_data_select_model (global, name)
    class(rt_data_t), intent(inout), target :: global
    type(string_t), intent(in) :: name
    logical :: same_model
    if (associated (global%model)) then
       same_model = global%model%get_name () == name
    else
       same_model = .false.
    end if
    if (.not. same_model) then
!       call global%delete_model_copy () 
       global%model => global%model_list%get_model_ptr (name)
       if (.not. associated (global%model)) then
          call global%read_model (name, global%model)
          global%model_is_copy = .false.
       else if (associated (global%context)) then
          global%model_is_copy = &
               global%model_list%model_exists (name, follow_link=.false.)
       else
          global%model_is_copy = .false.
       end if
    end if
    if (associated (global%model)) then
       call global%model%link_var_list (global%var_list)
       call var_list_set_string (global%var_list, var_str ("$model_name"), &
            name, is_known = .true.)
       call msg_message ("Switching to model '" // char (name) // "'")
    else
       call var_list_set_string (global%var_list, var_str ("$model_name"), &
            var_str (""), is_known = .false.)
    end if
  end subroutine rt_data_select_model
  
@ %def rt_data_select_model
@
Remove the model link and unset the model name variable.
<<RT data: rt data: TBP>>=
  procedure :: unselect_model => rt_data_unselect_model
<<RT data: procedures>>=
  subroutine rt_data_unselect_model (global)
    class(rt_data_t), intent(inout), target :: global
    if (associated (global%model)) then
!       call global%delete_model_copy ()
       global%model => null ()
       global%model_is_copy = .false.
       call var_list_set_string (global%var_list, var_str ("$model_name"), &
            var_str (""), is_known = .false.)
    end if
  end subroutine rt_data_unselect_model
  
@ %def rt_data_unselect_model
@
Create a copy of the currently selected model and append it to the local model
list.  The model pointer is redirected to the copy.
(Not applicable for the global model list, those models will be
modified in-place.)
%Take/delete a snapshot of the currently active model, if applicable.  The
%destructor also de-assigns the model if it just a link.
<<RT data: rt data: TBP>>=
  procedure :: ensure_model_copy => rt_data_ensure_model_copy
!   procedure :: delete_model_copy => rt_data_delete_model_copy
<<RT data: procedures>>=
  subroutine rt_data_ensure_model_copy (global)
    class(rt_data_t), intent(inout), target :: global
    if (associated (global%context)) then
       if (.not. global%model_is_copy) then
          call global%model_list%append_copy (global%model, global%model)
          global%model_is_copy = .true.
          call global%model%link_var_list (global%var_list)
       end if
    end if
  end subroutine rt_data_ensure_model_copy

!   subroutine rt_data_delete_model_copy (global)
!     class(rt_data_t), intent(inout), target :: global
!     if (global%model_is_copy) then
!        call model_pointer_delete_instance (global%model)
!        global%model_is_copy = .false.
!     else
!        global%model => null ()
!     end if
!   end subroutine rt_data_delete_model_copy

@ %def rt_data_ensure_model_copy
@ %def rt_data_delete_model_copy
@
Modify a model variable.  The update mechanism will ensure that the model
parameter set remains consistent.  This has to take place in a local copy
of the current model.  If there is none yet, create one.
<<RT data: rt data: TBP>>=
  procedure :: model_set_real => rt_data_model_set_real
<<RT data: procedures>>=
  subroutine rt_data_model_set_real (global, name, rval, verbose, pacified)
    class(rt_data_t), intent(inout), target :: global
    type(string_t), intent(in) :: name
    real(default), intent(in) :: rval
    logical, intent(in), optional :: verbose, pacified
    call global%ensure_model_copy ()
    call global%model%set_real (name, rval, verbose, pacified)
  end subroutine rt_data_model_set_real

@ %def rt_data_model_set_real
@
Modify particle properties.  This has to take place in a local copy
of the current model.  If there is none yet, create one.
<<RT data: rt data: TBP>>=
  procedure :: modify_particle => rt_data_modify_particle
<<RT data: procedures>>=
  subroutine rt_data_modify_particle &
       (global, pdg, polarized, stable, decay, &
       isotropic_decay, diagonal_decay, decay_helicity)
    class(rt_data_t), intent(inout), target :: global
    integer, intent(in) :: pdg
    logical, intent(in), optional :: polarized, stable
    logical, intent(in), optional :: isotropic_decay, diagonal_decay
    integer, intent(in), optional :: decay_helicity
    type(string_t), dimension(:), intent(in), optional :: decay
    call global%ensure_model_copy ()
    if (present (polarized)) then
       if (polarized) then
          call global%model%set_polarized (pdg)
       else
          call global%model%set_unpolarized (pdg)
       end if
    end if
    if (present (stable)) then
       if (stable) then
          call global%model%set_stable (pdg)
       else if (present (decay)) then
          call global%model%set_unstable &
               (pdg, decay, isotropic_decay, diagonal_decay, decay_helicity)
       else
          call msg_bug ("Setting particle unstable: missing decay processes")
       end if
    end if
  end subroutine rt_data_modify_particle

@ %def rt_data_modify_particle
@
\subsection{Managing Variables}
Return a pointer to the currently active variable list.  If there is no model,
this is the global variable list.  If there is one, it is the model variable
list, which should be linked to the former.
<<RT data: rt data: TBP>>=
  procedure :: get_var_list_ptr => rt_data_get_var_list_ptr
<<RT data: procedures>>=
  function rt_data_get_var_list_ptr (global) result (var_list)
    class(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    if (associated (global%model)) then
       var_list => global%model%get_var_list_ptr ()
    else
       var_list => global%var_list
    end if
  end function rt_data_get_var_list_ptr

@ %def rt_data_get_var_list_ptr
@ Initialize a local variable: append it to the current variable list.  No
initial value, yet.
<<RT data: rt data: TBP>>=
  procedure :: append_log => rt_data_append_log
  procedure :: append_int => rt_data_append_int
  procedure :: append_real => rt_data_append_real
  procedure :: append_cmplx => rt_data_append_cmplx
  procedure :: append_subevt => rt_data_append_subevt
  procedure :: append_pdg_array => rt_data_append_pdg_array
  procedure :: append_string => rt_data_append_string
<<RT data: procedures>>=
  subroutine rt_data_append_log (local, name, lval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    logical, intent(in), optional :: lval
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_log (local%var_list, name, lval, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_log
  
  subroutine rt_data_append_int (local, name, ival, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    integer, intent(in), optional :: ival
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_int (local%var_list, name, ival, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_int
  
  subroutine rt_data_append_real (local, name, rval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    real(default), intent(in), optional :: rval
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_real (local%var_list, name, rval, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_real
  
  subroutine rt_data_append_cmplx (local, name, cval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    complex(default), intent(in), optional :: cval
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_cmplx (local%var_list, name, cval, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_cmplx
  
  subroutine rt_data_append_subevt (local, name, pval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    type(subevt_t), intent(in), optional :: pval
    logical, intent(in) :: intrinsic, user
    call var_list_append_subevt (local%var_list, name, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_subevt
  
  subroutine rt_data_append_pdg_array (local, name, aval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    type(pdg_array_t), intent(in), optional :: aval
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_pdg_array (local%var_list, name, aval, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_pdg_array
  
  subroutine rt_data_append_string (local, name, sval, intrinsic, user)
    class(rt_data_t), intent(inout) :: local
    type(string_t), intent(in) :: name
    type(string_t), intent(in), optional :: sval
    logical, intent(in), optional :: intrinsic, user
    call var_list_append_string (local%var_list, name, sval, &
         intrinsic = intrinsic, user = user)
  end subroutine rt_data_append_string
  
@ %def rt_data_append_log 
@ %def rt_data_append_int 
@ %def rt_data_append_real 
@ %def rt_data_append_cmplx 
@ %def rt_data_append_subevt 
@ %def rt_data_append_pdg_array 
@ %def rt_data_append_string
@ Import values for all local variables, given a global context environment
where these variables are defined.
<<RT data: rt data: TBP>>=
  procedure :: import_values => rt_data_import_values
<<RT data: procedures>>=
  subroutine rt_data_import_values (local)
    class(rt_data_t), intent(inout) :: local
    type(string_t) :: name
    integer :: type
    type(rt_data_t), pointer :: global
    global => local%context
    if (associated (global)) then
       call var_list_import (local%var_list, global%var_list)
    end if
  end subroutine rt_data_import_values
    
@ %def rt_data_import_values
@ Unset all variable values.
<<RT data: rt data: TBP>>=
  procedure :: unset_values => rt_data_unset_values
<<RT data: procedures>>=
  subroutine rt_data_unset_values (global)
    class(rt_data_t), intent(inout) :: global
    call var_list_undefine (global%var_list, follow_link=.false.)
  end subroutine rt_data_unset_values
  
@ %def rt_data_unset_values
@ Set a variable.  (Not a model variable, these are handled separately.)  We
can assume that the variable has been initialized.
<<RT data: rt data: TBP>>=
  procedure :: set_log => rt_data_set_log
  procedure :: set_int => rt_data_set_int
  procedure :: set_real => rt_data_set_real
  procedure :: set_cmplx => rt_data_set_cmplx
  procedure :: set_subevt => rt_data_set_subevt
  procedure :: set_pdg_array => rt_data_set_pdg_array
  procedure :: set_string => rt_data_set_string
<<RT data: procedures>>=
  subroutine rt_data_set_log (global, name, lval, is_known, verbose)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    logical, intent(in) :: lval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose
    call var_list_set_log (global%var_list, name, lval, is_known, &
         verbose=verbose)
  end subroutine rt_data_set_log

  subroutine rt_data_set_int (global, name, ival, is_known, verbose)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    integer, intent(in) :: ival
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose
    call var_list_set_int (global%var_list, name, ival, is_known, &
         verbose=verbose)
  end subroutine rt_data_set_int

  subroutine rt_data_set_real (global, name, rval, is_known, verbose, pacified)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    real(default), intent(in) :: rval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose, pacified
    call var_list_set_real (global%var_list, name, rval, is_known, &
         verbose=verbose, pacified=pacified)
  end subroutine rt_data_set_real

  subroutine rt_data_set_cmplx (global, name, cval, is_known, verbose, pacified)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    complex(default), intent(in) :: cval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose, pacified
    call var_list_set_cmplx (global%var_list, name, cval, is_known, &
         verbose=verbose, pacified=pacified)
  end subroutine rt_data_set_cmplx

  subroutine rt_data_set_subevt (global, name, pval, is_known, verbose)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    type(subevt_t), intent(in) :: pval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose
    call var_list_set_subevt (global%var_list, name, pval, is_known, &
         verbose=verbose)
  end subroutine rt_data_set_subevt

  subroutine rt_data_set_pdg_array (global, name, aval, is_known, verbose)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    type(pdg_array_t), intent(in) :: aval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose
    call var_list_set_pdg_array (global%var_list, name, aval, is_known, &
         verbose=verbose)
  end subroutine rt_data_set_pdg_array

  subroutine rt_data_set_string (global, name, sval, is_known, verbose)
    class(rt_data_t), intent(inout) :: global
    type(string_t), intent(in) :: name
    type(string_t), intent(in) :: sval
    logical, intent(in) :: is_known
    logical, intent(in), optional :: verbose
    call var_list_set_string (global%var_list, name, sval, is_known, &
         verbose=verbose)
  end subroutine rt_data_set_string

@ %def rt_data_set_log
@ %def rt_data_set_int
@ %def rt_data_set_real
@ %def rt_data_set_cmplx
@ %def rt_data_set_subevt
@ %def rt_data_set_pdg_array
@ %def rt_data_set_string
@ Return the value of a variable, assuming that the type is correct.  
<<RT data: rt data: TBP>>=
  procedure :: get_lval => rt_data_get_lval
  procedure :: get_ival => rt_data_get_ival
  procedure :: get_rval => rt_data_get_rval
  procedure :: get_cval => rt_data_get_cval
  procedure :: get_pval => rt_data_get_pval
  procedure :: get_aval => rt_data_get_aval
  procedure :: get_sval => rt_data_get_sval
<<RT data: procedures>>=
  function rt_data_get_lval (global, name) result (lval)
    logical :: lval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    lval = var_list%get_lval (name)
  end function rt_data_get_lval
  
  function rt_data_get_ival (global, name) result (ival)
    integer :: ival
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    ival = var_list%get_ival (name)
  end function rt_data_get_ival
  
  function rt_data_get_rval (global, name) result (rval)
    real(default) :: rval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    rval = var_list%get_rval (name)
  end function rt_data_get_rval
    
  function rt_data_get_cval (global, name) result (cval)
    complex(default) :: cval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    cval = var_list%get_cval (name)
  end function rt_data_get_cval

  function rt_data_get_aval (global, name) result (aval)
    type(pdg_array_t) :: aval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    aval = var_list%get_aval (name)
  end function rt_data_get_aval
  
  function rt_data_get_pval (global, name) result (pval)
    type(subevt_t) :: pval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    pval = var_list%get_pval (name)
  end function rt_data_get_pval
  
  function rt_data_get_sval (global, name) result (sval)
    type(string_t) :: sval
    class(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: name
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    sval = var_list%get_sval (name)
  end function rt_data_get_sval
  
@ %def rt_data_get_lval
@ %def rt_data_get_ival
@ %def rt_data_get_rval
@ %def rt_data_get_cval
@ %def rt_data_get_pval
@ %def rt_data_get_aval
@ %def rt_data_get_sval
@
\subsection{Further Content}
Add a library (available via a pointer of type [[prclib_entry_t]]) to
the stack and update the pointer and variable list to the current
library.  The pointer association of [[prclib_entry]] will be discarded.
<<RT data: rt data: TBP>>=
  procedure :: add_prclib => rt_data_add_prclib
<<RT data: procedures>>=
  subroutine rt_data_add_prclib (global, prclib_entry)
    class(rt_data_t), intent(inout) :: global
    type(prclib_entry_t), intent(inout), pointer :: prclib_entry
    call global%prclib_stack%push (prclib_entry)
    call global%update_prclib (global%prclib_stack%get_first_ptr ())
  end subroutine rt_data_add_prclib
  
@ %def rt_data_add_prclib
@ Given a pointer to a process library, make this the currently active
library.
<<RT data: rt data: TBP>>=
  procedure :: update_prclib => rt_data_update_prclib
<<RT data: procedures>>=
  subroutine rt_data_update_prclib (global, lib)
    class(rt_data_t), intent(inout) :: global
    type(process_library_t), intent(in), target :: lib
    global%prclib => lib
    if (global%var_list%contains (&
         var_str ("$library_name"), follow_link = .false.)) then
       call var_list_set_string (global%var_list, &
            var_str ("$library_name"), &
            global%prclib%get_name (), is_known=.true.)
    else
       call var_list_append_string (global%var_list, &
            var_str ("$library_name"), global%prclib%get_name (), &
            intrinsic = .true.)
    end if
  end subroutine rt_data_update_prclib

@ %def rt_data_update_prclib
@
\subsection{Miscellaneous}
The helicity selection data are distributed among several parameters.  Here,
we collect them in a single record.
<<RT data: rt data: TBP>>=
  procedure :: get_helicity_selection => rt_data_get_helicity_selection
<<RT data: procedures>>=
  function rt_data_get_helicity_selection (rt_data) result (helicity_selection)
    class(rt_data_t), intent(in) :: rt_data
    type(helicity_selection_t) :: helicity_selection
    associate (var_list => rt_data%var_list)
      helicity_selection%active = var_list%get_lval (&
           var_str ("?helicity_selection_active"))
      if (helicity_selection%active) then
         helicity_selection%threshold = var_list%get_rval (&
              var_str ("helicity_selection_threshold"))
         helicity_selection%cutoff = var_list%get_ival (&
              var_str ("helicity_selection_cutoff"))
      end if
    end associate
  end function rt_data_get_helicity_selection

@ %def rt_data_get_helicity_selection
@ Show the beam setup: beam structure and relevant global variables.
<<RT data: rt data: TBP>>=
  procedure :: show_beams => rt_data_show_beams
<<RT data: procedures>>=
  subroutine rt_data_show_beams (rt_data, unit)
    class(rt_data_t), intent(in) :: rt_data
    integer, intent(in), optional :: unit
    type(string_t) :: s
    integer :: u
    u = given_output_unit (unit)
    associate (beams => rt_data%beam_structure, var_list => rt_data%var_list)
      call beams%write (u)
      if (.not. beams%asymmetric () .and. beams%get_n_beam () == 2) then
         write (u, "(2x,A,ES19.12,1x,'GeV')") "sqrts =", &
              var_list%get_rval (var_str ("sqrts"))         
      end if
      if (beams%contains ("pdf_builtin")) then
         s = var_list%get_sval (var_str ("$pdf_builtin_set"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "PDF set =", '"', char (s), '"'
         else
            write (u, "(2x,A,1x,A)")  "PDF set =", "[undefined]"
         end if
      end if
      if (beams%contains ("lhapdf")) then
         s = var_list%get_sval (var_str ("$lhapdf_dir"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF dir    =", '"', char (s), '"'
         end if
         s = var_list%get_sval (var_str ("$lhapdf_file"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF file   =", '"', char (s), '"'
            write (u, "(2x,A,1x,I0)") "LHAPDF member =", &
                 var_list%get_ival (var_str ("lhapdf_member"))
         else
            write (u, "(2x,A,1x,A)")  "LHAPDF file   =", "[undefined]"
         end if
      end if
      if (beams%contains ("lhapdf_photon")) then
         s = var_list%get_sval (var_str ("$lhapdf_dir"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF dir    =", '"', char (s), '"'
         end if
         s = var_list%get_sval (var_str ("$lhapdf_photon_file"))
         if (s /= "") then
            write (u, "(2x,A,1x,3A)")  "LHAPDF file   =", '"', char (s), '"'
            write (u, "(2x,A,1x,I0)") "LHAPDF member =", &
                 var_list%get_ival (var_str ("lhapdf_member"))
            write (u, "(2x,A,1x,I0)") "LHAPDF scheme =", &
                 var_list%get_ival (&
                 var_str ("lhapdf_photon_scheme"))
         else
            write (u, "(2x,A,1x,A)")  "LHAPDF file   =", "[undefined]"
         end if
      end if
      if (beams%contains ("isr")) then
         write (u, "(2x,A,ES19.12)") "ISR alpha =", &
              var_list%get_rval (var_str ("isr_alpha"))
         write (u, "(2x,A,ES19.12)") "ISR Q max =", &
              var_list%get_rval (var_str ("isr_q_max"))
         write (u, "(2x,A,ES19.12)") "ISR mass  =", &
              var_list%get_rval (var_str ("isr_mass"))
         write (u, "(2x,A,1x,I0)") "ISR order  =", &
              var_list%get_ival (var_str ("isr_order"))
         write (u, "(2x,A,1x,L1)") "ISR recoil =", &
              var_list%get_lval (var_str ("?isr_recoil"))
      end if
      if (beams%contains ("epa")) then
         write (u, "(2x,A,ES19.12)") "EPA alpha  =", &
              var_list%get_rval (var_str ("epa_alpha"))
         write (u, "(2x,A,ES19.12)") "EPA x min  =", &
              var_list%get_rval (var_str ("epa_x_min"))
         write (u, "(2x,A,ES19.12)") "EPA Q min  =", &
              var_list%get_rval (var_str ("epa_q_min"))
         write (u, "(2x,A,ES19.12)") "EPA E max  =", &
              var_list%get_rval (var_str ("epa_e_max"))
         write (u, "(2x,A,ES19.12)") "EPA mass   =", &
              var_list%get_rval (var_str ("epa_mass"))
         write (u, "(2x,A,1x,L1)") "EPA recoil =", &
              var_list%get_lval (var_str ("?epa_recoil"))
      end if
      if (beams%contains ("ewa")) then
         write (u, "(2x,A,ES19.12)") "EWA x min       =", &
              var_list%get_rval (var_str ("ewa_x_min"))
         write (u, "(2x,A,ES19.12)") "EWA Pt max      =", &
              var_list%get_rval (var_str ("ewa_pt_max"))
         write (u, "(2x,A,ES19.12)") "EWA mass        =", &
              var_list%get_rval (var_str ("ewa_mass"))
         write (u, "(2x,A,1x,L1)") "EWA mom cons.   =", &
              var_list%get_lval (&
              var_str ("?ewa_keep_momentum"))
         write (u, "(2x,A,1x,L1)") "EWA energ. cons. =", &
              var_list%get_lval (&
              var_str ("ewa_keep_energy"))
      end if
      if (beams%contains ("circe1")) then
         write (u, "(2x,A,1x,I0)") "CIRCE1 version    =", &
              var_list%get_ival (var_str ("circe1_ver"))
         write (u, "(2x,A,1x,I0)") "CIRCE1 revision   =", &
              var_list%get_ival (var_str ("circe1_rev")) 
         s = var_list%get_sval (var_str ("$circe1_acc"))
         write (u, "(2x,A,1x,A)") "CIRCE1 acceler.   =", char (s)
         write (u, "(2x,A,1x,I0)") "CIRCE1 chattin.   =", &
              var_list%get_ival (var_str ("circe1_chat"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 sqrts      =", &
              var_list%get_rval (var_str ("circe1_sqrts"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 epsil.     =", &
              var_list%get_rval (var_str ("circe1_eps"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 phot. 1  =", &
              var_list%get_lval (var_str ("?circe1_photon1"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 phot. 2  =", &
              var_list%get_lval (var_str ("?circe1_photon2"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 generat. =", &
              var_list%get_lval (var_str ("?circe1_generate"))
         write (u, "(2x,A,1x,L1)") "CIRCE1 mapping  =", &
              var_list%get_lval (var_str ("?circe1_map"))
         write (u, "(2x,A,ES19.12)") "CIRCE1 map. slope =", &
              var_list%get_rval (var_str ("circe1_mapping_slope"))
      end if
      if (beams%contains ("circe2")) then
         s = var_list%get_sval (var_str ("$circe2_design"))
         write (u, "(2x,A,1x,A)") "CIRCE2 design   =", char (s) 
         s = var_list%get_sval (var_str ("$circe2_file"))
         write (u, "(2x,A,1x,A)") "CIRCE2 file     =", char (s)
         write (u, "(2x,A,1x,L1)") "CIRCE2 polarized =", &
              var_list%get_lval (var_str ("?circe2_polarized"))
      end if
      if (beams%contains ("beam_events")) then
         s = var_list%get_sval (var_str ("$beam_events_file"))
         write (u, "(2x,A,1x,A)") "Beam events file     =", char (s)
         write (u, "(2x,A,1x,L1)") "Beam events EOF warn =", &
              var_list%get_lval (var_str ("?beam_events_warn_eof"))
      end if
    end associate
  end subroutine rt_data_show_beams
  
@ %def rt_data_show_beams
@ Return the collision energy as determined by the current beam
settings.  Without beam setup, this is the [[sqrts]] variable.

If the value is meaningless for a setup, the function returns zero.
<<RT data: rt data: TBP>>=
  procedure :: get_sqrts => rt_data_get_sqrts
<<RT data: procedures>>=
  function rt_data_get_sqrts (rt_data) result (sqrts)
    class(rt_data_t), intent(in) :: rt_data
    real(default) :: sqrts
    sqrts = rt_data%var_list%get_rval (var_str ("sqrts"))
  end function rt_data_get_sqrts
    
@ %def rt_data_get_sqrts
@ For testing purposes, the [[rt_data_t]] contents can be pacified to
suppress numerical fluctuations in (constant) test matrix elements.
<<RT data: rt data: TBP>>=
  procedure :: pacify => rt_data_pacify
<<RT data: procedures>>=
  subroutine rt_data_pacify (rt_data, efficiency_reset, error_reset)
    class(rt_data_t), intent(inout) :: rt_data
    logical, intent(in), optional :: efficiency_reset, error_reset
    type(process_entry_t), pointer :: process
    process => rt_data%process_stack%first
    do while (associated (process))
       call process%pacify (efficiency_reset, error_reset)
       process => process%next
    end do    
  end subroutine rt_data_pacify

@ %def rt_data_pacify 
@ Set the matrix element method
<<RT data: rt data: TBP>>=
  procedure :: set_me_method => rt_data_set_me_method
<<RT data: procedures>>=
 subroutine rt_data_set_me_method (global, me_method)
   class(rt_data_t), intent(inout) :: global
   type(string_t), intent(in) :: me_method
   logical :: success
   success = global%var_list%contains (var_str ("$method"))
   if (success) &
      call global%var_list%set_sval (var_str ("$method"), me_method)
 end subroutine rt_data_set_me_method
 
@ %def rt_data_set_me_method
@
\subsection{Test}
This is the master for calling self-test procedures.
<<RT data: public>>=
  public :: rt_data_test
<<RT data: tests>>=
  subroutine rt_data_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<RT data: execute tests>>
  end subroutine rt_data_test

@ %def rt_data_test
@
\subsubsection{Initial content}
Force system-dependent objects to well-defined values.  Some of the
variables are locked and therefore must be addressed directly.

This is, of course, only required for testing purposes. In principle,
the [[real_specimen]] variables could be set to their values in 
[[rt_data_t]], but this depends on the precision again, so we set
them to some dummy values.
<<RT data: rt data: TBP>>=
  procedure :: fix_system_dependencies => rt_data_fix_system_dependencies
<<RT data: tests>>=
  subroutine rt_data_fix_system_dependencies (rt_data)
    class(rt_data_t), intent(inout), target :: rt_data
    type(var_list_t), pointer :: var_list
    var_list => rt_data%var_list
    call var_list_set_log (var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true., force=.true.) 
    call var_list_set_log (var_list, var_str ("?openmp_is_active"), &
         .false., is_known = .true., force=.true.)
    call var_list_set_int (var_list, var_str ("openmp_num_threads_default"), &
         1, is_known = .true., force=.true.)
    call var_list_set_int (var_list, var_str ("openmp_num_threads"), &
         1, is_known = .true., force=.true.)        
    call var_list_set_int (var_list, var_str ("real_range"), &
         307, is_known = .true., force=.true.)
    call var_list_set_int (var_list, var_str ("real_precision"), &
         15, is_known = .true., force=.true.)    
    call var_list_set_real (var_list, var_str ("real_epsilon"), &
         1.e-16_default, is_known = .true., force=.true.)
    call var_list_set_real (var_list, var_str ("real_tiny"), &
         1.e-300_default, is_known = .true., force=.true.)     
    
    rt_data%os_data%fc = "Fortran-compiler"
    rt_data%os_data%fcflags = "Fortran-flags"
        
  end subroutine rt_data_fix_system_dependencies
  
@ %def rt_data_fix_system_dependencies
@ 
Display the RT data in the state just after (global) initialization.
<<RT data: execute tests>>=
  call test (rt_data_1, "rt_data_1", &
       "initialize", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_1 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    write (u, "(A)")  "* Test output: rt_data_1"
    write (u, "(A)")  "*   Purpose: initialize global runtime data"
    write (u, "(A)")

    call rt_data%global_init (logfile = var_str ("rt_data.log"))

    call rt_data%fix_system_dependencies ()
    call rt_data%set_int (var_str ("seed"), 0, is_known=.true.)            

    call rt_data%it_list%init ([2, 3], [5000, 20000])

    call rt_data%write (u)

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_1"
    
  end subroutine rt_data_1
  
@ %def rt_data_1
@
\subsubsection{Fill values}
Fill in empty slots in the runtime data block.
<<RT data: execute tests>>=
  call test (rt_data_2, "rt_data_2", &
       "fill", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_2 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    type(flavor_t), dimension(2) :: flv
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    
    write (u, "(A)")  "* Test output: rt_data_2"
    write (u, "(A)")  "*   Purpose: initialize global runtime data &
         &and fill contents"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%fix_system_dependencies ()

    call rt_data%select_model (var_str ("Test"))

    call rt_data%set_real (var_str ("sqrts"), &
         1000._default, is_known = .true.)
    call rt_data%set_int (var_str ("seed"), &
         0, is_known=.true.)        
    call flv%init ([25,25], rt_data%model)
    
    call rt_data%set_string (var_str ("$run_id"), &
         var_str ("run1"), is_known = .true.)
    call rt_data%set_real (var_str ("luminosity"), &
         33._default, is_known = .true.)
    
    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    rt_data%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    allocate (rt_data%sample_fmt (2))
    rt_data%sample_fmt(1) = "foo_fmt"
    rt_data%sample_fmt(2) = "bar_fmt"
    
    call rt_data%write (u)

    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()

    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_2"
    
  end subroutine rt_data_2
  
@ %def rt_data_2
@
\subsubsection{Save and restore}
Set up a local runtime data block, change some contents, restore the
global block.
<<RT data: execute tests>>=
  call test (rt_data_3, "rt_data_3", &
       "save/restore", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_3 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data, local
    type(var_list_t), pointer :: model_vars
    type(flavor_t), dimension(2) :: flv
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    type(prclib_entry_t), pointer :: lib
    
    write (u, "(A)")  "* Test output: rt_data_3"
    write (u, "(A)")  "*   Purpose: initialize global runtime data &
         &and fill contents;"
    write (u, "(A)")  "*            copy to local block and back"
    write (u, "(A)")

    write (u, "(A)")  "* Init global data"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%fix_system_dependencies ()
    call rt_data%set_int (var_str ("seed"), &
         0, is_known=.true.)        

    call rt_data%select_model (var_str ("Test"))

    call rt_data%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call flv%init ([25,25], rt_data%model)
    
    call rt_data%beam_structure%init_sf (flv%get_name (), [1])
    call rt_data%beam_structure%set_sf (1, 1, var_str ("pdf_builtin"))

    call rt_data%set_string (var_str ("$run_id"), &
         var_str ("run1"), is_known = .true.)
    call rt_data%set_real (var_str ("luminosity"), &
         33._default, is_known = .true.)
    
    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    rt_data%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    allocate (rt_data%sample_fmt (2))
    rt_data%sample_fmt(1) = "foo_fmt"
    rt_data%sample_fmt(2) = "bar_fmt"

    allocate (lib)
    call lib%init (var_str ("library_1"))
    call rt_data%add_prclib (lib)

    write (u, "(A)")  "* Init and modify local data"
    write (u, "(A)")

    call local%local_init (rt_data)
    call local%append_string (var_str ("$integration_method"), intrinsic=.true.)
    call local%append_string (var_str ("$phs_method"), intrinsic=.true.)

    call local%activate ()

    write (u, "(1x,A,L1)")  "model associated   = ", associated (local%model)
    write (u, "(1x,A,L1)")  "library associated = ", associated (local%prclib)
    write (u, *)

    call local%model_set_real (var_str ("ms"), 150._default)
    call local%set_string (var_str ("$integration_method"), &
         var_str ("midpoint"), is_known = .true.)
    call local%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)

    local%os_data%fc = "Local compiler"
    
    allocate (lib)
    call lib%init (var_str ("library_2"))
    call local%add_prclib (lib)

    call local%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Restore global data"
    write (u, "(A)")
    
    call local%deactivate (rt_data)

    write (u, "(1x,A,L1)")  "model associated   = ", associated (rt_data%model)
    write (u, "(1x,A,L1)")  "library associated = ", associated (rt_data%prclib)
    write (u, *)

    call rt_data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()

    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_3"
    
  end subroutine rt_data_3
  
@ %def rt_data_3
@
\subsubsection{Show variables}
Display selected variables in the global record.
<<RT data: execute tests>>=
  call test (rt_data_4, "rt_data_4", &
       "show variables", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_4 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    type(string_t), dimension(0) :: empty_string_array

    write (u, "(A)")  "* Test output: rt_data_4"
    write (u, "(A)")  "*   Purpose: display selected variables"
    write (u, "(A)")

    call rt_data%global_init ()

    write (u, "(A)")  "* No variables:"
    write (u, "(A)")

    call rt_data%write_vars (u, empty_string_array)

    write (u, "(A)")  "* Two variables:"
    write (u, "(A)")

    call rt_data%write_vars (u, &
         [var_str ("?unweighted"), var_str ("$phs_method")])
    
    write (u, "(A)")
    write (u, "(A)")  "* Display whole record with selected variables"
    write (u, "(A)")

    call rt_data%write (u, &
         vars = [var_str ("?unweighted"), var_str ("$phs_method")])

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_4"
    
  end subroutine rt_data_4
  
@ %def rt_data_4
@
\subsubsection{Show parts}
Display only selected parts in the state just after (global) initialization.
<<RT data: execute tests>>=
  call test (rt_data_5, "rt_data_5", &
       "show parts", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_5 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data
    
    write (u, "(A)")  "* Test output: rt_data_5"
    write (u, "(A)")  "*   Purpose: display parts of rt data"
    write (u, "(A)")

    call rt_data%global_init ()
    call rt_data%write_libraries (u)

    write (u, "(A)")

    call rt_data%write_beams (u)

    write (u, "(A)")

    call rt_data%write_process_stack (u)

    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_5"
    
  end subroutine rt_data_5
  
@ %def rt_data_5
@
\subsubsection{Local Model}
Locally modify a model and restore the global one.  We need an auxiliary
function to determine the status of a model particle:
<<RT data: tests>>=
  function is_stable (pdg, rt_data) result (flag)
    integer, intent(in) :: pdg
    type(rt_data_t), intent(in) :: rt_data
    logical :: flag
    type(flavor_t) :: flv
    call flv%init (pdg, rt_data%model)
    flag = flv%is_stable ()
  end function is_stable
   
  function is_polarized (pdg, rt_data) result (flag)
    integer, intent(in) :: pdg
    type(rt_data_t), intent(in) :: rt_data
    logical :: flag
    type(flavor_t) :: flv
    call flv%init (pdg, rt_data%model)
    flag = flv%is_polarized ()
  end function is_polarized
    
@ %def is_stable is_polarized
<<RT data: execute tests>>=
  call test (rt_data_6, "rt_data_6", &
       "local model", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_6 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data, local
    type(var_list_t), pointer :: model_vars
    type(string_t) :: var_name

    write (u, "(A)")  "* Test output: rt_data_6"
    write (u, "(A)")  "*   Purpose: apply and keep local modifications to model"
    write (u, "(A)")

    call syntax_model_file_init ()

    call rt_data%global_init ()
    call rt_data%select_model (var_str ("Test"))
    
    write (u, "(A)")  "* Original model"
    write (u, "(A)")

    call rt_data%write_model_list (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, *)

    var_name = "ff"

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Apply local modifications: unstable"
    write (u, "(A)")

    call local%local_init (rt_data)
    call local%activate ()

    call local%model_set_real (var_name, 0.4_default)
    call local%modify_particle (25, stable = .false., decay = [var_str ("d1")])
    call local%modify_particle (6, stable = .false., &
         decay = [var_str ("f1")], isotropic_decay = .true.)
    call local%modify_particle (-6, stable = .false., &
         decay = [var_str ("f2"), var_str ("f3")], diagonal_decay = .true.)

    call local%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Further modifications"
    write (u, "(A)")

    call local%modify_particle (6, stable = .false., &
         decay = [var_str ("f1")], &
         diagonal_decay = .true., isotropic_decay = .false.)
    call local%modify_particle (-6, stable = .false., &
         decay = [var_str ("f2"), var_str ("f3")], &
         diagonal_decay = .false., isotropic_decay = .true.)
    call local%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Further modifications: f stable but polarized"
    write (u, "(A)")

    call local%modify_particle (6, stable = .true., polarized = .true.)
    call local%modify_particle (-6, stable = .true.)
    call local%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Global model"
    write (u, "(A)")

    call rt_data%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, "(A)")
    write (u, "(A)")  "* Local model"
    write (u, "(A)")

    call local%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, local)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, local)

    write (u, *)

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)", advance="no")  "Local model variable: "
    call var_list_write_var (local%model%get_var_list_ptr (), &
         var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Restore global"

    call local%deactivate (rt_data, keep_local = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Global model"
    write (u, "(A)")

    call rt_data%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, rt_data)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, rt_data)

    write (u, "(A)")
    write (u, "(A)")  "* Local model"
    write (u, "(A)")

    call local%model%write (u)
    write (u, *)
    write (u, "(A,L1)")  "s is stable    = ", is_stable (25, local)
    write (u, "(A,L1)")  "f is polarized = ", is_polarized (6, local)

    write (u, *)

    write (u, "(A)", advance="no")  "Global model variable: "
    model_vars => rt_data%model%get_var_list_ptr ()
    call var_list_write_var (model_vars, var_name, u)

    write (u, "(A)", advance="no")  "Local model variable: "
    call var_list_write_var (local%model%get_var_list_ptr (), &
         var_name, u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call local%model%final ()
    deallocate (local%model)
    
    call rt_data%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_6"
    
  end subroutine rt_data_6
  
@ %def rt_data_6
@
\subsubsection{Result variables}
Initialize result variables and check that they are accessible via the
global variable list.
<<RT data: execute tests>>=
  call test (rt_data_7, "rt_data_7", &
       "result variables", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_7 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data

    write (u, "(A)")  "* Test output: rt_data_7"
    write (u, "(A)")  "*   Purpose: set and access result variables"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process variables"
    write (u, "(A)")

    call rt_data%global_init ()
    call rt_data%process_stack%init_result_vars (var_str ("testproc"))
    
    call var_list_write_var (rt_data%var_list, &
         var_str ("integral(testproc)"), u)
    call var_list_write_var (rt_data%var_list, &
         var_str ("error(testproc)"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_7"
    
  end subroutine rt_data_7
  
@ %def rt_data_7
@
\subsubsection{Beam energy}
If beam parameters are set, the variable [[sqrts]] is not necessarily
the collision energy.  The method [[get_sqrts]] fetches the correct value.
<<RT data: execute tests>>=
  call test (rt_data_8, "rt_data_8", &
       "beam energy", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_8 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: rt_data

    write (u, "(A)")  "* Test output: rt_data_8"
    write (u, "(A)")  "*   Purpose: get correct collision energy"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize"
    write (u, "(A)")

    call rt_data%global_init ()

    write (u, "(A)")  "* Set sqrts"
    write (u, "(A)")

    call var_list_set_real (rt_data%var_list, var_str ("sqrts"), &
         1000._default, is_known = .true.)
    write (u, "(1x,A,ES19.12)")  "sqrts =", rt_data%get_sqrts ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call rt_data%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_8"
    
  end subroutine rt_data_8
  
@ %def rt_data_8
@
\subsubsection{Local variable modifications}
<<RT data: execute tests>>=
  call test (rt_data_9, "rt_data_9", &
       "local variables", &
       u, results)
<<RT data: tests>>=
  subroutine rt_data_9 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global, local
    type(var_list_t), pointer :: var_list
    type(string_t) :: var_name

    write (u, "(A)")  "* Test output: rt_data_9"
    write (u, "(A)")  "*   Purpose: handle local variables"
    write (u, "(A)")

    call syntax_model_file_init ()

    write (u, "(A)")  "* Initialize global record and set some variables"
    write (u, "(A)")

    call global%global_init ()
    call global%select_model (var_str ("Test"))
    
    call global%set_real (var_str ("sqrts"), 17._default, is_known = .true.)
    call global%set_real (var_str ("luminosity"), 2._default, is_known = .true.)
    call global%model_set_real (var_str ("ff"), 0.5_default)
    call global%model_set_real (var_str ("gy"), 1.2_default)

    var_list => global%get_var_list_ptr ()

    call var_list_write_var (var_list, var_str ("sqrts"), u)
    call var_list_write_var (var_list, var_str ("luminosity"), u)
    call var_list_write_var (var_list, var_str ("ff"), u)
    call var_list_write_var (var_list, var_str ("gy"), u)
    call var_list_write_var (var_list, var_str ("mf"), u)
    call var_list_write_var (var_list, var_str ("x"), u)

    write (u, "(A)")
    
    write (u, "(1x,A,1x,F5.2)")  "sqrts      = ", &
         global%get_rval (var_str ("sqrts"))
    write (u, "(1x,A,1x,F5.2)")  "luminosity = ", &
         global%get_rval (var_str ("luminosity"))
    write (u, "(1x,A,1x,F5.2)")  "ff         = ", &
         global%get_rval (var_str ("ff"))
    write (u, "(1x,A,1x,F5.2)")  "gy         = ", &
         global%get_rval (var_str ("gy"))
    write (u, "(1x,A,1x,F5.2)")  "mf         = ", &
         global%get_rval (var_str ("mf"))
    write (u, "(1x,A,1x,F5.2)")  "x          = ", &
         global%get_rval (var_str ("x"))

    write (u, "(A)")
    write (u, "(A)")  "* Create local record with local variables"
    write (u, "(A)")

    call local%local_init (global)

    call local%append_real (var_str ("luminosity"), intrinsic = .true.)
    call local%append_real (var_str ("x"), user = .true.)

    call local%activate ()

    var_list => local%get_var_list_ptr ()

    call var_list_write_var (var_list, var_str ("sqrts"), u)
    call var_list_write_var (var_list, var_str ("luminosity"), u)
    call var_list_write_var (var_list, var_str ("ff"), u)
    call var_list_write_var (var_list, var_str ("gy"), u)
    call var_list_write_var (var_list, var_str ("mf"), u)
    call var_list_write_var (var_list, var_str ("x"), u)

    write (u, "(A)")
    
    write (u, "(1x,A,1x,F5.2)")  "sqrts      = ", &
         local%get_rval (var_str ("sqrts"))
    write (u, "(1x,A,1x,F5.2)")  "luminosity = ", &
         local%get_rval (var_str ("luminosity"))
    write (u, "(1x,A,1x,F5.2)")  "ff         = ", &
         local%get_rval (var_str ("ff"))
    write (u, "(1x,A,1x,F5.2)")  "gy         = ", &
         local%get_rval (var_str ("gy"))
    write (u, "(1x,A,1x,F5.2)")  "mf         = ", &
         local%get_rval (var_str ("mf"))
    write (u, "(1x,A,1x,F5.2)")  "x          = ", &
         local%get_rval (var_str ("x"))

    write (u, "(A)")
    write (u, "(A)")  "* Modify some local variables"
    write (u, "(A)")

    call local%set_real (var_str ("luminosity"), 42._default, is_known=.true.)
    call local%set_real (var_str ("x"), 6.66_default, is_known=.true.)
    call local%model_set_real (var_str ("ff"), 0.7_default)

    var_list => local%get_var_list_ptr ()

    call var_list_write_var (var_list, var_str ("sqrts"), u)
    call var_list_write_var (var_list, var_str ("luminosity"), u)
    call var_list_write_var (var_list, var_str ("ff"), u)
    call var_list_write_var (var_list, var_str ("gy"), u)
    call var_list_write_var (var_list, var_str ("mf"), u)
    call var_list_write_var (var_list, var_str ("x"), u)

    write (u, "(A)")
    
    write (u, "(1x,A,1x,F5.2)")  "sqrts      = ", &
         local%get_rval (var_str ("sqrts"))
    write (u, "(1x,A,1x,F5.2)")  "luminosity = ", &
         local%get_rval (var_str ("luminosity"))
    write (u, "(1x,A,1x,F5.2)")  "ff         = ", &
         local%get_rval (var_str ("ff"))
    write (u, "(1x,A,1x,F5.2)")  "gy         = ", &
         local%get_rval (var_str ("gy"))
    write (u, "(1x,A,1x,F5.2)")  "mf         = ", &
         local%get_rval (var_str ("mf"))
    write (u, "(1x,A,1x,F5.2)")  "x          = ", &
         local%get_rval (var_str ("x"))

    write (u, "(A)")
    write (u, "(A)")  "* Restore globals"
    write (u, "(A)")

    call local%deactivate (global)
    
    var_list => global%get_var_list_ptr ()

    call var_list_write_var (var_list, var_str ("sqrts"), u)
    call var_list_write_var (var_list, var_str ("luminosity"), u)
    call var_list_write_var (var_list, var_str ("ff"), u)
    call var_list_write_var (var_list, var_str ("gy"), u)
    call var_list_write_var (var_list, var_str ("mf"), u)
    call var_list_write_var (var_list, var_str ("x"), u)

    write (u, "(A)")
    
    write (u, "(1x,A,1x,F5.2)")  "sqrts      = ", &
         global%get_rval (var_str ("sqrts"))
    write (u, "(1x,A,1x,F5.2)")  "luminosity = ", &
         global%get_rval (var_str ("luminosity"))
    write (u, "(1x,A,1x,F5.2)")  "ff         = ", &
         global%get_rval (var_str ("ff"))
    write (u, "(1x,A,1x,F5.2)")  "gy         = ", &
         global%get_rval (var_str ("gy"))
    write (u, "(1x,A,1x,F5.2)")  "mf         = ", &
         global%get_rval (var_str ("mf"))
    write (u, "(1x,A,1x,F5.2)")  "x          = ", &
         global%get_rval (var_str ("x"))

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call local%local_final ()

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: rt_data_9"
    
  end subroutine rt_data_9
  
@ %def rt_data_9
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Select implementations}
For abstract types (process core, integrator, phase space, etc.), we need a
way to dynamically select a concrete type, using either data given by the user
or a previous selection of a concrete type.  This is done by subroutines in
the current module.

This module provides no new types, just procedures.
<<[[dispatch.f90]]>>=
<<File header>>

module dispatch
  
<<Use kinds>>
  use kinds, only: i16, double
<<Use strings>>
  use constants, only: PI
  use system_dependencies, only: LHAPDF5_AVAILABLE
  use system_dependencies, only: LHAPDF6_AVAILABLE
  use system_defs, only: LF
  use io_units
  use format_utils, only: write_separator
  use unit_tests
  use diagnostics
  use os_interface
  use physics_defs, only: MZ_REF, ALPHA_QCD_MZ_REF
  use physics_defs, only: PROTON, PHOTON, ELECTRON
  use sm_qcd
  use pdg_arrays
  use variables
  use model_data
  use flavors
  use interactions
  use models
  use process_constants
  use pdf_builtin !NODEP!
  use lhapdf !NODEP!  
  use sf_mappings
  use sf_base
  use sf_pdf_builtin
  use sf_lhapdf
  use sf_circe1
  use sf_circe2
  use sf_isr
  use sf_epa
  use sf_ewa
  use sf_escan
  use sf_beam_events
  use sf_user
  use rng_base
  use rng_tao
  use mci_base
  use mci_midpoint
  use mci_vamp
  use phs_base
  use mappings
  use phs_forests
  use phs_single
  use phs_wood
  use prc_core_def
  use prc_test
  use beams
  use prc_omega
  use prc_template_me
  use prc_core
  use processes
  use powheg
  use shower_base
  use shower_core
  use shower_pythia6
  use mlm_matching
  use ckkw_base
  use shower
  use event_transforms
  use decays
  use hadrons
  use beam_structures
  use eio_base
  use eio_raw
  use eio_checkpoints
  use eio_lhef
  use eio_hepmc
  use eio_lcio
  use eio_stdhep
  use eio_ascii
  use eio_weights
  use rt_data
  use prc_gosam
  use prc_openloops
  use phs_fks
  use nlo_data

<<Standard module head>>

<<Dispatch: public>>

<<Dispatch: types>>

<<Dispatch: interfaces>>

contains
  
<<Dispatch: procedures>>

<<Dispatch: tests>>

end module dispatch
@ %def dispatch
@
\subsection{Interfaces}
<<Dispatch: interfaces>>=
  interface
     subroutine GetXminM (set, mem, xmin)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: xmin
     end subroutine GetXminM
  end interface

@ %def GetXminM
<<Dispatch: interfaces>>=
  interface
     subroutine GetXmaxM (set, mem, xmax)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: xmax
     end subroutine GetXmaxM
  end interface

@ %def GetXmaxM
<<Dispatch: interfaces>>=
  interface
     subroutine GetQ2minM (set, mem, q2min)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: q2min
     end subroutine GetQ2minM
  end interface

@ %def GetQ2minM
<<Dispatch: interfaces>>=
  interface
     subroutine GetQ2maxM (set, mem, q2max)
       integer, intent(in) :: set, mem
       double precision, intent(out) :: q2max
     end subroutine GetQ2maxM
  end interface

@ %def GetQ2maxM
@
\subsection{Process Core Definition}
The [[prc_core_def_t]] abstract type can be instantiated by providing a
[[$method]] string variable.

Note: [[core_def]] has intent(inout) because gfortran 4.7.1 crashes for
intent(out).
<<Dispatch: public>>=
  public :: dispatch_core_def
<<Dispatch: procedures>>=
  subroutine dispatch_core_def (core_def, prt_in, prt_out, &
                                global, id, nlo_type)
    class(prc_core_def_t), allocatable, intent(inout) :: core_def
    type(string_t), dimension(:), intent(in) :: prt_in
    type(string_t), dimension(:), intent(in) :: prt_out
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in), optional :: id
    integer, intent(in), optional :: nlo_type
    type(string_t) :: method
    type(string_t) :: model_name
    type(string_t) :: restrictions
    logical :: openmp_support
    logical :: report_progress
    logical :: diags, diags_color
    type(string_t) :: extra_options
    type(model_t), pointer :: model
    model => global%model
    associate (var_list => global%get_var_list_ptr ())
      method = var_list%get_sval (var_str ("$method"))
      if (associated (model)) then
         model_name = model%get_name ()
      else
         model_name = ""
      end if
      select case (char (method))
      case ("unit_test")
         allocate (prc_test_def_t :: core_def)
         select type (core_def)
         type is (prc_test_def_t)
            call core_def%init (model_name, prt_in, prt_out)
         end select
      case ("template")
         allocate (template_me_def_t :: core_def)
         select type (core_def)
         type is (template_me_def_t)
            call core_def%init (model, prt_in, prt_out, unity = .false.)
         end select
      case ("template_unity")
         allocate (template_me_def_t :: core_def)
         select type (core_def)
         type is (template_me_def_t)
            call core_def%init (model, prt_in, prt_out, unity = .true.)
         end select                  
      case ("omega")
         diags = var_list%get_lval (&
              var_str ("?diags"))
         diags_color = var_list%get_lval (&
              var_str ("?diags_color"))         
         restrictions = var_list%get_sval (&
              var_str ("$restrictions"))
         openmp_support = var_list%get_lval (&
              var_str ("?omega_openmp"))
         report_progress = var_list%get_lval (&
              var_str ("?report_progress"))
         extra_options = var_list%get_sval (&
              var_str ("$omega_flags"))
         allocate (omega_omega_def_t :: core_def)
         select type (core_def)
         type is (omega_omega_def_t)
            call core_def%init (model_name, prt_in, prt_out, &
                 restrictions, openmp_support, report_progress, &
                 extra_options, diags, diags_color)
         end select
      case ("ovm")
         diags = var_list%get_lval (&
              var_str ("?diags"))
         diags_color = var_list%get_lval (&
              var_str ("?diags_color"))         
         restrictions = var_list%get_sval (&
              var_str ("$restrictions"))
         openmp_support = var_list%get_lval (&
              var_str ("?omega_openmp"))
         report_progress = var_list%get_lval (&
              var_str ("?report_progress"))
         extra_options = var_list%get_sval (&
              var_str ("$omega_flags"))
         allocate (omega_ovm_def_t :: core_def)
         select type (core_def)
         type is (omega_ovm_def_t)
            call core_def%init (model_name, prt_in, prt_out, &
                 restrictions, openmp_support, report_progress, &
                 extra_options, diags, diags_color)
         end select         
      case ("gosam")
        allocate (gosam_def_t :: core_def)
        select type (core_def)
        type is (gosam_def_t)
          if (present (id)) then
             call core_def%init (id, model_name, prt_in, &
                                 prt_out, nlo_type)
          else
             call msg_fatal ("Dispatch GoSam def: No id!")
          end if
        end select
      case ("openloops")
         allocate (openloops_def_t :: core_def)
         select type (core_def)
         type is (openloops_def_t)
            if (present (id)) then
               call core_def%init (id, model_name, prt_in, &
                                   prt_out, nlo_type)
            else
               call msg_fatal ("Dispatch OpenLoops def: No id!")
            end if
         end select
      case default
         call msg_fatal ("Process configuration: method '" &
              // char (method) // "' not implemented")
      end select
    end associate
  end subroutine dispatch_core_def
    
@ %def dispatch_core_def
@
\subsection{Process core allocation}
Here we allocate an object of abstract type [[prc_core_t]] with a concrete
type that matches a process definition.  The [[prc_omega_t]] extension
will require the current parameter set, so we take the opportunity to
grab it from the model.
<<Dispatch: public>>=
  public :: dispatch_core
<<Dispatch: procedures>>=
  subroutine dispatch_core (core, core_def, model, &
       helicity_selection, qcd, use_color_factors)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(prc_core_def_t), intent(in) :: core_def
    class(model_data_t), intent(in), target, optional :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    logical, intent(in), optional :: use_color_factors
    select type (core_def)
    type is (prc_test_def_t)
       allocate (test_t :: core)
    type is (template_me_def_t)
       allocate (prc_template_me_t :: core)
       select type (core)
       type is (prc_template_me_t)
          call core%set_parameters (model) 
       end select       
    class is (omega_def_t)
       if (.not. allocated (core)) allocate (prc_omega_t :: core)
       select type (core)
       type is (prc_omega_t)
          call core%set_parameters (model, & 
               helicity_selection, qcd, use_color_factors)
       end select
    type is (gosam_def_t)
      if (.not. allocated (core)) allocate (prc_gosam_t :: core)
      select type (core)
      type is (prc_gosam_t)
        call core%set_parameters (qcd, use_color_factors)
      end select
    type is (openloops_def_t)
      if (.not. allocated (core)) allocate (prc_openloops_t :: core)
      select type (core)
      type is (prc_openloops_t)
         call core%set_parameters (qcd, use_color_factors)
      end select
    class default
       call msg_bug ("Process core: unexpected process definition type")
    end select
  end subroutine dispatch_core

@ %def dispatch_core
@
\subsection{Process core update and restoration}
Here we take an existing object of abstract type [[prc_core_t]] and
update the parameters as given by the current state of [[model]].
Optionally, we can save the previous state as [[saved_core]].  The
second routine restores the original from the save.

(In the test case, there is no possible update.)
<<Dispatch: public>>=
  public :: dispatch_core_update
  public :: dispatch_core_restore
<<Dispatch: procedures>>=
  subroutine dispatch_core_update (core, model, helicity_selection, qcd, &
       saved_core)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(model_data_t), intent(in), optional, target :: model
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(qcd_t), intent(in), optional :: qcd
    class(prc_core_t), allocatable, intent(inout), optional :: saved_core
    if (present (saved_core)) then
       allocate (saved_core, source = core)
    end if
    select type (core)
    type is (test_t)
    type is (prc_omega_t)
       call core%set_parameters (model, helicity_selection, qcd)
       call core%activate_parameters ()
    type is (prc_gosam_t)
      call msg_message ("dispatch core restore: Gosam implementation not present yet!")
    class default
       call msg_bug ("Process core update: unexpected process definition type")
    end select
  end subroutine dispatch_core_update

  subroutine dispatch_core_restore (core, saved_core)
    class(prc_core_t), allocatable, intent(inout) :: core
    class(prc_core_t), allocatable, intent(inout) :: saved_core
    call move_alloc (from = saved_core, to = core)
    select type (core)
    type is (test_t)
    type is (prc_omega_t)
       call core%activate_parameters ()
    class default
       call msg_bug ("Process core restore: unexpected process definition type")
    end select
  end subroutine dispatch_core_restore

@ %def dispatch_core_update dispatch_core_restore
@
\subsection{Integrator allocation}
Allocate an integrator according to the variable [[$integration_method]].
<<Dispatch: public>>=
  public :: dispatch_mci
<<Dispatch: procedures>>=
  subroutine dispatch_mci (mci, global, process_id)
    class(mci_t), allocatable, intent(inout) :: mci
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in) :: process_id
    type(string_t) :: run_id
    type(string_t) :: integration_method
    type(grid_parameters_t) :: grid_par
    type(history_parameters_t) :: history_par
    logical :: rebuild_grids, check_grid_file, negative_weights, verbose
    integration_method = &
         global%var_list%get_sval (var_str ("$integration_method"))
    select case (char (integration_method))
    case ("midpoint")
       allocate (mci_midpoint_t :: mci)
    case ("vamp", "default")
       associate (var_list => global%get_var_list_ptr ())
         grid_par%threshold_calls = &
              var_list%get_ival (var_str ("threshold_calls"))
         grid_par%min_calls_per_channel = &
              var_list%get_ival (var_str ("min_calls_per_channel"))
         grid_par%min_calls_per_bin = &
              var_list%get_ival (var_str ("min_calls_per_bin"))
         grid_par%min_bins = &
              var_list%get_ival (var_str ("min_bins"))
         grid_par%max_bins = &
              var_list%get_ival (var_str ("max_bins"))
         grid_par%stratified = &
              var_list%get_lval (var_str ("?stratified"))
         grid_par%use_vamp_equivalences = &
              var_list%get_lval (var_str ("?use_vamp_equivalences"))
         grid_par%channel_weights_power = &
              var_list%get_rval (var_str ("channel_weights_power"))
         grid_par%accuracy_goal = &
              var_list%get_rval (var_str ("accuracy_goal"))
         grid_par%error_goal = &
              var_list%get_rval (var_str ("error_goal"))
         grid_par%rel_error_goal = &
              var_list%get_rval (var_str ("relative_error_goal"))
         history_par%global = &
              var_list%get_lval (var_str ("?vamp_history_global"))
         history_par%global_verbose = &
              var_list%get_lval (var_str ("?vamp_history_global_verbose"))
         history_par%channel = &
              var_list%get_lval (var_str ("?vamp_history_channels"))
         history_par%channel_verbose = &
              var_list%get_lval (var_str ("?vamp_history_channels_verbose"))
         verbose = &
              var_list%get_lval (var_str ("?vamp_verbose"))
         check_grid_file = &
              var_list%get_lval (var_str ("?check_grid_file"))
         run_id = &
              var_list%get_sval (var_str ("$run_id"))
         rebuild_grids = &
              var_list%get_lval (var_str ("?rebuild_grids"))
         negative_weights = &
              var_list%get_lval (var_str ("?negative_weights"))
       end associate
       allocate (mci_vamp_t :: mci)
       select type (mci)
       type is (mci_vamp_t)
          call mci%set_grid_parameters (grid_par)
          if (run_id /= "") then
             call mci%set_grid_filename (process_id, run_id)
          else
             call mci%set_grid_filename (process_id)
          end if
          call mci%set_history_parameters (history_par)
          call mci%set_rebuild_flag (rebuild_grids, check_grid_file)
          mci%negative_weights = negative_weights
          mci%verbose = verbose
       end select
    case default
       call msg_fatal ("Integrator '" &
            // char (integration_method) // "' not implemented")
    end select
  end subroutine dispatch_mci
  
@ %def dispatch_mci
@
\subsection{Phase-space allocation}
Allocate a phase-space object according to the variable [[$phs_method]].
<<Dispatch: public>>=
  public :: dispatch_phs
<<Dispatch: procedures>>=
  subroutine dispatch_phs (phs, global, process_id, mapping_defaults, phs_par, &
                           phs_method_in)
    class(phs_config_t), allocatable, intent(inout) :: phs
    type(rt_data_t), intent(in) :: global
    type(string_t), intent(in) :: process_id
    type(mapping_defaults_t), intent(in), optional :: mapping_defaults
    type(phs_parameters_t), intent(in), optional :: phs_par
    type(string_t), intent(in), optional :: phs_method_in
    type(string_t) :: phs_method, phs_file, run_id
    logical :: use_equivalences, vis_channels, fatal_beam_decay
    integer :: u_phs
    logical :: exist
    if (present (phs_method_in)) then
       phs_method = phs_method_in
    else
       phs_method = &
            global%var_list%get_sval (var_str ("$phs_method"))
    end if
    phs_file = &
         global%var_list%get_sval (var_str ("$phs_file"))
    use_equivalences = &
         global%var_list%get_lval (var_str ("?use_vamp_equivalences"))
    vis_channels = &
         global%var_list%get_lval (var_str ("?vis_channels"))
    fatal_beam_decay = &
         global%var_list%get_lval (var_str ("?fatal_beam_decay"))
    run_id = &
         global%var_list%get_sval (var_str ("$run_id"))    
    select case (char (phs_method))
    case ("single")
       allocate (phs_single_config_t :: phs)
       if (vis_channels) then
          call msg_warning ("Visualizing phase space channels not " // &
               "available for method 'single'.")
       end if
    case ("fks")
      allocate (phs_fks_config_t :: phs)
    case ("wood", "default")
       allocate (phs_wood_config_t :: phs)
       select type (phs)
       type is (phs_wood_config_t)
          if (phs_file /= "") then
             inquire (file = char (phs_file), exist = exist)
             if (exist) then
                call msg_message ("Phase space: reading configuration from '" &
                     // char (phs_file) // "'")
                u_phs = free_unit ()
                open (u_phs, file = char (phs_file), &
                     action = "read", status = "old")
                call phs%set_input (u_phs)
             else
                call msg_fatal ("Phase space: configuration file '" &
                     // char (phs_file) // "' not found")
             end if
          end if
          if (present (phs_par)) &
               call phs%set_parameters (phs_par)
          if (use_equivalences) &
               call phs%enable_equivalences ()
          if (present (mapping_defaults)) &
               call phs%set_mapping_defaults (mapping_defaults)
          phs%vis_channels = vis_channels
          phs%fatal_beam_decay = fatal_beam_decay
          phs%os_data = global%os_data
          phs%run_id = run_id
       end select
    case default
       call msg_fatal ("Phase space: parameterization method '" &
            // char (phs_method) // "' not implemented")
    end select
  end subroutine dispatch_phs
  
@ %def dispatch_phs
@
\subsection{FKS parameter}
Initialize parameters used to optimize FKS calculations.
<<Dispatch: public>>=
  public :: dispatch_fks
<<Dispatch: procedures>>=
  subroutine dispatch_fks (fks_template, global)
    type(fks_template_t), intent(inout) :: fks_template
    type(rt_data_t), intent(in) :: global
    real(default) :: fks_dij_exp1, fks_dij_exp2
    integer :: fks_mapping_type
    
    fks_dij_exp1 = &
         global%var_list%get_rval (var_str ("fks_dij_exp1"))
    fks_dij_exp2 = &
         global%var_list%get_rval (var_str ("fks_dij_exp2")) 
    fks_mapping_type = &
         global%var_list%get_ival (var_str ("fks_mapping_type"))

    call fks_template%set_dij_exp (fks_dij_exp1, fks_dij_exp2)
    call fks_template%set_mapping_type (fks_mapping_type)
    
  end subroutine dispatch_fks

@ %def dispatch_fks
@
\subsection{Random-number generator}
Allocate a random-number generator factory according to the variable
[[$rng_method]], using the current seed in the global record.  We take
only the lower 15 bits of the seed, so the actual value fits into a
positive 16-bit signed integer.

Since we want to guarantee that all random-number generators in a run
are independent, we increment the global seed by one after creating
the rng factory.  If the user wants to have identical sequences, he
can always set the seed manually, before it is used.
<<Dispatch: public>>=
  public :: dispatch_rng_factory
<<Dispatch: procedures>>=
  subroutine dispatch_rng_factory (rng_factory, global, local_input)
    class(rng_factory_t), allocatable, intent(inout) :: rng_factory
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), intent(in), target, optional :: local_input
    type(rt_data_t), pointer :: local
    type(string_t) :: rng_method
    integer :: seed
    character(30) :: buffer
    integer(i16) :: s
    if (present (local_input)) then
       local => local_input
    else
       local => global
    end if
    rng_method = &
         local%var_list%get_sval (var_str ("$rng_method"))
    seed = &
         local%var_list%get_ival (var_str ("seed"))
    s = mod (seed, 32768)
    select case (char (rng_method))
    case ("unit_test")
       allocate (rng_test_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing Test random-number generator")
    case ("tao")
       allocate (rng_tao_factory_t :: rng_factory)
       call msg_message ("RNG: Initializing TAO random-number generator")       
    case default
       call msg_fatal ("Random-number generator '" &
            // char (rng_method) // "' not implemented")
    end select
    write (buffer, "(I0)")  s
    call msg_message ("RNG: Setting seed for random-number generator to " &
            // trim (buffer))
    call rng_factory%init (s)
    call var_list_set_int (global%var_list, var_str ("seed"), seed + 1, &
         is_known = .true.)
  end subroutine dispatch_rng_factory
  
@ %def dispatch_rng_factory
@
\subsection{Structure function configuration data}
This data type is a container for transferring structure-function
specific data from the [[dispatch_sf_data]] to the
[[dispatch_sf_channels]] subroutine.
<<Dispatch: public>>=
  public :: sf_prop_t
<<Dispatch: types>>=
  type :: sf_prop_t
     real(default), dimension(2) :: isr_eps = 1
  end type sf_prop_t
  
@ %def sf_prop_t
@
Allocate a structure-function configuration object according to the
[[sf_method]] string.

The [[sf_prop]] object can be used to transfer structure-function
specific data up and to the [[dispatch_sf_channels]] subroutine below,
so they can be used for particular mappings.

The [[global]] object is intent(inout) because the RNG generator seed may change
during initialization.

The [[pdg_in]] array is the array of incoming flavors, corresponding
to the upstream structure function or the beam array.  This will be
checked for the structure function in question and replaced by the
outgoing flavors.  The [[pdg_prc]] array is the array of incoming
flavors (beam index, component index) for the hard process.
<<Dispatch: public>>=
  public :: dispatch_sf_data
<<Dispatch: procedures>>=
  subroutine dispatch_sf_data (data, sf_method, i_beam, sf_prop, global, &
       pdg_in, pdg_prc)
    class(sf_data_t), allocatable, intent(inout) :: data
    type(string_t), intent(in) :: sf_method
    integer, dimension(:), intent(in) :: i_beam
    type(pdg_array_t), dimension(:), intent(inout) :: pdg_in
    type(pdg_array_t), dimension(:,:), intent(in) :: pdg_prc
    type(sf_prop_t), intent(inout) :: sf_prop
    type(rt_data_t), intent(inout) :: global
    type(model_t), pointer :: model
    type(pdg_array_t), dimension(:), allocatable :: pdg_out
    real(default) :: sqrts, isr_alpha, isr_q_max, isr_mass
    integer :: isr_order
    logical :: isr_recoil
    real(default) :: epa_alpha, epa_x_min, epa_q_min, epa_e_max, epa_mass
    logical :: epa_recoil
    real(default) :: ewa_x_min, ewa_pt_max, ewa_mass
    logical :: ewa_keep_momentum, ewa_keep_energy   
    type(pdg_array_t), dimension(:), allocatable :: pdg_prc1
    integer :: ewa_id
    type(string_t) :: pdf_name
    type(string_t) :: lhapdf_dir, lhapdf_file
    type(string_t), dimension(13) :: lhapdf_photon_sets
    integer :: lhapdf_member, lhapdf_photon_scheme
    logical :: hoppet_b_matching
    class(rng_factory_t), allocatable :: rng_factory
    logical :: circe1_photon1, circe1_photon2, circe1_generate
    real(default) :: circe1_sqrts, circe1_eps
    integer :: circe1_version, circe1_chattiness, &
         circe1_revision
    character(6) :: circe1_accelerator
    logical :: circe2_polarized
    type(string_t) :: circe2_design, circe2_file
    logical :: beam_events_warn_eof
    type(string_t) :: beam_events_dir, beam_events_file
    logical :: escan_normalize
    lhapdf_photon_sets = [var_str ("DOG0.LHgrid"), var_str ("DOG1.LHgrid"), &
         var_str ("DGG.LHgrid"), var_str ("LACG.LHgrid"), &
         var_str ("GSG0.LHgrid"), var_str ("GSG1.LHgrid"), &
         var_str ("GSG960.LHgrid"), var_str ("GSG961.LHgrid"), &
         var_str ("GRVG0.LHgrid"), var_str ("GRVG1.LHgrid"), &
         var_str ("ACFGPG.LHgrid"), var_str ("WHITG.LHgrid"), &
         var_str ("SASG.LHgrid")]
    model => global%model
    sqrts = global%get_sqrts ()
    associate (var_list => global%get_var_list_ptr ())
      select case (char (sf_method))
      case ("sf_test_0", "sf_test_1")
         allocate (sf_test_data_t :: data)
         select type (data)
         type is (sf_test_data_t)
            select case (char (sf_method))
            case ("sf_test_0");  call data%init (model, pdg_in(i_beam(1)))
            case ("sf_test_1");  call data%init (model, pdg_in(i_beam(1)), &
                 mode = 1)
            end select
         end select
      case ("pdf_builtin")
         allocate (pdf_builtin_data_t :: data)
         select type (data)
         type is (pdf_builtin_data_t)
            pdf_name = &
                 var_list%get_sval (var_str ("$pdf_builtin_set"))
            hoppet_b_matching = &
                 var_list%get_lval (var_str ("?hoppet_b_matching"))
            call data%init ( &
                 model, pdg_in(i_beam(1)), &
                 name = pdf_name, &
                 path = global%os_data%pdf_builtin_datapath, &
                 hoppet_b_matching = hoppet_b_matching)
         end select
      case ("pdf_builtin_photon")
         call msg_fatal ("Currently, there are no photon PDFs built into WHIZARD,", &
              [var_str ("for the photon content inside a proton or neutron use"), &
               var_str ("the 'lhapdf_photon' structure function.")])
      case ("lhapdf")
         allocate (lhapdf_data_t :: data)
         if (pdg_array_get (pdg_in(i_beam(1)), 1) == PHOTON) then
            call msg_fatal ("The 'lhapdf' structure is intended only for protons and", &
                 [var_str ("pions, please use 'lhapdf_photon' for photon beams.")])
         end if         
         lhapdf_dir = &
              var_list%get_sval (var_str ("$lhapdf_dir"))  
         lhapdf_file = &
              var_list%get_sval (var_str ("$lhapdf_file")) 
         lhapdf_member = &
              var_list%get_ival (var_str ("lhapdf_member"))
         lhapdf_photon_scheme = &
              var_list%get_ival (var_str ("lhapdf_photon_scheme"))
         hoppet_b_matching = &
              var_list%get_lval (var_str ("?hoppet_b_matching"))
         select type (data)
         type is (lhapdf_data_t)
            call data%init &
                 (model, pdg_in(i_beam(1)), &
                  lhapdf_dir, lhapdf_file, lhapdf_member, &
                  lhapdf_photon_scheme, hoppet_b_matching)
         end select
      case ("lhapdf_photon")
         allocate (lhapdf_data_t :: data)
         if (pdg_array_get_length (pdg_in(i_beam(1))) /= 1 .or. &
              pdg_array_get (pdg_in(i_beam(1)), 1) /= PHOTON) then
            call msg_fatal ("The 'lhapdf_photon' structure function is exclusively for", &
                 [var_str ("photon PDFs, i.e. for photons as beam particles")])
         end if
         lhapdf_dir = &
              var_list%get_sval (var_str ("$lhapdf_dir"))  
         lhapdf_file = &
              var_list%get_sval (var_str ("$lhapdf_photon_file")) 
         lhapdf_member = &
              var_list%get_ival (var_str ("lhapdf_member"))
         lhapdf_photon_scheme = &
              var_list%get_ival (var_str ("lhapdf_photon_scheme"))
         if (.not. any (lhapdf_photon_sets == lhapdf_file)) then
            call msg_fatal ("This PDF set is not supported or not " // & 
                 "intended for photon beams.")
         end if
         select type (data)
         type is (lhapdf_data_t)
            call data%init &
                 (model, pdg_in(i_beam(1)), &
                  lhapdf_dir, lhapdf_file, lhapdf_member, &
                  lhapdf_photon_scheme)
         end select         
      case ("isr")
         allocate (isr_data_t :: data)
         isr_alpha = &
              var_list%get_rval (var_str ("isr_alpha"))
         if (isr_alpha == 0) then
            isr_alpha = (var_list%get_rval (var_str ("ee"))) &
                 ** 2 / (4 * PI)
         end if
         isr_q_max = &
              var_list%get_rval (var_str ("isr_q_max"))
         if (isr_q_max == 0) then
            isr_q_max = sqrts
         end if
         isr_mass   = var_list%get_rval (var_str ("isr_mass"))
         isr_order  = var_list%get_ival (var_str ("isr_order"))
         isr_recoil = var_list%get_lval (var_str ("?isr_recoil")) 
         select type (data)
         type is (isr_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), isr_alpha, isr_q_max, &
                 isr_mass, isr_order, isr_recoil)
            call data%check ()
            sf_prop%isr_eps(i_beam(1)) = data%get_eps ()
         end select
      case ("epa")
         allocate (epa_data_t :: data)
         epa_alpha = var_list%get_rval (var_str ("epa_alpha"))
         if (epa_alpha == 0) then
            epa_alpha = (var_list%get_rval (var_str ("ee"))) &
                 ** 2 / (4 * PI)
         end if         
         epa_x_min = var_list%get_rval (var_str ("epa_x_min"))
         epa_q_min = var_list%get_rval (var_str ("epa_q_min"))
         epa_e_max = var_list%get_rval (var_str ("epa_e_max"))
         if (epa_e_max == 0) then
            epa_e_max = sqrts
         end if
         epa_mass   = var_list%get_rval (var_str ("epa_mass"))
         epa_recoil = var_list%get_lval (var_str ("?epa_recoil"))
         select type (data)            
         type is (epa_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), epa_alpha, epa_x_min, &
                 epa_q_min, epa_e_max, epa_mass, epa_recoil)
            call data%check ()
         end select
      case ("ewa")
         allocate (ewa_data_t :: data)
         allocate (pdg_prc1 (size (pdg_prc, 2)))
         pdg_prc1 = pdg_prc(i_beam(1),:)
         if (any (pdg_array_get_length (pdg_prc1) /= 1) &
              .or. any (pdg_prc1 /= pdg_prc1(1))) then
            call msg_fatal &
                 ("EWA: process incoming particle (W/Z) must be unique")
         end if
         ewa_id = abs (pdg_array_get (pdg_prc1(1), 1))
         ewa_x_min = var_list%get_rval (var_str ("ewa_x_min"))
         ewa_pt_max = var_list%get_rval (var_str ("ewa_pt_max")) 
         if (ewa_pt_max == 0) then
            ewa_pt_max = sqrts
         end if
         ewa_mass = var_list%get_rval (var_str ("ewa_mass"))  
         ewa_keep_momentum = var_list%get_lval (&
              var_str ("?ewa_keep_momentum"))
         ewa_keep_energy = var_list%get_lval (&
              var_str ("?ewa_keep_energy"))                  
         if (ewa_keep_momentum .and. ewa_keep_energy) &
              call msg_fatal (" EWA cannot conserve both energy " &
                 // "and momentum.")          
         select type (data)
         type is (ewa_data_t)
            call data%init &
                 (model, pdg_in (i_beam(1)), ewa_x_min, &
                 ewa_pt_max, sqrts, ewa_keep_momentum, &
                 ewa_keep_energy, ewa_mass)
            call data%set_id (ewa_id)
            call data%check ()
         end select
      case ("circe1")
         allocate (circe1_data_t :: data)
         select type (data)
         type is (circe1_data_t)
            circe1_photon1 = &
                 var_list%get_lval (var_str ("?circe1_photon1"))	
            circe1_photon2 = &
                 var_list%get_lval (var_str ("?circe1_photon2"))	
            circe1_sqrts = &
                 var_list%get_rval (var_str ("circe1_sqrts"))
            circe1_eps = &
                 var_list%get_rval (var_str ("circe1_eps"))
            if (circe1_sqrts <= 0)  circe1_sqrts = sqrts
            circe1_generate = &
                 var_list%get_lval (var_str ("?circe1_generate"))
            circe1_version = &
                 var_list%get_ival (var_str ("circe1_ver"))
            circe1_revision = &
                 var_list%get_ival (var_str ("circe1_rev"))
            circe1_accelerator = &
                 char (var_list%get_sval (var_str ("$circe1_acc")))
            circe1_chattiness = &
                 var_list%get_ival (var_str ("circe1_chat"))
            call data%init (model, pdg_in, circe1_sqrts, circe1_eps, &
                 [circe1_photon1, circe1_photon2], &
                 circe1_version, circe1_revision, circe1_accelerator, &
                 circe1_chattiness)
            if (circe1_generate) then
               call msg_message ("Circe1: activating generator mode")
               call dispatch_rng_factory (rng_factory, global)
               call data%set_generator_mode (rng_factory)
            end if
         end select
      case ("circe2")
         allocate (circe2_data_t :: data)
         select type (data)
         type is (circe2_data_t)
            circe2_polarized = &
                 var_list%get_lval (var_str ("?circe2_polarized"))
            circe2_file = &
                 var_list%get_sval (var_str ("$circe2_file"))
            circe2_design = &
                 var_list%get_sval (var_str ("$circe2_design"))
            call data%init (global%os_data, model, pdg_in, sqrts, &
                 circe2_polarized, circe2_file, circe2_design)
            call msg_message ("Circe2: activating generator mode")
            call dispatch_rng_factory (rng_factory, global)
            call data%set_generator_mode (rng_factory)
         end select
      case ("beam_events")
         allocate (beam_events_data_t :: data)
         select type (data)
         type is (beam_events_data_t)
            beam_events_dir = global%os_data%whizard_beamsimpath
            beam_events_file = var_list%get_sval (&
                 var_str ("$beam_events_file"))
            beam_events_warn_eof = var_list%get_lval (&
                 var_str ("?beam_events_warn_eof"))
            call data%init (model, pdg_in, &
                    beam_events_dir, beam_events_file, beam_events_warn_eof)  
         end select
      case ("energy_scan")
         escan_normalize = &
              var_list%get_lval (var_str ("?energy_scan_normalize"))
         allocate (escan_data_t :: data)
         select type (data) 
         type is (escan_data_t)
            if (escan_normalize) then
               call data%init (model, pdg_in)  
            else
               call data%init (model, pdg_in, sqrts)  
            end if
         end select
      case default
         call msg_bug ("Structure function '" &
              // char (sf_method) // "' not implemented yet")
      end select
    end associate
    if (allocated (data)) then
       allocate (pdg_out (size (pdg_prc, 1)))
       call data%get_pdg_out (pdg_out)
       pdg_in(i_beam) = pdg_out
    end if
  end subroutine dispatch_sf_data
  
@ %def dispatch_sf_data
@ This is an auxiliary procedure, used by the beam-structure
expansion: tell for a given structure function name, whether it
corresponds to a pair spectrum ($n=2$), a single-particle structure
function ($n=1$), or nothing ($n=0$). Though [[energy_scan]] can
in principle also be a pair spectrum, it always has only one
parameter.
<<Dispatch: procedures>>=
  function strfun_mode (name) result (n)
    type(string_t), intent(in) :: name
    integer :: n
    select case (char (name))
    case ("none")
       n = 0
    case ("sf_test_0", "sf_test_1")
       n = 1
    case ("pdf_builtin","pdf_builtin_photon", &
          "lhapdf","lhapdf_photon")
       n = 1
    case ("isr","epa","ewa")
       n = 1
    case ("circe1", "circe2")
       n = 2
    case ("beam_events")
       n = 2
    case ("energy_scan")
       n = 2
    case default
       call msg_bug ("Structure function '" // char (name) &
            // "' not supported yet")
    end select
  end function strfun_mode
    
@ %def strfun_mode
@ Dispatch a whole structure-function chain, given beam data and beam
structure data.

This could be done generically, but we should look at the specific
combination of structure functions in order to select appropriate mappings.

The [[beam_structure]] argument gets copied because
we want to expand it to canonical form (one valid structure-function
entry per record) before proceeding further.

The [[pdg_prc]] argument is the array of incoming flavors.  The first
index is the beam index, the second one the process component index.
Each element is itself a PDG array, notrivial if there is a flavor sum
for the incoming state of this component.

The dispatcher is divided in two parts.  The first part configures the
structure function data themselves.  After this, we can configure the
phase space for the elementary process.
<<Dispatch: public>>=
  public :: dispatch_sf_config
<<Dispatch: procedures>>=
  subroutine dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    type(sf_config_t), dimension(:), allocatable, intent(out) :: sf_config
    type(sf_prop_t), intent(out) :: sf_prop
    type(rt_data_t), intent(inout) :: global
    type(beam_structure_t) :: beam_structure
    class(sf_data_t), allocatable :: sf_data
    type(pdg_array_t), dimension(:,:), intent(in) :: pdg_prc
    type(string_t), dimension(:), allocatable :: prt_in
    type(pdg_array_t), dimension(:), allocatable :: pdg_in
    type(flavor_t) :: flv_in
    integer :: n_beam, n_record, i
    beam_structure = global%beam_structure
    call beam_structure%expand (strfun_mode)
    n_record = beam_structure%get_n_record ()
    allocate (sf_config (n_record))
    n_beam = beam_structure%get_n_beam ()
    if (n_beam > 0) then
       allocate (prt_in (n_beam), pdg_in (n_beam))
       prt_in = beam_structure%get_prt ()
       do i = 1, n_beam
          call flv_in%init (prt_in(i), global%model)
          pdg_in(i) = flv_in%get_pdg ()
       end do
    else
       n_beam = size (pdg_prc, 1)
       allocate (pdg_in (n_beam))
       pdg_in = pdg_prc(:,1)
    end if
    do i = 1, n_record
       call dispatch_sf_data (sf_data, &
            beam_structure%get_name (i), &
            beam_structure%get_i_entry (i), &
            sf_prop, global, pdg_in, pdg_prc)
       call sf_config(i)%init (beam_structure%get_i_entry (i), sf_data)
       deallocate (sf_data)
    end do
  end subroutine dispatch_sf_config
    
@ %def dispatch_sf_config
@ The second part configures channel mappings, using some conditions
from the phase space configuration.  If there are no structure
functions, we enable a default setup with a single (dummy)
structure-function channel.  Otherwise, we look at the channel
collection that we got from the phase-space configuration step.  Each
entry should be translated into an independent structure-function
channel, where typically there is one default entry, which could be
mapped using a standard s-channel mapping if the structure function
setup recommends this, and other entries with s-channel resonances.
The latter need to be translated into global mappings from the
structure-function chain.
<<Dispatch: public>>=
  public :: dispatch_sf_channels
<<Dispatch: procedures>>=
  subroutine dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    type(sf_channel_t), dimension(:), allocatable, intent(out) :: sf_channel
    type(string_t), intent(out) :: sf_string
    type(sf_prop_t), intent(in) :: sf_prop
    type(phs_channel_collection_t), intent(in) :: coll
    type(rt_data_t), intent(in) :: global
    type(beam_structure_t) :: beam_structure
    class(channel_prop_t), allocatable :: prop
    integer :: n_strfun, n_sf_channel, i
    logical :: sf_allow_s_mapping, circe1_map, circe1_generate
    logical :: s_mapping_enable, endpoint_mapping, power_mapping
    integer, dimension(:), allocatable :: s_mapping, single_mapping
    real(default) :: sqrts, s_mapping_power
    real(default) :: circe1_mapping_slope, endpoint_mapping_slope
    real(default) :: power_mapping_eps
    sqrts = global%get_sqrts ()
    beam_structure = global%beam_structure
    call beam_structure%expand (strfun_mode)
    n_strfun = beam_structure%get_n_record ()
    sf_string = beam_structure%to_string (sf_only = .true.)
    sf_allow_s_mapping = &
         global%var_list%get_lval (var_str ("?sf_allow_s_mapping"))
    circe1_generate = &
         global%var_list%get_lval (var_str ("?circe1_generate"))
    circe1_map = &
         global%var_list%get_lval (var_str ("?circe1_map"))
    circe1_mapping_slope = &
         global%var_list%get_rval (var_str ("circe1_mapping_slope"))
    s_mapping_enable = .false.
    s_mapping_power = 1
    endpoint_mapping = .false.
    endpoint_mapping_slope = 1
    power_mapping = .false.
    select case (char (sf_string))
    case ("", "[any particles]")
    case ("pdf_builtin, none", &
         "pdf_builtin_photon, none", &
         "none, pdf_builtin", &
         "none, pdf_builtin_photon", &
         "lhapdf, none", &
         "lhapdf_photon, none", &
         "none, lhapdf", &
         "none, lhapdf_photon")
    case ("pdf_builtin, none => none, pdf_builtin", &
          "pdf_builtin, none => none, pdf_builtin_photon", &
          "pdf_builtin_photon, none => none, pdf_builtin", &
          "pdf_builtin_photon, none => none, pdf_builtin_photon", &
          "lhapdf, none => none, lhapdf", &
          "lhapdf, none => none, lhapdf_photon", &
          "lhapdf_photon, none => none, lhapdf", &
          "lhapdf_photon, none => none, lhapdf_photon")
       allocate (s_mapping (2), source = [1, 2])
       s_mapping_enable = .true.
       s_mapping_power = 2
    case ("pdf_builtin, none => none, pdf_builtin => epa, none => none, epa", &
          "pdf_builtin, none => none, pdf_builtin => ewa, none => none, ewa", &
          "pdf_builtin, none => none, pdf_builtin => ewa, none => none, epa", &
          "pdf_builtin, none => none, pdf_builtin => epa, none => none, ewa")
       allocate (s_mapping (2), source = [1, 2])
       s_mapping_enable = .true.
       s_mapping_power = 2
    case ("isr, none", &
         "none, isr")
       allocate (single_mapping (1), source = [1])
    case ("isr, none => none, isr")
       allocate (s_mapping (2), source = [1, 2])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("isr, none => none, isr => epa, none => none, epa", &
          "isr, none => none, isr => ewa, none => none, ewa", &
          "isr, none => none, isr => ewa, none => none, epa", &
          "isr, none => none, isr => epa, none => none, ewa")
       allocate (s_mapping (2), source = [1, 2])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("circe1 => isr, none => none, isr => epa, none => none, epa", &
          "circe1 => isr, none => none, isr => ewa, none => none, ewa", &
          "circe1 => isr, none => none, isr => ewa, none => none, epa", &
          "circe1 => isr, none => none, isr => epa, none => none, ewa")
       if (circe1_generate) then
          allocate (s_mapping (2), source = [2, 3])
       else
          allocate (s_mapping (3), source = [1, 2, 3])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       end if
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)       
    case ("pdf_builtin, none => none, isr", &
         "pdf_builtin_photon, none => none, isr", &
         "lhapdf, none => none, isr", &
         "lhapdf_photon, none => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("isr, none => none, pdf_builtin", &
         "isr, none => none, pdf_builtin_photon", &
         "isr, none => none, lhapdf", &
         "isr, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])
    case ("epa, none", &
          "none, epa")
       allocate (single_mapping (1), source = [1])
    case ("epa, none => none, epa")
       allocate (single_mapping (2), source = [1, 2])
    case ("epa, none => none, isr", &
         "isr, none => none, epa", &
         "ewa, none => none, isr", &
         "isr, none => none, ewa")
       allocate (single_mapping (2), source = [1, 2])
    case ("pdf_builtin, none => none, epa", &
         "pdf_builtin_photon, none => none, epa", &
         "lhapdf, none => none, epa", &
         "lhapdf_photon, none => none, epa")
       allocate (single_mapping (1), source = [2])
    case ("pdf_builtin, none => none, ewa", &
         "pdf_builtin_photon, none => none, ewa", &
         "lhapdf, none => none, ewa", &
         "lhapdf_photon, none => none, ewa")
       allocate (single_mapping (1), source = [2])       
    case ("epa, none => none, pdf_builtin", &
         "epa, none => none, pdf_builtin_photon", &
         "epa, none => none, lhapdf", &
         "epa, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])
    case ("ewa, none => none, pdf_builtin", &
         "ewa, none => none, pdf_builtin_photon", &
         "ewa, none => none, lhapdf", &
         "ewa, none => none, lhapdf_photon")
       allocate (single_mapping (1), source = [1])       
    case ("ewa, none", &
          "none, ewa")
       allocate (single_mapping (1), source = [1])
    case ("ewa, none => none, ewa")
       allocate (single_mapping (2), source = [1, 2])
    case ("energy_scan, none => none, energy_scan")
       allocate (s_mapping (2), source = [1, 2])
    case ("sf_test_1, none => none, sf_test_1")
       allocate (s_mapping (2), source = [1, 2])
    case ("circe1")
       if (circe1_generate) then
          !!! no mapping
       else if (circe1_map) then
          allocate (s_mapping (1), source = [1])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       else
          allocate (s_mapping (1), source = [1])
          s_mapping_enable = .true.
       end if
    case ("circe1 => isr, none => none, isr")
       if (circe1_generate) then
          allocate (s_mapping (2), source = [2, 3])
       else
          allocate (s_mapping (3), source = [1, 2, 3])
          endpoint_mapping = .true.
          endpoint_mapping_slope = circe1_mapping_slope
       end if
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("circe1 => isr, none", &
         "circe1 => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("circe1 => epa, none => none, epa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => ewa, none => none, ewa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else 
          call msg_fatal ("Circe/EWA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => epa, none", &
         "circe1 => none, epa")
       if (circe1_generate) then
          allocate (single_mapping (1), source = [2])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe1 => epa, none => none, isr", &
         "circe1 => isr, none => none, epa", &
         "circe1 => ewa, none => none, isr", &
         "circe1 => isr, none => none, ewa")
       if (circe1_generate) then
          allocate (single_mapping (2), source = [2, 3])
       else
          call msg_fatal ("Circe/EPA: supported with ?circe1_generate=true &
               &only")
       end if
    case ("circe2", &
         "beam_events")
       !!! no mapping
    case ("circe2 => isr, none => none, isr", &
       "beam_events => isr, none => none, isr")
       allocate (s_mapping (2), source = [2, 3])
       power_mapping = .true.
       power_mapping_eps = minval (sf_prop%isr_eps)
    case ("circe2 => isr, none", &
         "circe2 => none, isr", &
         "beam_events => isr, none", &
         "beam_events => none, isr")
       allocate (single_mapping (1), source = [2])
    case ("circe2 => epa, none => none, epa", &
         "beam_events => epa, none => none, epa")
       allocate (single_mapping (2), source = [2, 3])
    case ("circe2 => epa, none", &
         "circe2 => none, epa", &
         "circe2 => ewa, none", &
         "circe2 => none, ewa", &
         "beam_events => epa, none", &
         "beam_events => none, epa", &
         "beam_events => ewa, none", &
         "beam_events => none, ewa")
       allocate (single_mapping (1), source = [2])
    case ("circe2 => epa, none => none, isr", &
         "circe2 => isr, none => none, epa", &
         "circe2 => ewa, none => none, isr", &
         "circe2 => isr, none => none, ewa", &
         "beam_events => epa, none => none, isr", &
         "beam_events => isr, none => none, epa", &
         "beam_events => ewa, none => none, isr", &
         "beam_events => isr, none => none, ewa")
       allocate (single_mapping (2), source = [2, 3])
    case ("energy_scan")
    case default
       call msg_fatal ("Beam structure: " &
            // char (sf_string) // " not supported")
    end select
    if (sf_allow_s_mapping .and. coll%n > 0) then
       n_sf_channel = coll%n
       allocate (sf_channel (n_sf_channel))
       do i = 1, n_sf_channel
          call sf_channel(i)%init (n_strfun)
          if (allocated (single_mapping)) then
             call sf_channel(i)%activate_mapping (single_mapping)
          end if
          if (allocated (prop))  deallocate (prop)
          call coll%get_entry (i, prop)
          if (allocated (prop)) then
             if (endpoint_mapping .and. power_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_eir_mapping (s_mapping, &
                        a = endpoint_mapping_slope, eps = power_mapping_eps, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_eio_mapping (s_mapping, &
                        a = endpoint_mapping_slope, eps = power_mapping_eps, &
                        m = prop%mass / sqrts)
                end select
             else if (endpoint_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_epr_mapping (s_mapping, &
                        a = endpoint_mapping_slope, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_epo_mapping (s_mapping, &
                        a = endpoint_mapping_slope, &
                        m = prop%mass / sqrts)
                end select
             else if (power_mapping) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_ipr_mapping (s_mapping, &
                        eps = power_mapping_eps, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_ipo_mapping (s_mapping, &
                        eps = power_mapping_eps, &
                        m = prop%mass / sqrts)
                end select
             else if (allocated (s_mapping)) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_res_mapping (s_mapping, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_os_mapping (s_mapping, &
                        m = prop%mass / sqrts)
                end select
             else if (allocated (single_mapping)) then
                select type (prop)
                type is (resonance_t)
                   call sf_channel(i)%set_res_mapping (single_mapping, &
                        m = prop%mass / sqrts, w = prop%width / sqrts)
                type is (on_shell_t)
                   call sf_channel(i)%set_os_mapping (single_mapping, &
                        m = prop%mass / sqrts)
                end select
             end if
          else if (endpoint_mapping .and. power_mapping) then
             call sf_channel(i)%set_ei_mapping (s_mapping, &
                  a = endpoint_mapping_slope, eps = power_mapping_eps)
          else if (endpoint_mapping .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_ep_mapping (s_mapping, &
                  a = endpoint_mapping_slope)
          else if (power_mapping .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_ip_mapping (s_mapping, &
                  eps = power_mapping_eps)
          else if (s_mapping_enable .and. .not. allocated (single_mapping)) then
             call sf_channel(i)%set_s_mapping (s_mapping, &
                  power = s_mapping_power)
          end if
       end do
    else if (sf_allow_s_mapping) then
       allocate (sf_channel (1))
       call sf_channel(1)%init (n_strfun)
       if (allocated (single_mapping)) then
          call sf_channel(1)%activate_mapping (single_mapping)
       else if (endpoint_mapping .and. power_mapping) then
          call sf_channel(i)%set_ei_mapping (s_mapping, &
               a = endpoint_mapping_slope, eps = power_mapping_eps)
       else if (endpoint_mapping) then
          call sf_channel(1)%set_ep_mapping (s_mapping, &
                  a = endpoint_mapping_slope)
       else if (power_mapping) then
          call sf_channel(1)%set_ip_mapping (s_mapping, &
                  eps = power_mapping_eps)
       else if (s_mapping_enable) then
          call sf_channel(1)%set_s_mapping (s_mapping, &
               power = s_mapping_power)
       end if
    else
       allocate (sf_channel (1))
       call sf_channel(1)%init (n_strfun)
       if (allocated (single_mapping)) then
          call sf_channel(1)%activate_mapping (single_mapping)
       end if
    end if
  end subroutine dispatch_sf_channels
    
@ %def dispatch_sf_channels
@
\subsection{Event I/O stream}
<<Dispatch: public>>=
  public :: dispatch_eio
<<Dispatch: procedures>>=
  subroutine dispatch_eio (eio, method, global)
    class(eio_t), intent(inout), allocatable :: eio
    type(string_t), intent(in) :: method
    type(rt_data_t), intent(in) :: global
    logical :: check, keep_beams, keep_remnants, recover_beams
    logical :: use_alpha_s_from_file, use_scale_from_file
    logical :: write_sqme_prc, write_sqme_ref, write_sqme_alt
    type(string_t) :: lhef_version, lhef_extension, raw_version
    type(string_t) :: extension_default, debug_extension, extension_hepmc, &
         extension_lha, extension_hepevt, extension_ascii_short, &
         extension_ascii_long, extension_athena, extension_mokka, &
         extension_stdhep, extension_stdhep_up, extension_raw, &
         extension_hepevt_verb, extension_lha_verb, extension_lcio
    integer :: checkpoint
    logical :: show_process, show_transforms, show_decay, verbose, pacify
    select case (char (method))
    case ("raw")
       allocate (eio_raw_t :: eio)
       select type (eio)
       type is (eio_raw_t)
          check = &
               global%var_list%get_lval (var_str ("?check_event_file"))
          raw_version = &
               global%var_list%get_sval (var_str ("$event_file_version"))
          extension_raw = &
               global%var_list%get_sval (var_str ("$extension_raw"))
          call eio%set_parameters (check, raw_version, extension_raw)
       end select
    case ("checkpoint")
       allocate (eio_checkpoints_t :: eio)
       select type (eio)
       type is (eio_checkpoints_t)
          checkpoint = &
               global%var_list%get_ival (var_str ("checkpoint"))
          pacify = &
               global%var_list%get_lval (var_str ("?pacify"))
          call eio%set_parameters (checkpoint, blank = pacify)
       end select
    case ("lhef")
       allocate (eio_lhef_t :: eio)
       select type (eio)
       type is (eio_lhef_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          recover_beams = &
               global%var_list%get_lval (var_str ("?recover_beams"))
          use_alpha_s_from_file = &
               global%var_list%get_lval (var_str ("?use_alpha_s_from_file"))
          use_scale_from_file = &
               global%var_list%get_lval (var_str ("?use_scale_from_file"))
          lhef_version = &
               global%var_list%get_sval (var_str ("$lhef_version"))
          lhef_extension = &
               global%var_list%get_sval (var_str ("$lhef_extension"))
          write_sqme_prc = &
               global%var_list%get_lval (var_str ("?lhef_write_sqme_prc"))
          write_sqme_ref = &
               global%var_list%get_lval (var_str ("?lhef_write_sqme_ref"))
          write_sqme_alt = &
               global%var_list%get_lval (var_str ("?lhef_write_sqme_alt"))
          call eio%set_parameters ( &
               keep_beams, keep_remnants, recover_beams, &
               use_alpha_s_from_file, use_scale_from_file, &
               char (lhef_version), lhef_extension, &
               write_sqme_ref, write_sqme_prc, write_sqme_alt)
       end select
    case ("hepmc")
       allocate (eio_hepmc_t :: eio)
       select type (eio)
       type is (eio_hepmc_t)
          ! keep_beams = &
          !      global%var_list%get_lval (var_str ("?keep_beams"))
          use_alpha_s_from_file = &
               global%var_list%get_lval (var_str ("?use_alpha_s_from_file"))
          use_scale_from_file = &
               global%var_list%get_lval (var_str ("?use_scale_from_file"))
          recover_beams = &
               global%var_list%get_lval (var_str ("?recover_beams"))
          extension_hepmc = &
               global%var_list%get_sval (var_str ("$extension_hepmc"))          
          ! call eio%set_parameters (keep_beams, recover_beams, extension_hepmc)
          call eio%set_parameters (recover_beams, &
               use_alpha_s_from_file, use_scale_from_file, &
               extension_hepmc)
       end select
    case ("lcio")
       allocate (eio_lcio_t :: eio)
       select type (eio)
       type is (eio_lcio_t)
          ! keep_beams = &
          !      global%var_list%get_lval (var_str ("?keep_beams"))
          use_alpha_s_from_file = &
               global%var_list%get_lval (var_str ("?use_alpha_s_from_file"))
          use_scale_from_file = &
               global%var_list%get_lval (var_str ("?use_scale_from_file"))
          recover_beams = &
               global%var_list%get_lval (var_str ("?recover_beams"))
          extension_lcio = &
               global%var_list%get_sval (var_str ("$extension_lcio"))
          ! call eio%set_parameters &
          !      (keep_beams, keep_remnants, recover_beams, extension_lcio)
          call eio%set_parameters (recover_beams, &
               use_alpha_s_from_file, use_scale_from_file, &
               extension_lcio)
       end select       
    case ("stdhep")
       allocate (eio_stdhep_hepevt_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepevt_t)                   
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          use_alpha_s_from_file = &
               global%var_list%get_lval (var_str ("?use_alpha_s_from_file"))
          use_scale_from_file = &
               global%var_list%get_lval (var_str ("?use_scale_from_file"))
          recover_beams = &
               global%var_list%get_lval (var_str ("?recover_beams"))          
          extension_stdhep = &
               global%var_list%get_sval (var_str ("$extension_stdhep"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, recover_beams, &
                use_alpha_s_from_file, use_scale_from_file, extension_stdhep)
       end select
    case ("stdhep_up")
       allocate (eio_stdhep_hepeup_t :: eio)
       select type (eio)
       type is (eio_stdhep_hepeup_t)          
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          use_alpha_s_from_file = &
               global%var_list%get_lval (var_str ("?use_alpha_s_from_file"))
          use_scale_from_file = &
               global%var_list%get_lval (var_str ("?use_scale_from_file"))
          recover_beams = &
               global%var_list%get_lval (var_str ("?recover_beams"))          
          extension_stdhep_up = &
               global%var_list%get_sval (var_str ("$extension_stdhep_up")) 
          call eio%set_parameters (keep_beams, keep_remnants, &
               recover_beams, use_alpha_s_from_file, &
               use_scale_from_file, extension_stdhep_up)          
       end select       
    case ("ascii")   
       allocate (eio_ascii_ascii_t :: eio)
       select type (eio)
       type is (eio_ascii_ascii_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_default = &
               global%var_list%get_sval (var_str ("$extension_default"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_default)
       end select       
    case ("athena")   
       allocate (eio_ascii_athena_t :: eio)
       select type (eio)
       type is (eio_ascii_athena_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_athena = &
               global%var_list%get_sval (var_str ("$extension_athena"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_athena)
       end select              
    case ("debug")   
       allocate (eio_ascii_debug_t :: eio)
       select type (eio)
       type is (eio_ascii_debug_t)
          debug_extension = &
               global%var_list%get_sval (var_str ("$debug_extension"))          
          show_process = &
               global%var_list%get_lval (var_str ("?debug_process"))
          show_transforms = &
               global%var_list%get_lval (var_str ("?debug_transforms"))
          show_decay = &
               global%var_list%get_lval (var_str ("?debug_decay"))
          verbose = &
               global%var_list%get_lval (var_str ("?debug_verbose"))
          call eio%set_parameters ( &
               extension = debug_extension, &
               show_process = show_process, &
               show_transforms = show_transforms, &
               show_decay = show_decay, &
               verbose = verbose)
       end select
    case ("hepevt")   
       allocate (eio_ascii_hepevt_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_hepevt = &
               global%var_list%get_sval (var_str ("$extension_hepevt"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_hepevt)
       end select              
    case ("hepevt_verb")   
       allocate (eio_ascii_hepevt_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_hepevt_verb_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_hepevt_verb = &
               global%var_list%get_sval (var_str ("$extension_hepevt_verb"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_hepevt_verb)
       end select                     
    case ("lha")   
       allocate (eio_ascii_lha_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_lha = &
               global%var_list%get_sval (var_str ("$extension_lha"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_lha)
       end select                     
    case ("lha_verb")   
       allocate (eio_ascii_lha_verb_t :: eio)
       select type (eio)
       type is (eio_ascii_lha_verb_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_lha_verb = global%var_list%get_sval ( &
               var_str ("$extension_lha_verb"))          
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_lha_verb)
       end select                            
    case ("long")   
       allocate (eio_ascii_long_t :: eio)
       select type (eio)
       type is (eio_ascii_long_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_ascii_long = &
               global%var_list%get_sval (var_str ("$extension_ascii_long"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_ascii_long)
       end select              
    case ("mokka")   
       allocate (eio_ascii_mokka_t :: eio)
       select type (eio)
       type is (eio_ascii_mokka_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_mokka = &
               global%var_list%get_sval (var_str ("$extension_mokka"))          
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_mokka)
       end select                     
    case ("short")   
       allocate (eio_ascii_short_t :: eio)
       select type (eio)
       type is (eio_ascii_short_t)
          keep_beams = &
               global%var_list%get_lval (var_str ("?keep_beams"))
          keep_remnants = &
               global%var_list%get_lval (var_str ("?keep_remnants"))
          extension_ascii_short = &
               global%var_list%get_sval (var_str ("$extension_ascii_short"))
          call eio%set_parameters &
               (keep_beams, keep_remnants, extension_ascii_short)
       end select                     
    case ("weight_stream")
       allocate (eio_weights_t :: eio)
       select type (eio)
       type is (eio_weights_t)
          pacify = &
               global%var_list%get_lval (var_str ("?pacify"))
          call eio%set_parameters (pacify = pacify)       
       end select
    case default
       call msg_fatal ("Event I/O method '" // char (method) &
            // "' not implemented")
    end select
    call eio%set_fallback_model (global%fallback_model)
  end subroutine dispatch_eio
  
@ %def dispatch_eio
@
\subsection{QCD coupling}
Allocate the [[alpha]] (running coupling) component of the [[qcd]] block with
a concrete implementation, depending on the variable settings in the
[[global]] record.

If a fixed $\alpha_s$ is requested, we do not allocate the
[[qcd%alpha]] object.  In this case, the matrix element code will just take
the model parameter as-is, which implies fixed $\alpha_s$.  If the
object is allocated, the $\alpha_s$ value is computed and updated for
each matrix-element call.
<<Dispatch: public>>=
  public :: dispatch_qcd
<<Dispatch: procedures>>=
  subroutine dispatch_qcd (qcd, global)
    type(qcd_t), intent(inout) :: qcd
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    logical :: fixed, from_mz, from_pdf_builtin, from_lhapdf, from_lambda_qcd
    real(default) :: mz, alpha_val, lambda
    integer :: nf, order, lhapdf_member
    type(string_t) :: pdfset, lhapdf_dir, lhapdf_file
    var_list => global%get_var_list_ptr ()
    fixed = &
         var_list%get_lval (var_str ("?alpha_s_is_fixed"))
    from_mz = &
         var_list%get_lval (var_str ("?alpha_s_from_mz"))
    from_pdf_builtin = &
         var_list%get_lval (var_str ("?alpha_s_from_pdf_builtin"))
    from_lhapdf = &
         var_list%get_lval (var_str ("?alpha_s_from_lhapdf"))
    from_lambda_qcd = &
         var_list%get_lval (var_str ("?alpha_s_from_lambda_qcd"))
    pdfset = &
         var_list%get_sval (var_str ("$pdf_builtin_set"))    
    lambda = &
         var_list%get_rval (var_str ("lambda_qcd"))
    nf = &
         var_list%get_ival (var_str ("alpha_s_nf"))
    order = &
         var_list%get_ival (var_str ("alpha_s_order"))
    lhapdf_dir = &
         var_list%get_sval (var_str ("$lhapdf_dir"))
    lhapdf_file = &
         var_list%get_sval (var_str ("$lhapdf_file"))
    lhapdf_member = &
         var_list%get_ival (var_str ("lhapdf_member"))         
    var_list => global%get_var_list_ptr ()
    if (var_list%contains (var_str ("mZ"))) then
       mz = var_list%get_rval (var_str ("mZ"))
    else
       mz = MZ_REF
    end if
    if (var_list%contains (var_str ("alphas"))) then
       alpha_val = var_list%get_rval (var_str ("alphas"))
    else
       alpha_val = ALPHA_QCD_MZ_REF
    end if
    if (allocated (qcd%alpha))  deallocate (qcd%alpha)
    if (from_lhapdf .and. from_pdf_builtin) then
        call msg_fatal (" Mixing alphas evolution",  &
             [var_str (" from LHAPDF and builtin PDF is not permitted")])
    end if 
    select case (count ([from_mz, from_pdf_builtin, from_lhapdf, from_lambda_qcd]))
    case (0)
       if (fixed) then 
          allocate (alpha_qcd_fixed_t :: qcd%alpha)          
       else
          call msg_fatal ("QCD alpha: no calculation mode set")
       end if
    case (2:)
       call msg_fatal ("QCD alpha: calculation mode is ambiguous")
    case (1)
       if (fixed) then
          call msg_fatal ("QCD alpha: use '?alpha_s_is_fixed = false' for " // &
               "running alphas")          
       else if (from_mz) then
          allocate (alpha_qcd_from_scale_t :: qcd%alpha)
       else if (from_pdf_builtin) then
          allocate (alpha_qcd_pdf_builtin_t :: qcd%alpha)
       else if (from_lhapdf) then
          allocate (alpha_qcd_lhapdf_t :: qcd%alpha)
       else if (from_lambda_qcd) then
          allocate (alpha_qcd_from_lambda_t :: qcd%alpha)
       end if
       call msg_message ("QCD alpha: using a running strong coupling")
    end select
    select type (alpha => qcd%alpha)
    type is (alpha_qcd_fixed_t)
       alpha%val = alpha_val
    type is (alpha_qcd_from_scale_t)
       alpha%mu_ref = mz
       alpha%ref = alpha_val
       alpha%order = order
       alpha%nf = nf
    type is (alpha_qcd_from_lambda_t)
       alpha%lambda = lambda
       alpha%order = order
       alpha%nf = nf
    type is (alpha_qcd_pdf_builtin_t)
       call alpha%init (pdfset, &
            global%os_data%pdf_builtin_datapath)
    type is (alpha_qcd_lhapdf_t)
       call alpha%init (lhapdf_file, lhapdf_member, lhapdf_dir)
    end select
  end subroutine dispatch_qcd
  
@ %def dispatch_qcd
@
\subsection{Parton Shower}
Transfer the settings and parameters for shower and hadronization from
the [[global]] object to the [[shower_settings]] object.
<<Dispatch: procedures>>=
  subroutine dispatch_shower_settings (settings, global)
    type(shower_settings_t), intent(inout) :: settings
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    call settings%init (var_list)
  end subroutine dispatch_shower_settings

@ %def dispatch_shower_settings
@ If POWHEG matching is switched on, transfer the specific settings to
the corresponding variables.
<<Dispatch: procedures>>=
  subroutine dispatch_powheg (powheg, global, process_name)
    type(powheg_t), intent(inout) :: powheg 
    type(powheg_settings_t) :: settings
    type(rt_data_t), intent(in), target :: global
    type(string_t), intent(in) :: process_name
    type(var_list_t), pointer :: var_list    
    var_list => global%get_var_list_ptr ()
    call settings%init (var_list)
    call powheg%init (settings, process_name)
  end subroutine dispatch_powheg
@ 
\subsection{Event Transform}
An event transform is responsible for dressing a partonic event.
Since event transforms are not mutually exclusive but are
concatenated, we provide individual dispatchers for each of them.
<<Dispatch: public>>=
  public :: dispatch_evt_decay
<<Dispatch: procedures>>=
  subroutine dispatch_evt_decay (evt, global)
    class(evt_t), intent(out), pointer :: evt
    type(rt_data_t), intent(in) :: global
    logical :: allow_decays
    allow_decays = &
         global%var_list%get_lval (var_str ("?allow_decays"))
    if (allow_decays) then
       allocate (evt_decay_t :: evt)
       call msg_message ("Simulate: activating decays")
    else
       evt => null ()
    end if
  end subroutine dispatch_evt_decay

@ %def dispatch_evt_decay
@
<<Dispatch: public>>=
  public :: dispatch_evt_shower
<<Dispatch: procedures>>=
  subroutine dispatch_evt_shower (evt, global, process)
    class(evt_t), intent(out), pointer :: evt
    type(rt_data_t), intent(in), target :: global
    type(process_t), intent(in), optional, target :: process
    type(var_list_t), pointer :: var_list
    type(powheg_t) :: powheg
    type(string_t) :: lhapdf_file, lhapdf_dir, process_name
    integer :: lhapdf_member
    double precision :: xmin, xmax, q2min, q2max
    type(shower_settings_t) :: settings
    class(matching_settings_t), allocatable :: matching_settings
    external :: GetXminM, GetXmaxM, GetQ2minM, GetQ2maxM
    var_list => global%get_var_list_ptr ()
    process_name = ""
    lhapdf_dir = &
         var_list%get_sval (var_str ("$lhapdf_dir"))
    lhapdf_file = &
         var_list%get_sval (var_str ("$lhapdf_file"))
    lhapdf_member = &
         var_list%get_ival (var_str ("lhapdf_member"))
    allocate (evt_shower_t :: evt)
    call msg_message ("Simulate: activating parton shower")
    call dispatch_shower_settings (settings, global)
    if (present (process)) then
       process_name = process%get_id ()
       if (settings%powheg_matching) then
          call dispatch_powheg (powheg, global, process_name)
       end if
    end if
    if (settings%mlm_matching .and. settings%ckkw_matching) then
       call msg_fatal ("Both MLM and CKKW matching activated," // &
            LF // "     aborting simulation")
    end if
    select type (evt)
    type is (evt_shower_t)
       call evt%init &
            (settings, global%fallback_model, global%os_data, &
             powheg)
       if (settings%mlm_matching) then
          call msg_message ("Simulate: applying MLM matching")
          allocate (mlm_matching_settings_t :: evt%matching_settings)
          allocate (mlm_matching_data_t :: evt%data)
       end if
       if (settings%ckkw_matching) then
          call msg_warning ("Simulate: CKKW(-L) matching not yet supported")
          allocate (ckkw_matching_settings_t :: evt%matching_settings)
          allocate (ckkw_matching_data_t :: evt%data)
       end if
       if (allocated (evt%matching_settings)) &
            call evt%matching_settings%init (var_list)
       if (LHAPDF6_AVAILABLE) then
          call lhapdf_initialize &
               (1, lhapdf_dir, lhapdf_file, lhapdf_member, evt%pdf_data%pdf)
       end if
       if (present (process)) &
            call evt%setup_pdf &
            (process, global%beam_structure, lhapdf_member)
       select case (evt%settings%shower_type)
       case (SHOWER_ANALYTIC,SHOWER_KT_ORDERED)
          allocate (shower_t :: evt%shower)
       case (SHOWER_PYTHIA6_KT,SHOWER_PYTHIA6_ANGULAR)
          allocate (shower_pythia6_t :: evt%shower)
       case default
       end select
       call evt%shower%init (evt%settings, evt%pdf_data)
    end select
  end subroutine dispatch_evt_shower

@ %def dispatch_evt_shower
@
<<Dispatch: public>>=
  public :: dispatch_evt_hadrons
<<Dispatch: procedures>>=
  subroutine dispatch_evt_hadrons (evt, global, process)
    class(evt_t), intent(out), pointer :: evt
    type(rt_data_t), intent(in), target :: global
    type(process_t), intent(in), optional, target :: process
    logical :: allow_hadronization
    type(string_t) :: method
    type(var_list_t), pointer :: var_list
    type(shower_settings_t) :: settings
    var_list => global%get_var_list_ptr ()
    method = &
         var_list%get_sval (var_str ("$hadronization_method"))
    allocate (evt_hadrons_t :: evt)
    call msg_message ("Simulate: activating hadronization")
    call dispatch_shower_settings (settings, global)
    select type (evt)
    type is (evt_hadrons_t)
       call settings%init (var_list)
       call evt%init (settings, global%fallback_model, method)
    end select
  end subroutine dispatch_evt_hadrons

@ %def dispatch_evt_hadrons
@
\subsection{SLHA Interface}
This is a container for the settings for the SLHA Interface
<<Dispatch: public>>=
  public :: dispatch_slha
<<Dispatch: procedures>>=
  subroutine dispatch_slha (global, input, spectrum, decays)
    type(rt_data_t), intent(inout), target :: global
    logical, intent(out) :: input, spectrum, decays
    input = &
         global%var_list%get_lval (var_str ("?slha_read_input"))
    spectrum = &
         global%var_list%get_lval (var_str ("?slha_read_spectrum"))
    decays = &
         global%var_list%get_lval (var_str ("?slha_read_decays"))    
  end subroutine dispatch_slha

@ %def dispatch_slha  
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Dispatch: public>>=
  public :: dispatch_test
<<Dispatch: tests>>=
  subroutine dispatch_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Dispatch: execute tests>>
  end subroutine dispatch_test

@ %def dispatch_test
@
\subsubsection{Select type: process definition}
<<Dispatch: execute tests>>=
  call test (dispatch_1, "dispatch_1", &
       "process configuration method", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_1 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    
    write (u, "(A)")  "* Test output: dispatch_1"
    write (u, "(A)")  "*   Purpose: select process configuration method"
    write (u, "(A)")

    call global%global_init ()
    
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core_def as prc_test_def"

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    select type (core_def)
    type is (prc_test_def_t)
       call core_def%write (u)
    end select
    
    deallocate (core_def)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate core_def as omega_def"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    select type (core_def)
    type is (omega_omega_def_t)
       call core_def%write (u)
    end select
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_1"
    
  end subroutine dispatch_1
  
@ %def dispatch_1
@
\subsubsection{Select type: process core}
<<Dispatch: execute tests>>=
  call test (dispatch_2, "dispatch_2", &
       "process core", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_2 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    class(prc_core_t), allocatable :: core
    
    write (u, "(A)")  "* Test output: dispatch_2"
    write (u, "(A)")  "*   Purpose: select process configuration method"
    write (u, "(A)")  "             and allocate process core"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core as test_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)
    call dispatch_core (core, core_def)
    select type (core)
    type is (test_t)
       call core%write (u)
    end select
    
    deallocate (core)
    deallocate (core_def)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate core as prc_omega_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)

    call global%select_model (var_str ("Test"))

    call var_list_set_log (global%var_list, &
         var_str ("?helicity_selection_active"), &
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, &
         var_str ("helicity_selection_threshold"), &
         1e9_default, is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("helicity_selection_cutoff"), &
         10, is_known = .true.)
    
    call dispatch_core (core, core_def, &
         global%model, global%get_helicity_selection ())
    call core_def%allocate_driver (core%driver, var_str (""))

    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_2"
    
  end subroutine dispatch_2
  
@ %def dispatch_2
@
\subsubsection{Select type: integrator core}
<<Dispatch: execute tests>>=
  call test (dispatch_3, "dispatch_3", &
       "integration method", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_3 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(mci_t), allocatable :: mci
    type(string_t) :: process_id
    
    write (u, "(A)")  "* Test output: dispatch_3"
    write (u, "(A)")  "*   Purpose: select integration method"
    write (u, "(A)")

    call global%global_init ()
    process_id = "dispatch_3"

    write (u, "(A)")  "* Allocate MCI as midpoint_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("midpoint"), is_known = .true.)
    call dispatch_mci (mci, global, process_id)
    select type (mci)
    type is (mci_midpoint_t)
       call mci%write (u)
    end select

    call mci%final ()
    deallocate (mci)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate MCI as vamp_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("vamp"), is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("threshold_calls"), &
         1, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_calls_per_channel"), &
         2, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_calls_per_bin"), &
         3, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("min_bins"), &
         4, is_known = .true.)
    call var_list_set_int (global%var_list, var_str ("max_bins"), &
         5, is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?stratified"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call var_list_set_real (global%var_list, var_str ("channel_weights_power"),&
         4._default, is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_global_verbose"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_channels"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?vamp_history_channels_verbose"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?stratified"), &
         .false., is_known = .true.)

    call dispatch_mci (mci, global, process_id)
    select type (mci)
    type is (mci_vamp_t)
       call mci%write (u)
       call mci%write_history_parameters (u)
    end select

    call mci%final ()
    deallocate (mci)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate MCI as vamp_t, allow for negative weights"
    write (u, "(A)")    
    
    call var_list_set_string (global%var_list, &
         var_str ("$integration_method"), &
         var_str ("vamp"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?negative_weights"), &
         .true., is_known = .true.)
    
    call dispatch_mci (mci, global, process_id)
    select type (mci)       
    type is (mci_vamp_t)
       call mci%write (u)
       call mci%write_history_parameters (u)
    end select
    
    call mci%final ()
    deallocate (mci)
    
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_3"
    
  end subroutine dispatch_3
  
@ %def dispatch_3
@
\subsubsection{Select type: phase-space configuration object}
<<Dispatch: execute tests>>=
  call test (dispatch_4, "dispatch_4", &
       "phase-space configuration", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_4 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(phs_config_t), allocatable :: phs
    type(phs_parameters_t) :: phs_par
    type(mapping_defaults_t) :: mapping_defs
    
    write (u, "(A)")  "* Test output: dispatch_4"
    write (u, "(A)")  "*   Purpose: select phase-space configuration method"
    write (u, "(A)")

    call global%global_init ()

    write (u, "(A)")  "* Allocate PHS as phs_single_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_4"))
    call phs%write (u)

    call phs%final ()
    deallocate (phs)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate PHS as phs_wood_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_4"))
    call phs%write (u)
          
    call phs%final ()
    deallocate (phs)
    
    write (u, "(A)")
    write (u, "(A)")  "* Setting parameters for phs_wood_t"
    write (u, "(A)")        

    phs_par%m_threshold_s = 123
    phs_par%m_threshold_t = 456
    phs_par%t_channel = 42
    phs_par%off_shell = 17
    phs_par%keep_nonresonant = .false.    
    mapping_defs%energy_scale = 987
    mapping_defs%invariant_mass_scale = 654
    mapping_defs%momentum_transfer_scale = 321
    mapping_defs%step_mapping = .false.   
    mapping_defs%step_mapping_exp = .false.       
    mapping_defs%enable_s_mapping = .true.       
    call dispatch_phs (phs, global, var_str ("dispatch_4"), &
         mapping_defs, phs_par)    
    call phs%write (u)    
        
    call phs%final ()

    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_4"
    
  end subroutine dispatch_4
  
@ %def dispatch_4
@
\subsubsection{Select type: random number generator}
<<Dispatch: execute tests>>=
  call test (dispatch_5, "dispatch_5", &
       "random-number generator", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_5 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(rng_factory_t), allocatable :: rng_factory
    
    write (u, "(A)")  "* Test output: dispatch_5"
    write (u, "(A)")  "*   Purpose: select random-number generator"
    write (u, "(A)")

    call global%global_init ()

    write (u, "(A)")  "* Allocate RNG factory as rng_test_factory_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$rng_method"), &
         var_str ("unit_test"), is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("seed"), 1, is_known = .true.)
    call dispatch_rng_factory (rng_factory, global)
    call rng_factory%write (u)
    deallocate (rng_factory)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate RNG factory as rng_tao_factory_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$rng_method"), &
         var_str ("tao"), is_known = .true.)
    call dispatch_rng_factory (rng_factory, global)
    call rng_factory%write (u)
    deallocate (rng_factory)
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_5"
    
  end subroutine dispatch_5
  
@ %def dispatch_5
@
\subsubsection{Phase-space configuration with file}
<<Dispatch: execute tests>>=
  call test (dispatch_6, "dispatch_6", &
       "configure phase space using file", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_6 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(process_constants_t) :: process_data
    class(phs_config_t), allocatable :: phs
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: dispatch_6"
    write (u, "(A)")  "*   Purpose: select 'wood' phase-space &
         &for a test process"
    write (u, "(A)")  "*            and read phs configuration from file"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize a process"
    write (u, "(A)")

    call global%global_init ()

    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%select_model (var_str ("Test"))

    call syntax_phs_forest_init ()
    
    call init_test_process_data (var_str ("dispatch_6"), process_data)

    write (u, "(A)")  "* Write phase-space file"

    u_phs = free_unit ()
    open (u_phs, file = "dispatch_6.phs", action = "write", status = "replace")
    call write_test_phs_file (u_phs, var_str ("dispatch_6"))
    close (u_phs)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate PHS as phs_wood_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, &
         var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call var_list_set_string (global%var_list, &
         var_str ("$phs_file"), &
         var_str ("dispatch_6.phs"), is_known = .true.)
    call dispatch_phs (phs, global, var_str ("dispatch_6"))

    call phs%init (process_data, global%model)
    call phs%configure (sqrts = 1000._default)

    call phs%write (u)
    write (u, "(A)")
    select type (phs)
    type is (phs_wood_config_t)
       call phs%write_forest (u)
    end select

    call phs%final ()

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_6"
    
  end subroutine dispatch_6
  
@ %def dispatch_6
@
\subsubsection{Select type: structure-function data}
<<Dispatch: execute tests>>=
  call test (dispatch_7, "dispatch_7", &
       "structure-function data", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_7 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(string_t) :: prt, sf_method
    type(sf_prop_t) :: sf_prop
    class(sf_data_t), allocatable :: data
    type(pdg_array_t), dimension(1) :: pdg_in
    type(pdg_array_t), dimension(1,1) :: pdg_prc
    type(pdg_array_t), dimension(1) :: pdg_out
    integer, dimension(:), allocatable :: pdg1
    
    write (u, "(A)")  "* Test output: dispatch_7"
    write (u, "(A)")  "*   Purpose: select and configure &
         &structure function data"
    write (u, "(A)")

    call global%global_init ()
    
    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%select_model (var_str ("QCD"))
    
    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         14000._default, is_known = .true.)
    prt = "p"
    call global%beam_structure%init_sf ([prt, prt], [1])
    pdg_in = 2212
    
    write (u, "(A)")  "* Allocate data as sf_pdf_builtin_t"
    write (u, "(A)")

    sf_method = "pdf_builtin"
    call dispatch_sf_data &
         (data, sf_method, [1], sf_prop, global, pdg_in, pdg_prc)
    call data%write (u)

    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(A)")
    write (u, "(1x,A,99(1x,I0))")  "PDG(out) = ", pdg1

    deallocate (data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate data for different PDF set"
    write (u, "(A)")

    pdg_in = 2212
    
    call var_list_set_string (global%var_list, var_str ("$pdf_builtin_set"), &
         var_str ("CTEQ6M"), is_known = .true.)
    sf_method = "pdf_builtin"
    call dispatch_sf_data &
         (data, sf_method, [1], sf_prop, global, pdg_in, pdg_prc)
    call data%write (u)

    call data%get_pdg_out (pdg_out)
    pdg1 = pdg_out(1)
    write (u, "(A)")
    write (u, "(1x,A,99(1x,I0))")  "PDG(out) = ", pdg1

    deallocate (data)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_7"
    
  end subroutine dispatch_7
  
@ %def dispatch_7
@
\subsubsection{Beam structure}
<<Dispatch: execute tests>>=
  call test (dispatch_8, "dispatch_8", &
       "beam structure", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_8 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(os_data_t) :: os_data
    type(flavor_t), dimension(2) :: flv
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_prop_t) :: sf_prop
    type(sf_channel_t), dimension(:), allocatable :: sf_channel
    type(phs_channel_collection_t) :: coll
    type(string_t) :: sf_string
    integer :: i
    type(pdg_array_t), dimension (2,1) :: pdg_prc
    
    write (u, "(A)")  "* Test output: dispatch_8"
    write (u, "(A)")  "*   Purpose: configure a structure-function chain"
    write (u, "(A)")

    call global%global_init ()
    
    call os_data_init (os_data)
    call syntax_model_file_init ()
    call global%select_model (var_str ("QCD"))
    
    write (u, "(A)")  "* Allocate LHC beams with PDF builtin"
    write (u, "(A)")

    call flv(1)%init (PROTON, global%model)
    call flv(2)%init (PROTON, global%model)

    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         14000._default, is_known = .true.)
         
    call global%beam_structure%init_sf (flv%get_name (), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("pdf_builtin"))
    
    call dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    do i = 1, size (sf_config)
       call sf_config(i)%write (u)
    end do

    call dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    write (u, "(1x,A)")  "Mapping configuration:"
    do i = 1, size (sf_channel)
       write (u, "(2x)", advance = "no")
       call sf_channel(i)%write (u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Allocate ILC beams with CIRCE1"
    write (u, "(A)")

    call global%select_model (var_str ("QED"))
    call flv(1)%init ( ELECTRON, global%model)
    call flv(2)%init (-ELECTRON, global%model)

    call reset_interaction_counter ()
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         500._default, is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?circe1_generate"), &
         .false., is_known = .true.)
         
    call global%beam_structure%init_sf (flv%get_name (), [1])
    call global%beam_structure%set_sf (1, 1, var_str ("circe1"))
    
    call dispatch_sf_config (sf_config, sf_prop, global, pdg_prc)
    do i = 1, size (sf_config)
       call sf_config(i)%write (u)
    end do

    call dispatch_sf_channels (sf_channel, sf_string, sf_prop, coll, global)
    write (u, "(1x,A)")  "Mapping configuration:"
    do i = 1, size (sf_channel)
       write (u, "(2x)", advance = "no")
       call sf_channel(i)%write (u)
    end do

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_8"
    
  end subroutine dispatch_8
  
@ %def dispatch_8
@
\subsubsection{Event I/O}
<<Dispatch: execute tests>>=
  call test (dispatch_9, "dispatch_9", &
       "event I/O", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_9 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(eio_t), allocatable :: eio
    
    write (u, "(A)")  "* Test output: dispatch_9"
    write (u, "(A)")  "*   Purpose: allocate an event I/O (eio) stream"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    
    write (u, "(A)")  "* Allocate as raw"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("raw"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as checkpoints:"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("checkpoint"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as LHEF:"
    write (u, "(A)")
    
    call var_list_set_string (global%var_list, var_str ("$lhef_extension"), &
         var_str ("lhe_custom"), is_known = .true.)
    call dispatch_eio (eio, var_str ("lhef"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as HepMC:"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("hepmc"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as weight_stream"
    write (u, "(A)")
    
    call dispatch_eio (eio, var_str ("weight_stream"), global)

    call eio%write (u)

    call eio%final ()
    deallocate (eio)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate as debug format"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?debug_verbose"), &
         .false., is_known = .true.)
    call dispatch_eio (eio, var_str ("debug"), global)

    call eio%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_9"
    
  end subroutine dispatch_9
  
@ %def dispatch_9
@
\subsubsection{Update process core parameters}
This test dispatches a process core, temporarily modifies parameters,
then restores the original.
<<Dispatch: execute tests>>=
  call test (dispatch_10, "dispatch_10", &
       "process core update", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_10 (u)
    integer, intent(in) :: u
    type(string_t), dimension(2) :: prt_in, prt_out
    type(rt_data_t), target :: global
    class(prc_core_def_t), allocatable :: core_def
    class(prc_core_t), allocatable :: core, saved_core
    type(var_list_t), pointer :: var_list
    
    write (u, "(A)")  "* Test output: dispatch_10"
    write (u, "(A)")  "*   Purpose: select process configuration method,"
    write (u, "(A)")  "             allocate process core,"
    write (u, "(A)")  "             temporarily reset parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()

    prt_in = [var_str ("a"), var_str ("b")]
    prt_out = [var_str ("c"), var_str ("d")]

    write (u, "(A)")  "* Allocate core as prc_omega_t"
    write (u, "(A)")

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("omega"), is_known = .true.)
    call dispatch_core_def (core_def, prt_in, prt_out, global)

    call global%select_model (var_str ("Test"))

    call dispatch_core (core, core_def, global%model)
    call core_def%allocate_driver (core%driver, var_str (""))

    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Update core with modified model and helicity selection"
    write (u, "(A)")

    var_list => global%get_var_list_ptr ()
    call var_list_set_real (var_list, var_str ("gy"), 2._default, &
         is_known = .true.)
    call global%model%update_parameters ()

    call var_list_set_log (global%var_list, &
         var_str ("?helicity_selection_active"), &
         .true., is_known = .true.)
    call var_list_set_real (global%var_list, &
         var_str ("helicity_selection_threshold"), &
         2e10_default, is_known = .true.)
    call var_list_set_int (global%var_list, &
         var_str ("helicity_selection_cutoff"), &
         5, is_known = .true.)
    
    call dispatch_core_update (core, global%model, &
         global%get_helicity_selection (), &
         saved_core = saved_core)
    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    write (u, "(A)")
    write (u, "(A)")  "* Restore core from save"
    write (u, "(A)")

    call dispatch_core_restore (core, saved_core)
    select type (core)
    type is (prc_omega_t)
       call core%write (u)
    end select
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_10"
    
  end subroutine dispatch_10
  
@ %def dispatch_10
@
\subsubsection{QCD Coupling}
This test dispatches an [[qcd]] object, which is used to compute the
(running) coupling by one of several possible methods.
<<Dispatch: execute tests>>=
  call test (dispatch_11, "dispatch_11", &
       "QCD coupling", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_11 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(qcd_t) :: qcd
    type(var_list_t), pointer :: model_vars
    
    write (u, "(A)")  "* Test output: dispatch_11"
    write (u, "(A)")  "*   Purpose: select QCD coupling formula"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%select_model (var_str ("SM"))
    model_vars => global%get_var_list_ptr ()

    write (u, "(A)")  "* Allocate alpha_s as fixed"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .true., is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (built-in)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?alpha_s_from_mz"), &
         .true., is_known = .true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_order"), 1, is_known = .true.)
    call var_list_set_real &
         (model_vars, var_str ("alphas"), 0.1234_default, &
          is_known=.true.)
    call var_list_set_real &
         (model_vars, var_str ("mZ"), 91.234_default, &
          is_known=.true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (built-in, Lambda defined)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?alpha_s_from_mz"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, &
         var_str ("?alpha_s_from_lambda_qcd"), &
         .true., is_known = .true.)
    call var_list_set_real &
         (global%var_list, var_str ("lambda_qcd"), 250.e-3_default, &
          is_known=.true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_order"), 2, is_known = .true.)
    call var_list_set_int &
         (global%var_list, var_str ("alpha_s_nf"), 4, is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Allocate alpha_s as running (using builtin PDF set)"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, &
         var_str ("?alpha_s_from_lambda_qcd"), &
         .false., is_known = .true.)
    call var_list_set_log &
         (global%var_list, var_str ("?alpha_s_from_pdf_builtin"), &
         .true., is_known = .true.)
    call dispatch_qcd (qcd, global)
    call qcd%write (u)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_11"
    
  end subroutine dispatch_11
  
@ %def dispatch_11
@
\subsubsection{Shower settings}
This test dispatches an [[shower_settings]] object, which is used 
to steer the initial and final state.
<<Dispatch: execute tests>>=
  call test (dispatch_12, "dispatch_12", &
       "Shower settings", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_12 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(shower_settings_t) :: shower_settings
    
    write (u, "(A)")  "* Test output: dispatch_12"
    write (u, "(A)")  "*   Purpose: setting ISR/FSR shower"
    write (u, "(A)")

    write (u, "(A)")  "* Default settings"    
    write (u, "(A)")    
    
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?alpha_s_is_fixed"), &
         .true., is_known = .true.)
    call dispatch_shower_settings (shower_settings, global)
    call write_separator (u)
    call shower_settings%write (u)
    call write_separator (u)

    write (u, "(A)")
    write (u, "(A)")  "* Switch on ISR/FSR showers, hadronization"
    write (u, "(A)")  "      and MLM matching"
    write (u, "(A)")
    
    call var_list_set_log (global%var_list, var_str ("?ps_fsr_active"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?ps_isr_active"), &
         .true., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?hadronization_active"), &
         .true., is_known = .true.)    
    call var_list_set_log (global%var_list, var_str ("?mlm_matching"), &
         .true., is_known = .true.)        
    call var_list_set_int &
         (global%var_list, var_str ("ps_max_n_flavors"), 4, is_known = .true.)
    call var_list_set_real &
         (global%var_list, var_str ("ps_isr_z_cutoff"), 0.1234_default, &
          is_known=.true.)
    call var_list_set_real (global%var_list, &
         var_str ("mlm_etamax"), 3.456_default, is_known=.true.)
    call var_list_set_string (global%var_list, &
         var_str ("$ps_PYTHIA_PYGIVE"), var_str ("abcdefgh"), is_known=.true.)    
    call dispatch_shower_settings (shower_settings, global)
    call write_separator (u)
    call shower_settings%write (u)
    call write_separator (u)
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_12"
    
  end subroutine dispatch_12
  
@ %def dispatch_12
@
\subsubsection{Event transforms}
This test dispatches an [[evt]] (event transform) object.  Currently,
the only nontrivial transform is the partonic decay chain..
<<Dispatch: execute tests>>=
  call test (dispatch_13, "dispatch_13", &
       "event transforms", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_13 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    class(evt_t), pointer :: evt
    type(var_list_t), pointer :: model_vars
    
    write (u, "(A)")  "* Test output: dispatch_13"
    write (u, "(A)")  "*   Purpose: configure event transform"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    model_vars => global%get_var_list_ptr ()    

    write (u, "(A)")  "* Partonic decays"
    write (u, "(A)")

    call dispatch_evt_decay (evt, global)
    select type (evt)
    type is (evt_decay_t)
       call evt%write (u, show_decay_tree = .true., verbose = .true.)
    end select

    call evt%final ()
    deallocate (evt)

    write (u, "(A)")
    write (u, "(A)")  "* Shower"
    write (u, "(A)")

    call var_list_set_log (global%var_list, var_str ("?allow_shower"), .true., &
         is_known = .true.)
    call dispatch_evt_shower (evt, global)
    select type (evt)
    type is (evt_shower_t)
       call evt%write (u)
       call write_separator (u, 2)
    end select

    call evt%final ()
    deallocate (evt)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_13"
    
  end subroutine dispatch_13
  
@ %def dispatch_13
@
\subsubsection{SLHA interface}
This rather trivial sets all input values for the SLHA interface
to [[false]].
<<Dispatch: execute tests>>=
  call test (dispatch_14, "dispatch_14", &
       "SLHA interface", &
       u, results)
<<Dispatch: tests>>=
  subroutine dispatch_14 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    logical :: input, spectrum, decays
    
    write (u, "(A)")  "* Test output: dispatch_14"
    write (u, "(A)")  "*   Purpose: SLHA interface settings"
    write (u, "(A)")

    write (u, "(A)")  "* Default settings"    
    write (u, "(A)")    
    
    call global%global_init ()
    call dispatch_slha (global, &
         input = input, spectrum = spectrum, decays = decays)

    write (u, "(A,1x,L1)")  " slha_read_input     =", input
    write (u, "(A,1x,L1)")  " slha_read_spectrum  =", spectrum   
    write (u, "(A,1x,L1)")  " slha_read_decays    =", decays

    call global%final ()
    call global%global_init ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Set all entries to [false]"    
    write (u, "(A)")        
            
    call var_list_set_log (global%var_list, var_str ("?slha_read_input"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?slha_read_spectrum"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?slha_read_decays"), &
         .false., is_known = .true.)    

    call dispatch_slha (global, &
         input = input, spectrum = spectrum, decays = decays)

    write (u, "(A,1x,L1)")  " slha_read_input     =", input
    write (u, "(A,1x,L1)")  " slha_read_spectrum  =", spectrum   
    write (u, "(A,1x,L1)")  " slha_read_decays    =", decays
    
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: dispatch_14"
    
  end subroutine dispatch_14
  
@ %def dispatch_14
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Process Configuration}
This module communicates between the toplevel command structure with
its runtime data set and the process-library handling modules which
collect the definition of individual processes.  Its primary purpose
is to select from the available matrix-element generating methods and
configure the entry in the process library accordingly.
<<[[process_configurations.f90]]>>=
<<File header>>

module process_configurations
  
<<Use strings>>
  use unit_tests
  use diagnostics

  use variables
  use models
  use prc_core_def
  use particle_specifiers
  use process_libraries
  use prclib_stacks
  use prc_test
  use prc_omega
  use rt_data
  use dispatch

  use prc_gosam
  
<<Standard module head>>

<<Process configurations: public>>

<<Process configurations: types>>

contains
  
<<Process configurations: procedures>>

<<Process configurations: tests>>

end module process_configurations
@ %def process_configurations
@
\subsection{Data Type}
<<Process configurations: public>>=
  public :: process_configuration_t
<<Process configurations: types>>=
  type :: process_configuration_t
     type(process_def_entry_t), pointer :: entry => null ()
     type(string_t) :: id
     integer :: num_id = 0
   contains
   <<Process configurations: process configuration: TBP>>
  end type process_configuration_t
  
@ %def process_configuration_t
@ Initialize a process.  We only need the name, the number of incoming
particles, and the number of components.
<<Process configurations: process configuration: TBP>>=
  procedure :: init => process_configuration_init
<<Process configurations: procedures>>=
  subroutine process_configuration_init &
       (config, prc_name, n_in, n_components, global)
    class(process_configuration_t), intent(out) :: config
    type(string_t), intent(in) :: prc_name
    integer, intent(in) :: n_in
    integer, intent(in) :: n_components 
    type(rt_data_t), intent(in) :: global
    type(model_t), pointer :: model
    model => global%model
    config%id = prc_name
    allocate (config%entry)
    if (global%var_list%is_known (var_str ("process_num_id"))) then
       config%num_id = &
            global%var_list%get_ival (var_str ("process_num_id"))
       call config%entry%init (prc_name, &
            model = model, n_in = n_in, n_components = n_components, &
            num_id = config%num_id, nlo_process = global%nlo_calculation)
    else
       call config%entry%init (prc_name, &
            model = model, n_in = n_in, n_components = n_components, &
            nlo_process = global%nlo_calculation)
    end if
  end subroutine process_configuration_init
    
@ %def process_configuration_init
@ Initialize a process component.  The details depend on the process method,
which determines the type of the process component core.  We set the incoming
and outgoing particles (as strings, to be interpreted by the process driver).
All other information is taken from the variable list.

The dispatcher gets only the names of the particles.  The process
component definition gets the complete specifiers which contains a
polarization flag and names of decay processes, where applicable.
<<Process configurations: process configuration: TBP>>=
  procedure :: setup_component => process_configuration_setup_component
<<Process configurations: procedures>>=
  subroutine process_configuration_setup_component &
       (config, i_component, prt_in, prt_out, global, &
        nlo_type, active_in)
    class(process_configuration_t), intent(inout) :: config
    integer, intent(in) :: i_component
    type(prt_spec_t), dimension(:), intent(in) :: prt_in
    type(prt_spec_t), dimension(:), intent(in) :: prt_out
    type(rt_data_t), intent(inout) :: global
    integer, intent(in), optional :: nlo_type
    logical, intent(in), optional :: active_in
    type(string_t), dimension(:), allocatable :: prt_str_in
    type(string_t), dimension(:), allocatable :: prt_str_out
    class(prc_core_def_t), allocatable :: core_def
    type(string_t) :: method
    integer :: i
    logical :: active

    allocate (prt_str_in  (size (prt_in)))
    allocate (prt_str_out (size (prt_out)))
    forall (i = 1:size (prt_in))  prt_str_in(i)  = prt_in(i)% get_name ()
    forall (i = 1:size (prt_out)) prt_str_out(i) = prt_out(i)%get_name ()
    if (present (active_in)) then
      active = active_in
    else
      active = .true.
    end if

    call dispatch_core_def (core_def, prt_str_in, prt_str_out, &
                            global, config%id, nlo_type)
    method = &
         global%var_list%get_sval (var_str ("$method"))
    call config%entry%import_component (i_component, &
       n_out = size (prt_out), &
       prt_in = prt_in, &
       prt_out = prt_out, &
       method = method, &
       variant = core_def, &
       nlo_type = nlo_type, &
       active = active)
  end subroutine process_configuration_setup_component
  
@ %def process_configuration_setup_component
@
<<Process configurations: process configuration: TBP>>=
  procedure :: set_component_associations => &
                   process_configuration_set_component_associations
<<Process configurations: procedures>>=
  subroutine process_configuration_set_component_associations &
       (config, i_list)
    class(process_configuration_t), intent(inout) :: config
    integer, intent(in), dimension(4) :: i_list 
    integer :: i_component
    do i_component = 1, config%entry%get_n_components ()
       if (any (i_list == i_component)) then
          call config%entry%set_associated_components (i_component, &
                 i_list(1), i_list(2), i_list(3), i_list(4))
       end if
    end do
  end subroutine process_configuration_set_component_associations

@ %def process_configuration_set_component_associations
@ Record a process configuration: append it to the currently selected process
definition library.
<<Process configurations: process configuration: TBP>>=
  procedure :: record => process_configuration_record
<<Process configurations: procedures>>=
  subroutine process_configuration_record (config, global)
    class(process_configuration_t), intent(inout) :: config
    type(rt_data_t), intent(inout) :: global
    if (associated (global%prclib)) then
       call global%prclib%open ()
       call global%prclib%append (config%entry)
       if (config%num_id /= 0) then
          write (msg_buffer, "(5A,I0,A)") "Process library '", &
               char (global%prclib%get_name ()), &
               "': recorded process '", char (config%id), "' (", &
               config%num_id, ")"
       else
          write (msg_buffer, "(5A)") "Process library '", &
               char (global%prclib%get_name ()), &
               "': recorded process '", char (config%id), "'"          
       end if
       call msg_message ()
    else
       call msg_fatal ("Recording process '" // char (config%id) &
            // "': active process library undefined")
    end if
  end subroutine process_configuration_record
  
@ %def process_configuration_record
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Process configurations: public>>=
  public :: process_configurations_test
<<Process configurations: tests>>=
  subroutine process_configurations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Process configurations: execute tests>>
  end subroutine process_configurations_test

@ %def process_configurations_test
@
\subsubsection{Minimal setup}
The workflow for setting up a minimal process configuration with the
test matrix element method.

We wrap this in a public procedure, so we can reuse it in later modules.
The procedure prepares a process definition list for two processes
(one [[prc_test]] and one [[omega]] type) and appends this to the
process library stack in the global data set.

The [[mode]] argument determines which processes to build.

The [[procname]] argument replaces the predefined procname(s).
<<Process configurations: public>>=
  public :: prepare_test_library
<<Process configurations: tests>>=
  subroutine prepare_test_library (global, libname, mode, procname)
    type(rt_data_t), intent(inout), target :: global
    type(string_t), intent(in) :: libname
    integer, intent(in) :: mode
    type(string_t), intent(in), dimension(:), optional :: procname
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prc_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    integer :: n_components
    type(process_configuration_t) :: prc_config

    if (.not. associated (global%prclib_stack%get_first_ptr ())) then
       allocate (lib)
       call lib%init (libname)
       call global%add_prclib (lib)
    end if

    if (btest (mode, 0)) then

       call global%select_model (var_str ("Test"))

       if (present (procname)) then
          prc_name = procname(1)
       else
          prc_name = "prc_config_a"
       end if
       n_components = 1
       allocate (prt_in (2), prt_out (2))
       prt_in = [var_str ("s"), var_str ("s")]
       prt_out = [var_str ("s"), var_str ("s")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("unit_test"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if

    if (btest (mode, 1)) then

       call global%select_model (var_str ("QED"))

       if (present (procname)) then
          prc_name = procname(2)
       else
          prc_name = "prc_config_b"
       end if
       n_components = 1
       allocate (prt_in (2), prt_out (2))
       prt_in = [var_str ("e+"), var_str ("e-")]
       prt_out = [var_str ("m+"), var_str ("m-")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("omega"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if
    
    if (btest (mode, 2)) then

       call global%select_model (var_str ("Test"))

       if (present (procname)) then
          prc_name = procname(1)
       else
          prc_name = "prc_config_a"
       end if
       n_components = 1
       allocate (prt_in (1), prt_out (2))
       prt_in = [var_str ("s")]
       prt_out = [var_str ("f"), var_str ("fbar")]

       call var_list_set_string (global%var_list, var_str ("$method"),&
            var_str ("unit_test"), is_known = .true.)

       call prc_config%init (prc_name, size (prt_in), n_components, global)
       call prc_config%setup_component (1, &
            new_prt_spec (prt_in), new_prt_spec (prt_out), global)
       call prc_config%record (global)

       deallocate (prt_in, prt_out)
       
    end if

  end subroutine prepare_test_library
    
@ %def prepare_test_library
@ The actual test: the previous procedure with some prelude and postlude.
In the global variable list, just before printing we reset the
variables where the value may depend on the system and run environment.
<<Process configurations: execute tests>>=
  call test (process_configurations_1, "process_configurations_1", &
       "test processes", &
       u, results)
<<Process configurations: tests>>=
  subroutine process_configurations_1 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: process_configurations_1"
    write (u, "(A)")  "*   Purpose: configure test processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    write (u, "(A)")  "* Configure processes as prc_test, model Test"
    write (u, "(A)")  "*                     and omega, model QED"
    write (u, *)

    call var_list_set_int (global%var_list, var_str ("process_num_id"), &
         42, is_known = .true.)
    call prepare_test_library (global, var_str ("prc_config_lib_1"), 3)

    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_configurations_1"
    
  end subroutine process_configurations_1
  
@ %def process_configurations_1
@
\subsubsection{\oMega\ options}
Slightly extended example where we pass \oMega\ options to the
library.  The [[prepare_test_library]] contents are spelled out.
<<Process configurations: execute tests>>=
  call test (process_configurations_2, "process_configurations_2", &
       "omega options", &
       u, results)
<<Process configurations: tests>>=
  subroutine process_configurations_2 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    
    type(string_t) :: libname
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prc_name
    type(string_t), dimension(:), allocatable :: prt_in, prt_out
    integer :: n_components
    type(process_configuration_t) :: prc_config

    write (u, "(A)")  "* Test output: process_configurations_2"
    write (u, "(A)")  "*   Purpose: configure test processes with options"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    
    write (u, "(A)")  "* Configure processes as omega, model QED"
    write (u, *)

    libname = "prc_config_lib_2"
    
    allocate (lib)
    call lib%init (libname)
    call global%add_prclib (lib)

    call global%select_model (var_str ("QED"))

    prc_name = "prc_config_c"
    n_components = 2
    allocate (prt_in (2), prt_out (2))
    prt_in = [var_str ("e+"), var_str ("e-")]
    prt_out = [var_str ("m+"), var_str ("m-")]

    call var_list_set_string (global%var_list, var_str ("$method"),&
         var_str ("omega"), is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    call prc_config%init (prc_name, size (prt_in), n_components, global)

    call var_list_set_log (global%var_list, var_str ("?report_progress"), &
         .true., is_known = .true.)
    call prc_config%setup_component (1, &
         new_prt_spec (prt_in), new_prt_spec (prt_out), global)

    call var_list_set_log (global%var_list, var_str ("?report_progress"), &
         .false., is_known = .true.)
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .true., is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$restrictions"),&
         var_str ("3+4~A"), is_known = .true.)
    call var_list_set_string (global%var_list, var_str ("$omega_flags"), &
         var_str ("-fusion:progress_file omega_prc_config.log"), &
         is_known = .true.)
    call prc_config%setup_component (2, &
         new_prt_spec (prt_in), new_prt_spec (prt_out), global)
    
    call prc_config%record (global)

    deallocate (prt_in, prt_out)
    
    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    call global%write_vars (u, [ &
         var_str ("$model_name"), &
         var_str ("$method"), &
         var_str ("?report_progress"), &
         var_str ("$restrictions"), &
         var_str ("$omega_flags")])
    write (u, "(A)")
    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: process_configurations_2"
    
  end subroutine process_configurations_2
  
@ %def process_configurations_2
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compilation}
This module manages compilation and loading of of process libraries.  It is
needed as a separate module because integration depends on it.
<<[[compilations.f90]]>>=
<<File header>>

module compilations

<<Use strings>>
  use io_units
  use unit_tests
  use system_defs, only: TAB
  use diagnostics
  use os_interface
  use md5
  use variables
  use model_data
  use models
  use process_libraries
  use prclib_stacks
  use rt_data
  use process_configurations

<<Standard module head>>

<<Compilations: public>>

<<Compilations: types>>

contains

<<Compilations: procedures>>

<<Compilations: tests>>

end module compilations
@ %def compilations
@
\subsection{The data type}
The compilation item handles the compilation and loading of a single
process library.
<<Compilations: types>>=
  type :: compilation_item_t
     type(string_t) :: libname
     type(string_t) :: static_external_tag
     type(process_library_t), pointer :: lib => null ()
     logical :: recompile_library = .false.
   contains
   <<Compilations: compilation item: TBP>>
  end type compilation_item_t

@ %def compilation_item_t
@ Initialize:
<<Compilations: compilation item: TBP>>=
  procedure :: init => compilation_item_init
<<Compilations: procedures>>=
  subroutine compilation_item_init (comp, libname, stack, var_list)
    class(compilation_item_t), intent(out) :: comp
    type(string_t), intent(in) :: libname
    type(prclib_stack_t), intent(inout) :: stack
    type(var_list_t), intent(in) :: var_list
    comp%libname = libname
    comp%lib => stack%get_library_ptr (comp%libname)
    if (.not. associated (comp%lib)) then
       call msg_fatal ("Process library '" // char (comp%libname) &
            // "' has not been declared.")
    end if
    comp%recompile_library = &
         var_list%get_lval (var_str ("?recompile_library"))
  end subroutine compilation_item_init

@ %def compilation_item_init
@ Compile the current library.  The [[force]] flag has the
effect that we first delete any previous files, as far as accessible
by the current makefile.  It also guarantees that previous files not
accessible by a makefile will be overwritten.
<<Compilations: compilation item: TBP>>=
  procedure :: compile => compilation_item_compile
<<Compilations: procedures>>=
  subroutine compilation_item_compile (comp, model, os_data, force, recompile)
    class(compilation_item_t), intent(inout) :: comp
    class(model_data_t), intent(in), target :: model
    type(os_data_t), intent(in) :: os_data
    logical, intent(in) :: force, recompile
    if (associated (comp%lib)) then
       call msg_message ("Process library '" &
            // char (comp%libname) // "': compiling ...")
       call comp%lib%configure (os_data)
       if (signal_is_pending ())  return
       call comp%lib%compute_md5sum (model)
       call comp%lib%write_makefile (os_data, force)
       if (signal_is_pending ())  return
       if (force) then
          call comp%lib%clean (os_data, distclean = .false.)
          if (signal_is_pending ())  return
       end if
       call comp%lib%write_driver (force)
       if (signal_is_pending ())  return
       if (recompile) then
          call comp%lib%load (os_data, keep_old_source = .true.)
          if (signal_is_pending ())  return
       end if
       call comp%lib%update_status (os_data)
    end if
  end subroutine compilation_item_compile

@ %def compilation_item_compile
@ Load the current library, just after compiling it.
<<Compilations: compilation item: TBP>>=
  procedure :: load => compilation_item_load
<<Compilations: procedures>>=
  subroutine compilation_item_load (comp, os_data)
    class(compilation_item_t), intent(inout) :: comp
    type(os_data_t), intent(in) :: os_data
    if (associated (comp%lib)) then
       call comp%lib%load (os_data)
    end if
  end subroutine compilation_item_load

@ %def compilation_item_load
@ Message as a separate call:
<<Compilations: compilation item: TBP>>=
  procedure :: success => compilation_item_success
<<Compilations: procedures>>=
  subroutine compilation_item_success (comp)
    class(compilation_item_t), intent(in) :: comp
    if (associated (comp%lib)) then
       call msg_message ("Process library '" // char (comp%libname) &
            // "': ... success.")
    else
       call msg_fatal ("Process library '" // char (comp%libname) &
            // "': ... failure.")
    end if
  end subroutine compilation_item_success

@ %def compilation_item_success
@ %def compilation_item_failure
@
\subsection{API for library compilation and loading}
This is a shorthand for compiling and loading a single library.  The
[[compilation_item]] object is used only internally.

The [[global]] data set may actually be local to the caller.  The
compilation affects the library specified by its name if it is on the
stack, but it does not reset the currently selected library.
<<Compilations: public>>=
  public :: compile_library
<<Compilations: procedures>>=
  subroutine compile_library (libname, global)
    type(string_t), intent(in) :: libname
    type(rt_data_t), intent(inout), target :: global
    type(compilation_item_t) :: comp
    logical :: force, recompile
    force = &
         global%var_list%get_lval (var_str ("?rebuild_library"))
    recompile = &
         global%var_list%get_lval (var_str ("?recompile_library"))
    if (associated (global%model)) then
       call comp%init (libname, global%prclib_stack, global%var_list)
       call comp%compile (global%model, global%os_data, force, recompile)
       if (signal_is_pending ())  return
       call comp%load (global%os_data)
       if (signal_is_pending ())  return
    else
       call msg_fatal ("Process library compilation: " &
            // " model is undefined.")
    end if
    call comp%success ()
  end subroutine compile_library

@ %def compile_library
@
\subsection{Compiling static executable}
This object handles the creation of a static executable which should
contain a set of static process libraries.
<<Compilations: types>>=
  type :: compilation_t
     private
     type(string_t) :: exe_name
     type(string_t), dimension(:), allocatable :: lib_name
   contains
   <<Compilations: compilation: TBP>>
  end type compilation_t

@ %def compilation_t
@ Output.
<<Compilations: compilation: TBP>>=
  procedure :: write => compilation_write
<<Compilations: procedures>>=
  subroutine compilation_write (object, unit)
    class(compilation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Compilation object:"
    write (u, "(3x,3A)")  "executable        = '", &
         char (object%exe_name), "'"
    write (u, "(3x,A)", advance="no")  "process libraries ="
    do i = 1, size (object%lib_name)
       write (u, "(1x,3A)", advance="no")  "'", char (object%lib_name(i)), "'"
    end do
    write (u, *)
  end subroutine compilation_write
  
@ %def compilation_write
@ Initialize: we know the names of the executable and of the libraries.
<<Compilations: compilation: TBP>>=
  procedure :: init => compilation_init
<<Compilations: procedures>>=
  subroutine compilation_init (compilation, exe_name, lib_name)
    class(compilation_t), intent(out) :: compilation
    type(string_t), intent(in) :: exe_name
    type(string_t), dimension(:), intent(in) :: lib_name
    compilation%exe_name = exe_name
    allocate (compilation%lib_name (size (lib_name)))
    compilation%lib_name = lib_name
  end subroutine compilation_init
    
@ %def compilation_init
@ Write the dispatcher subroutine for the compiled libraries.  Also
write a subroutine which returns the names of the compiled libraries.
<<Compilations: compilation: TBP>>=
  procedure :: write_dispatcher => compilation_write_dispatcher
<<Compilations: procedures>>=
  subroutine compilation_write_dispatcher (compilation)
    class(compilation_t), intent(in) :: compilation
    type(string_t) :: file
    integer :: u, i
    file = compilation%exe_name // "_prclib_dispatcher.f90"
    call msg_message ("Static executable '" // char (compilation%exe_name) &
         // "': writing library dispatcher")
    u = free_unit ()
    open (u, file = char (file), status="replace", action="write")
    write (u, "(3A)")  "! Whizard: process libraries for executable '", &
         char (compilation%exe_name), "'"
    write (u, "(A)")  "! Automatically generated file, do not edit"
    write (u, "(A)")  "subroutine dispatch_prclib_static " // &
         "(driver, basename, modellibs_ldflags)"
    write (u, "(A)")  "  use iso_varying_string, string_t => varying_string"
    write (u, "(A)")  "  use prclib_interfaces"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A)")  "  use " // char (lib_name) // "_driver"
       end associate
    end do
    write (u, "(A)")  "  implicit none"
    write (u, "(A)")  "  class(prclib_driver_t), intent(inout), allocatable &
         &:: driver"
    write (u, "(A)")  "  type(string_t), intent(in) :: basename"
    write (u, "(A)")  "  logical, intent(in), optional :: " // &
         "modellibs_ldflags"
    write (u, "(A)")  "  select case (char (basename))"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(3A)")  "  case ('", char (lib_name), "')"
         write (u, "(3A)")  "     allocate (", char (lib_name), "_driver_t &
              &:: driver)"
       end associate
    end do
    write (u, "(A)")  "  end select"
    write (u, "(A)")  "end subroutine dispatch_prclib_static"
    write (u, *)
    write (u, "(A)")  "subroutine get_prclib_static (libname)"
    write (u, "(A)")  "  use iso_varying_string, string_t => varying_string"
    write (u, "(A)")  "  implicit none"
    write (u, "(A)")  "  type(string_t), dimension(:), intent(inout), &
         &allocatable :: libname"
    write (u, "(A,I0,A)")  "  allocate (libname (", &
         size (compilation%lib_name), "))"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A,I0,A,A,A)")  "  libname(", i, ") = '", &
              char (lib_name), "'"
       end associate
    end do
    write (u, "(A)")  "end subroutine get_prclib_static"
    close (u)
  end subroutine compilation_write_dispatcher
    
@ %def compilation_write_dispatcher
@ Write the Makefile subroutine for the compiled libraries.
<<Compilations: compilation: TBP>>=
  procedure :: write_makefile => compilation_write_makefile
<<Compilations: procedures>>=
  subroutine compilation_write_makefile (compilation, os_data, ext_libtag)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    type(string_t), intent(in), optional :: ext_libtag
    type(string_t) :: file, ext_tag
    integer :: u, i
    if (present (ext_libtag)) then
       ext_tag = ext_libtag
    else
       ext_tag = ""
    end if
    file = compilation%exe_name // ".makefile"
    call msg_message ("Static executable '" // char (compilation%exe_name) &
         // "': writing makefile")
    u = free_unit ()
    open (u, file = char (file), status="replace", action="write")
    write (u, "(3A)")  "# WHIZARD: Makefile for executable '", &
         char (compilation%exe_name), "'"
    write (u, "(A)")  "# Automatically generated file, do not edit"
    write (u, "(A)") ""
    write (u, "(A)") "# Executable name"
    write (u, "(A)") "EXE = " // char (compilation%exe_name)
    write (u, "(A)") ""
    write (u, "(A)") "# Compiler"
    write (u, "(A)") "FC = " // char (os_data%fc)
    write (u, "(A)") ""
    write (u, "(A)") "# Included libraries"
    write (u, "(A)") "FCINCL = " // char (os_data%whizard_includes)
    write (u, "(A)") ""
    write (u, "(A)") "# Compiler flags"
    write (u, "(A)") "FCFLAGS = " // char (os_data%fcflags)
    write (u, "(A)") "LDFLAGS = " // char (os_data%ldflags)
    write (u, "(A)") "LDFLAGS_STATIC = " // char (os_data%ldflags_static)   
    write (u, "(A)") "LDFLAGS_HEPMC = " // char (os_data%ldflags_hepmc)
    write (u, "(A)") "LDFLAGS_HOPPET = " // char (os_data%ldflags_hoppet)    
    write (u, "(A)") "LDFLAGS_LOOPTOOLS = " // char (os_data%ldflags_looptools)
    write (u, "(A)") "LDWHIZARD = " // char (os_data%whizard_ldflags)
    write (u, "(A)") ""
    write (u, "(A)") "# Libtool"
    write (u, "(A)") "LIBTOOL = " // char (os_data%whizard_libtool)
    write (u, "(A)") "FCOMPILE = $(LIBTOOL) --tag=FC --mode=compile"
    write (u, "(A)") "LINK = $(LIBTOOL) --tag=FC --mode=link"
    write (u, "(A)") ""
    write (u, "(A)") "# Compile commands (default)"
    write (u, "(A)") "LTFCOMPILE = $(FCOMPILE) $(FC) -c $(FCINCL) $(FCFLAGS)"
    write (u, "(A)") ""
    write (u, "(A)") "# Default target"
    write (u, "(A)") "all: link"
    write (u, "(A)") ""
    write (u, "(A)") "# Libraries"
    do i = 1, size (compilation%lib_name)
       associate (lib_name => compilation%lib_name(i))
         write (u, "(A)") "LIBRARIES += " // char (lib_name) // ".la"
         write (u, "(A)") char (lib_name) // ".la:"
         write (u, "(A)") TAB // "$(MAKE) -f " // char (lib_name) // ".makefile"
       end associate
    end do
    write (u, "(A)") ""
    write (u, "(A)") "# Library dispatcher"
    write (u, "(A)") "DISP = $(EXE)_prclib_dispatcher"
    write (u, "(A)") "$(DISP).lo: $(DISP).f90 $(LIBRARIES)"
    write (u, "(A)") TAB // "$(LTFCOMPILE) $<"
    write (u, "(A)") ""
    write (u, "(A)") "# Executable"
    write (u, "(A)") "$(EXE): $(DISP).lo $(LIBRARIES)"
    write (u, "(A)") TAB // "$(LINK) $(FC) -static-libtool-libs $(FCFLAGS) \"
    write (u, "(A)") TAB // "   $(LDWHIZARD) $(LDFLAGS) \" 
    write (u, "(A)") TAB // "   -o $(EXE) $^ \"
    write (u, "(A)") TAB // "   $(LDFLAGS_HEPMC) $(LDFLAGS_HOPPET) $(LDFLAGS_LOOPTOOLS) \"
    write (u, "(A)") TAB // "   $(LDFLAGS_STATIC)" // char (ext_tag)
    write (u, "(A)") ""
    write (u, "(A)") "# Main targets"
    write (u, "(A)") "link: compile $(EXE)"
    write (u, "(A)") "compile: $(LIBRARIES) $(DISP).lo"
    write (u, "(A)") ".PHONY: link compile"
    write (u, "(A)") ""
    write (u, "(A)") "# Cleanup targets"
    write (u, "(A)") "clean-exe:"
    write (u, "(A)") TAB // "rm -f $(EXE)"
    write (u, "(A)") "clean-objects:"
    write (u, "(A)") TAB // "rm -f $(DISP).lo"
    write (u, "(A)") "clean-source:"
    write (u, "(A)") TAB // "rm -f $(DISP).f90"
    write (u, "(A)") "clean-makefile:"
    write (u, "(A)") TAB // "rm -f $(EXE).makefile"
    write (u, "(A)") ""
    write (u, "(A)") "clean: clean-exe clean-objects clean-source"
    write (u, "(A)") "distclean: clean clean-makefile"
    write (u, "(A)") ".PHONY: clean distclean"
    close (u)
  end subroutine compilation_write_makefile
    
@ %def compilation_write_makefile
@ Compile the dispatcher source code.
<<Compilations: compilation: TBP>>=
  procedure :: make_compile => compilation_make_compile
<<Compilations: procedures>>=
  subroutine compilation_make_compile (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make compile " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_compile
  
@ %def compilation_make_compile
@ Link the dispatcher together with all matrix-element code and the
\whizard\ and \oMega\ main libraries, to generate a static executable.
<<Compilations: compilation: TBP>>=
  procedure :: make_link => compilation_make_link
<<Compilations: procedures>>=
  subroutine compilation_make_link (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make link " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_link
  
@ %def compilation_make_link
@ Cleanup.
<<Compilations: compilation: TBP>>=
  procedure :: make_clean_exe => compilation_make_clean_exe
<<Compilations: procedures>>=
  subroutine compilation_make_clean_exe (compilation, os_data)
    class(compilation_t), intent(in) :: compilation
    type(os_data_t), intent(in) :: os_data
    call os_system_call ("make clean-exe " // os_data%makeflags &
         // " -f " // compilation%exe_name // ".makefile")
  end subroutine compilation_make_clean_exe
  
@ %def compilation_make_clean_exe
@
\subsection{API for executable compilation}
This is a shorthand for compiling and loading an executable, including
the enclosed libraries.  The [[compilation]] object is used only internally.

The [[global]] data set may actually be local to the caller.  The
compilation affects the library specified by its name if it is on the
stack, but it does not reset the currently selected library.
<<Compilations: public>>=
  public :: compile_executable
<<Compilations: procedures>>=
  subroutine compile_executable (exename, libname, global)
    type(string_t), intent(in) :: exename
    type(string_t), dimension(:), intent(in) :: libname    
    type(rt_data_t), intent(inout), target :: global
    type(compilation_t) :: compilation
    type(compilation_item_t) :: item
    type(string_t) :: ext_libtag
    logical :: force, recompile
    integer :: i
    ext_libtag = ""
    force = &
         global%var_list%get_lval (var_str ("?rebuild_library"))
    recompile = &
         global%var_list%get_lval (var_str ("?recompile_library"))
    call compilation%init (exename, [libname])
    if (signal_is_pending ())  return
    call compilation%write_dispatcher ()
    if (signal_is_pending ())  return
    do i = 1, size (libname)
       call item%init (libname(i), global%prclib_stack, global%var_list)
       call item%compile (global%model, global%os_data, &
            force=force, recompile=recompile)
       ext_libtag = "" // item%lib%get_static_modelname (global%os_data)       
       if (signal_is_pending ())  return
       call item%success ()
    end do
    call compilation%write_makefile (global%os_data, ext_libtag)
    if (signal_is_pending ())  return    
    call compilation%make_compile (global%os_data)
    if (signal_is_pending ())  return
    call compilation%make_link (global%os_data)
  end subroutine compile_executable

@ %def compile_executable
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Compilations: public>>=
  public :: compilations_test
<<Compilations: tests>>=
  subroutine compilations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Compilations: execute tests>>
end subroutine compilations_test

@ %def compilations_test
@
\subsubsection{Intrinsic Matrix Element}
Compile an intrinsic test matrix element ([[prc_test]] type).

Note: In this and the following test, we reset the Fortran compiler and flag
variables immediately before they are printed, so the test is portable.
<<Compilations: execute tests>>=
  call test (compilations_1, "compilations_1", &
       "intrinsic test processes", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: compilations_1"
    write (u, "(A)")  "*   Purpose: configure and compile test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "compilation_1"
    procname = "prc_comp_1"
    call prepare_test_library (global, libname, 1, [procname])

    call compile_library (libname, global)
    
    call global%write_libraries (u)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_1"
    
  end subroutine compilations_1
  
@ %def compilations_1
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type)
<<Compilations: execute tests>>=
  call test (compilations_2, "compilations_2", &
       "external process (omega)", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: compilations_2"
    write (u, "(A)")  "*   Purpose: configure and compile test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilation_2"
    procname = "prc_comp_2"
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compile_library (libname, global)
    
    call global%write_libraries (u, libpath = .false.)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_2"
    
  end subroutine compilations_2
  
@ %def compilations_2
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
create driver files for a static executable.
<<Compilations: execute tests>>=
  call test (compilations_3, "compilations_3", &
       "static executable: driver", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_t) :: compilation
    integer :: u_file
    character(80) :: buffer

    write (u, "(A)")  "* Test output: compilations_3"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_3_lib"
    procname = "prc_comp_3"
    exename = "compilations_3"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compilation%init (exename, [libname])
    call compilation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write dispatcher"
    write (u, "(A)")

    call compilation%write_dispatcher ()

    u_file = free_unit ()
    open (u_file, file = char (exename) // "_prclib_dispatcher.f90", &
         status = "old", action = "read")
    do
       read (u_file, "(A)", end = 1)  buffer
       write (u, "(A)")  trim (buffer)
    end do
1   close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Write Makefile"
    write (u, "(A)")

    associate (os_data => global%os_data)
      os_data%fc = "fortran-compiler"
      os_data%whizard_includes = "my-includes"
      os_data%fcflags = "my-fcflags"
      os_data%ldflags = "my-ldflags"
      os_data%ldflags_static = "my-ldflags-static"
      os_data%ldflags_hepmc = "my-ldflags-hepmc"
      os_data%ldflags_hoppet = "my-ldflags-hoppet"      
      os_data%ldflags_looptools = "my-ldflags-looptools"
      os_data%whizard_ldflags = "my-ldwhizard"
      os_data%whizard_libtool = "my-libtool"
    end associate

    call compilation%write_makefile (global%os_data)

    open (u_file, file = char (exename) // ".makefile", &
         status = "old", action = "read")
    do
       read (u_file, "(A)", end = 2)  buffer
       write (u, "(A)")  trim (buffer)
    end do
2   close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_3"
    
  end subroutine compilations_3
  
@ %def compilations_3
@
\subsection{Test static build}
The tests for building a static executable are separate, since they
should be skipped if the \whizard\ build itself has static libraries
disabled.
<<Compilations: public>>=
  public :: compilations_static_test
<<Compilations: tests>>=
  subroutine compilations_static_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Compilations: static tests>>
end subroutine compilations_static_test

@ %def compilations_static_test
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
incorporate this in a new static WHIZARD executable.
<<Compilations: static tests>>=
  call test (compilations_static_1, "compilations_static_1", &
       "static executable: compilation", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_static_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_item_t) :: item
    type(compilation_t) :: compilation
    logical :: exist

    write (u, "(A)")  "* Test output: compilations_static_1"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library"

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_static_1_lib"
    procname = "prc_comp_stat_1"
    exename = "compilations_static_1"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compilation%init (exename, [libname])

    write (u, "(A)")
    write (u, "(A)")  "* Write dispatcher"

    call compilation%write_dispatcher ()

    write (u, "(A)")
    write (u, "(A)")  "* Write Makefile"

    call compilation%write_makefile (global%os_data)

    write (u, "(A)")
    write (u, "(A)")  "* Build libraries"

    call item%init (libname, global%prclib_stack, global%var_list)
    call item%compile &
         (global%model, global%os_data, force=.true., recompile=.false.)
    call item%success ()

    write (u, "(A)")
    write (u, "(A)")  "* Check executable (should be absent)"
    write (u, "(A)")
    
    call compilation%make_clean_exe (global%os_data)
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Build executable"
    write (u, "(A)")

    call compilation%make_compile (global%os_data)
    call compilation%make_link (global%os_data)

    write (u, "(A)")  "* Check executable (should be present)"
    write (u, "(A)")
    
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call compilation%make_clean_exe (global%os_data)

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_static_1"
    
  end subroutine compilations_static_1
  
@ %def compilations_static_1
@
\subsubsection{External Matrix Element}
Compile an external test matrix element ([[omega]] type) and
incorporate this in a new static WHIZARD executable.  In this version,
we use the wrapper [[compile_executable]] procedure.
<<Compilations: static tests>>=
  call test (compilations_static_2, "compilations_static_2", &
       "static executable: shortcut", &
       u, results)
<<Compilations: tests>>=
  subroutine compilations_static_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname, exename
    type(rt_data_t), target :: global
    type(compilation_item_t) :: item
    type(compilation_t) :: compilation
    logical :: exist
    integer :: u_file

    write (u, "(A)")  "* Test output: compilations_static_2"
    write (u, "(A)")  "*   Purpose: make static executable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize library and compile"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    libname = "compilations_static_2_lib"
    procname = "prc_comp_stat_2"
    exename = "compilations_static_2"
    
    call prepare_test_library (global, libname, 2, [procname,procname])

    call compile_executable (exename, [libname], global)

    write (u, "(A)")  "* Check executable (should be present)"
    write (u, "(A)")
    
    inquire (file = char (exename), exist = exist)
    write (u, "(A,A,L1)")  char (exename), " exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    u_file = free_unit ()
    open (u_file, file = char (exename), status = "old", action = "write")
    close (u_file, status = "delete")

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: compilations_static_2"
    
  end subroutine compilations_static_2
  
@ %def compilations_static_2
@ 
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Integration}
This module manages phase space setup, matrix-element evaluation and
integration, as far as it is not done by lower-level routines, in particular
in the [[processes]] module.
<<[[integrations.f90]]>>=
<<File header>>

module integrations

<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use os_interface
  use cputime
  use sm_qcd
  use physics_defs
  use ifiles
  use lexers
  use parser
  use model_data
  use flavors
  use pdg_arrays
  use variables
  use expr_base
  use eval_trees
  use models
  use interactions
  use sf_mappings
  use sf_base
  use phs_base
  use mappings
  use phs_forests
  use phs_wood
  use rng_base
  use mci_base
  use process_libraries
  use prc_core
  use processes
  use process_stacks
  use models
  use iterations
  use rt_data
  use dispatch
  use process_configurations
  use compilations

  use process_constants
  use prc_omega
  use prc_gosam
  use nlo_data

<<Standard module head>>

<<Integrations: public>>

<<Integrations: types>>

contains

<<Integrations: procedures>>

<<Integrations: tests>>

end module integrations
@ %def integrations
@
\subsection{The integration type}
This type holds all relevant data, the integration methods operates on this.
In contrast to the [[simulation_t]] introduced later, the [[integration_t]]
applies to a single process.
<<Integrations: public>>=
  public :: integration_t
<<Integrations: types>>=
  type :: integration_t
    private
    type(string_t) :: process_id
    type(string_t) :: run_id
    type(process_t), pointer :: process => null ()
    type(var_list_t), pointer :: model_vars => null ()
    type(qcd_t) :: qcd
    logical :: rebuild_phs = .false.
    logical :: ignore_phs_mismatch = .false.
    logical :: phs_only = .false.
    logical :: process_has_me = .true.
    integer :: n_calls_test = 0
    logical :: vis_history = .true.
    type(string_t) :: history_filename
    type(string_t) :: log_filename
    logical :: combined_integration = .false.
   contains
   <<Integrations: integration: TBP>> 
  end type integration_t

@ %def integration_t
@ 
@
\subsection{Initialization}
Initialization, first part: Create a process entry.
Push it on the stack if the [[global]] environment is supplied.
<<Integrations: integration: TBP>>=
  procedure :: create_process => integration_create_process
<<Integrations: procedures>>=
  subroutine integration_create_process (intg, process_id, global)
    class(integration_t), intent(out) :: intg
    type(rt_data_t), intent(inout), optional, target :: global
    type(string_t), intent(in) :: process_id
    type(process_entry_t), pointer :: process_entry
    intg%process_id = process_id
    if (present (global)) then
       allocate (process_entry)
       intg%process => process_entry%process_t
       call global%process_stack%push (process_entry)
    else
       allocate (process_t :: intg%process)
    end if
    intg%model_vars => null ()
  end subroutine integration_create_process

@ %def integration_create_process
@ Initialization, second part: Initialize the process object, using the local
environment.  We allocate a RNG factory and a QCD object.
We also fetch a pointer to the model that the process uses.  The
process initializer will create a snapshot of that model.

This procedure
does not modify the [[local]] stack directly.  The intent(inout) attribute for
the [[local]] data set is due to the random generator seed which may be
incremented during initialization.

NOTE: Changes to model parameters within the current context are respected
only if the process model coincides with the current model.  This is the usual
case.  If not, we read
the model from the global model library, which has default parameters.  To
become more flexible, we should implement a local model library which records
local changes to currently inactive models.
<<Integrations: integration: TBP>>=
  procedure :: init_process => integration_init_process
<<Integrations: procedures>>=
  subroutine integration_init_process (intg, local)
    class(integration_t), intent(inout) :: intg
    type(rt_data_t), intent(inout), target :: local
    type(string_t) :: model_name
    type(model_t), pointer :: model
    class(model_data_t), pointer :: model_instance
    class(rng_factory_t), allocatable :: rng_factory
    if (.not. local%prclib%contains (intg%process_id)) then
       call msg_fatal ("Process '" // char (intg%process_id) // "' not found" &
            // " in library '" // char (local%prclib%get_name ()) // "'")
       return
    end if
    intg%run_id = &
         local%var_list%get_sval (var_str ("$run_id"))
    call dispatch_qcd (intg%qcd, local)
    call dispatch_rng_factory (rng_factory, local)
    model_name = local%prclib%get_model_name (intg%process_id)
    if (local%get_sval (var_str ("$model_name")) == model_name) then
       model => local%model
    else
       model => local%model_list%get_model_ptr (model_name)
    end if
    allocate (model_t :: model_instance)
    select type (model_instance)
    type is (model_t)
       call model_instance%init_instance (model)
       intg%model_vars => model_instance%get_var_list_ptr ()
    end select
    call intg%process%init (intg%process_id, intg%run_id, &
         local%prclib, &
         local%os_data, intg%qcd, rng_factory, model_instance)
  end subroutine integration_init_process
    
@ %def integration_init_process
@ Initialization, third part: complete process configuration.   
<<Integrations: integration: TBP>>=
  procedure :: setup_process => integration_setup_process
<<Integrations: procedures>>=
  subroutine integration_setup_process (intg, local, verbose)
    class(integration_t), intent(inout) :: intg
    type(rt_data_t), intent(inout), target :: local
    logical, intent(in), optional :: verbose
    type(var_list_t), pointer :: var_list
    class(prc_core_t), allocatable :: core_template
    class(phs_config_t), allocatable :: phs_config_template
    class(phs_config_t), allocatable :: phs_config_template_real
    type(phs_parameters_t) :: phs_par
    type(mapping_defaults_t) :: mapping_defs
    class(mci_t), allocatable :: mci_template
    integer :: n_components, n_in, i_component
    type(pdg_array_t), dimension(:,:), allocatable :: pdg_prc
    type(process_component_def_t), pointer :: config
    type(helicity_selection_t), allocatable :: helicity_selection
    real(default) :: sqrts
    logical :: decay_rest_frame, use_color_factors
    type(sf_config_t), dimension(:), allocatable :: sf_config
    type(sf_prop_t) :: sf_prop
    type(sf_channel_t), dimension(:), allocatable :: sf_channel
    type(phs_channel_collection_t) :: phs_channel_collection
    logical :: sf_trace
    type(string_t) :: sf_string, sf_trace_file
    logical :: verb
    type(process_constants_t) :: prc_const
    integer :: i_born
    type(fks_template_t) :: fks_template
    type(gosam_template_t) :: gosam_template
    type(string_t) :: me_method
    type(eval_tree_factory_t) :: expr_factory
  
    verb = .true.; if (present (verbose))  verb = verbose
    
    call intg%process%set_var_list (local%get_var_list_ptr ())
    var_list => intg%process%get_var_list_ptr ()

    intg%rebuild_phs = &
         var_list%get_lval (var_str ("?rebuild_phase_space"))
    intg%ignore_phs_mismatch = &
         .not. var_list%get_lval (var_str ("?check_phs_file"))
    intg%phs_only = &
         var_list%get_lval (var_str ("?phs_only"))
    phs_par%m_threshold_s = &
         var_list%get_rval (var_str ("phs_threshold_s"))
    phs_par%m_threshold_t = &
         var_list%get_rval (var_str ("phs_threshold_t"))
    phs_par%off_shell = &
         var_list%get_ival (var_str ("phs_off_shell"))
    phs_par%keep_nonresonant = &
         var_list%get_lval (var_str ("?phs_keep_nonresonant"))
    phs_par%t_channel = &
         var_list%get_ival (var_str ("phs_t_channel"))
    mapping_defs%energy_scale = &
         var_list%get_rval (var_str ("phs_e_scale"))
    mapping_defs%invariant_mass_scale = &
         var_list%get_rval (var_str ("phs_m_scale"))
    mapping_defs%momentum_transfer_scale = &
         var_list%get_rval (var_str ("phs_q_scale"))
    mapping_defs%step_mapping = &
         var_list%get_lval (var_str ("?phs_step_mapping"))
    mapping_defs%step_mapping_exp = &
         var_list%get_lval (var_str ("?phs_step_mapping_exp"))
    mapping_defs%enable_s_mapping = &
         var_list%get_lval (var_str ("?phs_s_mapping"))

    call dispatch_phs (phs_config_template, local, &
         intg%process_id, mapping_defs, phs_par)
    
    
    intg%n_calls_test = &
         var_list%get_ival (var_str ("n_calls_test"))

    !!! We avoid two dots in the filename due to a bug in certain MetaPost versions.
    if (intg%run_id /= "") then
       intg%history_filename = intg%process_id // "." // intg%run_id &
            // "-history"
       intg%log_filename = intg%process_id // "." // intg%run_id // ".log"
    else
       intg%history_filename = intg%process_id // "-history"
       intg%log_filename = intg%process_id // ".log"
    end if

    call dispatch_mci (mci_template, local, intg%process_id)

    if (verb) then
       call msg_message ("Initializing integration for process " &
            // char (intg%process_id) // ":")
       if (intg%run_id /= "") then
          call msg_message ("Run ID = " // '"' // char (intg%run_id) // '"')
       end if
    end if
    
    helicity_selection = local%get_helicity_selection ()

    intg%vis_history = &
         var_list%get_lval (var_str ("?vis_history"))
    use_color_factors = var_list%get_lval &
         (var_str ("?read_color_factors"))
    
    n_components = intg%process%get_n_components ()
    n_in = intg%process%get_n_in ()

    call gosam_template%init ()
    intg%combined_integration = var_list%get_lval (&
                                var_str ('?combined_nlo_integration')) &
                                .and. intg%process%is_nlo_calculation ()

    do i_component = 1, n_components
       config => intg%process%get_component_def_ptr (i_component)
       call dispatch_core (core_template, config%get_core_def_ptr (), &
            intg%process%get_model_ptr (), helicity_selection, intg%qcd, &
            use_color_factors)
       select case (config%get_nlo_type ())
       case (NLO_VIRTUAL)
         me_method = var_list%get_sval (var_str ("$loop_me_method"))
         select case (char (me_method)) 
         case ('gosam')
            call gosam_template%set_loop (.true.)
         end select
         call intg%process%init_component &
            (i_component, core_template, mci_template, phs_config_template, &
             gosam_template = gosam_template)
         if (intg%combined_integration) &
            call intg%process%set_component_type (i_component, COMP_VIRT)
       case (NLO_REAL)
         me_method = var_list%get_sval (var_str ("$real_tree_me_method"))
         select case (char (me_method))
         case ('gosam')
            call gosam_template%set_real_trees (.true.)
         end select
         call dispatch_phs (phs_config_template_real, local, &
             intg%process_id, mapping_defs, phs_par, &
             var_str ('fks'))
         call dispatch_fks (fks_template, local)
         call intg%process%init_component &
            (i_component, core_template, mci_template, &
             phs_config_template_real, fks_template = fks_template, &
             gosam_template = gosam_template)
         if (intg%combined_integration) &
            call intg%process%set_component_type (i_component, COMP_REAL)
       case (BORN)
         call intg%process%init_component &
            (i_component, core_template, mci_template, phs_config_template)
         i_born = config%get_associated_born ()
         if (intg%combined_integration) &
            call intg%process%set_component_type (i_component, COMP_MASTER)
       case (NLO_SUBTRACTION)
         me_method = var_list%get_sval (var_str ("$correlation_me_method"))
         select case (char (me_method))
         case ('gosam')
            call gosam_template%set_subtraction (.true.)
         end select
         call intg%process%init_component &
             (i_component, core_template, mci_template, phs_config_template, &
              gosam_template = gosam_template)
         if (intg%combined_integration) &
            call intg%process%set_component_type (i_component, COMP_SUB)
       case default
         call msg_fatal ("setup_process: NLO type not implemented!")
       end select
       call gosam_template%reset ()
       deallocate (core_template)
    end do

    if (verb)  call intg%process%write (screen = .true.)
    
    intg%process_has_me = intg%process%has_matrix_element ()
    if (.not. intg%process_has_me) then
       call msg_warning ("Process '" &
            // char (intg%process_id) // "': matrix element vanishes")
    end if
    
    sqrts = local%get_sqrts ()
    decay_rest_frame = &
         var_list%get_lval (var_str ("?decay_rest_frame"))    
    if (intg%process_has_me) then
       if (local%beam_structure%is_set ()) then
          call intg%process%setup_beams_beam_structure &
               (local%beam_structure, sqrts, decay_rest_frame)
        else if (n_in == 2) then
          call intg%process%setup_beams_sqrts &
               (sqrts, local%beam_structure)
       else 
          call intg%process%setup_beams_decay &
               (decay_rest_frame, local%beam_structure)
       end if
    end if
    call intg%process%check_masses ()
    if (verb .and. intg%process_has_me) then
       call intg%process%beams_startup_message &
            (beam_structure = local%beam_structure)
    end if
    
    if (intg%process_has_me) then
       call intg%process%get_pdg_in (pdg_prc)
    else
       allocate (pdg_prc (n_in, n_components))
       pdg_prc = 0
    end if
    call dispatch_sf_config (sf_config, sf_prop, local, pdg_prc)
    sf_trace = &
         var_list%get_lval (var_str ("?sf_trace"))
    sf_trace_file = &
         var_list%get_sval (var_str ("$sf_trace_file"))
    if (sf_trace) then
       call intg%process%init_sf_chain (sf_config, sf_trace_file)
    else
       call intg%process%init_sf_chain (sf_config)
    end if

    if (intg%process_has_me) then
       call intg%process%configure_phs &
            (intg%rebuild_phs, intg%ignore_phs_mismatch, verbose=verbose, &
             combined_integration=intg%combined_integration)
       if (size (sf_config) > 0) then
          call intg%process%collect_channels (phs_channel_collection)
       else if (intg%process%contains_trivial_component ()) then
          call msg_fatal ("Integrate: 2 -> 1 process can't be handled &
               &with fixed-energy beams")
       end if
       call dispatch_sf_channels &
            (sf_channel, sf_string, sf_prop, phs_channel_collection, local)
       if (allocated (sf_channel)) then
          if (size (sf_channel) > 0) then
             call intg%process%set_sf_channel (sf_channel)
          end if
       end if
       call phs_channel_collection%final ()
       if (verb)  call intg%process%sf_startup_message (sf_string)    
    end if
    
    call intg%setup_process_mci ()
    call intg%process%setup_terms ()

    if (associated (local%pn%cuts_lexpr)) then
       if (verb)  call msg_message ("Applying user-defined cuts.")
       call expr_factory%init (local%pn%cuts_lexpr)
       call intg%process%set_cuts (expr_factory)
    else
       if (verb)  call msg_warning ("No cuts have been defined.")
    end if    
    if (associated (local%pn%scale_expr)) then
       if (verb) call msg_message ("Using user-defined general scale.")
       call expr_factory%init (local%pn%scale_expr)
       call intg%process%set_scale (expr_factory)
    end if
    if (associated (local%pn%fac_scale_expr)) then
       if (verb) call msg_message ("Using user-defined factorization scale.")
       call expr_factory%init (local%pn%fac_scale_expr)
       call intg%process%set_fac_scale (expr_factory)
    end if
    if (associated (local%pn%ren_scale_expr)) then
       if (verb) call msg_message ("Using user-defined renormalization scale.")
       call expr_factory%init (local%pn%ren_scale_expr)
       call intg%process%set_ren_scale (expr_factory)
    end if
    if (associated (local%pn%weight_expr)) then
       if (verb) call msg_message ("Using user-defined reweighting factor.")
       call expr_factory%init (local%pn%weight_expr)
       call intg%process%set_weight (expr_factory)
    end if

    call intg%process%compute_md5sum ()
  end subroutine integration_setup_process

@ %def integration_setup_process
@
\subsection{Integration}
Integrate: do the final integration.  Here, we do a multi-iteration
integration.  Again, we skip iterations that are already on file.
Record the results in the global variable list.
<<Integrations: integration: TBP>>=
  procedure :: evaluate => integration_evaluate
<<Integrations: procedures>>=
  subroutine integration_evaluate &
       (intg, process_instance, i_mci, pass, it_list, pacify)
    class(integration_t), intent(inout) :: intg
    type(process_instance_t), intent(inout), target :: process_instance
    integer, intent(in) :: i_mci
    integer, intent(in) :: pass
    type(iterations_list_t), intent(in) :: it_list
    logical, intent(in), optional :: pacify
    integer :: n_calls, n_it
    logical :: adapt_grids, adapt_weights, final
        
    n_it = it_list%get_n_it (pass)
    n_calls = it_list%get_n_calls (pass)
    adapt_grids = it_list%adapt_grids (pass)
    adapt_weights = it_list%adapt_weights (pass)
    final = pass == it_list%get_n_pass ()
    
    call intg%process%integrate (process_instance, &
         i_mci, n_it, n_calls, adapt_grids, adapt_weights, &
         final, pacify)

  end subroutine integration_evaluate

@ %def integration_evaluate
@ In case the user has not provided a list of iterations, make a
reasonable default.  This can depend on the process.  The usual
approach is to define two distinct passes, one for adaptation and one
for integration.
<<Integrations: integration: TBP>>=
  procedure :: make_iterations_list => integration_make_iterations_list
<<Integrations: procedures>>=
  subroutine integration_make_iterations_list (intg, it_list)
    class(integration_t), intent(in) :: intg
    type(iterations_list_t), intent(out) :: it_list
    integer :: pass, n_pass
    integer, dimension(:), allocatable :: n_it, n_calls
    logical, dimension(:), allocatable :: adapt_grids, adapt_weights
    n_pass = intg%process%get_n_pass_default ()
    allocate (n_it (n_pass), n_calls (n_pass))
    allocate (adapt_grids (n_pass), adapt_weights (n_pass))
    do pass = 1, n_pass
       n_it(pass)          = intg%process%get_n_it_default (pass)
       n_calls(pass)       = intg%process%get_n_calls_default (pass)
       adapt_grids(pass)   = intg%process%adapt_grids_default (pass)
       adapt_weights(pass) = intg%process%adapt_weights_default (pass)
    end do
    call it_list%init (n_it, n_calls, &
         adapt_grids = adapt_grids, adapt_weights = adapt_weights)
  end subroutine integration_make_iterations_list
  
@ %def integration_make_iterations_list
@
\subsection{API for integration objects}
This initializer does everything except assigning cuts/scale/weight
expressions.  
<<Integrations: integration: TBP>>=
  procedure :: init => integration_init
<<Integrations: procedures>>=
  subroutine integration_init (intg, process_id, local, global, local_stack)
    class(integration_t), intent(out) :: intg
    type(string_t), intent(in) :: process_id
    type(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(inout), optional, target :: global
    logical, intent(in), optional :: local_stack
    logical :: use_local
    use_local = .false.;  if (present (local_stack))  use_local = local_stack
    if (present (global)) then
       call intg%create_process (process_id, global)
    else if (use_local) then
       call intg%create_process (process_id, local)
    else
       call intg%create_process (process_id)
    end if
    call intg%init_process (local)
    call intg%setup_process (local)
  end subroutine integration_init

@ %def integration_init
@ Do the integration for a single process, both warmup and final evaluation.
The [[eff_reset]] flag is to suppress numerical noise in the graphical output
of the integration history.
<<Integrations: integration: TBP>>=
  procedure :: integrate => integration_integrate
<<Integrations: procedures>>=
  subroutine integration_integrate (intg, local, eff_reset)
    class(integration_t), intent(inout) :: intg
    type(rt_data_t), intent(in), target :: local
    logical, intent(in), optional :: eff_reset
    type(string_t) :: log_filename
    type(var_list_t), pointer :: var_list
    type(process_instance_t), allocatable, target :: process_instance
    type(iterations_list_t) :: it_list
    logical :: pacify
    integer :: pass, i_mci, n_mci, n_pass
    integer :: nlo_type
    logical :: display_summed
    logical :: use_internal_color_correlations

    var_list => intg%process%get_var_list_ptr ()
    use_internal_color_correlations = &
         .not. var_list%get_lval (var_str ('?use_gosam_correlations'))

    allocate (process_instance)
    call process_instance%init (intg%process, use_internal_color_correlations, &
                                combined_integration = intg%combined_integration)

    if (process_instance%has_nlo_component ()) then
       call process_instance%create_blha_interface ()
       call process_instance%load_blha_libraries (local%os_data)
       call process_instance%set_blha_constants (var_list)
    end if

    call openmp_set_num_threads_verbose &
         (var_list%get_ival (var_str ("openmp_num_threads")), &
          var_list%get_lval (var_str ("?openmp_logging")))
    pacify = var_list%get_lval (var_str ("?pacify"))

    display_summed = .true.
    n_mci = intg%process%get_n_mci ()
    if (n_mci == 1) then
       write (msg_buffer, "(A,A,A)") &
            "Starting integration for process '", &
            char (intg%process%get_id ()), "'"
       call msg_message ()
    end if
    call intg%setup_component_cores ()

    do i_mci = 1, n_mci
       if (intg%process%is_active_nlo_component (i_mci)) then
         if (n_mci > 1) then
            write (msg_buffer, "(A,A,A,I0)") &
                 "Starting integration for process '", &
                 char (intg%process%get_id ()), "' part ", i_mci
            call msg_message ()
         end if
         n_pass = local%it_list%get_n_pass ()
         if (n_pass == 0) then
            call msg_message ("Integrate: iterations not specified, &
                 &using default")
            call intg%make_iterations_list (it_list)
            n_pass = it_list%get_n_pass ()
         else
            it_list = local%it_list
         end if
         call msg_message ("Integrate: " // char (it_list%to_string ()))
         do pass = 1, n_pass
            call intg%evaluate (process_instance, i_mci, pass, it_list, pacify)
            if (signal_is_pending ())  return
         end do
         call intg%process%final_integration (i_mci)       
         if (intg%vis_history) then
            call intg%process%display_integration_history &
                 (i_mci, intg%history_filename, local%os_data, eff_reset)
         end if       
         if (local%logfile == intg%log_filename) then
            if (intg%run_id /= "") then
               log_filename = intg%process_id // "." // intg%run_id // &
                    ".var.log"
            else
               log_filename = intg%process_id // ".var.log"
            end if
            call msg_message ("Name clash for global logfile and process log: ", &
                 arr =[var_str ("| Renaming log file from ") // local%logfile, &
                       var_str ("|   to ") // log_filename // var_str (" .")])
         else
            log_filename = intg%log_filename
         end if
         call intg%process%write_logfile (i_mci, log_filename)    
       else
         nlo_type = intg%process%get_component_nlo_type (i_mci)
         if (nlo_type /= NLO_SUBTRACTION) display_summed = .false.
       end if          
    end do

    if (n_mci > 1 .and. display_summed) then
       call msg_message ("Integrate: sum of all components")
       call intg%process%display_summed_results ()
    end if

    call process_instance%final ()
    deallocate (process_instance)

  end subroutine integration_integrate
  
@ %def integration_integrate
@
<<Integrations: integration: TBP>>=
  procedure :: setup_component_cores => integration_setup_component_cores
<<Integrations: procedures>>=
  subroutine integration_setup_component_cores (intg)
    class(integration_t), intent(inout) :: intg
    associate (process => intg%process)
       call setup_nlo_component_cores (process)
    end associate
  end subroutine integration_setup_component_cores

@ %def integration_setup_component_cores
@
<<Integrations: integration: TBP>>=
  procedure :: setup_process_mci => integration_setup_process_mci
<<Integrations: procedures>>=
  subroutine integration_setup_process_mci (intg)
    class(integration_t), intent(inout) :: intg
    call intg%process%setup_mci (intg%combined_integration)
  end subroutine integration_setup_process_mci

@ %def integration_setup_process_mci@
@ Do a dummy integration for a process which could not be initialized (e.g.,
has no matrix element).  The result is zero.
<<Integrations: integration: TBP>>=
  procedure :: integrate_dummy => integration_integrate_dummy 
<<Integrations: procedures>>=
  subroutine integration_integrate_dummy (intg)
    class(integration_t), intent(inout) :: intg
    call intg%process%integrate_dummy ()
  end subroutine integration_integrate_dummy
     
@ %def integration_integrate_dummy
@ Just sample the matrix element under realistic conditions (but no
cuts); throw away the results.
<<Integrations: integration: TBP>>=
  procedure :: sampler_test => integration_sampler_test
<<Integrations: procedures>>=
  subroutine integration_sampler_test (intg)
    class(integration_t), intent(inout) :: intg
    type(process_instance_t), allocatable, target :: process_instance
    integer :: n_mci, i_mci
    type(timer_t) :: timer_mci, timer_tot
    real(default) :: t_mci, t_tot
    allocate (process_instance)
    call process_instance%init (intg%process)
    n_mci = intg%process%get_n_mci ()
    if (n_mci == 1) then
       write (msg_buffer, "(A,A,A)") &
            "Test: probing process '", &
            char (intg%process%get_id ()), "'"
       call msg_message ()
    end if
    call timer_tot%start ()
    do i_mci = 1, n_mci
       if (n_mci > 1) then
          write (msg_buffer, "(A,A,A,I0)") &
               "Test: probing process '", &
               char (intg%process%get_id ()), "' part ", i_mci
          call msg_message ()
       end if
       call timer_mci%start ()
       call intg%process%sampler_test &
            (process_instance, i_mci, intg%n_calls_test)
       call timer_mci%stop ()
       t_mci = timer_mci
       write (msg_buffer, "(A,ES12.5)")  "Test: " &
            // "time in seconds (wallclock): ", t_mci
       call msg_message ()
    end do
    call timer_tot%stop ()
    t_tot = timer_tot
    if (n_mci > 1) then
       write (msg_buffer, "(A,ES12.5)")  "Test: " &
            // "total time      (wallclock): ", t_tot
       call msg_message ()
    end if
    call process_instance%final ()
  end subroutine integration_sampler_test

@ %def integration_sampler_test
@ Return the process pointer (needed by simulate):
<<Integrations: integration: TBP>>=
  procedure :: get_process_ptr => integration_get_process_ptr
<<Integrations: procedures>>=
  function integration_get_process_ptr (intg) result (ptr)
    class(integration_t), intent(in) :: intg
    type(process_t), pointer :: ptr
    ptr => intg%process
  end function integration_get_process_ptr

@ %def integration_get_process_ptr
@ Simply integrate, do a dummy integration if necessary.  The [[integration]]
object exists only internally.

If the [[global]] environment is provided, the process object is appended to
the global stack.  Otherwise, if [[local_stack]] is set, we append to the
local process stack.  If this is unset, the [[process]] object is not recorded
permanently.

The [[init_only]] flag can be used to skip the actual integration part.  We
will end up with a process object that is completely initialized, including
phase space configuration. 

The [[eff_reset]] flag is to suppress numerical noise in the visualization
of the integration history.
<<Integrations: public>>=
  public :: integrate_process
<<Integrations: procedures>>=
  subroutine integrate_process (process_id, local, global, local_stack, init_only, eff_reset)
    type(string_t), intent(in) :: process_id
    type(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(inout), optional, target :: global
    logical, intent(in), optional :: local_stack, init_only, eff_reset
    type(string_t) :: prclib_name
    type(integration_t) :: intg
    character(32) :: buffer

    if (.not. associated (local%prclib)) then
       call msg_fatal ("Integrate: current process library is undefined")
       return
    end if

    if (.not. local%prclib%is_active ()) then
       call msg_message ("Integrate: current process library needs compilation")
       prclib_name = local%prclib%get_name ()
       call compile_library (prclib_name, local)
       if (signal_is_pending ())  return
       call msg_message ("Integrate: compilation done")
    end if

    call intg%init (process_id, local, global, local_stack)
    if (signal_is_pending ())  return

    if (present (init_only)) then
       if (init_only) return
    end if

    if (intg%n_calls_test > 0) then
       write (buffer, "(I0)")  intg%n_calls_test
       call msg_message ("Integrate: test (" // trim (buffer) // " calls) ...")
       call intg%sampler_test ()
       call msg_message ("Integrate: ... test complete.")
       if (signal_is_pending ())  return
    end if

    if (intg%phs_only) then
       call msg_message ("Integrate: phase space only, skipping integration")
    else
       if (intg%process_has_me) then
          call intg%integrate (local, eff_reset)
       else
          call intg%integrate_dummy ()
       end if
    end if

  end subroutine integrate_process

@ %def integrate_process
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Integrations: public>>=
  public :: integrations_test
<<Integrations: tests>>=
  subroutine integrations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Integrations: execute tests>>
  end subroutine integrations_test

@ %def integrations_test
@ 
<<Integrations: public>>=
  public :: integrations_history_test    
<<Integrations: tests>>=
  subroutine integrations_history_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Integrations: execute history tests>>
  end subroutine integrations_history_test  

@ %def integrations_history_test
@ 
\subsubsection{Integration of test process}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type).  The phase-space implementation is [[phs_single]]
(single-particle phase space), the integrator is [[mci_midpoint]].

The cross section for the $2\to 2$ process $ss\to ss$ with its
constant matrix element is given by
\begin{equation}
  \sigma = c\times f\times \Phi_2 \times |M|^2.
\end{equation}
$c$ is the conversion constant
\begin{equation}
  c = 0.3894\times 10^{12}\;\mathrm{fb}\,\mathrm{GeV}^2.
\end{equation}
$f$ is the flux of the incoming particles with mass
$m=125\,\mathrm{GeV}$ and energy $\sqrt{s}=1000\,\mathrm{GeV}$
\begin{equation}
  f = \frac{(2\pi)^4}{2\lambda^{1/2}(s,m^2,m^2)}
    = \frac{(2\pi)^4}{2\sqrt{s}\,\sqrt{s - 4m^2}}
    = 8.048\times 10^{-4}\;\mathrm{GeV}^{-2}
\end{equation}
$\Phi_2$ is the volume of the two-particle phase space
\begin{equation}
  \Phi_2 = \frac{1}{4(2\pi)^5} = 2.5529\times 10^{-5}.
\end{equation}
The squared matrix element $|M|^2$ is unity.
Combining everything, we obtain
\begin{equation}
  \sigma = 8000\;\mathrm{fb}
\end{equation}
This number should appear as the final result.

Note: In this and the following test, we reset the Fortran compiler and flag
variables immediately before they are printed, so the test is portable.
<<Integrations: execute tests>>=
  call test (integrations_1, "integrations_1", &
       "intrinsic test process", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_1"
    write (u, "(A)")  "*   Purpose: integrate test process"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integration_1"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call global%set_string (var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.) 
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)

    call global%write (u, vars = [ &
         var_str ("$method"), &
         var_str ("sqrts"), &
         var_str ("$integration_method"), &
         var_str ("$phs_method"), &
         var_str ("$run_id")])
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_1"
    
  end subroutine integrations_1
  
@ %def integrations_1
@
\subsubsection{Integration with cuts}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) with cuts set.
<<Integrations: execute tests>>=
  call test (integrations_2, "integrations_2", &
       "intrinsic test process with cut", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global

    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    
    type(string_t), dimension(0) :: empty_string_array

    write (u, "(A)")  "* Test output: integrations_2"
    write (u, "(A)")  "*   Purpose: integrate test process with cut"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    write (u, "(A)")  "* Prepare a cut expression"
    write (u, "(A)")

    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    global%pn%cuts_lexpr => parse_tree_get_root_ptr (parse_tree)
    
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "integration_3"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call global%set_string (var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)  
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])
    
    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%write (u, vars = empty_string_array)
    
    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_2"
    
  end subroutine integrations_2
  
@ %def integrations_2
@ 
\subsubsection{Standard phase space}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space implementation.  We
use an explicit phase-space configuration file with a single channel
and integrate by [[mci_midpoint]].
<<Integrations: execute tests>>=
  call test (integrations_3, "integrations_3", &
       "standard phase space", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    integer :: u_phs
    
    write (u, "(A)")  "* Test output: integrations_3"
    write (u, "(A)")  "*   Purpose: integrate test process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integration_3"
    procname = "prc_config_a"
    
    call prepare_test_library (global, libname, 1)
    call compile_library (libname, global)

    call global%set_string (var_str ("$run_id"), &
         var_str ("integrations1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("default"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)   
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    write (u, "(A)")  "* Create a scratch phase-space file"
    write (u, "(A)")

    u_phs = free_unit ()
    open (u_phs, file = "integrations_3.phs", &
         status = "replace", action = "write")
    call write_test_phs_file (u_phs, var_str ("prc_config_a_i1"))
    close (u_phs)

    call global%set_string (var_str ("$phs_file"),&
         var_str ("integrations_3.phs"), is_known = .true.)

    call global%it_list%init ([1], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%write (u, vars = [ &
         var_str ("$phs_method"), &
         var_str ("$phs_file")])
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_3"
    
  end subroutine integrations_3
  
@ %def integrations_3
@ 
\subsubsection{VAMP integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].
<<Integrations: execute tests>>=
  call test (integrations_4, "integrations_4", &
       "VAMP integration (one iteration)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_4 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_4"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_4_lib"
    procname = "integrations_4"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = [var_str ("$integration_method")], &
            pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_4"
    
  end subroutine integrations_4
  
@ %def integrations_4
@ 
\subsubsection{Multiple iterations integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
iterations.
<<Integrations: execute tests>>=
  call test (integrations_5, "integrations_5", &
       "VAMP integration (three iterations)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_5 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    
    write (u, "(A)")  "* Test output: integrations_5"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_5_lib"
    procname = "integrations_5"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3], [1000])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = [var_str ("$integration_method")], &
            pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_5"
    
  end subroutine integrations_5
  
@ %def integrations_5
@ 
\subsubsection{Multiple passes integration}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the single-channel ([[phs_single]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
passes with three iterations each.
<<Integrations: execute tests>>=
  call test (integrations_6, "integrations_6", &
       "VAMP integration (three passes)", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_6 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    
    write (u, "(A)")  "* Test output: integrations_6"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()

    libname = "integrations_6_lib"
    procname = "integrations_6"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .false., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3, 3, 3], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_6"
    
  end subroutine integrations_6
  
@ %def integrations_6
@ 
\subsubsection{VAMP and default phase space}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space
implementation.  The integration method is [[vamp]].  We launch three
passes with three iterations each.  We enable channel equivalences and
groves.
<<Integrations: execute tests>>=
  call test (integrations_7, "integrations_7", &
       "VAMP integration with wood phase space", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_7 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    integer :: iostat, u_phs
    character(95) :: buffer
    type(string_t) :: phs_file
    logical :: exist
    
    write (u, "(A)")  "* Test output: integrations_7"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_7_lib"
    procname = "integrations_7"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)    
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([3, 3, 3], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Generated phase-space file"
    write (u, "(A)")

    phs_file = procname // "_i1.r1.phs"
    inquire (file = char (phs_file), exist = exist)
    if (exist) then
       u_phs = free_unit ()
       open (u_phs, file = char (phs_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_phs, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_phs)
    else
       write (u, "(A)")  "[file is missing]"
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_7"
    
  end subroutine integrations_7
  
@ %def integrations_7
@ 
\subsubsection{Structure functions}
Compile and integrate an intrinsic test matrix element ([[prc_test]]
type) using the default ([[phs_wood]]) phase-space
implementation.  The integration method is [[vamp]].  There is a structure
function of type [[unit_test]].

We use a test structure function $f(x)=x$ for both beams.  Together with the
$1/x_1x_2$ factor from the phase-space flux and a unit matrix element, we
should get the same result as previously for the process without structure
functions.  There is a slight correction due to the $m_s$ mass which we set to
zero here.
<<Integrations: execute tests>>=
  call test (integrations_8, "integrations_8", &
       "integration with structure function", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_8 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(flavor_t) :: flv
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: integrations_8"
    write (u, "(A)")  "*   Purpose: integrate test process using VAMP &
         &with structure function"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_8_lib"
    procname = "integrations_8"
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)  
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), 0._default)

    call reset_interaction_counter ()

    call flv%init (25, global%model)
         
    name = flv%get_name ()
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call global%it_list%init ([1], [1000])
    call integrate_process (procname, global, local_stack=.true.)
    
    call global%write (u, vars = [var_str ("ms")])

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_8"
    
  end subroutine integrations_8
  
@ %def integrations_8
@ 
\subsubsection{Integration history for VAMP integration with default
  phase space}
This test is only run when event analysis can be done.
<<Integrations: execute history tests>>=
  call test (integrations_history_1, "integrations_history_1", &
       "Test integration history files", &
       u, results)
<<Integrations: tests>>=
  subroutine integrations_history_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: no_vars
    integer :: iostat, u_his
    character(91) :: buffer
    type(string_t) :: his_file, ps_file, pdf_file
    logical :: exist, exist_ps, exist_pdf
    
    write (u, "(A)")  "* Test output: integrations_history_1"
    write (u, "(A)")  "*   Purpose: test integration history files"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and parameters"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()

    libname = "integrations_history_1_lib"
    procname = "integrations_history_1"

    call global%set_log (var_str ("?vis_history"), &
         .true., is_known = .true.)        
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?phs_s_mapping"),&
         .false., is_known = .true.)    
    
    call prepare_test_library (global, libname, 1, [procname])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_real (var_str ("error_threshold"),&
         5E-6_default, is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known=.true.)    

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([2, 2, 2], [1000, 1000, 1000], &
         adapt = [.true., .true., .false.], &
         adapt_code = [var_str ("wg"), var_str ("g"), var_str ("")])

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call reset_interaction_counter ()
    call integrate_process (procname, global, local_stack=.true., &
         eff_reset = .true.)
    
    call global%pacify (efficiency_reset = .true., error_reset = .true.)
    call global%write (u, vars = no_vars, pacify = .true.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generated history files"
    write (u, "(A)")

    his_file = procname // ".r1-history.tex"
    ps_file  = procname // ".r1-history.ps"
    pdf_file = procname // ".r1-history.pdf"
    inquire (file = char (his_file), exist = exist)
    if (exist) then
       u_his = free_unit ()
       open (u_his, file = char (his_file), action = "read", status = "old")
       iostat = 0
       do while (iostat == 0)
          read (u_his, "(A)", iostat = iostat)  buffer
          if (iostat == 0)  write (u, "(A)")  trim (buffer)
       end do
       close (u_his)
    else
       write (u, "(A)")  "[History LaTeX file is missing]"
    end if
    inquire (file = char (ps_file), exist = exist_ps)
    if (exist_ps) then
       write (u, "(A)")  "[History Postscript file exists and is nonempty]"
    else
       write (u, "(A)")  "[History Postscript file is missing/non-regular]"
    end if
    inquire (file = char (pdf_file), exist = exist_pdf)
    if (exist_pdf) then
       write (u, "(A)")  "[History PDF file exists and is nonempty]"
    else
       write (u, "(A)")  "[History PDF file is missing/non-regular]"
    end if    
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    call syntax_phs_forest_final ()
    call syntax_model_file_final ()    
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: integrations_history_1"
    
  end subroutine integrations_history_1
  
@ %def integrations_history_1
@ 
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Event Streams}
This module manages I/O from/to multiple concurrent event streams.
Usually, there is at most one input stream, but several output
streams.  For the latter, we set up an array which can hold [[eio_t]]
(event I/O) objects of different dynamic types simultaneously.  One of
them may be marked as an input channel.
<<[[event_streams.f90]]>>=
<<File header>>

module event_streams
  
<<Use kinds>>
<<Use strings>>
  use io_units
  use unit_tests
  use diagnostics
  use variables
  use model_data
  use models
  use processes
  use events
  use eio_data
  use eio_base
  use rt_data
  use dispatch
  
<<Standard module head>>

<<Event streams: public>>

<<Event streams: types>>

contains

<<Event streams: tests>>

<<Event streams: procedures>>

end module event_streams
@ %def event_streams
@
\subsection{Event Stream Array}
Each entry is an [[eio_t]] object.  Since the type is dynamic, we need
a wrapper:
<<Event streams: types>>=
  type :: event_stream_entry_t
     class(eio_t), allocatable :: eio
  end type event_stream_entry_t
  
@ %def event_stream_entry_t
@ An array of event-stream entry objects.  If one of the entries is an
input channel, [[i_in]] is the corresponding index.
<<Event streams: public>>=
  public :: event_stream_array_t
<<Event streams: types>>=
  type :: event_stream_array_t
     type(event_stream_entry_t), dimension(:), allocatable :: entry
     integer :: i_in = 0
   contains
   <<Event streams: event stream array: TBP>>
  end type event_stream_array_t
  
@ %def event_stream_array_t
@ Output.
<<Event streams: event stream array: TBP>>=
  procedure :: write => event_stream_array_write
<<Event streams: procedures>>=
  subroutine event_stream_array_write (object, unit)
    class(event_stream_array_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Event stream array:"
    if (allocated (object%entry)) then
       select case (size (object%entry))
       case (0)
          write (u, "(3x,A)")  "[empty]"
       case default
          do i = 1, size (object%entry)
             if (i == object%i_in)  write (u, "(1x,A)")  "Input stream:"
             call object%entry(i)%eio%write (u)
          end do
       end select
    else
       write (u, "(3x,A)")  "[undefined]"
    end if
  end subroutine event_stream_array_write

@ %def event_stream_array_write
@ Finalize all streams.
<<Event streams: event stream array: TBP>>=
  procedure :: final => event_stream_array_final
<<Event streams: procedures>>=
  subroutine event_stream_array_final (es_array)
    class(event_stream_array_t), intent(inout) :: es_array
    integer :: i
    do i = 1, size (es_array%entry)
       call es_array%entry(i)%eio%final ()
    end do
  end subroutine event_stream_array_final

@ %def event_stream_array_final
@ Initialization.  We use a generic [[sample]] name, open event I/O
objects for all provided stream types (using the [[dispatch_eio]]
routine), and initialize for the given list of process pointers.  If
there is an [[input]] argument, this channel is initialized as an input
channel and appended to the array.

The [[input_data]] or, if not present, [[data]] may be modified.  This
happens if we open a stream for reading and get new information there.
<<Event streams: event stream array: TBP>>=
  procedure :: init => event_stream_array_init
<<Event streams: procedures>>=
  subroutine event_stream_array_init &
       (es_array, sample, stream_fmt, global, &
       data, input, input_sample, input_data, allow_switch, checkpoint, &
       error)
    class(event_stream_array_t), intent(out) :: es_array
    type(string_t), intent(in) :: sample
    type(string_t), dimension(:), intent(in) :: stream_fmt
    type(rt_data_t), intent(in) :: global
    type(event_sample_data_t), intent(inout), optional :: data
    type(string_t), intent(in), optional :: input
    type(string_t), intent(in), optional :: input_sample
    type(event_sample_data_t), intent(inout), optional :: input_data
    logical, intent(in), optional :: allow_switch
    integer, intent(in), optional :: checkpoint
    logical, intent(out), optional :: error
    type(string_t) :: sample_in
    integer :: n, i
    logical :: success, switch
    if (present (input)) then
       n = size (stream_fmt) + 1
    else
       n = size (stream_fmt)
    end if
    if (present (input_sample)) then
       sample_in = input_sample
    else
       sample_in = sample
    end if
    if (present (allow_switch)) then
       switch = allow_switch
    else
       switch = .true.
    end if
    if (present (error)) then
       error = .false.
    end if
    if (present (checkpoint)) then
       allocate (es_array%entry (n + 1))
       call dispatch_eio &
            (es_array%entry(n+1)%eio, var_str ("checkpoint"), global)
       call es_array%entry(n+1)%eio%init_out (sample, data)
    else
       allocate (es_array%entry (n))
    end if
    if (present (input)) then
       call dispatch_eio (es_array%entry(n)%eio, input, global)
       if (present (input_data)) then
          call es_array%entry(n)%eio%init_in (sample_in, input_data, success)
       else
          call es_array%entry(n)%eio%init_in (sample_in, data, success)
       end if
       if (success) then
          es_array%i_in = n
       else if (present (input_sample)) then
          if (present (error)) then
             error = .true.
          else
             call msg_fatal ("Events: &
                  &parameter mismatch in input, aborting")
          end if
       else
          call msg_message ("Events: &
               &parameter mismatch, discarding old event set")
          call es_array%entry(n)%eio%final ()
          if (switch) then
             call msg_message ("Events: generating new events")
             call es_array%entry(n)%eio%init_out (sample, data)
          end if
       end if
    end if
    do i = 1, size (stream_fmt)
       call dispatch_eio (es_array%entry(i)%eio, stream_fmt(i), global)
       call es_array%entry(i)%eio%init_out (sample, data)
    end do
  end subroutine event_stream_array_init
  
@ %def event_stream_array_init
@ Switch the (only) input channel to an output channel, so further
events are appended to the respective stream.
<<Event streams: event stream array: TBP>>=
  procedure :: switch_inout => event_stream_array_switch_inout
<<Event streams: procedures>>=
  subroutine event_stream_array_switch_inout (es_array)
    class(event_stream_array_t), intent(inout) :: es_array
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%switch_inout ()
       es_array%i_in = 0
    else
       call msg_bug ("Reading events: switch_inout: no input stream selected")
    end if
  end subroutine event_stream_array_switch_inout
  
@ %def event_stream_array_switch_inout
@ Output an event (with given process number) to all output streams.
If there is no output stream, do nothing.
<<Event streams: event stream array: TBP>>=
  procedure :: output => event_stream_array_output
<<Event streams: procedures>>=
  subroutine event_stream_array_output (es_array, event, i_prc, &
                                        event_index, passed, pacify)
    class(event_stream_array_t), intent(inout) :: es_array
    type(event_t), intent(in), target :: event
    integer, intent(in) :: i_prc, event_index
    logical, intent(in), optional :: passed, pacify
    integer :: i
    do i = 1, size (es_array%entry)
       if (i /= es_array%i_in) then
          associate (eio => es_array%entry(i)%eio)
            if (eio%split) then
               if (event_index > 1 .and. &
                    mod (event_index, eio%split_n_evt) == 1) then
                  call eio%split_out ()
               end if
            end if
            call eio%output (event, i_prc, reading = es_array%i_in /= 0, &
                 passed = passed, &
                 pacify = pacify)
          end associate
       end if
    end do
  end subroutine event_stream_array_output
  
@ %def event_stream_array_output
@ Input the [[i_prc]] index which selects the process for the current
event.  This is separated from reading the event, because it
determines which event record to read.  [[iostat]] may indicate an
error or an EOF condition, as usual.
<<Event streams: event stream array: TBP>>=
  procedure :: input_i_prc => event_stream_array_input_i_prc
<<Event streams: procedures>>=
  subroutine event_stream_array_input_i_prc (es_array, i_prc, iostat)
    class(event_stream_array_t), intent(inout) :: es_array
    integer, intent(out) :: i_prc
    integer, intent(out) :: iostat
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%input_i_prc (i_prc, iostat)
    else
       call msg_fatal ("Reading events: no input stream selected")
    end if
  end subroutine event_stream_array_input_i_prc
  
@ %def event_stream_array_input_i_prc
@ Input an event from the selected input stream.  [[iostat]] may indicate an
error or an EOF condition, as usual.
<<Event streams: event stream array: TBP>>=
  procedure :: input_event => event_stream_array_input_event
<<Event streams: procedures>>=
  subroutine event_stream_array_input_event (es_array, event, iostat)
    class(event_stream_array_t), intent(inout) :: es_array
    type(event_t), intent(inout), target :: event
    integer, intent(out) :: iostat
    integer :: n
    if (es_array%has_input ()) then
       n = es_array%i_in
       call es_array%entry(n)%eio%input_event (event, iostat)
    else
       call msg_fatal ("Reading events: no input stream selected")
    end if
  end subroutine event_stream_array_input_event
  
@ %def event_stream_array_input_event
@ Return true if there is an input channel among the event streams.
<<Event streams: event stream array: TBP>>=
  procedure :: has_input => event_stream_array_has_input
<<Event streams: procedures>>=
  function event_stream_array_has_input (es_array) result (flag)
    class(event_stream_array_t), intent(in) :: es_array
    logical :: flag
    flag = es_array%i_in /= 0
  end function event_stream_array_has_input
  
@ %def event_stream_array_has_input
@ 
\subsection{Unit Tests}
<<Event streams: public>>=
  public :: event_streams_test
<<Event streams: tests>>=
  subroutine event_streams_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Event streams: execute tests>>
  end subroutine event_streams_test
  
@ %def event_streams_test
@
\subsubsection{Empty event stream}
This should set up an empty event output stream array, including
initialization, output, and finalization (which are all no-ops).
<<Event streams: execute tests>>=
  call test (event_streams_1, "event_streams_1", &
       "empty event stream array", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_1 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(event_t) :: event
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array

    write (u, "(A)")  "* Test output: event_streams_1"
    write (u, "(A)")  "*   Purpose: handle empty event stream array"
    write (u, "(A)")

    sample = "event_streams_1"

    call es_array%init (sample, empty_string_array, global)
    call es_array%output (event, 42, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_1"
    
  end subroutine event_streams_1
  
@ %def event_streams_1
@
\subsubsection{Nontrivial event stream}
Here we generate a trivial event and choose [[raw]] output as an entry in
the stream array.
<<Event streams: execute tests>>=
  call test (event_streams_2, "event_streams_2", &
       "nontrivial event stream array", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_2 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(model_data_t), target :: model
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    integer :: i_prc, iostat

    write (u, "(A)")  "* Test output: event_streams_2"
    write (u, "(A)")  "*   Purpose: handle empty event stream array"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Allocate raw eio stream and write event to file"
    write (u, "(A)")

    sample = "event_streams_2"

    call es_array%init (sample, [var_str ("raw")], global)
    call es_array%output (event, 1, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    sample = "foo"
    call es_array%init (sample, empty_string_array, global, &
         input = var_str ("raw"), input_sample = var_str ("event_streams_2"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    
    write (u, "(1x,A,I0)")  "i_prc = ", i_prc
    write (u, "(A)")
    call es_array%input_event (event, iostat)
    call es_array%final ()
    
    call event%write (u)
    
    call global%final ()

    call model%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_2"
    
  end subroutine event_streams_2
  
@ %def event_streams_2
@
\subsubsection{Switch in/out}
Here we generate an event file and test switching from writing to
reading when the file is exhausted.
<<Event streams: execute tests>>=
  call test (event_streams_3, "event_streams_3", &
       "switch input/output", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_3 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(model_data_t), target :: model
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    integer :: i_prc, iostat

    write (u, "(A)")  "* Test output: event_streams_3"
    write (u, "(A)")  "*   Purpose: handle in/out switching"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call model%init_test ()

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()

    allocate (event)
    call event%basic_init ()
    call event%connect (process_instance, process%get_model_ptr ())
    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()

    write (u, "(A)") "* Allocate raw eio stream and write event to file"
    write (u, "(A)")

    sample = "event_streams_3"

    call es_array%init (sample, [var_str ("raw")], global)
    call es_array%output (event, 1, 1)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, global, &
         input = var_str ("raw"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    call es_array%input_event (event, iostat)

    write (u, "(A)") "* Attempt to read another event (fail), then generate"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    if (iostat < 0) then
       call es_array%switch_inout ()
       call event%generate (1, [0.3_default, 0.3_default])
       call event%evaluate_expressions ()
       call es_array%output (event, 1, 2)
    end if
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, global, &
         input = var_str ("raw"))
    call es_array%write (u)

    write (u, "(A)")
    write (u, "(A)") "* Reread two events and display 2nd event"
    write (u, "(A)")
    
    call es_array%input_i_prc (i_prc, iostat)
    call es_array%input_event (event, iostat)
    call es_array%input_i_prc (i_prc, iostat)
    
    call es_array%input_event (event, iostat)
    call es_array%final ()

    call event%write (u)
    
    call global%final ()
    
    call model%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_3"
    
  end subroutine event_streams_3
  
@ %def event_streams_3
@
\subsubsection{Checksum}
Here we generate an event file and repeat twice, once with identical
parameters and once with modified parameters.
<<Event streams: execute tests>>=
  call test (event_streams_4, "event_streams_4", &
       "check MD5 sum", &
       u, results)
<<Event streams: tests>>=
  subroutine event_streams_4 (u)
    integer, intent(in) :: u
    type(event_stream_array_t) :: es_array
    type(rt_data_t) :: global
    type(process_t), allocatable, target :: process
    type(string_t) :: sample
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data

    write (u, "(A)")  "* Test output: event_streams_4"
    write (u, "(A)")  "*   Purpose: handle in/out switching"
    write (u, "(A)")

    write (u, "(A)")  "* Generate test process event"
    write (u, "(A)")

    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    
    call global%set_log (var_str ("?check_event_file"), &
         .true., is_known = .true.)

    allocate (process)

    write (u, "(A)") "* Allocate raw eio stream for writing"
    write (u, "(A)")

    sample = "event_streams_4"
    data%md5sum_cfg = "1234567890abcdef1234567890abcdef"

    call es_array%init (sample, [var_str ("raw")], global, data)
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Reallocate raw eio stream for reading"
    write (u, "(A)")

    call es_array%init (sample, empty_string_array, global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()

    write (u, "(A)")
    write (u, "(A)") "* Reallocate modified raw eio stream for reading (fail)"
    write (u, "(A)")

    data%md5sum_cfg = "1234567890______1234567890______"
    call es_array%init (sample, empty_string_array, global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()
    
    write (u, "(A)")
    write (u, "(A)") "* Repeat ignoring checksum"
    write (u, "(A)")

    call global%set_log (var_str ("?check_event_file"), &
         .false., is_known = .true.)
    call es_array%init (sample, empty_string_array, global, &
         data, input = var_str ("raw"))
    call es_array%write (u)
    call es_array%final ()
    
    call global%final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: event_streams_4"
    
  end subroutine event_streams_4
  
@ %def event_streams_4
@ 
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Simulation}
This module manages simulation: event generation and reading/writing of event
files.  The [[simulation]] object is intended to be used (via a pointer)
outside of \whizard, if events are generated individually by an external
driver.
<<[[simulations.f90]]>>=
<<File header>>

module simulations

<<Use kinds>>
<<Use strings>>
  use io_units
  use format_utils, only: write_separator
  use format_defs, only: FMT_19
  use unit_tests
  use diagnostics
  use sm_qcd
  use md5
  use ifiles
  use lexers
  use parser
  use variables
  use eval_trees
  use model_data
  use flavors
  use particles
  use state_matrices
  use interactions
  use models
  use beams
  use phs_forests
  use rng_base
  use selectors
  use prc_core
  use prclib_stacks
  use processes
  use event_base
  use events
  use event_transforms
  use decays
  use shower
  use eio_data
  use eio_base
  use eio_raw
  use eio_ascii
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams
<<Standard module head>>

<<Simulations: public>>

<<Simulations: types>>

<<Simulations: interfaces>>

contains

<<Simulations: procedures>>

<<Simulations: tests>>

end module simulations
@ %def simulations
@
\subsection{Event counting}
In this object we collect statistical information about an event
sample or sub-sample.
<<Simulations: types>>=
  type :: counter_t
     integer :: total = 0
     integer :: generated = 0
     integer :: read = 0
     integer :: positive = 0
     integer :: negative = 0
     integer :: zero = 0
     integer :: excess = 0
     real(default) :: max_excess = 0
     real(default) :: sum_excess = 0
   contains
   <<Simulations: counter: TBP>>
  end type counter_t
  
@ %def simulation_counter_t
@ Output.
<<Simulations: counter: TBP>>=
  procedure :: write => counter_write
<<Simulations: procedures>>=
  subroutine counter_write (object, unit)
    class(counter_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
1   format (3x,A,I0)
2   format (5x,A,I0)
3   format (5x,A,ES19.12)
    write (u, 1)  "Events total      = ", object%total
    write (u, 2)  "generated       = ", object%generated
    write (u, 2)  "read            = ", object%read
    write (u, 2)  "positive weight = ", object%positive
    write (u, 2)  "negative weight = ", object%negative
    write (u, 2)  "zero weight     = ", object%zero
    write (u, 2)  "excess weight   = ", object%excess
    if (object%excess /= 0) then
       write (u, 3)  "max excess      = ", object%max_excess
       write (u, 3)  "avg excess      = ", object%sum_excess / object%total
    end if
  end subroutine counter_write

@ %def counter_write
@ This is a screen message: if there was an excess, display statistics.
<<Simulations: counter: TBP>>=
  procedure :: show_excess => counter_show_excess
<<Simulations: procedures>>=
  subroutine counter_show_excess (counter)
    class(counter_t), intent(in) :: counter
    if (counter%excess > 0) then
       write (msg_buffer, "(A,1x,I0,1x,A,1x,'(',F7.3,' %)')") &
            "Encountered events with excess weight:", counter%excess, &
            "events", 100 * counter%excess / real (counter%total)
       call msg_warning ()
       write (msg_buffer, "(A,ES10.3)") &
            "Maximum excess weight =", counter%max_excess
       call msg_message ()
       write (msg_buffer, "(A,ES10.3)") &
            "Average excess weight =", counter%sum_excess / counter%total
       call msg_message ()
    end if
  end subroutine counter_show_excess
    
@ %def counter_show_excess
@ Count an event.  The weight and event source are optional; by
default we assume that the event has been generated and has positive
weight.
<<Simulations: counter: TBP>>=
  procedure :: record => counter_record
<<Simulations: procedures>>=
  subroutine counter_record (counter, weight, excess, from_file)
    class(counter_t), intent(inout) :: counter
    real(default), intent(in), optional :: weight, excess
    logical, intent(in), optional :: from_file
    counter%total = counter%total + 1
    if (present (from_file)) then
       if (from_file) then
          counter%read = counter%read + 1
       else
          counter%generated = counter%generated + 1
       end if
    else
       counter%generated = counter%generated + 1
    end if
    if (present (weight)) then
       if (weight > 0) then
          counter%positive = counter%positive + 1
       else if (weight < 0) then
          counter%negative = counter%negative + 1
       else
          counter%zero = counter%zero + 1
       end if
    else
       counter%positive = counter%positive + 1
    end if
    if (present (excess)) then
       if (excess > 0) then
          counter%excess = counter%excess + 1
          counter%max_excess = max (counter%max_excess, excess)
          counter%sum_excess = counter%sum_excess + excess
       end if
    end if
  end subroutine counter_record
    
@ %def counter_record
@
\subsection{Simulation: component sets}
For each set of process components that share a MCI entry in the
process configuration, we keep a separate event record.
<<Simulations: types>>=
  type :: mci_set_t
     private
     integer :: n_components = 0
     integer, dimension(:), allocatable :: i_component
     type(string_t), dimension(:), allocatable :: component_id
     logical :: has_integral = .false.
     real(default) :: integral = 0
     real(default) :: error = 0
     real(default) :: weight_mci = 0
     type(counter_t) :: counter
   contains
   <<Simulations: mci set: TBP>>
  end type mci_set_t
     
@ %def mci_set_t
@ Output.
<<Simulations: mci set: TBP>>=
  procedure :: write => mci_set_write
<<Simulations: procedures>>=
  subroutine mci_set_write (object, unit)
    class(mci_set_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A)")  "Components:"
    do i = 1, object%n_components
       write (u, "(5x,I0,A,A,A)")  object%i_component(i), &
            ": '", char (object%component_id(i)), "'"
    end do
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral  = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error     = ", object%error
       write (u, "(3x,A,F13.10)")  "Weight    =", object%weight_mci
    else
       write (u, "(3x,A)")  "Integral  = [undefined]"
    end if
    call object%counter%write (u)
  end subroutine mci_set_write
  
@ %def mci_set_write
@ Initialize: Get the indices and names for the process components
that will contribute to this set.
<<Simulations: mci set: TBP>>=
  procedure :: init => mci_set_init
<<Simulations: procedures>>=
  subroutine mci_set_init (object, i_mci, process)
    class(mci_set_t), intent(out) :: object
    integer, intent(in) :: i_mci
    type(process_t), intent(in), target :: process
    integer :: i
    call process%get_i_component (i_mci, object%i_component)
    object%n_components = size (object%i_component)
    allocate (object%component_id (object%n_components))
    do i = 1, size (object%component_id)
       object%component_id(i) = &
            process%get_component_id (object%i_component(i))
    end do
    if (process%has_integral (i_mci)) then
       object%integral = process%get_integral (i_mci)
       object%error = process%get_error (i_mci)
       object%has_integral = .true.
    end if
  end subroutine mci_set_init
    
@ %def mci_set_init
@
\subsection{Process-core Safe}
This is an object that temporarily holds a process core object.  We
need this while rescanning a process with modified parameters.  After
the rescan, we want to restore the original state.
<<Simulations: types>>=
  type :: core_safe_t
     class(prc_core_t), allocatable :: core
  end type core_safe_t
  
@ %def core_safe_t
@
\subsection{Process Object}
The simulation works on process objects.  This subroutine makes a
process object available for simulation.  The process is in the
process stack.  If integration is not yet
done, do it.  Any generated process object should be put on the global stack,
if it is separate from the local one.
<<Simulations: procedures>>=
  subroutine prepare_process &
       (process, process_id, integrate, local, global)
    type(process_t), pointer, intent(out) :: process
    type(string_t), intent(in) :: process_id
    logical, intent(in) :: integrate
    type(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(inout), optional, target :: global
    if (present (global)) then
       process => global%process_stack%get_process_ptr (process_id)
    else
       process => local%process_stack%get_process_ptr (process_id)
    end if
    if (.not. associated (process)) then
       if (integrate) then
          call msg_message ("Simulate: process '" &
               // char (process_id) // "' needs integration")
       else
          call msg_message ("Simulate: process '" &
               // char (process_id) // "' needs initialization")
       end if
       if (present (global)) then
          call integrate_process (process_id, local, global, &
            init_only = .not. integrate)
       else
          call integrate_process (process_id, local, local_stack=.true., &
            init_only = .not. integrate)
       end if
       if (signal_is_pending ())  return
       process => global%process_stack%get_process_ptr (process_id)
       if (associated (process)) then
          if (integrate) then
             call msg_message ("Simulate: integration done")
             call global%process_stack%fill_result_vars (process_id)
          else
             call msg_message ("Simulate: process initialization done")
          end if
       else
          call msg_fatal ("Simulate: process '" &
               // char (process_id) // "' could not be initialized: aborting")
       end if
    end if
  end subroutine prepare_process
    
@ %def prepare_process
@
\subsection{Simulation entry}
For each process that we consider for event generation, we need a
separate entry.  The entry separately records the process ID and run ID.  The
[[weight_mci]] array is used for selecting a component set (which
shares a MCI record inside the process container) when generating an
event for the current process.

The simulation entry is an extension of the [[event_t]] event record.
This core object contains configuration data, pointers to the process
and process instance, the expressions, flags and values that are
evaluated at runtime, and the resulting particle set.

The entry explicitly allocate the [[process_instance]], which becomes
the process-specific workspace for the event record.

If entries with differing environments are present simultaneously, we
may need to switch QCD parameters and/or the model event by event.  In
this case, the [[qcd]] and/or [[model]] components are present.
<<Simulations: types>>=
  type, extends (event_t) :: entry_t
     private
     type(string_t) :: process_id
     type(string_t) :: library
     type(string_t) :: run_id
     logical :: has_integral = .false.
     real(default) :: integral = 0
     real(default) :: error = 0
     real(default) :: process_weight = 0
     logical :: valid = .false.
     type(counter_t) :: counter
     integer :: n_in = 0
     integer :: n_mci = 0
     type(mci_set_t), dimension(:), allocatable :: mci_set
     type(selector_t) :: mci_selector
     type(core_safe_t), dimension(:), allocatable :: core_safe
     class(model_data_t), pointer :: model => null ()
     type(qcd_t) :: qcd
     logical :: nlo_event = .false.
   contains
   <<Simulations: entry: TBP>>
  end type entry_t

@ %def entry_t
@ Output.  Write just the configuration, the event is written by a
separate routine.

The [[verbose]] option is unused, it is required by the interface of
the base-object method.
<<Simulations: entry: TBP>>=
  procedure :: write_config => entry_write_config
<<Simulations: procedures>>=
  subroutine entry_write_config (object, unit)
    class(entry_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    write (u, "(3x,A,A,A)")  "Process   = '", char (object%process_id), "'"
    write (u, "(3x,A,A,A)")  "Library   = '", char (object%library), "'"
    write (u, "(3x,A,A,A)")  "Run       = '", char (object%run_id), "'"
    write (u, "(3x,A,L1)")   "is valid  = ", object%valid
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral  = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error     = ", object%error
       write (u, "(3x,A,F13.10)")  "Weight    =", object%process_weight
    else
       write (u, "(3x,A)")  "Integral  = [undefined]"
    end if
    write (u, "(3x,A,I0)")   "MCI sets  = ", object%n_mci
    call object%counter%write (u)
    do i = 1, size (object%mci_set)
       write (u, "(A)")
       write (u, "(1x,A,I0,A)")  "MCI set #", i, ":"
       call object%mci_set(i)%write (u)
    end do
    if (allocated (object%core_safe)) then
       do i = 1, size (object%core_safe)
          write (u, "(1x,A,I0,A)")  "Saved process-component core #", i, ":"
          call object%core_safe(i)%core%write (u)
       end do
    end if
  end subroutine entry_write_config
  
@ %def entry_write_config
@ Finalizer.  The [[instance]] pointer component of the [[event_t]]
base type points to a target which we did explicitly allocate in the
[[entry_init]] procedure.  Therefore, we finalize and explicitly
deallocate it here.  Then we call the finalizer of the base type.
<<Simulations: entry: TBP>>=
  procedure :: final => entry_final
<<Simulations: procedures>>=
  subroutine entry_final (object)
    class(entry_t), intent(inout) :: object
    integer :: i
    if (associated (object%instance)) then
       do i = 1, object%n_mci
          call object%instance%final_simulation (i)
       end do
       call object%instance%final ()
       deallocate (object%instance)
    end if
    call object%event_t%final ()
  end subroutine entry_final
  
@ %def entry_final
@ Initialization.  Search for a process entry and allocate a process
instance as an anonymous object, temporarily accessible via the
[[process_instance]] pointer.  Assign data by looking at the process
object and at the environment.

If [[n_alt]] is set, we prepare for additional alternate sqme and weight
entries.

If the process object is not found initially: if [[integrate]] is set, attempt
an integration pass and try again.  Otherwise, just initialize the object.

If [[generate]] is set, prepare the MCI objects for generating new events.
For pure rescanning, this is not necessary.

When done, we assign the [[instance]] and [[process]] pointers of the
base type by the [[connect]] method, so we can reference them later.
<<Simulations: entry: TBP>>=
  procedure :: init => entry_init
<<Simulations: procedures>>=
  subroutine entry_init &
       (entry, process_id, integrate, generate, update_sqme, &
       local, global, n_alt)
    class(entry_t), intent(inout), target :: entry
    type(string_t), intent(in) :: process_id
    logical, intent(in) :: integrate, generate, update_sqme
    type(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(inout), optional, target :: global
    integer, intent(in), optional :: n_alt
    type(process_t), pointer :: process, master_process
    type(process_instance_t), pointer :: process_instance
    integer :: i
    logical :: combined_integration

    call prepare_process (master_process, process_id, integrate, local, global)
    if (signal_is_pending ())  return

    if (.not. master_process%has_matrix_element ()) then
       entry%has_integral = .true.
       entry%process_id = process_id
       entry%valid = .false.          
       return
    end if
    
    call entry%basic_init (local%var_list, n_alt)

    entry%process_id = process_id
    if (generate .or. integrate) then
       entry%run_id = master_process%get_run_id ()
       process => master_process
    else
       call local%set_log (var_str ("?rebuild_phase_space"), &
            .false., is_known = .true.)
       call local%set_log (var_str ("?check_phs_file"), &
            .false., is_known = .true.)
       call local%set_log (var_str ("?rebuild_grids"), &
            .false., is_known = .true.)
       entry%run_id = &
            local%var_list%get_sval (var_str ("$run_id"))
       if (update_sqme) then
          call prepare_local_process (process, process_id, local)
       else
          process => master_process
       end if
    end if

    call entry%import_process_characteristics (process)

    allocate (entry%mci_set (entry%n_mci))
    do i = 1, size (entry%mci_set)
       call entry%mci_set(i)%init (i, master_process)
    end do
    if (process%is_nlo_calculation ()) then
      entry%nlo_event = .true.
      call entry%combine_mci_sets ()
    end if

    call entry%import_process_results (master_process)
    call entry%prepare_expressions (local)

    combined_integration = local%get_lval (var_str ("?combined_nlo_integration"))
    call prepare_process_instance (process_instance, process, local%model, &
                                   combined_integration = combined_integration)
    if (generate) then
       do i = 1, entry%n_mci
          call process%prepare_simulation (i)
          call process_instance%init_simulation (i, entry%config%safety_factor)
       end do
    end if
    call entry%setup_event_transforms (process, local)
    call dispatch_qcd (entry%qcd, local)

    call entry%connect_qcd ()

    if (present (global)) then
       call entry%connect (process_instance, local%model, global%process_stack)
    else
       call entry%connect (process_instance, local%model, local%process_stack)
    end if
    call entry%setup_expressions ()

    entry%model => process%get_model_ptr ()
    entry%valid = .true.
    
  end subroutine entry_init
    
@ %def entry_init
@ Part of simulation-entry initialization: set up a process object for
local use.
<<Simulations: procedures>>=
  subroutine prepare_local_process (process, process_id, local)
    type(process_t), pointer, intent(inout) :: process
    type(string_t), intent(in) :: process_id
    type(rt_data_t), intent(inout), target :: local
    type(integration_t) :: intg
    call intg%create_process (process_id)
    call intg%init_process (local)
    call intg%setup_process (local, verbose=.false.)
    process => intg%get_process_ptr ()
  end subroutine prepare_local_process
  
@ %def prepare_local_process
@ Part of simulation-entry initialization: set up a process instance
matching the selected process object.

The model that we can provide as an extra argument can modify particle
settings (polarization) in the density matrices that will be constructed.  It
does not affect parameters.
<<Simulations: procedures>>=
  subroutine prepare_process_instance (process_instance, process, model, combined_integration)
    type(process_instance_t), pointer, intent(inout) :: process_instance
    type(process_t), intent(inout), target :: process
    class(model_data_t), intent(in), optional :: model
    logical, intent(in), optional :: combined_integration
    allocate (process_instance)
    if (process%is_nlo_calculation ()) then
       call process_instance%init (process, combined_integration = combined_integration)
       call setup_nlo_component_cores (process)
    else
       call process_instance%init (process)
    end if
    call process_instance%setup_event_data (model)
  end subroutine prepare_process_instance 

@ %def prepare_process_instance
@ Part of simulation-entry initialization: query the
process for basic information.
<<Simulations: entry: TBP>>=
  procedure, private :: import_process_characteristics &
       => entry_import_process_characteristics
<<Simulations: procedures>>=
  subroutine entry_import_process_characteristics (entry, process)
    class(entry_t), intent(inout) :: entry
    type(process_t), intent(in), target :: process
    entry%library = process%get_library_name ()
    entry%n_in = process%get_n_in ()
    entry%n_mci = process%get_n_mci ()
  end subroutine entry_import_process_characteristics

@ %def entry_import_process_characteristics
@ Part of simulation-entry initialization: query the
process for integration results.
<<Simulations: entry: TBP>>=
  procedure, private :: import_process_results &
       => entry_import_process_results
<<Simulations: procedures>>=
  subroutine entry_import_process_results (entry, process)
    class(entry_t), intent(inout) :: entry
    type(process_t), intent(in), target :: process
    if (process%has_integral ()) then
       entry%integral = process%get_integral ()
       entry%error = process%get_error ()
       call entry%set_sigma (entry%integral)
       entry%has_integral = .true.
    end if
  end subroutine entry_import_process_results

@ %def entry_import_process_characteristics
@ Part of simulation-entry initialization: create expression factory
objects and store them.
<<Simulations: entry: TBP>>=
  procedure, private :: prepare_expressions &
       => entry_prepare_expressions
<<Simulations: procedures>>=
  subroutine entry_prepare_expressions (entry, local)
    class(entry_t), intent(inout) :: entry
    type(rt_data_t), intent(in), target :: local
    type(eval_tree_factory_t) :: expr_factory
    call expr_factory%init (local%pn%selection_lexpr)
    call entry%set_selection (expr_factory)
    call expr_factory%init (local%pn%reweight_expr)
    call entry%set_reweight (expr_factory)
    call expr_factory%init (local%pn%analysis_lexpr)
    call entry%set_analysis (expr_factory)
  end subroutine entry_prepare_expressions

@ %def entry_prepare_expressions
@ Part of simulation-entry initialization: dispatch event transforms
(decay, shower) as requested.
<<Simulations: entry: TBP>>=
  procedure, private :: setup_event_transforms &
       => entry_setup_event_transforms
<<Simulations: procedures>>=
  subroutine entry_setup_event_transforms (entry, process, local)
    class(entry_t), intent(inout) :: entry
    type(process_t), intent(inout), target :: process
    type(rt_data_t), intent(in), target :: local
    class(evt_t), pointer :: evt
    logical :: enable_shower
    if (process%contains_unstable (local%model)) then
       call dispatch_evt_decay (evt, local)
       if (associated (evt))  call entry%import_transform (evt)
    end if
    enable_shower = local%get_lval (var_str ("?allow_shower")) .and. &
            (local%get_lval (var_str ("?ps_isr_active")) &
            .or. local%get_lval (var_str ("?ps_fsr_active")) &
            .or. local%get_lval (var_str ("?muli_active")) &
            .or. local%get_lval (var_str ("?mlm_matching")) &
            .or. local%get_lval (var_str ("?ckkw_matching")) &
            .or. local%get_lval (var_str ("?powheg_matching")))
    if (enable_shower) then
       call dispatch_evt_shower (evt, local, process)
       call entry%import_transform (evt)
    end if
    if (local%get_lval (var_str ("?hadronization_active"))) then
       call dispatch_evt_hadrons (evt, local, process)
       call entry%import_transform (evt)
    end if
  end subroutine entry_setup_event_transforms

@ %def entry_setup_event_transforms
@ Compute weights.  The integral in the argument is the sum of integrals for
all processes in the sample.  After computing the process weights, we repeat
the normalization procedure for the process components.
<<Simulations: entry: TBP>>=
  procedure :: init_mci_selector => entry_init_mci_selector
<<Simulations: procedures>>=
  subroutine entry_init_mci_selector (entry)
    class(entry_t), intent(inout) :: entry
    integer :: i
    if (entry%has_integral) then
       call entry%mci_selector%init (entry%mci_set%integral)
       do i = 1, entry%n_mci
          entry%mci_set(i)%weight_mci = entry%mci_selector%get_weight (i)
       end do
    end if
  end subroutine entry_init_mci_selector

@ %def entry_init_mci_selector
@ Select a MCI entry, using the embedded random-number generator.
<<Simulations: entry: TBP>>=
  procedure :: select_mci => entry_select_mci
<<Simulations: procedures>>=
  function entry_select_mci (entry) result (i_mci)
    class(entry_t), intent(inout) :: entry
    integer :: i_mci
    call entry%mci_selector%generate (entry%rng, i_mci)
  end function entry_select_mci
  
@ %def entry_select_mci
@ Record an event for this entry, i.e., increment the appropriate counters.
<<Simulations: entry: TBP>>=
  procedure :: record => entry_record
<<Simulations: procedures>>=
  subroutine entry_record (entry, i_mci, from_file)
    class(entry_t), intent(inout) :: entry
    integer, intent(in) :: i_mci
    logical, intent(in), optional :: from_file
    real(default) :: weight, excess
    weight = entry%get_weight_prc ()
    excess = entry%get_excess_prc ()
    call entry%counter%record (weight, excess, from_file)
    call entry%mci_set(i_mci)%counter%record (weight, excess)
  end subroutine entry_record
    
@ %def entry_record
@ Update and restore the process core that this entry accesses, when
parameters change.  If explicit arguments [[model]], [[qcd]], or
[[helicity_selection]] are provided, use those.  Otherwise use the
parameters stored in the process object.
<<Simulations: entry: TBP>>=
  procedure :: update_process => entry_update_process
  procedure :: restore_process => entry_restore_process
<<Simulations: procedures>>=
  subroutine entry_update_process (entry, model, qcd, helicity_selection)
    class(entry_t), intent(inout) :: entry
    class(model_data_t), intent(in), optional, target :: model
    type(qcd_t), intent(in), optional :: qcd
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    type(process_t), pointer :: process
    class(prc_core_t), allocatable :: core
    integer :: i, n_components
    class(model_data_t), pointer :: model_local
    type(qcd_t) :: qcd_local
    if (present (model)) then
       model_local => model
    else
       model_local => entry%model
    end if
    if (present (qcd)) then
       qcd_local = qcd
    else
       qcd_local = entry%qcd
    end if
    process => entry%get_process_ptr ()
    n_components = process%get_n_components ()
    allocate (entry%core_safe (n_components))
    do i = 1, n_components
       if (process%has_matrix_element (i)) then
          call process%extract_component_core (i, core)
          call dispatch_core_update (core, &
               model_local, helicity_selection, qcd_local, &
               entry%core_safe(i)%core)
          call process%restore_component_core (i, core)
       end if
    end do
  end subroutine entry_update_process
  
  subroutine entry_restore_process (entry)
    class(entry_t), intent(inout) :: entry
    type(process_t), pointer :: process
    class(prc_core_t), allocatable :: core
    integer :: i, n_components
    process => entry%get_process_ptr ()
    n_components = process%get_n_components ()
    do i = 1, n_components
       if (process%has_matrix_element (i)) then
          call process%extract_component_core (i, core)
          call dispatch_core_restore (core, entry%core_safe(i)%core)
          call process%restore_component_core (i, core)
       end if
    end do
    deallocate (entry%core_safe)
  end subroutine entry_restore_process
  
@ %def entry_update_process
@ %def entry_restore_process
<<Simulations: entry: TBP>>=
  procedure :: combine_mci_sets => entry_combine_mci_sets
<<Simulations: procedures>>=
  subroutine entry_combine_mci_sets (entry)
    class(entry_t), intent(inout) :: entry
    integer :: n_components_lo, i_component, i_virt
    n_components_lo = entry%n_mci / 3
    do i_component = 1, n_components_lo
      i_virt = i_component + 2*n_components_lo
      entry%mci_set(i_component)%integral = &
        entry%mci_set(i_component)%integral + entry%mci_set(i_virt)%integral
      entry%mci_set(i_component)%error = sqrt (&
        entry%mci_set(i_component)%error**2 + entry%mci_set(i_virt)%error**2)
      entry%mci_set(i_virt)%integral = 0._default
      entry%mci_set(i_virt)%has_integral = .false.
    end do
  end subroutine entry_combine_mci_sets
 
@ %def entry_combine_mci_sets
@
<<Simulations: entry: TBP>>=
  procedure :: connect_qcd => entry_connect_qcd
<<Simulations: procedures>>=
  subroutine entry_connect_qcd (entry)
    class(entry_t), intent(inout), target :: entry
    class(evt_t), pointer :: evt
    evt => entry%transform_first
    do while (associated (evt))
       select type (evt)
       type is (evt_shower_t)
          evt%qcd => entry%qcd
          if (evt%settings%powheg_matching) then
             evt%powheg%qcd => entry%qcd
             call evt%powheg%compute_lambda2_gen ()
          end if
       end select
       evt => evt%next
    end do
  end subroutine entry_connect_qcd

@ %def entry_connect_qcd
@
\subsection{Entries for alternative environment}
Entries for alternate environments.  [No additional components
anymore, so somewhat redundant.]
<<Simulations: types>>=
  type, extends (entry_t) :: alt_entry_t
   contains
   <<Simulations: alt entry: TBP>>
  end type alt_entry_t
  
@ %def alt_entry_t
@ The alternative entries are there to re-evaluate the event, given
momenta, in a different context.

Therefore, we allocate a local process object and use this as the
reference for the local process instance, when initializing the entry.
We temporarily import the [[process]] object into an [[integration_t]]
wrapper, to take advantage of the associated methods.  The local
process object is built in the context of the current environment,
here called [[global]].  Then, we initialize the process instance.

The [[master_process]] object contains the integration results to which we
refer when recalculating an event.  Therefore, we use this object instead of
the locally built [[process]] when we extract the integration results.

The locally built [[process]] object should be finalized when done.  It
remains accessible via the [[event_t]] base object of [[entry]], which
contains pointers to the process and instance.
<<Simulations: alt entry: TBP>>=
  procedure :: init_alt => alt_entry_init
<<Simulations: procedures>>=
  subroutine alt_entry_init (entry, process_id, master_process, local)
    class(alt_entry_t), intent(inout), target :: entry
    type(string_t), intent(in) :: process_id
    type(process_t), intent(in), target :: master_process
    type(rt_data_t), intent(inout), target :: local
    class(rng_factory_t), allocatable :: rng_factory
    type(process_t), pointer :: process
    type(process_instance_t), pointer :: process_instance
    type(string_t) :: run_id
    type(integration_t) :: intg
    integer :: i

    call msg_message ("Simulate: initializing alternate process setup ...")

    run_id = &
         local%var_list%get_sval (var_str ("$run_id"))
    call local%set_log (var_str ("?rebuild_phase_space"), &
         .false., is_known = .true.)
    call local%set_log (var_str ("?check_phs_file"), &
         .false., is_known = .true.)
    call local%set_log (var_str ("?rebuild_grids"), &
         .false., is_known = .true.)
    
    call entry%basic_init (local%var_list)
    
    call prepare_local_process (process, process_id, local)
    entry%process_id = process_id
    entry%run_id = run_id

    call entry%import_process_characteristics (process)
    
    allocate (entry%mci_set (entry%n_mci))
    do i = 1, size (entry%mci_set)
       call entry%mci_set(i)%init (i, master_process)
    end do

    call entry%import_process_results (master_process)
    call entry%prepare_expressions (local)

    call prepare_process_instance (process_instance, process, local%model)
    call entry%setup_event_transforms (process, local)

    call entry%connect (process_instance, local%model, local%process_stack)
    call entry%setup_expressions ()

    entry%model => process%get_model_ptr ()

    call msg_message ("...  alternate process setup complete.")

  end subroutine alt_entry_init

@ %def alt_entry_init
@ Copy the particle set from the master entry to the alternate entry.
This is the particle set of the hard process.
<<Simulations: alt entry: TBP>>=
  procedure :: fill_particle_set => entry_fill_particle_set
<<Simulations: procedures>>=
  subroutine entry_fill_particle_set (alt_entry, entry)
    class(alt_entry_t), intent(inout) :: alt_entry
    class(entry_t), intent(in), target :: entry
    type(particle_set_t) :: pset
    call entry%get_hard_particle_set (pset)
    call alt_entry%set_hard_particle_set (pset)
    call pset%final ()
  end subroutine entry_fill_particle_set
    
@ %def particle_set_copy_prt
@
\subsection{The simulation type}
Each simulation object corresponds to an event sample, identified by
the [[sample_id]].

The simulation may cover several processes simultaneously.  All
process-specific data, including the event records, are stored in the
[[entry]] subobjects.  The [[current]] index indicates which record
was selected last. [[version]] is foreseen to contain a tag on the \whizard\
event file version. It can be 
<<Simulations: public>>=
  public :: simulation_t
<<Simulations: types>>=
  type :: simulation_t
     private
     type(string_t) :: sample_id
     logical :: unweighted = .true.
     logical :: negative_weights = .false.
     logical :: respect_selection = .true.
     integer :: norm_mode = NORM_UNDEFINED
     logical :: update_sqme = .false.
     logical :: update_weight = .false.
     logical :: update_event = .false.
     logical :: recover_beams = .false.
     logical :: pacify = .false.
     integer :: n_max_tries = 10000
     integer :: n_prc = 0
     integer :: n_alt = 0
     logical :: has_integral = .false.
     logical :: valid
     real(default) :: integral = 0
     real(default) :: error = 0
     integer :: version = 1
     character(32) :: md5sum_prc = ""
     character(32) :: md5sum_cfg = ""
     character(32), dimension(:), allocatable :: md5sum_alt
     type(entry_t), dimension(:), allocatable :: entry
     type(alt_entry_t), dimension(:,:), allocatable :: alt_entry
     type(selector_t) :: process_selector
     integer :: n_evt_requested = 0
     integer :: split_n_evt = 0
     integer :: split_index = 0
     type(counter_t) :: counter
     class(rng_t), allocatable :: rng
     integer :: i_prc = 0
     integer :: i_mci = 0
     real(default) :: weight = 0
     real(default) :: excess = 0
   contains
   <<Simulations: simulation: TBP>>
  end type simulation_t
  
@ %def simulation_t
@ Output.  [[write_config]] writes just the configuration.  [[write]]
as a method of the base type [[event_t]]
writes the current event and process instance, depending on options.
<<Simulations: simulation: TBP>>=
  procedure :: write => simulation_write
<<Simulations: procedures>>=
  subroutine simulation_write (object, unit)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u, i
    u = given_output_unit (unit)
    call write_separator (u, 2)
    write (u, "(1x,A,A,A)")  "Event sample: '", char (object%sample_id), "'"
    write (u, "(3x,A,I0)")  "Processes    = ", object%n_prc
    if (object%n_alt > 0) then
       write (u, "(3x,A,I0)")  "Alt.wgts     = ", object%n_alt
    end if
    write (u, "(3x,A,L1)")  "Unweighted   = ", object%unweighted
    write (u, "(3x,A,A)")   "Event norm   = ", &
         char (event_normalization_string (object%norm_mode))
    write (u, "(3x,A,L1)")  "Neg. weights = ", object%negative_weights
    write (u, "(3x,A,L1)")  "Respect sel. = ", object%respect_selection
    write (u, "(3x,A,L1)")  "Update sqme  = ", object%update_sqme
    write (u, "(3x,A,L1)")  "Update wgt   = ", object%update_weight
    write (u, "(3x,A,L1)")  "Update event = ", object%update_event
    write (u, "(3x,A,L1)")  "Recov. beams = ", object%recover_beams
    write (u, "(3x,A,L1)")  "Pacify       = ", object%pacify
    write (u, "(3x,A,I0)")  "Max. tries   = ", object%n_max_tries
    if (object%has_integral) then
       write (u, "(3x,A," // FMT_19 // ")")  "Integral     = ", object%integral
       write (u, "(3x,A," // FMT_19 // ")")  "Error        = ", object%error
    else
       write (u, "(3x,A)")  "Integral     = [undefined]"
    end if
    write (u, "(3x,A,L1)")  "Sim. valid   = ", object%valid
    write (u, "(3x,A,I0)")  "Ev.file ver. = ", object%version
    if (object%md5sum_prc /= "") then
       write (u, "(3x,A,A,A)")  "MD5 sum (proc)   = '", object%md5sum_prc, "'"
    end if
    if (object%md5sum_cfg /= "") then
       write (u, "(3x,A,A,A)")  "MD5 sum (config) = '", object%md5sum_cfg, "'"
    end if
    write (u, "(3x,A,I0)")  "Events requested  = ", object%n_evt_requested
    if (object%split_n_evt > 0) then
       write (u, "(3x,A,I0)")  "Events per file   = ", object%split_n_evt
       write (u, "(3x,A,I0)")  "First file index  = ", object%split_index
    end if
    call object%counter%write (u)
    call write_separator (u)
    if (object%i_prc /= 0) then
       write (u, "(1x,A)")  "Current event:"
       write (u, "(3x,A,I0,A,A)")  "Process #", &
            object%i_prc, ": ", &
            char (object%entry(object%i_prc)%process_id)
       write (u, "(3x,A,I0)")  "MCI set #", object%i_mci
       write (u, "(3x,A," // FMT_19 // ")")  "Weight    = ", object%weight
       if (object%excess /= 0) &
            write (u, "(3x,A," // FMT_19 // ")")  "Excess    = ", object%excess
    else
       write (u, "(1x,A,I0,A,A)")  "Current event: [undefined]"
    end if
    call write_separator (u)
    if (allocated (object%rng)) then
       call object%rng%write (u)
    else
       write (u, "(3x,A)")  "Random-number generator: [undefined]"
    end if
    if (allocated (object%entry)) then
       do i = 1, size (object%entry)
          if (i == 1) then
             call write_separator (u, 2)
          else
             call write_separator (u)
          end if
          write (u, "(1x,A,I0,A)") "Process #", i, ":"
          call object%entry(i)%write_config (u)
       end do
    end if
    call write_separator (u, 2)
  end subroutine simulation_write
  
@ %def simulation_write
@ Write the current event record.  If an explicit index is given,
write that event record.

We implement writing to [[unit]] (event contents / debugging format)
and writing to an [[eio]] event stream (storage). We include a [[testflag]]
in order to suppress numerical noise in the testsuite.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_unit
  procedure :: write_event_unit => simulation_write_event_unit
<<Simulations: procedures>>=
  subroutine simulation_write_event_unit &
       (object, unit, i_prc, verbose, testflag)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    logical, intent(in), optional :: verbose
    integer, intent(in), optional :: i_prc
    logical, intent(in), optional :: testflag
    logical :: pacified
    integer :: current
    pacified = .false.
    if (present(testflag)) pacified = testflag
    pacified = pacified .or. object%pacify
    if (present (i_prc)) then
       current = i_prc
    else
       current = object%i_prc
    end if
    if (current > 0) then
       call object%entry(current)%write (unit, verbose = verbose, &
            testflag = pacified)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_unit

@ %def simulation_write_event
@ This writes one of the alternate events, if allocated.
<<Simulations: simulation: TBP>>=
  procedure :: write_alt_event => simulation_write_alt_event
<<Simulations: procedures>>=
  subroutine simulation_write_alt_event (object, unit, j_alt, i_prc, &
       verbose, testflag)
    class(simulation_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer, intent(in), optional :: j_alt
    integer, intent(in), optional :: i_prc
    logical, intent(in), optional :: verbose
    logical, intent(in), optional :: testflag
    integer :: i, j
    if (present (j_alt)) then
       j = j_alt
    else
       j = 1
    end if
    if (present (i_prc)) then
       i = i_prc
    else
       i = object%i_prc
    end if
    if (i > 0) then
       if (j> 0 .and. j <= object%n_alt) then
          call object%alt_entry(i,j)%write (unit, verbose = verbose, &
               testflag = testflag)
       else
          call msg_fatal ("Simulation: write alternate event: out of range")
       end if
    else
       call msg_fatal ("Simulation: write alternate event: no process selected")
    end if
  end subroutine simulation_write_alt_event

@ %def simulation_write_alt_event
@ Finalizer.
<<Simulations: simulation: TBP>>=
  procedure :: final => simulation_final
<<Simulations: procedures>>=
  subroutine simulation_final (object)
    class(simulation_t), intent(inout) :: object
    integer :: i, j
    if (allocated (object%entry)) then
       do i = 1, size (object%entry)
          call object%entry(i)%final ()
       end do
    end if
    if (allocated (object%alt_entry)) then
       do j = 1, size (object%alt_entry, 2)
          do i = 1, size (object%alt_entry, 1)
             call object%alt_entry(i,j)%final ()
          end do
       end do
    end if
    if (allocated (object%rng))  call object%rng%final ()
  end subroutine simulation_final
  
@ %def simulation_final
@ Initialization.  We can deduce all data from the given list of
process IDs and the global data set.  The process objects are taken
from the stack.  Once the individual integrals are known, we add them (and the
errors), to get the sample integral.

If there are alternative environments, we suspend initialization for
setting up alternative process objects, then restore the master
process and its parameters.  The generator or rescanner can then
switch rapidly between processes.

If [[integrate]] is set, we make sure that all affected processes are
integrated before simulation.  This is necessary if we want to actually
generate events.  If [[integrate]] is unset, we don't need the integral
because we just rescan existing events.  In that case, we just need compiled
matrix elements.

If [[generate]] is set, we prepare for actually generating events.  Otherwise,
we may only read and rescan events.
<<Simulations: simulation: TBP>>=
  procedure :: init => simulation_init
<<Simulations: procedures>>=
  subroutine simulation_init (simulation, &
       process_id, integrate, generate, local, global, alt_env)
    class(simulation_t), intent(out), target :: simulation
    type(string_t), dimension(:), intent(in) :: process_id
    logical, intent(in) :: integrate, generate
    type(rt_data_t), intent(inout), target :: local
    type(rt_data_t), intent(inout), optional, target :: global
    type(rt_data_t), dimension(:), intent(inout), optional, target :: alt_env
    class(rng_factory_t), allocatable :: rng_factory
    type(string_t) :: norm_string, version_string
    integer :: i, j
    simulation%sample_id = &
         local%get_sval (var_str ("$sample"))
    simulation%unweighted = &
         local%get_lval (var_str ("?unweighted"))
    simulation%negative_weights = &
         local%get_lval (var_str ("?negative_weights"))
    simulation%respect_selection = &
         local%get_lval (var_str ("?sample_select"))
    version_string = &
         local%get_sval (var_str ("$event_file_version"))
    norm_string = &
         local%get_sval (var_str ("$sample_normalization"))
    simulation%norm_mode = &
         event_normalization_mode (norm_string, simulation%unweighted)
    simulation%pacify = &
         local%get_lval (var_str ("?sample_pacify"))
    simulation%n_max_tries = &
         local%get_ival (var_str ("sample_max_tries"))
    simulation%split_n_evt = &
         local%get_ival (var_str ("sample_split_n_evt"))
    simulation%split_index = &
         local%get_ival (var_str ("sample_split_index"))
    simulation%update_sqme = &
         local%get_lval (var_str ("?update_sqme"))
    simulation%update_weight = &
         local%get_lval (var_str ("?update_weight"))
    simulation%update_event = &
         local%get_lval (var_str ("?update_event"))
    simulation%recover_beams = &
         local%get_lval (var_str ("?recover_beams"))
    select case (size (process_id))
    case (0)
       call msg_error ("Simulation: no process selected")
    case (1)
       write (msg_buffer, "(A,A,A)") &
            "Starting simulation for process '", &
            char (process_id(1)), "'"
       call msg_message ()
    case default
       write (msg_buffer, "(A,A,A)") &
            "Starting simulation for processes '", &
            char (process_id(1)), "' etc."
       call msg_message ()
    end select
    select case (char (version_string))
    case ("", "2.2.4")
       simulation%version = 2
    case ("2.2")
       simulation%version = 1
    case default
       simulation%version = 0
    end select
    if (simulation%version == 0) then
       call msg_fatal ("Event file format '" &
            // char (version_string) &
            // "' is not compatible with this version.")
    end if  	  
    simulation%n_prc = size (process_id)
    allocate (simulation%entry (simulation%n_prc))
    if (present (alt_env)) then
       simulation%n_alt = size (alt_env)
       do i = 1, simulation%n_prc
          call simulation%entry(i)%init (process_id(i), &
               integrate, generate, &
               simulation%update_sqme, &
               local, global, simulation%n_alt)
          if (signal_is_pending ())  return
       end do
       if (.not. any (simulation%entry%valid)) then
          call msg_error ("Simulate: no process has a valid matrix element.")
          simulation%valid = .false.
          return
       end if
       call simulation%update_processes ()
       allocate (simulation%alt_entry (simulation%n_prc, simulation%n_alt))
       allocate (simulation%md5sum_alt (simulation%n_alt))
       simulation%md5sum_alt = ""
       do j = 1, simulation%n_alt
          do i = 1, simulation%n_prc
             call simulation%alt_entry(i,j)%init_alt (process_id(i), &
                  simulation%entry(i)%get_process_ptr (), alt_env(j))
             if (signal_is_pending ())  return
          end do
       end do
       call simulation%restore_processes ()
    else       
       do i = 1, simulation%n_prc
          call simulation%entry(i)%init &
               (process_id(i), &
               integrate, generate, simulation%update_sqme, &
               local, global)
          if (signal_is_pending ())  return          
       end do
       if (.not. any (simulation%entry%valid)) then
          call msg_error ("Simulate: " &
               // "no process has a valid matrix element.") 
          simulation%valid = .false.
          return
       end if
    end if
    call dispatch_rng_factory (rng_factory, local)
    call rng_factory%make (simulation%rng)
    if (all (simulation%entry%has_integral)) then
       simulation%integral = sum (simulation%entry%integral)
       simulation%error = sqrt (sum (simulation%entry%error ** 2))
       simulation%has_integral = .true.
       if (integrate .and. generate) then
          do i = 1, simulation%n_prc
             if (simulation%entry(i)%integral < 0 .and. .not. &
                  simulation%negative_weights) then
                call msg_fatal ("Integral of process '" // &
                     char (process_id (i)) // "'is negative.")
             end if
          end do
       end if
    else
       if (integrate .and. generate) &
            call msg_error ("Simulation contains undefined integrals.")
    end if
    if (simulation%integral > 0 .or. &
         (simulation%integral < 0 .and. simulation%negative_weights)) then
       simulation%valid = .true.
    else if (generate) then
       call msg_error ("Simulate: " &
            // "sum of process integrals must be positive; skipping.")
       simulation%valid = .false.
       return
    end if
    if (simulation%valid)  call simulation%compute_md5sum ()
  end subroutine simulation_init

@ %def simulation_init
@ The number of events that we want to simulate is determined by the
settings of [[n_events]], [[luminosity]], and [[?unweighted]].  For
weighted events, we take [[n_events]] at face value as the number of
matrix element calls.  For unweighted events, if the process is a
decay, [[n_events]] is the number of unweighted events.  In these
cases, the luminosity setting is ignored.  

For unweighted events with a scattering process, we calculate the
event number that corresponds to the luminosity, given the current
value of the integral.  We then compare this with [[n_events]] and
choose the larger number.
<<Simulations: simulation: TBP>>=
  procedure :: compute_n_events => simulation_compute_n_events
<<Simulations: procedures>>=
  subroutine simulation_compute_n_events (simulation, n_events, var_list)
    class(simulation_t), intent(in) :: simulation
    integer, intent(out) :: n_events
    type(var_list_t) :: var_list
    real(default) :: lumi, x_events_lumi
    integer :: n_events_lumi
    logical :: is_scattering
    n_events = &
         var_list%get_ival (var_str ("n_events"))
    lumi = &
         var_list%get_rval (var_str ("luminosity"))
    if (simulation%unweighted) then
       is_scattering = simulation%entry(1)%n_in == 2
       if (is_scattering) then
          x_events_lumi = abs (simulation%integral * lumi)
          if (x_events_lumi < huge (n_events)) then
             n_events_lumi = nint (x_events_lumi)
          else
             call msg_message ("Simulation: luminosity too large, &
                  &limiting number of events")
             n_events_lumi = huge (n_events)
          end if
          if (n_events_lumi > n_events) then
             call msg_message ("Simulation: using n_events as computed from &
                  &luminosity value")
             n_events = n_events_lumi
          else
             write (msg_buffer, "(A,1x,I0)") &
                  "Simulation: requested number of events =", n_events
             call msg_message ()
             if (simulation%integral /= 0) then
                write (msg_buffer, "(A,1x,ES11.4)") &
                     "            corr. to luminosity [fb-1] = ", &
                     n_events / simulation%integral        
                call msg_message ()
             end if
          end if
       end if
    end if
  end subroutine simulation_compute_n_events

@ %def simulation_compute_n_events
@ Compute the checksum of the process set.  We retrieve the MD5 sums
of all processes.  This depends only on the process definitions, while
parameters are not considered.  The configuration checksum is
retrieved from the MCI records in the process objects and furthermore
includes beams, parameters, integration results, etc., so matching the
latter should guarantee identical physics.
<<Simulations: simulation: TBP>>=
  procedure :: compute_md5sum => simulation_compute_md5sum
<<Simulations: procedures>>=
  subroutine simulation_compute_md5sum (simulation)
    class(simulation_t), intent(inout) :: simulation
    type(process_t), pointer :: process
    type(string_t) :: buffer
    integer :: j, i, n_mci, i_mci, n_component, i_component
    if (simulation%md5sum_prc == "") then
       buffer = ""
       do i = 1, simulation%n_prc
          if (.not. simulation%entry(i)%valid) cycle
          process => simulation%entry(i)%get_process_ptr ()
          n_component = process%get_n_components ()
          do i_component = 1, n_component
             if (process%has_matrix_element (i_component)) then
                buffer = buffer // process%get_md5sum_prc (i_component)
             end if
          end do
       end do
       simulation%md5sum_prc = md5sum (char (buffer))
    end if
    if (simulation%md5sum_cfg == "") then
       buffer = ""
       do i = 1, simulation%n_prc
          if (.not. simulation%entry(i)%valid) cycle          
          process => simulation%entry(i)%get_process_ptr ()
          n_mci = process%get_n_mci ()
          do i_mci = 1, n_mci
             buffer = buffer // process%get_md5sum_mci (i_mci)
          end do
       end do
       simulation%md5sum_cfg = md5sum (char (buffer))
    end if
    do j = 1, simulation%n_alt
       if (simulation%md5sum_alt(j) == "") then
          buffer = ""
          do i = 1, simulation%n_prc
             process => simulation%alt_entry(i,j)%get_process_ptr ()
             buffer = buffer // process%get_md5sum_cfg ()
          end do
          simulation%md5sum_alt(j) = md5sum (char (buffer))
       end if
    end do
  end subroutine simulation_compute_md5sum

@ %def simulation_compute_md5sum
@ Initialize the process selector, using the entry integrals as process
weights.
<<Simulations: simulation: TBP>>=
  procedure :: init_process_selector => simulation_init_process_selector
<<Simulations: procedures>>=
  subroutine simulation_init_process_selector (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i
    if (simulation%has_integral) then
       call simulation%process_selector%init (simulation%entry%integral)
       do i = 1, simulation%n_prc
          associate (entry => simulation%entry(i))
            if (.not. entry%valid) then
               call msg_warning ("Process '" // char (entry%process_id) // &
                    "': matrix element vanishes, no events can be generated.")
               cycle
            end if
            call entry%init_mci_selector ()
            entry%process_weight = simulation%process_selector%get_weight (i)
          end associate
       end do
    end if
  end subroutine simulation_init_process_selector
    
@ %def simulation_init_process_selector
@ Select a process, using the random-number generator.
<<Simulations: simulation: TBP>>=
  procedure :: select_prc => simulation_select_prc
<<Simulations: procedures>>=
  function simulation_select_prc (simulation) result (i_prc)
    class(simulation_t), intent(inout) :: simulation
    integer :: i_prc
    call simulation%process_selector%generate (simulation%rng, i_prc)
  end function simulation_select_prc

@ %def simulation_select_prc
@ Select a MCI set for the selected process.
<<Simulations: simulation: TBP>>=
  procedure :: select_mci => simulation_select_mci
<<Simulations: procedures>>=
  function simulation_select_mci (simulation) result (i_mci)
    class(simulation_t), intent(inout) :: simulation
    integer :: i_mci
    if (simulation%i_prc /= 0) then
       i_mci = simulation%entry(simulation%i_prc)%select_mci ()
    end if
  end function simulation_select_mci

@ %def simulation_select_mci
@ Generate a predefined number of events.  First select a process and
a component set, then generate an event for that process and factorize
the quantum state.  The pair of random numbers can be used for
factorization.

When generating events, we drop all configurations where the event is
marked as incomplete.  This happens if the event fails cuts.  In fact,
such events are dropped already by the sampler if unweighting is in
effect, so this can happen only for weighted events.  By setting a
limit given by [[sample_max_tries]] (user parameter), we can avoid an
endless loop.

NB: When reading from file, event transforms can't be applied because the
process instance will not be complete.  This should be fixed.
<<Simulations: simulation: TBP>>=
  procedure :: generate => simulation_generate
<<Simulations: procedures>>=
  subroutine simulation_generate (simulation, n, es_array)
    class(simulation_t), intent(inout) :: simulation
    integer, intent(in) :: n
    type(event_stream_array_t), intent(inout), optional :: es_array
    type(string_t) :: str1, str2, str3
    logical :: generate_new, passed
    integer :: i, j
    simulation%n_evt_requested = n
    call simulation%entry%set_n (n)
    if (simulation%n_alt > 0)  call simulation%alt_entry%set_n (n)
    str1 = "Events: generating"
    if (present (es_array)) then
       if (es_array%has_input ())  str1 = "Events: reading"
    end if
    if (simulation%entry(1)%config%unweighted) then
       str2 = "unweighted"
    else
       str2 = "weighted"
    end if
    if (simulation%entry(1)%config%factorization_mode == &
         FM_IGNORE_HELICITY) then
       str3 = ", unpolarized"
    else 
       str3 = ", polarized"
    end if    
    write (msg_buffer, "(A,1x,I0,1x,A,1x,A)")  char (str1), n, &
         char (str2) // char(str3), "events ..."
    call msg_message ()
    write (msg_buffer, "(A,1x,A)") "Events: event normalization mode", &
         char (event_normalization_string (simulation%norm_mode))
    call msg_message ()
    do i = 1, n
       if (present (es_array)) then
          call simulation%read_event (es_array, .true., generate_new)
       else
          generate_new = .true.
       end if
       if (generate_new) then
          simulation%i_prc = simulation%select_prc ()
          simulation%i_mci = simulation%select_mci ()
          associate (entry => simulation%entry(simulation%i_prc))
            do j = 1, simulation%n_max_tries
               if (.not. entry%valid)  call msg_warning &
                       ("Process '" // char (entry%process_id) // "': " // &
                       "matrix element vanishes, no events can be generated.")
               call entry%generate (simulation%i_mci)
               if (signal_is_pending ()) return
               if (entry%has_valid_particle_set ())  exit
            end do
            if (.not. entry%has_valid_particle_set ()) then
               write (msg_buffer, "(A,I0,A)")  "Simulation: failed to &
                    &generate valid event after ", &
                    simulation%n_max_tries, " tries (sample_max_tries)"
               call msg_fatal ()
            end if
            call entry%evaluate_expressions ()
            if (signal_is_pending ()) return
            if (entry%passed_selection ()) then
               simulation%weight = entry%get_weight_ref ()
               simulation%excess = entry%get_excess_prc ()
            end if
            call simulation%counter%record &
                 (simulation%weight, simulation%excess)
            call entry%record (simulation%i_mci)
          end associate
       else
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%accept_sqme_ref ()
            call entry%accept_weight_ref ()
            !!! JRR: WK please check: why commented out
            ! call entry%evaluate_transforms ()  ! doesn't activate
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ()) return
            if (entry%passed_selection ()) then
               simulation%weight = entry%get_weight_ref ()
               simulation%excess = entry%get_excess_prc ()
            end if
            call simulation%counter%record &
                 (simulation%weight, simulation%excess, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       end if
       call simulation%calculate_alt_entries ()
       if (signal_is_pending ()) return
       if (simulation%pacify)  call pacify (simulation)
       if (simulation%respect_selection) then
          passed = simulation%entry(simulation%i_prc)%passed_selection ()
       else
          passed = .true.
       end if
       if (present (es_array)) then
          call simulation%write_event (es_array, passed)
       end if
    end do
    call msg_message ("        ... event sample complete.")
    call simulation%counter%show_excess ()
  end subroutine simulation_generate
  
@ %def simulation_generate
@ Compute the event matrix element and weight for all alternative
environments, given the current event and selected process.  We first
copy the particle set, then temporarily update the process core with
local parameters, recalculate everything, and restore the process
core.

The event weight is obtained by rescaling the original event weight with the
ratio of the new and old [[sqme]] values.  (In particular, if the old
value was zero, the weight will stay zero.)

Note: this may turn out to be inefficient because we always replace
all parameters and recalculate everything, once for each event and
environment.  However, a more fine-grained control requires more
code.  In any case, while we may keep multiple process cores (which
stay constant for a simulation run), we still have to update the
external matrix element parameters event by event.  The matrix element
``object'' is present only once.
<<Simulations: simulation: TBP>>=
  procedure :: calculate_alt_entries => simulation_calculate_alt_entries
<<Simulations: procedures>>=
  subroutine simulation_calculate_alt_entries (simulation)
    class(simulation_t), intent(inout) :: simulation
    real(default) :: factor
    real(default), dimension(:), allocatable :: sqme_alt, weight_alt
    integer :: n_alt, i, j
    i = simulation%i_prc
    n_alt = simulation%n_alt
    if (n_alt == 0)  return
    allocate (sqme_alt (n_alt), weight_alt (n_alt))
    associate (entry => simulation%entry(i))
      do j = 1, n_alt
         if (signal_is_pending ())  return
         factor = entry%get_kinematical_weight ()
         associate (alt_entry => simulation%alt_entry(i,j))
           call alt_entry%update_process ()
           call alt_entry%select &
                (entry%get_i_mci (), entry%get_i_term (), entry%get_channel ())
           call alt_entry%fill_particle_set (entry)
           call alt_entry%recalculate &
                (update_sqme = .true., weight_factor = factor)
           if (signal_is_pending ())  return
           call alt_entry%accept_sqme_prc ()
           call alt_entry%update_normalization ()
           call alt_entry%accept_weight_prc ()
           call alt_entry%check ()
           call alt_entry%evaluate_expressions ()
           if (signal_is_pending ())  return
           call alt_entry%restore_process ()
           sqme_alt(j) = alt_entry%get_sqme_ref ()
           if (alt_entry%passed_selection ()) then
              weight_alt(j) = alt_entry%get_weight_ref ()
           end if
         end associate
      end do
      call entry%set (sqme_alt = sqme_alt, weight_alt = weight_alt)
      call entry%check ()
      call entry%store_alt_values ()
    end associate
  end subroutine simulation_calculate_alt_entries
       
@ %def simulation_calculate_alt_entries
@ Rescan an undefined number of events.

If [[update_event]] or [[update_sqme]] is set, we have to recalculate the
event, starting from the particle set.  If the latter is set, this includes
the squared matrix element (i.e., the amplitude is evaluated).  Otherwise,
only kinematics and observables derived from it are recovered.

If any of the update flags is set, we will come up with separate
[[sqme_prc]] and [[weight_prc]] values.  (The latter is only distinct
if [[update_weight]] is set.)  Otherwise, we accept the reference values.
<<Simulations: simulation: TBP>>=
  procedure :: rescan => simulation_rescan
<<Simulations: procedures>>=
  subroutine simulation_rescan (simulation, n, es_array, global)
    class(simulation_t), intent(inout) :: simulation
    integer, intent(in) :: n
    type(event_stream_array_t), intent(inout) :: es_array
    type(rt_data_t), intent(inout) :: global
    type(qcd_t) :: qcd
    type(string_t) :: str1, str2, str3
    logical :: complete
    str1 = "Rescanning"
    if (simulation%entry(1)%config%unweighted) then
       str2 = "unweighted"
    else
       str2 = "weighted"
    end if
    simulation%n_evt_requested = n
    call simulation%entry%set_n (n)
    if (simulation%update_sqme .or. simulation%update_weight) then
       call dispatch_qcd (qcd, global)
       call simulation%update_processes &
            (global%model, qcd, global%get_helicity_selection ())
       str3 = "(process parameters updated) "
    else
       str3 = ""
    end if
    write (msg_buffer, "(A,1x,A,1x,A,A,A)")  char (str1), char (str2), &
         "events ", char (str3), "..."
    call msg_message ()
    do
       call simulation%read_event (es_array, .false., complete)
       if (complete)  exit
       if (simulation%update_event &
            .or. simulation%update_sqme &
            .or. simulation%update_weight) then
          call simulation%recalculate ()
          if (signal_is_pending ())  return
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%update_normalization ()
            if (simulation%update_event) then
               call entry%evaluate_transforms ()
            end if
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ())  return
            simulation%weight = entry%get_weight_prc ()
            call simulation%counter%record (simulation%weight, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       else
          associate (entry => simulation%entry(simulation%i_prc))
            call entry%accept_sqme_ref ()
            call entry%accept_weight_ref ()
            call entry%check ()
            call entry%evaluate_expressions ()
            if (signal_is_pending ())  return
            simulation%weight = entry%get_weight_ref ()
            call simulation%counter%record (simulation%weight, from_file=.true.)
            call entry%record (simulation%i_mci, from_file=.true.)
          end associate
       end if
       call simulation%calculate_alt_entries ()
       if (signal_is_pending ())  return
       call simulation%write_event (es_array)
    end do
    if (simulation%update_sqme .or. simulation%update_weight) then
       call simulation%restore_processes ()
    end if
  end subroutine simulation_rescan
  
@ %def simulation_rescan
@ These routines take care of temporary parameter redefinitions that
we want to take effect while recalculating the matrix elements.  We
extract the core(s) of the processes that we are simulating, apply the
changes, and make sure that the changes are actually used.  This is
the duty of [[dispatch_core_update]].  When done, we restore the
original versions using [[dispatch_core_restore]].
<<Simulations: simulation: TBP>>=
  procedure :: update_processes => simulation_update_processes
  procedure :: restore_processes => simulation_restore_processes
<<Simulations: procedures>>=
  subroutine simulation_update_processes (simulation, &
       model, qcd, helicity_selection)
    class(simulation_t), intent(inout) :: simulation
    class(model_data_t), intent(in), optional, target :: model
    type(qcd_t), intent(in), optional :: qcd
    type(helicity_selection_t), intent(in), optional :: helicity_selection
    integer :: i
    do i = 1, simulation%n_prc
       call simulation%entry(i)%update_process (model, qcd, helicity_selection)
    end do
  end subroutine simulation_update_processes
  
  subroutine simulation_restore_processes (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i
    do i = 1, simulation%n_prc
       call simulation%entry(i)%restore_process ()
    end do
  end subroutine simulation_restore_processes
  
@ %def simulation_update_processes
@ %def simulation_restore_processes
@ 
\subsection{Event Stream I/O} 
Write an event to a generic [[eio]] event stream.  The process index
must be selected, or the current index must be available.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_eio
  procedure :: write_event_eio => simulation_write_event_eio
<<Simulations: procedures>>=
  subroutine simulation_write_event_eio (object, eio, i_prc)
    class(simulation_t), intent(in) :: object
    class(eio_t), intent(inout) :: eio
    integer, intent(in), optional :: i_prc
    integer :: current
    if (present (i_prc)) then
       current = i_prc
    else
       current = object%i_prc
    end if
    if (current > 0) then
       if (object%split_n_evt > 0) then
          if (object%counter%total > 1 .and. &
               mod (object%counter%total, object%split_n_evt) == 1) then
             call eio%split_out ()
          end if
       end if
       call eio%output (object%entry(current)%event_t, current, pacify = object%pacify)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_eio

@ %def simulation_write_event
@
Read an event from a generic [[eio]] event stream.  The event stream element
must specify the process within the sample ([[i_prc]]), the MC group for this
process ([[i_mci]]), the selected term ([[i_term]]), the selected MC
integration [[channel]], and the particle set of the event.

We may encounter EOF, which we indicate by storing 0 for the process index
[[i_prc]].  An I/O error will be reported, and we also abort reading.
<<Simulations: simulation: TBP>>=
  generic :: read_event => read_event_eio
  procedure :: read_event_eio => simulation_read_event_eio
<<Simulations: procedures>>=
  subroutine simulation_read_event_eio (object, eio)
    class(simulation_t), intent(inout) :: object
    class(eio_t), intent(inout) :: eio
    integer :: iostat, current
    call eio%input_i_prc (current, iostat)
    select case (iostat)
    case (0)
       object%i_prc = current
       call eio%input_event (object%entry(current)%event_t, iostat)
    end select
    select case (iostat)
    case (:-1)
       object%i_prc = 0
       object%i_mci = 0
    case (1:)
       call msg_error ("Reading events: I/O error, aborting read")
       object%i_prc = 0
       object%i_mci = 0
    case default
       object%i_mci = object%entry(current)%get_i_mci ()
    end select
  end subroutine simulation_read_event_eio

@ %def simulation_read_event
@ 
\subsection{Event Stream Array} 
Write an event using an array of event I/O streams.
The process index must be selected, or the current index must be
available.
<<Simulations: simulation: TBP>>=
  generic :: write_event => write_event_es_array
  procedure :: write_event_es_array => simulation_write_event_es_array
<<Simulations: procedures>>=
  subroutine simulation_write_event_es_array (object, es_array, passed)
    class(simulation_t), intent(in) :: object
    class(event_stream_array_t), intent(inout) :: es_array
    logical, intent(in), optional :: passed
    integer :: i_prc, event_index
    i_prc = object%i_prc
    if (i_prc > 0) then
       event_index = object%counter%total
       call es_array%output (object%entry(i_prc)%event_t, i_prc, &
            event_index, passed = passed, pacify = object%pacify)
    else
       call msg_fatal ("Simulation: write event: no process selected")
    end if
  end subroutine simulation_write_event_es_array

@ %def simulation_write_event
@ Read an event using an array of event I/O streams.  Reading is
successful if there is an input stream within the array, and if a
valid event can be read from that stream.  If there is a stream, but
EOF is passed when reading the first item, we switch the channel to
output and return failure but no error message, such that new events
can be appended to that stream.
<<Simulations: simulation: TBP>>=
  generic :: read_event => read_event_es_array
  procedure :: read_event_es_array => simulation_read_event_es_array
<<Simulations: procedures>>=
  subroutine simulation_read_event_es_array (object, es_array, enable_switch, &
       fail)
    class(simulation_t), intent(inout) :: object
    class(event_stream_array_t), intent(inout) :: es_array
    logical, intent(in) :: enable_switch
    logical, intent(out) :: fail
    integer :: iostat, i_prc
    if (es_array%has_input ()) then
       fail = .false.
       call es_array%input_i_prc (i_prc, iostat)
       select case (iostat)
       case (0)
          object%i_prc = i_prc
          call es_array%input_event (object%entry(i_prc)%event_t, iostat)
       case (:-1)
          write (msg_buffer, "(A,1x,I0,1x,A)")  &
               "... event file terminates after", &
               object%counter%read, "events."
          call msg_message ()
          if (enable_switch) then
             call es_array%switch_inout ()
             write (msg_buffer, "(A,1x,I0,1x,A)")  &
                  "Generating remaining ", &
                  object%n_evt_requested - object%counter%read, "events ..."
             call msg_message ()
          end if
          fail = .true.
          return
       end select
       select case (iostat)
       case (0)
          object%i_mci = object%entry(i_prc)%get_i_mci ()
       case default
          write (msg_buffer, "(A,1x,I0,1x,A)")  &
               "Reading events: I/O error, aborting read after", &
               object%counter%read, "events."
          call msg_error ()
          object%i_prc = 0
          object%i_mci = 0
          fail = .true.
       end select
    else
       fail = .true.
    end if
  end subroutine simulation_read_event_es_array

@ %def simulation_read_event
@
\subsection{Recover event}
Recalculate the process instance contents, given an event with known particle
set.  The indices for MC, term, and channel must be already set.  The
[[recalculate]] method of the selected entry will import the result
into [[sqme_prc]] and [[weight_prc]].
<<Simulations: simulation: TBP>>=
  procedure :: recalculate => simulation_recalculate
<<Simulations: procedures>>=
  subroutine simulation_recalculate (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i_prc
    i_prc = simulation%i_prc
    associate (entry => simulation%entry(i_prc))
      if (simulation%update_weight) then
         call simulation%entry(i_prc)%recalculate &
              (update_sqme = simulation%update_sqme, &
              recover_beams = simulation%recover_beams, &
              weight_factor = entry%get_kinematical_weight ())
      else
         call simulation%entry(i_prc)%recalculate &
              (update_sqme = simulation%update_sqme, &
              recover_beams = simulation%recover_beams)
      end if
    end associate
  end subroutine simulation_recalculate

@ %def simulation_recalculate
@
\subsection{Extract contents}
Return the MD5 sum that summarizes configuration and integration
(but not the event file).  Used for initializing the event streams.
<<Simulations: simulation: TBP>>=
  procedure :: get_md5sum_prc => simulation_get_md5sum_prc
  procedure :: get_md5sum_cfg => simulation_get_md5sum_cfg
  procedure :: get_md5sum_alt => simulation_get_md5sum_alt
<<Simulations: procedures>>=
  function simulation_get_md5sum_prc (simulation) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    character(32) :: md5sum
    md5sum = simulation%md5sum_prc
  end function simulation_get_md5sum_prc
    
  function simulation_get_md5sum_cfg (simulation) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    character(32) :: md5sum
    md5sum = simulation%md5sum_cfg
  end function simulation_get_md5sum_cfg
    
  function simulation_get_md5sum_alt (simulation, i) result (md5sum)
    class(simulation_t), intent(in) :: simulation
    integer, intent(in) :: i
    character(32) :: md5sum
    md5sum = simulation%md5sum_alt(i)
  end function simulation_get_md5sum_alt
    
@ %def simulation_get_md5sum_prc
@ %def simulation_get_md5sum_cfg
@ Return data that may be useful for writing event files..
<<Simulations: simulation: TBP>>=
  procedure :: get_data => simulation_get_data
<<Simulations: procedures>>=
  function simulation_get_data (simulation, alt) result (sdata)
    class(simulation_t), intent(in) :: simulation
    logical, intent(in), optional :: alt
    type(event_sample_data_t) :: sdata
    type(process_t), pointer :: process
    type(beam_data_t), pointer :: beam_data
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: n, i
    logical :: enable_alt
    enable_alt = .true.;  if (present (alt))  enable_alt = alt    
    process => simulation%entry(1)%get_process_ptr ()
    beam_data => process%get_beam_data_ptr ()
    if (enable_alt) then
       call sdata%init (simulation%n_prc, simulation%n_alt)
       do i = 1, simulation%n_alt
          sdata%md5sum_alt(i) = simulation%get_md5sum_alt (i)
       end do
    else
       call sdata%init (simulation%n_prc)
    end if
    sdata%unweighted = simulation%unweighted
    sdata%negative_weights = simulation%negative_weights
    sdata%norm_mode = simulation%norm_mode
    n = beam_data_get_n_in (beam_data)
    sdata%n_beam = n
    allocate (flv (n))
    flv = beam_data_get_flavor (beam_data)
    sdata%pdg_beam(:n) = flv%get_pdg ()
    sdata%energy_beam(:n) = beam_data_get_energy (beam_data)
    do i = 1, simulation%n_prc
       if (.not. simulation%entry(i)%valid) cycle
       process => simulation%entry(i)%get_process_ptr ()
       sdata%proc_num_id(i) = process%get_num_id ()
       if (sdata%proc_num_id(i) == 0)  sdata%proc_num_id(i) = i
       if (simulation%entry(i)%has_integral) then
          sdata%cross_section(i) = simulation%entry(i)%integral
          sdata%error(i) = simulation%entry(i)%error
       end if
    end do
    sdata%total_cross_section = sum (sdata%cross_section)
    sdata%md5sum_prc = simulation%get_md5sum_prc ()
    sdata%md5sum_cfg = simulation%get_md5sum_cfg ()
    if (simulation%split_n_evt > 0) then
       sdata%split_n_evt = simulation%split_n_evt
       sdata%split_index = simulation%split_index
    end if
  end function simulation_get_data
    
@ %def simulation_get_data
@ Return a default name for the current event sample.  This is the
process ID of the first process.
<<Simulations: simulation: TBP>>=
  procedure :: get_default_sample_name => simulation_get_default_sample_name
<<Simulations: procedures>>=
  function simulation_get_default_sample_name (simulation) result (sample)
    class(simulation_t), intent(in) :: simulation
    type(string_t) :: sample
    type(process_t), pointer :: process
    sample = "whizard"
    if (simulation%n_prc > 0) then
       process => simulation%entry(1)%get_process_ptr ()
       if (associated (process)) then
          sample = process%get_id ()
       end if
    end if
  end function simulation_get_default_sample_name

@ %def simulation_get_default_sample_name
@
<<Simulations: simulation: TBP>>=
  procedure :: is_valid => simulation_is_valid
<<Simulations: procedures>>=
  function simulation_is_valid (simulation) result (valid)
    class(simulation_t), intent(inout) :: simulation
    logical :: valid
    valid = simulation%valid
  end function simulation_is_valid

@ %def simulation_is_valid
@ 
\subsection{Auxiliary}
Call pacify: eliminate numerical noise.
<<Simulations: interfaces>>=
  interface pacify
     module procedure pacify_simulation
  end interface
<<Simulations: procedures>>=
  subroutine pacify_simulation (simulation)
    class(simulation_t), intent(inout) :: simulation
    integer :: i, j
    i = simulation%i_prc
    if (i > 0) then
       call pacify (simulation%entry(i))
       do j = 1, simulation%n_alt
          call pacify (simulation%alt_entry(i,j))
       end do
    end if
  end subroutine pacify_simulation
  
@ %def pacify_simulation
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Simulations: public>>=
  public :: simulations_test
<<Simulations: tests>>=
  subroutine simulations_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Simulations: execute tests>>
  end subroutine simulations_test

@ %def simulations_test
@ 
\subsubsection{Initialization}
Initialize a [[simulation_t]] object, including the embedded event records.
<<Simulations: execute tests>>=
  call test (simulations_1, "simulations_1", &
       "initialization", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_1 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, procname2
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_1"
    write (u, "(A)")  "*   Purpose: initialize simulation"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_1a"
    procname1 = "simulation_1p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)
    
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    procname2 = "sim_extra"
    
    call prepare_test_library (global, libname, 1, [procname2])
    call compile_library (libname, global)
    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations2"), is_known = .true.)


    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_string (var_str ("$sample"), &
         var_str ("sim1"), is_known = .true.)
    call integrate_process (procname2, global, local_stack=.true.)

    call simulation%init ([procname1, procname2], .false., .true., global)
    call simulation%init_process_selector ()
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the first process"
    write (u, "(A)")
    
    call simulation%write_event (u, i_prc = 1)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_1"
    
  end subroutine simulations_1
  
@ %def simulations_1
@ 
\subsubsection{Weighted events}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_2, "simulations_2", &
       "weighted events", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_2 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_2"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_2a"
    procname1 = "simulation_2p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_2"
    
  end subroutine simulations_2
  
@ %def simulations_2
@ 
\subsubsection{Unweighted events}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_3, "simulations_3", &
       "unweighted events", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_3 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_3"
    write (u, "(A)")  "*   Purpose: generate unweighted events &
         &for a single process"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_3a"
    procname1 = "simulation_3p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_3"
    
  end subroutine simulations_3
  
@ %def simulations_3
@ 
\subsubsection{Simulating process with structure functions}
Generate events for a single process.
<<Simulations: execute tests>>=
  call test (simulations_4, "simulations_4", &
       "process with structure functions", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_4 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1
    type(rt_data_t), target :: global
    type(flavor_t) :: flv
    type(string_t) :: name
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_4"
    write (u, "(A)")  "*   Purpose: generate events for a single process &
         &with structure functions"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_phs_forest_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_4a"
    procname1 = "simulation_4p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)
    
    call reset_interaction_counter ()

    call flv%init (25, global%model)
    name = flv%get_name ()
    
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    write (u, "(A)")  "* Integrate"
    write (u, "(A)")

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    call global%set_string (var_str ("$sample"), &
         var_str ("simulations4"), is_known = .true.)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate three events"
    write (u, "(A)")

    call simulation%generate (3)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_4"
    
  end subroutine simulations_4
  
@ %def simulations_4
@ 
\subsubsection{Event I/O}
Generate event for a test process, write to file and reread.
<<Simulations: execute tests>>=
  call test (simulations_5, "simulations_5", &
       "raw event I/O", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_5 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_5"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_5a"
    procname1 = "simulation_5p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)   
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations5"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations5"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    allocate (eio_raw_t :: eio)
    call eio%init_out (sample)
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write_event (u)
    call simulation%write_event (eio)

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    call global%set_log (var_str ("?update_sqme"), &
         .true., is_known = .true.)
    call global%set_log (var_str ("?update_weight"), &
         .true., is_known = .true.)
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()
    allocate (eio_raw_t :: eio)
    call eio%init_in (sample)
    
    call simulation%read_event (eio)
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Recalculate process instance"
    write (u, "(A)")

    call simulation%recalculate ()
    call simulation%entry(simulation%i_prc)%evaluate_expressions ()
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_5"
    
  end subroutine simulations_5
  
@ %def simulations_5
@ 
\subsubsection{Event I/O}
Generate event for a real process with structure functions, write to file and
reread.
<<Simulations: execute tests>>=
  call test (simulations_6, "simulations_6", &
       "raw event I/O with structure functions", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_6 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: simulations_6"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_6"
    procname1 = "simulation_6p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)

    call flv%init (25, global%model)
    name = flv%get_name ()
    
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations6"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    allocate (eio_raw_t :: eio)
    call eio%init_out (sample)
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)
    call simulation%write_event (eio)

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?update_sqme"), &
         .true., is_known = .true.)
    call global%set_log (var_str ("?update_weight"), &
         .true., is_known = .true.)

    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()
    allocate (eio_raw_t :: eio)
    call eio%init_in (sample)
    
    call simulation%read_event (eio)
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Recalculate process instance"
    write (u, "(A)")

    call simulation%recalculate ()
    call simulation%entry(simulation%i_prc)%evaluate_expressions ()
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call eio%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_6"
    
  end subroutine simulations_6
  
@ %def simulations_6
@ 
\subsubsection{Automatic Event I/O}
Generate events with raw-format event file as cache: generate, reread,
append.
<<Simulations: execute tests>>=
  call test (simulations_7, "simulations_7", &
       "automatic raw event I/O", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_7 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: simulations_7"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and reread"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_7"
    procname1 = "simulation_7p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)

    call flv%init (25, global%model)
    name = flv%get_name ()
    
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations7"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init (sample, [var_str ("raw")], global, data)
    
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")  "* Re-read the event from file and generate another one"
    write (u, "(A)")
    
    call global%set_log (&
         var_str ("?rebuild_events"), .false., is_known = .true.)

    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init (sample, empty_string_array, global, data, &
         input = var_str ("raw"))
    
    call simulation%generate (2, es_array)
    
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read both events from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    call es_array%init (sample, empty_string_array, global, data, &
         input = var_str ("raw"))

    call simulation%generate (2, es_array)
    
    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_7"
    
  end subroutine simulations_7
  
@ %def simulations_7
@ 
\subsubsection{Rescanning Events}
Generate events and rescan the resulting raw event file.
<<Simulations: execute tests>>=
  call test (simulations_8, "simulations_8", &
       "rescan raw event file", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_8 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    type(string_t) :: name
    
    write (u, "(A)")  "* Test output: simulations_8"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and rescan"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)        

    libname = "simulation_8"
    procname1 = "simulation_8p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)   
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)

    call flv%init (25, global%model)
    name = flv%get_name ()
    
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations8"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, [var_str ("raw")], global, &
         data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read the event from file"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1], .false., .false., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, empty_string_array, global, data, &
         input = var_str ("raw"), input_sample = sample, allow_switch = .false.)
    
    call simulation%rescan (1, es_array, global = global)
    
    write (u, "(A)")

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")
    write (u, "(A)")  "* Re-read again and recalculate"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?update_sqme"), &
         .true., is_known = .true.)
    call global%set_log (var_str ("?update_event"), &
         .true., is_known = .true.)

    allocate (simulation)
    call simulation%init ([procname1], .false., .false., global)
    call simulation%init_process_selector ()

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, empty_string_array, global, data, &
         input = var_str ("raw"), input_sample = sample, allow_switch = .false.)
    
    call simulation%rescan (1, es_array, global = global)
    
    write (u, "(A)")

    call pacify (simulation%entry(simulation%i_prc))
    call simulation%write_event (u, verbose = .true., testflag = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_8"
    
  end subroutine simulations_8
  
@ %def simulations_8
@ 
\subsubsection{Rescanning Check}
Generate events and rescan with process mismatch.
<<Simulations: execute tests>>=
  call test (simulations_9, "simulations_9", &
       "rescan mismatch", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_9 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    type(string_t), dimension(0) :: empty_string_array
    type(event_sample_data_t) :: data
    type(event_stream_array_t) :: es_array
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    type(string_t) :: name
    logical :: error
    
    write (u, "(A)")  "* Test output: simulations_9"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            write to file and rescan"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_9"
    procname1 = "simulation_9p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("wood"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("vamp"), is_known = .true.)
    call global%set_log (var_str ("?use_vamp_equivalences"),&
         .true., is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)

    call flv%init (25, global%model)
    name = flv%get_name ()
    
    call global%beam_structure%init_sf ([name, name], [1])
    call global%beam_structure%set_sf (1, 1, var_str ("sf_test_1"))

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call reset_interaction_counter ()
    
    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations9"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize raw event file"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = simulation%get_md5sum_cfg ()
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, [var_str ("raw")], global, &
         data)
    
    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1, es_array)

    call es_array%final ()
    call simulation%final ()
    deallocate (simulation)
    
    write (u, "(A)")  "* Initialize event generation for different parameters"
    write (u, "(A)")
    
    call reset_interaction_counter ()
    
    allocate (simulation)
    call simulation%init ([procname1, procname1], .false., .false., global)
    call simulation%init_process_selector ()
    
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Attempt to re-read the events (should fail)"
    write (u, "(A)")

    data%md5sum_prc = simulation%get_md5sum_prc ()
    data%md5sum_cfg = ""
    write (u, "(1x,A,A,A)")  "MD5 sum (proc)   = '", data%md5sum_prc, "'"
    write (u, "(1x,A,A,A)")  "MD5 sum (config) = '", data%md5sum_cfg, "'"
    call es_array%init (sample, empty_string_array, global, data, &
         input = var_str ("raw"), input_sample = sample, &
         allow_switch = .false., error = error)
    
    write (u, "(1x,A,L1)")  "error = ", error
    
    call simulation%rescan (1, es_array, global = global)

    call es_array%final ()
    call simulation%final ()
    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_9"
    
  end subroutine simulations_9
  
@ %def simulations_9
@ 
\subsubsection{Alternative weights}
Generate an event for a single process and reweight it in a
simultaneous calculation.
<<Simulations: execute tests>>=
  call test (simulations_10, "simulations_10", &
       "alternative weight", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_10 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, expr_text
    type(rt_data_t), target :: global
    type(rt_data_t), dimension(1), target :: alt_env
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_weight
    type(simulation_t), target :: simulation
    type(event_sample_data_t) :: data
    
    write (u, "(A)")  "* Test output: simulations_10"
    write (u, "(A)")  "*   Purpose: reweight event"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_pexpr_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_10a"
    procname1 = "simulation_10p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("simulations1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize alternative environment with custom weight"
    write (u, "(A)")
    
    call alt_env(1)%local_init (global)
    call alt_env(1)%activate ()

    expr_text = "2"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    write (u, *)
    
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)
    alt_env(1)%pn%weight_expr => parse_tree_get_root_ptr (pt_weight)
    call alt_env(1)%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    call simulation%init ([procname1], .true., .true., global, alt_env=alt_env)
    call simulation%init_process_selector ()

    data = simulation%get_data ()
    call data%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Generate an event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the last event"
    write (u, "(A)")
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Write the event record for the alternative setup"
    write (u, "(A)")
    
    call simulation%write_alt_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call simulation%final ()
    call global%final ()
    
    call syntax_model_file_final ()
    call syntax_pexpr_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_10"
    
  end subroutine simulations_10
  
@ %def simulations_10
@ 
\subsubsection{Decays}
Generate an event with subsequent partonic decays.
<<Simulations: execute tests>>=
  call test (simulations_11, "simulations_11", &
       "decay", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_11 (u)
    integer, intent(in) :: u
    type(rt_data_t), target :: global
    type(prclib_entry_t), pointer :: lib
    type(string_t) :: prefix, procname1, procname2
    type(process_t), pointer :: process
    type(simulation_t), target :: simulation
    
    write (u, "(A)")  "* Test output: simulations_11"
    write (u, "(A)")  "*   Purpose: apply decay"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize processes"
    write (u, "(A)")

    call syntax_model_file_init ()
        
    call global%global_init ()
    allocate (lib)
    call global%add_prclib (lib)

    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)        
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)
    
    prefix = "simulation_11"
    procname1 = prefix // "_p"
    procname2 = prefix // "_d"
    call prepare_testbed &
         (global%prclib, global%process_stack, &
         prefix, global%os_data, &
         scattering=.true., decay=.true.)

    call global%select_model (var_str ("Test"))
    call global%model%set_par (var_str ("ff"), 0.4_default)
    call global%model%set_par (var_str ("mf"), &
         global%model%get_real (var_str ("ff")) &
         * global%model%get_real (var_str ("ms")))
    call global%model%set_unstable (25, [procname2])

    write (u, "(A)")  "* Initialize simulation object"
    write (u, "(A)")

    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    write (u, "(A)")  "* Generate event"
    write (u, "(A)")

    call simulation%generate (1)
    call simulation%write (u)

    write (u, *)
    
    call simulation%write_event (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    write (u, "(A)")

    call simulation%final ()
    call global%final ()
    
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_11"
    
  end subroutine simulations_11
  
@ %def simulations_11
@ 
\subsubsection{Split Event Files}
Generate event for a real process with structure functions and write to file,
accepting a limit for the number of events per file.
<<Simulations: execute tests>>=
  call test (simulations_12, "simulations_12", &
       "split event files", &
       u, results)
<<Simulations: tests>>=
  subroutine simulations_12 (u)
    integer, intent(in) :: u
    type(string_t) :: libname, procname1, sample
    type(rt_data_t), target :: global
    class(eio_t), allocatable :: eio
    type(simulation_t), allocatable, target :: simulation
    type(flavor_t) :: flv
    integer :: i_evt
    
    write (u, "(A)")  "* Test output: simulations_12"
    write (u, "(A)")  "*   Purpose: generate events for a single process"
    write (u, "(A)")  "*            and write to split event files"
    write (u, "(A)")

    write (u, "(A)")  "* Initialize process and integrate"
    write (u, "(A)")

    call syntax_model_file_init ()

    call global%global_init ()
    call global%set_log (var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    call global%set_int (var_str ("seed"), &
         0, is_known = .true.)    
    
    libname = "simulation_12"
    procname1 = "simulation_12p"
    
    call prepare_test_library (global, libname, 1, [procname1])
    call compile_library (libname, global)

    call global%append_log (&
         var_str ("?rebuild_phase_space"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_grids"), .true., intrinsic = .true.)
    call global%append_log (&
         var_str ("?rebuild_events"), .true., intrinsic = .true.)

    call global%set_string (var_str ("$method"), &
         var_str ("unit_test"), is_known = .true.)
    call global%set_string (var_str ("$phs_method"), &
         var_str ("single"), is_known = .true.)
    call global%set_string (var_str ("$integration_method"),&
         var_str ("midpoint"), is_known = .true.)
    call global%set_log (var_str ("?vis_history"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call global%set_log (var_str ("?recover_beams"), &
         .false., is_known = .true.)

    call global%set_real (var_str ("sqrts"),&
         1000._default, is_known = .true.)
    call global%model_set_real (var_str ("ms"), &
         0._default)

    call flv%init (25, global%model)

    call global%it_list%init ([1], [1000])

    call global%set_string (var_str ("$run_id"), &
         var_str ("r1"), is_known = .true.)
    call integrate_process (procname1, global, local_stack=.true.)

    write (u, "(A)")  "* Initialize event generation"
    write (u, "(A)")

    call global%set_log (var_str ("?unweighted"), &
         .false., is_known = .true.)
    sample = "simulations_12"
    call global%set_string (var_str ("$sample"), &
         sample, is_known = .true.)
    call global%set_int (var_str ("sample_split_n_evt"), &
         2, is_known = .true.)
    call global%set_int (var_str ("sample_split_index"), &
         42, is_known = .true.)
    allocate (simulation)
    call simulation%init ([procname1], .true., .true., global)
    call simulation%init_process_selector ()

    call simulation%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize ASCII event file"
    write (u, "(A)")

    allocate (eio_ascii_short_t :: eio)
    select type (eio)
    class is (eio_ascii_t);  call eio%set_parameters ()
    end select
    call eio%init_out (sample, data = simulation%get_data ())
    
    write (u, "(A)")  "* Generate 5 events, distributed among three files"

    do i_evt = 1, 5
       call simulation%generate (1)
       call simulation%write_event (eio)
    end do

    call eio%final ()
    deallocate (eio)
    call simulation%final ()
    deallocate (simulation)
    
    write (u, *)
    call display_file ("simulations_12.42.short.evt", u)
    write (u, *)
    call display_file ("simulations_12.43.short.evt", u)
    write (u, *)
    call display_file ("simulations_12.44.short.evt", u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call global%final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: simulations_12"
    
  end subroutine simulations_12
  
@ %def simulations_12
@ Auxiliary: display file contents.
<<Simulations: tests>>=
  subroutine display_file (file, u)
    character(*), intent(in) :: file
    integer, intent(in) :: u
    character(256) :: buffer
    integer :: u_file
    write (u, "(3A)")  "* Contents of file '", file, "':"
    write (u, *)
    u_file = free_unit ()
    open (u_file, file = file, action = "read", status = "old")
    do
       read (u_file, "(A)", end = 1)  buffer
       write (u, "(A)")  trim (buffer)
    end do
1   continue
  end subroutine display_file

@ %def display_file
@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{More Unit Tests}

This chapter collects some procedures for testing that can't be
provided at the point where the corresponding modules are defined,
because they use other modules of a different level.

(We should move them back, collecting the high-level functionality in
init/final hooks that we can set at runtime.)


\section{Expression Testing}

Expression objects are part of process and event objects, but the
process and event object modules should not depend on the
implementation of expressions.  Here, we collect unit tests that
depend on expression implementation.
<<[[expr_tests.f90]]>>=
<<File header>>
module expr_tests

<<Use kinds>>
<<Use strings>>
  use format_defs, only: FMT_12
  use format_utils, only: write_separator
  use unit_tests
  use os_interface
  use ifiles
  use lexers
  use parser
  use lorentz
  use sm_qcd
  use model_data
  use interactions, only: reset_interaction_counter
  use variables
  use expr_base
  use eval_trees
  use models
  use subevents
  use subevt_expr
  use phs_base
  use rng_base
  use mci_base
  use process_libraries
  use prc_test
  use prc_core
  use processes
  use events

<<Standard module head>>

<<Expr tests: public>>

contains
  
<<Expr tests: tests>>

end module expr_tests
@ %def expr_tests
@
\subsection{Test}
This is the master for calling self-test procedures.
<<Expr tests: public>>=
  public :: subevt_expr_test
<<Expr tests: tests>>=
  subroutine subevt_expr_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Expr tests: execute tests>>
end subroutine subevt_expr_test

@ %def subevt_expr_test
@
\subsubsection{Parton-event expressions}
<<Expr tests: execute tests>>=
  call test (subevt_expr_1, "subevt_expr_1", &
       "parton-event expressions", &
       u, results)
<<Expr tests: tests>>=
  subroutine subevt_expr_1 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_cuts, pt_scale, pt_fac_scale, pt_ren_scale
    type(parse_tree_t) :: pt_weight
    type(parse_node_t), pointer :: pn_cuts, pn_scale, pn_fac_scale, pn_ren_scale
    type(parse_node_t), pointer :: pn_weight
    type(eval_tree_factory_t) :: expr_factory
    type(os_data_t) :: os_data
    type(model_t), target :: model
    type(parton_expr_t), target :: expr
    real(default) :: E, Ex, m
    type(vector4_t), dimension(6) :: p
    integer :: i, pdg
    logical :: passed
    real(default) :: scale, fac_scale, ren_scale, weight
    
    write (u, "(A)")  "* Test output: subevt_expr_1"
    write (u, "(A)")  "*   Purpose: Set up a subevt and associated &
         &process-specific expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model%read (var_str ("Test.mdl"), os_data)

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")


    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "cuts = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_cuts, stream, .true.)
    call stream_final (stream)
    pn_cuts => parse_tree_get_root_ptr (pt_cuts)

    expr_text = "sqrts"
    write (u, "(A,A)")  "scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_scale, stream, .true.)
    call stream_final (stream)
    pn_scale => parse_tree_get_root_ptr (pt_scale)

    expr_text = "sqrts_hat"
    write (u, "(A,A)")  "fac_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_fac_scale, stream, .true.)
    call stream_final (stream)
    pn_fac_scale => parse_tree_get_root_ptr (pt_fac_scale)

    expr_text = "100"
    write (u, "(A,A)")  "ren_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_ren_scale, stream, .true.)
    call stream_final (stream)
    pn_ren_scale => parse_tree_get_root_ptr (pt_ren_scale)

    expr_text = "n_tot - n_in - n_out"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)
    pn_weight => parse_tree_get_root_ptr (pt_weight)

    call ifile_final (ifile)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize process expr"
    write (u, "(A)")

    call expr%setup_vars (1000._default)
    call var_list_append_real (expr%var_list, var_str ("tolerance"), 0._default)
    call expr%link_var_list (model%get_var_list_ptr ())

    call expr_factory%init (pn_cuts)
    call expr%setup_selection (expr_factory)
    call expr_factory%init (pn_scale)
    call expr%setup_scale (expr_factory)
    call expr_factory%init (pn_fac_scale)
    call expr%setup_fac_scale (expr_factory)
    call expr_factory%init (pn_ren_scale)
    call expr%setup_ren_scale (expr_factory)
    call expr_factory%init (pn_weight)
    call expr%setup_weight (expr_factory)

    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Fill subevt and evaluate expressions"
    write (u, "(A)")

    call subevt_init (expr%subevt_t, 6)
    E = 500._default
    Ex = 400._default
    m = 125._default
    pdg = 25
    p(1) = vector4_moving (E, sqrt (E**2 - m**2), 3)
    p(2) = vector4_moving (E, -sqrt (E**2 - m**2), 3)
    p(3) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 3)
    p(4) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 3)
    p(5) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 1)
    p(6) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 1)

    call expr%reset ()
    do i = 1, 2
       call subevt_set_beam (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 3, 4
       call subevt_set_incoming (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 5, 6
       call subevt_set_outgoing (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in = 2
    expr%n_out = 2
    expr%n_tot = 4
    expr%subevt_filled = .true.

    call expr%evaluate (passed, scale, fac_scale, ren_scale, weight)
    
    write (u, "(A,L1)")      "Event has passed      = ", passed
    write (u, "(A," // FMT_12 // ")")  "Scale                 = ", scale
    write (u, "(A," // FMT_12 // ")")  "Factorization scale   = ", fac_scale
    write (u, "(A," // FMT_12 // ")")  "Renormalization scale = ", ren_scale
    write (u, "(A," // FMT_12 // ")")  "Weight                = ", weight
    write (u, "(A)")
    
    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call expr%final ()

    call model%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: subevt_expr_1"
    
  end subroutine subevt_expr_1
  
@ %def subevt_expr_1
@
\subsubsection{Parton-event expressions}
<<Expr tests: execute tests>>=
  call test (subevt_expr_2, "subevt_expr_2", &
       "parton-event expressions", &
       u, results)
<<Expr tests: tests>>=
  subroutine subevt_expr_2 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_selection
    type(parse_tree_t) :: pt_reweight, pt_analysis
    type(parse_node_t), pointer :: pn_selection
    type(parse_node_t), pointer :: pn_reweight, pn_analysis
    type(os_data_t) :: os_data
    type(model_t), target :: model
    type(eval_tree_factory_t) :: expr_factory
    type(event_expr_t), target :: expr
    real(default) :: E, Ex, m
    type(vector4_t), dimension(6) :: p
    integer :: i, pdg
    logical :: passed
    real(default) :: reweight
    logical :: analysis_flag
    
    write (u, "(A)")  "* Test output: subevt_expr_2"
    write (u, "(A)")  "*   Purpose: Set up a subevt and associated &
         &process-specific expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()

    call syntax_model_file_init ()
    call os_data_init (os_data)
    call model%read (var_str ("Test.mdl"), os_data)

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")


    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "selection = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_selection, stream, .true.)
    call stream_final (stream)
    pn_selection => parse_tree_get_root_ptr (pt_selection)

    expr_text = "n_tot - n_in - n_out"
    write (u, "(A,A)")  "reweight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_reweight, stream, .true.)
    call stream_final (stream)
    pn_reweight => parse_tree_get_root_ptr (pt_reweight)

    expr_text = "true"
    write (u, "(A,A)")  "analysis = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_analysis, stream, .true.)
    call stream_final (stream)
    pn_analysis => parse_tree_get_root_ptr (pt_analysis)

    call ifile_final (ifile)

    write (u, "(A)")
    write (u, "(A)")  "* Initialize process expr"
    write (u, "(A)")

    call expr%setup_vars (1000._default)
    call expr%link_var_list (model%get_var_list_ptr ())
    call var_list_append_real (expr%var_list, var_str ("tolerance"), 0._default)

    call expr_factory%init (pn_selection)
    call expr%setup_selection (expr_factory)
    call expr_factory%init (pn_analysis)
    call expr%setup_analysis (expr_factory)
    call expr_factory%init (pn_reweight)
    call expr%setup_reweight (expr_factory)

    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Fill subevt and evaluate expressions"
    write (u, "(A)")

    call subevt_init (expr%subevt_t, 6)
    E = 500._default
    Ex = 400._default
    m = 125._default
    pdg = 25
    p(1) = vector4_moving (E, sqrt (E**2 - m**2), 3)
    p(2) = vector4_moving (E, -sqrt (E**2 - m**2), 3)
    p(3) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 3)
    p(4) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 3)
    p(5) = vector4_moving (Ex, sqrt (Ex**2 - m**2), 1)
    p(6) = vector4_moving (Ex, -sqrt (Ex**2 - m**2), 1)

    call expr%reset ()
    do i = 1, 2
       call subevt_set_beam (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 3, 4
       call subevt_set_incoming (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    do i = 5, 6
       call subevt_set_outgoing (expr%subevt_t, i, pdg, p(i), m**2)
    end do
    expr%sqrts_hat = subevt_get_sqrts_hat (expr%subevt_t)
    expr%n_in = 2
    expr%n_out = 2
    expr%n_tot = 4
    expr%subevt_filled = .true.

    call expr%evaluate (passed, reweight, analysis_flag)
    
    write (u, "(A,L1)")      "Event has passed      = ", passed
    write (u, "(A," // FMT_12 // ")")  "Reweighting factor    = ", reweight
    write (u, "(A,L1)")      "Analysis flag         = ", analysis_flag
    write (u, "(A)")
    
    call write_separator (u)
    call expr%write (u)
    call write_separator (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call expr%final ()

    call model%final ()
    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: subevt_expr_2"
    
  end subroutine subevt_expr_2
  
@ %def subevt_expr_2
@
\subsubsection{Processes: handle partonic cuts}
Initialize a process and process instance, choose a sampling point and
fill the process instance, evaluating a given cut configuration.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Expr tests: execute tests>>=
  call test (processes_5, "processes_5", &
       "handle cuts (partonic event)", &
       u, results)
<<Expr tests: tests>>=
  subroutine processes_5 (u)
    integer, intent(in) :: u
    type(string_t) :: cut_expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: parse_tree
    type(eval_tree_factory_t) :: expr_factory
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_t), pointer :: model_tmp
    class(model_data_t), pointer :: model
    type(var_list_t), target :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance

    write (u, "(A)")  "* Test output: processes_5"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare a cut expression"
    write (u, "(A)")

    call syntax_pexpr_init ()
    cut_expr_text = "all Pt > 100 [s]"
    call ifile_append (ifile, cut_expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (parse_tree, stream, .true.)
    
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes5"
    procname = libname
    run_id = "run5"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call syntax_model_file_init ()
    allocate (model_tmp)
    call model_tmp%read (var_str ("Test.mdl"), os_data)
    call var_list_init_snapshot (var_list, model_tmp%get_var_list_ptr ())
    model => model_tmp

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 

    call var_list_append_real &
         (var_list, var_str ("tolerance"), 0._default)
    call process%set_var_list (var_list)
    call var_list%final ()
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization and set cuts"
    write (u, "(A)")

    call process%setup_terms ()
    call expr_factory%init (parse_tree_get_root_ptr (parse_tree))
    call process%set_cuts (expr_factory)
    call process%write (.false., u, show_var_list=.true., show_expressions=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)

    write (u, "(A)")
    write (u, "(A)")  "* Inject a set of random numbers"
    write (u, "(A)")
     
    call process_instance%choose_mci (1)
    call process_instance%set_mcpar ([0._default, 0._default])

    write (u, "(A)")
    write (u, "(A)")  "* Set up kinematics and subevt, check cuts (should fail)"
    write (u, "(A)")

    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
   
    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set (should succeed)"
    write (u, "(A)")
     
    call process_instance%reset ()
    call process_instance%set_mcpar ([0.5_default, 0.125_default])
    call process_instance%select_channel (1)
    call process_instance%compute_seed_kinematics ()
    call process_instance%compute_hard_kinematics ()
    call process_instance%compute_eff_kinematics ()
    call process_instance%evaluate_expressions ()
    call process_instance%compute_other_channels ()
    call process_instance%evaluate_trace ()

    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set using convenience procedure &
         &(failure)"
    write (u, "(A)")
     
    call process_instance%evaluate_sqme (1, [0.0_default, 0.2_default])

    call process_instance%write_header (u)

    write (u, "(A)")
    write (u, "(A)")  "* Evaluate for another set using convenience procedure &
         &(success)"
    write (u, "(A)")
     
    call process_instance%evaluate_sqme (1, [0.1_default, 0.2_default])

    call process_instance%write_header (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call ifile_final (ifile)
    call syntax_pexpr_final ()
    
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_5"
    
  end subroutine processes_5
  
@ %def processes_5
@
\subsubsection{Processes: scales and such}
Initialize a process and process instance, choose a sampling point and
fill the process instance, evaluating a given cut configuration.

We use the same trivial process as for the previous test.  All
momentum and state dependence is trivial, so we just test basic
functionality. 
<<Expr tests: execute tests>>=
  call test (processes_6, "processes_6", &
       "handle scales and weight (partonic event)", &
       u, results)
<<Expr tests: tests>>=
  subroutine processes_6 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_scale, pt_fac_scale, pt_ren_scale, pt_weight
    type(process_library_t), target :: lib
    type(string_t) :: libname
    type(string_t) :: procname
    type(string_t) :: run_id
    type(os_data_t) :: os_data
    type(qcd_t) :: qcd
    class(rng_factory_t), allocatable :: rng_factory
    type(model_t), pointer :: model_tmp
    class(model_data_t), pointer :: model
    type(var_list_t), target :: var_list
    type(process_t), allocatable, target :: process
    class(prc_core_t), allocatable :: core_template
    class(mci_t), allocatable :: mci_template
    class(phs_config_t), allocatable :: phs_config_template
    real(default) :: sqrts
    type(process_instance_t), allocatable, target :: process_instance
    type(eval_tree_factory_t) :: expr_factory

    write (u, "(A)")  "* Test output: processes_6"
    write (u, "(A)")  "*   Purpose: create a process &
         &and fill a process instance"
    write (u, "(A)")

    write (u, "(A)")  "* Prepare expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()

    expr_text = "sqrts - 100 GeV"
    write (u, "(A,A)")  "scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_scale, stream, .true.)
    call stream_final (stream)

    expr_text = "sqrts_hat"
    write (u, "(A,A)")  "fac_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_fac_scale, stream, .true.)
    call stream_final (stream)
    
    expr_text = "eval sqrt (M2) [collect [s]]"
    write (u, "(A,A)")  "ren_scale = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_ren_scale, stream, .true.)
    call stream_final (stream)
    
    expr_text = "n_tot * n_in * n_out * (eval Phi / pi [s])"
    write (u, "(A,A)")  "weight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_weight, stream, .true.)
    call stream_final (stream)

    call ifile_final (ifile)
    
    write (u, "(A)")
    write (u, "(A)")  "* Build and initialize a test process"
    write (u, "(A)")

    libname = "processes4"
    procname = libname
    run_id = "run4"
    call os_data_init (os_data)
    allocate (rng_test_factory_t :: rng_factory)
    call prc_test_create_library (libname, lib)

    call syntax_model_file_init ()
    allocate (model_tmp)
    call model_tmp%read (var_str ("Test.mdl"), os_data)
    call var_list_init_snapshot (var_list, model_tmp%get_var_list_ptr ())
    model => model_tmp

    call reset_interaction_counter ()

    allocate (process)
    call process%init &
         (procname, run_id, lib, os_data, qcd, rng_factory, model) 

    call process%set_var_list (var_list)
    call var_list%final ()
   
    allocate (test_t :: core_template)
    allocate (phs_test_config_t :: phs_config_template)
    call process%init_component &
         (1, core_template, mci_template, phs_config_template)

    write (u, "(A)")  "* Prepare a trivial beam setup"
    write (u, "(A)")
    
    sqrts = 1000
    call process%setup_beams_sqrts (sqrts)
    call process%configure_phs ()
    call process%setup_mci ()

    write (u, "(A)")  "* Complete process initialization and set cuts"
    write (u, "(A)")

    call process%setup_terms ()
    call expr_factory%init (parse_tree_get_root_ptr (pt_scale))
    call process%set_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_fac_scale))
    call process%set_fac_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_ren_scale))
    call process%set_ren_scale (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_weight))
    call process%set_weight (expr_factory)
    call process%write (.false., u, show_expressions=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Create a process instance and evaluate"
    write (u, "(A)")

    allocate (process_instance)
    call process_instance%init (process)
    call process_instance%choose_mci (1)
    call process_instance%evaluate_sqme (1, [0.5_default, 0.125_default])

    call process_instance%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"
    
    call process_instance%final ()
    deallocate (process_instance)
    
    call process%final ()
    deallocate (process)

    call parse_tree_final (pt_scale)
    call parse_tree_final (pt_fac_scale)
    call parse_tree_final (pt_ren_scale)
    call parse_tree_final (pt_weight)
    call syntax_pexpr_final ()

    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: processes_6"
    
  end subroutine processes_6
  
@ %def processes_6
@
\subsubsection{Event expressions}
After generating an event, fill the [[subevt]] and evaluate expressions for
selection, reweighting, and analysis.
<<Expr tests: execute tests>>=
  call test (events_3, "events_3", &
       "expression evaluation", &
       u, results)
<<Expr tests: tests>>=
  subroutine events_3 (u)
    integer, intent(in) :: u
    type(string_t) :: expr_text
    type(ifile_t) :: ifile
    type(stream_t) :: stream
    type(parse_tree_t) :: pt_selection, pt_reweight, pt_analysis
    type(eval_tree_factory_t) :: expr_factory
    type(event_t), allocatable, target :: event
    type(process_t), allocatable, target :: process
    type(process_instance_t), allocatable, target :: process_instance
    type(os_data_t) :: os_data
    type(model_t), pointer :: model
    type(var_list_t), target :: var_list

    write (u, "(A)")  "* Test output: events_3"
    write (u, "(A)")  "*   Purpose: generate an event and evaluate expressions"
    write (u, "(A)")

    call syntax_pexpr_init ()

    write (u, "(A)")  "* Expression texts"
    write (u, "(A)")

    expr_text = "all Pt > 100 [s]"
    write (u, "(A,A)")  "selection = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_selection, stream, .true.)
    call stream_final (stream)

    expr_text = "1 + sqrts_hat / sqrts"
    write (u, "(A,A)")  "reweight = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_expr (pt_reweight, stream, .true.)
    call stream_final (stream)
    
    expr_text = "true"
    write (u, "(A,A)")  "analysis = ", char (expr_text)
    call ifile_clear (ifile)
    call ifile_append (ifile, expr_text)
    call stream_init (stream, ifile)
    call parse_tree_init_lexpr (pt_analysis, stream, .true.)
    call stream_final (stream)

    call ifile_final (ifile)
    
    write (u, "(A)")
    write (u, "(A)")  "* Initialize test process event"

    call os_data_init (os_data)

    call syntax_model_file_init ()
    allocate (model)
    call model%read (var_str ("Test.mdl"), os_data)
    call var_list_init_snapshot (var_list, model%get_var_list_ptr ())

    allocate (process)
    allocate (process_instance)
    call prepare_test_process (process, process_instance, model)

    call process%set_var_list (var_list)
    call var_list%final ()

    call process_instance%setup_event_data ()

    write (u, "(A)")
    write (u, "(A)")  "* Initialize event object and set expressions"

    allocate (event)
    call event%basic_init ()

    call expr_factory%init (parse_tree_get_root_ptr (pt_selection))
    call event%set_selection (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_reweight))
    call event%set_reweight (expr_factory)
    call expr_factory%init (parse_tree_get_root_ptr (pt_analysis))
    call event%set_analysis (expr_factory)
    
    call event%connect (process_instance, process%get_model_ptr ())
    call var_list_append_real &
         (event%expr%var_list, var_str ("tolerance"), 0._default)
    call event%setup_expressions ()

    write (u, "(A)")
    write (u, "(A)")  "* Generate test process event"

    call process%generate_weighted_event (process_instance, 1)

    write (u, "(A)")
    write (u, "(A)")  "* Fill event object and evaluate expressions"
    write (u, "(A)")

    call event%generate (1, [0.4_default, 0.4_default])
    call event%evaluate_expressions ()
    call event%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call event%final ()
    deallocate (event)

    call cleanup_test_process (process, process_instance)
    deallocate (process_instance)
    deallocate (process)

    call syntax_model_file_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: events_3"
    
  end subroutine events_3
  
@ %def events_3
@ 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Top Level}

The top level consists of
\begin{description}
\item[commands]
  Defines generic command-list and command objects, and all specific
  implementations.  Each command type provides a specific
  functionality.  Together with the modules that provide expressions
  and variables, this module defines the Sindarin language.
\item[whizard]
  This module interprets streams of various kind in terms of the
  command language.  It also contains the unit-test feature.  We also
  define the externally visible procedures here, for the \whizard\ as
  a library.
\item[main]
  The driver for \whizard\ as a stand-alone program.  Contains the
  command-line interpreter.
\item[whizard\_c\_interface]
  Alternative top-level procedures, for use in the context of a
  C-compatible caller program.
\end{description}

\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Commands}
This module defines the command language of the main input file.
<<[[commands.f90]]>>=
<<File header>>

module commands

<<Use kinds>>
<<Use strings>>
  use io_units
  use constants
  use string_utils, only: lower_case
  use format_utils, only: write_indent
  use format_defs, only: FMT_14, FMT_19
  use unit_tests
  use diagnostics
  use sm_qcd
  use physics_defs
  use pdf_builtin !NODEP!
  use sorting
  use sf_lhapdf
  use os_interface
  use ifiles
  use lexers
  use syntax_rules
  use parser
  use analysis
  use pdg_arrays
  use variables
  use observables
  use eval_trees
  use models
  use auto_components
  use interactions
  use flavors
  use polarizations
  use beams
  use particle_specifiers
  use process_libraries
  use processes
  use prclib_stacks
  use slha_interface
  use user_files
  use eio_data
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams
  use simulations
  use radiation_generator
  use blha_config

<<Standard module head>>

<<Commands: public>>

<<Commands: types>>

<<Commands: variables>>

<<Commands: parameters>>

<<Commands: interfaces>>

contains

<<Commands: procedures>>

<<Commands: tests>>

end module commands
@ %def commands
@ 
\subsection{The command type}
The command type is a generic type that holds any command, compiled
for execution.

Each command may come with its own local environment.  The command list that
determines this environment is allocated as [[options]], if necessary.  (It
has to be allocated as a pointer because the type definition is recursive.) The
local environment is available as a pointer which either points to the global
environment, or is explicitly allocated and initialized.
<<Commands: types>>=
  type, abstract :: command_t
     type(parse_node_t), pointer :: pn => null ()
     class(command_t), pointer :: next => null ()
     type(parse_node_t), pointer :: pn_opt => null ()
     type(command_list_t), pointer :: options => null ()
     type(rt_data_t), pointer :: local => null ()
   contains
   <<Commands: command: TBP>>
  end type command_t

@ %def command_t
@ Finalizer: If there is an option list, finalize the option list and
deallocate.  If not, the local environment is just a pointer.
<<Commands: command: TBP>>=
  procedure :: final => command_final
<<Commands: procedures>>=
  recursive subroutine command_final (cmd)
    class(command_t), intent(inout) :: cmd
    if (associated (cmd%options)) then
       call cmd%options%final ()
       deallocate (cmd%options)
       call cmd%local%local_final ()
       deallocate (cmd%local)
    else
       cmd%local => null ()
    end if
  end subroutine command_final

@ %def command_final
@ Allocate a command with the appropriate concrete type.  Store the
parse node pointer in the command object, so we can reference to it
when compiling.
<<Commands: procedures>>=
  subroutine dispatch_command (command, pn)
    class(command_t), intent(inout), pointer :: command
    type(parse_node_t), intent(in), target :: pn
    select case (char (parse_node_get_rule_key (pn)))
    case ("cmd_model")
       allocate (cmd_model_t :: command)
    case ("cmd_library")
       allocate (cmd_library_t :: command)
    case ("cmd_process")
       allocate (cmd_process_t :: command)
    case ("cmd_nlo")
       allocate (cmd_nlo_t :: command)
    case ("cmd_compile")
       allocate (cmd_compile_t :: command)
    case ("cmd_exec")
       allocate (cmd_exec_t :: command)
     case ("cmd_num", "cmd_complex", "cmd_real", "cmd_int", &
           "cmd_log_decl", "cmd_log", "cmd_string", "cmd_string_decl", &
           "cmd_alias", "cmd_result")
       allocate (cmd_var_t :: command)
    case ("cmd_slha")
       allocate (cmd_slha_t :: command)
    case ("cmd_show")
       allocate (cmd_show_t :: command)
    case ("cmd_clear")
       allocate (cmd_clear_t :: command)
    case ("cmd_expect")
       allocate (cmd_expect_t :: command)
    case ("cmd_beams")
       allocate (cmd_beams_t :: command)
    case ("cmd_beams_pol_density")
       allocate (cmd_beams_pol_density_t :: command)
    case ("cmd_beams_pol_fraction")
       allocate (cmd_beams_pol_fraction_t :: command)
    case ("cmd_beams_momentum")
       allocate (cmd_beams_momentum_t :: command)
    case ("cmd_beams_theta")
       allocate (cmd_beams_theta_t :: command)
    case ("cmd_beams_phi")
       allocate (cmd_beams_phi_t :: command)
    case ("cmd_cuts")
       allocate (cmd_cuts_t :: command)
    case ("cmd_scale")
       allocate (cmd_scale_t :: command)
    case ("cmd_fac_scale")
       allocate (cmd_fac_scale_t :: command)
    case ("cmd_ren_scale")
       allocate (cmd_ren_scale_t :: command)
    case ("cmd_weight")
       allocate (cmd_weight_t :: command)
    case ("cmd_selection")
       allocate (cmd_selection_t :: command)
    case ("cmd_reweight")
       allocate (cmd_reweight_t :: command)
    case ("cmd_iterations")
       allocate (cmd_iterations_t :: command)
    case ("cmd_integrate")
       allocate (cmd_integrate_t :: command)
    case ("cmd_observable")
       allocate (cmd_observable_t :: command)
    case ("cmd_histogram")
       allocate (cmd_histogram_t :: command)
    case ("cmd_plot")
       allocate (cmd_plot_t :: command)
    case ("cmd_graph")
       allocate (cmd_graph_t :: command)
    case ("cmd_record")
       allocate (cmd_record_t :: command)
    case ("cmd_analysis")
       allocate (cmd_analysis_t :: command)
    case ("cmd_alt_setup")
       allocate (cmd_alt_setup_t :: command)
    case ("cmd_unstable")
       allocate (cmd_unstable_t :: command)
    case ("cmd_stable")
       allocate (cmd_stable_t :: command)
    case ("cmd_polarized")
       allocate (cmd_polarized_t :: command)
    case ("cmd_unpolarized")
       allocate (cmd_unpolarized_t :: command)
    case ("cmd_sample_format")
       allocate (cmd_sample_format_t :: command)
    case ("cmd_simulate")
       allocate (cmd_simulate_t :: command)
    case ("cmd_rescan")
       allocate (cmd_rescan_t :: command)
    case ("cmd_write_analysis")
       allocate (cmd_write_analysis_t :: command)
    case ("cmd_compile_analysis")
       allocate (cmd_compile_analysis_t :: command)
    case ("cmd_open_out")
       allocate (cmd_open_out_t :: command)
    case ("cmd_close_out")
       allocate (cmd_close_out_t :: command)
    case ("cmd_printf")
       allocate (cmd_printf_t :: command)
    case ("cmd_scan")
       allocate (cmd_scan_t :: command)
    case ("cmd_if")
       allocate (cmd_if_t :: command)
    case ("cmd_include")
       allocate (cmd_include_t :: command)
    case ("cmd_quit")
       allocate (cmd_quit_t :: command)
    case default
       print *, char (parse_node_get_rule_key (pn))
       call msg_bug ("Command not implemented")
    end select
    command%pn => pn
  end subroutine dispatch_command

@ %def dispatch_command
@ Output.  We allow for indentation so we can display a command tree.
<<Commands: command: TBP>>=
  procedure (command_write), deferred :: write
<<Commands: interfaces>>=
  abstract interface
     subroutine command_write (cmd, unit, indent)
       import
       class(command_t), intent(in) :: cmd
       integer, intent(in), optional :: unit, indent
     end subroutine command_write
  end interface
  
@ %def command_write
@ Compile a command.  The command type is already fixed, so this is a
deferred type-bound procedure.
<<Commands: command: TBP>>=
  procedure (command_compile), deferred :: compile
<<Commands: interfaces>>=
  abstract interface
     subroutine command_compile (cmd, global)
       import
       class(command_t), intent(inout) :: cmd
       type(rt_data_t), intent(inout), target :: global
     end subroutine command_compile
  end interface

@ %def command_compile
@ Execute a command.  This will use and/or modify the runtime data
set.  If the [[quit]] flag is set, the caller should terminate command
execution.
<<Commands: command: TBP>>=
  procedure (command_execute), deferred :: execute
<<Commands: interfaces>>=
  abstract interface
     subroutine command_execute (cmd, global)
       import
       class(command_t), intent(inout) :: cmd
       type(rt_data_t), intent(inout), target :: global
     end subroutine command_execute
  end interface

@ %def command_execute
@
\subsection{Options}
The [[options]] command list is allocated, initialized, and executed, if the
command is associated with an option text in curly braces.  If present, a
separate local runtime data set [[local]] will be allocated and initialized;
otherwise, [[local]] becomes a pointer to the global dataset.

For output, we indent the options list.
<<Commands: command: TBP>>=
  procedure :: write_options => command_write_options
<<Commands: procedures>>=
  recursive subroutine command_write_options (cmd, unit, indent)
    class(command_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: ind
    ind = 1;  if (present (indent))  ind = indent + 1
    if (associated (cmd%options))  call cmd%options%write (unit, ind)
  end subroutine command_write_options
  
@ %def command_write_options
@ Compile the options list, if any.  This implies initialization of the local
environment.  Should be done once the [[pn_opt]] node has been assigned (if
applicable), but before the actual command compilation.
<<Commands: command: TBP>>=
  procedure :: compile_options => command_compile_options
<<Commands: procedures>>=
  recursive subroutine command_compile_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%pn_opt)) then
       allocate (cmd%local)
       call cmd%local%local_init (global)
       call global%copy_globals (cmd%local)
       allocate (cmd%options)
       call cmd%options%compile (cmd%pn_opt, cmd%local)
       call global%restore_globals (cmd%local)
       call cmd%local%deactivate ()
    else
       cmd%local => global
    end if
  end subroutine command_compile_options
  
@ %def command_compile_options
@ Execute options.  First prepare the local environment, then execute the
command list. 
<<Commands: command: TBP>>=
  procedure :: execute_options => cmd_execute_options
<<Commands: procedures>>=
  recursive subroutine cmd_execute_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%options)) then
       call cmd%local%activate ()
       call cmd%options%execute (cmd%local)
    end if
  end subroutine cmd_execute_options

@ %def cmd_execute_options
@ This must be called after the parent command has been executed, to undo
temporary modifications to the environment.  Note that some modifications to
[[global]] can become permanent.
<<Commands: command: TBP>>=
  procedure :: reset_options => cmd_reset_options
<<Commands: procedures>>=
  subroutine cmd_reset_options (cmd, global)
    class(command_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%options)) then
       call cmd%local%deactivate (global)
    end if
  end subroutine cmd_reset_options
  
@ %def cmd_reset_options
@
\subsection{Specific command types}
\subsubsection{Model configuration}
The command declares a model, looks for the specified file and loads
it.
<<Commands: types>>=
  type, extends (command_t) :: cmd_model_t
     private
     type(string_t) :: name
   contains
   <<Commands: cmd model: TBP>>
  end type cmd_model_t

@ %def cmd_model_t
@ Output
<<Commands: cmd model: TBP>>=
  procedure :: write => cmd_model_write
<<Commands: procedures>>=
  subroutine cmd_model_write (cmd, unit, indent)
    class(cmd_model_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,'""',A,'""')")  "model =", char (cmd%name)
  end subroutine cmd_model_write

@ %def cmd_model_write
@ Compile.  Get the model name and read the model from file, so it is
readily available when the command list is executed.

Assign the model pointer in the [[global]] record, so it can be used for
(read-only) variable lookup while compiling further commands.
<<Commands: cmd model: TBP>>=
  procedure :: compile => cmd_model_compile
<<Commands: procedures>>=
  subroutine cmd_model_compile (cmd, global)
    class(cmd_model_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_name
    type(model_t), pointer :: model
    pn_name => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%name = parse_node_get_string (pn_name)
    model => null ()
    if (associated (global%model)) then
       if (global%model%get_name () == cmd%name)  model => global%model
    end if
    if (.not. associated (model)) then
       if (global%model_list%model_exists (cmd%name)) then
          model => global%model_list%get_model_ptr (cmd%name)
       else
          call global%read_model (cmd%name, model)
       end if
    end if
    global%model => model
    if (associated (global%model)) then
       call global%model%link_var_list (global%var_list)
    end if
  end subroutine cmd_model_compile

@ %def cmd_model_compile
@ Execute: Insert a pointer into the global data record and reassign
the variable list.
<<Commands: cmd model: TBP>>=
  procedure :: execute => cmd_model_execute
<<Commands: procedures>>=
  subroutine cmd_model_execute (cmd, global)
    class(cmd_model_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    call global%select_model (cmd%name)
    if (.not. associated (global%model)) &
         call msg_fatal ("Switching to model '" &
         // char (cmd%name) // "': model not found")
  end subroutine cmd_model_execute

@ %def cmd_model_execute
@
\subsubsection{Library configuration}
We configure a process library that should hold the subsequently
defined processes.  If the referenced library exists already, just
make it the currently active one.
<<Commands: types>>=
  type, extends (command_t) :: cmd_library_t
     private
     type(string_t) :: name
   contains
   <<Commands: cmd library: TBP>>
  end type cmd_library_t

@ %def cmd_library_t
@ Output.
<<Commands: cmd library: TBP>>=
  procedure :: write => cmd_library_write
<<Commands: procedures>>=
  subroutine cmd_library_write (cmd, unit, indent)
    class(cmd_library_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit)
    call write_indent (u, indent)
    write (u, "(1x,A,1x,'""',A,'""')")  "library =", char (cmd%name)
  end subroutine cmd_library_write

@ %def cmd_library_write
@ Compile.  Get the library name.
<<Commands: cmd library: TBP>>=
  procedure :: compile => cmd_library_compile
<<Commands: procedures>>=
  subroutine cmd_library_compile (cmd, global)
    class(cmd_library_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_name
    pn_name => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%name = parse_node_get_string (pn_name)
  end subroutine cmd_library_compile

@ %def cmd_library_compile
@ Execute: Initialize a new library and push it on the library stack
(if it does not yet exist).   Insert a pointer to the library into the
global data record.  Then, try to load the library unless the
[[rebuild]] flag is set.
<<Commands: cmd library: TBP>>=
  procedure :: execute => cmd_library_execute
<<Commands: procedures>>=
  subroutine cmd_library_execute (cmd, global)
    class(cmd_library_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(prclib_entry_t), pointer :: lib_entry
    type(process_library_t), pointer :: lib
    logical :: rebuild_library
    lib => global%prclib_stack%get_library_ptr (cmd%name)
    rebuild_library = &
         global%var_list%get_lval (var_str ("?rebuild_library"))    
    if (.not. (associated (lib))) then
       allocate (lib_entry)
       call lib_entry%init (cmd%name)
       lib => lib_entry%process_library_t
       call global%add_prclib (lib_entry)
    else
       call global%update_prclib (lib)
    end if
    if (associated (lib) .and. .not. rebuild_library) then
       call lib%update_status (global%os_data)
    end if
  end subroutine cmd_library_execute

@ %def cmd_library_execute
@
\subsubsection{Process configuration}
We define a process-configuration command as a specific type.  The
incoming and outgoing particles are given evaluation-trees which we
transform to PDG-code arrays.  For transferring to \oMega, they are
reconverted to strings.

For the incoming particles, we store parse nodes individually.  We do
not yet resolve the outgoing state, so we store just a single parse
node. 

This also includes the choice of method for the corresponding process:
[[omega]] for \oMega\ matrix elements as Fortran code, [[ovm]] for
\oMega\ matrix elements as a bytecode virtual machine, [[test]] for
special processes, [[unit_test]] for internal test matrix elements
generated by \whizard, [[template]] and [[template_unity]] for test
matrix elements generated by \whizard\ as Fortran code similar to the 
\oMega\ code. If the one-loop program (OLP) \gosam\ is linked, also
matrix elements from there (at leading and next-to-leading order) can
be generated via [[gosam]].
<<Commands: types>>=
  type, extends (command_t) :: cmd_process_t
     private
     type(string_t) :: id
     integer :: n_in  = 0
     type(parse_node_p), dimension(:), allocatable :: pn_pdg_in
     type(parse_node_t), pointer :: pn_out => null ()
   contains
   <<Commands: cmd process: TBP>>  
  end type cmd_process_t

@ %def cmd_process_t
@ Output.  The particle expressions are not resolved, so we just list the
number of incoming particles.
<<Commands: cmd process: TBP>>=
  procedure :: write => cmd_process_write
<<Commands: procedures>>=
  subroutine cmd_process_write (cmd, unit, indent)
    class(cmd_process_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A,I0,A)")  "process: ", char (cmd%id), " (", &
         size (cmd%pn_pdg_in), " -> X)"
    call cmd%write_options (u, indent)
  end subroutine cmd_process_write

@ %def cmd_process_write
@ Compile.  Find and assign the parse nodes.
<<Commands: cmd process: TBP>>=
  procedure :: compile => cmd_process_compile
<<Commands: procedures>>=
  subroutine cmd_process_compile (cmd, global)
    class(cmd_process_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_id, pn_in, pn_codes
    integer :: i
    pn_id => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_in  => parse_node_get_next_ptr (pn_id, 2)
    cmd%pn_out => parse_node_get_next_ptr (pn_in, 2)
    cmd%pn_opt => parse_node_get_next_ptr (cmd%pn_out)
    call cmd%compile_options (global)
    cmd%id = parse_node_get_string (pn_id)
    cmd%n_in  = parse_node_get_n_sub (pn_in)
    pn_codes => parse_node_get_sub_ptr (pn_in)
    allocate (cmd%pn_pdg_in (cmd%n_in))
    do i = 1, cmd%n_in
       cmd%pn_pdg_in(i)%ptr => pn_codes
       pn_codes => parse_node_get_next_ptr (pn_codes)
    end do
  end subroutine cmd_process_compile

@ %def cmd_process_compile
@ Command execution.  Evaluate the subevents, transform PDG codes
into strings, and add the current process configuration to the
process library. 

The initial state will be unique (one or two particles).  For the final state,
we allow for expressions.  The expressions will be expanded until we have a
sum of final states.  Each distinct final state will get its own process
component.

To identify equivalent final states, we transform the final state into an array
of PDG codes, which we sort and compare.  If a particle entry is actually a
PDG array, only the first entry in the array is used for the comparison.
The user should make sure that there is no overlap between different particles
or arrays which would make the expansion ambiguous.
<<Commands: cmd process: TBP>>=
  procedure :: execute => cmd_process_execute
<<Commands: procedures>>=
  subroutine cmd_process_execute (cmd, global)
    class(cmd_process_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(pdg_array_t) :: pdg_in, pdg_out
    type(pdg_array_t), dimension(:), allocatable :: pdg_out_tab
    type(string_t), dimension(:), allocatable :: prt_in
    type(string_t) :: prt_out, prt_out1
    type(process_configuration_t) :: prc_config
    type(prt_expr_t) :: prt_expr_out
    type(prt_spec_t), dimension(:), allocatable :: prt_spec_in
    type(prt_spec_t), dimension(:), allocatable :: prt_spec_out
    type(var_list_t), pointer :: var_list
    integer, dimension(:), allocatable :: pdg
    integer, dimension(:), allocatable :: i_term
    integer :: i, j, n_in, n_out, n_terms, n_components
    logical :: nlo_calc
    logical, dimension(3) :: active_nlo_components
    type(pdg_array_t), dimension(:), allocatable :: pdg_array_in, pdg_array_out
    type(string_t), dimension(:), allocatable :: prt_in_nlo, prt_out_nlo
    type(radiation_generator_t) :: radiation_generator
    type(pdg_list_t) :: pl_in, pl_out
    logical :: method_changed = .false.
    type(string_t) :: loop_me_method
    type(string_t) :: correlation_me_method
    type(string_t) :: real_tree_me_method
    type(string_t) :: current_me_method 
    integer , dimension(4) :: i_list
    logical :: combined_nlo_integration, powheg_active
    
    nlo_calc = cmd%local%nlo_calculation                 
    combined_nlo_integration = &
           global%var_list%get_lval (var_str ('?combined_nlo_integration'))
    powheg_active = & 
           global%var_list%get_lval (var_str ('?powheg_matching')) 
    call check_nlo_options (nlo_calc, combined_nlo_integration, powheg_active)
    active_nlo_components = cmd%local%active_nlo_components

    var_list => cmd%local%get_var_list_ptr ()

    n_in = size (cmd%pn_pdg_in)
    allocate (prt_in (n_in), prt_spec_in (n_in))
    do i = 1, n_in
       pdg_in = &
            eval_pdg_array (cmd%pn_pdg_in(i)%ptr, var_list)
       prt_in(i) = make_flavor_string (pdg_in, cmd%local%model)
       prt_spec_in(i) = new_prt_spec (prt_in(i))
    end do
    call compile_prt_expr &
         (prt_expr_out, cmd%pn_out, var_list, cmd%local%model)
    call prt_expr_out%expand ()
    n_terms = prt_expr_out%get_n_terms ()
    allocate (pdg_out_tab (n_terms))
    allocate (i_term (n_terms), source = 0)
    n_components = 0
    SCAN_COMPONENTS: do i = 1, n_terms
       if (allocated (pdg))  deallocate (pdg)
       call prt_expr_out%term_to_array (prt_spec_out, i)
       n_out = size (prt_spec_out)
       allocate (pdg (n_out))
       do j = 1, n_out
          prt_out = prt_spec_out(j)%to_string ()
          call split (prt_out, prt_out1, ":")
          pdg(j) = cmd%local%model%get_pdg (prt_out1)
       end do
       pdg_out = sort (pdg)
       do j = 1, n_components
          if (pdg_out == pdg_out_tab(j))  cycle SCAN_COMPONENTS
       end do
       n_components = n_components + 1
       i_term(n_components) = i
       pdg_out_tab(n_components) = pdg_out
    end do SCAN_COMPONENTS
    if (nlo_calc) then
      call prc_config%init (cmd%id, n_in, n_components*4, cmd%local)
    else
      call prc_config%init (cmd%id, n_in, n_components, cmd%local)
    end if
    do i = 1, n_components
       call prt_expr_out%term_to_array (prt_spec_out, i_term(i))
       if (nlo_calc) then
         associate (active_comp => cmd%local%active_nlo_components)
            i_list(1) = i
            i_list(2) = i + n_components
            i_list(3) = i + 2*n_components
            i_list(4) = i + 3*n_components
            loop_me_method = global%var_list%get_sval (var_str ("$loop_me_method"))
            correlation_me_method = global%var_list%get_sval (var_str ("$correlation_me_method"))
            real_tree_me_method = global%var_list%get_sval (var_str ("$real_tree_me_method"))

            call prc_config%setup_component (i, prt_spec_in, prt_spec_out, &
                                             cmd%local, BORN, &
                                             active_in = active_comp (1))
            call split_prt (prt_spec_in, n_in, pl_in)
            call split_prt (prt_spec_out, n_out, pl_out)
            call radiation_generator_init (radiation_generator, .true., .false., &
                                           pl_in, pl_out)
            call radiation_generator%set_n (n_in, n_out, 0)
            call radiation_generator%set_constraints (.false., .false., .true., .true.)
            call radiation_generator%init_radiation_model &
                 (cmd%local%radiation_model)
            call radiation_generator%generate (prt_in_nlo, prt_out_nlo)

            current_me_method = var_str ('omega')
            if (current_me_method /= real_tree_me_method) then
               call global%set_me_method (real_tree_me_method)
               current_me_method = real_tree_me_method
            end if
  
            call prc_config%setup_component (n_components + i, &
                            new_prt_spec (prt_in_nlo), &
                            new_prt_spec (prt_out_nlo),&
                            cmd%local, NLO_REAL, &
                            active_in = active_comp (2))

            if (current_me_method /= loop_me_method) then
               call global%set_me_method (loop_me_method)
               current_me_method = loop_me_method
            end if

            call prc_config%setup_component (n_components*2 + i, prt_spec_in, &
                            prt_spec_out, global, NLO_VIRTUAL, &
                            active_in = active_comp (3))

            if (current_me_method /= correlation_me_method) then
               call global%set_me_method (correlation_me_method)
               current_me_method = correlation_me_method
            end if

            call prc_config%setup_component (n_components*3 + i, prt_spec_in, &
                            prt_spec_out, global, NLO_SUBTRACTION, &
                            .false.)                     
            call prc_config%set_component_associations (i_list)
         end associate
       else
         call prc_config%setup_component (i, prt_spec_in, prt_spec_out, cmd%local)
       end if
    end do
    call prc_config%record (cmd%local)
 
  contains
    subroutine check_nlo_options (nlo, combined, powheg)
      logical, intent(in) :: nlo, combined, powheg
      logical :: case_lo_but_any_other
      logical :: case_nlo_powheg_but_not_combined
      case_lo_but_any_other = .not. nlo .and. &
                              any ([combined, powheg])
      case_nlo_powheg_but_not_combined = &
                              nlo .and. powheg .and. .not. combined
      if (case_lo_but_any_other) then
          call msg_fatal ("Option mismatch: Leading order process is selected &
                          &but either powheg_matching or combined_nlo_integration &
                          &is set to true.")
      else if (case_nlo_powheg_but_not_combined) then
          call msg_fatal ("POWHEG requires the 'combined_nlo_integration'-option &
                          &to be set to true.")
      end if
    end subroutine check_nlo_options

    subroutine split_prt (prt, n_out, pl)
      type(prt_spec_t), intent(in), dimension(:), allocatable :: prt
      integer, intent(in) :: n_out
      type(pdg_list_t), intent(out) :: pl
      type(pdg_array_t) :: pdg
      type(string_t) :: prt_string, prt_tmp
      integer, dimension(10) :: i_particle
      integer :: i, j, n
      call pl%init (n_out)
      do i = 1, n_out
         n = 1
         prt_string = prt(i)%to_string ()
         do
           call split (prt_string, prt_tmp, ":")
           if (prt_tmp /= "") then
             i_particle(n) = cmd%local%model%get_pdg (prt_tmp)
             n=n+1
           else
             exit
           end if
         end do
         call pdg_array_init (pdg, n-1)
         do j = 1, n-1 
           call pdg%set (j, i_particle(j))
         end do
         call pl%set (i, pdg)
         call pdg_array_delete (pdg)
      end do
    end subroutine split_prt
             
  end subroutine cmd_process_execute

@ %def cmd_process_execute
@ This is a method of the eval tree, but cannot be coded inside the
[[expressions]] module since it uses the [[model]] and [[flv]] types
which are not available there.
<<Commands: procedures>>=
  function make_flavor_string (aval, model) result (prt)
    type(string_t) :: prt
    type(pdg_array_t), intent(in) :: aval
    type(model_t), intent(in), target :: model
    integer, dimension(:), allocatable :: pdg
    type(flavor_t), dimension(:), allocatable :: flv
    integer :: i
    pdg = aval
    allocate (flv (size (pdg)))
    call flv%init (pdg, model)
    if (size (pdg) /= 0) then
       prt = flv(1)%get_name ()
       do i = 2, size (flv)
          prt = prt // ":" // flv(i)%get_name ()
       end do
    else
       prt = "?"
    end if
  end function make_flavor_string

@ %def make_flavor_string
@ Create a pdg array from a particle-specification array
<<Commands: procedures>>=
  function make_pdg_array (prt, model) result (pdg_array)
    type(prt_spec_t), intent(in), dimension(:) :: prt
    type(model_t), intent(in) :: model
    integer, dimension(:), allocatable :: aval
    type(pdg_array_t) :: pdg_array
    type(flavor_t) :: flv
    integer :: k
    allocate (aval (size (prt)))
    do k = 1, size (prt)
      call flv%init (prt(k)%to_string (), model)
      aval (k) = flv%get_pdg ()
    end do
    pdg_array = aval
  end function make_pdg_array

@ %def make_pdg_array
@ Compile a (possible nested) expression, to obtain a
particle-specifier expression which we can process further.
<<Commands: procedures>>=
  recursive subroutine compile_prt_expr (prt_expr, pn, var_list, model)
    type(prt_expr_t), intent(out) :: prt_expr
    type(parse_node_t), intent(in), target :: pn
    type(var_list_t), intent(in), target :: var_list
    type(model_t), intent(in), target :: model
    type(parse_node_t), pointer :: pn_entry, pn_term, pn_addition
    type(pdg_array_t) :: pdg
    type(string_t) :: prt_string
    integer :: n_entry, n_term, i
    select case (char (parse_node_get_rule_key (pn)))
    case ("prt_state_list")
       n_entry = parse_node_get_n_sub (pn)
       pn_entry => parse_node_get_sub_ptr (pn)
       if (n_entry == 1) then
          call compile_prt_expr (prt_expr, pn_entry, var_list, model)
       else
          call prt_expr%init_list (n_entry)
          select type (x => prt_expr%x)
          type is (prt_spec_list_t)
             do i = 1, n_entry
                call compile_prt_expr (x%expr(i), pn_entry, var_list, model)
                pn_entry => parse_node_get_next_ptr (pn_entry)
             end do
          end select
       end if
    case ("prt_state_sum")
       n_term = parse_node_get_n_sub (pn)
       pn_term => parse_node_get_sub_ptr (pn)
       pn_addition => pn_term
       if (n_term == 1) then
          call compile_prt_expr (prt_expr, pn_term, var_list, model)
       else
          call prt_expr%init_sum (n_term)
          select type (x => prt_expr%x)
          type is (prt_spec_sum_t)
             do i = 1, n_term
                call compile_prt_expr (x%expr(i), pn_term, var_list, model)
                pn_addition => parse_node_get_next_ptr (pn_addition)
                if (associated (pn_addition)) &
                     pn_term => parse_node_get_sub_ptr (pn_addition, 2)
             end do
          end select
       end if
    case ("cexpr")
       pdg = eval_pdg_array (pn, var_list)
       prt_string = make_flavor_string (pdg, model)
       call prt_expr%init_spec (new_prt_spec (prt_string))
    case default
       call parse_node_write_rec (pn)
       call msg_bug ("compile prt expr: impossible syntax rule")
    end select
  end subroutine compile_prt_expr
          
@ %def compile_prt_expr
@
\subsubsection{Initiating a NLO calculation}
<<Commands: types>>=
  type, extends (command_t) :: cmd_nlo_t
    private
    type(parse_node_p), dimension(3) :: pn_components
    logical, dimension(3) :: active_component  
  contains
    <<Commands: cmd nlo: TBP>>
  end type cmd_nlo_t

@ %def cmd_nlo_t
@
<<Commands: cmd nlo: TBP>>=
  procedure :: write => cmd_nlo_write
<<Commands: procedures>>=
  subroutine cmd_nlo_write (cmd, unit, indent)
    class(cmd_nlo_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
  end subroutine cmd_nlo_write

@ %def cmd_nlo_write
@ As it is, the NLO calculation is switched on by putting {nlo} behind the process definition. This should be made nicer in the future.
<<Commands: cmd nlo: TBP>>=
  procedure :: compile => cmd_nlo_compile
<<Commands: procedures>>=
  subroutine cmd_nlo_compile (cmd, global)
    class(cmd_nlo_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_comp
    integer :: i
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    cmd%pn_components(1)%ptr => parse_node_get_sub_ptr (pn_arg)
    pn_comp => parse_node_get_next_ptr (cmd%pn_components(1)%ptr)
    i = 2
    do 
      if (associated (pn_comp)) then
         cmd%pn_components(i)%ptr => pn_comp
         pn_comp => parse_node_get_next_ptr (cmd%pn_components(i)%ptr)
         i = i+1
      else
         exit
      end if
    end do
  end subroutine cmd_nlo_compile

@ %def cmd_nlo_compile
@
<<Commands: cmd nlo: TBP>>=
  procedure :: execute => cmd_nlo_execute
<<Commands: procedures>>=
  subroutine cmd_nlo_execute (cmd, global)
    class(cmd_nlo_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: current_component
    type(string_t) :: component_type
    integer :: i

    cmd%active_component = .false.

    current_component => cmd%pn_components(1)%ptr
    i = 2
    do 
      if (associated (current_component)) then
         component_type = eval_string (current_component, global%var_list)
         select case (char (component_type))
         case ('Born')
            cmd%active_component(1) = .true.
         case ('Real')
            cmd%active_component(2) = .true.
         case ('Virtual')
            cmd%active_component(3) = .true.
         case ('Full')
            cmd%active_component = .true.
         end select
         if (i >= 4) exit
         current_component => cmd%pn_components(i)%ptr
         i = i+1
      else
         exit
      end if
    end do   
    ! global%nlo_calculation = cmd%nlo_calc
    global%nlo_calculation = cmd%active_component(2) &
                        .or. cmd%active_component(3)
    global%active_nlo_components = cmd%active_component
  end subroutine cmd_nlo_execute

@ %def cmd_nlo_execute
@
\subsubsection{Process compilation}
<<Commands: types>>=
  type, extends (command_t) :: cmd_compile_t
     private
     type(string_t), dimension(:), allocatable :: libname
     logical :: make_executable = .false.
     type(string_t) :: exec_name
   contains
   <<Commands: cmd compile: TBP>>
  end type cmd_compile_t

@ %def cmd_compile_t
@ Output: list all libraries to be compiled.
<<Commands: cmd compile: TBP>>=
  procedure :: write => cmd_compile_write
<<Commands: procedures>>=
  subroutine cmd_compile_write (cmd, unit, indent)
    class(cmd_compile_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "compile ("
    if (allocated (cmd%libname)) then
       do i = 1, size (cmd%libname)
          if (i > 1)  write (u, "(A,1x)", advance="no")  ","
          write (u, "('""',A,'""')", advance="no")  char (cmd%libname(i))
       end do
    end if
    write (u, "(A)")  ")"
  end subroutine cmd_compile_write

@ %def cmd_compile_write
@ Compile the libraries specified in the argument.  If the argument is
empty, compile all libraries which can be found in the process library stack.
<<Commands: cmd compile: TBP>>=
  procedure :: compile => cmd_compile_compile
<<Commands: procedures>>=
  subroutine cmd_compile_compile (cmd, global)
    class(cmd_compile_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd, pn_clause, pn_arg, pn_lib
    type(parse_node_t), pointer :: pn_exec_name_spec, pn_exec_name
    integer :: n_lib, i
    pn_cmd => parse_node_get_sub_ptr (cmd%pn)
    pn_clause => parse_node_get_sub_ptr (pn_cmd)
    pn_exec_name_spec => parse_node_get_sub_ptr (pn_clause, 2)
    if (associated (pn_exec_name_spec)) then
       pn_exec_name => parse_node_get_sub_ptr (pn_exec_name_spec, 2)
    else
       pn_exec_name => null ()
    end if
    pn_arg => parse_node_get_next_ptr (pn_clause)
    cmd%pn_opt => parse_node_get_next_ptr (pn_cmd)
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_lib = parse_node_get_n_sub (pn_arg)
    else
       n_lib = 0
    end if
    if (n_lib > 0) then
       allocate (cmd%libname (n_lib))
       pn_lib => parse_node_get_sub_ptr (pn_arg)
       do i = 1, n_lib
          cmd%libname(i) = parse_node_get_string (pn_lib)
          pn_lib => parse_node_get_next_ptr (pn_lib)
       end do
    end if
    if (associated (pn_exec_name)) then
       cmd%make_executable = .true.
       cmd%exec_name = parse_node_get_string (pn_exec_name)
    end if
  end subroutine cmd_compile_compile

@ %def cmd_compile_compile
@ Command execution.  Generate code, write driver, compile and link.
Do this for all libraries in the list.

If no library names have been given and stored while compiling this
command, we collect all libraries from the current stack and compile
those.

We can compile static libraries (which actually just loads them).  However, we
can't incorporate in a generated executable.
<<Commands: cmd compile: TBP>>=
  procedure :: execute => cmd_compile_execute
<<Commands: procedures>>=
  subroutine cmd_compile_execute (cmd, global)
    class(cmd_compile_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t), dimension(:), allocatable :: libname, libname_static
    integer :: i
    if (allocated (cmd%libname)) then
       allocate (libname (size (cmd%libname)))
       libname = cmd%libname
    else
       call cmd%local%prclib_stack%get_names (libname)
    end if
    if (cmd%make_executable) then
       call get_prclib_static (libname_static)
       do i = 1, size (libname)
          if (any (libname_static == libname(i))) then
             call msg_fatal ("Compile: can't include static library '" &
                  // char (libname(i)) // "'")
          end if
       end do
       call compile_executable (cmd%exec_name, libname, cmd%local)
    else
       do i = 1, size (libname)
          call compile_library (libname(i), cmd%local)
       end do
    end if
  end subroutine cmd_compile_execute
    
@ %def cmd_compile_execute
@
This is the interface to the external procedure which returns the
names of all static libraries which are part of the executable.  (The
default is none.)  The routine must allocate the array.
<<Commands: public>>=
  public :: get_prclib_static
<<Commands: interfaces>>=
  interface
     subroutine get_prclib_static (libname)
       import
       type(string_t), dimension(:), intent(inout), allocatable :: libname
     end subroutine get_prclib_static
  end interface

@ %def get_prclib_static
@ 
\subsubsection{Execute a shell command}
The argument is a string expression.
<<Commands: types>>=
  type, extends (command_t) :: cmd_exec_t
     private
     type(parse_node_t), pointer :: pn_command => null ()
   contains
   <<Commands: cmd exec: TBP>>  
  end type cmd_exec_t

@ %def cmd_exec_t
@ Simply tell the status.
<<Commands: cmd exec: TBP>>=
  procedure :: write => cmd_exec_write
<<Commands: procedures>>=
  subroutine cmd_exec_write (cmd, unit, indent)
    class(cmd_exec_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    if (associated (cmd%pn_command)) then
       write (u, "(1x,A)")  "exec: [command associated]"
    else
       write (u, "(1x,A)")  "exec: [undefined]"       
    end if
  end subroutine cmd_exec_write

@ %def cmd_exec_write
@ Compile the exec command.
<<Commands: cmd exec: TBP>>=
  procedure :: compile => cmd_exec_compile
<<Commands: procedures>>=
  subroutine cmd_exec_compile (cmd, global)
    class(cmd_exec_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_command
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_command => parse_node_get_sub_ptr (pn_arg)
    cmd%pn_command => pn_command
  end subroutine cmd_exec_compile

@ %def cmd_exec_compile
@ Execute the specified shell command.
<<Commands: cmd exec: TBP>>=
  procedure :: execute => cmd_exec_execute
<<Commands: procedures>>=
  subroutine cmd_exec_execute (cmd, global)
    class(cmd_exec_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(string_t) :: command
    logical :: is_known
    integer :: status
    command = eval_string (cmd%pn_command, global%var_list, is_known=is_known)
    if (is_known) then
       if (command /= "") then
          call os_system_call (command, status, verbose=.true.)
          if (status /= 0) then
             write (msg_buffer, "(A,I0)")  "Return code = ", status
             call msg_message ()
             call msg_error ("System command returned with nonzero status code")
          end if
       end if 
    end if
  end subroutine cmd_exec_execute

@ %def cmd_exec_execute
@ 
\subsubsection{Variable declaration}
A variable can have various types.  Hold the definition as an eval
tree.

There are intrinsic variables, user variables, and model variables.
The latter are further divided in independent variables and dependent
variables.

Regarding model variables: When dealing with them, we always look at
two variable lists in parallel.  The global (or local) variable list
contains the user-visible values.  It includes variables that
correspond to variables in the current model's list.  These, in turn,
are pointers to the model's parameter list, so the model is always in
sync, internally.  To keep the global variable list in sync with the
model, the global variables carry the [[is_copy]] property and contain
a separate pointer to the model variable.  (The pointer is reassigned
whenever the model changes.)  Modifying the global variable changes
two values simultaneously: the visible value and the model variable,
via this extra pointer.  After each modification, we update dependent
parameters in the model variable list and re-synchronize the global
variable list (again, using these pointers) with the model variable
this.  In the last step, modifications in the derived parameters
become visible.

When we integrate a process, we capture the current variable list of
the current model in a separate model instance, which is stored in the
process object.  Thus, the model parameters associated to this process
at this time are preserved for the lifetime of the process object.

When we generate or rescan events, we can again capture a local model
variable list in a model instance.  This allows us to reweight event
by event with different parameter sets simultaneously.
<<Commands: types>>=
  type, extends (command_t) :: cmd_var_t
     private
     type(string_t) :: name
     integer :: type = V_NONE
     type(parse_node_t), pointer :: pn_value => null ()
     logical :: is_intrinsic = .false.
     logical :: is_model_var = .false.
   contains
   <<Commands: cmd var: TBP>>
  end type cmd_var_t

@ %def cmd_var_t
@ Output.  We know name, type, and properties, but not the value.
<<Commands: cmd var: TBP>>=
  procedure :: write => cmd_var_write
<<Commands: procedures>>=
  subroutine cmd_var_write (cmd, unit, indent)
    class(cmd_var_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A)", advance="no")  "var: ", char (cmd%name), " ("
    select case (cmd%type)
    case (V_NONE)
       write (u, "(A)", advance="no")  "[unknown]"
    case (V_LOG)
       write (u, "(A)", advance="no")  "logical"
    case (V_INT)
       write (u, "(A)", advance="no")  "int"
    case (V_REAL)
       write (u, "(A)", advance="no")  "real"
    case (V_CMPLX)
       write (u, "(A)", advance="no")  "complex"
    case (V_STR)
       write (u, "(A)", advance="no")  "string"
    case (V_PDG)
       write (u, "(A)", advance="no")  "alias"
    end select
    if (cmd%is_intrinsic) then
       write (u, "(A)", advance="no")  ", intrinsic"
    end if
    if (cmd%is_model_var) then
       write (u, "(A)", advance="no")  ", model"
    end if
    write (u, "(A)")  ")"
  end subroutine cmd_var_write

@ %def cmd_var_write
@ Compile the lhs and determine the variable name and type.  Check whether
this variable can be created or modified as requested, and append the value to
the variable list, if appropriate.  The value is initially undefined.
The rhs is assigned to a pointer, to be compiled and evaluated when the
command is executed.
<<Commands: cmd var: TBP>>=
  procedure :: compile => cmd_var_compile
<<Commands: procedures>>=
  subroutine cmd_var_compile (cmd, global)
    class(cmd_var_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_var, pn_name
    type(parse_node_t), pointer :: pn_result, pn_proc
    type(string_t) :: var_name
    type(var_list_t), pointer :: model_vars
    integer :: type
    logical :: new
    pn_result => null ()
    new = .false.
    select case (char (parse_node_get_rule_key (cmd%pn)))
    case ("cmd_log_decl");    type = V_LOG
       pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
       if (.not. associated (pn_var)) then   ! handle masked syntax error 
          cmd%type = V_NONE; return
       end if
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       new = .true.
    case ("cmd_log");         type = V_LOG
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
    case ("cmd_int");         type = V_INT
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_real");        type = V_REAL
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_complex");       type = V_CMPLX
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_num");         type = V_NONE
       pn_name => parse_node_get_sub_ptr (cmd%pn)
    case ("cmd_string_decl"); type = V_STR
       pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
       if (.not. associated (pn_var)) then   ! handle masked syntax error 
          cmd%type = V_NONE; return
       end if
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       new = .true.
    case ("cmd_string");      type = V_STR
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
    case ("cmd_alias");       type = V_PDG
       pn_name => parse_node_get_sub_ptr (cmd%pn, 2)
       new = .true.
    case ("cmd_result");      type = V_REAL
       pn_name => parse_node_get_sub_ptr (cmd%pn)
       pn_result => parse_node_get_sub_ptr (pn_name)
       pn_proc => parse_node_get_next_ptr (pn_result)
    case default
       call parse_node_mismatch &
            ("logical|int|real|complex|?|$|alias|var_name", cmd%pn)  ! $
    end select
    if (.not. associated (pn_name)) then   ! handle masked syntax error 
       cmd%type = V_NONE; return
    end if
    if (.not. associated (pn_result)) then
       var_name = parse_node_get_string (pn_name)
    else
       var_name = parse_node_get_key (pn_result) &
            // "(" // parse_node_get_string (pn_proc) // ")"
    end if
    select case (type)
    case (V_LOG);  var_name = "?" // var_name
    case (V_STR);  var_name = "$" // var_name    ! $
    end select
    if (associated (global%model)) then
       model_vars => global%model%get_var_list_ptr ()
    else
       model_vars => null ()
    end if
    call var_list_check_observable (global%var_list, var_name, type)
    call var_list_check_result_var (global%var_list, var_name, type)
    call var_list_check_user_var (global%var_list, var_name, type, new)
    cmd%name = var_name
    cmd%pn_value => parse_node_get_next_ptr (pn_name, 2)
    if (global%var_list%contains (cmd%name, follow_link = .false.)) then
       ! local variable
       cmd%is_intrinsic = &
            global%var_list%is_intrinsic (cmd%name, follow_link = .false.)
       cmd%type = &
            global%var_list%get_type (cmd%name, follow_link = .false.)
    else
       if (new)  cmd%type = type
       if (global%var_list%contains (cmd%name, follow_link = .true.)) then
          ! global variable
          cmd%is_intrinsic = &
               global%var_list%is_intrinsic (cmd%name, follow_link = .true.)
          if (cmd%type == V_NONE) then
             cmd%type = &
                  global%var_list%get_type (cmd%name, follow_link = .true.)
          end if
       else if (associated (model_vars)) then  ! check model variable
          cmd%is_model_var = &
               model_vars%contains (cmd%name)
          if (cmd%type == V_NONE) then
             cmd%type = &
                  model_vars%get_type (cmd%name)
          end if
       end if
       if (cmd%type == V_NONE) then
          call msg_fatal ("Variable '" // char (cmd%name) // "' " &
               // "set without declaration")
          cmd%type = V_NONE;  return
       end if
       if (cmd%is_model_var) then
          if (new) then
             call msg_fatal ("Model variable '" // char (cmd%name) // "' " &
                  // "redeclared")
          else if (model_vars%is_locked (cmd%name)) then
             call msg_fatal ("Model variable '" // char (cmd%name) // "' " &
                  // "is locked")
          end if
       else
          select case (cmd%type)
          case (V_LOG)
             call var_list_append_log (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_INT)
             call var_list_append_int (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_REAL)
             call var_list_append_real (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_CMPLX)
             call var_list_append_cmplx (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_PDG)
             call var_list_append_pdg_array (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          case (V_STR)
             call var_list_append_string (global%var_list, cmd%name, &
                  intrinsic=cmd%is_intrinsic, user=.true.)
          end select
       end if
    end if
  end subroutine cmd_var_compile

@ %def cmd_var_compile
@ Execute.  Evaluate the definition and assign the variable value.
If the variable is a model variable, take a snapshot of the model if necessary
and set the variable in the local model.
<<Commands: cmd var: TBP>>=
  procedure :: execute => cmd_var_execute
<<Commands: procedures>>=
  subroutine cmd_var_execute (cmd, global)
    class(cmd_var_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default) :: rval
    logical :: is_known, pacified
    var_list => global%get_var_list_ptr ()
    if (cmd%is_model_var) then
       pacified = var_list%get_lval (var_str ("?pacify"))     
       rval = eval_real (cmd%pn_value, var_list, is_known=is_known)
       call global%model_set_real &
            (cmd%name, rval, verbose=.true., pacified=pacified)
    else if (cmd%type /= V_NONE) then
       call cmd%set_value (var_list, verbose=.true.)
    end if
  end subroutine cmd_var_execute

@ %def cmd_var_execute
@ Copy the value to the variable list, where the variable should already exist.
<<Commands: cmd var: TBP>>=
  procedure :: set_value => cmd_var_set_value
<<Commands: procedures>>=
  subroutine cmd_var_set_value (var, var_list, verbose, model_name)
    class(cmd_var_t), intent(inout) :: var
    type(var_list_t), intent(inout), target :: var_list
    logical, intent(in), optional :: verbose
    type(string_t), intent(in), optional :: model_name
    logical :: lval, pacified
    integer :: ival
    real(default) :: rval
    complex(default) :: cval
    type(pdg_array_t) :: aval
    type(string_t) :: sval
    logical :: is_known
    pacified = var_list%get_lval (var_str ("?pacify"))     
    select case (var%type)
    case (V_LOG)
       lval = eval_log (var%pn_value, var_list, is_known=is_known)
       call var_list_set_log (var_list, var%name, &
            lval, is_known, verbose=verbose, model_name=model_name)
    case (V_INT)
       ival = eval_int (var%pn_value, var_list, is_known=is_known)
       call var_list_set_int (var_list, var%name, &
            ival, is_known, verbose=verbose, model_name=model_name)
    case (V_REAL)
       rval = eval_real (var%pn_value, var_list, is_known=is_known)
       call var_list_set_real (var_list, var%name, &
            rval, is_known, verbose=verbose, &
            model_name=model_name, pacified = pacified)
    case (V_CMPLX)
       cval = eval_cmplx (var%pn_value, var_list, is_known=is_known)
       call var_list_set_cmplx (var_list, var%name, &
            cval, is_known, verbose=verbose, &
            model_name=model_name, pacified = pacified)
    case (V_PDG)
       aval = eval_pdg_array (var%pn_value, var_list, is_known=is_known)
       call var_list_set_pdg_array (var_list, var%name, &
            aval, is_known, verbose=verbose, model_name=model_name)
    case (V_STR)
       sval = eval_string (var%pn_value, var_list, is_known=is_known)
       call var_list_set_string (var_list, var%name, &
            sval, is_known, verbose=verbose, model_name=model_name)
    end select
  end subroutine cmd_var_set_value
  
@ %def cmd_var_set_value
@ 
\subsubsection{SLHA}
Read a SLHA (SUSY Les Houches Accord) file to fill the appropriate
model parameters.  We do not access the current variable record, but
directly work on the appropriate SUSY model, which is loaded if
necessary.

We may be in read or write mode.  In the latter case, we may write
just input parameters, or the complete spectrum, or the spectrum with
all decays.
<<Commands: types>>=
  type, extends (command_t) :: cmd_slha_t
     private
     type(string_t) :: file
     logical :: write_mode = .false.
   contains
   <<Commands: cmd slha: TBP>>  
  end type cmd_slha_t

@ %def cmd_slha_t
@ Output.
<<Commands: cmd slha: TBP>>=
  procedure :: write => cmd_slha_write
<<Commands: procedures>>=
  subroutine cmd_slha_write (cmd, unit, indent)
    class(cmd_slha_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "slha: file name  = ", char (cmd%file)
    write (u, "(1x,A,L1)") "slha: write mode = ", cmd%write_mode
  end subroutine cmd_slha_write

@ %def cmd_slha_write
@ Compile.  Read the filename and store it.
<<Commands: cmd slha: TBP>>=
  procedure :: compile => cmd_slha_compile
<<Commands: procedures>>=
  subroutine cmd_slha_compile (cmd, global)
    class(cmd_slha_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_key, pn_arg, pn_file
    pn_key => parse_node_get_sub_ptr (cmd%pn)
    pn_arg => parse_node_get_next_ptr (pn_key)
    pn_file => parse_node_get_sub_ptr (pn_arg)
    call cmd%compile_options (global)
    cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
    select case (char (parse_node_get_key (pn_key)))
    case ("read_slha")
       cmd%write_mode = .false.
    case ("write_slha")
       cmd%write_mode = .true.
    case default
       call parse_node_mismatch ("read_slha|write_slha",  cmd%pn)
    end select
    cmd%file = parse_node_get_string (pn_file)
  end subroutine cmd_slha_compile

@ %def cmd_slha_compile
@ Execute.  Read or write the specified SLHA file.  Behind the scenes,
this will first read the WHIZARD model file, then read the SLHA file
and assign the SLHA parameters as far as determined by
[[dispatch_slha]].  Finally, the global variables are synchronized
with the model.  This is similar to executing [[cmd_model]].
<<Commands: cmd slha: TBP>>=
  procedure :: execute => cmd_slha_execute
<<Commands: procedures>>=
  subroutine cmd_slha_execute (cmd, global)
    class(cmd_slha_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    logical :: input, spectrum, decays
    type(model_t), pointer :: model
    if (cmd%write_mode) then
       input = .true.
       spectrum = .false.
       decays = .false.
       if (.not. associated (cmd%local%model)) then
          call msg_fatal ("SLHA: local model not associated")
          return
       end if
       call slha_write_file &
            (cmd%file, cmd%local%model, &
             input = input, spectrum = spectrum, decays = decays)
    else
       if (.not. associated (global%model)) then
          call msg_fatal ("SLHA: global model not associated")
          return
       end if
       call dispatch_slha (cmd%local, &
            input = input, spectrum = spectrum, decays = decays)
       call global%ensure_model_copy ()
       call slha_read_file &
            (cmd%file, cmd%local%os_data, global%model, &
             input = input, spectrum = spectrum, decays = decays)
    end if
  end subroutine cmd_slha_execute

@ %def cmd_slha_execute
@ 
\subsubsection{Show values}
This command shows the current values of variables or other objects,
in a suitably condensed form.
<<Commands: types>>=
  type, extends (command_t) :: cmd_show_t
     private
     type(string_t), dimension(:), allocatable :: name
   contains
   <<Commands: cmd show: TBP>>
  end type cmd_show_t

@ %def cmd_show_t
@ Output: list the object names, not values.
<<Commands: cmd show: TBP>>=
  procedure :: write => cmd_show_write
<<Commands: procedures>>=
  subroutine cmd_show_write (cmd, unit, indent)
    class(cmd_show_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "show: "  
    if (allocated (cmd%name)) then
       do i = 1, size (cmd%name)
          write (u, "(1x,A)", advance="no")  char (cmd%name(i))
       end do
       write (u, *)
    else
       write (u, "(5x,A)")  "[undefined]"
    end if
  end subroutine cmd_show_write

@ %def cmd_show_write
@ Compile.  Allocate an array which is filled with the names of the
variables to show.
<<Commands: cmd show: TBP>>=
  procedure :: compile => cmd_show_compile
<<Commands: procedures>>=
  subroutine cmd_show_compile (cmd, global)
    class(cmd_show_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_var, pn_prefix, pn_name
    type(string_t) :: key
    integer :: i, n_args
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       select case (char (parse_node_get_rule_key (pn_arg)))
       case ("show_arg")
          cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
       case default
          cmd%pn_opt => pn_arg
          pn_arg => null ()
       end select
    end if
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_args = parse_node_get_n_sub (pn_arg)
       allocate (cmd%name (n_args))
       pn_var => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_var))
          i = i + 1
          select case (char (parse_node_get_rule_key (pn_var)))
          case ("model", "library", "beams", "iterations", &
                "cuts", "weight", "int", "real", "complex", &
                "scale", "factorization_scale", "renormalization_scale", &
                "selection", "reweight", "analysis", "pdg", &
                "stable", "unstable", "polarized", "unpolarized", &
                "results", "expect", "intrinsic", "string", "logical")
             cmd%name(i) = parse_node_get_key (pn_var)
          case ("result_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             if (associated (pn_name)) then
                cmd%name(i) = parse_node_get_key (pn_prefix) &
                     // "(" // parse_node_get_string (pn_name) // ")"
             else
                cmd%name(i) = parse_node_get_key (pn_prefix)
             end if
          case ("log_var", "string_var", "alias_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             key = parse_node_get_key (pn_prefix)
             if (associated (pn_name)) then
                select case (char (parse_node_get_rule_key (pn_name)))
                case ("var_name")
                   select case (char (key))
                   case ("?", "$")  ! $ sign
                      cmd%name(i) = key // parse_node_get_string (pn_name)
                   case ("alias")
                      cmd%name(i) = parse_node_get_string (pn_name)
                   end select
                case default
                   call parse_node_mismatch &
                        ("var_name",  pn_name)
                end select
             else
                cmd%name(i) = key
             end if
          case default
             cmd%name(i) = parse_node_get_string (pn_var)
          end select
          pn_var => parse_node_get_next_ptr (pn_var)
       end do
    else
       allocate (cmd%name (0))
    end if
  end subroutine cmd_show_compile

@ %def cmd_show_compile
@ Execute.  Scan the list of objects to show.
<<Commands: parameters>>=
  integer, parameter, public :: SHOW_BUFFER_SIZE = 4096
<<Commands: cmd show: TBP>>=
  procedure :: execute => cmd_show_execute
<<Commands: procedures>>=    
  subroutine cmd_show_execute (cmd, global)
    class(cmd_show_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list, model_vars
    type(model_t), pointer :: model
    type(string_t) :: name
    integer :: n, pdg
    type(flavor_t) :: flv
    type(process_library_t), pointer :: prc_lib
    type(process_t), pointer :: process
    logical :: pacified
    character(SHOW_BUFFER_SIZE) :: buffer
    integer :: i, j, u, u_log, u_out
    u = free_unit ()
    var_list => cmd%local%var_list
    if (associated (cmd%local%model)) then
       model_vars => cmd%local%model%get_var_list_ptr ()
    else
       model_vars => null ()
    end if
    pacified = var_list%get_lval (var_str ("?pacify"))
    open (u, status = "scratch", action = "readwrite")
    if (associated (cmd%local%model)) then
       name = cmd%local%model%get_name ()
    end if
    if (size (cmd%name) == 0) then
       if (associated (model_vars)) then
          call var_list_write (model_vars, model_name = name, &
               unit = u, pacified = pacified, follow_link = .false.)
       end if
       call var_list_write (var_list, unit = u, pacified = pacified)
    else
       do i = 1, size (cmd%name)
          select case (char (cmd%name(i)))
          case ("model")
             if (associated (cmd%local%model)) then
                call cmd%local%model%show (u)
             else
                write (u, "(A)")  "Model: [undefined]"
             end if
          case ("library")
             if (associated (cmd%local%prclib)) then
                call cmd%local%prclib%show (u)
             else
                write (u, "(A)")  "Process library: [undefined]"
             end if
          case ("beams")
             call cmd%local%show_beams (u)
          case ("iterations")
             call cmd%local%it_list%write (u)
          case ("results")
             call cmd%local%process_stack%show (u)
          case ("stable")
             call cmd%local%model%show_stable (u)
          case ("polarized")
             call cmd%local%model%show_polarized (u)
          case ("unpolarized")
             call cmd%local%model%show_unpolarized (u)
          case ("unstable")
             model => cmd%local%model
             call model%show_unstable (u)
             n = model%get_n_field ()
             do j = 1, n
                pdg = model%get_pdg (j)
                call flv%init (pdg, model)
                if (.not. flv%is_stable ()) &
                     call show_unstable (cmd%local, pdg, u)
                if (flv%has_antiparticle ()) then
                   associate (anti => flv%anti ())
                     if (.not. anti%is_stable ()) &
                          call show_unstable (cmd%local, -pdg, u)
                   end associate
                end if
             end do
          case ("cuts", "weight", "scale", &
               "factorization_scale", "renormalization_scale", &
               "selection", "reweight", "analysis")
             call cmd%local%pn%show (cmd%name(i), u)
          case ("expect")
             call expect_summary (force = .true.)
          case ("intrinsic")
             call var_list_write (var_list, &
                  intrinsic=.true., unit=u, pacified = pacified)
          case ("logical")
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_LOG, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, &
                  only_type=V_LOG, unit=u, pacified = pacified)
          case ("int")
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_INT, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, only_type=V_INT, &
                  unit=u, pacified = pacified)
          case ("real")
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_REAL, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, only_type=V_REAL, &
                  unit=u, pacified = pacified)
          case ("complex")
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_CMPLX, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, only_type=V_CMPLX, &
                  unit=u, pacified = pacified)
          case ("pdg")
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_PDG, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, only_type=V_PDG, &
                  unit=u, pacified = pacified)
          case ("string") 
             if (associated (model_vars)) then
                call var_list_write (model_vars, only_type=V_STR, &
                     model_name = name, unit=u, pacified = pacified, &
                     follow_link=.false.)
             end if
             call var_list_write (var_list, only_type=V_STR, &
                  unit=u, pacified = pacified)
          case default
             if (analysis_exists (cmd%name(i))) then
                call analysis_write (cmd%name(i), u)
             else if (cmd%local%process_stack%exists (cmd%name(i))) then
                process => cmd%local%process_stack%get_process_ptr (cmd%name(i))
                call process%show (u)
             else if (associated (cmd%local%prclib_stack%get_library_ptr &
                  (cmd%name(i)))) then
                prc_lib => cmd%local%prclib_stack%get_library_ptr (cmd%name(i))
                call prc_lib%show (u)
             else if (associated (model_vars)) then
                if (model_vars%contains (cmd%name(i), follow_link=.false.)) then
                   call var_list_write_var (model_vars, cmd%name(i), &
                        unit = u, model_name = name, pacified = pacified)
                else if (var_list%contains (cmd%name(i))) then
                   call var_list_write_var (var_list, cmd%name(i), &
                        unit = u, pacified = pacified)
                else
                   call msg_error ("show: object '" // char (cmd%name(i)) &
                        // "' not found")
                end if
             else if (var_list%contains (cmd%name(i))) then
                call var_list_write_var (var_list, cmd%name(i), &
                     unit = u, pacified = pacified)
             else
                call msg_error ("show: object '" // char (cmd%name(i)) &
                     // "' not found")
             end if
          end select
       end do
    end if
    rewind (u)
    u_log = logfile_unit ()
    u_out = given_output_unit ()
    do
       read (u, "(A)", end = 1)  buffer
       if (u_log > 0)  write (u_log, "(A)")  trim (buffer)
       if (u_out > 0)  write (u_out, "(A)")  trim (buffer)
    end do
1   close (u)
    if (u_log > 0)  flush (u_log)
    if (u_out > 0)  flush (u_out)
  end subroutine cmd_show_execute

@ %def cmd_show_execute
@
\subsubsection{Clear values}
This command clears the current values of variables or other objects,
where this makes sense.  It parallels the [[show]] command.  The
objects are cleared, but not deleted.
<<Commands: types>>=
  type, extends (command_t) :: cmd_clear_t
     private
     type(string_t), dimension(:), allocatable :: name
   contains
   <<Commands: cmd clear: TBP>>
  end type cmd_clear_t
     
@ %def cmd_clear_t
@ Output: list the names of the objects to be cleared.
<<Commands: cmd clear: TBP>>=
  procedure :: write => cmd_clear_write
<<Commands: procedures>>=
  subroutine cmd_clear_write (cmd, unit, indent)
    class(cmd_clear_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "clear: "  
    if (allocated (cmd%name)) then
       do i = 1, size (cmd%name)
          write (u, "(1x,A)", advance="no")  char (cmd%name(i))
       end do
       write (u, *)
    else
       write (u, "(5x,A)")  "[undefined]"
    end if
  end subroutine cmd_clear_write

@ %def cmd_clear_write
@ Compile.  Allocate an array which is filled with the names of the
objects to be cleared.

Note: there is currently no need to account for options, but we
prepare for that possibility.
<<Commands: cmd clear: TBP>>=
  procedure :: compile => cmd_clear_compile
<<Commands: procedures>>=
  subroutine cmd_clear_compile (cmd, global)
    class(cmd_clear_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_var, pn_prefix, pn_name
    type(string_t) :: key
    integer :: i, n_args
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       select case (char (parse_node_get_rule_key (pn_arg)))
       case ("clear_arg")
          cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
       case default
          cmd%pn_opt => pn_arg
          pn_arg => null ()
       end select
    end if
    call cmd%compile_options (global)
    if (associated (pn_arg)) then
       n_args = parse_node_get_n_sub (pn_arg)
       allocate (cmd%name (n_args))
       pn_var => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_var))
          i = i + 1
          select case (char (parse_node_get_rule_key (pn_var)))
          case ("beams", "iterations", &
                "cuts", "weight", &
                "scale", "factorization_scale", "renormalization_scale", &
                "selection", "reweight", "analysis", &
                "unstable", "polarized", &
                "expect")
             cmd%name(i) = parse_node_get_key (pn_var)
          case ("log_var", "string_var")
             pn_prefix => parse_node_get_sub_ptr (pn_var)
             pn_name => parse_node_get_next_ptr (pn_prefix)
             key = parse_node_get_key (pn_prefix)
             if (associated (pn_name)) then
                select case (char (parse_node_get_rule_key (pn_name)))
                case ("var_name")
                   select case (char (key))
                   case ("?", "$")  ! $ sign
                      cmd%name(i) = key // parse_node_get_string (pn_name)
                   end select
                case default
                   call parse_node_mismatch &
                        ("var_name",  pn_name)
                end select
             else
                cmd%name(i) = key
             end if
          case default
             cmd%name(i) = parse_node_get_string (pn_var)
          end select
          pn_var => parse_node_get_next_ptr (pn_var)
       end do
    else
       allocate (cmd%name (0))
    end if
  end subroutine cmd_clear_compile

@ %def cmd_clear_compile
@ Execute.  Scan the list of objects to clear.

Objects that can be shown but not cleared: model, library, results
<<Commands: cmd clear: TBP>>=
  procedure :: execute => cmd_clear_execute
<<Commands: procedures>>=    
  subroutine cmd_clear_execute (cmd, global)
    class(cmd_clear_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    integer :: i
    logical :: success
    type(var_list_t), pointer :: model_vars
    if (size (cmd%name) == 0) then
       call msg_warning ("clear: no object specified")
    else
       do i = 1, size (cmd%name)
          success = .true.
          select case (char (cmd%name(i)))
          case ("beams")
             call cmd%local%clear_beams ()
          case ("iterations")
             call cmd%local%it_list%clear ()
          case ("polarized")
             call cmd%local%model%clear_polarized ()
          case ("unstable")
             call cmd%local%model%clear_unstable ()
          case ("cuts", "weight", "scale", &
               "factorization_scale", "renormalization_scale", &
               "selection", "reweight", "analysis")
             call cmd%local%pn%clear (cmd%name(i))
          case ("expect")
             call expect_clear ()
          case default
             if (analysis_exists (cmd%name(i))) then
                call analysis_clear (cmd%name(i))
             else if (cmd%local%var_list%contains (cmd%name(i))) then
                if (.not. cmd%local%var_list%is_locked (cmd%name(i))) then
                   call cmd%local%var_list%unset (cmd%name(i))
                else
                   call msg_error ("clear: variable '" // char (cmd%name(i)) &
                        // "' is locked and can't be cleared")
                   success = .false.
                end if
             else if (associated (cmd%local%model)) then
                model_vars => cmd%local%model%get_var_list_ptr ()
                if (model_vars%contains (cmd%name(i), follow_link=.false.)) then
                   call msg_error ("clear: variable '" // char (cmd%name(i)) &
                        // "' is a model variable and can't be cleared")
                else
                   call msg_error ("clear: object '" // char (cmd%name(i)) &
                        // "' not found")
                end if
                success = .false.
             else
                call msg_error ("clear: object '" // char (cmd%name(i)) &
                     // "' not found")
                success = .false.
             end if
          end select
          if (success)  call msg_message ("cleared: " // char (cmd%name(i)))
       end do
    end if
  end subroutine cmd_clear_execute

@ %def cmd_clear_execute
@ 
\subsubsection{Compare values of variables to expectation}
The implementation is similar to the [[show]] command.  There are just
two arguments: two values that should be compared.  For providing
local values for the numerical tolerance, the command has a local
argument list.

If the expectation fails, an error condition is recorded.
<<Commands: types>>=
  type, extends (command_t) :: cmd_expect_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd expect: TBP>>  
  end type cmd_expect_t

@ %def cmd_expect_t
@ Simply tell the status.
<<Commands: cmd expect: TBP>>=
  procedure :: write => cmd_expect_write
<<Commands: procedures>>=
  subroutine cmd_expect_write (cmd, unit, indent)
    class(cmd_expect_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    if (associated (cmd%pn_lexpr)) then
       write (u, "(1x,A)")  "expect: [expression associated]"
    else
       write (u, "(1x,A)")  "expect: [undefined]"       
    end if
  end subroutine cmd_expect_write

@ %def cmd_expect_write
@ Compile.  This merely assigns the parse node, the actual compilation is done
at execution.  This is necessary because the origin of variables
(local/global) may change during execution.
<<Commands: cmd expect: TBP>>=
  procedure :: compile => cmd_expect_compile
<<Commands: procedures>>=
  subroutine cmd_expect_compile (cmd, global)
    class(cmd_expect_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_arg)
    cmd%pn_lexpr => parse_node_get_sub_ptr (pn_arg)
    call cmd%compile_options (global)
  end subroutine cmd_expect_compile

@ %def cmd_expect_compile
@ Execute.  Evaluate both arguments, print them and their difference
(if numerical), and whether they agree.  Record the result.
<<Commands: cmd expect: TBP>>=
  procedure :: execute => cmd_expect_execute
<<Commands: procedures>>=    
  subroutine cmd_expect_execute (cmd, global)
    class(cmd_expect_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    logical :: success, is_known
    var_list => cmd%local%get_var_list_ptr ()
    success = eval_log (cmd%pn_lexpr, var_list, is_known=is_known)
    if (is_known) then
       if (success) then
          call msg_message ("expect: success")
       else
          call msg_error ("expect: failure")
       end if
    else
       call msg_error ("expect: undefined result")
       success = .false.
    end if
    call expect_record (success)
  end subroutine cmd_expect_execute

@ %def cmd_expect_execute
@ 
\subsubsection{Beams}
The beam command includes both beam and structure-function
definition.
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_t
     private
     integer :: n_in = 0
     type(parse_node_p), dimension(:), allocatable :: pn_pdg
     integer :: n_sf_record = 0
     integer, dimension(:), allocatable :: n_entry
     type(parse_node_p), dimension(:,:), allocatable :: pn_sf_entry
   contains
   <<Commands: cmd beams: TBP>>
  end type cmd_beams_t

@ %def cmd_beams_t
@ Output.  The particle expressions are not resolved.
<<Commands: cmd beams: TBP>>=
  procedure :: write => cmd_beams_write
<<Commands: procedures>>=
  subroutine cmd_beams_write (cmd, unit, indent)
    class(cmd_beams_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams: [undefined]"
    end select
    if (allocated (cmd%n_entry)) then
       if (cmd%n_sf_record > 0) then
          write (u, "(1x,A,99(1x,I0))")  "structure function entries:", &
               cmd%n_entry
       end if
    end if
  end subroutine cmd_beams_write

@ %def cmd_beams_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams: TBP>>=
  procedure :: compile => cmd_beams_compile
<<Commands: procedures>>=
  subroutine cmd_beams_compile (cmd, global)
    class(cmd_beams_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_beam_def, pn_beam_spec
    type(parse_node_t), pointer :: pn_beam_list
    type(parse_node_t), pointer :: pn_codes
    type(parse_node_t), pointer :: pn_strfun_seq, pn_strfun_pair
    type(parse_node_t), pointer :: pn_strfun_def
    integer :: i
    pn_beam_def => parse_node_get_sub_ptr (cmd%pn, 3)
    pn_beam_spec => parse_node_get_sub_ptr (pn_beam_def)
    pn_strfun_seq => parse_node_get_next_ptr (pn_beam_spec)
    pn_beam_list => parse_node_get_sub_ptr (pn_beam_spec)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_beam_list)
    allocate (cmd%pn_pdg (cmd%n_in))
    pn_codes => parse_node_get_sub_ptr (pn_beam_list)
    do i = 1, cmd%n_in
       cmd%pn_pdg(i)%ptr => pn_codes
       pn_codes => parse_node_get_next_ptr (pn_codes)
    end do
    if (associated (pn_strfun_seq)) then
       cmd%n_sf_record = parse_node_get_n_sub (pn_beam_def) - 1
       allocate (cmd%n_entry (cmd%n_sf_record), source = 1)
       allocate (cmd%pn_sf_entry (2, cmd%n_sf_record))
       do i = 1, cmd%n_sf_record
          pn_strfun_pair => parse_node_get_sub_ptr (pn_strfun_seq, 2)
          pn_strfun_def => parse_node_get_sub_ptr (pn_strfun_pair)
          cmd%pn_sf_entry(1,i)%ptr => pn_strfun_def
          pn_strfun_def => parse_node_get_next_ptr (pn_strfun_def)
          cmd%pn_sf_entry(2,i)%ptr => pn_strfun_def
          if (associated (pn_strfun_def))  cmd%n_entry(i) = 2
          pn_strfun_seq => parse_node_get_next_ptr (pn_strfun_seq)
       end do
    else
       allocate (cmd%n_entry (0))
       allocate (cmd%pn_sf_entry (0, 0))
    end if
  end subroutine cmd_beams_compile

@ %def cmd_beams_compile
@ Command execution: Determine beam particles and structure-function
names, if any.  The results are stored in the [[beam_structure]]
component of the [[global]] data block.
<<Commands: cmd beams: TBP>>=
  procedure :: execute => cmd_beams_execute
<<Commands: procedures>>=
  subroutine cmd_beams_execute (cmd, global)
    class(cmd_beams_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(pdg_array_t) :: pdg_array
    integer, dimension(:), allocatable :: pdg
    type(flavor_t), dimension(:), allocatable :: flv
    type(parse_node_t), pointer :: pn_key
    type(string_t) :: sf_name
    integer :: i, j
    call lhapdf_global_reset ()
    var_list => cmd%local%get_var_list_ptr ()
    allocate (flv (cmd%n_in))
    do i = 1, cmd%n_in
       pdg_array = eval_pdg_array (cmd%pn_pdg(i)%ptr, var_list)
       pdg = pdg_array
       select case (size (pdg))
       case (1)
          call flv(i)%init ( pdg(1), cmd%local%model)
       case default
          call msg_fatal ("Beams: beam particles must be unique")
       end select
    end do
    select case (cmd%n_in)
    case (1)
       if (cmd%n_sf_record > 0) then
          call msg_fatal ("Beam setup: no structure functions allowed &
               &for decay")
       end if
       call global%beam_structure%init_sf (flv%get_name ())
    case (2)
       call global%beam_structure%init_sf (flv%get_name (), cmd%n_entry)
       do i = 1, cmd%n_sf_record
          do j = 1, cmd%n_entry(i)
             pn_key => parse_node_get_sub_ptr (cmd%pn_sf_entry(j,i)%ptr)
             sf_name = parse_node_get_key (pn_key)
             call global%beam_structure%set_sf (i, j, sf_name)
          end do
       end do
    end select
  end subroutine cmd_beams_execute

@ %def cmd_beams_execute 
@ 
\subsubsection{Density matrices for beam polarization}
For holding beam polarization, we define a notation and a data
structure for sparse matrices.  The entries (and the index
expressions) are numerical expressions, so we use evaluation trees.

Each entry in the sparse matrix is an n-tuple of expressions.  The first
tuple elements represent index values, the last one is an arbitrary
(complex) number.  Absent expressions are replaced by default-value rules.

Note: Here, and in some other commands, we would like to store an evaluation
tree, not just a parse node pointer.  However, the current expression handler
wants all variables defined, so the evaluation tree can only be built by
[[evaluate]], i.e., compiled just-in-time and evaluated immediately.
<<Commands: types>>=
  type :: sentry_expr_t
     type(parse_node_p), dimension(:), allocatable :: expr
   contains
   <<Commands: sentry expr: TBP>>
  end type sentry_expr_t

@ %def sentry_expr_t
@ Compile parse nodes into evaluation trees.
<<Commands: sentry expr: TBP>>=
  procedure :: compile => sentry_expr_compile
<<Commands: procedures>>=
  subroutine sentry_expr_compile (sentry, pn)
    class(sentry_expr_t), intent(out) :: sentry
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_expr, pn_extra
    integer :: n_expr, i
    n_expr = parse_node_get_n_sub (pn)
    allocate (sentry%expr (n_expr))
    if (n_expr > 0) then
       i = 0
       pn_expr => parse_node_get_sub_ptr (pn)
       pn_extra => parse_node_get_next_ptr (pn_expr)
       do i = 1, n_expr
          sentry%expr(i)%ptr => pn_expr
          if (associated (pn_extra)) then
             pn_expr => parse_node_get_sub_ptr (pn_extra, 2)
             pn_extra => parse_node_get_next_ptr (pn_extra)
          end if
       end do
    end if
  end subroutine sentry_expr_compile
    
@ %def sentry_expr_compile
@ Evaluate the expressions and return an index array of predefined
length together with a complex value.  If the value (as the last expression)
is undefined, set it to unity.  If index values are undefined, repeat
the previous index value.
<<Commands: sentry expr: TBP>>=
  procedure :: evaluate => sentry_expr_evaluate
<<Commands: procedures>>=
  subroutine sentry_expr_evaluate (sentry, index, value, global)
    class(sentry_expr_t), intent(inout) :: sentry
    integer, dimension(:), intent(out) :: index
    complex(default), intent(out) :: value
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    integer :: i, n_expr, n_index
    type(eval_tree_t) :: eval_tree
    var_list => global%get_var_list_ptr ()
    n_expr = size (sentry%expr) 
    n_index = size (index)
    if (n_expr <= n_index + 1) then
       do i = 1, min (n_expr, n_index)
          associate (expr => sentry%expr(i))
            call eval_tree%init_expr (expr%ptr, var_list)
            call eval_tree%evaluate ()
            if (eval_tree%is_known ()) then
               index(i) = eval_tree%get_int ()
            else
               call msg_fatal ("Evaluating density matrix: undefined index")
            end if
          end associate
       end do
       do i = n_expr + 1, n_index
          index(i) = index(n_expr)
       end do
       if (n_expr == n_index + 1) then
          associate (expr => sentry%expr(n_expr))
            call eval_tree%init_expr (expr%ptr, var_list)
            call eval_tree%evaluate ()
            if (eval_tree%is_known ()) then
               value = eval_tree%get_cmplx ()
            else
               call msg_fatal ("Evaluating density matrix: undefined index")
            end if
            call eval_tree%final ()
          end associate
       else
          value = 1
       end if
    else
       call msg_fatal ("Evaluating density matrix: index expression too long")
    end if
  end subroutine sentry_expr_evaluate

@ %def sentry_expr_evaluate
@ The sparse matrix itself consists of an arbitrary number of entries.
<<Commands: types>>=
  type :: smatrix_expr_t
     type(sentry_expr_t), dimension(:), allocatable :: entry
   contains
   <<Commands: smatrix expr: TBP>>
  end type smatrix_expr_t
  
@ %def smatrix_expr_t
@ Compile: assign sub-nodes to sentry-expressions and compile those.
<<Commands: smatrix expr: TBP>>=
  procedure :: compile => smatrix_expr_compile
<<Commands: procedures>>=
  subroutine smatrix_expr_compile (smatrix_expr, pn)
    class(smatrix_expr_t), intent(out) :: smatrix_expr
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_arg, pn_entry
    integer :: n_entry, i
    pn_arg => parse_node_get_sub_ptr (pn, 2)
    if (associated (pn_arg)) then
       n_entry = parse_node_get_n_sub (pn_arg)
       allocate (smatrix_expr%entry (n_entry))
       pn_entry => parse_node_get_sub_ptr (pn_arg)
       do i = 1, n_entry
          call smatrix_expr%entry(i)%compile (pn_entry)
          pn_entry => parse_node_get_next_ptr (pn_entry)
       end do
    else
       allocate (smatrix_expr%entry (0))
    end if
  end subroutine smatrix_expr_compile

@ %def smatrix_expr_compile
@ Evaluate the entries and build a new [[smatrix]] object, which
contains just the numerical results.
<<Commands: smatrix expr: TBP>>=
  procedure :: evaluate => smatrix_expr_evaluate
<<Commands: procedures>>=
  subroutine smatrix_expr_evaluate (smatrix_expr, smatrix, global)
    class(smatrix_expr_t), intent(inout) :: smatrix_expr
    type(smatrix_t), intent(out) :: smatrix
    type(rt_data_t), intent(in), target :: global
    integer, dimension(2) :: idx
    complex(default) :: value
    integer :: i, n_entry
    n_entry = size (smatrix_expr%entry)
    call smatrix%init (2, n_entry)
    do i = 1, n_entry
       call smatrix_expr%entry(i)%evaluate (idx, value, global)
       call smatrix%set_entry (i, idx, value)
    end do
  end subroutine smatrix_expr_evaluate
    
@ %def smatrix_expr_evaluate
@ 
\subsubsection{Beam polarization density}

The beam polarization command defines spin density matrix for one or
two beams (scattering or decay).
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_pol_density_t
     private
     integer :: n_in = 0
     type(smatrix_expr_t), dimension(:), allocatable :: smatrix
   contains
   <<Commands: cmd beams pol density: TBP>>
  end type cmd_beams_pol_density_t

@ %def cmd_beams_pol_density_t
@ Output.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: write => cmd_beams_pol_density_write
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_write (cmd, unit, indent)
    class(cmd_beams_pol_density_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams polarization setup: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams polarization setup: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams polarization setup: [undefined]"
    end select
  end subroutine cmd_beams_pol_density_write

@ %def cmd_beams_pol_density_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: compile => cmd_beams_pol_density_compile
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_compile (cmd, global)
    class(cmd_beams_pol_density_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_pol_spec, pn_smatrix
    integer :: i
    pn_pol_spec => parse_node_get_sub_ptr (cmd%pn, 3)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_pol_spec)
    allocate (cmd%smatrix (cmd%n_in))
    pn_smatrix => parse_node_get_sub_ptr (pn_pol_spec)
    do i = 1, cmd%n_in
       call cmd%smatrix(i)%compile (pn_smatrix)
       pn_smatrix => parse_node_get_next_ptr (pn_smatrix)
    end do
  end subroutine cmd_beams_pol_density_compile

@ %def cmd_beams_pol_density_compile
@ Command execution: Fill polarization density matrices.  No check
yet, the matrices are checked and normalized when the actual beam
object is created, just before integration.  For intermediate storage,
we use the [[beam_structure]] object in the [[global]] data set.
<<Commands: cmd beams pol density: TBP>>=
  procedure :: execute => cmd_beams_pol_density_execute
<<Commands: procedures>>=
  subroutine cmd_beams_pol_density_execute (cmd, global)
    class(cmd_beams_pol_density_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(smatrix_t) :: smatrix
    integer :: i
    call global%beam_structure%init_pol (cmd%n_in)
    do i = 1, cmd%n_in
       call cmd%smatrix(i)%evaluate (smatrix, global)
       call global%beam_structure%set_smatrix (i, smatrix)
    end do
  end subroutine cmd_beams_pol_density_execute

@ %def cmd_beams_pol_density_execute 
@ 
\subsubsection{Beam polarization fraction}
In addition to the polarization density matrix, we can independently
specify the polarization fraction for one or both beams.
<<Commands: types>>=
  type, extends (command_t) :: cmd_beams_pol_fraction_t
     private
     integer :: n_in = 0
     type(parse_node_p), dimension(:), allocatable :: expr
   contains
   <<Commands: cmd beams pol fraction: TBP>>
  end type cmd_beams_pol_fraction_t

@ %def cmd_beams_pol_fraction_t
@ Output.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: write => cmd_beams_pol_fraction_write
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_write (cmd, unit, indent)
    class(cmd_beams_pol_fraction_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams polarization fraction: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams polarization fraction: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams polarization fraction: [undefined]"
    end select
  end subroutine cmd_beams_pol_fraction_write

@ %def cmd_beams_pol_fraction_write
@ Compile.  Find and assign the parse nodes.

Note: local environments are not yet supported.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: compile => cmd_beams_pol_fraction_compile
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_compile (cmd, global)
    class(cmd_beams_pol_fraction_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_frac_spec, pn_expr
    integer :: i
    pn_frac_spec => parse_node_get_sub_ptr (cmd%pn, 3)
    call cmd%compile_options (global)
    cmd%n_in = parse_node_get_n_sub (pn_frac_spec)
    allocate (cmd%expr (cmd%n_in))
    pn_expr => parse_node_get_sub_ptr (pn_frac_spec)
    do i = 1, cmd%n_in
       cmd%expr(i)%ptr => pn_expr
       pn_expr => parse_node_get_next_ptr (pn_expr)
    end do
  end subroutine cmd_beams_pol_fraction_compile

@ %def cmd_beams_pol_fraction_compile
@ Command execution: Retrieve the numerical values of the beam
polarization fractions.  The results are stored in the
[[beam_structure]] component of the [[global]] data block.
<<Commands: cmd beams pol fraction: TBP>>=
  procedure :: execute => cmd_beams_pol_fraction_execute
<<Commands: procedures>>=
  subroutine cmd_beams_pol_fraction_execute (cmd, global)
    class(cmd_beams_pol_fraction_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default), dimension(:), allocatable :: pol_f
    type(eval_tree_t) :: expr
    integer :: i
    var_list => global%get_var_list_ptr ()
    allocate (pol_f (cmd%n_in))
    do i = 1, cmd%n_in
       call expr%init_expr (cmd%expr(i)%ptr, var_list)
       call expr%evaluate ()
       if (expr%is_known ()) then
          pol_f(i) = expr%get_real ()
       else
          call msg_fatal ("beams polarization fraction: undefined value")
       end if
       call expr%final ()
    end do
    call global%beam_structure%set_pol_f (pol_f)
  end subroutine cmd_beams_pol_fraction_execute

@ %def cmd_beams_pol_fraction_execute 
@ 
\subsubsection{Beam momentum}
This is completely analogous to the previous command, hence we can use
inheritance.
<<Commands: types>>=
  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_momentum_t
   contains
   <<Commands: cmd beams momentum: TBP>>
  end type cmd_beams_momentum_t

@ %def cmd_beams_momentum_t
@ Output.
<<Commands: cmd beams momentum: TBP>>=
  procedure :: write => cmd_beams_momentum_write
<<Commands: procedures>>=
  subroutine cmd_beams_momentum_write (cmd, unit, indent)
    class(cmd_beams_momentum_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams momentum: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams momentum: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams momentum: [undefined]"
    end select
  end subroutine cmd_beams_momentum_write

@ %def cmd_beams_momentum_write
@ Compile: inherited.

Command execution: Not inherited, but just the error string and the final
command are changed.
<<Commands: cmd beams momentum: TBP>>=
  procedure :: execute => cmd_beams_momentum_execute
<<Commands: procedures>>=
  subroutine cmd_beams_momentum_execute (cmd, global)
    class(cmd_beams_momentum_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default), dimension(:), allocatable :: p
    type(eval_tree_t) :: expr
    integer :: i
    var_list => global%get_var_list_ptr ()
    allocate (p (cmd%n_in))
    do i = 1, cmd%n_in
       call expr%init_expr (cmd%expr(i)%ptr, var_list)
       call expr%evaluate ()
       if (expr%is_known ()) then
          p(i) = expr%get_real ()
       else
          call msg_fatal ("beams momentum: undefined value")
       end if
       call expr%final ()
    end do
    call global%beam_structure%set_momentum (p)
  end subroutine cmd_beams_momentum_execute

@ %def cmd_beams_momentum_execute 
@ 
\subsubsection{Beam angles}
Again, this is analogous.  There are two angles, polar angle $\theta$
and azimuthal angle $\phi$, which can be set independently for both beams.
<<Commands: types>>=
  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_theta_t
   contains
   <<Commands: cmd beams theta: TBP>>
  end type cmd_beams_theta_t

  type, extends (cmd_beams_pol_fraction_t) :: cmd_beams_phi_t
   contains
   <<Commands: cmd beams phi: TBP>>
  end type cmd_beams_phi_t

@ %def cmd_beams_theta_t
@ %def cmd_beams_phi_t
@ Output.
<<Commands: cmd beams theta: TBP>>=
  procedure :: write => cmd_beams_theta_write
<<Commands: cmd beams phi: TBP>>=
  procedure :: write => cmd_beams_phi_write
<<Commands: procedures>>=
  subroutine cmd_beams_theta_write (cmd, unit, indent)
    class(cmd_beams_theta_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams theta: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams theta: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams theta: [undefined]"
    end select
  end subroutine cmd_beams_theta_write

  subroutine cmd_beams_phi_write (cmd, unit, indent)
    class(cmd_beams_phi_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_in)
    case (1)
       write (u, "(1x,A)")  "beams phi: 1 [decay]"
    case (2)
       write (u, "(1x,A)")  "beams phi: 2 [scattering]"
    case default
       write (u, "(1x,A)")  "beams phi: [undefined]"
    end select
  end subroutine cmd_beams_phi_write

@ %def cmd_beams_theta_write
@ %def cmd_beams_phi_write
@ Compile: inherited.

Command execution: Not inherited, but just the error string and the final
command are changed.
<<Commands: cmd beams theta: TBP>>=
  procedure :: execute => cmd_beams_theta_execute
<<Commands: cmd beams phi: TBP>>=
  procedure :: execute => cmd_beams_phi_execute
<<Commands: procedures>>=
  subroutine cmd_beams_theta_execute (cmd, global)
    class(cmd_beams_theta_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default), dimension(:), allocatable :: theta
    type(eval_tree_t) :: expr
    integer :: i
    var_list => global%get_var_list_ptr ()
    allocate (theta (cmd%n_in))
    do i = 1, cmd%n_in
       call expr%init_expr (cmd%expr(i)%ptr, var_list)
       call expr%evaluate ()
       if (expr%is_known ()) then
          theta(i) = expr%get_real ()
       else
          call msg_fatal ("beams theta: undefined value")
       end if
       call expr%final ()
    end do
    call global%beam_structure%set_theta (theta)
  end subroutine cmd_beams_theta_execute

  subroutine cmd_beams_phi_execute (cmd, global)
    class(cmd_beams_phi_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default), dimension(:), allocatable :: phi
    type(eval_tree_t) :: expr
    integer :: i
    var_list => global%get_var_list_ptr ()
    allocate (phi (cmd%n_in))
    do i = 1, cmd%n_in
       call expr%init_expr (cmd%expr(i)%ptr, var_list)
       call expr%evaluate ()
       if (expr%is_known ()) then
          phi(i) = expr%get_real ()
       else
          call msg_fatal ("beams phi: undefined value")
       end if
       call expr%final ()
    end do
    call global%beam_structure%set_phi (phi)
  end subroutine cmd_beams_phi_execute

@ %def cmd_beams_theta_execute 
@ %def cmd_beams_phi_execute 
@
\subsubsection{Cuts}
Define a cut expression.  We store the parse tree for the right-hand
side instead of compiling it.  Compilation is deferred to the process
environment where the cut expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_cuts_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd cuts: TBP>>
  end type cmd_cuts_t

@ %def cmd_cuts_t
@ Output.  Do not print the parse tree, since this may get cluttered.
Just a message that cuts have been defined.
<<Commands: cmd cuts: TBP>>=
  procedure :: write => cmd_cuts_write
<<Commands: procedures>>=
  subroutine cmd_cuts_write (cmd, unit, indent)
    class(cmd_cuts_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "cuts: [defined]"
  end subroutine cmd_cuts_write
  
@ %def cmd_cuts_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd cuts: TBP>>=
  procedure :: compile => cmd_cuts_compile
<<Commands: procedures>>=
  subroutine cmd_cuts_compile (cmd, global)
    class(cmd_cuts_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_cuts_compile

@ %def cmd_cuts_compile
@ Instead of evaluating the cut expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd cuts: TBP>>=
  procedure :: execute => cmd_cuts_execute
<<Commands: procedures>>=
  subroutine cmd_cuts_execute (cmd, global)
    class(cmd_cuts_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%cuts_lexpr => cmd%pn_lexpr
  end subroutine cmd_cuts_execute

@ %def cmd_cuts_execute
@ 
\subsubsection{General, Factorization and Renormalization Scales}
Define a scale expression for either the renormalization or the 
factorization scale.  We store the parse tree for the right-hand
side instead of compiling it.  Compilation is deferred to the process
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd scale: TBP>>   
  end type cmd_scale_t

@ %def cmd_scale_t
<<Commands: types>>=
  type, extends (command_t) :: cmd_fac_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd fac scale: TBP>>
  end type cmd_fac_scale_t

@ %def cmd_fac_scale_t
<<Commands: types>>=
  type, extends (command_t) :: cmd_ren_scale_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()     
   contains
   <<Commands: cmd ren scale: TBP>>
  end type cmd_ren_scale_t

@ %def cmd_ren_scale_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd scale: TBP>>=
  procedure :: write => cmd_scale_write
<<Commands: procedures>>=
  subroutine cmd_scale_write (cmd, unit, indent)
    class(cmd_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "scale: [defined]"
  end subroutine cmd_scale_write
  
@ %def cmd_scale_write
@
<<Commands: cmd fac scale: TBP>>=
  procedure :: write => cmd_fac_scale_write
<<Commands: procedures>>=
  subroutine cmd_fac_scale_write (cmd, unit, indent)
    class(cmd_fac_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "factorization scale: [defined]"
  end subroutine cmd_fac_scale_write
  
@ %def cmd_fac_scale_write
@
<<Commands: cmd ren scale: TBP>>=
  procedure :: write => cmd_ren_scale_write
<<Commands: procedures>>=
  subroutine cmd_ren_scale_write (cmd, unit, indent)
    class(cmd_ren_scale_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "renormalization scale: [defined]"
  end subroutine cmd_ren_scale_write
  
@ %def cmd_ren_scale_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd scale: TBP>>=
  procedure :: compile => cmd_scale_compile 
<<Commands: procedures>>=
  subroutine cmd_scale_compile (cmd, global)
    class(cmd_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_scale_compile

@ %def cmd_scale_compile
@
<<Commands: cmd fac scale: TBP>>=
  procedure :: compile => cmd_fac_scale_compile
<<Commands: procedures>>=
  subroutine cmd_fac_scale_compile (cmd, global)
    class(cmd_fac_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_fac_scale_compile

@ %def cmd_fac_scale_compile
@
<<Commands: cmd ren scale: TBP>>=
  procedure :: compile => cmd_ren_scale_compile
<<Commands: procedures>>=
  subroutine cmd_ren_scale_compile (cmd, global)
    class(cmd_ren_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_ren_scale_compile

@ %def cmd_ren_scale_compile
@ Instead of evaluating the scale expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd scale: TBP>>=
  procedure :: execute => cmd_scale_execute
<<Commands: procedures>>=
  subroutine cmd_scale_execute (cmd, global)
    class(cmd_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%scale_expr => cmd%pn_expr
  end subroutine cmd_scale_execute

@ %def cmd_scale_execute
@ 
<<Commands: cmd fac scale: TBP>>=
  procedure :: execute => cmd_fac_scale_execute
<<Commands: procedures>>=
  subroutine cmd_fac_scale_execute (cmd, global)
    class(cmd_fac_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%fac_scale_expr => cmd%pn_expr
  end subroutine cmd_fac_scale_execute

@ %def cmd_fac_scale_execute
@ 
<<Commands: cmd ren scale: TBP>>=
  procedure :: execute => cmd_ren_scale_execute
<<Commands: procedures>>=
  subroutine cmd_ren_scale_execute (cmd, global)
    class(cmd_ren_scale_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%ren_scale_expr => cmd%pn_expr    
  end subroutine cmd_ren_scale_execute

@ %def cmd_ren_scale_execute
@ 
\subsubsection{Weight}
Define a weight expression. The weight is applied to a process to be
integrated, event by event. We store the parse tree for the right-hand
side instead of compiling it. Compilation is deferred to the process
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_weight_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd weight: TBP>>  
  end type cmd_weight_t

@ %def cmd_weight_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd weight: TBP>>=
  procedure :: write => cmd_weight_write
<<Commands: procedures>>=
  subroutine cmd_weight_write (cmd, unit, indent)
    class(cmd_weight_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "weight expression: [defined]"
  end subroutine cmd_weight_write
  
@ %def cmd_weight_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd weight: TBP>>=
  procedure :: compile => cmd_weight_compile
<<Commands: procedures>>=
  subroutine cmd_weight_compile (cmd, global)
    class(cmd_weight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_weight_compile

@ %def cmd_weight_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd weight: TBP>>=
  procedure :: execute => cmd_weight_execute
<<Commands: procedures>>=
  subroutine cmd_weight_execute (cmd, global)
    class(cmd_weight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%weight_expr => cmd%pn_expr
  end subroutine cmd_weight_execute

@ %def cmd_weight_execute
@ 
\subsubsection{Selection}
Define a selection expression.  This is to be applied upon simulation or
event-file rescanning, event by event.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to the
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_selection_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd selection: TBP>>
  end type cmd_selection_t

@ %def cmd_selection_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd selection: TBP>>=
  procedure :: write => cmd_selection_write
<<Commands: procedures>>=
  subroutine cmd_selection_write (cmd, unit, indent)
    class(cmd_selection_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "selection expression: [defined]"
  end subroutine cmd_selection_write
  
@ %def cmd_selection_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd selection: TBP>>=
  procedure :: compile => cmd_selection_compile
<<Commands: procedures>>=
  subroutine cmd_selection_compile (cmd, global)
    class(cmd_selection_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_selection_compile

@ %def cmd_selection_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd selection: TBP>>=
  procedure :: execute => cmd_selection_execute
<<Commands: procedures>>=
  subroutine cmd_selection_execute (cmd, global)
    class(cmd_selection_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%selection_lexpr => cmd%pn_expr
  end subroutine cmd_selection_execute

@ %def cmd_selection_execute
@ 
\subsubsection{Reweight}
Define a reweight expression.  This is to be applied upon simulation or
event-file rescanning, event by event.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to the
environment where the expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_reweight_t
     private
     type(parse_node_t), pointer :: pn_expr => null ()
   contains
   <<Commands: cmd reweight: TBP>>  
  end type cmd_reweight_t

@ %def cmd_reweight_t
@ Output. Do not print the parse tree, since this may get cluttered.
Just a message that scale, renormalization and factorization have been
defined, respectively.
<<Commands: cmd reweight: TBP>>=
  procedure :: write => cmd_reweight_write
<<Commands: procedures>>=
  subroutine cmd_reweight_write (cmd, unit, indent)
    class(cmd_reweight_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "reweight expression: [defined]"
  end subroutine cmd_reweight_write
  
@ %def cmd_reweight_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd reweight: TBP>>=
  procedure :: compile => cmd_reweight_compile
<<Commands: procedures>>=
  subroutine cmd_reweight_compile (cmd, global)
    class(cmd_reweight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_expr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_reweight_compile

@ %def cmd_reweight_compile
@ Instead of evaluating the expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd reweight: TBP>>=
  procedure :: execute => cmd_reweight_execute
<<Commands: procedures>>=
  subroutine cmd_reweight_execute (cmd, global)
    class(cmd_reweight_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%reweight_expr => cmd%pn_expr
  end subroutine cmd_reweight_execute

@ %def cmd_reweight_execute
@ 
\subsubsection{Alternative Simulation Setups}
Together with simulation, we can re-evaluate event weights in the context of
alternative setups.  The [[cmd_alt_setup_t]] object is designed to hold these
setups, which are brace-enclosed command lists.  Compilation is deferred to
the simulation environment where the setup expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_alt_setup_t
     private
     type(parse_node_p), dimension(:), allocatable :: setup
   contains
   <<Commands: cmd alt setup: TBP>>
  end type cmd_alt_setup_t

@ %def cmd_alt_setup_t
@ Output.  Print just a message that the alternative setup list has been
defined.
<<Commands: cmd alt setup: TBP>>=
  procedure :: write => cmd_alt_setup_write
<<Commands: procedures>>=
  subroutine cmd_alt_setup_write (cmd, unit, indent)
    class(cmd_alt_setup_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,I0,A)")  "alt_setup: ", size (cmd%setup), " entries"
  end subroutine cmd_alt_setup_write
  
@ %def cmd_alt_setup_write
@ Compile.  Store the parse sub-trees in an array.
<<Commands: cmd alt setup: TBP>>=
  procedure :: compile => cmd_alt_setup_compile
<<Commands: procedures>>=
  subroutine cmd_alt_setup_compile (cmd, global)
    class(cmd_alt_setup_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_setup
    integer :: i
    pn_list => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_list)) then
       allocate (cmd%setup (parse_node_get_n_sub (pn_list)))
       i = 1
       pn_setup => parse_node_get_sub_ptr (pn_list)
       do while (associated (pn_setup))
          cmd%setup(i)%ptr => pn_setup
          i = i + 1
          pn_setup => parse_node_get_next_ptr (pn_setup)
       end do
    else
       allocate (cmd%setup (0))
    end if
  end subroutine cmd_alt_setup_compile

@ %def cmd_alt_setup_compile
@ Execute.  Transfer the array of command lists to the global environment.
<<Commands: cmd alt setup: TBP>>=
  procedure :: execute => cmd_alt_setup_execute
<<Commands: procedures>>=
  subroutine cmd_alt_setup_execute (cmd, global)
    class(cmd_alt_setup_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (allocated (global%pn%alt_setup))  deallocate (global%pn%alt_setup)
    allocate (global%pn%alt_setup (size (cmd%setup)), source = cmd%setup)
  end subroutine cmd_alt_setup_execute

@ %def cmd_alt_setup_execute
@
\subsubsection{Integration}
Integrate several processes, consecutively with identical parameters.
<<Commands: types>>=
  type, extends (command_t) :: cmd_integrate_t
     private
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd integrate: TBP>>
  end type cmd_integrate_t
     
@ %def cmd_integrate_t
@ Output: we know the process IDs.
<<Commands: cmd integrate: TBP>>=
  procedure :: write => cmd_integrate_write
<<Commands: procedures>>=
  subroutine cmd_integrate_write (cmd, unit, indent)
    class(cmd_integrate_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "integrate ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_integrate_write

@ %def cmd_integrate_write
@ Compile.
<<Commands: cmd integrate: TBP>>=
  procedure :: compile => cmd_integrate_compile
<<Commands: procedures>>=
  subroutine cmd_integrate_compile (cmd, global)
    class(cmd_integrate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_proclist, pn_proc
    integer :: i
    pn_proclist => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       call global%process_stack%init_result_vars (cmd%process_id(i))
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_integrate_compile

@ %def cmd_integrate_compile
@ Command execution.  Integrate the process(es) with the predefined number
of passes, iterations and calls.  For structure functions, cuts,
weight and scale, use local definitions if present; by default, the local
definitions are initialized with the global ones.

The [[integrate]] procedure should take its input from the currently
active local environment, but produce a process record in the stack of
the global environment.

Since the process acquires a snapshot of the variable list, so if the global
list (or the local one) is deleted, this does no harm.  This implies that
later changes of the variable list do not affect the stored process.
<<Commands: cmd integrate: TBP>>=
  procedure :: execute => cmd_integrate_execute
<<Commands: procedures>>=
  subroutine cmd_integrate_execute (cmd, global)
    class(cmd_integrate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    integer :: i
    do i = 1, cmd%n_proc
       call integrate_process (cmd%process_id(i), cmd%local, global)
       call global%process_stack%fill_result_vars (cmd%process_id(i))
       if (signal_is_pending ())  return
    end do
  end subroutine cmd_integrate_execute

@ %def cmd_integrate_execute
@
\subsubsection{Observables}
Declare an observable.  After the declaration, it can be used to
record data, and at the end one can retrieve average and error.
<<Commands: types>>=
  type, extends (command_t) :: cmd_observable_t
     private
     type(string_t) :: id
   contains
   <<Commands: cmd observable: TBP>>
  end type cmd_observable_t
     
@ %def cmd_observable_t
@ Output.  We know the ID.
<<Commands: cmd observable: TBP>>=
  procedure :: write => cmd_observable_write
<<Commands: procedures>>=
  subroutine cmd_observable_write (cmd, unit, indent)
    class(cmd_observable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "observable: ", char (cmd%id)
  end subroutine cmd_observable_write
  
@ %def cmd_observable_write
@ Compile.  Just record the observable ID.
<<Commands: cmd observable: TBP>>=
  procedure :: compile => cmd_observable_compile
<<Commands: procedures>>=
  subroutine cmd_observable_compile (cmd, global)
    class(cmd_observable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_tag)) then
       cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    end if       
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("observable: name expression not implemented (yet)")
    end select
  end subroutine cmd_observable_compile

@ %def cmd_observable_compile
@ Command execution.  This declares the observable and allocates it in
the analysis store.
<<Commands: cmd observable: TBP>>=
  procedure :: execute => cmd_observable_execute
<<Commands: procedures>>=
  subroutine cmd_observable_execute (cmd, global)
    class(cmd_observable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(graph_options_t) :: graph_options
    type(string_t) :: label, unit
    var_list => cmd%local%get_var_list_ptr ()
    label = var_list%get_sval (var_str ("$obs_label"))
    unit = var_list%get_sval (var_str ("$obs_unit"))
    call graph_options_init (graph_options)
    call set_graph_options (graph_options, var_list)
    call analysis_init_observable (cmd%id, label, unit, graph_options)
  end subroutine cmd_observable_execute

@ %def cmd_observable_execute
@
\subsubsection{Histograms}
Declare a histogram.  At minimum, we have to set lower and upper bound
and bin width.
<<Commands: types>>=
  type, extends (command_t) :: cmd_histogram_t
     private
     type(string_t) :: id
     type(parse_node_t), pointer :: pn_lower_bound => null ()
     type(parse_node_t), pointer :: pn_upper_bound => null ()
     type(parse_node_t), pointer :: pn_bin_width => null ()
   contains
   <<Commands: cmd histogram: TBP>>
  end type cmd_histogram_t
     
@ %def cmd_histogram_t
@ Output.  Just print the ID.
<<Commands: cmd histogram: TBP>>=
  procedure :: write => cmd_histogram_write
<<Commands: procedures>>=
  subroutine cmd_histogram_write (cmd, unit, indent)
    class(cmd_histogram_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "histogram: ", char (cmd%id)
  end subroutine cmd_histogram_write
  
@ %def cmd_histogram_write
@ Compile.  Record the histogram ID and initialize lower, upper bound
and bin width.
<<Commands: cmd histogram: TBP>>=
  procedure :: compile => cmd_histogram_compile
<<Commands: procedures>>=
  subroutine cmd_histogram_compile (cmd, global)
    class(cmd_histogram_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag, pn_args, pn_arg1, pn_arg2, pn_arg3
    character(*), parameter :: e_illegal_use = &
       "illegal usage of 'histogram': insufficient number of arguments"
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_args => parse_node_get_next_ptr (pn_tag)
    if (associated (pn_args)) then
       pn_arg1 => parse_node_get_sub_ptr (pn_args)
       if (.not. associated (pn_arg1)) call msg_fatal (e_illegal_use)
       pn_arg2 => parse_node_get_next_ptr (pn_arg1)
       if (.not. associated (pn_arg2)) call msg_fatal (e_illegal_use)
       pn_arg3 => parse_node_get_next_ptr (pn_arg2)
       cmd%pn_opt => parse_node_get_next_ptr (pn_args)
    end if       
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("histogram: name expression not implemented (yet)")
    end select
    cmd%pn_lower_bound => pn_arg1
    cmd%pn_upper_bound => pn_arg2
    cmd%pn_bin_width => pn_arg3
  end subroutine cmd_histogram_compile

@ %def cmd_histogram_compile
@ Command execution.  This declares the histogram and allocates it in
the analysis store.
<<Commands: cmd histogram: TBP>>=
  procedure :: execute => cmd_histogram_execute
<<Commands: procedures>>=
  subroutine cmd_histogram_execute (cmd, global)
    class(cmd_histogram_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    real(default) :: lower_bound, upper_bound, bin_width
    integer :: bin_number
    logical :: bin_width_is_used, normalize_bins
    type(string_t) :: obs_label, obs_unit
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options

    var_list => cmd%local%get_var_list_ptr ()
    lower_bound = eval_real (cmd%pn_lower_bound, var_list)
    upper_bound = eval_real (cmd%pn_upper_bound, var_list)
    if (associated (cmd%pn_bin_width)) then
       bin_width = eval_real (cmd%pn_bin_width, var_list)
       bin_width_is_used = .true.
    else if (var_list%is_known (var_str ("n_bins"))) then
       bin_number = &
            var_list%get_ival (var_str ("n_bins"))
       bin_width_is_used = .false.
    else
       call msg_error ("Cmd '" // char (cmd%id) // &
            "': neither bin width nor number is defined")
    end if
    normalize_bins = &
         var_list%get_lval (var_str ("?normalize_bins"))
    obs_label = &
         var_list%get_sval (var_str ("$obs_label"))
    obs_unit = &
         var_list%get_sval (var_str ("$obs_unit"))

    call graph_options_init (graph_options)
    call set_graph_options (graph_options, var_list)
    call drawing_options_init_histogram (drawing_options)
    call set_drawing_options (drawing_options, var_list)

    if (bin_width_is_used) then
       call analysis_init_histogram &
            (cmd%id, lower_bound, upper_bound, bin_width, &
             normalize_bins, &
             obs_label, obs_unit, &
             graph_options, drawing_options)
    else
       call analysis_init_histogram &
            (cmd%id, lower_bound, upper_bound, bin_number, &
             normalize_bins, &
             obs_label, obs_unit, &
             graph_options, drawing_options)
    end if
  end subroutine cmd_histogram_execute

@ %def cmd_histogram_execute
@ Set the graph options from a variable list.
<<Commands: procedures>>=
  subroutine set_graph_options (gro, var_list)
    type(graph_options_t), intent(inout) :: gro
    type(var_list_t), intent(in) :: var_list
    call graph_options_set (gro, title = &
         var_list%get_sval (var_str ("$title")))
    call graph_options_set (gro, description = &
         var_list%get_sval (var_str ("$description")))
    call graph_options_set (gro, x_label = &
         var_list%get_sval (var_str ("$x_label")))
    call graph_options_set (gro, y_label = &
         var_list%get_sval (var_str ("$y_label")))
    call graph_options_set (gro, width_mm = &
         var_list%get_ival (var_str ("graph_width_mm")))
    call graph_options_set (gro, height_mm = &
         var_list%get_ival (var_str ("graph_height_mm")))
    call graph_options_set (gro, x_log = &
         var_list%get_lval (var_str ("?x_log")))
    call graph_options_set (gro, y_log = &
         var_list%get_lval (var_str ("?y_log")))
    if (var_list%is_known (var_str ("x_min"))) &
         call graph_options_set (gro, x_min = &
         var_list%get_rval (var_str ("x_min")))
    if (var_list%is_known (var_str ("x_max"))) &
         call graph_options_set (gro, x_max = &
         var_list%get_rval (var_str ("x_max")))
    if (var_list%is_known (var_str ("y_min"))) &
         call graph_options_set (gro, y_min = &
         var_list%get_rval (var_str ("y_min")))
    if (var_list%is_known (var_str ("y_max"))) &
         call graph_options_set (gro, y_max = &
         var_list%get_rval (var_str ("y_max")))
    call graph_options_set (gro, gmlcode_bg = &
         var_list%get_sval (var_str ("$gmlcode_bg")))
    call graph_options_set (gro, gmlcode_fg = &
         var_list%get_sval (var_str ("$gmlcode_fg")))
  end subroutine set_graph_options

@ %def set_graph_options
@ Set the drawing options from a variable list.
<<Commands: procedures>>=
  subroutine set_drawing_options (dro, var_list)
    type(drawing_options_t), intent(inout) :: dro
    type(var_list_t), intent(in) :: var_list
    if (var_list%is_known (var_str ("?draw_histogram"))) then
       if (var_list%get_lval (var_str ("?draw_histogram"))) then
          call drawing_options_set (dro, with_hbars = .true.)
       else
          call drawing_options_set (dro, with_hbars = .false., &
               with_base = .false., fill = .false., piecewise = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?draw_base"))) then
       if (var_list%get_lval (var_str ("?draw_base"))) then
          call drawing_options_set (dro, with_base = .true.)
       else
          call drawing_options_set (dro, with_base = .false., fill = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?draw_piecewise"))) then
       if (var_list%get_lval (var_str ("?draw_piecewise"))) then
          call drawing_options_set (dro, piecewise = .true.)
       else
          call drawing_options_set (dro, piecewise = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?fill_curve"))) then
       if (var_list%get_lval (var_str ("?fill_curve"))) then
          call drawing_options_set (dro, fill = .true., with_base = .true.)
       else
          call drawing_options_set (dro, fill = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?draw_curve"))) then
       if (var_list%get_lval (var_str ("?draw_curve"))) then
          call drawing_options_set (dro, draw = .true.)
       else
          call drawing_options_set (dro, draw = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?draw_errors"))) then
       if (var_list%get_lval (var_str ("?draw_errors"))) then
          call drawing_options_set (dro, err = .true.)
       else
          call drawing_options_set (dro, err = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("?draw_symbols"))) then
       if (var_list%get_lval (var_str ("?draw_symbols"))) then
          call drawing_options_set (dro, symbols = .true.)
       else
          call drawing_options_set (dro, symbols = .false.)
       end if
    end if
    if (var_list%is_known (var_str ("$fill_options"))) then
       call drawing_options_set (dro, fill_options = &
            var_list%get_sval (var_str ("$fill_options")))
    end if
    if (var_list%is_known (var_str ("$draw_options"))) then
       call drawing_options_set (dro, draw_options = &
            var_list%get_sval (var_str ("$draw_options")))
    end if
    if (var_list%is_known (var_str ("$err_options"))) then
       call drawing_options_set (dro, err_options = &
            var_list%get_sval (var_str ("$err_options")))
    end if
    if (var_list%is_known (var_str ("$symbol"))) then
       call drawing_options_set (dro, symbol = &
            var_list%get_sval (var_str ("$symbol")))
    end if
    if (var_list%is_known (var_str ("$gmlcode_bg"))) then
       call drawing_options_set (dro, gmlcode_bg = &
            var_list%get_sval (var_str ("$gmlcode_bg")))
    end if
    if (var_list%is_known (var_str ("$gmlcode_fg"))) then
       call drawing_options_set (dro, gmlcode_fg = &
            var_list%get_sval (var_str ("$gmlcode_fg")))
    end if
  end subroutine set_drawing_options

@ %def set_drawing_options
@
\subsubsection{Plots}
Declare a plot.  No mandatory arguments, just options.
<<Commands: types>>=
  type, extends (command_t) :: cmd_plot_t
     private
     type(string_t) :: id
   contains
   <<Commands: cmd plot: TBP>>
  end type cmd_plot_t
     
@ %def cmd_plot_t
@ Output.  Just print the ID.
<<Commands: cmd plot: TBP>>=
  procedure :: write => cmd_plot_write
<<Commands: procedures>>=
  subroutine cmd_plot_write (cmd, unit, indent)
    class(cmd_plot_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A)")  "plot: ", char (cmd%id)
  end subroutine cmd_plot_write
  
@ %def cmd_plot_write
@ Compile.  Record the plot ID and initialize lower, upper bound
and bin width.
<<Commands: cmd plot: TBP>>=
  procedure :: compile => cmd_plot_compile
<<Commands: procedures>>=
  subroutine cmd_plot_compile (cmd, global)
    class(cmd_plot_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_tag
    pn_tag => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%init (pn_tag, global)
  end subroutine cmd_plot_compile

@ %def cmd_plot_compile
@ This init routine is separated because it is reused below for graph
initialization. 
<<Commands: cmd plot: TBP>>=
  procedure :: init => cmd_plot_init
<<Commands: procedures>>=
  subroutine cmd_plot_init (plot, pn_tag, global)
    class(cmd_plot_t), intent(inout) :: plot
    type(parse_node_t), intent(in), pointer :: pn_tag
    type(rt_data_t), intent(inout), target :: global
    call plot%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       plot%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("plot: name expression not implemented (yet)")
    end select
  end subroutine cmd_plot_init

@ %def cmd_plot_init
@ Command execution.  This declares the plot and allocates it in
the analysis store.
<<Commands: cmd plot: TBP>>=
  procedure :: execute => cmd_plot_execute
<<Commands: procedures>>=
  subroutine cmd_plot_execute (cmd, global)
    class(cmd_plot_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options

    var_list => cmd%local%get_var_list_ptr ()
    call graph_options_init (graph_options)
    call set_graph_options (graph_options, var_list)
    call drawing_options_init_plot (drawing_options)
    call set_drawing_options (drawing_options, var_list)

    call analysis_init_plot (cmd%id, graph_options, drawing_options)
  end subroutine cmd_plot_execute

@ %def cmd_plot_execute
@
\subsubsection{Graphs}
Declare a graph.  The graph is defined in terms of its contents.  Both the
graph and its contents may carry options.

The graph object contains its own ID as well as the IDs of its elements.  For
the elements, we reuse the [[cmd_plot_t]] defined above.
<<Commands: types>>=
  type, extends (command_t) :: cmd_graph_t
     private
     type(string_t) :: id
     integer :: n_elements = 0
     type(cmd_plot_t), dimension(:), allocatable :: el
     type(string_t), dimension(:), allocatable :: element_id
   contains
   <<Commands: cmd graph: TBP>>
  end type cmd_graph_t
     
@ %def cmd_graph_t
@ Output.  Just print the ID.
<<Commands: cmd graph: TBP>>=
  procedure :: write => cmd_graph_write
<<Commands: procedures>>=
  subroutine cmd_graph_write (cmd, unit, indent)
    class(cmd_graph_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,A,A,I0,A)")  "graph: ", char (cmd%id), &
         " (", cmd%n_elements, " entries)"
  end subroutine cmd_graph_write
  
@ %def cmd_graph_write
@ Compile.  Record the graph ID and initialize lower, upper bound
and bin width.  For compiling the graph element syntax, we use part of the
[[cmd_plot_t]] compiler.

Note: currently, we do not respect options, therefore just IDs on the RHS.
<<Commands: cmd graph: TBP>>=
  procedure :: compile => cmd_graph_compile
<<Commands: procedures>>=
  subroutine cmd_graph_compile (cmd, global)
    class(cmd_graph_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_term, pn_tag, pn_def, pn_app
    integer :: i

    pn_term => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_tag => parse_node_get_sub_ptr (pn_term)
    cmd%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%compile_options (global)
    select case (char (parse_node_get_rule_key (pn_tag)))
    case ("analysis_id")
       cmd%id = parse_node_get_string (pn_tag)
    case default
       call msg_bug ("graph: name expression not implemented (yet)")
    end select
    pn_def => parse_node_get_next_ptr (pn_term, 2)
    cmd%n_elements = parse_node_get_n_sub (pn_def)
    allocate (cmd%element_id (cmd%n_elements))
    allocate (cmd%el (cmd%n_elements))
    pn_term => parse_node_get_sub_ptr (pn_def)
    pn_tag => parse_node_get_sub_ptr (pn_term)
    cmd%el(1)%pn_opt => parse_node_get_next_ptr (pn_tag)
    call cmd%el(1)%init (pn_tag, global)
    cmd%element_id(1) = parse_node_get_string (pn_tag)
    pn_app => parse_node_get_next_ptr (pn_term)
    do i = 2, cmd%n_elements
       pn_term => parse_node_get_sub_ptr (pn_app, 2)
       pn_tag => parse_node_get_sub_ptr (pn_term)
       cmd%el(i)%pn_opt => parse_node_get_next_ptr (pn_tag)
       call cmd%el(i)%init (pn_tag, global)
       cmd%element_id(i) = parse_node_get_string (pn_tag)
       pn_app => parse_node_get_next_ptr (pn_app)
    end do

  end subroutine cmd_graph_compile

@ %def cmd_graph_compile
@ Command execution.  This declares the graph, allocates it in
the analysis store, and copies the graph elements.

For the graph, we set graph and default drawing options.  For the elements, we
reset individual drawing options.

This accesses internals of the contained elements of type [[cmd_plot_t]], see
above.  We might disentangle such an interdependency when this code is
rewritten using proper type extension.
<<Commands: cmd graph: TBP>>=
  procedure :: execute => cmd_graph_execute
<<Commands: procedures>>=
  subroutine cmd_graph_execute (cmd, global)
    class(cmd_graph_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(graph_options_t) :: graph_options
    type(drawing_options_t) :: drawing_options
    integer :: i, type

    var_list => cmd%local%get_var_list_ptr ()
    call graph_options_init (graph_options)
    call set_graph_options (graph_options, var_list)
    call analysis_init_graph (cmd%id, cmd%n_elements, graph_options)

    do i = 1, cmd%n_elements
       if (associated (cmd%el(i)%options)) then
          call cmd%el(i)%options%execute (cmd%el(i)%local)
       end if
       type = analysis_store_get_object_type (cmd%element_id(i))
       select case (type)
       case (AN_HISTOGRAM)
          call drawing_options_init_histogram (drawing_options)
       case (AN_PLOT)
          call drawing_options_init_plot (drawing_options)
       end select
       call set_drawing_options (drawing_options, var_list)
       if (associated (cmd%el(i)%options)) then
          call set_drawing_options (drawing_options, cmd%el(i)%local%var_list)
       end if
       call analysis_fill_graph (cmd%id, i, cmd%element_id(i), drawing_options)
    end do
  end subroutine cmd_graph_execute

@ %def cmd_graph_execute
@ 
\subsubsection{Analysis}
Hold the analysis ID either as a string or as an expression:
<<Commands: types>>=
  type :: analysis_id_t
    type(string_t) :: tag
    type(parse_node_t), pointer :: pn_sexpr => null ()
  end type analysis_id_t

@ %def analysis_id_t
@ Define the analysis expression.  We store the parse tree for the
right-hand side instead of compiling it.  Compilation is deferred to
the process environment where the analysis expression is used.
<<Commands: types>>=
  type, extends (command_t) :: cmd_analysis_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd analysis: TBP>>
  end type cmd_analysis_t

@ %def cmd_analysis_t
@ Output.  Print just a message that analysis has been defined.
<<Commands: cmd analysis: TBP>>=
  procedure :: write => cmd_analysis_write
<<Commands: procedures>>=
  subroutine cmd_analysis_write (cmd, unit, indent)
    class(cmd_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "analysis: [defined]"
  end subroutine cmd_analysis_write
  
@ %def cmd_analysis_write
@ Compile.  Simply store the parse (sub)tree.
<<Commands: cmd analysis: TBP>>=
  procedure :: compile => cmd_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_analysis_compile (cmd, global)
    class(cmd_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 3)
  end subroutine cmd_analysis_compile

@ %def cmd_analysis_compile
@ Instead of evaluating the cut expression, link the parse tree to the
global data set, such that it is compiled and executed in the
appropriate process context.
<<Commands: cmd analysis: TBP>>=
  procedure :: execute => cmd_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_analysis_execute (cmd, global)
    class(cmd_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    global%pn%analysis_lexpr => cmd%pn_lexpr
  end subroutine cmd_analysis_execute

@ %def cmd_analysis_execute
@
\subsubsection{Write histograms and plots}
The data type encapsulating the command:
<<Commands: types>>=
  type, extends (command_t) :: cmd_write_analysis_t
     private
     type(analysis_id_t), dimension(:), allocatable :: id
     type(string_t), dimension(:), allocatable :: tag
   contains
   <<Commands: cmd write analysis: TBP>>
  end type cmd_write_analysis_t

@ %def analysis_id_t
@ %def cmd_write_analysis_t
@ Output.  Just the keyword.
<<Commands: cmd write analysis: TBP>>=
  procedure :: write => cmd_write_analysis_write
<<Commands: procedures>>=
  subroutine cmd_write_analysis_write (cmd, unit, indent)
    class(cmd_write_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "write_analysis"
  end subroutine cmd_write_analysis_write
  
@ %def cmd_write_analysis_write
@ Compile.
<<Commands: cmd write analysis: TBP>>=
  procedure :: compile => cmd_write_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_write_analysis_compile (cmd, global)
    class(cmd_write_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_clause, pn_args, pn_id
    integer :: n, i
    pn_clause => parse_node_get_sub_ptr (cmd%pn)
    pn_args => parse_node_get_sub_ptr (pn_clause, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_clause)
    call cmd%compile_options (global)
    if (associated (pn_args)) then
       n = parse_node_get_n_sub (pn_args)
       allocate (cmd%id (n))
       do i = 1, n
           pn_id => parse_node_get_sub_ptr (pn_args, i)
           if (char (parse_node_get_rule_key (pn_id)) == "analysis_id") then
              cmd%id(i)%tag = parse_node_get_string (pn_id)              
           else
              cmd%id(i)%pn_sexpr => pn_id
           end if
       end do
    else
       allocate (cmd%id (0))
    end if
  end subroutine cmd_write_analysis_compile

@ %def cmd_write_analysis_compile
@ The output format for real data values:
<<Commands: parameters>>=
  character(*), parameter, public :: &
       DEFAULT_ANALYSIS_FILENAME = "whizard_analysis.dat"
  character(len=1), dimension(2), parameter, public :: &
       FORBIDDEN_ENDINGS1 = [ "o", "a" ]
  character(len=2), dimension(5), parameter, public :: &       
       FORBIDDEN_ENDINGS2 = [ "mp", "ps", "vg", "lo", "la" ]
  character(len=3), dimension(16), parameter, public :: &
       FORBIDDEN_ENDINGS3 = [ "aux", "dvi", "evt", "evx", "f03", "f90", &
          "f95", "log", "ltp", "mpx", "olc", "olp", "pdf", "phs", "sin", "tex" ]
       
@ %def DEFAULT_ANALYSIS_FILENAME
@ %def FORBIDDEN_ENDINGS1
@ %def FORBIDDEN_ENDINGS2
@ %def FORBIDDEN_ENDINGS3
@ As this contains a lot of similar code to [[cmd_compile_analysis_execute]]
we outsource the main code to a subroutine.
<<Commands: cmd write analysis: TBP>>=
  procedure :: execute => cmd_write_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_write_analysis_execute (cmd, global)
    class(cmd_write_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    var_list => cmd%local%get_var_list_ptr ()
    call write_analysis_wrap (var_list, global%out_files, &
         cmd%id, tag = cmd%tag)
  end subroutine cmd_write_analysis_execute

@ %def cmd_write_analysis_execute   
@ If the [[data_file]] optional argument is present, this is 
called from [[cmd_compile_analysis_execute]], which needs the file name for
further processing, and requires the default format.  For the moment, 
parameters and macros for custom data processing are disabled.
<<Commands: procedures>>=
  subroutine write_analysis_wrap (var_list, out_files, id, tag, data_file)
    type(var_list_t), intent(inout), target :: var_list
    type(file_list_t), intent(inout), target :: out_files
    type(analysis_id_t), dimension(:), intent(in), target :: id 
    type(string_t), dimension(:), allocatable, intent(out) :: tag
    type(string_t), intent(out), optional :: data_file
    type(string_t) :: defaultfile, file
    integer :: i   
    logical :: keep_open !, custom, header, columns    
    type(string_t) :: extension !, comment_prefix, separator 
!!! JRR: WK please check (#542)           
!     integer :: type
!     type(ifile_t) :: ifile
    logical :: one_file !, has_writer
!     type(analysis_iterator_t) :: iterator
!     type(rt_data_t), target :: sandbox
!     type(command_list_t) :: writer    
    defaultfile = var_list%get_sval (var_str ("$out_file"))
    if (present (data_file)) then
       if (defaultfile == "" .or. defaultfile == ".") then
          defaultfile = DEFAULT_ANALYSIS_FILENAME
       else
          if (scan (".", defaultfile) > 0) then
             call split (defaultfile, extension, ".", back=.true.)
             if (any (lower_case (char(extension)) == FORBIDDEN_ENDINGS1) .or. &
                 any (lower_case (char(extension)) == FORBIDDEN_ENDINGS2) .or. &
                 any (lower_case (char(extension)) == FORBIDDEN_ENDINGS3)) & 
                 call msg_fatal ("The ending " // char(extension) // &
                 " is internal and not allowed as data file.")
             if (extension /= "") then
                if (defaultfile /= "") then
                   defaultfile = defaultfile // "." // extension
                else
                   defaultfile = "whizard_analysis." // extension
                end if
             else
                defaultfile = defaultfile // ".dat"
             endif
          else
             defaultfile = defaultfile // ".dat"
          end if
       end if
       data_file = defaultfile
    end if
    one_file = defaultfile /= ""
    if (one_file) then
       file = defaultfile
       keep_open = file_list_is_open (out_files, file, &
            action = "write")
       if (keep_open) then
          if (present (data_file)) then
             call msg_fatal ("Compiling analysis: File '" &
                  // char (data_file) &
                   // "' can't be used, it is already open.")
          else
             call msg_message ("Appending analysis data to file '" &
                  // char (file) // "'")
          end if
       else
          call file_list_open (out_files, file, &
               action = "write", status = "replace", position = "asis")
          call msg_message ("Writing analysis data to file '" &
               // char (file) // "'")          
       end if
    end if    

!!! JRR: WK please check. Custom data output. Ticket #542
!     if (present (data_file)) then
!        custom = .false.
!     else
!        custom = var_list%get_lval (&
!            var_str ("?out_custom"))
!     end if
!     comment_prefix = var_list%get_sval (&
!          var_str ("$out_comment"))
!     header = var_list%get_lval (&
!          var_str ("?out_header"))
!     write_yerr = var_list%get_lval (&
!          var_str ("?out_yerr"))
!     write_xerr = var_list%get_lval (&
!          var_str ("?out_xerr"))

    call get_analysis_tags (tag, id, var_list)       
    do i = 1, size (tag)
       call file_list_write_analysis &
            (out_files, file, tag(i))
    end do
    if (one_file .and. .not. keep_open) then
       call file_list_close (out_files, file)
    end if       

  contains
    
    subroutine get_analysis_tags (analysis_tag, id, var_list)
      type(string_t), dimension(:), intent(out), allocatable :: analysis_tag
      type(analysis_id_t), dimension(:), intent(in) :: id
      type(var_list_t), intent(in), target :: var_list
      if (size (id) /= 0) then
         allocate (analysis_tag (size (id)))
         do i = 1, size (id)
            if (associated (id(i)%pn_sexpr)) then
               analysis_tag(i) = eval_string (id(i)%pn_sexpr, var_list)
            else
               analysis_tag(i) = id(i)%tag
            end if
         end do
      else
         call analysis_store_get_ids (tag)                
      end if
    end subroutine get_analysis_tags
    
  end subroutine write_analysis_wrap
  
@ %def write_analysis_wrap
\subsubsection{Compile analysis results}
This command writes files in a form suitable for GAMELAN and executes the
appropriate commands to compile them.  The first part is identical to
[[cmd_write_analysis]].
<<Commands: types>>= 
  type, extends (command_t) :: cmd_compile_analysis_t
     private
     type(analysis_id_t), dimension(:), allocatable :: id
     type(string_t), dimension(:), allocatable :: tag
   contains
   <<Commands: cmd compile analysis: TBP>>
  end type cmd_compile_analysis_t

@ %def cmd_compile_analysis_t
@ Output.  Just the keyword.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: write => cmd_compile_analysis_write
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_write (cmd, unit, indent)
    class(cmd_compile_analysis_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "compile_analysis"
  end subroutine cmd_compile_analysis_write
  
@ %def cmd_compile_analysis_write
@ Compile.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: compile => cmd_compile_analysis_compile
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_compile (cmd, global)
    class(cmd_compile_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_clause, pn_args, pn_id
    integer :: n, i
    pn_clause => parse_node_get_sub_ptr (cmd%pn)
    pn_args => parse_node_get_sub_ptr (pn_clause, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_clause)
    call cmd%compile_options (global)
    if (associated (pn_args)) then
       n = parse_node_get_n_sub (pn_args)
       allocate (cmd%id (n))
       do i = 1, n
           pn_id => parse_node_get_sub_ptr (pn_args, i)
           if (char (parse_node_get_rule_key (pn_id)) == "analysis_id") then
              cmd%id(i)%tag = parse_node_get_string (pn_id)
           else
              cmd%id(i)%pn_sexpr => pn_id
           end if
       end do
    else
       allocate (cmd%id (0))       
    end if
  end subroutine cmd_compile_analysis_compile

@ %def cmd_compile_analysis_compile
@ First write the analysis data to file, then write a GAMELAN driver and
produce MetaPost and \TeX\ output.
<<Commands: cmd compile analysis: TBP>>=
  procedure :: execute => cmd_compile_analysis_execute
<<Commands: procedures>>=
  subroutine cmd_compile_analysis_execute (cmd, global)
    class(cmd_compile_analysis_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(string_t) :: file, basename, extension, driver_file, &
         makefile
    integer :: u_driver, u_makefile
    logical :: has_gmlcode, only_file
    var_list => cmd%local%get_var_list_ptr ()
    call write_analysis_wrap (var_list, &
         global%out_files, cmd%id, tag = cmd%tag, &
            data_file = file)
    basename = file    
    if (scan (".", basename) > 0) then
      call split (basename, extension, ".", back=.true.)
    else
      extension = ""
    end if
    driver_file = basename // ".tex"
    makefile = basename // "_ana.makefile"
    u_driver = free_unit ()
    open (unit=u_driver, file=char(driver_file), &
          action="write", status="replace")
    if (allocated (cmd%tag)) then
       call analysis_write_driver (file, cmd%tag, unit=u_driver)
       has_gmlcode = analysis_has_plots (cmd%tag)
    else
       call analysis_write_driver (file, unit=u_driver)
       has_gmlcode = analysis_has_plots ()
    end if
    close (u_driver)
    u_makefile = free_unit ()
    open (unit=u_makefile, file=char(makefile), &
         action="write", status="replace")
    call analysis_write_makefile (basename, u_makefile, &
         has_gmlcode, global%os_data)
    close (u_makefile)
    call msg_message ("Compiling analysis results display in '" &
         // char (driver_file) // "'")
    call msg_message ("Providing analysis steering makefile '" &
         // char (makefile) // "'")    
    only_file = global%var_list%get_lval &
         (var_str ("?analysis_file_only"))
    if (.not. only_file)  call analysis_compile_tex &
         (basename, has_gmlcode, global%os_data)
  end subroutine cmd_compile_analysis_execute

@ %def cmd_compile_analysis_execute
@ 
\subsection{User-controlled output to data files}

\subsubsection{Open file (output)}
Open a file for output.
<<Commands: types>>=
  type, extends (command_t) :: cmd_open_out_t
     private
     type(parse_node_t), pointer :: file_expr => null ()
   contains
   <<Commands: cmd open out: TBP>>
  end type cmd_open_out_t

@ %def cmd_open_out
@ Finalizer for the embedded eval tree.
<<Commands: procedures>>=
  subroutine cmd_open_out_final (object)
    class(cmd_open_out_t), intent(inout) :: object
  end subroutine cmd_open_out_final
  
@ %def cmd_open_out_final
@ Output (trivial here).
<<Commands: cmd open out: TBP>>=
  procedure :: write => cmd_open_out_write
<<Commands: procedures>>=
  subroutine cmd_open_out_write (cmd, unit, indent)
    class(cmd_open_out_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)  
    write (u, "(1x,A)", advance="no")  "open_out: <filename>"  
  end subroutine cmd_open_out_write
  
@ %def cmd_open_out_write
@ Compile: create an eval tree for the filename expression.
<<Commands: cmd open out: TBP>>=
  procedure :: compile => cmd_open_out_compile
<<Commands: procedures>>=
  subroutine cmd_open_out_compile (cmd, global)
    class(cmd_open_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    cmd%file_expr => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (cmd%file_expr)) then
       cmd%pn_opt => parse_node_get_next_ptr (cmd%file_expr)
    end if
    call cmd%compile_options (global)
  end subroutine cmd_open_out_compile

@ %def cmd_open_out_compile
@ Execute: append the file to the global list of open files.
<<Commands: cmd open out: TBP>>=
  procedure :: execute => cmd_open_out_execute
<<Commands: procedures>>=
  subroutine cmd_open_out_execute (cmd, global)
    class(cmd_open_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(eval_tree_t) :: file_expr
    type(string_t) :: file
    var_list => cmd%local%get_var_list_ptr ()
    call file_expr%init_sexpr (cmd%file_expr, var_list)
    call file_expr%evaluate ()
    if (file_expr%is_known ()) then
       file = file_expr%get_string ()
       call file_list_open (global%out_files, file, &
            action = "write", status = "replace", position = "asis")
    else
       call msg_fatal ("open_out: file name argument evaluates to unknown")
    end if
    call file_expr%final ()
  end subroutine cmd_open_out_execute

@ %def cmd_open_out_execute

\subsubsection{Open file (output)}
Close an output file.  Except for the [[execute]] method, everything is
analogous to the open command, so we can just inherit.
<<Commands: types>>=
  type, extends (cmd_open_out_t) :: cmd_close_out_t
     private
   contains
   <<Commands: cmd close out: TBP>>
  end type cmd_close_out_t

@ %def cmd_close_out
@ Execute: remove the file from the global list of output files.
<<Commands: cmd close out: TBP>>=
  procedure :: execute => cmd_close_out_execute
<<Commands: procedures>>=
  subroutine cmd_close_out_execute (cmd, global)
    class(cmd_close_out_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(eval_tree_t) :: file_expr
    type(string_t) :: file
    var_list => cmd%local%var_list
    call file_expr%init_sexpr (cmd%file_expr, var_list)
    call file_expr%evaluate ()
    if (file_expr%is_known ()) then
       file = file_expr%get_string ()
       call file_list_close (global%out_files, file)
    else
       call msg_fatal ("close_out: file name argument evaluates to unknown")
    end if
    call file_expr%final ()
  end subroutine cmd_close_out_execute

@ %def cmd_close_out_execute
@ 
\subsection{Print custom-formatted values}
<<Commands: types>>=
  type, extends (command_t) :: cmd_printf_t
     private
     type(parse_node_t), pointer :: sexpr => null ()
     type(parse_node_t), pointer :: sprintf_fun => null ()
     type(parse_node_t), pointer :: sprintf_clause => null ()
     type(parse_node_t), pointer :: sprintf => null ()
   contains
   <<Commands: cmd printf: TBP>>
  end type cmd_printf_t

@ %def cmd_printf_t
@ Finalize.
<<Commands: cmd printf: TBP>>=
  procedure :: final => cmd_printf_final
<<Commands: procedures>>=
  subroutine cmd_printf_final (cmd)
    class(cmd_printf_t), intent(inout) :: cmd
    call parse_node_final (cmd%sexpr, recursive = .false.)
    deallocate (cmd%sexpr)
    call parse_node_final (cmd%sprintf_fun, recursive = .false.)
    deallocate (cmd%sprintf_fun)
    call parse_node_final (cmd%sprintf_clause, recursive = .false.)
    deallocate (cmd%sprintf_clause)
    call parse_node_final (cmd%sprintf, recursive = .false.)
    deallocate (cmd%sprintf)
  end subroutine cmd_printf_final

@ %def cmd_printf_final
@ Output.  Do not print the parse tree, since this may get cluttered.
Just a message that cuts have been defined.
<<Commands: cmd printf: TBP>>=
  procedure :: write => cmd_printf_write
<<Commands: procedures>>=
  subroutine cmd_printf_write (cmd, unit, indent)
    class(cmd_printf_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "printf:"
  end subroutine cmd_printf_write
  
@ %def cmd_printf_write
@ Compile.  We create a fake parse node (subtree) with a [[sprintf]] command
with identical arguments which can then be handled by the corresponding
evaluation procedure.
<<Commands: cmd printf: TBP>>=
  procedure :: compile => cmd_printf_compile
<<Commands: procedures>>=
  subroutine cmd_printf_compile (cmd, global)
    class(cmd_printf_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd, pn_clause, pn_args, pn_format
    pn_cmd => parse_node_get_sub_ptr (cmd%pn)
    pn_clause => parse_node_get_sub_ptr (pn_cmd)
    pn_format => parse_node_get_sub_ptr (pn_clause, 2)
    pn_args => parse_node_get_next_ptr (pn_clause)
    cmd%pn_opt => parse_node_get_next_ptr (pn_cmd)
    call cmd%compile_options (global)
    allocate (cmd%sexpr)
    call parse_node_create_branch (cmd%sexpr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sexpr")))
    allocate (cmd%sprintf_fun)
    call parse_node_create_branch (cmd%sprintf_fun, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf_fun")))
    allocate (cmd%sprintf_clause)
    call parse_node_create_branch (cmd%sprintf_clause, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf_clause")))
    allocate (cmd%sprintf)
    call parse_node_create_key (cmd%sprintf, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("sprintf")))
    call parse_node_append_sub (cmd%sprintf_clause, cmd%sprintf)
    call parse_node_append_sub (cmd%sprintf_clause, pn_format)
    call parse_node_freeze_branch (cmd%sprintf_clause)
    call parse_node_append_sub (cmd%sprintf_fun, cmd%sprintf_clause)
    if (associated (pn_args)) then
       call parse_node_append_sub (cmd%sprintf_fun, pn_args)
    end if
    call parse_node_freeze_branch (cmd%sprintf_fun)
    call parse_node_append_sub (cmd%sexpr, cmd%sprintf_fun)
    call parse_node_freeze_branch (cmd%sexpr)
  end subroutine cmd_printf_compile

@ %def cmd_printf_compile
@ Execute.  Evaluate the string (pretending this is a [[sprintf]] expression)
and print it.
<<Commands: cmd printf: TBP>>=
  procedure :: execute => cmd_printf_execute
<<Commands: procedures>>=    
  subroutine cmd_printf_execute (cmd, global)
    class(cmd_printf_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(string_t) :: string, file
    type(eval_tree_t) :: sprintf_expr
    logical :: advance
    var_list => cmd%local%get_var_list_ptr ()
    advance = var_list%get_lval (&
         var_str ("?out_advance"))
    file = var_list%get_sval (&
         var_str ("$out_file"))
    call sprintf_expr%init_sexpr (cmd%sexpr, var_list)
    call sprintf_expr%evaluate ()
    if (sprintf_expr%is_known ()) then
       string = sprintf_expr%get_string ()
       if (len (file) == 0) then
          call msg_result (char (string))
       else
          call file_list_write (global%out_files, file, string, advance)
       end if
    end if
  end subroutine cmd_printf_execute

@ %def cmd_printf_execute
@
\subsubsection{Record data}
The expression syntax already contains a [[record]] keyword; this evaluates to
a logical which is always true, but it has the side-effect of recording data
into analysis objects.  Here we define a command as an interface to this
construct.
<<Commands: types>>=
  type, extends (command_t) :: cmd_record_t
     private
     type(parse_node_t), pointer :: pn_lexpr => null ()
   contains
   <<Commands: cmd record: TBP>>
  end type cmd_record_t
     
@ %def cmd_record_t
@ Output.  With the compile hack below, there is nothing of interest
to print here.
<<Commands: cmd record: TBP>>=
  procedure :: write => cmd_record_write
<<Commands: procedures>>=
  subroutine cmd_record_write (cmd, unit, indent)
    class(cmd_record_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)")  "record"
  end subroutine cmd_record_write
  
@ %def cmd_record_write
@ Compile.  This is a hack which transforms the [[record]] command
into a [[record]] expression, which we handle in the [[expressions]]
module.
<<Commands: cmd record: TBP>>=
  procedure :: compile => cmd_record_compile
<<Commands: procedures>>=
  subroutine cmd_record_compile (cmd, global)
    class(cmd_record_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_lexpr, pn_lsinglet, pn_lterm, pn_record
    call parse_node_create_branch (pn_lexpr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lexpr")))
    call parse_node_create_branch (pn_lsinglet, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lsinglet")))
    call parse_node_append_sub (pn_lexpr, pn_lsinglet)
    call parse_node_create_branch (pn_lterm, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("lterm")))
    call parse_node_append_sub (pn_lsinglet, pn_lterm)
    pn_record => parse_node_get_sub_ptr (cmd%pn)
    call parse_node_append_sub (pn_lterm, pn_record)
    cmd%pn_lexpr => pn_lexpr
  end subroutine cmd_record_compile

@ %def cmd_record_compile
@ Command execution.  Again, transfer this to the embedded expression
and just forget the logical result.
<<Commands: cmd record: TBP>>=
  procedure :: execute => cmd_record_execute
<<Commands: procedures>>=
  subroutine cmd_record_execute (cmd, global)
    class(cmd_record_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    logical :: lval
    var_list => global%get_var_list_ptr ()
    lval = eval_log (cmd%pn_lexpr, var_list)
  end subroutine cmd_record_execute

@ %def cmd_record_execute
@
\subsubsection{Unstable particles}
Mark a particle as unstable.  For each unstable particle, we store a
number of decay channels and compute their respective BRs.
<<Commands: types>>=
  type, extends (command_t) :: cmd_unstable_t
     private
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
     type(parse_node_t), pointer :: pn_prt_in => null ()
   contains
   <<Commands: cmd unstable: TBP>>
  end type cmd_unstable_t
     
@ %def cmd_unstable_t
@ Output: we know the process IDs.
<<Commands: cmd unstable: TBP>>=
  procedure :: write => cmd_unstable_write
<<Commands: procedures>>=
  subroutine cmd_unstable_write (cmd, unit, indent)
    class(cmd_unstable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0,1x,A)", advance="no")  &
         "unstable:", 1, "("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_unstable_write

@ %def cmd_unstable_write
@ Compile.  Initiate an eval tree for the decaying particle and
determine the decay channel process IDs.
<<Commands: cmd unstable: TBP>>=
  procedure :: compile => cmd_unstable_compile
<<Commands: procedures>>=
  subroutine cmd_unstable_compile (cmd, global)
    class(cmd_unstable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_proc
    integer :: i
    cmd%pn_prt_in => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_list => parse_node_get_next_ptr (cmd%pn_prt_in)
    if (associated (pn_list)) then
       select case (char (parse_node_get_rule_key (pn_list)))
       case ("unstable_arg")
          cmd%n_proc = parse_node_get_n_sub (pn_list)
          cmd%pn_opt => parse_node_get_next_ptr (pn_list)
       case default
          cmd%n_proc = 0
          cmd%pn_opt => pn_list
          pn_list => null ()
       end select
    end if       
    call cmd%compile_options (global)
    if (associated (pn_list)) then
       allocate (cmd%process_id (cmd%n_proc))
       pn_proc => parse_node_get_sub_ptr (pn_list)
       do i = 1, cmd%n_proc
          cmd%process_id(i) = parse_node_get_string (pn_proc)
          call cmd%local%process_stack%init_result_vars (cmd%process_id(i))
          pn_proc => parse_node_get_next_ptr (pn_proc)
       end do
    else
       allocate (cmd%process_id (0))
    end if
  end subroutine cmd_unstable_compile

@ %def cmd_unstable_compile
@ Command execution.  Evaluate the decaying particle and mark the decays in
the current model object.
<<Commands: cmd unstable: TBP>>=
  procedure :: execute => cmd_unstable_execute
<<Commands: procedures>>=
  subroutine cmd_unstable_execute (cmd, global)
    class(cmd_unstable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    logical :: auto_decays, auto_decays_radiative
    integer :: auto_decays_multiplicity
    logical :: isotropic_decay, diagonal_decay, polarized_decay
    integer :: decay_helicity
    type(pdg_array_t) :: pa_in
    integer :: pdg_in
    type(string_t) :: libname_cur, libname_dec
    type(string_t), dimension(:), allocatable :: auto_id, tmp_id
    integer :: n_proc_user
    integer :: i, u_tmp
    character(80) :: buffer
    var_list => cmd%local%get_var_list_ptr ()
    auto_decays = &
         var_list%get_lval (var_str ("?auto_decays"))
    if (auto_decays) then
       auto_decays_multiplicity = &
            var_list%get_ival (var_str ("auto_decays_multiplicity"))
       auto_decays_radiative = &
            var_list%get_lval (var_str ("?auto_decays_radiative"))
    end if
    isotropic_decay = &
         var_list%get_lval (var_str ("?isotropic_decay"))
    if (isotropic_decay) then
       diagonal_decay = .false.
       polarized_decay = .false.
    else
       diagonal_decay = &
            var_list%get_lval (var_str ("?diagonal_decay"))
       if (diagonal_decay) then
          polarized_decay = .false.
       else
          polarized_decay = &
               var_list%is_known (var_str ("decay_helicity"))
          if (polarized_decay) then
             decay_helicity = var_list%get_ival (var_str ("decay_helicity"))
          end if
       end if
    end if
    pa_in = eval_pdg_array (cmd%pn_prt_in, var_list)
    if (pdg_array_get_length (pa_in) /= 1) &
         call msg_fatal ("Unstable: decaying particle must be unique")
    pdg_in = pdg_array_get (pa_in, 1)
    n_proc_user = cmd%n_proc
    if (auto_decays) then
       call create_auto_decays (pdg_in, &
            auto_decays_multiplicity, auto_decays_radiative, &
            libname_dec, auto_id, cmd%local)
       allocate (tmp_id (cmd%n_proc + size (auto_id)))
       tmp_id(:cmd%n_proc) = cmd%process_id
       tmp_id(cmd%n_proc+1:) = auto_id
       call move_alloc (from = tmp_id, to = cmd%process_id)
       cmd%n_proc = size (cmd%process_id)
    end if
    libname_cur = cmd%local%prclib%get_name ()
    do i = 1, cmd%n_proc
       if (i == n_proc_user + 1) then
          call cmd%local%update_prclib &
               (cmd%local%prclib_stack%get_library_ptr (libname_dec))
       end if
       if (.not. global%process_stack%exists (cmd%process_id(i))) then
          call var_list_set_log (var_list, &
               var_str ("?decay_rest_frame"), .false., is_known = .true.)
          call integrate_process (cmd%process_id(i), cmd%local, global)
          call global%process_stack%fill_result_vars (cmd%process_id(i))
       end if
    end do
    call cmd%local%update_prclib &
         (cmd%local%prclib_stack%get_library_ptr (libname_cur))
    if (cmd%n_proc > 0) then
       if (polarized_decay) then
          call global%modify_particle (pdg_in, stable = .false., &
               decay = cmd%process_id, &
               isotropic_decay = .false., &
               diagonal_decay = .false., &
               decay_helicity = decay_helicity, &
               polarized = .false.)
       else
          call global%modify_particle (pdg_in, stable = .false., &
               decay = cmd%process_id, &
               isotropic_decay = isotropic_decay, &
               diagonal_decay = diagonal_decay, &
               polarized = .false.)
       end if
       u_tmp = free_unit ()
       open (u_tmp, status = "scratch", action = "readwrite")
       call show_unstable (global, pdg_in, u_tmp)
       rewind (u_tmp)
       do
          read (u_tmp, "(A)", end = 1)  buffer
          write (msg_buffer, "(A)")  trim (buffer)
          call msg_message ()
       end do
1      continue
       close (u_tmp)
    else
       call err_unstable (global, pdg_in)
    end if
  end subroutine cmd_unstable_execute

@ %def cmd_unstable_execute
@ Show data for the current unstable particle.  This is called both by
the [[unstable]] and by the [[show]] command.
<<Commands: procedures>>=
  subroutine show_unstable (global, pdg, u)
    type(rt_data_t), intent(in), target :: global
    integer, intent(in) :: pdg, u
    type(flavor_t) :: flv
    type(string_t), dimension(:), allocatable :: decay
    real(default), dimension(:), allocatable :: br
    real(default) :: width
    type(process_t), pointer :: process
    type(process_component_def_t), pointer :: prc_def
    type(string_t), dimension(:), allocatable :: prt_out, prt_out_str
    integer :: i, j
    call flv%init (pdg, global%model)
    call flv%get_decays (decay)
    if (.not. allocated (decay))  return
    allocate (prt_out_str (size (decay)))
    allocate (br (size (decay)))
    do i = 1, size (br)
       process => global%process_stack%get_process_ptr (decay(i))
       prc_def => process%get_component_def_ptr (1)
       call prc_def%get_prt_out (prt_out)
       prt_out_str(i) = prt_out(1)
       do j = 2, size (prt_out)
          prt_out_str(i) = prt_out_str(i) // ", " // prt_out(j)
       end do
       br(i) = process%get_integral ()
    end do
    if (all (br >= 0)) then
       if (any (br > 0)) then
          width = sum (br)
          br = br / sum (br)
          write (u, "(A)") "Unstable particle " &
               // char (flv%get_name ()) &
               // ": computed branching ratios:"
          do i = 1, size (br)
             write (u, "(2x,A,':'," // FMT_14 // ",3x,A)") &
                  char (decay(i)), br(i), char (prt_out_str(i))
          end do
          write (u, "(2x,'Total width ='," // FMT_14 // ",' GeV (computed)')")  width
          write (u, "(2x,'            ='," // FMT_14 // ",' GeV (preset)')") &
               flv%get_width ()
          if (flv%decays_isotropically ()) then
             write (u, "(2x,A)")  "Decay options: isotropic"
          else if (flv%decays_diagonal ()) then
             write (u, "(2x,A)")  "Decay options: &
                  &projection on diagonal helicity states"
          else if (flv%has_decay_helicity ()) then
             write (u, "(2x,A,1x,I0)")  "Decay options: projection onto helicity =", &
                  flv%get_decay_helicity ()
          else
             write (u, "(2x,A)")  "Decay options: helicity treated exactly"
          end if
       else
          call msg_fatal ("Unstable particle " &
               // char (flv%get_name ()) &
               // ": partial width vanishes for all decay channels")
       end if
    else
       call msg_fatal ("Unstable particle " &
               // char (flv%get_name ()) &
               // ": partial width is negative")
    end if
  end subroutine show_unstable
    
@ %def show_unstable
@ If no decays have been found, issue a non-fatal error.
<<Commands: procedures>>=
  subroutine err_unstable (global, pdg)
    type(rt_data_t), intent(in), target :: global
    integer, intent(in) :: pdg
    type(flavor_t) :: flv
    call flv%init (pdg, global%model)
    call msg_error ("Unstable: no allowed decays found for particle " &
         // char (flv%get_name ()) // ", keeping as stable")
  end subroutine err_unstable
    
@ %def err_unstable
@ Auto decays: create process IDs and make up process
configurations, using the PDG codes generated by the [[ds_table]] make
method.

We allocate and use a self-contained process library that contains only the
decay processes of the current particle.  When done, we revert the global
library pointer to the original library but return the name of the new one.
The new library becomes part of the global library stack and can thus be
referred to at any time.
<<Commands: procedures>>=
  subroutine create_auto_decays &
       (pdg_in, mult, rad, libname_dec, process_id, global)
    integer, intent(in) :: pdg_in
    integer, intent(in) :: mult
    logical, intent(in) :: rad
    type(string_t), intent(out) :: libname_dec
    type(string_t), dimension(:), allocatable, intent(out) :: process_id
    type(rt_data_t), intent(inout) :: global
    type(prclib_entry_t), pointer :: lib_entry
    type(process_library_t), pointer :: lib
    type(ds_table_t) :: ds_table
    type(split_constraints_t) :: constraints
    type(pdg_array_t), dimension(:), allocatable :: pa_out
    character(80) :: buffer
    character :: p_or_a
    type(string_t) :: process_string, libname_cur
    type(flavor_t) :: flv_in, flv_out
    type(string_t) :: prt_in
    type(string_t), dimension(:), allocatable :: prt_out
    type(process_configuration_t) :: prc_config
    integer :: i, j, k, n
    call flv_in%init (pdg_in, global%model)
    if (rad) then
       call constraints%init (2)
    else
       call constraints%init (3)
       call constraints%set (3, constrain_radiation ())
    end if
    call constraints%set (1, constrain_n_tot (mult))
    call constraints%set (2, &
         constrain_mass_sum (flv_in%get_mass (), margin = 0._default))
    call ds_table%make (global%model, pdg_in, constraints)
    prt_in = flv_in%get_name ()
    if (pdg_in > 0) then
       p_or_a = "p"
    else
       p_or_a = "a"
    end if
    if (ds_table%get_length () == 0) then
       call msg_warning ("Auto-decays: Particle " // char (prt_in) // ": " &
            // "no decays found")
       libname_dec = ""
       allocate (process_id (0))
    else
       call msg_message ("Creating decay process library for particle " &
            // char (prt_in))
       libname_cur = global%prclib%get_name () 
       write (buffer, "(A,A,I0)")  "_d", p_or_a, abs (pdg_in)
       libname_dec = libname_cur // trim (buffer)
       lib => global%prclib_stack%get_library_ptr (libname_dec)
       if (.not. (associated (lib))) then
          allocate (lib_entry)
          call lib_entry%init (libname_dec)
          lib => lib_entry%process_library_t
          call global%add_prclib (lib_entry)
       else
          call global%update_prclib (lib)
       end if
       allocate (process_id (ds_table%get_length ()))
       do i = 1, size (process_id)
          write (buffer, "(A,'_',A,I0,'_',I0)") &
               "decay", p_or_a, abs (pdg_in), i
          process_id(i) = trim (buffer)
          process_string = process_id(i) // ": " // prt_in // " =>"
          call ds_table%get_pdg_out (i, pa_out)
          allocate (prt_out (size (pa_out)))
          do j = 1, size (pa_out)
             do k = 1, pa_out(j)%get_length ()
                call flv_out%init (pa_out(j)%get (k), global%model)
                if (k == 1) then
                   prt_out(j) = flv_out%get_name ()
                else
                   prt_out(j) = prt_out(j) // ":" // flv_out%get_name ()
                end if
             end do
             process_string = process_string // " " // prt_out(j)
          end do
          call msg_message (char (process_string))
          call prc_config%init (process_id(i), 1, 1, global)
          !!! Causes runtime error with gfortran 4.9.1 
          ! call prc_config%setup_component (1, &
          !      new_prt_spec ([prt_in]), new_prt_spec (prt_out), global)
          !!! Workaround:
          call prc_config%setup_component (1, &
               [new_prt_spec (prt_in)], new_prt_spec (prt_out), global)       
          call prc_config%record (global)
          deallocate (prt_out)
          deallocate (pa_out)
       end do
       lib => global%prclib_stack%get_library_ptr (libname_cur)
       call global%update_prclib (lib)
    end if
    call ds_table%final ()
  end subroutine create_auto_decays
    
@ %def create_auto_decays
@ 
\subsubsection{(Stable particles}
Revert the unstable declaration for a list of particles.
<<Commands: types>>=
  type, extends (command_t) :: cmd_stable_t
     private
     type(parse_node_p), dimension(:), allocatable :: pn_pdg
   contains
   <<Commands: cmd stable: TBP>>
  end type cmd_stable_t
  
@ %def cmd_stable_t
@ Output: we know only the number of particles.
<<Commands: cmd stable: TBP>>=
  procedure :: write => cmd_stable_write
<<Commands: procedures>>=
  subroutine cmd_stable_write (cmd, unit, indent)
    class(cmd_stable_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "stable:", size (cmd%pn_pdg)
  end subroutine cmd_stable_write

@ %def cmd_stable_write
@ Compile.  Assign parse nodes for the particle IDs.
<<Commands: cmd stable: TBP>>=
  procedure :: compile => cmd_stable_compile
<<Commands: procedures>>=
  subroutine cmd_stable_compile (cmd, global)
    class(cmd_stable_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_list, pn_prt
    integer :: n, i
    pn_list => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_list)
    call cmd%compile_options (global)
    n = parse_node_get_n_sub (pn_list)
    allocate (cmd%pn_pdg (n))
    pn_prt => parse_node_get_sub_ptr (pn_list)
    i = 1
    do while (associated (pn_prt))
       cmd%pn_pdg(i)%ptr => pn_prt
       pn_prt  => parse_node_get_next_ptr (pn_prt)
       i = i + 1
    end do
  end subroutine cmd_stable_compile

@ %def cmd_stable_compile
@ Execute: apply the modifications to the current model.
<<Commands: cmd stable: TBP>>=
  procedure :: execute => cmd_stable_execute
<<Commands: procedures>>=
  subroutine cmd_stable_execute (cmd, global)
    class(cmd_stable_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(var_list_t), pointer :: var_list
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    var_list => cmd%local%get_var_list_ptr ()
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Stable: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call global%modify_particle (pdg, stable = .true., &
         isotropic_decay = .false., &
         diagonal_decay = .false., &
         polarized = .false.)
       call flv%init (pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flv%get_name ()) &
            // " declared as stable")
    end do
  end subroutine cmd_stable_execute
  
@ %def cmd_stable_execute
@ 
\subsubsection{Polarized particles}
These commands mark particles as (un)polarized, to be applied in
subsequent simulation passes.  Since this is technically the same as
the [[stable]] command, we take a shortcut and make this an extension,
just overriding methods.
<<Commands: types>>=
  type, extends (cmd_stable_t) :: cmd_polarized_t
   contains
   <<Commands: cmd polarized: TBP>>
  end type cmd_polarized_t
  
  type, extends (cmd_stable_t) :: cmd_unpolarized_t
   contains
   <<Commands: cmd unpolarized: TBP>>
  end type cmd_unpolarized_t
  
@ %def cmd_polarized_t cmd_unpolarized_t
@ Output: we know only the number of particles.
<<Commands: cmd polarized: TBP>>=
  procedure :: write => cmd_polarized_write
<<Commands: cmd unpolarized: TBP>>=
  procedure :: write => cmd_unpolarized_write
<<Commands: procedures>>=
  subroutine cmd_polarized_write (cmd, unit, indent)
    class(cmd_polarized_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "polarized:", size (cmd%pn_pdg)
  end subroutine cmd_polarized_write

  subroutine cmd_unpolarized_write (cmd, unit, indent)
    class(cmd_unpolarized_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,I0)")  "unpolarized:", size (cmd%pn_pdg)
  end subroutine cmd_unpolarized_write

@ %def cmd_polarized_write
@ %def cmd_unpolarized_write
@ Compile: accounted for by the base command.

Execute: apply the modifications to the current model.
<<Commands: cmd polarized: TBP>>=
  procedure :: execute => cmd_polarized_execute
<<Commands: cmd unpolarized: TBP>>=
  procedure :: execute => cmd_unpolarized_execute
<<Commands: procedures>>=
  subroutine cmd_polarized_execute (cmd, global)
    class(cmd_polarized_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(var_list_t), pointer :: var_list
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    var_list => cmd%local%get_var_list_ptr ()
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Polarized: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call global%modify_particle (pdg, polarized = .true., &
            stable = .true., &
            isotropic_decay = .false., &
            diagonal_decay = .false.)
       call flv%init (pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flv%get_name ()) &
            // " declared as polarized")
    end do
  end subroutine cmd_polarized_execute
  
  subroutine cmd_unpolarized_execute (cmd, global)
    class(cmd_unpolarized_t), intent(inout) :: cmd
    type(rt_data_t), target, intent(inout) :: global
    type(var_list_t), pointer :: var_list
    type(pdg_array_t) :: pa
    integer :: pdg
    type(flavor_t) :: flv
    integer :: i
    var_list => cmd%local%get_var_list_ptr ()
    do i = 1, size (cmd%pn_pdg)
       pa = eval_pdg_array (cmd%pn_pdg(i)%ptr, var_list)
       if (pdg_array_get_length (pa) /= 1) &
            call msg_fatal ("Unpolarized: listed particles must be unique")
       pdg = pdg_array_get (pa, 1)
       call global%modify_particle (pdg, polarized = .false., &
            stable = .true., &
            isotropic_decay = .false., &
            diagonal_decay = .false.)
       call flv%init (pdg, cmd%local%model)
       call msg_message ("Particle " &
            // char (flv%get_name ()) &
            // " declared as unpolarized")
    end do
  end subroutine cmd_unpolarized_execute
  
@ %def cmd_polarized_execute
@ %def cmd_unpolarized_execute
@
\subsubsection{Parameters: formats for event-sample output}
Specify all event formats that are to be used for output files in the
subsequent simulation run.  (The raw format is on by default and can be turned
off here.)
<<Commands: types>>=
  type, extends (command_t) :: cmd_sample_format_t
     private
     type(string_t), dimension(:), allocatable :: format
   contains
   <<Commands: cmd sample format: TBP>>
  end type cmd_sample_format_t

@ %def cmd_sample_format_t
@ Output: here, everything is known.
<<Commands: cmd sample format: TBP>>=
  procedure :: write => cmd_sample_format_write
<<Commands: procedures>>=
  subroutine cmd_sample_format_write (cmd, unit, indent)
    class(cmd_sample_format_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "sample_format = "
    do i = 1, size (cmd%format)
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%format(i))
    end do
    write (u, "(A)")
  end subroutine cmd_sample_format_write
  
@ %def cmd_sample_format_write
@ Compile.  Initialize evaluation trees.
<<Commands: cmd sample format: TBP>>=
  procedure :: compile => cmd_sample_format_compile
<<Commands: procedures>>=
  subroutine cmd_sample_format_compile (cmd, global)
    class(cmd_sample_format_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    type(parse_node_t), pointer :: pn_format
    integer :: i, n_format
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_arg)) then
       n_format = parse_node_get_n_sub (pn_arg)
       allocate (cmd%format (n_format))
       pn_format => parse_node_get_sub_ptr (pn_arg)
       i = 0
       do while (associated (pn_format))
          i = i + 1
          cmd%format(i) = parse_node_get_string (pn_format)
          pn_format => parse_node_get_next_ptr (pn_format)
       end do
    else
       allocate (cmd%format (0))
    end if
  end subroutine cmd_sample_format_compile

@ %def cmd_sample_format_compile
@ Execute.  Transfer the list of format specifications to the
corresponding array in the runtime data set.
<<Commands: cmd sample format: TBP>>=
  procedure :: execute => cmd_sample_format_execute
<<Commands: procedures>>=
  subroutine cmd_sample_format_execute (cmd, global)
    class(cmd_sample_format_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (allocated (global%sample_fmt))  deallocate (global%sample_fmt)
    allocate (global%sample_fmt (size (cmd%format)), source = cmd%format)
  end subroutine cmd_sample_format_execute

@ %def cmd_sample_format_execute
@
\subsubsection{The simulate command}
This is the actual SINDARIN command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_simulate_t
     ! not private anymore as required by the whizard-c-interface
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd simulate: TBP>>
  end type cmd_simulate_t

@ %def cmd_simulate_t
@ Output: we know the process IDs.
<<Commands: cmd simulate: TBP>>=
  procedure :: write => cmd_simulate_write
<<Commands: procedures>>=
  subroutine cmd_simulate_write (cmd, unit, indent)
    class(cmd_simulate_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "simulate ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_simulate_write

@ %def cmd_simulate_write
@ Compile. In contrast to WHIZARD 1 the confusing option to give the
number of unweighted events for weighted events as if unweighting were
to take place has been abandoned. (We both use [[n_events]] for
weighted and unweighted events, the variable [[n_calls]] from WHIZARD
1 has been discarded.
<<Commands: cmd simulate: TBP>>=
  procedure :: compile => cmd_simulate_compile
<<Commands: procedures>>=
  subroutine cmd_simulate_compile (cmd, global)
    class(cmd_simulate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_proclist, pn_proc
    integer :: i
    pn_proclist => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       call global%process_stack%init_result_vars (cmd%process_id(i))
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_simulate_compile

@ %def cmd_simulate_compile
@ Execute command:  Simulate events.  This is done via a [[simulation_t]]
object and its associated methods.

Signal handling: the [[generate]] method may exit abnormally if there is a
pending signal.  The current logic ensures that the [[es_array]] output
channels are closed before the [[execute]] routine returns.  The program will
terminate then in [[command_list_execute]].
<<Commands: cmd simulate: TBP>>=
  procedure :: execute => cmd_simulate_execute
<<Commands: procedures>>=
  subroutine cmd_simulate_execute (cmd, global)
    class(cmd_simulate_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(rt_data_t), dimension(:), allocatable, target :: alt_env
    integer :: n_events, n_fmt
    type(string_t) :: sample
    logical :: rebuild_events, read_raw, write_raw
    type(simulation_t), target :: sim
    type(string_t), dimension(:), allocatable :: sample_fmt
    type(event_stream_array_t) :: es_array
    type(event_sample_data_t) :: data
    integer :: i, checkpoint
    var_list => cmd%local%var_list
    if (allocated (cmd%local%pn%alt_setup)) then
       allocate (alt_env (size (cmd%local%pn%alt_setup)))
       do i = 1, size (alt_env)
          call build_alt_setup (alt_env(i), cmd%local, &
               cmd%local%pn%alt_setup(i)%ptr)
       end do
       call sim%init (cmd%process_id, .true., .true., cmd%local, global, &
            alt_env)
    else
       call sim%init (cmd%process_id, .true., .true., cmd%local, global)
    end if
    if (signal_is_pending ())  return
    if (sim%is_valid ()) then
       call sim%init_process_selector ()    
       call openmp_set_num_threads_verbose &
            (var_list%get_ival (var_str ("openmp_num_threads")), &
            var_list%get_lval (var_str ("?openmp_logging")))
       call sim%compute_n_events (n_events, var_list)
       sample = var_list%get_sval (var_str ("$sample"))
       if (sample == "")  sample = sim%get_default_sample_name ()
       rebuild_events = &
            var_list%get_lval (var_str ("?rebuild_events"))
       read_raw = &
            var_list%get_lval (var_str ("?read_raw")) &
            .and. .not. rebuild_events
       write_raw = &
            var_list%get_lval (var_str ("?write_raw"))
       checkpoint = &
            var_list%get_ival (var_str ("checkpoint"))
       if (read_raw) then
          inquire (file = char (sample) // ".evx", exist = read_raw)
       end if
       if (allocated (cmd%local%sample_fmt)) then
          n_fmt = size (cmd%local%sample_fmt)
       else
          n_fmt = 0
       end if
       data = sim%get_data ()
       data%n_evt = n_events
       if (read_raw) then
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
          call es_array%init (sample, &
               sample_fmt, cmd%local, &
               data = data, &
               input = var_str ("raw"), &
               allow_switch = write_raw, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else if (write_raw) then
          allocate (sample_fmt (n_fmt + 1))
          if (n_fmt > 0)  sample_fmt(:n_fmt) = cmd%local%sample_fmt
          sample_fmt(n_fmt+1) = var_str ("raw")
          call es_array%init (sample, &
               sample_fmt, cmd%local, &
               data = data, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else if (allocated (cmd%local%sample_fmt) .or. checkpoint > 0) then
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
          call es_array%init (sample, &
               sample_fmt, cmd%local, &
               data = data, &
               checkpoint = checkpoint)
          call sim%generate (n_events, es_array)
          call es_array%final ()
       else
          call sim%generate (n_events)
       end if
       if (allocated (alt_env)) then
          do i = 1, size (alt_env)
             call alt_env(i)%local_final ()
          end do
       end if
    end if
    call sim%final ()
  end subroutine cmd_simulate_execute

@ %def cmd_simulate_execute
@ Build an alternative setup: the parse tree is stored in the global
environment.  We create a temporary command list to compile and execute this;
the result is an alternative local environment [[alt_env]] which we can hand
over to the [[simulate]] command.
<<Commands: procedures>>=
  recursive subroutine build_alt_setup (alt_env, global, pn)
    type(rt_data_t), intent(inout), target :: alt_env
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), intent(in), target :: pn
    type(command_list_t), allocatable :: alt_options
    allocate (alt_options)
    call alt_env%local_init (global)
    call alt_env%activate ()
    call alt_options%compile (pn, alt_env)
    call alt_options%execute (alt_env)
    call alt_env%deactivate (global, keep_local = .true.)
    call alt_options%final ()
  end subroutine build_alt_setup
            
@ %def build_alt_setup
@
\subsubsection{The rescan command}
This is the actual SINDARIN command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_rescan_t
     ! private
     type(parse_node_t), pointer :: pn_filename => null ()
     integer :: n_proc = 0
     type(string_t), dimension(:), allocatable :: process_id
   contains
   <<Commands: cmd rescan: TBP>>
  end type cmd_rescan_t

@ %def cmd_rescan_t
@ Output: we know the process IDs.
<<Commands: cmd rescan: TBP>>=
  procedure :: write => cmd_rescan_write
<<Commands: procedures>>=
  subroutine cmd_rescan_write (cmd, unit, indent)
    class(cmd_rescan_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, i
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A)", advance="no")  "rescan ("
    do i = 1, cmd%n_proc
       if (i > 1)  write (u, "(A,1x)", advance="no")  ","
       write (u, "(A)", advance="no")  char (cmd%process_id(i))
    end do
    write (u, "(A)")  ")"
  end subroutine cmd_rescan_write

@ %def cmd_rescan_write
@ Compile.  The command takes a suffix argument, namely the file name
of requested event file.
<<Commands: cmd rescan: TBP>>=
  procedure :: compile => cmd_rescan_compile
<<Commands: procedures>>=
  subroutine cmd_rescan_compile (cmd, global)
    class(cmd_rescan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_filename, pn_proclist, pn_proc
    integer :: i
    pn_filename => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_proclist => parse_node_get_next_ptr (pn_filename)
    cmd%pn_opt => parse_node_get_next_ptr (pn_proclist)
    call cmd%compile_options (global)
    cmd%pn_filename => pn_filename
    cmd%n_proc = parse_node_get_n_sub (pn_proclist)
    allocate (cmd%process_id (cmd%n_proc))
    pn_proc => parse_node_get_sub_ptr (pn_proclist)
    do i = 1, cmd%n_proc
       cmd%process_id(i) = parse_node_get_string (pn_proc)
       pn_proc => parse_node_get_next_ptr (pn_proc)
    end do
  end subroutine cmd_rescan_compile

@ %def cmd_rescan_compile
@ Execute command:  Rescan events.  This is done via a [[simulation_t]]
object and its associated methods.
<<Commands: cmd rescan: TBP>>=
  procedure :: execute => cmd_rescan_execute
<<Commands: procedures>>=
  subroutine cmd_rescan_execute (cmd, global)
    class(cmd_rescan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(rt_data_t), dimension(:), allocatable, target :: alt_env
    type(string_t) :: sample
    logical :: exist, write_raw, update_event, update_sqme, update_weight
    type(simulation_t), target :: sim
    type(event_sample_data_t) :: input_data, data
    type(string_t) :: input_sample
    integer :: n_fmt
    type(string_t), dimension(:), allocatable :: sample_fmt
    type(string_t) :: input_format, input_ext, input_file
    type(string_t) :: lhef_extension, extension_hepmc, extension_lcio
    type(event_stream_array_t) :: es_array
    integer :: i, n_events
    var_list => cmd%local%var_list
    if (allocated (cmd%local%pn%alt_setup)) then
       allocate (alt_env (size (cmd%local%pn%alt_setup)))
       do i = 1, size (alt_env)
          call build_alt_setup (alt_env(i), cmd%local, &
               cmd%local%pn%alt_setup(i)%ptr)
       end do
       call sim%init (cmd%process_id, .false., .false., cmd%local, global, &
            alt_env)
    else
       call sim%init (cmd%process_id, .false., .false., cmd%local, global)
    end if
    call sim%compute_n_events (n_events, var_list)
    input_sample = eval_string (cmd%pn_filename, var_list)
    input_format = var_list%get_sval (&
         var_str ("$rescan_input_format"))
    sample = var_list%get_sval (var_str ("$sample"))
    if (sample == "")  sample = sim%get_default_sample_name ()
    write_raw = var_list%get_lval (var_str ("?write_raw"))
    if (allocated (cmd%local%sample_fmt)) then
       n_fmt = size (cmd%local%sample_fmt)
    else
       n_fmt = 0
    end if
    if (write_raw) then
       if (sample == input_sample) then
          call msg_error ("Rescan: ?write_raw = true: " &
               // "suppressing raw event output (filename clashes with input)")
          allocate (sample_fmt (n_fmt))
          if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
       else
          allocate (sample_fmt (n_fmt + 1))
          if (n_fmt > 0)  sample_fmt(:n_fmt) = cmd%local%sample_fmt
          sample_fmt(n_fmt+1) = var_str ("raw")
       end if
    else
       allocate (sample_fmt (n_fmt))
       if (n_fmt > 0)  sample_fmt = cmd%local%sample_fmt
    end if
    update_event = &
         var_list%get_lval (var_str ("?update_event"))
    update_sqme = &
         var_list%get_lval (var_str ("?update_sqme"))
    update_weight = &
         var_list%get_lval (var_str ("?update_weight"))
    if (update_event .or. update_sqme) then
       call msg_message ("Recalculating observables")
       if (update_sqme) then
          call msg_message ("Recalculating squared matrix elements")
       end if
    end if
    lhef_extension = &
         var_list%get_sval (var_str ("$lhef_extension"))
    extension_hepmc = &
         var_list%get_sval (var_str ("$extension_hepmc"))
    extension_lcio = &
         var_list%get_sval (var_str ("$extension_lcio"))
    select case (char (input_format))
    case ("raw");  input_ext = "evx"
       call cmd%local%set_log &
            (var_str ("?recover_beams"), .false., is_known=.true.)
    case ("lhef"); input_ext = lhef_extension
    case ("hepmc"); input_ext = extension_hepmc
    case default
       call msg_fatal ("rescan: input sample format '" // char (input_format) &
            // "' not supported")
    end select
    input_file = input_sample // "." // input_ext
    inquire (file = char (input_file), exist = exist)
    if (exist) then
       input_data = sim%get_data (alt = .false.)
       input_data%n_evt = n_events
       data = sim%get_data ()
       data%n_evt = n_events
       input_data%md5sum_cfg = ""
       call es_array%init (sample, &
            sample_fmt, cmd%local, data, &
            input = input_format, input_sample = input_sample, &
            input_data = input_data, &
            allow_switch = .false.)
       call sim%rescan (n_events, es_array, global = cmd%local)
       call es_array%final ()
    else
       call msg_fatal ("Rescan: event file '" &
            // char (input_file) // "' not found")
    end if
    if (allocated (alt_env)) then
       do i = 1, size (alt_env)
          call alt_env(i)%local_final ()
       end do
    end if
    call sim%final ()
  end subroutine cmd_rescan_execute

@ %def cmd_rescan_execute
@ 
\subsubsection{Parameters: number of iterations}
Specify number of iterations and number of calls for one integration pass.
<<Commands: types>>=
  type, extends (command_t) :: cmd_iterations_t
     private
     integer :: n_pass = 0
     type(parse_node_p), dimension(:), allocatable :: pn_expr_n_it
     type(parse_node_p), dimension(:), allocatable :: pn_expr_n_calls
     type(parse_node_p), dimension(:), allocatable :: pn_sexpr_adapt
   contains
   <<Commands: cmd iterations: TBP>>
  end type cmd_iterations_t

@ %def cmd_iterations_t
@ Output.  Display the number of passes, which is known after compilation.
<<Commands: cmd iterations: TBP>>=
  procedure :: write => cmd_iterations_write
<<Commands: procedures>>=
  subroutine cmd_iterations_write (cmd, unit, indent)
    class(cmd_iterations_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    select case (cmd%n_pass)
    case (0)
       write (u, "(1x,A)")  "iterations: [empty]"
    case (1)
       write (u, "(1x,A,I0,A)")  "iterations: ", cmd%n_pass, " pass"
    case default
       write (u, "(1x,A,I0,A)")  "iterations: ", cmd%n_pass, " passes"
    end select
  end subroutine cmd_iterations_write

@ %def cmd_iterations_write
@ Compile.  Initialize evaluation trees.
<<Commands: cmd iterations: TBP>>=
  procedure :: compile => cmd_iterations_compile
<<Commands: procedures>>=
  subroutine cmd_iterations_compile (cmd, global)
    class(cmd_iterations_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_n_it, pn_n_calls, pn_adapt
    type(parse_node_t), pointer :: pn_it_spec, pn_calls_spec, pn_adapt_spec
    integer :: i
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 3)
    if (associated (pn_arg)) then
       cmd%n_pass = parse_node_get_n_sub (pn_arg)
       allocate (cmd%pn_expr_n_it (cmd%n_pass))
       allocate (cmd%pn_expr_n_calls (cmd%n_pass))
       allocate (cmd%pn_sexpr_adapt (cmd%n_pass))
       pn_it_spec => parse_node_get_sub_ptr (pn_arg)
       i = 1
       do while (associated (pn_it_spec))
          pn_n_it => parse_node_get_sub_ptr (pn_it_spec)
          pn_calls_spec => parse_node_get_next_ptr (pn_n_it)
          pn_n_calls => parse_node_get_sub_ptr (pn_calls_spec, 2)
          pn_adapt_spec => parse_node_get_next_ptr (pn_calls_spec)
          if (associated (pn_adapt_spec)) then
             pn_adapt => parse_node_get_sub_ptr (pn_adapt_spec, 2)
          else
             pn_adapt => null ()
          end if
          cmd%pn_expr_n_it(i)%ptr => pn_n_it
          cmd%pn_expr_n_calls(i)%ptr => pn_n_calls
          cmd%pn_sexpr_adapt(i)%ptr => pn_adapt
          i = i + 1
          pn_it_spec => parse_node_get_next_ptr (pn_it_spec)
       end do
    else
       allocate (cmd%pn_expr_n_it (0))
       allocate (cmd%pn_expr_n_calls (0))
    end if
  end subroutine cmd_iterations_compile

@ %def cmd_iterations_compile
@ Execute.  Evaluate the trees and transfer the results to the iteration
list in the runtime data set.
<<Commands: cmd iterations: TBP>>=
  procedure :: execute => cmd_iterations_execute
<<Commands: procedures>>=
  subroutine cmd_iterations_execute (cmd, global)
    class(cmd_iterations_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    integer, dimension(cmd%n_pass) :: n_it, n_calls
    logical, dimension(cmd%n_pass) :: custom_adapt
    type(string_t), dimension(cmd%n_pass) :: adapt_code
    integer :: i
    var_list => global%get_var_list_ptr ()
    do i = 1, cmd%n_pass
       n_it(i) = eval_int (cmd%pn_expr_n_it(i)%ptr, var_list)
       n_calls(i) = &
            eval_int (cmd%pn_expr_n_calls(i)%ptr, var_list)
       if (associated (cmd%pn_sexpr_adapt(i)%ptr)) then
          adapt_code(i) = &
               eval_string (cmd%pn_sexpr_adapt(i)%ptr, &
                            var_list, is_known = custom_adapt(i))
       else
          custom_adapt(i) = .false.
       end if        
    end do
    call global%it_list%init (n_it, n_calls, custom_adapt, adapt_code)
  end subroutine cmd_iterations_execute

@ %def cmd_iterations_execute
@ 
\subsubsection{Range expressions}
We need a special type for storing and evaluating range expressions.
<<Commands: parameters>>=
  integer, parameter :: STEP_NONE = 0
  integer, parameter :: STEP_ADD = 1
  integer, parameter :: STEP_SUB = 2
  integer, parameter :: STEP_MUL = 3
  integer, parameter :: STEP_DIV = 4
  integer, parameter :: STEP_COMP_ADD = 11
  integer, parameter :: STEP_COMP_MUL = 13
@ 
There is an abstract base type and two implementations: scan over integers and
scan over reals.
<<Commands: types>>=
  type, abstract :: range_t
     type(parse_node_t), pointer :: pn_expr => null ()
     type(parse_node_t), pointer :: pn_term => null ()
     type(parse_node_t), pointer :: pn_factor => null ()
     type(parse_node_t), pointer :: pn_value => null ()
     type(parse_node_t), pointer :: pn_literal => null ()
     type(parse_node_t), pointer :: pn_beg => null ()
     type(parse_node_t), pointer :: pn_end => null ()
     type(parse_node_t), pointer :: pn_step => null ()
     type(eval_tree_t) :: expr_beg
     type(eval_tree_t) :: expr_end
     type(eval_tree_t) :: expr_step
     integer :: step_mode = 0
     integer :: n_step = 0
   contains
   <<Commands: range: TBP>>
  end type range_t
     
@ %def range_t
@ These are the implementations:
<<Commands: types>>=
  type, extends (range_t) :: range_int_t
     integer :: i_beg = 0
     integer :: i_end = 0
     integer :: i_step = 0
   contains
   <<Commands: range int: TBP>>
end type range_int_t
     
  type, extends (range_t) :: range_real_t
     real(default) :: r_beg = 0
     real(default) :: r_end = 0
     real(default) :: r_step = 0
     real(default) :: lr_beg  = 0
     real(default) :: lr_end  = 0
     real(default) :: lr_step = 0
   contains
   <<Commands: range real: TBP>>
end type range_real_t
     
@ %def range_int_t range_real_t
@ Finalize the allocated dummy node.  The other nodes are just pointers.
<<Commands: range: TBP>>=
  procedure :: final => range_final
<<Commands: procedures>>=
  subroutine range_final (object)
    class(range_t), intent(inout) :: object
    if (associated (object%pn_expr)) then
       call parse_node_final (object%pn_expr, recursive = .false.)
       call parse_node_final (object%pn_term, recursive = .false.)
       call parse_node_final (object%pn_factor, recursive = .false.)
       call parse_node_final (object%pn_value, recursive = .false.)
       call parse_node_final (object%pn_literal, recursive = .false.)
       deallocate (object%pn_expr)
       deallocate (object%pn_term)
       deallocate (object%pn_factor)
       deallocate (object%pn_value)
       deallocate (object%pn_literal)
    end if
  end subroutine range_final
  
@ %def range_final
@ Output.
<<Commands: range: TBP>>=
  procedure (range_write), deferred :: write
  procedure :: base_write => range_write
<<Commands: range int: TBP>>=
  procedure :: write => range_int_write
<<Commands: range real: TBP>>=
  procedure :: write => range_real_write
<<Commands: procedures>>=
  subroutine range_write (object, unit)
    class(range_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    write (u, "(1x,A)")  "Range specification:"
    if (associated (object%pn_expr)) then
       write (u, "(1x,A)")  "Dummy value:"
       call parse_node_write_rec (object%pn_expr, u)
    end if
    if (associated (object%pn_beg)) then
       write (u, "(1x,A)")  "Initial value:"
       call parse_node_write_rec (object%pn_beg, u)
       call object%expr_beg%write (u)
       if (associated (object%pn_end)) then
          write (u, "(1x,A)")  "Final value:"
          call parse_node_write_rec (object%pn_end, u)
          call object%expr_end%write (u)
          if (associated (object%pn_step)) then
             write (u, "(1x,A)")  "Step value:"
             call parse_node_write_rec (object%pn_step, u)
             select case (object%step_mode)
             case (STEP_ADD);   write (u, "(1x,A)")  "Step mode: +"
             case (STEP_SUB);   write (u, "(1x,A)")  "Step mode: -"
             case (STEP_MUL);   write (u, "(1x,A)")  "Step mode: *"
             case (STEP_DIV);   write (u, "(1x,A)")  "Step mode: /"
             case (STEP_COMP_ADD);  write (u, "(1x,A)")  "Division mode: +"
             case (STEP_COMP_MUL);  write (u, "(1x,A)")  "Division mode: *"
             end select
          end if
       end if
    else
       write (u, "(1x,A)")  "Expressions: [undefined]"
    end if
  end subroutine range_write

  subroutine range_int_write (object, unit)
    class(range_int_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (unit)
    write (u, "(1x,A)")  "Range parameters:"
    write (u, "(3x,A,I0)")  "i_beg  = ", object%i_beg
    write (u, "(3x,A,I0)")  "i_end  = ", object%i_end
    write (u, "(3x,A,I0)")  "i_step = ", object%i_step
    write (u, "(3x,A,I0)")  "n_step = ", object%n_step
  end subroutine range_int_write
  
  subroutine range_real_write (object, unit)
    class(range_real_t), intent(in) :: object
    integer, intent(in), optional :: unit
    integer :: u
    u = given_output_unit (unit)
    call object%base_write (unit)
    write (u, "(1x,A)")  "Range parameters:"
    write (u, "(3x,A," // FMT_19 // ")")  "r_beg  = ", object%r_beg
    write (u, "(3x,A," // FMT_19 // ")")  "r_end  = ", object%r_end
    write (u, "(3x,A," // FMT_19 // ")")  "r_step = ", object%r_end
    write (u, "(3x,A,I0)")  "n_step = ", object%n_step
  end subroutine range_real_write
  
@ %def range_write
@ Initialize, given a range expression parse node.  This is common to the
implementations.
<<Commands: range: TBP>>=
  procedure :: init => range_init
<<Commands: procedures>>=
  subroutine range_init (range, pn)
    class(range_t), intent(out) :: range
    type(parse_node_t), intent(in), target :: pn
    type(parse_node_t), pointer :: pn_spec, pn_end, pn_step_spec, pn_op
    select case (char (parse_node_get_rule_key (pn)))
    case ("expr")
    case ("range_expr")
       range%pn_beg => parse_node_get_sub_ptr (pn)
       pn_spec => parse_node_get_next_ptr (range%pn_beg)
       if (associated (pn_spec)) then
          pn_end => parse_node_get_sub_ptr (pn_spec, 2)
          range%pn_end => pn_end
          pn_step_spec => parse_node_get_next_ptr (pn_end)
          if (associated (pn_step_spec)) then
             pn_op => parse_node_get_sub_ptr (pn_step_spec)
             range%pn_step => parse_node_get_next_ptr (pn_op)
             select case (char (parse_node_get_rule_key (pn_op)))
             case ("/+");  range%step_mode = STEP_ADD
             case ("/-");  range%step_mode = STEP_SUB
             case ("/*");  range%step_mode = STEP_MUL
             case ("//");  range%step_mode = STEP_DIV
             case ("/+/");  range%step_mode = STEP_COMP_ADD
             case ("/*/");  range%step_mode = STEP_COMP_MUL
             case default
                call range%write ()
                call msg_bug ("Range: step mode not implemented")
             end select
          else
             range%step_mode = STEP_ADD
          end if
       else
          range%step_mode = STEP_NONE
       end if
       call range%create_value_node ()
    case default
       call msg_bug ("range expression: node type '" &
            // char (parse_node_get_rule_key (pn)) &
            // "' not implemented")
    end select
  end subroutine range_init
  
@ %def range_init
@ This method manually creates a parse node (actually, a cascade of parse
nodes) that hold a constant value as a literal.  The idea is that this node is
inserted as the right-hand side of a fake variable assignment, which is
prepended to each scan iteration.  Before the variable
assignment is compiled and executed, we can manually reset the value of the
literal and thus pretend that the loop variable is assigned this value.
<<Commands: range: TBP>>=
  procedure :: create_value_node => range_create_value_node
<<Commands: procedures>>=
  subroutine range_create_value_node (range)
    class(range_t), intent(inout) :: range
    allocate (range%pn_literal)
    allocate (range%pn_value)
    select type (range)
    type is (range_int_t)
       call parse_node_create_value (range%pn_literal, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("integer_literal")),&
            ival = 0)
       call parse_node_create_branch (range%pn_value, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("integer_value")))
    type is (range_real_t)
       call parse_node_create_value (range%pn_literal, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("real_literal")),&
            rval = 0._default)
       call parse_node_create_branch (range%pn_value, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("real_value")))
    class default
       call msg_bug ("range: create value node: type not implemented")
    end select
    call parse_node_append_sub (range%pn_value, range%pn_literal)
    call parse_node_freeze_branch (range%pn_value)
    allocate (range%pn_factor)
    call parse_node_create_branch (range%pn_factor, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("factor")))
    call parse_node_append_sub (range%pn_factor, range%pn_value)
    call parse_node_freeze_branch (range%pn_factor)
    allocate (range%pn_term)
    call parse_node_create_branch (range%pn_term, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("term")))
    call parse_node_append_sub (range%pn_term, range%pn_factor)
    call parse_node_freeze_branch (range%pn_term)
    allocate (range%pn_expr)
    call parse_node_create_branch (range%pn_expr, &
         syntax_get_rule_ptr (syntax_cmd_list, var_str ("expr")))
    call parse_node_append_sub (range%pn_expr, range%pn_term)
    call parse_node_freeze_branch (range%pn_expr)
  end subroutine range_create_value_node
  
@ %def range_create_value_node
@ Compile, given an environment.
<<Commands: range: TBP>>=
  procedure :: compile => range_compile
<<Commands: procedures>>=
  subroutine range_compile (range, global)
    class(range_t), intent(inout) :: range
    type(rt_data_t), intent(in), target :: global
    type(var_list_t), pointer :: var_list
    var_list => global%get_var_list_ptr ()
    if (associated (range%pn_beg)) then
       call range%expr_beg%init_expr (range%pn_beg, var_list)
       if (associated (range%pn_end)) then
          call range%expr_end%init_expr (range%pn_end, var_list)
          if (associated (range%pn_step)) then
             call range%expr_step%init_expr (range%pn_step, var_list)
          end if
       end if
    end if
  end subroutine range_compile
  
@ %def range_compile
@ Evaluate: compute the actual bounds and parameters that determine the values
that we can iterate.

This is implementation-specific.
<<Commands: range: TBP>>=
  procedure (range_evaluate), deferred :: evaluate
<<Commands: interfaces>>=
  abstract interface
     subroutine range_evaluate (range)
       import
       class(range_t), intent(inout) :: range
     end subroutine range_evaluate
  end interface
  
@ %def range_evaluate
@ The version for an integer variable.  If the step is subtractive, we invert
the sign and treat it as an additive step.  For a multiplicative step, the
step must be greater than one, and the initial and final values must be of
same sign and strictly ordered.  Analogously for a division step.
<<Commands: range int: TBP>>=
  procedure :: evaluate => range_int_evaluate
<<Commands: procedures>>=
  subroutine range_int_evaluate (range)
    class(range_int_t), intent(inout) :: range
    integer :: ival
    if (associated (range%pn_beg)) then
       call range%expr_beg%evaluate ()
       if (range%expr_beg%is_known ()) then
          range%i_beg = range%expr_beg%get_int ()
       else
          call range%write ()
          call msg_fatal &
               ("Range expression: initial value evaluates to unknown")
       end if
       if (associated (range%pn_end)) then
          call range%expr_end%evaluate ()
          if (range%expr_end%is_known ()) then
             range%i_end = range%expr_end%get_int ()
             if (associated (range%pn_step)) then
                call range%expr_step%evaluate ()
                if (range%expr_step%is_known ()) then
                   range%i_step = range%expr_step%get_int ()
                   select case (range%step_mode)
                   case (STEP_SUB);  range%i_step = - range%i_step
                   end select
                else
                   call range%write ()
                   call msg_fatal &
                        ("Range expression: step value evaluates to unknown")
                end if
             else
                range%i_step = 1
             end if
          else
             call range%write ()
             call msg_fatal &
                  ("Range expression: final value evaluates to unknown")
          end if
       else
          range%i_end = range%i_beg
          range%i_step = 1
       end if
       select case (range%step_mode)
       case (STEP_NONE)
          range%n_step = 1
       case (STEP_ADD, STEP_SUB)
          if (range%i_step /= 0) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (sign (1, range%i_end - range%i_beg) &
                  == sign (1, range%i_step)) then
                range%n_step = (range%i_end - range%i_beg) / range%i_step + 1
             else
                range%n_step = 0
             end if
          else
             call msg_fatal ("range evaluation (add): step value is zero")
          end if
       case (STEP_MUL)
          if (range%i_step > 1) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (range%i_beg == 0) then
                call msg_fatal ("range evaluation (mul): initial value is zero")
             else if (sign (1, range%i_beg) == sign (1, range%i_end) &
                  .and. abs (range%i_beg) < abs (range%i_end)) then
                range%n_step = 0
                ival = range%i_beg
                do while (abs (ival) <= abs (range%i_end))
                   range%n_step = range%n_step + 1
                   ival = ival * range%i_step
                end do
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_DIV)
          if (range%i_step > 1) then
             if (range%i_beg == range%i_end) then
                range%n_step = 1
             else if (sign (1, range%i_beg) == sign (1, range%i_end) &
                  .and. abs (range%i_beg) > abs (range%i_end)) then
                range%n_step = 0
                ival = range%i_beg
                do while (abs (ival) >= abs (range%i_end))
                   range%n_step = range%n_step + 1
                   if (ival == 0)  exit
                   ival = ival / range%i_step
                end do
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (div): step value is one or less")
          end if
       case (STEP_COMP_ADD)
          call msg_fatal ("range evaluation: &
               &step mode /+/ not allowed for integer variable")
       case (STEP_COMP_MUL)
          call msg_fatal ("range evaluation: &
               &step mode /*/ not allowed for integer variable")
       case default
          call range%write ()
          call msg_bug ("range evaluation: step mode not implemented")
       end select
    end if
  end subroutine range_int_evaluate

@ %def range_int_evaluate
@ The version for a real variable.
<<Commands: range real: TBP>>=
  procedure :: evaluate => range_real_evaluate
<<Commands: procedures>>=
  subroutine range_real_evaluate (range)
    class(range_real_t), intent(inout) :: range
    if (associated (range%pn_beg)) then
       call range%expr_beg%evaluate ()
       if (range%expr_beg%is_known ()) then
          range%r_beg = range%expr_beg%get_real ()
       else
          call range%write ()
          call msg_fatal &
               ("Range expression: initial value evaluates to unknown")
       end if
       if (associated (range%pn_end)) then
          call range%expr_end%evaluate ()
          if (range%expr_end%is_known ()) then
             range%r_end = range%expr_end%get_real ()
             if (associated (range%pn_step)) then
                if (range%expr_step%is_known ()) then
                   select case (range%step_mode)
                   case (STEP_ADD, STEP_SUB, STEP_MUL, STEP_DIV)
                      call range%expr_step%evaluate ()
                      range%r_step = range%expr_step%get_real ()
                      select case (range%step_mode)
                      case (STEP_SUB);  range%r_step = - range%r_step
                      end select
                   case (STEP_COMP_ADD, STEP_COMP_MUL)
                      range%n_step = &
                           max (range%expr_step%get_int (), 0)
                   end select
                else
                   call range%write ()
                   call msg_fatal &
                        ("Range expression: step value evaluates to unknown")
                end if
             else
                call range%write ()
                call msg_fatal &
                     ("Range expression (real): step value must be provided")
             end if
          else
             call range%write ()
             call msg_fatal &
                  ("Range expression: final value evaluates to unknown")
          end if
       else
          range%r_end = range%r_beg
          range%r_step = 1
       end if
       select case (range%step_mode)
       case (STEP_NONE)
          range%n_step = 1
       case (STEP_ADD, STEP_SUB)
          if (range%r_step /= 0) then
             if (sign (1._default, range%r_end - range%r_beg) &
                  == sign (1._default, range%r_step)) then
                range%n_step = &
                     nint ((range%r_end - range%r_beg) / range%r_step + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal ("range evaluation (add): step value is zero")
          end if
       case (STEP_MUL)
          if (range%r_step > 1) then
             if (range%r_beg == 0 .or. range%r_end == 0) then
                call msg_fatal ("range evaluation (mul): bound is zero")
             else if (sign (1._default, range%r_beg) &
                  == sign (1._default, range%r_end) &
                  .and. abs (range%r_beg) <= abs (range%r_end)) then
                range%lr_beg = log (abs (range%r_beg))
                range%lr_end = log (abs (range%r_end))
                range%lr_step = log (range%r_step)
                range%n_step = nint &
                     (abs ((range%lr_end - range%lr_beg) / range%lr_step) + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_DIV)
          if (range%r_step > 1) then
             if (range%r_beg == 0 .or. range%r_end == 0) then
                call msg_fatal ("range evaluation (div): bound is zero")
             else if (sign (1._default, range%r_beg) &
                  == sign (1._default, range%r_end) &
                  .and. abs (range%r_beg) >= abs (range%r_end)) then
                range%lr_beg = log (abs (range%r_beg))
                range%lr_end = log (abs (range%r_end))
                range%lr_step = -log (range%r_step)
                range%n_step = nint &
                     (abs ((range%lr_end - range%lr_beg) / range%lr_step) + 1)
             else
                range%n_step = 0
             end if
          else
             call msg_fatal &
                  ("range evaluation (mult): step value is one or less")
          end if
       case (STEP_COMP_ADD)
          ! Number of steps already known
       case (STEP_COMP_MUL)
          ! Number of steps already known
          if (range%r_beg == 0 .or. range%r_end == 0) then
             call msg_fatal ("range evaluation (mul): bound is zero")
          else if (sign (1._default, range%r_beg) &
               == sign (1._default, range%r_end)) then
             range%lr_beg = log (abs (range%r_beg))
             range%lr_end = log (abs (range%r_end))
          else
             range%n_step = 0
          end if
       case default
          call range%write ()
          call msg_bug ("range evaluation: step mode not implemented")
       end select
    end if
  end subroutine range_real_evaluate

@ %def range_real_evaluate
@ Return the number of iterations:
<<Commands: range: TBP>>=
  procedure :: get_n_iterations => range_get_n_iterations
<<Commands: procedures>>=
  function range_get_n_iterations (range) result (n)
    class(range_t), intent(in) :: range
    integer :: n
    n = range%n_step
  end function range_get_n_iterations
  
@ %def range_get_n_iterations
@ Compute the value for iteration [[i]] and store it in the embedded token.
<<Commands: range: TBP>>=
  procedure (range_set_value), deferred :: set_value
<<Commands: interfaces>>=
  abstract interface
     subroutine range_set_value (range, i)
       import
       class(range_t), intent(inout) :: range
       integer, intent(in) :: i
     end subroutine range_set_value
  end interface
  
@ %def range_set_value
@ In the integer case, we compute the value directly for additive step.  For
multiplicative step, we perform a loop in the same way as above, where the
number of iteration was determined.
<<Commands: range int: TBP>>=
  procedure :: set_value => range_int_set_value
<<Commands: procedures>>=
  subroutine range_int_set_value (range, i)
    class(range_int_t), intent(inout) :: range
    integer, intent(in) :: i
    integer :: k, ival
    select case (range%step_mode)
    case (STEP_NONE)
       ival = range%i_beg
    case (STEP_ADD, STEP_SUB)
       ival = range%i_beg + (i - 1) * range%i_step
    case (STEP_MUL)
       ival = range%i_beg
       do k = 1, i - 1
          ival = ival * range%i_step
       end do
    case (STEP_DIV)
       ival = range%i_beg
       do k = 1, i - 1
          ival = ival / range%i_step
       end do
    case default
       call range%write ()
       call msg_bug ("range iteration: step mode not implemented")
    end select
    call parse_node_set_value (range%pn_literal, ival = ival)
  end subroutine range_int_set_value
  
@ %def range_int_set_value
@ In the integer case, we compute the value directly for additive step.  For
multiplicative step, we perform a loop in the same way as above, where the
number of iteration was determined.
<<Commands: range real: TBP>>=
  procedure :: set_value => range_real_set_value
<<Commands: procedures>>=
  subroutine range_real_set_value (range, i)
    class(range_real_t), intent(inout) :: range
    integer, intent(in) :: i
    real(default) :: rval, x
    select case (range%step_mode)
    case (STEP_NONE)
       rval = range%r_beg
    case (STEP_ADD, STEP_SUB, STEP_COMP_ADD)
       if (range%n_step > 1) then
          x = real (i - 1, default) / (range%n_step - 1)
       else
          x = 1._default / 2
       end if
       rval = x * range%r_end + (1 - x) * range%r_beg
    case (STEP_MUL, STEP_DIV, STEP_COMP_MUL)
       if (range%n_step > 1) then
          x = real (i - 1, default) / (range%n_step - 1)
       else
          x = 1._default / 2
       end if
       rval = sign &
            (exp (x * range%lr_end + (1 - x) * range%lr_beg), range%r_beg)
    case default
       call range%write ()
       call msg_bug ("range iteration: step mode not implemented")
    end select
    call parse_node_set_value (range%pn_literal, rval = rval)
  end subroutine range_real_set_value
  
@ %def range_real_set_value
@ 
\subsubsection{Scan over parameters and other objects}
The scan command allocates a new parse node for the variable
assignment (the lhs).  The rhs of this parse node is assigned from the
available rhs expressions in the scan list, one at a time, so the
compiled parse node can be prepended to the scan body.

Note: for the integer/real range array, the obvious implementation as a
polymorphic array is suspended because in gfortran 4.7, polymorphic arrays are
apparently broken.
<<Commands: types>>=
  type, extends (command_t) :: cmd_scan_t
     private
     type(string_t) :: name
     integer :: n_values = 0
     type(parse_node_p), dimension(:), allocatable :: scan_cmd
     !!! !!! gfortran 4.7.x memory corruption
     !!!  class(range_t), dimension(:), allocatable :: range
     type(range_int_t), dimension(:), allocatable :: range_int
     type(range_real_t), dimension(:), allocatable :: range_real
   contains
   <<Commands: cmd scan: TBP>>  
  end type cmd_scan_t

@ %def cmd_scan_t
@ Finalizer.  

The auxiliary parse nodes that we have constructed have to be treated
carefully: the embedded pointers all point to persistent objects
somewhere else and should not be finalized, so we should not call the
finalizer recursively.
<<Commands: cmd scan: TBP>>=
  procedure :: final => cmd_scan_final
<<Commands: procedures>>=
  recursive subroutine cmd_scan_final (cmd)
    class(cmd_scan_t), intent(inout) :: cmd
    type(parse_node_t), pointer :: pn_var_single, pn_decl_single
    type(string_t) :: key
    integer :: i
    if (allocated (cmd%scan_cmd)) then
       do i = 1, size (cmd%scan_cmd)
          pn_var_single => parse_node_get_sub_ptr (cmd%scan_cmd(i)%ptr)
          key = parse_node_get_rule_key (pn_var_single)
          select case (char (key))
          case ("scan_string_decl", "scan_log_decl")
             pn_decl_single => parse_node_get_sub_ptr (pn_var_single, 2)
             call parse_node_final (pn_decl_single, recursive=.false.)
             deallocate (pn_decl_single)
          end select
          call parse_node_final (pn_var_single, recursive=.false.)
          deallocate (pn_var_single)
       end do
       deallocate (cmd%scan_cmd)
    end if
    !!! !!! gfortran 4.7.x memory corruption
    !!!  if (allocated (cmd%range)) then
    !!!     do i = 1, size (cmd%range)
    !!!        call cmd%range(i)%final ()
    !!!     end do
    !!!  end if
    if (allocated (cmd%range_int)) then
       do i = 1, size (cmd%range_int)
          call cmd%range_int(i)%final ()
       end do
    end if
    if (allocated (cmd%range_real)) then
       do i = 1, size (cmd%range_real)
          call cmd%range_real(i)%final ()
       end do
    end if
  end subroutine cmd_scan_final

@ %def cmd_scan_final
@ Output.
<<Commands: cmd scan: TBP>>=
  procedure :: write => cmd_scan_write
<<Commands: procedures>>=
  subroutine cmd_scan_write (cmd, unit, indent)
    class(cmd_scan_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,1x,A,1x,'(',I0,')')")  "scan:", char (cmd%name), &
         cmd%n_values
  end subroutine cmd_scan_write

@ %def cmd_scan_write
@ Compile the scan command.  We construct a new parse node that
implements the variable assignment for a single element on the rhs,
instead of the whole list that we get from the original parse tree.
By simply copying the node, we copy all pointers and inherit the
targets from the original.  During execution, we should replace the
rhs by the stored rhs pointers (the list elements), one by one, then
(re)compile the redefined node.
<<Commands: cmd scan: TBP>>=
  procedure :: compile => cmd_scan_compile
<<Commands: procedures>>=
  recursive subroutine cmd_scan_compile (cmd, global)
    class(cmd_scan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    type(parse_node_t), pointer :: pn_var, pn_body, pn_body_first
    type(parse_node_t), pointer :: pn_decl, pn_name
    type(parse_node_t), pointer :: pn_arg, pn_scan_cmd, pn_rhs
    type(parse_node_t), pointer :: pn_decl_single, pn_var_single
    type(syntax_rule_t), pointer :: var_rule_decl, var_rule
    type(string_t) :: key
    integer :: var_type
    integer :: i
    logical, parameter :: debug = .false.
    if (debug) then
       print *, "compile scan"
       call parse_node_write_rec (cmd%pn)
    end if
    pn_var => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_body => parse_node_get_next_ptr (pn_var)
    if (associated (pn_body)) then
       pn_body_first => parse_node_get_sub_ptr (pn_body)
    else
       pn_body_first => null ()
    end if
    key = parse_node_get_rule_key (pn_var)
    select case (char (key))
    case ("scan_num")
       pn_name => parse_node_get_sub_ptr (pn_var)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_num"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_int")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_int"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_real")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_real"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_complex")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str("cmd_complex"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_alias")
       pn_name => parse_node_get_sub_ptr (pn_var, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, var_str ("cmd_alias"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_string_decl")
       pn_decl => parse_node_get_sub_ptr (pn_var, 2)
       pn_name => parse_node_get_sub_ptr (pn_decl, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule_decl => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_string"))
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_string_decl"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_log_decl")
       pn_decl => parse_node_get_sub_ptr (pn_var, 2)
       pn_name => parse_node_get_sub_ptr (pn_decl, 2)
       cmd%name = parse_node_get_string (pn_name)
       var_rule_decl => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_log"))
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_log_decl"))
       pn_arg => parse_node_get_next_ptr (pn_name, 2)
    case ("scan_cuts")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_cuts"))
       cmd%name = "cuts"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_weight")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_weight"))
       cmd%name = "weight"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_scale"))
       cmd%name = "scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_ren_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_ren_scale"))
       cmd%name = "renormalization_scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_fac_scale")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_fac_scale"))
       cmd%name = "factorization_scale"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_selection")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_selection"))
       cmd%name = "selection"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_reweight")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_reweight"))
       cmd%name = "reweight"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_analysis")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_analysis"))
       cmd%name = "analysis"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_model")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_model"))
       cmd%name = "model"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case ("scan_library")
       var_rule => syntax_get_rule_ptr (syntax_cmd_list, &
            var_str ("cmd_library"))
       cmd%name = "library"
       pn_arg => parse_node_get_sub_ptr (pn_var, 3)
    case default
       call msg_bug ("scan: case '" // char (key) // "' not implemented")
    end select
    if (associated (pn_arg)) then
       cmd%n_values = parse_node_get_n_sub (pn_arg)
    end if
    var_list => global%get_var_list_ptr ()
    allocate (cmd%scan_cmd (cmd%n_values))
    select case (char (key))
    case ("scan_num")
       var_type = &
            var_list%get_type (cmd%name)
       select case (var_type)
       case (V_INT)
          !!! !!! gfortran 4.7.x memory corruption
          !!!  allocate (range_int_t :: cmd%range (cmd%n_values))
          allocate (cmd%range_int (cmd%n_values))
       case (V_REAL)
          !!! !!! gfortran 4.7.x memory corruption          
          !!!  allocate (range_real_t :: cmd%range (cmd%n_values))
          allocate (cmd%range_real (cmd%n_values))
       case (V_CMPLX)
          call msg_fatal ("scan over complex variable not implemented")
       case (V_NONE)
          call msg_fatal ("scan: variable '" // char (cmd%name) //"' undefined")
       case default
          call msg_bug ("scan: impossible variable type")
       end select
    case ("scan_int")
       !!! !!! gfortran 4.7.x memory corruption       
       !!!  allocate (range_int_t :: cmd%range (cmd%n_values))
       allocate (cmd%range_int (cmd%n_values))
    case ("scan_real")
       !!! !!! gfortran 4.7.x memory corruption
       !!!  allocate (range_real_t :: cmd%range (cmd%n_values))
       allocate (cmd%range_real (cmd%n_values))
    case ("scan_complex")
       call msg_fatal ("scan over complex variable not implemented")
    end select
    i = 1
    if (associated (pn_arg)) then
       pn_rhs => parse_node_get_sub_ptr (pn_arg)
    else
       pn_rhs => null ()
    end if
    do while (associated (pn_rhs))
       allocate (pn_scan_cmd)
       call parse_node_create_branch (pn_scan_cmd, &
            syntax_get_rule_ptr (syntax_cmd_list, var_str ("command_list")))
       allocate (pn_var_single)
       pn_var_single = pn_var
       call parse_node_replace_rule (pn_var_single, var_rule)
       select case (char (key))
       case ("scan_num", "scan_int", "scan_real", &
            "scan_complex", "scan_alias", &
            "scan_cuts", "scan_weight", &
            "scan_scale", "scan_ren_scale", "scan_fac_scale", &
            "scan_selection", "scan_reweight", "scan_analysis", &
            "scan_model", "scan_library")
          if (allocated (cmd%range_int)) then
             call cmd%range_int(i)%init (pn_rhs)
             !!! !!! gfortran 4.7.x memory corruption             
             !!!  call cmd%range_int(i)%compile (global)
             call parse_node_replace_last_sub &
                  (pn_var_single, cmd%range_int(i)%pn_expr)
          else if (allocated (cmd%range_real)) then
             call cmd%range_real(i)%init (pn_rhs)
             !!! !!! gfortran 4.7.x memory corruption 
             !!!  call cmd%range_real(i)%compile (global)
             call parse_node_replace_last_sub &
                  (pn_var_single, cmd%range_real(i)%pn_expr)
          else
             call parse_node_replace_last_sub (pn_var_single, pn_rhs)
          end if
       case ("scan_string_decl", "scan_log_decl")
          allocate (pn_decl_single)
          pn_decl_single = pn_decl
          call parse_node_replace_rule (pn_decl_single, var_rule_decl)
          call parse_node_replace_last_sub (pn_decl_single, pn_rhs)
          call parse_node_freeze_branch (pn_decl_single)
          call parse_node_replace_last_sub (pn_var_single, pn_decl_single)
       case default
          call msg_bug ("scan: case '" // char (key)  &
               // "' broken")
       end select
       call parse_node_freeze_branch (pn_var_single)
       call parse_node_append_sub (pn_scan_cmd, pn_var_single)
       call parse_node_append_sub (pn_scan_cmd, pn_body_first)
       call parse_node_freeze_branch (pn_scan_cmd)
       cmd%scan_cmd(i)%ptr => pn_scan_cmd
       i = i + 1
       pn_rhs => parse_node_get_next_ptr (pn_rhs)
    end do
    if (debug) then
       do i = 1, cmd%n_values
          print *, "scan command ", i
          call parse_node_write_rec (cmd%scan_cmd(i)%ptr)
          if (allocated (cmd%range_int))  call cmd%range_int(i)%write ()
          if (allocated (cmd%range_real))  call cmd%range_real(i)%write ()
       end do
       print *, "original"
       call parse_node_write_rec (cmd%pn)
    end if
  end subroutine cmd_scan_compile

@ %def cmd_scan_compile
@ Execute the loop for all values in the step list.  We use the
parse trees with single variable assignment that we have stored, to
iteratively create a local environment, execute the stored commands, and
destroy it again.  When we encounter a range object, we execute the commands
for each value that this object provides.  Computing this value has the side
effect of modifying the rhs of the variable assignment that heads the local
command list, directly in the local parse tree.
<<Commands: cmd scan: TBP>>=
  procedure :: execute => cmd_scan_execute
<<Commands: procedures>>=
  recursive subroutine cmd_scan_execute (cmd, global)
    class(cmd_scan_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(rt_data_t), allocatable :: local
    integer :: i, j
    do i = 1, cmd%n_values
       if (allocated (cmd%range_int)) then
          call cmd%range_int(i)%compile (global)
          call cmd%range_int(i)%evaluate ()
          do j = 1, cmd%range_int(i)%get_n_iterations ()
             call cmd%range_int(i)%set_value (j)
             allocate (local)
             call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
             call local%local_final ()
             deallocate (local)
          end do
       else if (allocated (cmd%range_real)) then
          call cmd%range_real(i)%compile (global)
          call cmd%range_real(i)%evaluate ()
          do j = 1, cmd%range_real(i)%get_n_iterations ()
             call cmd%range_real(i)%set_value (j)
             allocate (local)
             call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
             call local%local_final ()
             deallocate (local)
          end do
       else
          allocate (local)
          call build_alt_setup (local, global, cmd%scan_cmd(i)%ptr)
          call local%local_final ()
          deallocate (local)
       end if
    end do
  end subroutine cmd_scan_execute

@ %def cmd_scan_execute
@ 
\subsubsection{Conditionals}
Conditionals are implemented as a list that is compiled and evaluated
recursively; this allows for a straightforward representation of
[[else if]] constructs.  A [[cmd_if_t]] object can hold either an
[[else_if]] clause which is another object of this type, or an
[[else_body]], but not both.

If- or else-bodies are no scoping units, so all data remain global and
no copy-in copy-out is needed.
<<Commands: types>>=
  type, extends (command_t) :: cmd_if_t
     private
     type(parse_node_t), pointer :: pn_if_lexpr => null ()
     type(command_list_t), pointer :: if_body => null ()
     type(cmd_if_t), dimension(:), pointer :: elsif_cmd => null ()
     type(command_list_t), pointer :: else_body => null ()
   contains
   <<Commands: cmd if: TBP>>
  end type cmd_if_t

@ %def cmd_if_t
@ Finalizer.  There are no local options, therefore we can simply override
the default finalizer.
<<Commands: cmd if: TBP>>=
  procedure :: final => cmd_if_final
<<Commands: procedures>>=
  recursive subroutine cmd_if_final (cmd)
    class(cmd_if_t), intent(inout) :: cmd
    integer :: i
    if (associated (cmd%if_body)) then
       call command_list_final (cmd%if_body)
       deallocate (cmd%if_body)
    end if
    if (associated (cmd%elsif_cmd)) then
       do i = 1, size (cmd%elsif_cmd)
          call cmd_if_final (cmd%elsif_cmd(i))
       end do
       deallocate (cmd%elsif_cmd)
    end if
    if (associated (cmd%else_body)) then
       call command_list_final (cmd%else_body)
       deallocate (cmd%else_body)
    end if
  end subroutine cmd_if_final

@ %def cmd_if_final
@ Output.  Recursively write the command lists.
<<Commands: cmd if: TBP>>=
  procedure :: write => cmd_if_write
<<Commands: procedures>>=
  subroutine cmd_if_write (cmd, unit, indent)
    class(cmd_if_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, ind, i
    u = given_output_unit (unit);  if (u < 0)  return
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, indent)
    write (u, "(A)")  "if <expr> then"
    if (associated (cmd%if_body)) then
       call cmd%if_body%write (unit, ind + 1)
    end if
    if (associated (cmd%elsif_cmd)) then
       do i = 1, size (cmd%elsif_cmd)
          call write_indent (u, indent)
          write (u, "(A)")  "elsif <expr> then"
          if (associated (cmd%elsif_cmd(i)%if_body)) then
             call cmd%elsif_cmd(i)%if_body%write (unit, ind + 1)
          end if
       end do
    end if
    if (associated (cmd%else_body)) then
       call write_indent (u, indent)
       write (u, "(A)")  "else"
       call cmd%else_body%write (unit, ind + 1)
    end if
  end subroutine cmd_if_write
  
@ %def cmd_if_write
@ Compile the conditional.
<<Commands: cmd if: TBP>>=
  procedure :: compile => cmd_if_compile
<<Commands: procedures>>=
  recursive subroutine cmd_if_compile (cmd, global)
    class(cmd_if_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_lexpr, pn_body
    type(parse_node_t), pointer :: pn_elsif_clauses, pn_cmd_elsif
    type(parse_node_t), pointer :: pn_else_clause, pn_cmd_else
    integer :: i, n_elsif
    pn_lexpr => parse_node_get_sub_ptr (cmd%pn, 2)
    cmd%pn_if_lexpr => pn_lexpr
    pn_body => parse_node_get_next_ptr (pn_lexpr, 2)
    select case (char (parse_node_get_rule_key (pn_body)))
    case ("command_list")
       allocate (cmd%if_body)
       call cmd%if_body%compile (pn_body, global)
       pn_elsif_clauses => parse_node_get_next_ptr (pn_body)
    case default
       pn_elsif_clauses => pn_body
    end select
    select case (char (parse_node_get_rule_key (pn_elsif_clauses)))
    case ("elsif_clauses")
       n_elsif = parse_node_get_n_sub (pn_elsif_clauses)
       allocate (cmd%elsif_cmd (n_elsif))
       pn_cmd_elsif => parse_node_get_sub_ptr (pn_elsif_clauses)
       do i = 1, n_elsif
          pn_lexpr => parse_node_get_sub_ptr (pn_cmd_elsif, 2)
          cmd%elsif_cmd(i)%pn_if_lexpr => pn_lexpr
          pn_body => parse_node_get_next_ptr (pn_lexpr, 2)
          if (associated (pn_body)) then
             allocate (cmd%elsif_cmd(i)%if_body)
             call cmd%elsif_cmd(i)%if_body%compile (pn_body, global)
          end if
          pn_cmd_elsif => parse_node_get_next_ptr (pn_cmd_elsif)
       end do
       pn_else_clause => parse_node_get_next_ptr (pn_elsif_clauses)
    case default
       pn_else_clause => pn_elsif_clauses
    end select
    select case (char (parse_node_get_rule_key (pn_else_clause)))
    case ("else_clause")
       pn_cmd_else => parse_node_get_sub_ptr (pn_else_clause)
       pn_body => parse_node_get_sub_ptr (pn_cmd_else, 2)
       if (associated (pn_body)) then
          allocate (cmd%else_body)
          call cmd%else_body%compile (pn_body, global)
       end if
    end select
  end subroutine cmd_if_compile

@ %def global
@ (Recursively) execute the condition.  Context remains global in all cases.
<<Commands: cmd if: TBP>>=
  procedure :: execute => cmd_if_execute
<<Commands: procedures>>=
  recursive subroutine cmd_if_execute (cmd, global)
    class(cmd_if_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    logical :: lval, is_known
    integer :: i
    var_list => global%get_var_list_ptr ()
    lval = eval_log (cmd%pn_if_lexpr, var_list, is_known=is_known)
    if (is_known) then
       if (lval) then
          if (associated (cmd%if_body)) then
             call cmd%if_body%execute (global)
          end if
          return
       end if
    else
       call error_undecided ()
       return
    end if
    if (associated (cmd%elsif_cmd)) then
       SCAN_ELSIF: do i = 1, size (cmd%elsif_cmd)
          lval = eval_log (cmd%elsif_cmd(i)%pn_if_lexpr, var_list, &
                is_known=is_known)
          if (is_known) then
             if (lval) then
                if (associated (cmd%elsif_cmd(i)%if_body)) then
                   call cmd%elsif_cmd(i)%if_body%execute (global)
                end if
                return
             end if
          else
             call error_undecided ()
             return
          end if
       end do SCAN_ELSIF
    end if
    if (associated (cmd%else_body)) then
       call cmd%else_body%execute (global)
    end if
  contains
    subroutine error_undecided ()
      call msg_error ("Undefined result of cmditional expression: " &
           // "neither branch will be executed")
    end subroutine error_undecided
  end subroutine cmd_if_execute

@ %def cmd_if_execute
@
\subsubsection{Include another command-list file}
The include command allocates a local parse tree.  This must not be
deleted before the command object itself is deleted, since pointers
may point to subobjects of it.
<<Commands: types>>=
  type, extends (command_t) :: cmd_include_t
     private
     type(string_t) :: file
     type(command_list_t), pointer :: command_list => null ()
     type(parse_tree_t) :: parse_tree
   contains
   <<Commands: cmd include: TBP>>
  end type cmd_include_t

@ %def cmd_include_t
@ Finalizer: delete the command list.  No options, so we can simply override
the default finalizer.
<<Commands: cmd include: TBP>>=
  procedure :: final => cmd_include_final
<<Commands: procedures>>=
  subroutine cmd_include_final (cmd)
    class(cmd_include_t), intent(inout) :: cmd
    call parse_tree_final (cmd%parse_tree)
    if (associated (cmd%command_list)) then
       call cmd%command_list%final ()
       deallocate (cmd%command_list)
    end if
  end subroutine cmd_include_final

@ %def cmd_include_final
@ Write: display the command list as-is, if allocated.
<<Commands: cmd include: TBP>>=
  procedure :: write => cmd_include_write
<<Commands: procedures>>=
  subroutine cmd_include_write (cmd, unit, indent)
    class(cmd_include_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u, ind
    u = given_output_unit (unit)
    ind = 0;  if (present (indent))  ind = indent
    call write_indent (u, indent)
    write (u, "(A,A,A,A)")  "include ", '"', char (cmd%file), '"'
    if (associated (cmd%command_list)) then
       call cmd%command_list%write (u, ind + 1)
    end if
  end subroutine cmd_include_write
  
@ %def cmd_include_write
@ Compile file contents: First parse the file, then immediately
compile its contents.  Use the global data set.
<<Commands: cmd include: TBP>>=
  procedure :: compile => cmd_include_compile
<<Commands: procedures>>=
  subroutine cmd_include_compile (cmd, global)
    class(cmd_include_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg, pn_file
    type(string_t) :: file
    logical :: exist
    integer :: u
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    pn_file => parse_node_get_sub_ptr (pn_arg)
    file = parse_node_get_string (pn_file)
    inquire (file=char(file), exist=exist)
    if (exist) then
       cmd%file = file
    else
       cmd%file = global%os_data%whizard_cutspath // "/" // file
       inquire (file=char(cmd%file), exist=exist)
       if (.not. exist) then
          call msg_error ("Include file '" // char (file) // "' not found")
          return
       end if
    end if
    u = free_unit ()
    call lexer_init_cmd_list (lexer, global%lexer)
    call stream_init (stream, char (cmd%file))
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (cmd%parse_tree, syntax_cmd_list, lexer)
    call stream_final (stream)
    call lexer_final (lexer)
    close (u)
    allocate (cmd%command_list)
    call cmd%command_list%compile (parse_tree_get_root_ptr (cmd%parse_tree), &
         global)
  end subroutine cmd_include_compile

@ %def cmd_include_compile
@ Execute file contents in the global context.
<<Commands: cmd include: TBP>>=
  procedure :: execute => cmd_include_execute
<<Commands: procedures>>=
  subroutine cmd_include_execute (cmd, global)
    class(cmd_include_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    if (associated (cmd%command_list)) then
       call msg_message &
            ("Including Sindarin from '" // char (cmd%file) // "'")
       call cmd%command_list%execute (global)
       call msg_message &
            ("End of included '" // char (cmd%file) // "'")
    end if
  end subroutine cmd_include_execute

@ %def cmd_include_execute
@ 
\subsubsection{Quit command execution}
The code is the return code of the whole program if it is terminated
by this command.
<<Commands: types>>=
  type, extends (command_t) :: cmd_quit_t
     private
     logical :: has_code = .false.
     type(parse_node_t), pointer :: pn_code_expr => null ()
   contains
   <<Commands: cmd quit: TBP>>
  end type cmd_quit_t

@ %def cmd_quit_t
@ Output.
<<Commands: cmd quit: TBP>>=
  procedure :: write => cmd_quit_write
<<Commands: procedures>>=  
  subroutine cmd_quit_write (cmd, unit, indent)
    class(cmd_quit_t), intent(in) :: cmd
    integer, intent(in), optional :: unit, indent
    integer :: u
    u = given_output_unit (unit);  if (u < 0)  return
    call write_indent (u, indent)
    write (u, "(1x,A,L1)")  "quit: has_code = ", cmd%has_code
  end subroutine cmd_quit_write

@ %def cmd_quit_write
@ Compile: allocate a [[quit]] object which serves as a placeholder.
<<Commands: cmd quit: TBP>>=
  procedure :: compile => cmd_quit_compile
<<Commands: procedures>>=
  subroutine cmd_quit_compile (cmd, global)
    class(cmd_quit_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_arg
    pn_arg => parse_node_get_sub_ptr (cmd%pn, 2)
    if (associated (pn_arg)) then
       cmd%pn_code_expr => parse_node_get_sub_ptr (pn_arg)
       cmd%has_code = .true.
    end if
  end subroutine cmd_quit_compile

@ %def cmd_quit_compile
@ Execute: The quit command does not execute anything, it just stops
command execution.  This is achieved by setting quit flag and quit
code in the global variable list.  However, the return code, if
present, is an expression which has to be evaluated.
<<Commands: cmd quit: TBP>>=
  procedure :: execute => cmd_quit_execute
<<Commands: procedures>>=
  subroutine cmd_quit_execute (cmd, global)
    class(cmd_quit_t), intent(inout) :: cmd
    type(rt_data_t), intent(inout), target :: global
    type(var_list_t), pointer :: var_list
    logical :: is_known
    var_list => global%get_var_list_ptr ()
    if (cmd%has_code) then
       global%quit_code = eval_int (cmd%pn_code_expr, var_list, &
            is_known=is_known)
       if (.not. is_known) then
          call msg_error ("Undefined return code of quit/exit command")
       end if
    end if
    global%quit = .true.
  end subroutine cmd_quit_execute

@ %def cmd_quit_execute
@
\subsection{The command list}
The command list holds a list of commands and relevant global data.
<<Commands: public>>=
  public :: command_list_t
<<Commands: types>>=
  type :: command_list_t
     ! not private anymore as required by the whizard-c-interface
     class(command_t), pointer :: first => null ()
     class(command_t), pointer :: last => null ()
   contains
   <<Commands: command list: TBP>>
  end type command_list_t

@ %def command_list_t
@ Output.
<<Commands: command list: TBP>>=
  procedure :: write => command_list_write
<<Commands: procedures>>=
  recursive subroutine command_list_write (cmd_list, unit, indent)
    class(command_list_t), intent(in) :: cmd_list
    integer, intent(in), optional :: unit, indent
    class(command_t), pointer :: cmd
    cmd => cmd_list%first
    do while (associated (cmd))
       call cmd%write (unit, indent)
       cmd => cmd%next
    end do
  end subroutine command_list_write
  
@ %def command_list_write
@ Append a new command to the list and free the original pointer.
<<Commands: command list: TBP>>=
  procedure :: append => command_list_append
<<Commands: procedures>>=
  subroutine command_list_append (cmd_list, command)
    class(command_list_t), intent(inout) :: cmd_list
    class(command_t), intent(inout), pointer :: command
    if (associated (cmd_list%last)) then
       cmd_list%last%next => command
    else
       cmd_list%first => command
    end if
    cmd_list%last => command
    command => null ()
  end subroutine command_list_append

@ %def command_list_append
@ Finalize.
<<Commands: command list: TBP>>=
  procedure :: final => command_list_final
<<Commands: procedures>>=
  recursive subroutine command_list_final (cmd_list)
    class(command_list_t), intent(inout) :: cmd_list
    class(command_t), pointer :: command
    do while (associated (cmd_list%first))
       command => cmd_list%first
       cmd_list%first => cmd_list%first%next
       call command%final ()
       deallocate (command)
    end do
    cmd_list%last => null ()
  end subroutine command_list_final

@ %def command_list_final
@ 
\subsection{Compiling the parse tree}
Transform a parse tree into a command list.  Initialization is assumed
to be done.  

After each command, we set a breakpoint.
<<Commands: command list: TBP>>=
  procedure :: compile => command_list_compile
<<Commands: procedures>>=
  recursive subroutine command_list_compile (cmd_list, pn, global)
    class(command_list_t), intent(inout), target :: cmd_list
    type(parse_node_t), intent(in), target :: pn
    type(rt_data_t), intent(inout), target :: global
    type(parse_node_t), pointer :: pn_cmd
    class(command_t), pointer :: command
    integer :: i
    pn_cmd => parse_node_get_sub_ptr (pn)
    do i = 1, parse_node_get_n_sub (pn)
       call dispatch_command (command, pn_cmd)
       call command%compile (global)
       call cmd_list%append (command)
       call terminate_now_if_signal ()
       pn_cmd => parse_node_get_next_ptr (pn_cmd)
    end do
  end subroutine command_list_compile

@ %def command_list_compile
@
\subsection{Executing the command list}
Before executing a command we should execute its options (if any).  After
that, reset the options, i.e., remove temporary effects from the global
state.

Also here, after each command we set a breakpoint.
<<Commands: command list: TBP>>=
  procedure :: execute => command_list_execute
<<Commands: procedures>>=
  recursive subroutine command_list_execute (cmd_list, global)
    class(command_list_t), intent(in) :: cmd_list
    type(rt_data_t), intent(inout), target :: global
    class(command_t), pointer :: command
    command => cmd_list%first
    COMMAND_COND: do while (associated (command))
       call command%execute_options (global)
       call command%execute (global)
       call command%reset_options (global)
       call terminate_now_if_signal ()
       if (global%quit)  exit COMMAND_COND
       command => command%next
    end do COMMAND_COND
  end subroutine command_list_execute

@ %def command_list_execute
@
\subsection{Command list syntax}
<<Commands: public>>=
  public :: syntax_cmd_list
<<Commands: variables>>=
  type(syntax_t), target, save :: syntax_cmd_list

@ %def syntax_cmd_list
<<Commands: public>>=
  public :: syntax_cmd_list_init
<<Commands: procedures>>=
  subroutine syntax_cmd_list_init ()
    type(ifile_t) :: ifile
    call define_cmd_list_syntax (ifile)
    call syntax_init (syntax_cmd_list, ifile)
    call ifile_final (ifile)
  end subroutine syntax_cmd_list_init

@ %def syntax_cmd_list_init
<<Commands: public>>=
  public :: syntax_cmd_list_final
<<Commands: procedures>>=
  subroutine syntax_cmd_list_final ()
    call syntax_final (syntax_cmd_list)
  end subroutine syntax_cmd_list_final

@ %def syntax_cmd_list_final
<<Commands: public>>=
  public :: syntax_cmd_list_write
<<Commands: procedures>>=
  subroutine syntax_cmd_list_write (unit)
    integer, intent(in), optional :: unit
    call syntax_write (syntax_cmd_list, unit)
  end subroutine syntax_cmd_list_write

@ %def syntax_cmd_list_write
<<Commands: procedures>>=
  subroutine define_cmd_list_syntax (ifile)
    type(ifile_t), intent(inout) :: ifile
    call ifile_append (ifile, "SEQ command_list = command*")
    call ifile_append (ifile, "ALT command = " &
         // "cmd_model | cmd_library | cmd_iterations | cmd_sample_format | " &
         // "cmd_var | cmd_slha | " &
         // "cmd_show | cmd_clear | " &
         // "cmd_expect | " &
         // "cmd_cuts | cmd_scale | cmd_fac_scale | cmd_ren_scale | " &
         // "cmd_weight | cmd_selection | cmd_reweight | " &
         // "cmd_beams | cmd_beams_pol_density | cmd_beams_pol_fraction | " &
         // "cmd_beams_momentum | cmd_beams_theta | cmd_beams_phi | " &
         // "cmd_integrate | " &
         // "cmd_observable | cmd_histogram | cmd_plot | cmd_graph | " &
         // "cmd_record | " &
         // "cmd_analysis | cmd_alt_setup | " &
         // "cmd_unstable | cmd_stable | cmd_simulate | cmd_rescan | " &
         // "cmd_process | cmd_compile | cmd_exec | " &
         // "cmd_scan | cmd_if | cmd_include | cmd_quit | " &
         // "cmd_polarized | cmd_unpolarized | " &
         // "cmd_open_out | cmd_close_out | cmd_printf | " &
         // "cmd_write_analysis | cmd_compile_analysis | cmd_nlo | cmd_components") 
    call ifile_append (ifile, "GRO options = '{' local_command_list '}'")
    call ifile_append (ifile, "SEQ local_command_list = local_command*")
    call ifile_append (ifile, "ALT local_command = " &
         // "cmd_model | cmd_library | cmd_iterations | cmd_sample_format | " &
         // "cmd_var | cmd_slha | " &
         // "cmd_show | " &
         // "cmd_expect | " &
         // "cmd_cuts | cmd_scale | cmd_fac_scale | cmd_ren_scale | " &
         // "cmd_weight | cmd_selection | cmd_reweight | " &
         // "cmd_beams | cmd_beams_pol_density | cmd_beams_pol_fraction | " &
         // "cmd_beams_momentum | cmd_beams_theta | cmd_beams_phi | " &
         // "cmd_observable | cmd_histogram | cmd_plot | cmd_graph | " &
         // "cmd_clear | cmd_record | " &
         // "cmd_analysis | cmd_alt_setup | " &
         // "cmd_open_out | cmd_close_out | cmd_printf | " &
         // "cmd_write_analysis | cmd_compile_analysis | cmd_nlo | cmd_components")
    call ifile_append (ifile, "SEQ cmd_model = model '=' model_name")
    call ifile_append (ifile, "KEY model")
    call ifile_append (ifile, "ALT model_name = model_id | string_literal")
    call ifile_append (ifile, "IDE model_id")
    call ifile_append (ifile, "SEQ cmd_library = library '=' lib_name")
    call ifile_append (ifile, "KEY library")
    call ifile_append (ifile, "ALT lib_name = lib_id | string_literal")
    call ifile_append (ifile, "IDE lib_id")
    call ifile_append (ifile, "ALT cmd_var = " &
         // "cmd_log_decl | cmd_log | " &
         // "cmd_int | cmd_real | cmd_complex | cmd_num | " &
         // "cmd_string_decl | cmd_string | cmd_alias | " &
         // "cmd_result")
    call ifile_append (ifile, "SEQ cmd_log_decl = logical cmd_log")
    call ifile_append (ifile, "SEQ cmd_log = '?' var_name '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_int = int var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_real = real var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_complex = complex var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_num = var_name '=' expr")
    call ifile_append (ifile, "SEQ cmd_string_decl = string cmd_string")
    call ifile_append (ifile, "SEQ cmd_string = " &
         // "'$' var_name '=' sexpr") ! $
    call ifile_append (ifile, "SEQ cmd_alias = alias var_name '=' cexpr")
    call ifile_append (ifile, "SEQ cmd_result = result '=' expr") 
    call ifile_append (ifile, "SEQ cmd_slha = slha_action slha_arg options?")
    call ifile_append (ifile, "ALT slha_action = " &
         // "read_slha | write_slha")
    call ifile_append (ifile, "KEY read_slha")
    call ifile_append (ifile, "KEY write_slha")
    call ifile_append (ifile, "ARG slha_arg = ( string_literal )")
    call ifile_append (ifile, "SEQ cmd_show = show show_arg options?")
    call ifile_append (ifile, "KEY show")
    call ifile_append (ifile, "ARG show_arg = ( showable* )")
    call ifile_append (ifile, "ALT showable = " &
         // "model | library | beams | iterations | " &
         // "cuts | weight | logical | string | pdg | " &
         // "scale | factorization_scale | renormalization_scale | " & 
	 // "selection | reweight | analysis | " &
         // "stable | unstable | polarized | unpolarized | " &
         // "expect | intrinsic | int | real | complex | " &
         // "alias_var | string | results | result_var | " &
         // "log_var | string_var | var_name")
    call ifile_append (ifile, "KEY results")
    call ifile_append (ifile, "KEY intrinsic")    
    call ifile_append (ifile, "SEQ alias_var = alias var_name")
    call ifile_append (ifile, "SEQ result_var = result_key result_arg?")
    call ifile_append (ifile, "SEQ log_var = '?' var_name")
    call ifile_append (ifile, "SEQ string_var = '$' var_name")  ! $
    call ifile_append (ifile, "SEQ cmd_clear = clear clear_arg options?")    
    call ifile_append (ifile, "KEY clear")
    call ifile_append (ifile, "ARG clear_arg = ( clearable* )")
    call ifile_append (ifile, "ALT clearable = " &
         // "beams | iterations | " &
         // "cuts | weight | " &
         // "scale | factorization_scale | renormalization_scale | " & 
	 // "selection | reweight | analysis | " &
         // "unstable | polarized | " &
         // "expect | " &
         // "log_var | string_var | var_name")
    call ifile_append (ifile, "SEQ cmd_expect = expect expect_arg options?")
    call ifile_append (ifile, "KEY expect")
    call ifile_append (ifile, "ARG expect_arg = ( lexpr )")
    call ifile_append (ifile, "SEQ cmd_cuts = cuts '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_scale = scale '=' expr")    
    call ifile_append (ifile, "SEQ cmd_fac_scale = " &
         // "factorization_scale '=' expr")
    call ifile_append (ifile, "SEQ cmd_ren_scale = " &
         // "renormalization_scale '=' expr")
    call ifile_append (ifile, "SEQ cmd_weight = weight '=' expr")
    call ifile_append (ifile, "SEQ cmd_selection = selection '=' lexpr")
    call ifile_append (ifile, "SEQ cmd_reweight = reweight '=' expr")
    call ifile_append (ifile, "KEY cuts")
    call ifile_append (ifile, "KEY scale")    
    call ifile_append (ifile, "KEY factorization_scale")
    call ifile_append (ifile, "KEY renormalization_scale")    
    call ifile_append (ifile, "KEY weight")
    call ifile_append (ifile, "KEY selection")
    call ifile_append (ifile, "KEY reweight")
    call ifile_append (ifile, "SEQ cmd_process = process process_id '=' " &
         // "process_prt '=>' prt_state_list options?")
    call ifile_append (ifile, "KEY process")
    call ifile_append (ifile, "KEY '=>'")
    call ifile_append (ifile, "LIS process_prt = cexpr+")
    call ifile_append (ifile, "LIS prt_state_list = prt_state_sum+")
    call ifile_append (ifile, "SEQ prt_state_sum = " &
         // "prt_state prt_state_addition*")
    call ifile_append (ifile, "SEQ prt_state_addition = '+' prt_state")
    call ifile_append (ifile, "ALT prt_state = grouped_prt_state_list | cexpr")
    call ifile_append (ifile, "GRO grouped_prt_state_list = " &
         // "( prt_state_list )")
    call ifile_append (ifile, "SEQ cmd_compile = compile_cmd options?")
    call ifile_append (ifile, "SEQ compile_cmd = compile_clause compile_arg?")
    call ifile_append (ifile, "SEQ compile_clause = compile exec_name_spec?")
    call ifile_append (ifile, "KEY compile")
    call ifile_append (ifile, "SEQ exec_name_spec = as exec_name")
    call ifile_append (ifile, "KEY as")
    call ifile_append (ifile, "ALT exec_name = exec_id | string_literal")
    call ifile_append (ifile, "IDE exec_id")
    call ifile_append (ifile, "ARG compile_arg = ( lib_name* )")
    call ifile_append (ifile, "SEQ cmd_exec = exec exec_arg")
    call ifile_append (ifile, "KEY exec")
    call ifile_append (ifile, "ARG exec_arg = ( sexpr )")
    call ifile_append (ifile, "SEQ cmd_beams = beams '=' beam_def")
    call ifile_append (ifile, "KEY beams")
    call ifile_append (ifile, "SEQ beam_def = beam_spec strfun_seq*")
    call ifile_append (ifile, "SEQ beam_spec = beam_list")
    call ifile_append (ifile, "LIS beam_list = cexpr, cexpr?")
    call ifile_append (ifile, "SEQ cmd_beams_pol_density = " &
         // "beams_pol_density '=' beams_pol_spec")
    call ifile_append (ifile, "KEY beams_pol_density")
    call ifile_append (ifile, "LIS beams_pol_spec = smatrix, smatrix?")
    call ifile_append (ifile, "SEQ smatrix = '@' smatrix_arg")
    ! call ifile_append (ifile, "KEY '@'")     !!! Key already exists
    call ifile_append (ifile, "ARG smatrix_arg = ( sentry* )")
    call ifile_append (ifile, "SEQ sentry = expr extra_sentry*")
    call ifile_append (ifile, "SEQ extra_sentry = ':' expr")
    call ifile_append (ifile, "SEQ cmd_beams_pol_fraction = " &
         // "beams_pol_fraction '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_pol_fraction")
    call ifile_append (ifile, "SEQ cmd_beams_momentum = " &
         // "beams_momentum '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_momentum")
    call ifile_append (ifile, "SEQ cmd_beams_theta = " &
         // "beams_theta '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_theta")
    call ifile_append (ifile, "SEQ cmd_beams_phi = " &
         // "beams_phi '=' beams_par_spec")
    call ifile_append (ifile, "KEY beams_phi")
    call ifile_append (ifile, "LIS beams_par_spec = expr, expr?")
    call ifile_append (ifile, "SEQ strfun_seq = '=>' strfun_pair")
    call ifile_append (ifile, "LIS strfun_pair = strfun_def, strfun_def?")
    call ifile_append (ifile, "SEQ strfun_def = strfun_id")
    call ifile_append (ifile, "ALT strfun_id = " &
          // "none | lhapdf | lhapdf_photon | pdf_builtin | pdf_builtin_photon | " &
          // "isr | epa | ewa | circe1 | circe2 | energy_scan | " &
          // "beam_events | user_sf_spec")
    call ifile_append (ifile, "KEY none")
    call ifile_append (ifile, "KEY lhapdf")
    call ifile_append (ifile, "KEY lhapdf_photon")    
    call ifile_append (ifile, "KEY pdf_builtin")    
    call ifile_append (ifile, "KEY pdf_builtin_photon")        
    call ifile_append (ifile, "KEY isr")
    call ifile_append (ifile, "KEY epa")
    call ifile_append (ifile, "KEY ewa")    
    call ifile_append (ifile, "KEY circe1")        
    call ifile_append (ifile, "KEY circe2")
    call ifile_append (ifile, "KEY energy_scan")
    call ifile_append (ifile, "KEY beam_events")
    call ifile_append (ifile, "SEQ user_sf_spec = user_strfun user_arg")
    call ifile_append (ifile, "KEY user_strfun")
    call ifile_append (ifile, "SEQ cmd_integrate = " &
         // "integrate proc_arg options?") 
    call ifile_append (ifile, "KEY integrate")
    call ifile_append (ifile, "ARG proc_arg = ( proc_id* )")
    call ifile_append (ifile, "IDE proc_id")
    call ifile_append (ifile, "SEQ cmd_iterations = " &
         // "iterations '=' iterations_list")
    call ifile_append (ifile, "KEY iterations")
    call ifile_append (ifile, "LIS iterations_list = iterations_spec+")
    call ifile_append (ifile, "ALT iterations_spec = it_spec")
    call ifile_append (ifile, "SEQ it_spec = expr calls_spec adapt_spec?")
    call ifile_append (ifile, "SEQ calls_spec = ':' expr")
    call ifile_append (ifile, "SEQ adapt_spec = ':' sexpr")
    call ifile_append (ifile, "SEQ cmd_components = " &
         // "active '=' component_list")
    call ifile_append (ifile, "KEY active")
    call ifile_append (ifile, "LIS component_list = sexpr+")
    call ifile_append (ifile, "SEQ cmd_sample_format = " &
         // "sample_format '=' event_format_list")
    call ifile_append (ifile, "KEY sample_format")
    call ifile_append (ifile, "LIS event_format_list = event_format+")
    call ifile_append (ifile, "IDE event_format")
    call ifile_append (ifile, "SEQ cmd_observable = " &
         // "observable analysis_tag options?")
    call ifile_append (ifile, "KEY observable")
    call ifile_append (ifile, "SEQ cmd_histogram = " &
         // "histogram analysis_tag histogram_arg " & 
         // "options?")
    call ifile_append (ifile, "KEY histogram")
    call ifile_append (ifile, "ARG histogram_arg = (expr, expr, expr?)")
    call ifile_append (ifile, "SEQ cmd_plot = plot analysis_tag options?")
    call ifile_append (ifile, "KEY plot")
    call ifile_append (ifile, "SEQ cmd_graph = graph graph_term '=' graph_def")
    call ifile_append (ifile, "KEY graph")
    call ifile_append (ifile, "SEQ graph_term = analysis_tag options?")
    call ifile_append (ifile, "SEQ graph_def = graph_term graph_append*")
    call ifile_append (ifile, "SEQ graph_append = '&' graph_term")
    call ifile_append (ifile, "SEQ cmd_analysis = analysis '=' lexpr")
    call ifile_append (ifile, "KEY analysis")
    call ifile_append (ifile, "SEQ cmd_alt_setup = " &
         // "alt_setup '=' option_list_expr")
    call ifile_append (ifile, "KEY alt_setup")
    call ifile_append (ifile, "ALT option_list_expr = " &
         // "grouped_option_list | option_list")
    call ifile_append (ifile, "GRO grouped_option_list = ( option_list_expr )")
    call ifile_append (ifile, "LIS option_list = options+")
    call ifile_append (ifile, "SEQ cmd_open_out = open_out open_arg options?")
    call ifile_append (ifile, "SEQ cmd_close_out = close_out open_arg options?")
    call ifile_append (ifile, "KEY open_out")
    call ifile_append (ifile, "KEY close_out")
    call ifile_append (ifile, "ARG open_arg = (sexpr)")
    call ifile_append (ifile, "SEQ cmd_printf = printf_cmd options?")
    call ifile_append (ifile, "SEQ printf_cmd = printf_clause sprintf_args?")
    call ifile_append (ifile, "SEQ printf_clause = printf sexpr")
    call ifile_append (ifile, "KEY printf")
    call ifile_append (ifile, "SEQ cmd_record = record_cmd")
    call ifile_append (ifile, "SEQ cmd_unstable = " &
         // "unstable cexpr unstable_arg options?")
    call ifile_append (ifile, "KEY unstable")
    call ifile_append (ifile, "ARG unstable_arg = ( proc_id* )")
    call ifile_append (ifile, "SEQ cmd_stable = stable stable_list options?")
    call ifile_append (ifile, "KEY stable")
    call ifile_append (ifile, "LIS stable_list = cexpr+")
    call ifile_append (ifile, "KEY polarized")
    call ifile_append (ifile, "SEQ cmd_polarized = polarized polarized_list options?")
    call ifile_append (ifile, "LIS polarized_list = cexpr+")
    call ifile_append (ifile, "KEY unpolarized")
    call ifile_append (ifile, "SEQ cmd_unpolarized = unpolarized unpolarized_list options?")
    call ifile_append (ifile, "LIS unpolarized_list = cexpr+")
    call ifile_append (ifile, "SEQ cmd_simulate = " &
         // "simulate proc_arg options?")
    call ifile_append (ifile, "KEY simulate")
    call ifile_append (ifile, "SEQ cmd_rescan = " &
         // "rescan sexpr proc_arg options?")
    call ifile_append (ifile, "KEY rescan")
    call ifile_append (ifile, "SEQ cmd_scan = scan scan_var scan_body?")
    call ifile_append (ifile, "KEY scan")
    call ifile_append (ifile, "ALT scan_var = " &
         // "scan_log_decl | scan_log | " &
         // "scan_int | scan_real | scan_complex | scan_num | " &
         // "scan_string_decl | scan_string | scan_alias | " &
         // "scan_cuts | scan_weight | " &
         // "scan_scale | scan_ren_scale | scan_fac_scale | " &
         // "scan_selection | scan_reweight | scan_analysis | " &
         // "scan_model | scan_library")
    call ifile_append (ifile, "SEQ scan_log_decl = logical scan_log")
    call ifile_append (ifile, "SEQ scan_log = '?' var_name '=' scan_log_arg")
    call ifile_append (ifile, "ARG scan_log_arg = ( lexpr* )")
    call ifile_append (ifile, "SEQ scan_int = int var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_real = real var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_complex = " &
         // "complex var_name '=' scan_num_arg")
    call ifile_append (ifile, "SEQ scan_num = var_name '=' scan_num_arg")
    call ifile_append (ifile, "ARG scan_num_arg = ( range* )")
    call ifile_append (ifile, "ALT range = grouped_range | range_expr")
    call ifile_append (ifile, "GRO grouped_range = ( range_expr )")
    call ifile_append (ifile, "SEQ range_expr = expr range_spec?")
    call ifile_append (ifile, "SEQ range_spec = '=>' expr step_spec?")
    call ifile_append (ifile, "SEQ step_spec = step_op expr")
    call ifile_append (ifile, "ALT step_op = " &
         // "'/+' | '/-' | '/*' | '//' | '/+/' | '/*/'")
    call ifile_append (ifile, "KEY '/+'")
    call ifile_append (ifile, "KEY '/-'")
    call ifile_append (ifile, "KEY '/*'")
    call ifile_append (ifile, "KEY '//'")
    call ifile_append (ifile, "KEY '/+/'")
    call ifile_append (ifile, "KEY '/*/'")
    call ifile_append (ifile, "SEQ scan_string_decl = string scan_string")
    call ifile_append (ifile, "SEQ scan_string = " &
         // "'$' var_name '=' scan_string_arg")
    call ifile_append (ifile, "ARG scan_string_arg = ( sexpr* )")
    call ifile_append (ifile, "SEQ scan_alias = " &
         // "alias var_name '=' scan_alias_arg")
    call ifile_append (ifile, "ARG scan_alias_arg = ( cexpr* )")
    call ifile_append (ifile, "SEQ scan_cuts = cuts '=' scan_lexpr_arg")
    call ifile_append (ifile, "ARG scan_lexpr_arg = ( lexpr* )")
    call ifile_append (ifile, "SEQ scan_scale = scale '=' scan_expr_arg")
    call ifile_append (ifile, "ARG scan_expr_arg = ( expr* )")
    call ifile_append (ifile, "SEQ scan_fac_scale = " &
         // "factorization_scale '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_ren_scale = " &
         // "renormalization_scale '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_weight = weight '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_selection = selection '=' scan_lexpr_arg")
    call ifile_append (ifile, "SEQ scan_reweight = reweight '=' scan_expr_arg")
    call ifile_append (ifile, "SEQ scan_analysis = analysis '=' scan_lexpr_arg")
    call ifile_append (ifile, "SEQ scan_model = model '=' scan_model_arg")
    call ifile_append (ifile, "ARG scan_model_arg = ( model_name* )")
    call ifile_append (ifile, "SEQ scan_library = library '=' scan_library_arg")
    call ifile_append (ifile, "ARG scan_library_arg = ( lib_name* )")
    call ifile_append (ifile, "GRO scan_body = '{' command_list '}'")
    call ifile_append (ifile, "SEQ cmd_if = " &
         // "if lexpr then command_list elsif_clauses else_clause endif")
    call ifile_append (ifile, "SEQ elsif_clauses = cmd_elsif*")
    call ifile_append (ifile, "SEQ cmd_elsif = elsif lexpr then command_list")
    call ifile_append (ifile, "SEQ else_clause = cmd_else?")
    call ifile_append (ifile, "SEQ cmd_else = else command_list")
    call ifile_append (ifile, "SEQ cmd_include = include include_arg")
    call ifile_append (ifile, "KEY include")
    call ifile_append (ifile, "ARG include_arg = ( string_literal )")
    call ifile_append (ifile, "SEQ cmd_quit = quit_cmd quit_arg?")
    call ifile_append (ifile, "ALT quit_cmd = quit | exit")
    call ifile_append (ifile, "KEY quit")
    call ifile_append (ifile, "KEY exit")
    call ifile_append (ifile, "ARG quit_arg = ( expr )")
    call ifile_append (ifile, "SEQ cmd_write_analysis = " &
         // "write_analysis_clause options?")
    call ifile_append (ifile, "SEQ cmd_compile_analysis = " &
         // "compile_analysis_clause options?")
    call ifile_append (ifile, "SEQ write_analysis_clause = " &
         // "write_analysis write_analysis_arg?")
    call ifile_append (ifile, "SEQ compile_analysis_clause = " &
         // "compile_analysis write_analysis_arg?")
    call ifile_append (ifile, "KEY write_analysis")
    call ifile_append (ifile, "KEY compile_analysis")
    call ifile_append (ifile, "ARG write_analysis_arg = ( analysis_tag* )")
    call ifile_append (ifile, "SEQ cmd_nlo = " &
                       // "nlo_calculation '=' nlo_calculation_list")
    call ifile_append (ifile, "KEY nlo_calculation")
    call ifile_append (ifile, "LIS nlo_calculation_list = sexpr ',' sexpr ',' sexpr")
    call define_expr_syntax (ifile, particles=.true., analysis=.true.)
  end subroutine define_cmd_list_syntax

@ %def define_cmd_list_syntax
<<Commands: public>>=
  public :: lexer_init_cmd_list
<<Commands: procedures>>=
  subroutine lexer_init_cmd_list (lexer, parent_lexer)
    type(lexer_t), intent(out) :: lexer
    type(lexer_t), intent(in), optional, target :: parent_lexer
    call lexer_init (lexer, &
         comment_chars = "#!", &
         quote_chars = '"', &
         quote_match = '"', &
         single_chars = "()[]{},;:&%?$@", &
         special_class = [ "+-*/^", "<>=~ " ] , &
         keyword_list = syntax_get_keyword_list_ptr (syntax_cmd_list), &
         parent = parent_lexer)
  end subroutine lexer_init_cmd_list

@ %def lexer_init_cmd_list
@ 
\subsection{Unit Tests}
<<Commands: public>>=
  public :: commands_test
<<Commands: tests>>=
  subroutine commands_test (u, results)
    integer, intent(in) :: u
    type(test_results_t), intent(inout) :: results
  <<Commands: execute tests>>
  end subroutine commands_test
  
@ %def commands_test
@
\subsubsection{Prepare Sindarin code}
This routine parses an internal file, prints the parse tree, and
returns a parse node to the root.  We use the routine in the tests
below.
<<Commands: tests>>=
  subroutine parse_ifile (ifile, pn_root, u)
    type(ifile_t), intent(in) :: ifile
    type(parse_node_t), pointer, intent(out) :: pn_root
    integer, intent(in), optional :: u
    type(stream_t), target :: stream
    type(lexer_t), target :: lexer
    type(parse_tree_t) :: parse_tree

    call lexer_init_cmd_list (lexer)
    call stream_init (stream, ifile)
    call lexer_assign_stream (lexer, stream)

    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    if (present (u))  call parse_tree_write (parse_tree, u)
    pn_root => parse_tree_get_root_ptr (parse_tree)

    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine parse_ifile

@ %def parse_ifile
@
\subsubsection{Empty command list}
Compile and execute an empty command list.  Should do nothing but
test the integrity of the workflow.
<<Commands: execute tests>>=
  call test (commands_1, "commands_1", &
       "empty command list", &
       u, results)
<<Commands: tests>>=
  subroutine commands_1 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_1"
    write (u, "(A)")  "*   Purpose: compile and execute empty command list"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Parse empty file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"

    if (associated (pn_root)) then
       call command_list%compile (pn_root, global)
    end if

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call global%activate ()
    call command_list%execute (global)
    call global%deactivate ()

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_1"

  end subroutine commands_1

@ %def commands_1
@
\subsubsection{Read model}
Execute a [[model]] assignment.
<<Commands: execute tests>>=
  call test (commands_2, "commands_2", &
       "model", &
       u, results)
<<Commands: tests>>=
  subroutine commands_2 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_2"
    write (u, "(A)")  "*   Purpose: set model"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    
    call ifile_write (ifile, u)

    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_2"

  end subroutine commands_2

@ %def commands_2
@
\subsubsection{Declare Process}
Read a model, then declare a process.  The process library is allocated
explicitly.  For the process definition, We take the default ([[omega]])
method.  Since we do not compile, \oMega\ is not actually called.
<<Commands: execute tests>>=
  call test (commands_3, "commands_3", &
       "process declaration", &
       u, results)
<<Commands: tests>>=
  subroutine commands_3 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_3"
    write (u, "(A)")  "*   Purpose: define process"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd3"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t3 = s, s => s, s')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_3"

  end subroutine commands_3

@ %def commands_3
@
\subsubsection{Compile Process}
Read a model, then declare a process and compile the library.  The process
library is allocated explicitly.  For the process definition, We take the
default ([[unit_test]]) method.  There is no external code, so compilation of
the library is merely a formal status change.
<<Commands: execute tests>>=
  call test (commands_4, "commands_4", &
       "compilation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_4 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_4"
    write (u, "(A)")  "*   Purpose: define process and compile library"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd4"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t4 = s, s => s, s')
    call ifile_append (ifile, 'compile ("lib_cmd4")')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_4"

  end subroutine commands_4

@ %def commands_4
@
\subsubsection{Integrate Process}
Read a model, then declare a process, compile the library, and
integrate over phase space.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.
<<Commands: execute tests>>=
  call test (commands_5, "commands_5", &
       "integration", &
       u, results)
<<Commands: tests>>=
  subroutine commands_5 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_5"
    write (u, "(A)")  "*   Purpose: define process, iterations, and integrate"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_int (global%var_list, var_str ("seed"), &
         0, is_known=.true.)
    
    allocate (lib)
    call lib%init (var_str ("lib_cmd5"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t5 = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (t5)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call reset_interaction_counter ()
    call command_list%execute (global)

    call global%it_list%write (u)
    write (u, "(A)")
    call global%process_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_5"

  end subroutine commands_5

@ %def commands_5
@
\subsubsection{Variables}
Set intrinsic and user-defined variables.
<<Commands: execute tests>>=
  call test (commands_6, "commands_6", &
       "variables", &
       u, results)
<<Commands: tests>>=
  subroutine commands_6 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_6"
    write (u, "(A)")  "*   Purpose: define and set variables"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    call global%write_vars (u, [ &
         var_str ("$run_id"), &
         var_str ("?unweighted"), &
         var_str ("sqrts")])

    write (u, "(A)")
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$run_id = "run1"')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'sqrts = 1000')
    call ifile_append (ifile, 'int j = 10')
    call ifile_append (ifile, 'real x = 1000.')
    call ifile_append (ifile, 'complex z = 5')
    call ifile_append (ifile, 'string $text = "abcd"')
    call ifile_append (ifile, 'logical ?flag = true')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_vars (u, [ &
         var_str ("$run_id"), &
         var_str ("?unweighted"), &
         var_str ("sqrts"), &
         var_str ("j"), &
         var_str ("x"), &
         var_str ("z"), &
         var_str ("$text"), &
         var_str ("?flag")])


    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_6"

  end subroutine commands_6

@ %def commands_6
@
\subsubsection{Process library}
Open process libraries explicitly.
<<Commands: execute tests>>=
  call test (commands_7, "commands_7", &
       "process library", &
       u, results)
<<Commands: tests>>=
  subroutine commands_7 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_7"
    write (u, "(A)")  "*   Purpose: declare process libraries"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    global%os_data%fc = "Fortran-compiler"
    global%os_data%fcflags = "Fortran-flags"

    write (u, "(A)")
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'library = "lib_cmd7_1"')
    call ifile_append (ifile, 'library = "lib_cmd7_2"')
    call ifile_append (ifile, 'library = "lib_cmd7_1"')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_libraries (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call syntax_cmd_list_final ()
    call global%final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_7"

  end subroutine commands_7

@ %def commands_7
@
\subsubsection{Generate events}
Read a model, then declare a process, compile the library, and
generate weighted events.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.
<<Commands: execute tests>>=
  call test (commands_8, "commands_8", &
       "event generation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_8 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_8"
    write (u, "(A)")  "*   Purpose: define process, integrate, generate events"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd8"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_8_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_8_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'simulate (commands_8_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_8"

  end subroutine commands_8

@ %def commands_8
@
\subsubsection{Define cuts}
Declare a cut expression.
<<Commands: execute tests>>=
  call test (commands_9, "commands_9", &
       "cuts", &
       u, results)
<<Commands: tests>>=
  subroutine commands_9 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(string_t), dimension(0) :: no_vars

    write (u, "(A)")  "* Test output: commands_9"
    write (u, "(A)")  "*   Purpose: define cuts"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'cuts = all Pt > 0 [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_9"

  end subroutine commands_9

@ %def commands_9
@
\subsubsection{Beams}
Define beam setup.
<<Commands: execute tests>>=
  call test (commands_10, "commands_10", &
       "beams", &
       u, results)
<<Commands: tests>>=
  subroutine commands_10 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_10"
    write (u, "(A)")  "*   Purpose: define beams"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = QCD')
    call ifile_append (ifile, 'sqrts = 1000')
    call ifile_append (ifile, 'beams = p, p')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_beams (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_10"

  end subroutine commands_10

@ %def commands_10
@
\subsubsection{Structure functions}
Define beam setup with structure functions
<<Commands: execute tests>>=
  call test (commands_11, "commands_11", &
       "structure functions", &
       u, results)
<<Commands: tests>>=
  subroutine commands_11 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_11"
    write (u, "(A)")  "*   Purpose: define beams with structure functions"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = QCD')
    call ifile_append (ifile, 'sqrts = 1100')
    call ifile_append (ifile, 'beams = p, p => lhapdf => pdf_builtin, isr')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_beams (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_11"

  end subroutine commands_11

@ %def commands_11
@
\subsubsection{Rescan events}
Read a model, then declare a process, compile the library, and
generate weighted events.  We take the
default ([[unit_test]]) method and use the simplest methods of
phase-space parameterization and integration.  Then, rescan the
generated event sample.
<<Commands: execute tests>>=
  call test (commands_12, "commands_12", &
       "event rescanning", &
       u, results)
<<Commands: tests>>=
  subroutine commands_12 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_12"
    write (u, "(A)")  "*   Purpose: generate events and rescan"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()

    call global%global_init ()
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_phase_space"), .false., &
         intrinsic=.true.)
    call var_list_append_log (global%var_list, &
         var_str ("?rebuild_grids"), .false., &
         intrinsic=.true.)
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd12"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_12_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_12_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'simulate (commands_12_p)')
    call ifile_append (ifile, '?write_raw = false')
    call ifile_append (ifile, 'rescan "commands_12_p" (commands_12_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_12"

  end subroutine commands_12

@ %def commands_12
@
\subsubsection{Event Files}
Set output formats for event files.
<<Commands: execute tests>>=
  call test (commands_13, "commands_13", &
       "event output formats", &
       u, results)
<<Commands: tests>>=
  subroutine commands_13 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib
    logical :: exist

    write (u, "(A)")  "* Test output: commands_13"
    write (u, "(A)")  "*   Purpose: generate events and rescan"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    

    allocate (lib)
    call lib%init (var_str ("lib_cmd13"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_13_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (commands_13_p)')
    call ifile_append (ifile, '?unweighted = false')
    call ifile_append (ifile, 'n_events = 1')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'sample_format = weight_stream')
    call ifile_append (ifile, 'simulate (commands_13_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"

    call command_list%execute (global)

    write (u, "(A)")
    write (u, "(A)")  "* Verify output files"
    write (u, "(A)")

    inquire (file = "commands_13_p.evx", exist = exist)
    if (exist)  write (u, "(1x,A)")  "raw"

    inquire (file = "commands_13_p.weights.dat", exist = exist)
    if (exist)  write (u, "(1x,A)")  "weight_stream"

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_13"

  end subroutine commands_13

@ %def commands_13
@
\subsubsection{Compile Empty Libraries}
(This is a regression test:)  Declare two empty libraries and compile them.
<<Commands: execute tests>>=
  call test (commands_14, "commands_14", &
       "empty libraries", &
       u, results)
<<Commands: tests>>=
  subroutine commands_14 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_14"
    write (u, "(A)")  "*   Purpose: define and compile empty libraries"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_cmd_list_init ()

    call global%global_init ()

    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'library = "lib1"')
    call ifile_append (ifile, 'library = "lib2"')
    call ifile_append (ifile, 'compile ()')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()

    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_14"

  end subroutine commands_14

@ %def commands_14
@
\subsubsection{Compile Process}
Read a model, then declare a process and compile the library.  The process
library is allocated explicitly.  For the process definition, We take the
default ([[unit_test]]) method.  There is no external code, so compilation of
the library is merely a formal status change.
<<Commands: execute tests>>=
  call test (commands_15, "commands_15", &
       "compilation", &
       u, results)
<<Commands: tests>>=
  subroutine commands_15 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_15"
    write (u, "(A)")  "*   Purpose: define process and compile library"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    allocate (lib)
    call lib%init (var_str ("lib_cmd15"))
    call global%add_prclib (lib)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process t15 = s, s => s, s')
    call ifile_append (ifile, 'iterations = 1:1000')
    call ifile_append (ifile, 'integrate (t15)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%prclib_stack%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_15"

  end subroutine commands_15

@ %def commands_15
@
\subsubsection{Observable}
Declare an observable, fill it and display.
<<Commands: execute tests>>=
  call test (commands_16, "commands_16", &
       "observables", &
       u, results)
<<Commands: tests>>=
  subroutine commands_16 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_16"
    write (u, "(A)")  "*   Purpose: declare an observable"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Observable foo"')
    call ifile_append (ifile, '$description = "This is observable foo"')
    call ifile_append (ifile, 'observable foo')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    call analysis_record_data (var_str ("foo"), 1._default)
    call analysis_record_data (var_str ("foo"), 3._default)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_16"

  end subroutine commands_16

@ %def commands_16
@
\subsubsection{Histogram}
Declare a histogram, fill it and display.
<<Commands: execute tests>>=
  call test (commands_17, "commands_17", &
       "histograms", &
       u, results)
<<Commands: tests>>=
  subroutine commands_17 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(string_t), dimension(3) :: name
    integer :: i

    write (u, "(A)")  "* Test output: commands_17"
    write (u, "(A)")  "*   Purpose: declare histograms"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Histogram foo"')
    call ifile_append (ifile, '$description = "This is histogram foo"')
    call ifile_append (ifile, 'histogram foo (0,5,1)')
    call ifile_append (ifile, '$title = "Histogram bar"')
    call ifile_append (ifile, '$description = "This is histogram bar"')
    call ifile_append (ifile, 'n_bins = 2')
    call ifile_append (ifile, 'histogram bar (0,5)')
    call ifile_append (ifile, '$title = "Histogram gee"')
    call ifile_append (ifile, '$description = "This is histogram gee"')
    call ifile_append (ifile, '?normalize_bins = true')
    call ifile_append (ifile, 'histogram gee (0,5)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    name(1) = "foo"
    name(2) = "bar"
    name(3) = "gee"
    
    do i = 1, 3
       call analysis_record_data (name(i), 0.1_default, &
            weight = 0.25_default)
       call analysis_record_data (name(i), 3.1_default)
       call analysis_record_data (name(i), 4.1_default, &
            excess = 0.5_default)
       call analysis_record_data (name(i), 7.1_default)
    end do

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_17"

  end subroutine commands_17

@ %def commands_17
@
\subsubsection{Plot}
Declare a plot, fill it and display contents.
<<Commands: execute tests>>=
  call test (commands_18, "commands_18", &
       "plots", &
       u, results)
<<Commands: tests>>=
  subroutine commands_18 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_18"
    write (u, "(A)")  "*   Purpose: declare a plot"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$obs_label = "foo"')
    call ifile_append (ifile, '$obs_unit = "cm"')
    call ifile_append (ifile, '$title = "Plot foo"')
    call ifile_append (ifile, '$description = "This is plot foo"')
    call ifile_append (ifile, '$x_label = "x axis"')
    call ifile_append (ifile, '$y_label = "y axis"')
    call ifile_append (ifile, '?x_log = false')
    call ifile_append (ifile, '?y_log = true')
    call ifile_append (ifile, 'x_min = -1')
    call ifile_append (ifile, 'x_max = 1')
    call ifile_append (ifile, 'y_min = 0.1')
    call ifile_append (ifile, 'y_max = 1000')
    call ifile_append (ifile, 'plot foo')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Record two data items"
    write (u, "(A)")

    call analysis_record_data (var_str ("foo"), 0._default, 20._default, &
         xerr = 0.25_default)
    call analysis_record_data (var_str ("foo"), 0.5_default, 0.2_default, &
         yerr = 0.07_default)
    call analysis_record_data (var_str ("foo"), 3._default, 2._default)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_18"

  end subroutine commands_18

@ %def commands_18
@
\subsubsection{Graph}
Combine two (empty) plots to a graph.
<<Commands: execute tests>>=
  call test (commands_19, "commands_19", &
       "graphs", &
       u, results)
<<Commands: tests>>=
  subroutine commands_19 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_19"
    write (u, "(A)")  "*   Purpose: combine two plots to a graph"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'plot a')
    call ifile_append (ifile, 'plot b')
    call ifile_append (ifile, '$title = "Graph foo"')
    call ifile_append (ifile, '$description = "This is graph foo"')
    call ifile_append (ifile, 'graph foo = a & b')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (var_str ("foo"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_19"

  end subroutine commands_19

@ %def commands_19
@
\subsubsection{Record Data}
Record data in previously allocated analysis objects.
<<Commands: execute tests>>=
  call test (commands_20, "commands_20", &
       "record data", &
       u, results)
<<Commands: tests>>=
  subroutine commands_20 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_20"
    write (u, "(A)")  "*   Purpose: record data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable, histogram, plot"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call analysis_init_observable (var_str ("o"))
    call analysis_init_histogram (var_str ("h"), 0._default, 1._default, 3, &
         normalize_bins = .false.)
    call analysis_init_plot (var_str ("p"))
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'record o (1.234)')
    call ifile_append (ifile, 'record h (0.5)')
    call ifile_append (ifile, 'record p (1, 2)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (u, verbose = .true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_20"

  end subroutine commands_20

@ %def commands_20
@
\subsubsection{Analysis}
Declare an analysis expression and use it to fill an observable during
event generation.
<<Commands: execute tests>>=
  call test (commands_21, "commands_21", &
       "analysis expression", &
       u, results)
<<Commands: tests>>=
  subroutine commands_21 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_21"
    write (u, "(A)")  "*   Purpose: create and use analysis expression"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))

    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)        
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    call var_list_set_real (global%var_list, var_str ("sqrts"), &
         1000._default, is_known=.true.)

    allocate (lib)
    call lib%init (var_str ("lib_cmd8"))
    call global%add_prclib (lib)
    
    call analysis_init_observable (var_str ("m"))
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_21_p = s, s => s, s')
    call ifile_append (ifile, 'compile')
    call ifile_append (ifile, 'iterations = 1:100')
    call ifile_append (ifile, 'integrate (commands_21_p)')
    call ifile_append (ifile, '?unweighted = true')
    call ifile_append (ifile, 'n_events = 3')
    call ifile_append (ifile, '?read_raw = false')
    call ifile_append (ifile, 'observable m')
    call ifile_append (ifile, 'analysis = record m (eval M [s])')
    call ifile_append (ifile, 'simulate (commands_21_p)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis object"
    write (u, "(A)")

    call analysis_write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_21"

  end subroutine commands_21

@ %def commands_21
@
\subsubsection{Write Analysis}
Write accumulated analysis data to file.
<<Commands: execute tests>>=
  call test (commands_22, "commands_22", &
       "write analysis", &
       u, results)
<<Commands: tests>>=
  subroutine commands_22 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    logical :: exist
    character(80) :: buffer

    write (u, "(A)")  "* Test output: commands_22"
    write (u, "(A)")  "*   Purpose: write analysis data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create observable"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call analysis_init_observable (var_str ("m"))
    call analysis_record_data (var_str ("m"), 125._default)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$out_file = "commands_22.dat"')
    call ifile_append (ifile, 'write_analysis')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis data"
    write (u, "(A)")

    inquire (file = "commands_22.dat", exist = exist)
    if (.not. exist) then
       write (u, "(A)")  "ERROR: File commands_22.dat not found"
       return
    end if
    
    u_file = free_unit ()
    open (u_file, file = "commands_22.dat", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_22"

  end subroutine commands_22

@ %def commands_22
@
\subsubsection{Compile Analysis}
Write accumulated analysis data to file and compile.
<<Commands: execute tests>>=
  call test (commands_23, "commands_23", &
       "compile analysis", &
       u, results)
<<Commands: tests>>=
  subroutine commands_23 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    character(256) :: buffer
    logical :: exist
    type(graph_options_t) :: graph_options

    write (u, "(A)")  "* Test output: commands_23"
    write (u, "(A)")  "*   Purpose: write and compile analysis data"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization: create and fill histogram"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    call graph_options_init (graph_options)
    call graph_options_set (graph_options, &
         title = var_str ("Histogram for test: commands 23"), &
         description = var_str ("This is a test."), &
         width_mm = 125, height_mm = 85)
    call analysis_init_histogram (var_str ("h"), &
         0._default, 10._default, 2._default, .false., &
         graph_options = graph_options)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 1._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 3._default)
    call analysis_record_data (var_str ("h"), 5._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 7._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    call analysis_record_data (var_str ("h"), 9._default)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$out_file = "commands_23.dat"')
    call ifile_append (ifile, 'compile_analysis')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Delete Postscript output"
    write (u, "(A)")
    
    inquire (file = "commands_23.ps", exist = exist)
    if (exist) then
       u_file = free_unit ()
       open (u_file, file = "commands_23.ps", action = "write", status = "old")
       close (u_file, status = "delete")
    end if
    inquire (file = "commands_23.ps", exist = exist)
    write (u, "(1x,A,L1)")  "Postcript output exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* TeX file"
    write (u, "(A)")

    inquire (file = "commands_23.tex", exist = exist)
    if (.not. exist) then
       write (u, "(A)")  "ERROR: File commands_23.tex not found"
       return
    end if
    
    u_file = free_unit ()
    open (u_file, file = "commands_23.tex", &
         action = "read", status = "old")
    do
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0)  exit
       write (u, "(A)") trim (buffer)
    end do
    close (u_file)
    write (u, *)
    
    inquire (file = "commands_23.ps", exist = exist)
    write (u, "(1x,A,L1)")  "Postcript output exists = ", exist

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_23"

  end subroutine commands_23

@ %def commands_23
@
\subsubsection{Histogram}
Declare a histogram, fill it and display.
<<Commands: execute tests>>=
  call test (commands_24, "commands_24", &
       "drawing options", &
       u, results)
<<Commands: tests>>=
  subroutine commands_24 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_24"
    write (u, "(A)")  "*   Purpose: check graph and drawing options"
    write (u, "(A)")

    write (u, "(A)")  "* Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, '$title = "Title"')
    call ifile_append (ifile, '$description = "Description"')
    call ifile_append (ifile, '$x_label = "X Label"')
    call ifile_append (ifile, '$y_label = "Y Label"')
    call ifile_append (ifile, 'graph_width_mm = 111')
    call ifile_append (ifile, 'graph_height_mm = 222')
    call ifile_append (ifile, 'x_min = -11')
    call ifile_append (ifile, 'x_max = 22')
    call ifile_append (ifile, 'y_min = -33')
    call ifile_append (ifile, 'y_max = 44')
    call ifile_append (ifile, '$gmlcode_bg = "GML Code BG"')
    call ifile_append (ifile, '$gmlcode_fg = "GML Code FG"')
    call ifile_append (ifile, '$fill_options = "Fill Options"')
    call ifile_append (ifile, '$draw_options = "Draw Options"')
    call ifile_append (ifile, '$err_options = "Error Options"')
    call ifile_append (ifile, '$symbol = "Symbol"')
    call ifile_append (ifile, 'histogram foo (0,1)')
    call ifile_append (ifile, 'plot bar')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)

    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Display analysis store"
    write (u, "(A)")

    call analysis_write (u, verbose=.true.)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call analysis_final ()
    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_24"

  end subroutine commands_24

@ %def commands_24
@
\subsubsection{Local Environment}
Declare a local environment.
<<Commands: execute tests>>=
  call test (commands_25, "commands_25", &
       "local process environment", &
       u, results)
<<Commands: tests>>=
  subroutine commands_25 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_25"
    write (u, "(A)")  "*   Purpose: declare local environment for process"
    write (u, "(A)")

    call syntax_model_file_init ()
    call syntax_cmd_list_init ()
    call global%global_init ()
    call var_list_set_log (global%var_list, var_str ("?omega_openmp"), &
         .false., is_known = .true.)
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'library = "commands_25_lib"')
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'process commands_25_p1 = g, g => g, g &
         &{ model = "QCD" }')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)
    call global%write_libraries (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_25"

  end subroutine commands_25

@ %def commands_25
@
\subsubsection{Alternative Setups}
Declare a list of alternative setups.
<<Commands: execute tests>>=
  call test (commands_26, "commands_26", &
       "alternative setups", &
       u, results)
<<Commands: tests>>=
  subroutine commands_26 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_26"
    write (u, "(A)")  "*   Purpose: declare alternative setups for simulation"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()
    
    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'int i = 0')
    call ifile_append (ifile, 'alt_setup = ({ i = 1 }, { i = 2 })')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)
    
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_26"

  end subroutine commands_26

@ %def commands_26
@
\subsubsection{Unstable Particle}
Define decay processes and declare a particle as unstable.  Also check
the commands stable, polarized, unpolarized.
<<Commands: execute tests>>=
  call test (commands_27, "commands_27", &
       "unstable and polarized particles", &
       u, results)
<<Commands: tests>>=
  subroutine commands_27 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    type(prclib_entry_t), pointer :: lib

    write (u, "(A)")  "* Test output: commands_27"
    write (u, "(A)")  "*   Purpose: modify particle properties"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call global%global_init ()
    call var_list_set_string (global%var_list, var_str ("$method"), &
         var_str ("unit_test"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$phs_method"), &
         var_str ("single"), is_known=.true.)
    call var_list_set_string (global%var_list, var_str ("$integration_method"),&
         var_str ("midpoint"), is_known=.true.)
    call var_list_set_log (global%var_list, var_str ("?vis_history"),&
         .false., is_known=.true.)    
    call var_list_set_log (global%var_list, var_str ("?integration_timer"),&
         .false., is_known = .true.)    
    
    allocate (lib)
    call lib%init (var_str ("commands_27_lib"))
    call global%add_prclib (lib)

    write (u, "(A)")  "* Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "Test"')
    call ifile_append (ifile, 'ff = 0.4')
    call ifile_append (ifile, 'process d1 = s => f, fbar')
    call ifile_append (ifile, 'unstable s (d1)')
    call ifile_append (ifile, 'polarized f, fbar')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, '?diagonal_decay = true')
    call ifile_append (ifile, 'unstable s (d1)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, '?isotropic_decay = true')
    call ifile_append (ifile, 'unstable s (d1)')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Extra Input"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call ifile_append (ifile, 'stable s')
    call ifile_append (ifile, 'unpolarized f')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "* Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root)

    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%final ()
    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Show model"
    write (u, "(A)")
    
    call global%model%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_model_file_init ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_27"

  end subroutine commands_27

@ %def commands_27
@ 
\subsubsection{Quit the program}
Quit the program.
<<Commands: execute tests>>=
  call test (commands_28, "commands_28", &
       "quit", &
       u, results)
<<Commands: tests>>=
  subroutine commands_28 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root1, pn_root2
    type(string_t), dimension(0) :: no_vars

    write (u, "(A)")  "* Test output: commands_28"
    write (u, "(A)")  "*   Purpose: quit the program"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()    
    
    write (u, "(A)")  "*  Input file: quit without code"
    write (u, "(A)")
    
    call ifile_append (ifile, 'quit')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root1, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root1, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "*  Input file: quit with code"
    write (u, "(A)")
    
    call ifile_final (ifile)
    call command_list%final ()
    call ifile_append (ifile, 'quit ( 3 + 4 )')        
   
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root2, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root2, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write (u, vars = no_vars)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_28"

  end subroutine commands_28

@ %def commands_28
@
@ 
\subsubsection{SLHA interface}
Testing commands steering the SLHA interface.
<<Commands: execute tests>>=
  call test (commands_29, "commands_29", &
       "SLHA interface", &
       u, results)
<<Commands: tests>>=
  subroutine commands_29 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(var_list_t), pointer :: model_vars
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_29"
    write (u, "(A)")  "*   Purpose: test SLHA interface"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call syntax_model_file_init ()
    call syntax_slha_init ()
    call global%global_init ()
    
    write (u, "(A)")  "*  Model MSSM, read SLHA file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'model = "MSSM"')
    call ifile_append (ifile, '?slha_read_decays = true')    
    call ifile_append (ifile, 'read_slha ("sps1ap_decays.slha")')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)
           
    write (u, "(A)")
    write (u, "(A)")  "* Model MSSM, default values:"
    write (u, "(A)")    
        
    call global%model%write (u, verbose = .false., &
         show_vertices = .false., show_particles = .false.)
    
    write (u, "(A)")
    write (u, "(A)")  "* Selected global variables"
    write (u, "(A)")

    model_vars => global%model%get_var_list_ptr ()

    call var_list_write_var (model_vars, var_str ("mch1"), u)
    call var_list_write_var (model_vars, var_str ("wch1"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    write (u, "(A)")  "* Model MSSM, values from SLHA file"
    write (u, "(A)")
        
    call global%model%write (u, verbose = .false., &
         show_vertices = .false., show_particles = .false.)

    write (u, "(A)")
    write (u, "(A)")  "* Selected global variables"
    write (u, "(A)")

    model_vars => global%model%get_var_list_ptr ()

    call var_list_write_var (model_vars, var_str ("mch1"), u)
    call var_list_write_var (model_vars, var_str ("wch1"), u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_slha_final ()
    call syntax_model_file_final ()
    call syntax_cmd_list_final ()
    
    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_29"

  end subroutine commands_29

@ %def commands_29
@
\subsubsection{Expressions for scales}
Declare a scale, factorization scale or factorization scale expression.
<<Commands: execute tests>>=
  call test (commands_30, "commands_30", &
       "scales", &
       u, results)
<<Commands: tests>>=
  subroutine commands_30 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_30"
    write (u, "(A)")  "*   Purpose: define scales"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'scale = 200 GeV')
    call ifile_append (ifile, &
         'factorization_scale = eval Pt [particle]')
    call ifile_append (ifile, &
         'renormalization_scale = eval E [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_30"

  end subroutine commands_30

@ %def commands_30
@
\subsubsection{Weight and reweight expressions}
Declare an expression for event weights and reweighting.
<<Commands: execute tests>>=
  call test (commands_31, "commands_31", &
       "event weights/reweighting", &
       u, results)
<<Commands: tests>>=
  subroutine commands_31 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_31"
    write (u, "(A)")  "*   Purpose: define weight/reweight"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'weight = eval Pz [particle]')
    call ifile_append (ifile, 'reweight = eval M2 [particle]')    
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()
    call syntax_model_file_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_31"

  end subroutine commands_31

@ %def commands_31
@
\subsubsection{Selecting events}
Declare an expression for selecting events in an analysis.
<<Commands: execute tests>>=
  call test (commands_32, "commands_32", &
       "event selection", &
       u, results)
<<Commands: tests>>=
  subroutine commands_32 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root

    write (u, "(A)")  "* Test output: commands_32"
    write (u, "(A)")  "*   Purpose: define selection"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'selection = any PDG == 13 [particle]')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)

    call global%write_expr (u)

    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_32"

  end subroutine commands_32

@ %def commands_32
@
\subsubsection{Executing shell commands}
Execute a shell command.
<<Commands: execute tests>>=
  call test (commands_33, "commands_33", &
       "execute shell command", &
       u, results)
<<Commands: tests>>=
  subroutine commands_33 (u)
    integer, intent(in) :: u
    type(ifile_t) :: ifile
    type(command_list_t), target :: command_list
    type(rt_data_t), target :: global
    type(parse_node_t), pointer :: pn_root
    integer :: u_file, iostat
    character(3) :: buffer

    write (u, "(A)")  "* Test output: commands_33"
    write (u, "(A)")  "*   Purpose: execute shell command"
    write (u, "(A)")

    write (u, "(A)")  "*  Initialization"
    write (u, "(A)")

    call syntax_cmd_list_init ()
    call global%global_init ()

    write (u, "(A)")  "*  Input file"
    write (u, "(A)")
    
    call ifile_append (ifile, 'exec ("echo foo >> bar")')
    
    call ifile_write (ifile, u)

    write (u, "(A)")
    write (u, "(A)")  "*  Parse file"
    write (u, "(A)")
    
    call parse_ifile (ifile, pn_root, u)

    write (u, "(A)")
    write (u, "(A)")  "* Compile command list"
    write (u, "(A)")

    call command_list%compile (pn_root, global)
    call command_list%write (u)

    write (u, "(A)")
    write (u, "(A)")  "* Execute command list"
    write (u, "(A)")

    call command_list%execute (global)
    u_file = free_unit ()
    open (u_file, file = "bar", &
         action = "read", status = "old")
    do 
       read (u_file, "(A)", iostat = iostat)  buffer
       if (iostat /= 0) exit        
    end do
    write (u, "(A,A)")  "should be 'foo': ", trim (buffer)           
    close (u_file)
        
    write (u, "(A)")
    write (u, "(A)")  "* Cleanup"

    call ifile_final (ifile)

    call command_list%final ()
    call global%final ()
    call syntax_cmd_list_final ()

    write (u, "(A)")
    write (u, "(A)")  "* Test output end: commands_33"

  end subroutine commands_33

@ %def commands_33
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Toplevel module WHIZARD}
<<[[whizard.f90]]>>=
<<File header>>

module whizard

  use io_units
<<Use strings>>
  use unit_tests
  use system_defs, only: VERSION_STRING
  use system_defs, only: EOF, BACKSLASH
  use diagnostics
  use os_interface
  use formats
  use md5
  use sorting
  use object_base
  use object_logical
  use grids
  use solver
  use cputime
  use sm_qcd
  use ifiles
  use lexers
  use parser
  use xml
  use colors
  use state_matrices
  use analysis
  use variables
  use model_testbed
  use user_code_interface
  use eval_trees
  use particles
  use models
  use auto_components
  use evaluators
  use phs_forests
  use beams
  use polarizations
  use sf_aux
  use sf_mappings
  use sf_base
  use sf_pdf_builtin
  use sf_lhapdf
  use sf_circe1
  use sf_circe2
  use sf_isr
  use sf_epa
  use sf_ewa
  use sf_escan
  use sf_beam_events
  use sf_user
  use phs_base
  use phs_single
  use phs_wood
  use phs_fks
  use rng_base
  use rng_tao
  use selectors
  use mci_base
  use mci_midpoint
  use mci_vamp
  use prclib_interfaces
  use particle_specifiers
  use process_libraries
  use prclib_stacks
  use hepmc_interface
  use lcio_interface
  use jets
  use pdg_arrays
  use interactions
  use slha_interface
  use cascades
  use blha_driver
  use blha_config
  use prc_core
  use prc_test
  use prc_template_me
  use prc_omega
  use subevt_expr
  use processes
  use process_stacks
  use event_transforms
  use decays
  use powheg
  use shower
  use events

  use hep_events
  use eio_data
  use eio_base
  use eio_raw
  use eio_checkpoints
  use eio_lhef
  use eio_hepmc
  use eio_lcio
  use eio_stdhep
  use eio_ascii
  use eio_weights

  use iterations
  use beam_structures
  use rt_data
  use dispatch
  use process_configurations
  use compilations
  use integrations
  use event_streams
  use simulations
  use nlo_controller

  use expr_tests

  use commands

<<Standard module head>>

<<WHIZARD: public>>

<<WHIZARD: types>>

  save

contains

<<WHIZARD: procedures>>

end module whizard
@ %def whizard
@
\subsection{Options}
Here we introduce a wrapper that holds various user options, so they
can transparently be passed from the main program to the [[whizard]]
object.  Most parameters are used for initializing the [[global]]
state.
<<WHIZARD: public>>=
  public :: whizard_options_t
<<WHIZARD: types>>=
  type :: whizard_options_t
     type(string_t) :: preload_model
     type(string_t) :: default_lib
     type(string_t) :: preload_libraries
     logical :: rebuild_library = .false.
     logical :: recompile_library = .false.
     logical :: rebuild_user
     logical :: rebuild_phs = .false.
     logical :: rebuild_grids = .false.
     logical :: rebuild_events = .false.
  end type whizard_options_t
  
@ %def whizard_options_t
@
\subsection{Parse tree stack}
We collect all parse trees that we generate in the [[whizard]] object.  To
this end, we create a stack of parse trees.  They must not be finalized before
the [[global]] object is finalized, because items such as a cut definition may
contain references to the parse tree from which they were generated.
<<WHIZARD: types>>=
  type, extends (parse_tree_t) :: pt_entry_t
     type(pt_entry_t), pointer :: previous => null ()
  end type pt_entry_t
  
@ %def pt_entry_t
@ This is the stack.  Since we always prepend, we just need the [[last]]
pointer.
<<WHIZARD: types>>=
  type :: pt_stack_t
     type(pt_entry_t), pointer :: last => null ()
   contains
   <<WHIZARD: pt stack: TBP>>
  end type pt_stack_t
  
@ %def pt_stack_t
@ The finalizer is called at the very end.
<<WHIZARD: pt stack: TBP>>=
  procedure :: final => pt_stack_final
<<WHIZARD: procedures>>=
  subroutine pt_stack_final (pt_stack)
    class(pt_stack_t), intent(inout) :: pt_stack
    type(pt_entry_t), pointer :: current
    do while (associated (pt_stack%last))
       current => pt_stack%last
       pt_stack%last => current%previous
       call parse_tree_final (current%parse_tree_t)
       deallocate (current)
    end do
  end subroutine pt_stack_final

@ %def pt_stack_final
@ Create and push a new entry, keeping the previous ones.
<<WHIZARD: pt stack: TBP>>=
  procedure :: push => pt_stack_push
<<WHIZARD: procedures>>=
  subroutine pt_stack_push (pt_stack, parse_tree)
    class(pt_stack_t), intent(inout) :: pt_stack
    type(parse_tree_t), intent(out), pointer :: parse_tree
    type(pt_entry_t), pointer :: current
    allocate (current)
    parse_tree => current%parse_tree_t
    current%previous => pt_stack%last
    pt_stack%last => current
  end subroutine pt_stack_push
  
@ %def pt_stack_push
@
\subsection{The [[whizard]] object}
An object of type [[whizard_t]] is the top-level wrapper for a
\whizard\ instance.  The object holds various default
settings and the current state of the generator, the [[global]] object
of type [[rt_data_t]].  This object contains, for instance, the list
of variables and the process libraries.

Since components of the [[global]] subobject are frequently used as
targets, the [[whizard]] object should also consistently carry the
[[target]] attribute.

The various self-tests do no not use this object.  They initialize
only specific subsets of the system, according to their needs.

Note: we intend to allow several concurrent instances.  In the current
implementation, there are still a few obstacles to this: the model
library and the syntax tables are global variables, and the error
handling uses global state.  This should be improved.
<<WHIZARD: public>>=
  public :: whizard_t
<<WHIZARD: types>>=
  type :: whizard_t
     type(whizard_options_t) :: options
     type(rt_data_t) :: global
     type(pt_stack_t) :: pt_stack
   contains
   <<WHIZARD: whizard: TBP>>
  end type whizard_t
  
@ %def whizard_t
@ 
\subsection{Initialization and finalization}
<<WHIZARD: whizard: TBP>>=
  procedure :: init => whizard_init
<<WHIZARD: procedures>>=
  subroutine whizard_init (whizard, options, paths, logfile)
    class(whizard_t), intent(out), target :: whizard
    type(whizard_options_t), intent(in) :: options    
    type(paths_t), intent(in), optional :: paths
    type(string_t), intent(in), optional :: logfile
    call init_syntax_tables ()
    whizard%options = options
    call whizard%global%global_init (paths, logfile)
    call whizard%init_rebuild_flags ()
    call whizard%preload_model ()
    call whizard%preload_library ()
    call whizard%global%init_fallback_model &
         (var_str ("SM_hadrons"), var_str ("SM_hadrons.mdl"))
    call whizard%global%init_radiation_model &
         (var_str ("SM_rad"), var_str ("SM_rad.mdl"))
  end subroutine whizard_init
  
@ %def whizard_init
@ Apart from the global data which have been initialized above, the
process and model lists need to be finalized.
<<WHIZARD: whizard: TBP>>=
  procedure :: final => whizard_final
<<WHIZARD: procedures>>=
  subroutine whizard_final (whizard)
    class(whizard_t), intent(inout), target :: whizard
    call whizard%global%final ()
    call whizard%pt_stack%final ()
!!! JRR: WK please check (#529)
    !    call user_code_final ()
    call final_syntax_tables () 
  end subroutine whizard_final
  
@ %def whizard_final
@
Set the rebuild flags.  They can be specified on the command line and
set the initial value for the associated logical variables.
<<WHIZARD: whizard: TBP>>=
  procedure :: init_rebuild_flags => whizard_init_rebuild_flags
<<WHIZARD: procedures>>=
  subroutine whizard_init_rebuild_flags (whizard)
    class(whizard_t), intent(inout), target :: whizard
    associate (var_list => whizard%global%var_list, options => whizard%options) 
      call var_list_append_log &
           (var_list, var_str ("?rebuild_library"), options%rebuild_library, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?recompile_library"), &
           options%recompile_library, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_phase_space"), options%rebuild_phs, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_grids"), options%rebuild_grids, &
           intrinsic=.true.)
      call var_list_append_log &
           (var_list, var_str ("?rebuild_events"), options%rebuild_events, &
           intrinsic=.true.)
    end associate
  end subroutine whizard_init_rebuild_flags

@ %def whizard_init_rebuild_flags
@
This procedure preloads a model, if a model name is given.
<<WHIZARD: whizard: TBP>>=
  procedure :: preload_model => whizard_preload_model
<<WHIZARD: procedures>>=
  subroutine whizard_preload_model (whizard)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t) :: model_name
    model_name = whizard%options%preload_model
    if (model_name /= "") then
       call whizard%global%read_model (model_name, whizard%global%preload_model)
       whizard%global%model => whizard%global%preload_model
       if (associated (whizard%global%model)) then
          call whizard%global%model%link_var_list (whizard%global%var_list)
          call msg_message ("Preloaded model: " &
               // char (model_name))
       else
          call msg_fatal ("Preloading model " // char (model_name) &
               // " failed")
       end if
    else
       call msg_message ("No model preloaded")
    end if
  end subroutine whizard_preload_model
    
@ %def whizard_preload_model
@
This procedure preloads a library, if a library name is given.

Note: This version just opens a new library with that name.  It does not load
(yet) an existing library on file, as previous \whizard\ versions would do.
<<WHIZARD: whizard: TBP>>=
  procedure :: preload_library => whizard_preload_library
<<WHIZARD: procedures>>=
  subroutine whizard_preload_library (whizard)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t) :: library_name, libs
    type(string_t), dimension(:), allocatable :: libname_static
    type(prclib_entry_t), pointer :: lib_entry
    integer :: i
    call get_prclib_static (libname_static)
    do i = 1, size (libname_static)
       allocate (lib_entry)
       call lib_entry%init_static (libname_static(i))
       call whizard%global%add_prclib (lib_entry)
    end do
    libs = adjustl (whizard%options%preload_libraries)
    if (libs == "" .and. whizard%options%default_lib /= "") then
          allocate (lib_entry)
          call lib_entry%init (whizard%options%default_lib)
          call whizard%global%add_prclib (lib_entry)
          call msg_message ("Preloaded library: " // &
               char (whizard%options%default_lib))    
       end if    
    SCAN_LIBS: do while (libs /= "")
       call split (libs, library_name, " ")      
       if (library_name /= "") then
          allocate (lib_entry)
          call lib_entry%init (library_name)
          call whizard%global%add_prclib (lib_entry)
          call msg_message ("Preloaded library: " // char (library_name))
       end if
    end do SCAN_LIBS    
  end subroutine whizard_preload_library
    
@ %def whizard_preload_library
@ 
\subsection{Initialization and finalization (old version)}
These procedures initialize and finalize global variables.  Most of
them are collected in the [[global]] data record located here, the
others are syntax tables located in various modules, which do not
change during program execution.  Furthermore, there is a global model
list and a global process store, which get filled during program
execution but are finalized here.

During initialization, we can preload a default model and initialize a
default library for setting up processes.  The default library is
loaded if requested by the setup.  Further libraries can be loaded as
specified by command-line flags.
@ Initialize/finalize the syntax tables used by WHIZARD:
<<WHIZARD: public>>=
  public :: init_syntax_tables
  public :: final_syntax_tables
<<WHIZARD: procedures>>=
  subroutine init_syntax_tables ()
    call syntax_model_file_init ()
    call syntax_phs_forest_init ()
    call syntax_pexpr_init ()
    call syntax_slha_init ()
    call syntax_blha_contract_init ()    
    call syntax_cmd_list_init ()
  end subroutine init_syntax_tables

  subroutine final_syntax_tables ()
    call syntax_model_file_final ()
    call syntax_phs_forest_final ()
    call syntax_pexpr_final ()
    call syntax_slha_final ()
    call syntax_blha_contract_final ()    
    call syntax_cmd_list_final ()
  end subroutine final_syntax_tables

@ %def init_syntax_tables
@ %def final_syntax_tables
@ Write the syntax tables to external files.
<<WHIZARD: public>>=
  public :: write_syntax_tables
<<WHIZARD: procedures>>=
  subroutine write_syntax_tables ()
    integer :: unit
    character(*), parameter :: file_model = "whizard.model_file.syntax"
    character(*), parameter :: file_phs = "whizard.phase_space_file.syntax"
    character(*), parameter :: file_pexpr = "whizard.prt_expressions.syntax"
    character(*), parameter :: file_slha = "whizard.slha.syntax"
    character(*), parameter :: file_sindarin = "whizard.sindarin.syntax"
    unit = free_unit ()
    print *, "Writing file '" // file_model // "'"
    open (unit=unit, file=file_model, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_model
    call syntax_model_file_write (unit)
    close (unit)
    print *, "Writing file '" // file_phs // "'"
    open (unit=unit, file=file_phs, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_phs
    call syntax_phs_forest_write (unit)
    close (unit)
    print *, "Writing file '" // file_pexpr // "'"
    open (unit=unit, file=file_pexpr, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_pexpr
    call syntax_pexpr_write (unit)
    close (unit)
    print *, "Writing file '" // file_slha // "'"
    open (unit=unit, file=file_slha, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_slha
    call syntax_slha_write (unit)
    close (unit)
    print *, "Writing file '" // file_sindarin // "'"
    open (unit=unit, file=file_sindarin, status="replace", action="write")
    write (unit, "(A)")  VERSION_STRING
    write (unit, "(A)")  "Syntax definition file: " // file_sindarin
    call syntax_cmd_list_write (unit)
    close (unit)
  end subroutine write_syntax_tables

@ %def write_syntax_tables
@ 
\subsection{Execute command lists}
Process commands given on the command line, stored as an [[ifile]].  The whole
input is read, compiled and executed as a whole.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_ifile => whizard_process_ifile
<<WHIZARD: procedures>>=
  subroutine whizard_process_ifile (whizard, ifile, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(ifile_t), intent(in) :: ifile
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    call msg_message ("Reading commands given on the command line")
    call lexer_init_cmd_list (lexer)
    call stream_init (stream, ifile)
    call whizard%process_stream (stream, lexer, quit, quit_code)
    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine whizard_process_ifile

@ %def whizard_process_ifile
@ Process standard input as a command list.  The whole input is read,
compiled and executed as a whole.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_stdin => whizard_process_stdin
<<WHIZARD: procedures>>=
  subroutine whizard_process_stdin (whizard, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    call msg_message ("Reading commands from standard input")
    call lexer_init_cmd_list (lexer)
    call stream_init (stream, 5)
    call whizard%process_stream (stream, lexer, quit, quit_code)
    call stream_final (stream)
    call lexer_final (lexer)
  end subroutine whizard_process_stdin

@ %def whizard_process_stdin
@ Process a file as a command list.
<<WHIZARD: whizard: TBP>>=
  procedure :: process_file => whizard_process_file
<<WHIZARD: procedures>>=
  subroutine whizard_process_file (whizard, file, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(string_t), intent(in) :: file
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    logical :: exist
    call msg_message ("Reading commands from file '" // char (file) // "'")
    inquire (file=char(file), exist=exist)
    if (exist) then
       call lexer_init_cmd_list (lexer)
       call stream_init (stream, char (file))
       call whizard%process_stream (stream, lexer, quit, quit_code)
       call stream_final (stream)
       call lexer_final (lexer)
    else
       call msg_error ("File '" // char (file) // "' not found")
    end if
  end subroutine whizard_process_file

@ %def whizard_process_file
@
<<WHIZARD: whizard: TBP>>=
  procedure :: process_stream => whizard_process_stream
<<WHIZARD: procedures>>=
  subroutine whizard_process_stream (whizard, stream, lexer, quit, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    type(stream_t), intent(inout), target :: stream
    type(lexer_t), intent(inout), target :: lexer
    logical, intent(out) :: quit
    integer, intent(out) :: quit_code
    type(parse_tree_t), pointer :: parse_tree
    type(command_list_t), target :: command_list
    call lexer_assign_stream (lexer, stream)
    call whizard%pt_stack%push (parse_tree)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    if (associated (parse_tree_get_root_ptr (parse_tree))) then
       whizard%global%lexer => lexer
       call command_list%compile (parse_tree_get_root_ptr (parse_tree), &
            whizard%global)
    end if
    call whizard%global%activate ()
    call command_list%execute (whizard%global)
    call command_list%final ()
    quit = whizard%global%quit
    quit_code = whizard%global%quit_code
  end subroutine whizard_process_stream

@ %def whizard_process_stream
@ 
\subsection{The WHIZARD shell}
This procedure implements interactive mode.  One line is processed at
a time.
<<WHIZARD: whizard: TBP>>=
  procedure :: shell => whizard_shell
<<WHIZARD: procedures>>=
  subroutine whizard_shell (whizard, quit_code)
    class(whizard_t), intent(inout), target :: whizard
    integer, intent(out) :: quit_code
    type(lexer_t), target :: lexer
    type(stream_t), target :: stream
    type(string_t) :: prompt1
    type(string_t) :: prompt2
    type(string_t) :: input
    type(string_t) :: extra
    integer :: last
    integer :: iostat
    logical :: mask_tmp
    logical :: quit
    call msg_message ("Launching interactive shell")
    call lexer_init_cmd_list (lexer)
    prompt1 = "whish? "
    prompt2 = "     > "
    COMMAND_LOOP: do
       call put (6, prompt1)
       call get (5, input, iostat=iostat)
       if (iostat > 0 .or. iostat == EOF) exit COMMAND_LOOP
       CONTINUE_INPUT: do
          last = len_trim (input)
          if (extract (input, last, last) /= BACKSLASH)  exit CONTINUE_INPUT
          call put (6, prompt2)
          call get (5, extra, iostat=iostat)
          if (iostat > 0) exit COMMAND_LOOP
          input = replace (input, last, extra)
       end do CONTINUE_INPUT
       call stream_init (stream, input)
       mask_tmp = mask_fatal_errors
       mask_fatal_errors = .true.
       call whizard%process_stream (stream, lexer, quit, quit_code)
       msg_count = 0
       mask_fatal_errors = mask_tmp
       call stream_final (stream)
       if (quit)  exit COMMAND_LOOP
    end do COMMAND_LOOP
    print *
    call lexer_final (lexer)
  end subroutine whizard_shell

@ %def whizard_shell
@ 
\subsection{Self-tests}
For those self-tests, we need some auxiliary routines that provide an
enviroment.  The environment depends on things that are not available at the
level of the module that we want to test.

\subsubsection{Testbed for event I/O}
This subroutine prepares a test process with a single event.  All objects are
allocated via anonymous pointers, because we want to recover the pointers and
delete the objects in a separate procedure.
<<WHIZARD: procedures>>=
  subroutine prepare_eio_test (event, unweighted, n_alt)
    use variables
    use model_data
    use event_base
    class(generic_event_t), intent(inout), pointer :: event
    logical, intent(in), optional :: unweighted
    integer, intent(in), optional :: n_alt
    type(model_data_t), pointer :: model
    type(var_list_t) :: var_list
    type(process_t), pointer :: process
    type(process_instance_t), pointer :: process_instance

    allocate (model)
    call model%init_test ()

    allocate (process)
    allocate (process_instance)

    call prepare_test_process (process, process_instance, model)
    call process_instance%setup_event_data ()
 
    call model%final ()
    deallocate (model)

    allocate (event_t :: event)
    select type (event)
    type is (event_t)
       if (present (unweighted)) then
          call var_list_append_log (var_list, &
               var_str ("?unweighted"), unweighted, &
               intrinsic = .true.)
       else
          call var_list_append_log (var_list, &
               var_str ("?unweighted"), .true., &
               intrinsic = .true.)
       end if
       call var_list_append_string (var_list, &
            var_str ("$sample_normalization"), &
            var_str ("auto"), intrinsic = .true.)
       call event%basic_init (var_list, n_alt)
       call event%connect (process_instance, process%get_model_ptr ())
       call var_list%final ()
    end select
  end subroutine prepare_eio_test
    
@ %def prepare_eio_test_event
@ Recover those pointers, finalize the objects and deallocate.
<<WHIZARD: procedures>>=
  subroutine cleanup_eio_test (event)
    use model_data
    use event_base
    class(generic_event_t), intent(inout), pointer :: event
    type(process_t), pointer :: process
    type(process_instance_t), pointer :: process_instance
    select type (event)
    type is (event_t)
       process => event%get_process_ptr ()
       process_instance => event%get_process_instance_ptr ()
       call cleanup_test_process (process, process_instance)
       deallocate (process_instance)
       deallocate (process)
       call event%final ()
    end select
    deallocate (event)
  end subroutine cleanup_eio_test
    
@ %def cleanup_eio_test_event
@ Assign those procedures to appropriate pointers (module variables) in the
[[eio_base]] module, so they can be called as if they were module procedures.
<<WHIZARD: prepare testbed>>=
  eio_prepare_test => prepare_eio_test
  eio_cleanup_test => cleanup_eio_test
@ 
\subsubsection{Any Model}
This procedure reads any model from file and, optionally, assigns a
var-list pointer.
<<WHIZARD: procedures>>=
  subroutine prepare_whizard_model (model, name, vars)
  <<Use strings>>
    use os_interface
    use model_data
    use var_base
    use models
    class(model_data_t), intent(inout), pointer :: model
    type(string_t), intent(in) :: name
    class(vars_t), pointer, intent(out), optional :: vars
    type(os_data_t) :: os_data
    call syntax_model_file_init ()
    call os_data_init (os_data)
    allocate (model_t :: model)
    select type (model)
    type is (model_t)
       call model%read (name // ".mdl", os_data)
       if (present (vars)) then
          vars => model%get_var_list_ptr ()
       end if
    end select
  end subroutine prepare_whizard_model
    
@ %def prepare_whizard_model
@ Cleanup after use.  Includes deletion of the model-file syntax.
<<WHIZARD: procedures>>=
  subroutine cleanup_whizard_model (model)
    use model_data
    use models
    class(model_data_t), intent(inout), pointer :: model
    call model%final ()
    deallocate (model)
    call syntax_model_file_final ()
  end subroutine cleanup_whizard_model
    
@ %def cleanup_whizard_model
@ Assign those procedures to appropriate pointers (module variables) in the
[[model_testbed]] module, so they can be called as if they were module
procedures.
<<WHIZARD: prepare testbed>>=
  prepare_model => prepare_whizard_model
  cleanup_model => cleanup_whizard_model
@ 
\subsubsection{Fallback model: hadrons}
Some event format tests require the hadronic SM implementation, which
has to be read from file.  We provide the functionality here, so the
tests do not depend on model I/O.
<<WHIZARD: procedures>>=
  subroutine prepare_fallback_model (model)
    use model_data
    class(model_data_t), intent(inout), pointer :: model
    call prepare_whizard_model (model, var_str ("SM_hadrons"))
  end subroutine prepare_fallback_model
    
@ %def prepare_fallback_model
@ Assign those procedures to appropriate pointers (module variables) in the
[[eio_base]] module, so they can be called as if they were module procedures.
<<WHIZARD: prepare testbed>>=
  eio_prepare_fallback_model => prepare_fallback_model
  eio_cleanup_fallback_model => cleanup_model
@ 
\subsubsection{Procedure for Checking}
This is for developers only, but needs a well-defined interface.
<<WHIZARD: public>>=
  public :: whizard_check
<<WHIZARD: procedures>>=
  subroutine whizard_check (check, results)
    type(string_t), intent(in) :: check
    type(test_results_t), intent(inout) :: results
    type(os_data_t) :: os_data
    integer :: u
    call os_data_init (os_data)
    u = free_unit ()
    open (u, file="whizard_check." // char (check) // ".log", &
         action="write", status="replace")
    call msg_message (repeat ('=', 76), 0)
    call msg_message ("Running self-test: " // char (check), 0)
    call msg_message (repeat ('-', 76), 0)
  <<WHIZARD: prepare testbed>>
    select case (char (check))
    case ("analysis")
       call analysis_test (u, results)
    case ("beams")
       call beam_test (u, results)
    case ("cascades")
       call cascade_test (u, results)
    case ("colors")
       call color_test (u, results)
    case ("evaluators")
      call evaluator_test (u, results)
    case ("expressions")
       call expressions_test (u, results)
    case ("formats")
       call format_test (u, results)
    case ("hepmc")
       call hepmc_test (u, results)
    case ("lcio")
       call lcio_test (u, results)
    case ("jets")
       call jets_test (u, results)
    case ("pdg_arrays")
       call pdg_arrays_test (u, results)
    case ("interactions")
       call interaction_test (u, results)
    case ("lexers")
       call lexer_test (u, results)
    case ("os_interface") 
       call os_interface_test (u, results)
    case ("cputime") 
       call cputime_test (u, results)
    case ("parser")
       call parse_test (u, results)       
    case ("sorting")
       call sorting_test (u, results)
    case ("object_base")
       call object_base_test (u, results)
    case ("object_logical")
       call object_logical_test (u, results)
    case ("grids")
       call grids_test (u, results)
    case ("solver")
       call solver_test (u, results)
    case ("md5")       
       call md5_test (u, results)       
    case ("xml")
       call xml_test (u, results)
    case ("sm_qcd")
       call sm_qcd_test (u, results)
    case ("models")
       call models_test (u, results)
    case ("auto_components")
       call auto_components_test (u, results)
    case ("particles")
       call particles_test (u, results)
    case ("polarizations")
       call polarization_test (u, results)
    case ("sf_aux")
       call sf_aux_test (u, results)
    case ("sf_mappings")
       call sf_mappings_test (u, results)
    case ("sf_base")
       call sf_base_test (u, results)
    case ("sf_pdf_builtin")
       call sf_pdf_builtin_test (u, results)
    case ("sf_lhapdf")
       call sf_lhapdf_test (u, results)
    case ("sf_isr")
       call sf_isr_test (u, results)
    case ("sf_epa")
       call sf_epa_test (u, results)
    case ("sf_ewa")
       call sf_ewa_test (u, results)
    case ("sf_circe1")
       call sf_circe1_test (u, results)
    case ("sf_circe2")
       call sf_circe2_test (u, results)
    case ("sf_beam_events")
       call sf_beam_events_test (u, results)
    case ("sf_escan")
       call sf_escan_test (u, results)
    case ("phs_base")
       call phs_base_test (u, results)
    case ("phs_single")
       call phs_single_test (u, results)
    case ("phs_forests")
       call phs_forest_test (u, results)       
    case ("phs_wood")
       call phs_wood_test (u, results)
    case ("phs_wood_vis")
       call phs_wood_vis_test (u, results)
    case ("phs_fks_generator")
       call phs_fks_generator_test (u, results)
    case ("mci_base")
       call mci_base_test (u, results)
    case ("rng_base")
       call rng_base_test (u, results)
    case ("rng_tao")
       call rng_tao_test (u, results)
    case ("selectors")
       call selectors_test (u, results)
    case ("mci_midpoint")
       call mci_midpoint_test (u, results)
    case ("mci_vamp")
       call mci_vamp_test (u, results)
    case ("prclib_interfaces")
       call prclib_interfaces_test (u, results)
    case ("particle_specifiers")
       call particle_specifiers_test (u, results)
    case ("process_libraries")
       call process_libraries_test (u, results)
    case ("prclib_stacks")
       call prclib_stacks_test (u, results)
    case ("slha_interface")
       call slha_test (u, results)
    case ("state_matrices")
       call state_matrix_test (u, results)
    case ("prc_test")
       call prc_test_test (u, results)
    case ("subevt_expr")
       call subevt_expr_test (u, results)
    case ("processes")
       call processes_test (u, results)       
    case ("process_stacks")
       call process_stacks_test (u, results)   
    case ("event_transforms")
       call event_transforms_test (u, results)       
    case ("decays")
       call decays_test (u, results)       
    case ("powheg")
       call powheg_test (u, results)
    case ("shower")
       call shower_test (u, results)       
    case ("events")
       call events_test (u, results)
    case ("prc_template_me")
       call prc_template_me_test (u, results)              
    case ("prc_omega")
       call prc_omega_test (u, results)
    case ("prc_omega_diags")
       call prc_omega_diags_test (u, results)       
    case ("hep_events")
       call hep_events_test (u, results)       
    case ("eio_data")       
       call eio_data_test (u, results)
    case ("eio_base")
       call eio_base_test (u, results)
    case ("eio_raw")
       call eio_raw_test (u, results)
    case ("eio_checkpoints")
       call eio_checkpoints_test (u, results)
    case ("eio_lhef")
       call eio_lhef_test (u, results)
    case ("eio_hepmc")
       call eio_hepmc_test (u, results)
    case ("eio_lcio")
       call eio_lcio_test (u, results)
    case ("eio_stdhep")
       call eio_stdhep_test (u, results)
    case ("eio_ascii")
       call eio_ascii_test (u, results)       
    case ("eio_weights")
       call eio_weights_test (u, results)
    case ("iterations")
       call iterations_test (u, results)
    case ("beam_structures")
       call beam_structures_test (u, results)
    case ("rt_data")
       call rt_data_test (u, results)
    case ("dispatch")
       call dispatch_test (u, results)
    case ("process_configurations")
       call process_configurations_test (u, results)
    case ("compilations")
       call compilations_test (u, results)
    case ("compilations_static")
       call compilations_static_test (u, results)
    case ("integrations")
       call integrations_test (u, results)
    case ("integrations_history")
       call integrations_history_test (u, results)
    case ("event_streams")
       call event_streams_test (u, results)
    case ("simulations")
       call simulations_test (u, results)
    case ("commands")
       call commands_test (u, results)
    case ("all")
       call analysis_test (u, results)
       call beam_test (u, results)
       call md5_test (u, results)
       call lexer_test (u, results)
       call sorting_test (u, results)
       call object_base_test (u, results)
       call object_logical_test (u, results)
       call solver_test (u, results)
       call grids_test (u, results)
       call parse_test (u, results)
       call color_test (u, results)
       call evaluator_test (u, results)
       call expressions_test (u, results)
       call format_test (u, results)
       call hepmc_test (u, results)
       call lcio_test (u, results)
       call jets_test (u, results)
       call os_interface_test (u, results)
       call cputime_test (u, results)
       call interaction_test (u, results)
       call xml_test (u, results)
       call sm_qcd_test (u, results)
       call models_test (u, results)
       call auto_components_test (u, results)
       call particles_test (u, results)
       call polarization_test (u, results)
       call sf_aux_test (u, results)
       call sf_mappings_test (u, results)
       call sf_base_test (u, results)
       call sf_pdf_builtin_test (u, results)
       call sf_lhapdf_test (u, results)
       call sf_isr_test (u, results)
       call sf_epa_test (u, results)
       call sf_ewa_test (u, results)
       call sf_circe1_test (u, results)
       call sf_circe2_test (u, results)
       call sf_beam_events_test (u, results)
       call sf_escan_test (u, results)
       call phs_base_test (u, results)
       call phs_single_test (u, results)
       call phs_forest_test (u, results)
       call phs_wood_test (u, results)
       call phs_wood_vis_test (u, results)
       call rng_base_test (u, results)
       call cascade_test (u, results)
       call rng_tao_test (u, results)
       call selectors_test (u, results)
       call mci_base_test (u, results)
       call mci_midpoint_test (u, results)
       call mci_vamp_test (u, results)
       call prclib_interfaces_test (u, results)
       call particle_specifiers_test (u, results)
       call process_libraries_test (u, results)
       call prclib_stacks_test (u, results)
       call slha_test (u, results)
       call state_matrix_test (u, results)
       call prc_test_test (u, results)
       call subevt_expr_test (u, results)
       call processes_test (u, results)
       call process_stacks_test (u, results)   
       call event_transforms_test (u, results)
       call decays_test (u, results)
       call powheg_test (u, results)
       call shower_test (u, results)
       call events_test (u, results)
       call prc_omega_test (u, results)
       call prc_omega_diags_test (u, results)
       call prc_template_me_test (u, results)
       call hep_events_test (u, results)
       call eio_data_test (u, results)
       call eio_base_test (u, results)
       call eio_raw_test (u, results)
       call eio_checkpoints_test (u, results)
       call eio_lhef_test (u, results)
       call eio_hepmc_test (u, results)
       call eio_lcio_test (u, results)
       call eio_stdhep_test (u, results)
       call eio_ascii_test (u, results)
       call eio_weights_test (u, results)
       call iterations_test (u, results)
       call beam_structures_test (u, results)
       call rt_data_test (u, results)
       call dispatch_test (u, results)
       call process_configurations_test (u, results)
       call compilations_test (u, results)
       call compilations_static_test (u, results)
       call integrations_test (u, results)
       call integrations_history_test (u, results)       
       call event_streams_test (u, results)
       call simulations_test (u, results)
       call commands_test (u, results)
    case default
       call msg_fatal ("Self-test '" // char (check) // "' not implemented.")
    end select
    close (u)
  end subroutine whizard_check

@ %def whizard_check
@
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Driver program}
The main program handles command options, initializes the environment,
and runs WHIZARD in a particular mode (interactive, file, standard
input).

This is also used in the C interface:
<<Main: cmdline arg len declaration>>=
  integer, parameter :: CMDLINE_ARG_LEN = 1000
@ %def CMDLINE_ARG_LEN
@ 
The actual main program:
<<[[main.f90]]>>=
<<File header>>

program main

<<Use strings>>
  use unit_tests
  use system_dependencies
  use diagnostics
  use ifiles
  use os_interface
  use whizard

  implicit none

<<Main: cmdline arg len declaration>>

  ! Main program variable declarations
  character(CMDLINE_ARG_LEN) :: arg
  character(2) :: option
  type(string_t) :: long_option, value
  integer :: i, j, arg_len, arg_status
  logical :: look_for_options
  logical :: interactive
  logical :: banner
  type(string_t) :: files, this, model, default_lib, library, libraries
  type(string_t) :: check, checks, logfile
  type(test_results_t) :: test_results
  logical :: success
  logical :: user_code_enable = .false.
  integer :: n_user_src = 0, n_user_lib = 0
  type(string_t) :: user_src, user_lib, user_target
  type(paths_t) :: paths
  logical :: rebuild_library, rebuild_user
  logical :: rebuild_phs, rebuild_grids, rebuild_events
  logical :: recompile_library
  type(ifile_t) :: commands
  type(string_t) :: command

  type(whizard_options_t), allocatable :: options
  type(whizard_t), allocatable, target :: whizard_instance

  ! Exit status
  logical :: quit = .false.
  integer :: quit_code = 0

  ! Initial values
  look_for_options = .true.
  interactive = .false.
  files = ""
  model = "SM"
  default_lib = "default_lib"
  library = ""
  libraries = ""  
  banner = .true.
  logging = .true.
  logfile = "whizard.log"
  check = ""
  checks = ""
  user_src = ""
  user_lib = ""
  user_target = ""
  rebuild_library = .false.
  rebuild_user = .false.
  rebuild_phs = .false.
  rebuild_grids = .false.
  rebuild_events = .false.
  recompile_library = .false.
  call paths_init (paths)

  ! Read and process options
  i = 0
  SCAN_CMDLINE: do
     i = i + 1
     call get_command_argument (i, arg, arg_len, arg_status)
     select case (arg_status)
     case (0)
     case (-1)
        call msg_error (" Command argument truncated: '" // arg // "'")
     case default
        exit SCAN_CMDLINE
     end select
     if (look_for_options) then
        select case (arg(1:2))
        case ("--")
           value = trim (arg)
           call split (value, long_option, "=")
           select case (char (long_option))
           case ("--version")
              call no_option_value (long_option, value)
              call print_version (); stop
           case ("--help")
              call no_option_value (long_option, value)
              call print_usage (); stop
           case ("--prefix")
              paths%prefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--exec-prefix")
              paths%exec_prefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--bindir")
              paths%bindir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--libdir")
              paths%libdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--includedir")
              paths%includedir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--datarootdir")
              paths%datarootdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--libtool")
              paths%libtool = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--lhapdfdir")
              paths%lhapdfdir = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--check")
              check = get_option_value (i, long_option, value)
              checks = checks // " " // check
              cycle SCAN_CMDLINE
           case ("--execute")
              command = get_option_value (i, long_option, value)
	      call ifile_append (commands, command)
              cycle SCAN_CMDLINE
           case ("--interactive")
              call no_option_value (long_option, value)
              interactive = .true.
              cycle SCAN_CMDLINE
           case ("--library")
              library = get_option_value (i, long_option, value)
              libraries = libraries // " " // library
              cycle SCAN_CMDLINE
           case ("--no-library")
              call no_option_value (long_option, value)
              default_lib = ""
              library = ""              
              libraries = ""
              cycle SCAN_CMDLINE
           case ("--localprefix")
              paths%localprefix = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--logfile")
              logfile = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--no-logfile")
              call no_option_value (long_option, value)
              logfile = ""
              cycle SCAN_CMDLINE
           case ("--logging")
              call no_option_value (long_option, value)
              logging = .true.
              cycle SCAN_CMDLINE
           case ("--no-logging")
              call no_option_value (long_option, value)
              logging = .false.
              cycle SCAN_CMDLINE
           case ("--banner")
              call no_option_value (long_option, value)
              banner = .true.
              cycle SCAN_CMDLINE
           case ("--no-banner")
              call no_option_value (long_option, value)
              banner = .false.
              cycle SCAN_CMDLINE
           case ("--model")
              model = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--no-model")
              call no_option_value (long_option, value)
              model = ""
              cycle SCAN_CMDLINE
           case ("--rebuild")
              call no_option_value (long_option, value)
              rebuild_library = .true.
              rebuild_user = .true.
              rebuild_phs = .true.
              rebuild_grids = .true.
              rebuild_events = .true.
              cycle SCAN_CMDLINE
           case ("--no-rebuild")
              call no_option_value (long_option, value)
              rebuild_library = .false.
              recompile_library = .false.
              rebuild_user = .false.
              rebuild_phs = .false.
              rebuild_grids = .false.
              rebuild_events = .false.
              cycle SCAN_CMDLINE
           case ("--rebuild-library")
              call no_option_value (long_option, value)
              rebuild_library = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-user")
              call no_option_value (long_option, value)
              rebuild_user = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-phase-space")
              call no_option_value (long_option, value)
              rebuild_phs = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-grids")
              call no_option_value (long_option, value)
              rebuild_grids = .true.
              cycle SCAN_CMDLINE
           case ("--rebuild-events")
              call no_option_value (long_option, value)
              rebuild_events = .true.
              cycle SCAN_CMDLINE
           case ("--recompile")
              call no_option_value (long_option, value)
              recompile_library = .true.
	      rebuild_grids = .true.
              cycle SCAN_CMDLINE
           case ("--user")
              user_code_enable = .true.
              cycle SCAN_CMDLINE
           case ("--user-src")
              if (user_src == "") then
                 user_src = get_option_value (i, long_option, value)
              else
                 user_src = user_src // " " &
                      // get_option_value (i, long_option, value)
              end if
              n_user_src = n_user_src + 1
              cycle SCAN_CMDLINE
           case ("--user-lib")
              if (user_lib == "") then
                 user_lib = get_option_value (i, long_option, value)
              else
                 user_lib = user_lib // " " &
                      // get_option_value (i, long_option, value)
              end if
              n_user_lib = n_user_lib + 1
              cycle SCAN_CMDLINE
           case ("--user-target")
              user_target = get_option_value (i, long_option, value)
              cycle SCAN_CMDLINE
           case ("--write-syntax-tables")
              call no_option_value (long_option, value)
	      call init_syntax_tables ()
              call write_syntax_tables ()
              call final_syntax_tables ()
              stop
              cycle SCAN_CMDLINE
           case default
              call print_usage ()
              call msg_fatal ("Option '" // trim (arg) // "' not recognized")
           end select
        end select
        select case (arg(1:1))
        case ("-")
           j = 1
           if (len_trim (arg) == 1) then
              look_for_options = .false.
           else
              SCAN_SHORT_OPTIONS: do
                 j = j + 1
                 if (j > len_trim (arg)) exit SCAN_SHORT_OPTIONS
                 option = "-" // arg(j:j)
                 select case (option)
                 case ("-V")
                    call print_version (); stop
                 case ("-?", "-h")
                    call print_usage (); stop
                 case ("-e")
                    command = get_option_value (i, var_str (option))
                    call ifile_append (commands, command)
                    cycle SCAN_CMDLINE
                 case ("-i")
                    interactive = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case ("-l")
                    if (j == len_trim (arg)) then
                       library = get_option_value (i, var_str (option))
                    else
                       library = trim (arg(j+1:))
                    end if
                    libraries = libraries // " " // library                    
                    cycle SCAN_CMDLINE
                 case ("-L")
                    if (j == len_trim (arg)) then
                       logfile = get_option_value (i, var_str (option))
                    else
                       logfile = trim (arg(j+1:))
                    end if
                    cycle SCAN_CMDLINE
                 case ("-m")
                    if (j < len_trim (arg))  call msg_fatal &
                         ("Option '" // option // "' needs a value")
                    model = get_option_value (i, var_str (option))
                    cycle SCAN_CMDLINE
                 case ("-r")
                    rebuild_library = .true.
                    rebuild_user = .true.
                    rebuild_phs = .true.
                    rebuild_grids = .true.
                    rebuild_events = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case ("-u")
                    user_code_enable = .true.
                    cycle SCAN_SHORT_OPTIONS
                 case default
                    call print_usage ()
                    call msg_fatal &
                         ("Option '" // option // "' not recognized")
                 end select
              end do SCAN_SHORT_OPTIONS
           end if
        case default
           files = files // " " // trim (arg)
        end select
     else
        files = files // " " // trim (arg)
     end if
  end do SCAN_CMDLINE

  ! Overall initialization
  if (logfile /= "")  call logfile_init (logfile)
  if (banner)  call msg_banner ()
  
   ! Run any self-checks (and no commands)
   if (checks /= "") then
      checks = trim (adjustl (checks))
      RUN_CHECKS: do while (checks /= "")
         call split (checks, check, " ")
         call whizard_check (check, test_results)
      end do RUN_CHECKS
      call test_results%wrapup (6, success)
      if (.not. success)  quit_code = 7
      quit = .true.
   end if
   
   allocate (options)
   allocate (whizard_instance)

   if (.not. quit) then

      ! Set options and initialize the whizard object
      options%preload_model = model
      options%default_lib = default_lib
      options%preload_libraries = libraries
      options%rebuild_library = rebuild_library
      options%recompile_library = recompile_library
      options%rebuild_user = rebuild_user 
      options%rebuild_phs = rebuild_phs
      options%rebuild_grids = rebuild_grids
      options%rebuild_events = rebuild_events
      
      call whizard_instance%init (options, paths, logfile)
      
      call mask_term_signals ()

   end if

   ! Run commands given on the command line
   if (.not. quit .and. ifile_get_length (commands) > 0) then
      call whizard_instance%process_ifile (commands, quit, quit_code)
   end if

   if (.not. quit) then
      ! Process commands from standard input
      if (.not. interactive .and. files == "") then
         call whizard_instance%process_stdin (quit, quit_code)

         ! ... or process commands from file
      else
         files = trim (adjustl (files))
         SCAN_FILES: do while (files /= "")
            call split (files, this, " ")
            call whizard_instance%process_file (this, quit, quit_code)
            if (quit)  exit SCAN_FILES
         end do SCAN_FILES

      end if
  end if
 
  ! Enter an interactive shell if requested
  if (.not. quit .and. interactive) then
     call whizard_instance%shell (quit_code)
  end if

  ! Overall finalization
  call ifile_final (commands)

  deallocate (options)

  call whizard_instance%final ()
  deallocate (whizard_instance)
  
  call terminate_now_if_signal ()
  call release_term_signals ()
  call msg_terminate (quit_code = quit_code)

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
contains

  subroutine no_option_value (option, value)
    type(string_t), intent(in) :: option, value
    if (value /= "") then
       call msg_error (" Option '" // char (option) // "' should have no value")
    end if
  end subroutine no_option_value

  function get_option_value (i, option, value) result (string)
    type(string_t) :: string
    integer, intent(inout) :: i
    type(string_t), intent(in) :: option
    type(string_t), intent(in), optional :: value
    character(CMDLINE_ARG_LEN) :: arg
    character(CMDLINE_ARG_LEN) :: arg_value
    integer :: arg_len, arg_status
    logical :: has_value
    if (present (value)) then
       has_value = value /= ""
    else
       has_value = .false.
    end if
    if (has_value) then
       string = value
    else
       i = i + 1 
       call get_command_argument (i, arg_value, arg_len, arg_status)
       select case (arg_status)
       case (0)
       case (-1)
          call msg_error (" Option value truncated: '" // arg // "'")
       case default
          call print_usage ()
          call msg_fatal (" Option '" // char (option) // "' needs a value")
       end select
       select case (arg(1:1))
       case ("-")
          call print_usage ()
          call msg_fatal (" Option '" // char (option) // "' needs a value")
       end select
       string = trim (arg_value)
    end if
  end function get_option_value

  subroutine print_version ()
    print "(A)", "WHIZARD " // WHIZARD_VERSION 
    print "(A)", "Copyright (C) 1999-2015 Wolfgang Kilian, Thorsten Ohl, Juergen Reuter"
    print "(A)", "              ---------------------------------------                "
    print "(A)", "This is free software; see the source for copying conditions.  There is NO"
    print "(A)", "warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
    print *
  end subroutine print_version

  subroutine print_usage ()
    print "(A)", "WHIZARD " // WHIZARD_VERSION
    print "(A)", "Usage: whizard [OPTIONS] [FILE]"
    print "(A)", "Run WHIZARD with the command list taken from FILE(s)"
    print "(A)", "Options for resetting default directories and tools" &
            // "(GNU naming conventions):"
    print "(A)", "    --prefix DIR"
    print "(A)", "    --exec_prefix DIR"
    print "(A)", "    --bindir DIR"
    print "(A)", "    --libdir DIR"
    print "(A)", "    --includedir DIR"
    print "(A)", "    --datarootdir DIR"
    print "(A)", "    --libtool LOCAL_LIBTOOL"
    print "(A)", "    --lhapdfdir DIR   (PDF sets directory)"
    print "(A)", "Other options:"
    print "(A)", "-h, --help            display this help and exit"
    print "(A)", "    --banner          display banner at startup (default)"
    print "(A)", "-e, --execute CMDS    execute SINDARIN CMDS before reading FILE(s)"
    print "(A)", "-i, --interactive     run interactively after reading FILE(s)"
    print "(A)", "-l, --library         preload process library NAME"
    print "(A)", "    --localprefix DIR"
    print "(A)", "                      search in DIR for local models (default: ~/.whizard)"
    print "(A)", "-L, --logfile FILE    write log to FILE (default: 'whizard.log'"
    print "(A)", "    --logging         switch on logging at startup (default)"
    print "(A)", "-m, --model NAME      preload model NAME (default: 'SM')"
    print "(A)", "    --no-banner       do not display banner at startup"
    print "(A)", "    --no-library      do not preload process library"
    print "(A)", "    --no-logfile      do not write a logfile"
    print "(A)", "    --no-logging      switch off logging at startup"
    print "(A)", "    --no-model        do not preload a model"
    print "(A)", "    --no-rebuild      do not force rebuilding"
    print "(A)", "-r, --rebuild         rebuild all (see below)"
    print "(A)", "    --rebuild-library"
    print "(A)", "                      rebuild process code library"
    print "(A)", "    --rebuild-user    rebuild user-provided code"
    print "(A)", "    --rebuild-phase-space"
    print "(A)", "                      rebuild phase-space configuration"
    print "(A)", "    --rebuild-grids   rebuild integration grids"
    print "(A)", "    --rebuild-events  rebuild event samples"
    print "(A)", "    --recompile       recompile process code"
    print "(A)", "-u  --user            enable user-provided code"
    print "(A)", "    --user-src FILE   user-provided source file"
    print "(A)", "    --user-lib FILE   user-provided library file"
    print "(A)", "    --user-target BN  basename of created user library (default: user)"
    print "(A)", "-V, --version         output version information and exit"
    print "(A)", "    --write-syntax-tables"
    print "(A)", "                      write the internal syntax tables to files and exit"
    print "(A)", "-                     further options are taken as filenames"
    print *
    print "(A)", "With no FILE, read standard input."
  end subroutine print_usage

end program main
@ %def main
@ 
\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\section{Whizard-C-Interface}
<<[[whizard-c-interface.f90]]>>=
<<File header>>

<<Whizard-C-Interface: Internals>>
<<Whizard-C-Interface: Init and Finalize>>
<<Whizard-C-Interface: Interfaced Commads>>
<<Whizard-C-Interface: HepMC>>

@
<<Whizard-C-Interface: Internals>>=
  subroutine c_whizard_convert_string (c_string, f_string)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    character(kind=c_char), intent(in) :: c_string(*)
    type(string_t), intent(inout) :: f_string
    character(len=1) :: dummy_char
    integer :: dummy_i = 1
  
    f_string = ""
    do
       if (c_string(dummy_i) == c_null_char) then
          exit
       else if (c_string(dummy_i) == c_new_line) then
          dummy_char = CHAR(13)
          f_string = f_string // dummy_char
          dummy_char = CHAR(10)
       else
          dummy_char = c_string (dummy_i)
       end if
       f_string = f_string // dummy_char
       dummy_i = dummy_i + 1
    end do
    dummy_i = 1
  end subroutine c_whizard_convert_string
  
  subroutine c_whizard_commands (w_c_instance, cmds)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use commands
    use diagnostics
    use lexers
    use models
    use parser
    use whizard

    type(c_ptr), intent(inout) :: w_c_instance
    type(whizard_t), pointer :: whizard_instance
    type(string_t) :: cmds
    type(parse_tree_t) :: parse_tree
    type(parse_node_t), pointer :: pn_root
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    type(command_list_t), target :: cmd_list

    call c_f_pointer (w_c_instance, whizard_instance)
    call lexer_init_cmd_list (lexer)
    call syntax_cmd_list_init ()
  
    call stream_init (stream, cmds)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    pn_root => parse_tree_get_root_ptr (parse_tree)
  
    if (associated (pn_root)) then
       call cmd_list%compile (pn_root, whizard_instance%global)
    end if
    call whizard_instance%global%activate ()
    call cmd_list%execute (whizard_instance%global)
    call cmd_list%final ()
  
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call lexer_final (lexer)
    call syntax_cmd_list_final ()
  end subroutine c_whizard_commands

@
<<Whizard-C-Interface: Init and Finalize>>=
  subroutine c_whizard_init (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!    
    use system_dependencies
    use diagnostics
    use unit_tests
    use ifiles
    use os_interface
    use whizard
  
    implicit none
  
  <<Main: cmdline arg len declaration>>

    type(c_ptr), intent(out) :: w_c_instance    
    character(CMDLINE_ARG_LEN) :: arg
    character(2) :: option
    type(string_t) :: long_option, value
    integer :: i, j, arg_len, arg_status
    logical :: look_for_options
    logical :: interactive
    logical :: banner
    type(string_t) :: files, this, model, default_lib, library, libraries
    type(string_t) :: check, checks, logfile
    type(test_results_t) :: test_results
    logical :: success
    logical :: user_code_enable = .false.
    integer :: n_user_src = 0, n_user_lib = 0
    type(string_t) :: user_src, user_lib
    type(paths_t) :: paths
    logical :: rebuild_library, rebuild_user
    logical :: rebuild_phs, rebuild_grids, rebuild_events
    logical :: recompile_library
    type(ifile_t) :: commands
    type(string_t) :: command

    type(whizard_options_t), allocatable :: options
    type(whizard_t), pointer :: whizard_instance
    
    ! Exit status
    logical :: quit = .false.
    integer :: quit_code = 0
  
    ! Initial values
    look_for_options = .true.
    interactive = .false.
    files = ""
    model = "SM"
    default_lib = "default_lib"
    library = ""
    libraries = ""    
    banner = .true.
    logging = .true.
    logfile = "whizard.log"
    check = ""
    checks = ""
    user_src = ""
    user_lib = ""
    rebuild_library = .false.
    recompile_library = .false.
    rebuild_user = .false.
    rebuild_phs = .false.
    rebuild_grids = .false.
    rebuild_events = .false.
    call paths_init (paths)
  
    ! Overall initialization
    if (logfile /= "")  call logfile_init (logfile)
    call mask_term_signals ()
    if (banner)  call msg_banner ()
    
    ! Set options and initialize the whizard object
    allocate (options)
    options%preload_model = model
    options%default_lib = default_lib
    options%preload_libraries = libraries
    options%rebuild_library = rebuild_library
    options%rebuild_user = rebuild_user
    options%rebuild_phs = rebuild_phs
    options%rebuild_grids = rebuild_grids
    options%rebuild_events = rebuild_events
    
    allocate (whizard_instance)
    call whizard_instance%init (options, paths)
      
    if (checks /= "") then
       checks = trim (adjustl (checks))
       RUN_CHECKS: do while (checks /= "")
          call split (checks, check, " ")
          call whizard_check (check, test_results)
       end do RUN_CHECKS
       call test_results%wrapup (6, success)
       if (.not. success)  quit_code = 7
       quit = .true.
    end if
    
    w_c_instance = c_loc (whizard_instance)
              
  end subroutine c_whizard_init
  
  subroutine c_whizard_finalize (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use system_dependencies
    use diagnostics
    use ifiles
    use os_interface
    use whizard
    
    type(c_ptr), intent(in) :: w_c_instance
    type(whizard_t), pointer :: whizard_instance
    logical :: quit = .false.
    integer :: quit_code = 0
      
    call c_f_pointer (w_c_instance, whizard_instance)
    call whizard_instance%final ()
    deallocate (whizard_instance)
    call terminate_now_if_signal ()
    call release_term_signals ()
    call msg_terminate (quit_code = quit_code)
  end subroutine c_whizard_finalize
  
  subroutine c_whizard_process_string (w_c_instance, c_cmds_in) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_cmds_in(*)
    type(string_t) :: f_cmds
  
    call c_whizard_convert_string (c_cmds_in, f_cmds)
    call c_whizard_commands (w_c_instance, f_cmds)
  end subroutine c_whizard_process_string

@
<<Whizard-C-Interface: Interfaced Commads>>=
  subroutine c_whizard_model (w_c_instance, c_model) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_model(*)
    type(string_t) :: model, mdl_str
  
    call c_whizard_convert_string (c_model, model)
    mdl_str = "model = " // model
    call c_whizard_commands (w_c_instance, mdl_str)
  end subroutine c_whizard_model
  
  subroutine c_whizard_library (w_c_instance, c_library) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_library(*)
    type(string_t) :: library, lib_str
  
    call c_whizard_convert_string(c_library, library)
    lib_str = "library = " // library
    call c_whizard_commands (w_c_instance, lib_str)
  end subroutine c_whizard_library
  
  subroutine c_whizard_process (w_c_instance, c_id, c_in, c_out) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_id(*), c_in(*), c_out(*)
    type(string_t) :: proc_str, id, in, out
  
    call c_whizard_convert_string (c_id, id)
    call c_whizard_convert_string (c_in, in)
    call c_whizard_convert_string (c_out, out)
    proc_str = "process " // id // " = " // in // " => " // out
    call c_whizard_commands (w_c_instance, proc_str)
  end subroutine c_whizard_process
  
  subroutine c_whizard_compile (w_c_instance) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    type(c_ptr), intent(inout) :: w_c_instance
    type(string_t) :: cmp_str
    cmp_str = "compile"
    call c_whizard_commands (w_c_instance, cmp_str)
  end subroutine c_whizard_compile
    
  subroutine c_whizard_beams (w_c_instance, c_specs) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_specs(*)
    type(string_t) :: specs, beam_str
  
    call c_whizard_convert_string (c_specs, specs)
    beam_str = "beams = " // specs
    call c_whizard_commands (w_c_instance, beam_str)
  end subroutine c_whizard_beams
  
  subroutine c_whizard_integrate (w_c_instance, c_process) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_process(*)
    type(string_t) :: process, int_str
  
    call c_whizard_convert_string (c_process, process)
    int_str = "integrate (" // process //")"
    call c_whizard_commands (w_c_instance, int_str)
  end subroutine c_whizard_integrate
  
  subroutine c_whizard_matrix_element_test &
       (w_c_instance, c_process, n_calls) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance
    integer(kind=c_int) :: n_calls
    character(kind=c_char) :: c_process(*)
    type(string_t) :: process, me_str
    character(len=8) :: buffer
  
    call c_whizard_convert_string (c_process, process)
    write (buffer, "(I0)")  n_calls
    me_str = "integrate (" // process // ") { ?phs_only = true" // &
         "  n_calls_test = " // trim (buffer) 
    call c_whizard_commands (w_c_instance, me_str)
  end subroutine c_whizard_matrix_element_test
  
  subroutine c_whizard_simulate (w_c_instance, c_id) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none
  
    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_id(*)
    type(string_t) :: sim_str, id
  
    call c_whizard_convert_string(c_id, id)
    sim_str = "simulate (" // id // ")"
    call c_whizard_commands (w_c_instance, sim_str)
  end subroutine c_whizard_simulate
  
  subroutine c_whizard_sqrts (w_c_instance, c_value, c_unit) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
  
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance
    character(kind=c_char) :: c_unit(*)
    integer(kind=c_int) :: c_value
    integer :: f_value
    character(len=8) :: f_val
    type(string_t) :: val, unit, sqrts_str
  
    f_value = c_value
    write (f_val,'(i8)') f_value
    val = f_val
    call c_whizard_convert_string (c_unit, unit)
    sqrts_str = "sqrts =" // val // unit
    call c_whizard_commands (w_c_instance, sqrts_str)
  end subroutine c_whizard_sqrts
  
@
<<Whizard-C-Interface: HepMC>>=
  type(c_ptr) function c_whizard_hepmc_test &
       (w_c_instance, c_id, c_proc_id, c_event_id) bind(C)
    use, intrinsic :: iso_c_binding
    use iso_varying_string, string_t => varying_string !NODEP!
    use commands
    use diagnostics
    use events
    use hepmc_interface
    use lexers
    use models
    use parser
    use processes
    use rt_data
    use simulations
    use whizard
    use os_interface
   
    implicit none

    type(c_ptr), intent(inout) :: w_c_instance    
    type(string_t) :: sim_str
    type(parse_tree_t) :: parse_tree
    type(parse_node_t), pointer :: pn_root
    type(stream_t), target :: stream
    type(lexer_t) :: lexer
    type(command_list_t), pointer :: cmd_list
    type(whizard_t), pointer :: whizard_instance
   
    integer :: i_evt
    type(simulation_t), target :: sim
   
    character(kind=c_char), intent(in) :: c_id(*)
    type(string_t) :: id
    integer(kind=c_int), value :: c_proc_id, c_event_id
    integer :: proc_id, event_id
  
    type(hepmc_event_t), pointer :: hepmc_event
   
    type(process_t), pointer :: process
    integer :: proc
   
    integer :: factorization_mode, try
   
    call c_f_pointer (w_c_instance, whizard_instance)        
    
    call c_whizard_convert_string (c_id, id)
    sim_str = "simulate (" // id // ")" 
  
    proc_id = c_proc_id
    event_id = c_event_id
  
    allocate (hepmc_event)
    call hepmc_event_init (hepmc_event, c_proc_id, c_event_id)
  
    call syntax_cmd_list_init ()
    call lexer_init_cmd_list (lexer)
   
    call stream_init (stream, sim_str)
    call lexer_assign_stream (lexer, stream)
    call parse_tree_init (parse_tree, syntax_cmd_list, lexer)
    pn_root => parse_tree_get_root_ptr (parse_tree)
   
    allocate (cmd_list)
    if (associated (pn_root)) then
       call cmd_list%compile (pn_root, whizard_instance%global)
    end if   
  
    call sim%init ([id], .true., .true., whizard_instance%global)

    !!! This should generate a HepMC event as hepmc_event_t type
    call msg_message ("Not enabled for the moment.")
  
    call sim%final ()

    call cmd_list%final ()
   
    call parse_tree_final (parse_tree)
    call stream_final (stream)
    call lexer_final (lexer)
    call syntax_cmd_list_final ()
  
    c_whizard_hepmc_test = c_loc(hepmc_event)
    return
  end function c_whizard_hepmc_test
@ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
